Анализ содержимого папки: C:\Users\User\Desktop\mody\metamorph-1.4\src
==================================================

--- Файл №1 ---
Путь: main\java\mchorse\metamorph\ClientProxy.java
--------------------
package mchorse.metamorph;

import mchorse.mclib.utils.OpHelper;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.client.EntityModelHandler;
import mchorse.metamorph.client.KeyboardHandler;
import mchorse.metamorph.client.NetworkHandler;
import mchorse.metamorph.client.RenderingHandler;
import mchorse.metamorph.client.gui.overlays.GuiHud;
import mchorse.metamorph.client.gui.overlays.GuiOverlay;
import mchorse.metamorph.client.gui.survival.GuiSurvivalScreen;
import mchorse.metamorph.client.render.RenderMorph;
import mchorse.metamorph.entity.EntityMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.network.NetworkPlayerInfo;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.entity.RenderPlayer;
import net.minecraft.client.renderer.entity.RenderSubPlayer;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.world.GameType;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.client.registry.RenderingRegistry;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.lang.reflect.Field;
import java.util.Map;

/**
 * Client proxy
 * 
 * Client proxy is responsible for adding some rendering modifications (i.e. 
 * HUD morph panel and player rendering) and also responsible for loading 
 * (constructing ModelCustom out of) custom models. 
 */
@SideOnly(Side.CLIENT)
public class ClientProxy extends CommonProxy
{
    /**
     * GUI overlay which is responsible for showing up acquired morphs
     */
    public static GuiOverlay morphOverlay = new GuiOverlay();

    /**
     * Cached survival screen
     */
    public static GuiSurvivalScreen survivalScreen;
    
    public static GuiHud hud = new GuiHud();

    /**
     * Keyboard handler 
     */
    public static KeyboardHandler keys;

    /**
     * Entity model handler
     */
    public static EntityModelHandler models;

    public static GuiSurvivalScreen getSurvivalScreen()
    {
        if (survivalScreen == null)
        {
            survivalScreen = new GuiSurvivalScreen();
        }

        return survivalScreen;
    }

    @Override
    public void preLoad(FMLPreInitializationEvent event)
    {
        super.preLoad(event);

        /* Register entity renderers */
        RenderingRegistry.registerEntityRenderingHandler(EntityMorph.class, new RenderMorph.MorphFactory());

        /* Registering an event channel for custom payload */
        Metamorph.channel.register(new NetworkHandler());
    }

    @Override
    public void load()
    {
        /* Continue loading process */
        super.load();

        /* Register client event handlers */
        MinecraftForge.EVENT_BUS.register(new RenderingHandler(morphOverlay, hud));
        MinecraftForge.EVENT_BUS.register(keys = new KeyboardHandler());
        MinecraftForge.EVENT_BUS.register(models = new EntityModelHandler());

        models.loadSelectors();

        if (!this.selectors.exists())
        {
            MorphUtils.generateFile(this.selectors, "[]");
        }

        if (!this.list.exists())
        {
            MorphUtils.generateFile(this.selectors, "[]");
        }
    }

    /**
     * In post load, we're going to substitute player renderers 
     */
    @Override
    public void postLoad(FMLPostInitializationEvent event)
    {
        super.postLoad(event);

        /* Rendering stuff */
        RenderManager manager = Minecraft.getMinecraft().getRenderManager();

        this.substitutePlayerRenderers(manager);
    }

    /**
     * Substitute default player renders to get the ability to render the
     * hand.
     *
     * Please, kids, don't do that at home. This was made by an expert in
     * his field, so please, don't override skinMap the way I did. Don't break
     * the compatibility with this mod (already confirmed breaking while 
     * using Metamorph and Blockbuster together).
     */
    @SuppressWarnings({"rawtypes", "unchecked"})
    private void substitutePlayerRenderers(RenderManager manager)
    {
        Map<String, net.minecraft.client.renderer.entity.RenderPlayer> skins = null;

        /* Iterate over all render manager fields and get access to skinMap */
        for (Field field : manager.getClass().getDeclaredFields())
        {
            if (field.getType().equals(Map.class))
            {
                field.setAccessible(true);

                try
                {
                    Map map = (Map) field.get(manager);

                    if (map.get("default") instanceof net.minecraft.client.renderer.entity.RenderPlayer)
                    {
                        skins = map;

                        break;
                    }
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }

        /* Replace player renderers with Blockbuster substitutes */
        if (skins != null)
        {
            RenderPlayer slim = skins.get("slim");
            RenderPlayer def = skins.get("default");

            skins.put("slim", new RenderSubPlayer(manager, slim, true));
            skins.put("default", new RenderSubPlayer(manager, def, false));

            Metamorph.log("Skin map renderers were successfully replaced with Metamorph substitutes!");
        }
    }

    /**
     * Get game mode of a player 
     */
    public static GameType getGameMode(EntityPlayer player)
    {
        NetworkPlayerInfo networkplayerinfo = Minecraft.getMinecraft().getConnection().getPlayerInfo(player.getGameProfile().getId());

        return networkplayerinfo != null ? networkplayerinfo.getGameType() : GameType.CREATIVE;
    }

    @Override
    public boolean canEditSelectors()
    {
        return OpHelper.isPlayerOp() || Metamorph.opEntitySelector.get();
    }
}

==================================================

--- Файл №2 ---
Путь: main\java\mchorse\metamorph\CommonProxy.java
--------------------
package mchorse.metamorph;

import mchorse.metamorph.api.MorphHandler;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.RegisterHandler;
import mchorse.metamorph.capabilities.CapabilityHandler;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.capabilities.morphing.MorphingStorage;
import mchorse.metamorph.capabilities.render.IModelRenderer;
import mchorse.metamorph.capabilities.render.ModelRenderer;
import mchorse.metamorph.capabilities.render.ModelRendererStorage;
import mchorse.metamorph.entity.EntityMorph;
import mchorse.metamorph.entity.SoundHandler;
import mchorse.metamorph.network.Dispatcher;
import mchorse.vanilla_pack.MetamorphFactory;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.capabilities.CapabilityManager;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.registry.EntityRegistry;

import java.io.File;

/**
 * Common proxy
 * 
 * This proxy is responsible for number of things. For registering network 
 * messages, event handlers and capabilities. It also responsible for loading 
 * models.
 */
public class CommonProxy
{
    /**
     * Location of a user's morph settings
     */
    public File morphs;

    /**
     * Location of a user's morph blacklist
     */
    public File blacklist;

    /**
     * Location of a user's morph ID remapper
     */
    public File remap;

    /**
     * Location of a user's entity selectors (client side)
     */
    public File selectors;

    /**
     * Location of a user's custom global morph list (client side)
     */
    public File list;

    public void preLoad(FMLPreInitializationEvent event)
    {
        /* Network messages */
        Dispatcher.register();

        /* Attaching morph factory to the morph manager */
        MorphManager.INSTANCE.factories.add(new MetamorphFactory());

        /* Configuration */
        this.morphs = new File(event.getModConfigurationDirectory(), "metamorph/morphs.json");
        this.blacklist = new File(event.getModConfigurationDirectory(), "metamorph/blacklist.json");
        this.remap = new File(event.getModConfigurationDirectory(), "metamorph/remap.json");
        this.selectors = new File(event.getModConfigurationDirectory(), "metamorph/selectors.json");
        this.list = new File(event.getModConfigurationDirectory(), "metamorph/list.json");

        /* Entities */
        EntityRegistry.registerModEntity(new ResourceLocation("metamorph:morph"), EntityMorph.class, "Morph", 0, Metamorph.instance, 64, 3, false);
    }

    /**
     * Load stuff
     * 
     * Add event listeners, register morphing capability and also load user 
     * configuration. I don't know how it's going to work in multiplayer, 
     * probably won't lol
     */
    public void load()
    {
        /* Event listeners */
        MinecraftForge.EVENT_BUS.register(new MorphHandler());
        MinecraftForge.EVENT_BUS.register(new SoundHandler());
        MinecraftForge.EVENT_BUS.register(new CapabilityHandler());
        MinecraftForge.EVENT_BUS.register(new RegisterHandler());

        /* Morphing manager and capabilities */
        CapabilityManager.INSTANCE.register(IMorphing.class, new MorphingStorage(), Morphing::new);
        CapabilityManager.INSTANCE.register(IModelRenderer.class, new ModelRendererStorage(), ModelRenderer::new);

        /* Register morph factories */
        MorphManager.INSTANCE.register();

        /* User configuration */
        if (!this.morphs.exists())
        {
            MorphUtils.generateFile(this.morphs, "{}");
        }

        if (!this.blacklist.exists())
        {
            MorphUtils.generateFile(this.blacklist, "[]");
        }

        if (!this.remap.exists())
        {
            MorphUtils.generateFile(this.remap, "{}");
        }
    }

    /**
     * Post load
     */
    public void postLoad(FMLPostInitializationEvent event)
    {}

    public boolean canUse(EntityPlayer player)
    {
        return player.isCreative() || Metamorph.allowMorphingIntoCategoryMorphs.get();
    }

    public boolean canEditSelectors()
    {
        return true;
    }
}

==================================================

--- Файл №3 ---
Путь: main\java\mchorse\metamorph\Metamorph.java
--------------------
package mchorse.metamorph;

import mchorse.mclib.McLib;
import mchorse.mclib.config.ConfigBuilder;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.events.RegisterConfigEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.Logger;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.commands.CommandAcquireMorph;
import mchorse.metamorph.commands.CommandMetamorph;
import mchorse.metamorph.commands.CommandMorph;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.SidedProxy;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.event.FMLServerStartingEvent;
import net.minecraftforge.fml.common.network.FMLEventChannel;
import net.minecraftforge.fml.common.network.NetworkRegistry;

/**
 * Metamorph mod
 * 
 * This mod provides functionality for survival morphing. To gain a morph 
 * you have to kill a mob. Once you killed it, you gain its morphing. Once you 
 * gained its morphing you can use special menu to select a mob into which to 
 * morph.
 * 
 * Except different shape, you gain also special abilities for specific mobs. 
 * In creative you can access all morphings.
 * 
 * Inspired by Morph and Shape Shifter Z mods (mostly due to the fact that 
 * they're outdated), however, iChun saying that he's working on Morph for 
 * 1.10.2, this is really exciting! :D
 */
@Mod(modid = Metamorph.MOD_ID, name = Metamorph.MODNAME, version = Metamorph.VERSION, updateJSON = "https://raw.githubusercontent.com/mchorse/metamorph/1.12/version.json", dependencies = "after:moreplayermodels;required-after:mclib@[%MCLIB%,)")
public class Metamorph
{
    /* Metadata fields */
    public static final String MOD_ID = "metamorph";
    public static final String MODNAME = "Metamorph";
    public static final String VERSION = "%VERSION%";

    public static final String CLIENT_PROXY = "mchorse.metamorph.ClientProxy";
    public static final String SERVER_PROXY = "mchorse.metamorph.CommonProxy";

    /* Forge stuff classes */
    @SidedProxy(clientSide = CLIENT_PROXY, serverSide = SERVER_PROXY)
    public static CommonProxy proxy;

    @Mod.Instance(MOD_ID)
    public static Metamorph instance;

    /**
     * Custom payload channel 
     */
    public static FMLEventChannel channel;

    /* Configuration */
    public static ValueBoolean opEntitySelector;

    public static ValueBoolean preventGhosts;
    public static ValueBoolean preventKillAcquire;
    public static ValueBoolean acquireImmediately;

    public static ValueBoolean keepMorphs;
    public static ValueBoolean disablePov;
    public static ValueBoolean disableHealth;
    public static ValueBoolean disableMorphAnimation;
    public static ValueBoolean disableMorphDisguise;
    public static ValueBoolean disableFirstPersonHand;
    public static ValueBoolean morphInTightSpaces;
    public static ValueBoolean showMorphIdleSounds;
    public static ValueBoolean pauseGUIInSP;
    public static ValueBoolean renderBodyPartAxis;
    public static ValueInt maxRecentMorphs;
    public static ValueBoolean allowMorphingIntoCategoryMorphs;
    public static ValueBoolean loadEntityMorphs;

    /* Events */

    @SubscribeEvent
    public void onConfigRegister(RegisterConfigEvent event)
    {
        opEntitySelector = event.opAccess.category(MOD_ID).getBoolean("entity_selectors", true);
        opEntitySelector.syncable();

        /* Metamorph configuration */
        ConfigBuilder builder = event.createBuilder(MOD_ID);

        preventGhosts = builder.category("acquiring").getBoolean("prevent_ghosts", true);
        preventKillAcquire = builder.getBoolean("prevent_kill_acquire", false);
        acquireImmediately = builder.getBoolean("acquire_immediately", false);

        keepMorphs = builder.category("morphs").getBoolean("keep_morphs", true);
        disablePov = builder.getBoolean("disable_pov", false);
        disableHealth = builder.getBoolean("disable_health", false);
        disableMorphAnimation = builder.getBoolean("disable_morph_animation", false);
        disableMorphDisguise = builder.getBoolean("disable_morph_disguise", false);
        disableFirstPersonHand = builder.getBoolean("disable_first_person_hand", false);
        disableFirstPersonHand.clientSide();
        morphInTightSpaces = builder.getBoolean("morph_in_tight_spaces", false);
        showMorphIdleSounds = builder.getBoolean("show_morph_idle_sounds", true);
        pauseGUIInSP = builder.getBoolean("pause_gui_in_sp", true);
        pauseGUIInSP.clientSide();
        renderBodyPartAxis = builder.getBoolean("render_bodypart_axis", true);
        renderBodyPartAxis.clientSide();
        maxRecentMorphs = builder.getInt("max_recent_morphs", 20, 1, 200);
        maxRecentMorphs.clientSide();
        allowMorphingIntoCategoryMorphs = builder.getBoolean("allow_morphing_into_category_morphs", false);
        loadEntityMorphs = builder.getBoolean("load_entity_morphs", true);
        loadEntityMorphs.clientSide();
    }

    @EventHandler
    public void preLoad(FMLPreInitializationEvent event)
    {
        LOGGER = event.getModLog();
        channel = NetworkRegistry.INSTANCE.newEventDrivenChannel("Metamorph");
        McLib.EVENT_BUS.register(this);

        proxy.preLoad(event);
    }

    @EventHandler
    public void load(FMLInitializationEvent event)
    {
        proxy.load();
    }

    @EventHandler
    public void postLoad(FMLPostInitializationEvent event)
    {
        proxy.postLoad(event);
    }

    @EventHandler
    public void serverStarting(FMLServerStartingEvent event)
    {
        /* Setting up the blacklist */
        MorphManager.INSTANCE.setActiveBlacklist(null, MorphUtils.reloadBlacklist());
        MorphManager.INSTANCE.setActiveSettings(MorphUtils.reloadMorphSettings());
        MorphManager.INSTANCE.setActiveMap(MorphUtils.reloadRemapper());

        /* Register commands */
        event.registerServerCommand(new CommandMorph());
        event.registerServerCommand(new CommandAcquireMorph());
        event.registerServerCommand(new CommandMetamorph());
    }

    /* Logging */

    /* TODO: Set to false when publishing and remove all unnecessary printlns */
    public static boolean DEBUG = false;
    public static Logger LOGGER;

    /**
     * Log out the message if in DEBUG mode.
     * 
     * But I always forget to turn it off before releasing the mod.
     */
    public static void log(String message)
    {
        if (DEBUG)
        {
            LOGGER.log(Level.INFO, message);
        }
    }
}

==================================================

--- Файл №4 ---
Путь: main\java\mchorse\metamorph\api\EntityUtils.java
--------------------
package mchorse.metamorph.api;

import java.util.List;

import javax.annotation.Nullable;

import com.google.common.base.Predicate;
import com.google.common.collect.Lists;

import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.MorphingProvider;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;

/**
 * Entity utilities methods
 * 
 * Methods that are related to {@link EntityMorph} are going here.
 */
public class EntityUtils
{
    /**
     * List of attributes to remove
     */
    private static List<String> removeAttributes = Lists.newArrayList("generic.followRange");

    /**
     * Strip some common {@link Entity} related tags, so there won't be 
     * interference with comparing two tags on  
     */
    public static NBTTagCompound stripEntityNBT(NBTTagCompound tag)
    {
        /* Meta stuff */
        tag.removeTag("Dimension");
        tag.removeTag("HurtTime");
        tag.removeTag("DeathTime");
        tag.removeTag("HurtByTimestamp");
        tag.removeTag("Health");
        tag.removeTag("PortalCooldown");
        tag.removeTag("Leashed");
        tag.removeTag("Air");
        tag.removeTag("id");
        tag.removeTag("Invulnerable");

        /* Inventory and equipment */
        tag.removeTag("ArmorDropChances");
        tag.removeTag("HandDropChances");
        tag.removeTag("HandItems");
        tag.removeTag("Inventory");
        tag.removeTag("LeftHanded");
        tag.removeTag("CanPickUpLoot");

        /* Space data */
        tag.removeTag("Pos");
        tag.removeTag("Motion");
        tag.removeTag("Rotation");
        tag.removeTag("FallDistance");
        tag.removeTag("FallFlying");
        tag.removeTag("OnGround");
        tag.removeTag("Fire");
        tag.removeTag("ArmorItems");

        /* UUID */
        tag.removeTag("UUIDLeast");
        tag.removeTag("UUIDMost");

        /* Attributes */
        tag.removeTag("Attributes");

        /* Shulker tags stripping */
        tag.removeTag("Peek");
        tag.removeTag("AttachFace");
        tag.removeTag("APX");
        tag.removeTag("APY");
        tag.removeTag("APZ");

        /* Zombie pigmen stripping */
        tag.removeTag("Anger");
        tag.removeTag("HurtBy");
        
        /* Chicken de-egging */
        tag.removeTag("EggLayTime");

        return tag;
    }

    /**
     * Compare two {@link NBTTagCompound}s for morphing acquiring
     */
    public static boolean compareData(NBTTagCompound a, NBTTagCompound b)
    {
        /* Different count of tags? They're different */
        if (a.getSize() != b.getSize())
        {
            return false;
        }

        for (String key : a.getKeySet())
        {
            NBTBase aTag = a.getTag(key);
            NBTBase bTag = b.getTag(key);

            /* Supporting condition for size check above, in case if the size 
             * the same, but different keys are missing */
            if (bTag == null)
            {
                return false;
            }

            /* We check only strings and primitives, lists and compounds aren't 
             * concern of mine */
            if (!(aTag instanceof NBTPrimitive) && !(aTag instanceof NBTTagString))
            {
                continue;
            }

            if (!aTag.equals(bTag))
            {
                return false;
            }
        }

        return true;
    }

    /**
     * Get slot for given index of {@link Entity#getEquipmentAndArmor()}. I 
     * assume that it would be the same all the time, across all of the 
     * subclasses of {@link Entity}.
     */
    public static EntityEquipmentSlot slotForIndex(int index)
    {
        EntityEquipmentSlot slot = EntityEquipmentSlot.MAINHAND;

        switch (index)
        {
            case 1:
                slot = EntityEquipmentSlot.OFFHAND;
            break;
            case 2:
                slot = EntityEquipmentSlot.FEET;
            break;
            case 3:
                slot = EntityEquipmentSlot.LEGS;
            break;
            case 4:
                slot = EntityEquipmentSlot.CHEST;
            break;
            case 5:
                slot = EntityEquipmentSlot.HEAD;
            break;
        }

        return slot;
    }

    /**
     * Get morph from an entity 
     */
    public static AbstractMorph getMorph(EntityLivingBase entity)
    {
        if (entity instanceof IMorphProvider)
        {
            return ((IMorphProvider) entity).getMorph();
        }
        else
        {
            IMorphing cap = entity.getCapability(MorphingProvider.MORPHING_CAP, null);

            if (cap != null)
            {
                return cap.getCurrentMorph();
            }
        }

        return null;
    }

    /**
     * Get string pose for entity based on its attributes or based on given 
     * custom pose
     */
    public static String getPose(EntityLivingBase entity, String custom, boolean sneak)
    {
        boolean empty = custom.isEmpty();

        if (!empty && !sneak)
        {
            return custom;
        }

        if (entity.isElytraFlying())
        {
            return "flying";
        }
        else if (entity.isRiding())
        {
            return "riding";
        }
        else if (entity.isSneaking())
        {
            return sneak && !empty ? custom : "sneaking";
        }

        return "standing";
    }

    /**
     * Get the entity at which given player is looking at.
     * Taken from EntityRenderer class.
     *
     * That's a big method... Why Minecraft has lots of these big methods?
     */
    public static Entity getTargetEntity(Entity input, double maxReach)
    {
        double blockDistance = maxReach;

        RayTraceResult result = rayTrace(input, maxReach, 1.0F);
        Vec3d eyes = new Vec3d(input.posX, input.posY + input.getEyeHeight(), input.posZ);

        if (result != null)
        {
            blockDistance = result.hitVec.distanceTo(eyes);
        }

        Vec3d look = input.getLook(1.0F);
        Vec3d max = eyes.addVector(look.x * maxReach, look.y * maxReach, look.z * maxReach);
        Entity target = null;

        float area = 1.0F;

        List<Entity> list = input.world.getEntitiesInAABBexcluding(input, input.getEntityBoundingBox().expand(look.x * maxReach, look.y * maxReach, look.z * maxReach).grow(area, area, area), new Predicate<Entity>()
        {
            @Override
            public boolean apply(@Nullable Entity entity)
            {
                return entity != null && entity.canBeCollidedWith();
            }
        });

        double entityDistance = blockDistance;

        for (int i = 0; i < list.size(); ++i)
        {
            Entity entity = list.get(i);

            if (entity == input)
            {
                continue;
            }

            AxisAlignedBB aabb = entity.getEntityBoundingBox().grow(entity.getCollisionBorderSize());
            RayTraceResult intercept = aabb.calculateIntercept(eyes, max);

            if (aabb.contains(eyes))
            {
                if (entityDistance >= 0.0D)
                {
                    target = entity;
                    entityDistance = 0.0D;
                }
            }
            else if (intercept != null)
            {
                double eyesDistance = eyes.distanceTo(intercept.hitVec);

                if (eyesDistance < entityDistance || entityDistance == 0.0D)
                {
                    if (entity.getLowestRidingEntity() == input.getLowestRidingEntity() && !input.canRiderInteract())
                    {
                        if (entityDistance == 0.0D)
                        {
                            target = entity;
                        }
                    }
                    else
                    {
                        target = entity;
                        entityDistance = eyesDistance;
                    }
                }
            }
        }

        return target;
    }

    /**
     * This method is extracted from {@link Entity} class, because it was marked
     * as client side only code.
     */
    public static RayTraceResult rayTrace(Entity input, double blockReachDistance, float partialTicks)
    {
        Vec3d eyePos = new Vec3d(input.posX, input.posY + input.getEyeHeight(), input.posZ);
        Vec3d eyeDir = input.getLook(partialTicks);
        Vec3d eyeReach = eyePos.addVector(eyeDir.x * blockReachDistance, eyeDir.y * blockReachDistance, eyeDir.z * blockReachDistance);

        return input.world.rayTraceBlocks(eyePos, eyeReach, false, false, true);
    }

    public static void forceUpdateSize(EntityPlayer player, AbstractMorph morph)
    {
        if (morph != null)
        {
            morph.updateSize(player, morph.getWidth(player), morph.getHeight(player));
        }
        else
        {
            float width;
            float height;
            if (player.isElytraFlying())
            {
                width = 0.6F;
                height = 0.6F;
            }
            else if (player.isPlayerSleeping())
            {
                width = 0.2F;
                height = 0.2F;
            }
            else if (player.isSneaking())
            {
                width = 0.6F;
                height = 1.65F;
            }
            else
            {
                width = 0.6F;
                height = 1.8F;
            }

            AbstractMorph.updateSizeDefault(player, width, height);
        }
    }

    public static boolean canPlayerMorphFit(EntityPlayer player, AbstractMorph currentMorph, AbstractMorph newMorph)
    {
        boolean canFit;

        forceUpdateSize(player, newMorph);
        canFit = player.world.getCollisionBoxes(player, player.getEntityBoundingBox()).isEmpty();
        forceUpdateSize(player, currentMorph);

        return canFit;
    }
}

==================================================

--- Файл №5 ---
Путь: main\java\mchorse\metamorph\api\IMorphFactory.java
--------------------
package mchorse.metamorph.api;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * Morph factory
 * 
 * This factory interface will be responsible for providing different resources 
 * related to morphs like custom models, abilities, attacks or actions.
 */
public interface IMorphFactory
{
    /**
     * Register here everything that is required by morph manager system
     */
    public void register(MorphManager manager);

    /**
     * Register morph editors which will be available in the creative 
     * morphs for editing 
     */
    @SideOnly(Side.CLIENT)
    public void registerMorphEditors(Minecraft mc, List<GuiAbstractMorph> editors);

    /**
     * Does this factory has morph by given name? 
     */
    public boolean hasMorph(String name);

    /**
     * Get a morph from NBT
     */
    public AbstractMorph getMorphFromNBT(NBTTagCompound tag);
}

==================================================

--- Файл №6 ---
Путь: main\java\mchorse\metamorph\api\Morph.java
--------------------
package mchorse.metamorph.api;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.nbt.NBTTagCompound;

import java.util.Objects;

/**
 * Morph container 
 * 
 * This class is responsible for holding a morph, beside that it's also 
 * provides additional methods for cloning and other shit. It should be 
 * straightforward 
 */
public class Morph
{
    protected AbstractMorph morph;

    public Morph()
    {}

    public Morph(AbstractMorph morph)
    {
        this.morph = morph;
    }

    public boolean isEmpty()
    {
        return this.morph == null;
    }

    public boolean set(AbstractMorph morph)
    {
        if (this.morph == null || !this.morph.canMerge(morph))
        {
            if (this.morph != null && morph != null)
            {
                morph.afterMerge(this.morph);
            }

            this.morph = morph;

            return true;
        }

        return false;
    }

    public void setDirect(AbstractMorph morph)
    {
        this.morph = morph;
    }

    public AbstractMorph get()
    {
        return this.morph;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Morph)
        {
            return Objects.equals(this.morph, ((Morph) obj).morph);
        }

        return super.equals(obj);
    }

    public AbstractMorph copy()
    {
        return MorphUtils.copy(this.morph);
    }

    public void copy(Morph morph)
    {
        this.set(morph.copy());
    }

    public void fromNBT(NBTTagCompound tag)
    {
        this.morph = MorphManager.INSTANCE.morphFromNBT(tag);
    }

    public NBTTagCompound toNBT()
    {
        return MorphUtils.toNBT(this.morph);
    }
}

==================================================

--- Файл №7 ---
Путь: main\java\mchorse\metamorph\api\MorphAPI.java
--------------------
package mchorse.metamorph.api;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.events.AcquireMorphEvent;
import mchorse.metamorph.api.events.MorphEvent;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import mchorse.metamorph.network.common.creative.PacketMorph;
import mchorse.metamorph.network.common.survival.PacketMorphPlayer;
import mchorse.metamorph.network.common.survival.PacketMorphState;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraftforge.common.MinecraftForge;

/**
 * Morph API class
 * 
 * This class provides public API for morphing the player. Let me know which 
 * methods I may add to simplify your life :D
 * 
 * Acquired morphs and favorites are sent only to the owner players. So you 
 * can't access this information from the client side. However, you can hit me 
 * up, and prove me why I should send that information to the other players :D
 * 
 * Use this API on the server side, please. Thanks!
 */
public class MorphAPI
{
    /**
     * Demorph given player 
     */
    public static boolean demorph(EntityPlayer player)
    {
        return morph(player, null, false);
    }

    /**
     * Morph a player into given morph with given force flag. 
     * 
     * @return true, if player was morphed successfully
     */
    public static boolean morph(EntityPlayer player, AbstractMorph morph, boolean force)
    {
        IMorphing morphing = Morphing.get(player);

        if (morphing == null)
        {
            return false;
        }

        if (!force && !player.noClip && !Metamorph.morphInTightSpaces.get() && !EntityUtils.canPlayerMorphFit(player, morphing.getCurrentMorph(), morph))
        {
            if (!player.world.isRemote)
            {
                player.sendStatusMessage(new TextComponentTranslation("metamorph.gui.status.tight_space"), true);
            }

            return false;
        }

        MorphEvent.Pre event = new MorphEvent.Pre(player, morph, force);

        if (MinecraftForge.EVENT_BUS.post(event))
        {
            return false;
        }

        boolean morphed = morphing.setCurrentMorph(event.morph, player, event.force);

        if (!player.world.isRemote && morphed)
        {
            Dispatcher.sendTo(new PacketMorph(morph), (EntityPlayerMP) player);
            Dispatcher.sendToTracked(player, new PacketMorphPlayer(player.getEntityId(), morph));
            Dispatcher.sendTo(new PacketMorphState(player, morphing), (EntityPlayerMP) player);
        }

        if (morphed)
        {
            MinecraftForge.EVENT_BUS.post(new MorphEvent.Post(player, event.morph, force));
        }

        return morphed;
    }

    public static boolean acquire(EntityPlayer player, AbstractMorph morph)
    {
        return acquire(player, morph, true);
    }

    /**
     * Make given player acquire a given morph. Usable on both sides, but it's 
     * better to use it on the server.
     * 
     * @return true, if player has acquired a morph
     */
    public static boolean acquire(EntityPlayer player, AbstractMorph morph, boolean notify)
    {
        if (morph == null)
        {
            return false;
        }

        AcquireMorphEvent.Pre event = new AcquireMorphEvent.Pre(player, morph);

        if (MinecraftForge.EVENT_BUS.post(event))
        {
            return false;
        }

        boolean acquired = Morphing.get(player).acquireMorph(event.morph);

        if (notify && !player.world.isRemote && acquired)
        {
            Dispatcher.sendTo(new PacketAcquireMorph(event.morph), (EntityPlayerMP) player);
        }

        if (acquired)
        {
            MinecraftForge.EVENT_BUS.post(new AcquireMorphEvent.Post(player, event.morph));
        }

        return acquired;
    }
}

==================================================

--- Файл №8 ---
Путь: main\java\mchorse\metamorph\api\MorphHandler.java
--------------------
package mchorse.metamorph.api;

import mchorse.metamorph.ClientProxy;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.events.SpawnGhostEvent;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.entity.EntityMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EntityDamageSourceIndirect;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.util.FakePlayer;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.event.entity.living.LivingDeathEvent;
import net.minecraftforge.event.entity.living.LivingSetAttackTargetEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerChangedDimensionEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.Phase;
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent;

import java.util.ArrayList;
import java.util.List;

/**
 * Server event handler
 * 
 * This event handler (or rather listener) is responsible for morphings. In 
 * essence, there are few things going on over here:
 * 
 * 1. Update morphs in the player's loop
 * 2. Acquiring morphs from killed entities
 * 3. Grant additional attack effect while morphed (more damage, explosions, 
 *    potion effects, etc.)
 * 4. Cancel attack targeting for hostile morphs 
 */
public class MorphHandler
{
    /* Next tick tasks (used for "knockback" attack) */
    public static List<Runnable> FUTURE_TASKS_CLIENT = new ArrayList<Runnable>();
    public static List<Runnable> FUTURE_TASKS_SERVER = new ArrayList<Runnable>();

    /**
     * When player is morphed, its morphing abilities are executed over here.
     * 
     * Stuff like gliding, allergies, climbing, swiming and other stuff are 
     * get applied on the player over here.
     */
    @SubscribeEvent
    public void onPlayerTick(PlayerTickEvent event)
    {
        if (event.phase == Phase.START)
        {
            return;
        }

        EntityPlayer player = event.player;
        IMorphing capability = Morphing.get(player);

        this.runFutureTasks(player);

        // A sanity check to prevent "healing" health when morphing to and from
        // a mob
        // with essentially zero health
        // We have to do it every tick because you never know when another mod
        // could
        // change the max health
        if (capability != null)
        {
            // If the current health ratio makes sense, store that ratio in the
            // capability
            float maxHealth = player.getMaxHealth();

            if (maxHealth > IMorphing.REASONABLE_HEALTH_VALUE)
            {
                float healthRatio = player.getHealth() / maxHealth;
                capability.setLastHealthRatio(healthRatio);
            }
        }

        if (capability == null || !capability.isMorphed())
        {
            /* Restore default eye height */
            if (!Metamorph.disablePov.get())
            {
                player.eyeHeight = player.getDefaultEyeHeight();
            }
        }

        /* Keep client gui state up-to-date for morphs with the
         * Swim ability.
         */
        if (player.world.isRemote)
        {
            boolean hasSquidAir = false;
            int squidAir = 300;

            if (capability != null)
            {
                hasSquidAir = capability.getHasSquidAir();
                squidAir = capability.getSquidAir();
            }

            ClientProxy.hud.renderSquidAir = hasSquidAir;
            ClientProxy.hud.squidAir = squidAir;
        }

        try
        {
            capability.update(player);
        }
        catch (Exception e)
        {
            e.printStackTrace();

            if (!player.world.isRemote)
            {
                MorphAPI.demorph(player);
            }
        }
    }

    /**
     * When a player kills an entity, he gains a morph based on the properties 
     * of this entity.
     * 
     * I think I need to implement some mechanism or a callback to map some 
     * entities with the same name onto different morphs. 
     */
    @SubscribeEvent
    public void onPlayerKillEntity(LivingDeathEvent event)
    {
        Entity source = event.getSource().getTrueSource();
        Entity target = event.getEntity();

        if (target.world.isRemote || source instanceof FakePlayer)
        {
            return;
        }

        if (!(source instanceof EntityPlayer) || target instanceof EntityPlayer || Metamorph.preventKillAcquire.get())
        {
            return;
        }

        EntityPlayer player = (EntityPlayer) source;
        IMorphing capability = Morphing.get(player);

        if (capability == null)
        {
            return;
        }

        String name = MorphManager.INSTANCE.morphNameFromEntity(target);

        if (!MorphManager.INSTANCE.hasMorph(name))
        {
            Metamorph.log("Morph by key '" + name + "' doesn't exist!");

            return;
        }

        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Name", name);
        tag.setTag("EntityData", EntityUtils.stripEntityNBT(target.serializeNBT()));

        AbstractMorph morph = MorphManager.INSTANCE.morphFromNBT(tag);
        boolean acquired = capability.acquiredMorph(morph);

        if (Metamorph.acquireImmediately.get() && !acquired)
        {
            MorphAPI.acquire(player, morph);

            return;
        }

        if (!Metamorph.preventGhosts.get() || !acquired)
        {
            SpawnGhostEvent spawnGhostEvent = new SpawnGhostEvent.Pre(player, morph);

            if (MinecraftForge.EVENT_BUS.post(spawnGhostEvent) || spawnGhostEvent.morph == null)
            {
                return;
            }
            morph = spawnGhostEvent.morph;

            EntityMorph morphEntity = new EntityMorph(player.world, player.getUniqueID(), morph);

            morphEntity.setPositionAndRotation(target.posX, target.posY + target.height / 2, target.posZ, target.rotationYaw, target.rotationPitch);
            player.world.spawnEntity(morphEntity);

            MinecraftForge.EVENT_BUS.post(new SpawnGhostEvent.Post(player, morph));
        }
    }
    
    /**
     * When an EntityMorph is updated, the entity may attempt to hurt the player.
     * This should not be allowed.
     */
    @SubscribeEvent
    public void onMorphAttackPlayer(LivingAttackEvent event)
    {
        Entity target = event.getEntity();
        
        if (target instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer)target;
            IMorphing capability = Morphing.get(player);
            
            if (capability == null || !capability.isMorphed())
            {
                return;
            }
            
            AbstractMorph morph = capability.getCurrentMorph();
            
            if (morph == null || !(morph instanceof mchorse.metamorph.api.morphs.EntityMorph))
            {
                return;
            }
            
            mchorse.metamorph.api.morphs.EntityMorph entityMorph = (mchorse.metamorph.api.morphs.EntityMorph)morph;
            
            if (entityMorph.isUpdatingEntity())
            {
                // Unfortunately, entities sometimes do damage to the player without telling the player where the damage came from
                // Luckily, entities are ticked in sequence, so we know for certain the player's morph entity is responsible for this
                event.setCanceled(true);
            }
        }
    }

    /**
     * When player is morphed, he can deal an damage or effect onto the enemy. 
     * 
     * For example, if player is morphed into the wither skeleton, he also 
     * grants a target wither potion effect. Pretty realistic, however I don't 
     * really know what that does. 
     */
    @SubscribeEvent
    public void onPlayerAttack(LivingAttackEvent event)
    {
        DamageSource source = event.getSource();
        Entity trueSource = source.getTrueSource();
        Entity target = event.getEntity();

        if(source instanceof EntityDamageSourceIndirect)
        {
            return;
        }
        
        if (trueSource instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) trueSource;
            IMorphing capability = Morphing.get(player);

            if (capability == null || !capability.isMorphed())
            {
                return;
            }

            capability.getCurrentMorph().attack(target, player);
        }
    }

    /**
     * Another morphing handler.
     * 
     * This handler is responsible for canceling setting attack target for 
     * hostile morphs.  Also handles any instance where the morph entity
     * is targeted instead of the player, and shifts the targetting onto
     * the player.
     */
    @SubscribeEvent
    public void onLivingSetAttackTarget(LivingSetAttackTargetEvent event)
    {
        if (Metamorph.disableMorphDisguise.get())
        {
            return;
        }

        Entity target = event.getTarget();
        EntityLivingBase source = event.getEntityLiving();

        if (target instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) target;
            IMorphing morphing = Morphing.get(player);

            if (morphing == null || !morphing.isMorphed())
            {
                return;
            }
            
            AbstractMorph currentMorph = morphing.getCurrentMorph();

            if (morphing.getCurrentMorph().getSettings().hostile && source.getAttackingEntity() != target && 
            !(currentMorph instanceof mchorse.metamorph.api.morphs.EntityMorph && ((mchorse.metamorph.api.morphs.EntityMorph) currentMorph).getEntity() == source.getAttackingEntity()))
            {
                if (source instanceof EntityLiving)
                {
                    ((EntityLiving) event.getEntity()).setAttackTarget(null);
                }
            }
        }
        else if(target != null)
        {
            List playerList = target.world.getEntitiesWithinAABB(EntityPlayer.class, new AxisAlignedBB(target.posX-1,target.posY-1,target.posZ-1,target.posX+1,target.posY+1,target.posZ+1));
            for(int i = 0; i < playerList.size(); i++)
            {
                Object o = playerList.get(i);
                if(o instanceof EntityPlayer)
                {
                    EntityPlayer player = (EntityPlayer) o;
                    IMorphing capability = Morphing.get(player);
                    if(capability == null)
                        continue;
                    AbstractMorph currentMorph = capability.getCurrentMorph();
                    if(currentMorph == null)
                        continue;
                    if (currentMorph instanceof mchorse.metamorph.api.morphs.EntityMorph)
                    {
                        mchorse.metamorph.api.morphs.EntityMorph currentEntityMorph = (mchorse.metamorph.api.morphs.EntityMorph) currentMorph;
                        if(currentEntityMorph.getEntity() == target && source instanceof EntityLiving)
                            ((EntityLiving) event.getEntity()).setAttackTarget(player);
                    }
                }
            }
        }
    }

    /**
     * Make sure the player dimension and morph dimension are synced
     */
    @SubscribeEvent
    public void onPlayerChangeDimension(PlayerChangedDimensionEvent event)
    {
        IMorphing capability = Morphing.get(event.player);

        if (capability != null && capability.getCurrentMorph() != null)
        {
            capability.getCurrentMorph().onChangeDimension(event.player, event.fromDim, event.toDim);
        }
    }

    /**
     * Run future tasks on both client and server. 
     */
    private void runFutureTasks(EntityPlayer player)
    {
        if (player.world.isRemote && !FUTURE_TASKS_CLIENT.isEmpty())
        {
            FUTURE_TASKS_CLIENT.remove(0).run();
        }

        if (!player.world.isRemote && !FUTURE_TASKS_SERVER.isEmpty())
        {
            FUTURE_TASKS_SERVER.remove(0).run();
        }
    }
}


==================================================

--- Файл №9 ---
Путь: main\java\mchorse\metamorph\api\MorphManager.java
--------------------
package mchorse.metamorph.api;

import mchorse.metamorph.api.abilities.IAbility;
import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.abilities.IAttackAbility;
import mchorse.metamorph.api.creative.MorphList;
import mchorse.metamorph.api.creative.sections.UserSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.vanilla_pack.MetamorphSection;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityList;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

/**
 * Morph manager class
 * 
 * This manager is responsible for managing available morphings.
 */
public class MorphManager
{
    /**
     * Default <s>football</s> morph manager
     */
    public static final MorphManager INSTANCE = new MorphManager();

    /**
     * Registered abilities 
     */
    public Map<String, IAbility> abilities = new HashMap<String, IAbility>();

    /**
     * Registered actions 
     */
    public Map<String, IAction> actions = new HashMap<String, IAction>();

    /**
     * Registered attacks 
     */
    public Map<String, IAttackAbility> attacks = new HashMap<String, IAttackAbility>();

    /**
     * Registered morph factories
     */
    public List<IMorphFactory> factories = new ArrayList<IMorphFactory>();

    /**
     * Active morph settings from JSON config
     */
    public Map<String, MorphSettings> activeSettings = new HashMap<String, MorphSettings>();

    /**
     * Active blacklist. Sent either from server, or getting assigned on 
     * server start. Modifying this is a not a good idea 
     */
    public Set<String> activeBlacklist = new TreeSet<String>();

    /**
     * Active morph ID remapper
     */
    public Map<String, String> activeMap = new HashMap<String, String>();

    /**
     * Global morph list
     */
    public final MorphList list = new MorphList();

    /**
     * Check whether morph by the given name is blacklisted 
     */
    public static boolean isBlacklisted(String name)
    {
        return INSTANCE.activeBlacklist.contains(name);
    }

    /**
     * Set currently used morph ID blacklist
     */
    public void setActiveBlacklist(World world, Set<String> blacklist)
    {
        this.activeBlacklist.clear();
        this.activeBlacklist.addAll(blacklist);

        MetamorphSection section = this.list.getSection(MetamorphSection.class);

        if (section != null && world != null)
        {
            section.reset();
            section.update(world);
        }
    }

    /**
     * Set currently used morph settings
     */
    public void setActiveSettings(Map<String, MorphSettings> settings)
    {
        Map<String, MorphSettings> newSettings = new HashMap<String, MorphSettings>();

        for (Map.Entry<String, MorphSettings> entry : settings.entrySet())
        {
            String key = entry.getKey();
            MorphSettings setting = this.activeSettings.get(key);

            if (setting == null)
            {
                setting = entry.getValue();
            }
            else
            {
                setting.copy(entry.getValue());
            }

            newSettings.put(key, setting);
        }

        this.activeSettings = newSettings;
    }

    /**
     * Set current morph ID remapper
     */
    public void setActiveMap(Map<String, String> map)
    {
        this.activeMap.clear();
        this.activeMap.putAll(map);
    }

    /**
     * That's a singleton, boy!
     */
    private MorphManager()
    {}

    /**
     * Register all morph factories 
     */
    public void register()
    {
        this.list.register(new UserSection("user"));

        for (int i = this.factories.size() - 1; i >= 0; i--)
        {
            this.factories.get(i).register(this);
        }
    }

    /**
     * Register morph editors 
     */
    @SideOnly(Side.CLIENT)
    public void registerMorphEditors(Minecraft mc, List<GuiAbstractMorph> editors)
    {
        for (int i = this.factories.size() - 1; i >= 0; i--)
        {
            this.factories.get(i).registerMorphEditors(mc, editors);
        }
    }

    /**
     * Checks if manager has given morph by ID and NBT tag compound
     * 
     * This meethod iterates over all {@link IMorphFactory}s and if any of them 
     * returns true, then there's a morph, otherwise false.
     */
    public boolean hasMorph(String name)
    {
        name = this.remap(name);

        if (isBlacklisted(name))
        {
            return false;
        }

        for (int i = this.factories.size() - 1; i >= 0; i--)
        {
            if (this.factories.get(i).hasMorph(name))
            {
                return true;
            }
        }

        return false;
    }

    /**
     * Get an abstract morph from NBT
     * 
     * This method iterates over all {@link IMorphFactory}s, returns a morph 
     * from the first morph factory that does have a morph.
     */
    public AbstractMorph morphFromNBT(NBTTagCompound tag)
    {
        if (tag == null)
        {
            return null;
        }

        if (tag.hasKey("Name"))
        {
            tag.setString("Name", this.remap(tag.getString("Name")));
        }

        String name = tag.getString("Name");

        if (isBlacklisted(name))
        {
            return null;
        }

        for (int i = this.factories.size() - 1; i >= 0; i--)
        {
            if (this.factories.get(i).hasMorph(name))
            {
                AbstractMorph morph = this.factories.get(i).getMorphFromNBT(tag);
                
                if (morph != null)
                {
                    this.applySettings(morph);
                    
                    return morph;
                }
            }
        }

        return null;
    }

    /**
     * Apply morph settings on a given morph 
     */
    public void applySettings(AbstractMorph morph)
    {
        morph.setActiveSettings(this.activeSettings.get(morph.name));
    }

    /**
     * Get morph from the entity
     * 
     * Here I should add some kind of mechanism that allows people to substitute 
     * the name of the morph based on the given entity (in the future with 
     * introduction of the public API).
     */
    public String morphNameFromEntity(Entity entity)
    {
        return EntityList.getKey(entity).toString();
    }

    /**
     * Remap morph name
     */
    public String remap(String name)
    {
        String remapped = this.activeMap.get(name);

        return remapped == null ? name : remapped;
    }
}

==================================================

--- Файл №10 ---
Путь: main\java\mchorse\metamorph\api\MorphSettings.java
--------------------
package mchorse.metamorph.api;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.abilities.IAbility;
import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.abilities.IAttackAbility;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.nbt.NBTTagString;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * Morph settings
 * 
 * An instance of this class is responsible for storing information about 
 * morph's configurable settings.
 * 
 * For well-defined defaults, use {@link #DEFAULT_MORPHED} or {@link #DEFAULT}.
 */
public class MorphSettings
{
    /**
     * "Safe" settings, equivalent to not being morphed
     */
    public static final MorphSettings DEFAULT = new MorphSettings();
    
    static
    {
        DEFAULT.hostile = false;
        DEFAULT.hands = true;
        DEFAULT.updates = false;
    }

    /**
     * Default settings to fall back on for most morphs.
     */
    public static final MorphSettings DEFAULT_MORPHED = new MorphSettings();

    /**
     * Abilities that are going to be applied on a morph 
     */
    public List<IAbility> abilities = new ArrayList<IAbility>();
    public boolean hasAbilities = true;

    /**
     * Attack that is going to be used on a morph
     */
    public IAttackAbility attack = null;
    public boolean hasAttack = true;

    /**
     * Action that is going to be used on a morph
     */
    public IAction action = null;
    public boolean hasAction = true;

    /**
     * Health units which are going to be applied
     */
    public int health = 20;
    public boolean hasHealth = true;

    /**
     * Speed which is going to be applied 
     */
    public float speed = 0.1F;
    public boolean hasSpeed = true;

    /**
     * Hostile flag which is going to be applied
     */
    public boolean hostile = true;
    public boolean hasHostile = true;

    /**
     * Does client tries render hands for this morph 
     */
    public boolean hands = false;
    public boolean hasHands = true;

    /**
     * Does this morph updates itself 
     */
    public boolean updates = true;
    public boolean hasUpdates = true;

    /**
     * Whether to render this morph in shadow pass
     */
    public int shadowOption = 0;
    public boolean hasShadowOption = true;
    public boolean betterLightsShadow = true;
    public boolean hasbetterLightsShadow = true;
    
    /**
     * Morph settings applier lambda
     */
    public static interface Edit
    {
    	void apply(MorphSettings settings);
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof MorphSettings)
        {
            MorphSettings settings = (MorphSettings) obj;

            return (this.hasAbilities == settings.hasAbilities && (this.abilities.equals(settings.abilities) || this.hasAbilities == false)) &&
                (this.hasAction == settings.hasAction && (Objects.equals(this.action, settings.action) || this.hasAction == false)) &&
                (this.hasAttack == settings.hasAttack && (Objects.equals(this.attack, settings.attack) || this.hasAttack == false)) &&
                (this.hasHealth == settings.hasHealth && (this.health == settings.health || this.hasHealth == false)) &&
                (this.hasSpeed == settings.hasSpeed && (this.speed == settings.speed || this.hasSpeed == false)) &&
                (this.hasHostile == settings.hasHostile && (this.hostile == settings.hostile || this.hasHostile == false)) &&
                (this.hasUpdates == settings.hasUpdates && (this.updates == settings.updates || this.hasUpdates == false)) &&
                (this.hasShadowOption == settings.hasShadowOption && (this.shadowOption == settings.shadowOption || this.hasShadowOption == false) &&
                (this.hasbetterLightsShadow == settings.hasbetterLightsShadow && (this.betterLightsShadow == settings.betterLightsShadow || this.hasbetterLightsShadow == false)));
        }

        return super.equals(obj);
    }

    public MorphSettings copy()
    {
        MorphSettings settings = new MorphSettings();

        settings.copy(this);

        return settings;
    }

    /**
     * Merge given morph settings with this settings
     */
    public void copy(MorphSettings setting)
    {
        this.abilities.clear();
        this.abilities.addAll(setting.abilities);
        this.hasAbilities = setting.hasAbilities;

        this.action = setting.action;
        this.hasAction = setting.hasAction;
        this.attack = setting.attack;
        this.hasAttack = setting.hasAttack;

        this.health = setting.health;
        this.hasHealth = setting.hasHealth;
        this.speed = setting.speed;
        this.hasSpeed = setting.hasSpeed;
        this.hostile = setting.hostile;
        this.hasHostile = setting.hasHostile;
        this.hands = setting.hands;
        this.hasHands = setting.hasHands;
        this.updates = setting.updates;
        this.hasUpdates = setting.hasUpdates;
        
		this.shadowOption = setting.shadowOption;
		this.hasShadowOption = setting.hasShadowOption;

        this.betterLightsShadow = setting.betterLightsShadow;
        this.hasbetterLightsShadow = setting.hasbetterLightsShadow;
    }

    /**
     * Apply any additional settings to this one as long as they are not null/empty
     */
    public void applyOverrides(MorphSettings setting)
    {
        if (setting.hasAbilities)
        {
            this.abilities.clear();
            this.abilities.addAll(setting.abilities);
            this.hasAbilities = true;
        }

        if (setting.hasAction)
        {
            this.action = setting.action;
            this.hasAction = true;
        }

        if (setting.hasAttack)
        {
            this.attack = setting.attack;
            this.hasAttack = true;
        }

        if (setting.hasHealth)
        {
            this.health = setting.health;
            this.hasHealth = true;
        }

        if (setting.hasSpeed)
        {
            this.speed = setting.speed;
            this.hasSpeed = true;
        }

        if (setting.hasHostile)
        {
            this.hostile = setting.hostile;
            this.hasHostile = true;
        }

        if (setting.hasHands)
        {
            this.hands = setting.hands;
            this.hasHands = true;
        }

        if (setting.hasUpdates)
        {
            this.updates = setting.updates;
            this.hasUpdates = true;
        }

        if (setting.hasShadowOption)
        {
            this.shadowOption = setting.shadowOption;
            this.hasShadowOption = true;
        }

        if (setting.hasbetterLightsShadow)
        {
            this.betterLightsShadow = setting.betterLightsShadow;
            this.hasbetterLightsShadow = true;
        }
    }

    /**
     * Write morph settings to the network buffer
     */
    public void toBytes(ByteBuf buf)
    {
        buf.writeBoolean(this.hasAbilities);

        if (this.hasAbilities)
        {
    		buf.writeInt(this.abilities.size());
    
            for (IAbility ability : this.abilities)
            {
                String string = getKey(MorphManager.INSTANCE.abilities, ability);
    
                ByteBufUtils.writeUTF8String(buf, string == null ? "" : string);
            }
        }

        buf.writeBoolean(this.hasAction);

        if (this.hasAction)
        {
            String action = getKey(MorphManager.INSTANCE.actions, this.action);
            buf.writeBoolean(action != null);

            if (action != null)
            {
                ByteBufUtils.writeUTF8String(buf, action);
            }
        }

        buf.writeBoolean(this.hasAttack);

        if (this.hasAttack) {
            String attack = getKey(MorphManager.INSTANCE.attacks, this.attack);
            buf.writeBoolean(attack != null);

            if (attack != null)
            {
                ByteBufUtils.writeUTF8String(buf, attack);
            }
        }
        
        buf.writeBoolean(this.hasHealth);

        if (this.hasHealth)
        {
            buf.writeInt(this.health);
        }

        buf.writeBoolean(this.hasSpeed);

        if (this.hasSpeed)
        {
            buf.writeFloat(this.speed);
        }

        buf.writeBoolean(this.hasHostile);

        if (this.hasHostile)
        {
            buf.writeBoolean(this.hostile);
        }

        buf.writeBoolean(this.hasHands);

        if (this.hasHands)
        {
            buf.writeBoolean(this.hands);
        }

        buf.writeBoolean(this.hasUpdates);

        if (this.hasUpdates)
        {
            buf.writeBoolean(this.updates);
        }

        buf.writeBoolean(this.hasShadowOption);

        if (this.hasShadowOption)
        {
        	buf.writeInt(this.shadowOption);
        }

        buf.writeBoolean(this.hasbetterLightsShadow);

        if (this.hasbetterLightsShadow)
        {
            buf.writeBoolean(this.betterLightsShadow);
        }
    }

    /**
     * Read morph settings from the network buffer 
     */
    public void fromBytes(ByteBuf buf)
    {
        this.hasAbilities = buf.readBoolean();

        if (this.hasAbilities)
        {
            List<IAbility> abilities = new ArrayList<IAbility>();
            for (int i = 0, c = buf.readInt(); i < c; i++)
            {
                IAbility ability = MorphManager.INSTANCE.abilities.get(ByteBufUtils.readUTF8String(buf));
    
                if (ability != null)
                {
                    abilities.add(ability);
                }
            }

            this.abilities = abilities;
        }

        this.hasAction = buf.readBoolean();

        if (this.hasAction)
        {
            if (buf.readBoolean())
            {
                String action = ByteBufUtils.readUTF8String(buf);
                this.action = MorphManager.INSTANCE.actions.get(action);
            }
            else
            {
                this.action = null;
            }
        }

        this.hasAttack = buf.readBoolean();

        if (this.hasAttack)
        {
            if (buf.readBoolean())
            {
                String attack = ByteBufUtils.readUTF8String(buf);
                this.attack = MorphManager.INSTANCE.attacks.get(attack);
            }
            else
            {
                this.attack = null;
            }
        }
        
        this.hasHealth = buf.readBoolean();

        if (this.hasHealth)
        {
        	this.health = buf.readInt();
        }
        
        this.hasSpeed = buf.readBoolean();

        if (this.hasSpeed)
        {
        	this.speed = buf.readFloat();
        }
        
        this.hasHostile = buf.readBoolean();

        if (this.hasHostile)
        {
        	this.hostile = buf.readBoolean();
        }
        
        this.hasHands = buf.readBoolean();

        if (this.hasHands)
        {
        	this.hands = buf.readBoolean();
        }
        
        this.hasUpdates = buf.readBoolean();

        if (this.hasUpdates)
        {
        	this.updates = buf.readBoolean();
        }
        
        this.hasShadowOption = buf.readBoolean();

        if (this.hasShadowOption)
        {
        	this.shadowOption = buf.readInt();
        }

        this.hasbetterLightsShadow = buf.readBoolean();

        if (this.hasbetterLightsShadow)
        {
            this.betterLightsShadow = buf.readBoolean();
        }
    }

    /**
     * Save properties to NBT compound
     */
    public void toNBT(NBTTagCompound tag)
    {
    	if (this.hasAbilities)
        {
            NBTTagList list = new NBTTagList();

            for (IAbility ability : this.abilities)
            {
                list.appendTag(new NBTTagString(getKey(MorphManager.INSTANCE.abilities, ability)));
            }

            tag.setTag("Abilities", list);
        }

        if (this.hasAttack)
        {
            String attackKey = getKey(MorphManager.INSTANCE.attacks, this.attack);
            if (attackKey == null) { attackKey = "null"; }
        	tag.setString("Attack", attackKey);
        }

        if (this.hasAction)
        {
            String actionKey = getKey(MorphManager.INSTANCE.actions, this.action);

            if (actionKey == null) { actionKey = "null"; }

        	tag.setString("Action", actionKey);
        }

        if (this.hasHealth)
        {
            tag.setInteger("HP", this.health);
        }

        if (this.hasSpeed)
        {
            tag.setFloat("Speed", this.speed);
        }

        if (this.hasHostile)
        {
            tag.setBoolean("Hostile", this.hostile);
        }

        if (this.hasHands)
        {
            tag.setBoolean("Hands", this.hands);
        }

        if (this.hasUpdates)
        {
            tag.setBoolean("Updates", this.updates);
        }

        if (this.hasShadowOption)
        {
            tag.setInteger("ShadowOption", this.shadowOption);
        }

        if (this.hasbetterLightsShadow)
        {
            tag.setBoolean("BetterLightsShadow", this.betterLightsShadow);
        }
    }

    /**
     * Read properties from NBT compound
     */
    public void fromNBT(NBTTagCompound tag)
    {
        this.hasAbilities = tag.hasKey("Abilities");

    	if (this.hasAbilities)
        {
        	NBTTagList list = tag.getTagList("Abilities", Constants.NBT.TAG_STRING);

            this.abilities.clear();

            for (int i = 0; i < list.tagCount(); i ++)
            {
                IAbility ability = MorphManager.INSTANCE.abilities.get(list.getStringTagAt(i));

                if (ability != null)
                {
                    this.abilities.add(ability);
                }
            }
        }

    	this.hasAttack = tag.hasKey("Attack");

        if (this.hasAttack)
        {
            this.attack = MorphManager.INSTANCE.attacks.get(tag.getString("Attack"));
        }

        this.hasAction = tag.hasKey("Action");

        if (this.hasAction)
        {
            this.action = MorphManager.INSTANCE.actions.get(tag.getString("Action"));
        }

        this.hasHealth = tag.hasKey("HP");

        if (this.hasHealth)
        {
            this.health = tag.getInteger("HP");
        }

        this.hasSpeed = tag.hasKey("Speed");

        if (this.hasSpeed)
        {
            this.speed = tag.getFloat("Speed");
        }

        this.hasHostile = tag.hasKey("Hostile");

        if (this.hasHostile)
        {
            this.hostile = tag.getBoolean("Hostile");
        }

        this.hasHands = tag.hasKey("Hands");

        if (this.hasHands)
        {
            this.hands = tag.getBoolean("Hands");
        }

        this.hasUpdates = tag.hasKey("Updates");

        if (this.hasUpdates)
        {
            this.updates = tag.getBoolean("Updates");
        }

        this.hasShadowOption = tag.hasKey("ShadowOption");

        if (this.hasShadowOption)
        {
            this.shadowOption = tag.getInteger("ShadowOption");
        }

        this.hasbetterLightsShadow = tag.hasKey("BetterLightsShadowOption");

        if (this.hasbetterLightsShadow)
        {
            this.betterLightsShadow = tag.getBoolean("BetterLightsShadow");
        }
    }

    /**
     * Get key of given value in given map 
     */
    public static <T> String getKey(Map<String, T> map, T value)
    {
        if (value == null)
        {
            return null;
        }

        for (Map.Entry<String, T> entry : map.entrySet())
        {
            if (entry.getValue() == value)
            {
                return entry.getKey();
            }
        }

        return null;
    }
}


==================================================

--- Файл №11 ---
Путь: main\java\mchorse\metamorph\api\MorphUtils.java
--------------------
package mchorse.metamorph.api;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Map;
import java.util.Set;
import java.util.function.Predicate;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.utils.BetterLightsHelper;
import mchorse.mclib.utils.NBTUtils;
import mchorse.mclib.utils.OptifineHelper;
import mchorse.metamorph.api.events.RegisterBlacklistEvent;
import mchorse.metamorph.api.events.RegisterRemapEvent;
import mchorse.metamorph.api.events.RegisterSettingsEvent;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.BodyPartManager;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class MorphUtils
{
    public static boolean isRenderingOnScreen = false;

    /**
     * Generate an empty file
     */
    public static void generateFile(File config, String content)
    {
        config.getParentFile().mkdirs();

        try
        {
            PrintWriter writer = new PrintWriter(config);
            writer.print(content);
            writer.close();
        }
        catch (FileNotFoundException e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Reload blacklist using event
     */
    public static Set<String> reloadBlacklist()
    {
        RegisterBlacklistEvent event = new RegisterBlacklistEvent();
        MinecraftForge.EVENT_BUS.post(event);

        return event.blacklist;
    }

    /**
     * Reload morph settings using event 
     */
    public static Map<String, MorphSettings> reloadMorphSettings()
    {
        RegisterSettingsEvent event = new RegisterSettingsEvent();
        MinecraftForge.EVENT_BUS.post(event);

        return event.settings;
    }

    /**
     * Reload morph ID mappings using event
     */
    public static Map<String, String> reloadRemapper()
    {
        RegisterRemapEvent event = new RegisterRemapEvent();
        MinecraftForge.EVENT_BUS.post(event);

        return event.map;
    }

    /**
     * Render in the world with morph error handling
     */
    @SideOnly(Side.CLIENT)
    public static boolean render(AbstractMorph morph, EntityLivingBase entity, double x, double y, double z, float yaw, float partialTick)
    {
        if (morph == null || morph.errorRendering)
        {
            return false;
        }

        /* optifine and better lights shadow pass overlap, optifine shadow pass needs to be only optifine */
        boolean isOptifineShadowPass = OptifineHelper.isOptifineShadowPass() && !BetterLightsHelper.isBetterLightsShadowPass();
        boolean isBetterLightsShadowPass = BetterLightsHelper.isBetterLightsShadowPass();
        boolean isNormalPass = !isOptifineShadowPass && !isBetterLightsShadowPass;

        boolean normalPass = morph.getSettings().shadowOption == 0 || morph.getSettings().shadowOption == 1;
        boolean betterLightsShadows = morph.getSettings().betterLightsShadow;
        boolean optifineShadows = morph.getSettings().shadowOption == 0 || morph.getSettings().shadowOption == 2;

        if (!GuiModelRenderer.isRendering()
                && ((isNormalPass && !normalPass)
                || (isOptifineShadowPass && !optifineShadows)
                || (isBetterLightsShadowPass && !betterLightsShadows)))
        {
            return false;
        }

        return renderDirect(morph, entity, x, y, z, yaw, partialTick);
    }

    /* Without shadow pass check */
    @SideOnly(Side.CLIENT)
    public static boolean renderDirect(AbstractMorph morph, EntityLivingBase entity, double x, double y, double z, float yaw, float partialTick)
    {
        if (morph == null || morph.errorRendering)
        {
            return false;
        }

        try
        {
            morph.render(entity, x, y, z, yaw, partialTick);

            return true;
        }
        catch (Exception e)
        {
            e.printStackTrace();
            morph.errorRendering = true;
        }
        finally
        {
            try
            {
                Tessellator.getInstance().getBuffer().finishDrawing();
                System.err.println("Unfinished builder comes from class: " + morph.getClass().getName());
            }
            catch (IllegalStateException ex)
            {}
        }

        return false;
    }

    /**
     * Render on screen with morph error handling
     */
    @SideOnly(Side.CLIENT)
    public static boolean renderOnScreen(AbstractMorph morph, EntityPlayer player, int x, int y, float scale, float alpha)
    {
        if (morph == null || morph.errorRendering)
        {
            return false;
        }

        try
        {
            isRenderingOnScreen = true;
            morph.renderOnScreen(player, x, y, scale, alpha);

            return true;
        }
        catch (Exception e)
        {
            e.printStackTrace();
            morph.errorRendering = true;
        }
        finally
        {
            isRenderingOnScreen = false;
            try
            {
                Tessellator.getInstance().getBuffer().finishDrawing();
                System.err.println("Unfinished builder comes from class: " + morph.getClass().getName());
            }
            catch (IllegalStateException ex)
            {}
        }

        return false;
    }

    /**
     * Copy a morph
     */
    public static AbstractMorph copy(AbstractMorph morph)
    {
        return morph == null ? null : morph.copy();
    }

    /**
     * Pause given morph
     */
    public static boolean pause(AbstractMorph morph, AbstractMorph previous, int offset)
    {
        if (morph instanceof ISyncableMorph)
        {
            ((ISyncableMorph) morph).pause(previous, offset);

            return true;
        }
        else if (morph instanceof IBodyPartProvider)
        {
            ((IBodyPartProvider) morph).getBodyPart().pause(previous, offset);

            return true;
        }

        return false;
    }
    
    /**
     * Resume given morph from pause.
     */
    public static boolean resume(AbstractMorph morph)
    {
        if (morph instanceof ISyncableMorph)
        {
            ((ISyncableMorph) morph).resume();
            
            return true;
        }
        else if (morph instanceof IBodyPartProvider)
        {
            for (BodyPart part : ((IBodyPartProvider) morph).getBodyPart().parts)
            {
                if (!part.morph.isEmpty() && part.morph.get() instanceof ISyncableMorph)
                {
                    ((ISyncableMorph) part.morph.get()).resume();
                }
            }
            
            return true;
        }

        return false;
    }

    /**
     * Morph to NBT
     */
    public static NBTTagCompound toNBT(AbstractMorph morph)
    {
        if (morph == null)
        {
            return null;
        }

        return morph.toNBT();
    }

    /**
     * Write a morph to {@link ByteBuf}
     *
     * This method will simply write a boolean indicating whether a morph was
     * saved and morph's data.
     *
     * Important: use this method in conjunction with
     * {@link #morphFromBuf(ByteBuf)}
     */
    public static void morphToBuf(ByteBuf buffer, AbstractMorph morph)
    {
        ByteBufUtils.writeTag(buffer, morph == null ? null : morph.toNBT());
    }

    /**
     * Create a morph from {@link ByteBuf}
     *
     * This method will read a morph from {@link ByteBuf} which should contain
     * a boolean indicating whether a morph was written and the morph data.
     *
     * Important: use this method in conjunction with
     * {@link #morphToBuf(ByteBuf, AbstractMorph)}!
     */
    public static AbstractMorph morphFromBuf(ByteBuf buffer)
    {
        return MorphManager.INSTANCE.morphFromNBT(NBTUtils.readInfiniteTag(buffer));
    }

    /**
     * Traverses the morph and its bodyparts to find a morph that matches the provided predicate.
     * @param morph
     * @param condition the predicate to apply on the morphs and children
     * @return true if any of the morph and children match the provided predicate, otherwise false.
     */
    public static boolean anyMatch(AbstractMorph morph, Predicate<AbstractMorph> condition)
    {
        while (true)
        {
            if (condition.test(morph))
            {
                return true;
            }

            if (morph instanceof IBodyPartProvider)
            {
                BodyPartManager mgr = ((IBodyPartProvider) morph).getBodyPart();
                for (BodyPart part : mgr.parts)
                {
                    if (part.enabled)
                    {
                        if (anyMatch(part.morph.get(), condition))
                        {
                            return true;
                        }
                    }
                }
            }

            if (morph instanceof IMorphProvider)
            {
                morph = ((IMorphProvider) morph).getMorph();
            }
            else
            {
                break;
            }
        }

        return false;
    }
}

==================================================

--- Файл №12 ---
Путь: main\java\mchorse\metamorph\api\RegisterHandler.java
--------------------
package mchorse.metamorph.api;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.events.RegisterBlacklistEvent;
import mchorse.metamorph.api.events.RegisterRemapEvent;
import mchorse.metamorph.api.events.RegisterSettingsEvent;
import mchorse.metamorph.api.json.MorphSettingsAdapter;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;

/**
 * Register handler 
 * 
 * This event handler is responsible for 
 */
public class RegisterHandler
{
    /**
     * GSON instance that is responsible for deserializing morph settings
     */
    private final static Gson GSON = new GsonBuilder().registerTypeAdapter(MorphSettings.class, new MorphSettingsAdapter()).create();

    /**
     * Register morph settings from default morphs configuration that 
     * comes with Metamorph and user configuration file 
     */
    @SubscribeEvent
    public void onSettingsReload(RegisterSettingsEvent event)
    {
        this.loadMorphSettings(event.settings, this.getClass().getClassLoader().getResourceAsStream("assets/metamorph/morphs.json"));
        this.loadMorphSettings(event.settings, Metamorph.proxy.morphs);
    }

    /**
     * Load morph settings into {@link MorphManager} with given {@link File} and 
     * with a try-catch which logs out an error in case of failure.
     */
    private void loadMorphSettings(Map<String, MorphSettings> settings, File config)
    {
        try
        {
            this.loadMorphSettings(settings, new FileInputStream(config));
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Load morph settings from {@link InputStream}
     */
    private void loadMorphSettings(Map<String, MorphSettings> settings, InputStream input)
    {
        Scanner scanner = new Scanner(input, "UTF-8");

        @SuppressWarnings("serial")
        Type type = (new TypeToken<Map<String, MorphSettings>>() {}).getType();
        Map<String, MorphSettings> data = GSON.fromJson(scanner.useDelimiter("\\A").next(), type);

        scanner.close();

        for (Map.Entry<String, MorphSettings> entry : data.entrySet())
        {
            String key = entry.getKey();
            MorphSettings morphSettings = entry.getValue();

            if (settings.containsKey(key))
            {
                settings.get(key).copy(morphSettings);
            }
            else
            {
                settings.put(key, morphSettings);
            }
        }
    }

    /**
     * Registers blacklist
     */
    @SubscribeEvent
    public void onRegisterBlacklist(RegisterBlacklistEvent event)
    {
        event.blacklist.add("metamorph:morph");

        this.loadBlacklist(event.blacklist, Metamorph.proxy.blacklist);
    }

    /**
     * Load user provided blacklist using the safe way.
     */
    private void loadBlacklist(Set<String> set, File blacklist)
    {
        try
        {
            Scanner scanner = new Scanner(new FileInputStream(blacklist), "UTF-8");

            @SuppressWarnings("serial")
            Type type = (new TypeToken<List<String>>() {}).getType();
            List<String> data = GSON.fromJson(scanner.useDelimiter("\\A").next(), type);

            set.addAll(data);
            scanner.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Registers remapper
     */
    @SubscribeEvent
    public void onRegisterRemapper(RegisterRemapEvent event)
    {
        event.map.put("metamorph.Block", "block");

        this.loadMappings(event.map, Metamorph.proxy.remap);
    }

    /**
     * Load user provided morph ID mappings using the safe way.
     */
    private void loadMappings(Map<String, String> map, File remap)
    {
        try
        {
            Scanner scanner = new Scanner(new FileInputStream(remap), "UTF-8");

            @SuppressWarnings("serial")
            Type type = (new TypeToken<Map<String, String>>() {}).getType();
            Map<String, String> data = GSON.fromJson(scanner.useDelimiter("\\A").next(), type);

            map.putAll(data);
            scanner.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}

==================================================

--- Файл №13 ---
Путь: main\java\mchorse\metamorph\api\abilities\Ability.java
--------------------
package mchorse.metamorph.api.abilities;

import net.minecraft.entity.EntityLivingBase;

/**
 * Ability's base class
 * 
 * All it does, makes onMorph and onDemorph methods empty (so I didn't had a 
 * need to create those methods like in every ability).
 */
public abstract class Ability implements IAbility
{
    @Override
    public void onMorph(EntityLivingBase player)
    {}

    @Override
    public void onDemorph(EntityLivingBase player)
    {}
}

==================================================

--- Файл №14 ---
Путь: main\java\mchorse\metamorph\api\abilities\IAbility.java
--------------------
package mchorse.metamorph.api.abilities;

import net.minecraft.entity.EntityLivingBase;

/**
 * Ability interface
 * 
 * This interface should provide a method which is responsible for updating 
 * entity every tick, with ability to setup some behavior on player before 
 * morphing, and reset player, in given way, on player's demorph.
 */
public interface IAbility
{
    /**
     * This method is responsible for updating a player based on ability's 
     * function.
     */
    public void update(EntityLivingBase target);

    /**
     * This method should be invoked when the player is about to get morphed.
     */
    public void onMorph(EntityLivingBase target);

    /**
     * This method should be invoked when the player morphs into other morph 
     * without this ability. 
     */
    public void onDemorph(EntityLivingBase target);
}

==================================================

--- Файл №15 ---
Путь: main\java\mchorse\metamorph\api\abilities\IAction.java
--------------------
package mchorse.metamorph.api.abilities;

import javax.annotation.Nullable;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;

/**
 * Action interface
 * 
 * Just like an ability, but cooler. This interface, instead of changing player's 
 * properties, it's actually does some kind of trick.
 */
public interface IAction
{
    /**
     * Execute an action. Depends on action's description, it can teleport 
     * player, emit explosion, or something else.  
     */
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph);
}

==================================================

--- Файл №16 ---
Путь: main\java\mchorse\metamorph\api\abilities\IAttackAbility.java
--------------------
package mchorse.metamorph.api.abilities;

import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;

/**
 * Ability attack interface
 * 
 * This interface is responsible for adding some additional effect on the 
 * target (used primarly for wither, and other stuff)
 */
public interface IAttackAbility
{
    /**
     * Do something with attacked entity
     */
    public void attack(Entity target, EntityLivingBase source);
}

==================================================

--- Файл №17 ---
Путь: main\java\mchorse\metamorph\api\creative\MorphList.java
--------------------
package mchorse.metamorph.api.creative;

import mchorse.metamorph.api.creative.sections.MorphSection;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.world.World;

import java.util.ArrayList;
import java.util.List;

/**
 * Morph list
 */
public class MorphList
{
    /**
     * Morph sections
     */
    public List<MorphSection> sections = new ArrayList<MorphSection>();

    /**
     * Add a morph section to this list
     */
    public void register(MorphSection section)
    {
        this.sections.add(section);
    }

    /**
     * This method gets called when a new morph picker appears
     */
    public void update(World world)
    {
        for (MorphSection section : this.sections)
        {
            section.update(world);
        }
    }

    /**
     * This method gets called when player exits to the main menu
     */
    public void reset()
    {
        for (MorphSection section : this.sections)
        {
            section.reset();
        }
    }

    /**
     * If any of the morphs have keybind attached, use it
     */
    public boolean keyTyped(EntityPlayer player, int keycode)
    {
        for (MorphSection section : this.sections)
        {
            if (section.keyTyped(player, keycode))
            {
                return true;
            }
        }

        return false;
    }

    public <T> T getSection(Class<T> clazz)
    {
        for (MorphSection section : this.sections)
        {
            if (section.getClass() == clazz)
            {
                return clazz.cast(section);
            }
        }

        return null;
    }
}

==================================================

--- Файл №18 ---
Путь: main\java\mchorse\metamorph\api\creative\categories\AcquiredCategory.java
--------------------
package mchorse.metamorph.api.creative.categories;

import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import mchorse.metamorph.network.common.creative.PacketClearAcquired;
import mchorse.metamorph.network.common.creative.PacketSyncMorph;
import mchorse.metamorph.network.common.survival.PacketRemoveMorph;
import mchorse.metamorph.network.common.survival.PacketSelectMorph;
import net.minecraft.entity.player.EntityPlayer;

import java.util.List;

public class AcquiredCategory extends MorphCategory
{
    public AcquiredCategory(MorphSection parent, String title)
    {
        super(parent, title);
    }

    public void setMorphs(List<AbstractMorph> morphs)
    {
        this.morphs = morphs;
    }

    @Override
    public void clear()
    {
        super.clear();

        Dispatcher.sendToServer(new PacketClearAcquired());
    }

    @Override
    protected void addMorph(AbstractMorph morph)
    {
        super.addMorph(morph);

        Dispatcher.sendToServer(new PacketAcquireMorph(morph, false));
    }

    @Override
    public boolean isEditable(AbstractMorph morph)
    {
        return this.morphs.indexOf(morph) != -1;
    }

    @Override
    public void edit(AbstractMorph morph)
    {
        int index = this.morphs.indexOf(morph);

        if (index >= 0)
        {
            Dispatcher.sendToServer(new PacketSyncMorph(morph, index));
        }
    }

    @Override
    public boolean remove(AbstractMorph morph)
    {
        int index = this.morphs.indexOf(morph);
        boolean has = index != -1;

        if (has)
        {
            Dispatcher.sendToServer(new PacketRemoveMorph(index));
        }

        return has;
    }

    @Override
    protected boolean morph(EntityPlayer player, AbstractMorph morph)
    {
        int index = this.morphs.indexOf(morph);

        if (index >= 0)
        {
            Dispatcher.sendToServer(new PacketSelectMorph(index));
        }

        return true;
    }
}

==================================================

--- Файл №19 ---
Путь: main\java\mchorse\metamorph\api\creative\categories\MorphCategory.java
--------------------
package mchorse.metamorph.api.creative.categories;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.creative.PacketMorph;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class MorphCategory
{
    public MorphSection parent;

    public String title;
    public boolean hidden;
    protected List<AbstractMorph> morphs = new ArrayList<AbstractMorph>();

    public MorphCategory(MorphSection parent, String title)
    {
        this.parent = parent;
        this.title = title;
    }

    @SideOnly(Side.CLIENT)
    public String getTitle()
    {
        return I18n.format("morph.category." + this.title);
    }

    public List<AbstractMorph> getMorphs()
    {
        return this.morphs;
    }

    public boolean isHidden()
    {
        return this.morphs.isEmpty() || this.hidden;
    }

    public AbstractMorph getEqual(AbstractMorph morph)
    {
        for (AbstractMorph child : this.morphs)
        {
            if (child.equals(morph))
            {
                return child;
            }
        }

        return null;
    }

    public void clear()
    {
        this.morphs.clear();
    }

    public void sort()
    {
        Collections.sort(this.morphs, (a, b) -> a.name.compareToIgnoreCase(b.name));
    }

    public final void add(AbstractMorph morph)
    {
        if (MorphManager.isBlacklisted(morph.name))
        {
            return;
        }

        MorphManager.INSTANCE.applySettings(morph);

        this.addMorph(morph);
    }

    protected void addMorph(AbstractMorph morph)
    {
        this.morphs.add(morph);
    }

    public boolean isEditable(AbstractMorph morph)
    {
        return false;
    }

    public void edit(AbstractMorph morph)
    {}

    public boolean remove(AbstractMorph morph)
    {
        return this.morphs.remove(morph);
    }

    public boolean keyTyped(EntityPlayer player, int keycode)
    {
        for (AbstractMorph morph : this.morphs)
        {
            if (morph.keybind == keycode && this.morph(player, morph))
            {
                return true;
            }
        }

        return false;
    }

    protected boolean morph(EntityPlayer player, AbstractMorph morph)
    {
        if (Metamorph.proxy.canUse(player))
        {
            Dispatcher.sendToServer(new PacketMorph(morph));

            return true;
        }

        return false;
    }
}


==================================================

--- Файл №20 ---
Путь: main\java\mchorse\metamorph\api\creative\categories\RecentCategory.java
--------------------
package mchorse.metamorph.api.creative.categories;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.morphs.AbstractMorph;

public class RecentCategory extends MorphCategory
{
    public RecentCategory(MorphSection parent, String title)
    {
        super(parent, title);
    }

    @Override
    protected void addMorph(AbstractMorph morph)
    {
        while (this.morphs.size() >= Metamorph.maxRecentMorphs.get())
        {
            this.morphs.remove(this.morphs.size() - 1);
        }

        this.morphs.add(0, morph);
    }

    @Override
    public boolean isEditable(AbstractMorph morph)
    {
        return this.morphs.indexOf(morph) != -1;
    }
}

==================================================

--- Файл №21 ---
Путь: main\java\mchorse\metamorph\api\creative\categories\UserCategory.java
--------------------
package mchorse.metamorph.api.creative.categories;

import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.creative.sections.UserSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class UserCategory extends MorphCategory
{
    public UserCategory(MorphSection parent, String title)
    {
        super(parent, title);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public String getTitle()
    {
        return this.title;
    }

    @Override
    public boolean isHidden()
    {
        return this.hidden;
    }

    @Override
    public void addMorph(AbstractMorph morph)
    {
        super.addMorph(morph);

        if (this.parent instanceof UserSection)
        {
            ((UserSection) this.parent).save();
        }
    }

    @Override
    public boolean isEditable(AbstractMorph morph)
    {
        return this.morphs.indexOf(morph) != -1;
    }

    @Override
    public void edit(AbstractMorph morph)
    {
        int index = this.morphs.indexOf(morph);

        if (index >= 0 && this.parent instanceof UserSection)
        {
            ((UserSection) this.parent).save();
        }
    }

    @Override
    public boolean remove(AbstractMorph morph)
    {
        boolean result = super.remove(morph);

        if (result && this.parent instanceof UserSection)
        {
            ((UserSection) this.parent).save();
        }

        return result;
    }
}

==================================================

--- Файл №22 ---
Путь: main\java\mchorse\metamorph\api\creative\sections\MorphSection.java
--------------------
package mchorse.metamorph.api.creative.sections;

import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList;
import mchorse.metamorph.client.gui.creative.GuiMorphSection;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class MorphSection
{
    public String title;
    public List<MorphCategory> categories = new ArrayList<MorphCategory>();
    public boolean hidden;

    public MorphSection(String title)
    {
        this.title = title;
    }

    @SideOnly(Side.CLIENT)
    public String getTitle()
    {
        return I18n.format("morph.section." + this.title);
    }

    public void add(MorphCategory category)
    {
        this.categories.add(category);
    }

    public void remove(MorphCategory category)
    {
        this.categories.remove(category);
    }

    /**
     * This method gets called when a new morph picker appears
     */
    public void update(World world)
    {}

    /**
     * This method gets called when player exits to the main menu
     */
    public void reset()
    {}

    @SideOnly(Side.CLIENT)
    public GuiMorphSection getGUI(Minecraft mc, GuiCreativeMorphsList parent, Consumer<GuiMorphSection> callback)
    {
        return new GuiMorphSection(mc, parent, this, callback);
    }

    public boolean keyTyped(EntityPlayer player, int keycode)
    {
        for (MorphCategory category : this.categories)
        {
            if (category.keyTyped(player, keycode))
            {
                return true;
            }
        }

        return false;
    }
}

==================================================

--- Файл №23 ---
Путь: main\java\mchorse\metamorph\api\creative\sections\UserSection.java
--------------------
package mchorse.metamorph.api.creative.sections;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import mchorse.mclib.utils.JsonUtils;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.categories.AcquiredCategory;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.categories.RecentCategory;
import mchorse.metamorph.api.creative.categories.UserCategory;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList;
import mchorse.metamorph.client.gui.creative.GuiMorphSection;
import mchorse.metamorph.client.gui.creative.GuiUserSection;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

/**
 * User morph section
 *
 * Here we store acquired morphs, recently edited morphs and custom
 * categories created by the player
 */
public class UserSection extends MorphSection
{
    public AcquiredCategory acquired;
    public RecentCategory recent;

    public boolean loaded = false;
    public List<UserCategory> global = new ArrayList<UserCategory>();

    public UserSection(String title)
    {
        super(title);

        this.acquired = new AcquiredCategory(this, "acquired");
        this.recent = new RecentCategory(this, "recent");
    }

    @Override
    public void add(MorphCategory category)
    {
        super.add(category);

        if (category instanceof UserCategory)
        {
            this.global.add((UserCategory) category);
        }

        this.save();
    }

    @Override
    public void remove(MorphCategory category)
    {
        super.remove(category);

        if (category instanceof UserCategory)
        {
            this.global.remove(category);
        }

        this.save();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void update(World world)
    {
        super.update(world);

        IMorphing morphing = Morphing.get(Minecraft.getMinecraft().player);

        this.categories.clear();
        this.categories.add(this.acquired);
        this.categories.add(this.recent);
        this.acquired.setMorphs(morphing == null ? Collections.emptyList() : morphing.getAcquiredMorphs());

        if (!this.loaded)
        {
            this.load();
            this.loaded = true;
        }

        this.categories.addAll(this.global);
    }

    @Override
    public void reset()
    {
        super.reset();

        if (this.loaded)
        {
            this.save();
            this.loaded = false;
        }

        this.categories.clear();
        this.acquired.setMorphs(Collections.emptyList());
        this.recent.clear();
        this.global.clear();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public GuiMorphSection getGUI(Minecraft mc, GuiCreativeMorphsList parent, Consumer<GuiMorphSection> callback)
    {
        return new GuiUserSection(mc, parent, this, callback);
    }

    public void load()
    {
        File file = Metamorph.proxy.list;

        if (!file.exists())
        {
            return;
        }

        try
        {
            List<UserCategory> categories = new ArrayList<UserCategory>();
            String content = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
            JsonArray object = new JsonParser().parse(content).getAsJsonArray();
            int i = 0;

            for (JsonElement entry : object)
            {
                JsonObject cat = entry.getAsJsonObject();
                UserCategory category = new UserCategory(this, cat.get("title").getAsString());

                if (cat.has("hidden") && cat.get("hidden").isJsonPrimitive())
                {
                    category.hidden = cat.get("hidden").getAsBoolean();
                }

                if (cat.has("morphs"))
                {
                    for (JsonElement string : cat.get("morphs").getAsJsonArray())
                    {
                        try {
                            AbstractMorph morph = MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson(string.getAsString()));

                            if (morph != null)
                            {
                                category.add(morph);
                                i ++;
                            }
                        }
                        catch (Exception e)
                        {
                            e.printStackTrace();
                        }
                    }
                }

                categories.add(category);
            }

            System.out.println("Loading " + categories.size() + " categories with " + i + " morphs!");

            this.global = categories;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public void save()
    {
        if (!this.loaded)
        {
            return;
        }

        JsonArray array = new JsonArray();
        int i = 0;

        for (UserCategory category : this.global)
        {
            JsonObject cat = new JsonObject();
            JsonArray morphs = new JsonArray();

            cat.addProperty("title", category.getTitle());
            cat.addProperty("hidden", category.hidden);
            cat.add("morphs", morphs);

            for (AbstractMorph morph : category.getMorphs())
            {
                if (morph != null)
                {
                    morphs.add(morph.toNBT().toString());

                    i ++;
                }
            }

            array.add(cat);
        }

        System.out.println("Saving " + array.size() + " categories with " + i + " morphs to list.json!");

        try
        {
            FileUtils.writeStringToFile(Metamorph.proxy.list, JsonUtils.jsonToPretty(array), StandardCharsets.UTF_8);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}


==================================================

--- Файл №24 ---
Путь: main\java\mchorse\metamorph\api\events\AcquireMorphEvent.java
--------------------
package mchorse.metamorph.api.events;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.Morphing;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.common.eventhandler.Cancelable;
import net.minecraftforge.fml.common.eventhandler.Event;

/**
 * Acquire morph event
 * 
 * {@link AcquireMorphEvent.Pre} is fired when a player is about to acquire a morph. This is not 
 * necessarily means that player already has this morph. Use {@link #hasMorph()} 
 * method to figure out whether player already has given morph.
 * 
 * You can modify the morph property. This will result into player getting 
 * different morph. 
 * 
 * If you cancel this event, player won't acquire a morph, however, if player 
 * already has this morph, it will be completely useless.
 * 
 * {@link AcquireMorphEvent.Post} is fired after a player successfully acquires a new morph.
 */
public abstract class AcquireMorphEvent extends Event
{
    public EntityPlayer player;
    public AbstractMorph morph;

    public AcquireMorphEvent(EntityPlayer player, AbstractMorph morph)
    {
        this.player = player;
        this.morph = morph;
    }

    /**
     * Does given player already has this morph 
     */
    public boolean hasMorph()
    {
        return Morphing.get(this.player).acquiredMorph(this.morph);
    }

    /**
     * Fires before player acquires a morph. This event is {@link Cancelable}.
     * 
     * @author asanetargoss
     */
    @Cancelable
    public static class Pre extends AcquireMorphEvent
    {
        public Pre(EntityPlayer player, AbstractMorph morph)
        {
            super(player, morph);
        }
    }

    /**
     * Fires after player successfully acquires a morph. 
     */
    public static class Post extends AcquireMorphEvent
    {
        public Post(EntityPlayer player, AbstractMorph morph)
        {
            super(player, morph);
        }
    }
}

==================================================

--- Файл №25 ---
Путь: main\java\mchorse\metamorph\api\events\MorphActionEvent.java
--------------------
package mchorse.metamorph.api.events;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.eventhandler.Event;

/**
 * Morph action event
 * 
 * This event is fired on {@link MinecraftForge#EVENT_BUS}. It's fired when a 
 * player uses an action on the server side.
 * 
 * It's not cancel-able and not modify-able.
 */
public class MorphActionEvent extends Event
{
    public EntityPlayer player;
    public IAction action;
    public AbstractMorph morph;

    public MorphActionEvent(EntityPlayer player, IAction action, AbstractMorph morph)
    {
        this.player = player;
        this.action = action;
        this.morph = morph;
    }

    /**
     * Check whether this action is valid (and did take place, because if 
     * action is null, nothing will happen) 
     */
    public boolean isValid()
    {
        return this.action != null;
    }
}

==================================================

--- Файл №26 ---
Путь: main\java\mchorse\metamorph\api\events\MorphEvent.java
--------------------
package mchorse.metamorph.api.events;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.common.eventhandler.Cancelable;
import net.minecraftforge.fml.common.eventhandler.Event;

/**
 * Morph event
 * 
 * {@link MorphEvent.Pre} occurs when player gets morphed or demorphed. If player gets 
 * demorphed then {@link #morph} is null. Check for player's worldObj property 
 * to get on which side this event is triggered.
 * 
 * This event is cancelable. If it's get canceled, then player won't demorph 
 * or morph. If you'll reassign {@link #morph}, then player will apply morph 
 * which you assigned (or demorph if you assign {@link #morph} to null).
 * 
 * You can also modify {@link #force} parameter which is responsible for 
 * forcing morphing (if not forced, player will morph only in case if he has 
 * acquired morph like given).
 * 
 * {@link MorphEvent.Post} is fired after a player successfully morphs or demorphs.
 * 
 */
public abstract class MorphEvent extends Event
{
    public EntityPlayer player;
    public AbstractMorph morph;
    public boolean force;

    public MorphEvent(EntityPlayer player, AbstractMorph morph, boolean force)
    {
        this.player = player;
        this.morph = morph;
        this.force = force;
    }

    /**
     * Whether given player is about to demorph
     */
    public boolean isDemorphing()
    {
        return this.morph == null;
    }

    /**
     * Fires before player morphs. This event is {@link Cancelable}.
     * 
     * @author asanetargoss 
     */
    @Cancelable
    public static class Pre extends MorphEvent
    {
        public Pre(EntityPlayer player, AbstractMorph morph, boolean force)
        {
            super(player, morph, force);
        }
    }

    /**
     * Fires after a player successfully morphed
     * 
     * @author asanetargoss 
     */
    public static class Post extends MorphEvent
    {
        public Post(EntityPlayer player, AbstractMorph morph, boolean force)
        {
            super(player, morph, force);
        }
    }
}

==================================================

--- Файл №27 ---
Путь: main\java\mchorse\metamorph\api\events\RegisterBlacklistEvent.java
--------------------
package mchorse.metamorph.api.events;

import java.util.Set;
import java.util.TreeSet;

import net.minecraftforge.fml.common.eventhandler.Event;

/**
 * Register blacklist event
 * 
 * This event is fired when Metamorph is signaled to reload blacklist. 
 * During this event you can register names of morphs which you want 
 * to be disabled. 
 */
public class RegisterBlacklistEvent extends Event
{
    /**
     * Blacklist. You should use this field to fill the morph names you 
     * want to disable.
     */
    public Set<String> blacklist = new TreeSet<String>();
}

==================================================

--- Файл №28 ---
Путь: main\java\mchorse\metamorph\api\events\RegisterRemapEvent.java
--------------------
package mchorse.metamorph.api.events;

import net.minecraftforge.fml.common.eventhandler.Event;

import java.util.HashMap;
import java.util.Map;

/**
 * Register ramep event
 *
 * This event is fired when Metamorph is signaled to reload morph ID mappings.
 * During this event you can register names of morphs which you want
 * to be remapped to another names.
 */
public class RegisterRemapEvent extends Event
{
    /**
     * Map of which morph IDs should be remapped
     */
    public Map<String, String> map = new HashMap<String, String>();
}


==================================================

--- Файл №29 ---
Путь: main\java\mchorse\metamorph\api\events\RegisterSettingsEvent.java
--------------------
package mchorse.metamorph.api.events;

import java.util.HashMap;
import java.util.Map;

import mchorse.metamorph.api.MorphSettings;
import net.minecraftforge.fml.common.eventhandler.Event;

/**
 * Register settings event
 * 
 * This event should be fired when Metamorph reloads morph settings 
 * (this happens once the server is starting up or when admin executes 
 * "/metamorph reload settings" command).
 * 
 * Use this event to add your own custom morph settings.  
 */
public class RegisterSettingsEvent extends Event
{
    public Map<String, MorphSettings> settings = new HashMap<String, MorphSettings>();
}

==================================================

--- Файл №30 ---
Путь: main\java\mchorse\metamorph\api\events\ReloadMorphs.java
--------------------
package mchorse.metamorph.api.events;

import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Reload morphs event
 * 
 * This event gets fired when creative morphs picker gets initiated
 */
@SideOnly(Side.CLIENT)
public class ReloadMorphs extends Event
{
    public ReloadMorphs()
    {}
}

==================================================

--- Файл №31 ---
Путь: main\java\mchorse\metamorph\api\events\SpawnGhostEvent.java
--------------------
package mchorse.metamorph.api.events;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.common.eventhandler.Cancelable;
import net.minecraftforge.fml.common.eventhandler.Event;

/**
 * Morph spawn event
 * 
 * {@link SpawnGhostEvent.Pre} occurs when a player kills a monster and a ghost is
 * about to spawn from it. The event will not occur if the config option
 * prevent_kill_acquire is set to true, nor will it occur if the config option
 * prevent_ghosts is set to true while the player already has the morph.
 * 
 * {@link #player} is the player responsible for killing the monster which spawned
 * the morph.
 * 
 * {@link #morph} is an instance of (@link #AbstractMorph} which represents the
 * monster that was just killed. If you change this, a different morph ghost will
 * spawn. If you set this to null, no morph will spawn.
 * 
 * Canceling the event will prevent the ghost from spawning.
 * 
 * {@link SpawnGhostEvent.Post} is fired after the ghost successfully spawns.
 * 
 * @author asanetargoss
 */
public abstract class SpawnGhostEvent extends Event
{
    public EntityPlayer player;
    public AbstractMorph morph;

    public SpawnGhostEvent(EntityPlayer player, AbstractMorph morph)
    {
        this.player = player;
        this.morph = morph;
    }

    @Cancelable
    public static class Pre extends SpawnGhostEvent
    {
        public Pre(EntityPlayer player, AbstractMorph morph)
        {
            super(player, morph);
        }
    }

    public static class Post extends SpawnGhostEvent
    {
        public Post(EntityPlayer player, AbstractMorph morph)
        {
            super(player, morph);
        }
    }
}

==================================================

--- Файл №32 ---
Путь: main\java\mchorse\metamorph\api\json\MorphSettingsAdapter.java
--------------------
package mchorse.metamorph.api.json;

import java.lang.reflect.Type;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphSettings;
import mchorse.metamorph.api.abilities.IAbility;

/**
 * Morph settings adapter
 * 
 * This class is responsible for deserializing {@link MorphSettings}.
 */
public class MorphSettingsAdapter implements JsonDeserializer<MorphSettings>
{
    @Override
    public MorphSettings deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
    {
        JsonObject object = json.getAsJsonObject();

        MorphSettings morph = new MorphSettings();
        MorphManager manager = MorphManager.INSTANCE;

        morph.hasHealth = object.has("health") && object.get("health").isJsonPrimitive();

        if (morph.hasHealth)
        {
            morph.health = object.get("health").getAsInt();
        }

        morph.hasSpeed = object.has("speed") && object.get("speed").isJsonPrimitive();

        if (morph.hasSpeed)
        {
            morph.speed = object.get("speed").getAsFloat();
        }

        morph.hasHostile = object.has("hostile") && object.get("hostile").isJsonPrimitive();

        if (morph.hasHostile)
        {
            morph.hostile = object.get("hostile").getAsBoolean();
        }

        morph.hasHands = object.has("hands") && object.get("hands").isJsonPrimitive();

        if (morph.hasHands)
        {
            morph.hands = object.get("hands").getAsBoolean();
        }

        morph.hasAbilities = object.has("abilities") && object.get("abilities").isJsonArray();

        if (morph.hasAbilities)
        {
            morph.abilities.clear();

            for (JsonElement ability : object.get("abilities").getAsJsonArray())
            {
                if (!ability.isJsonPrimitive())
                {
                    continue;
                }

                IAbility iability = manager.abilities.get(ability.getAsString());

                if (iability != null)
                {
                    morph.abilities.add(iability);
                }
            }
        }

        morph.hasAction = object.has("action") && object.get("action").isJsonPrimitive();

        if (morph.hasAction)
        {
            morph.action = manager.actions.get(object.get("action").getAsString());
        }

        morph.hasAttack = object.has("attack") && object.get("attack").isJsonPrimitive();

        if (morph.hasAttack)
        {
            morph.attack = manager.attacks.get(object.get("attack").getAsString());
        }

        morph.hasUpdates = object.has("updates") && object.get("updates").isJsonPrimitive();

        if (morph.hasUpdates)
        {
            morph.updates = object.get("updates").getAsBoolean();
        }
        
        morph.hasShadowOption = object.has("shadow_option") && object.get("shadow_option").isJsonPrimitive();

        if (morph.hasShadowOption)
        {
            morph.shadowOption = object.get("shadow_option").getAsInt();
        }

        morph.hasbetterLightsShadow = object.has("betterlights_shadow") && object.get("betterlights_shadow").isJsonPrimitive();

        if (morph.hasbetterLightsShadow)
        {
            morph.betterLightsShadow = object.get("betterlights_shadow").getAsBoolean();
        }

        return morph;
    }
}


==================================================

--- Файл №33 ---
Путь: main\java\mchorse\metamorph\api\models\IMorphProvider.java
--------------------
package mchorse.metamorph.api.models;

import mchorse.metamorph.api.morphs.AbstractMorph;

public interface IMorphProvider
{
    public AbstractMorph getMorph();
}

==================================================

--- Файл №34 ---
Путь: main\java\mchorse\metamorph\api\morphs\AbstractMorph.java
--------------------
package mchorse.metamorph.api.morphs;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphSettings;
import mchorse.metamorph.api.abilities.IAbility;
import mchorse.metamorph.api.morphs.utils.Hitbox;
import mchorse.metamorph.entity.SoundHandler;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.SharedMonsterAttributes;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumHand;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraftforge.classloading.FMLForgePlugin;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Vector3f;
import java.util.Objects;

/**
 * Base class for all different types of morphs
 * 
 * This is an abstract morph. It contains all needed properties for a basic 
 * morph such as abilities, action, attack, health, speed and hotstyle flag.
 * 
 * This class is also responsible for rendering operations. Oh boy, this class 
 * is so huge. I'll have to decompose this thing onto rendering and logic code.
 */
public abstract class AbstractMorph
{
    public Vector3f cachedTranslation = new Vector3f();

    /**
     * At the moment no use -> would be useful to have realistic physics
     * for every limb, see robotics https://www.tu-chemnitz.de/informatik/KI/edu/robotik/ws2017/vel.kin.pdf
     */
    public Vector3f angularVelocity = new Vector3f();

    public int age = 0;

    /* Meta information */

    /**
     * Morph's name
     */
    public String name = "";

    /**
     * Morph's display name
     */
    public String displayName = "";

    /* Survival morph properties */

    /**
     * Is this morph is favorite 
     */
    public boolean favorite = false;

    /**
     * Is this morph is favorite
     */
    public int keybind = -1;

    /* Morph Settings */

    /**
     * The authoritative settings for the morph.
     */
    @Deprecated
    public MorphSettings settings = MorphSettings.DEFAULT.copy();

    /**
     * If this is false, {@link #settings} will be initialized
     * as needed. If this is true, {@link #settings} will remain
     * at whatever value it was set to in {@link #forceSettings(MorphSettings)}
     */
    protected boolean forcedSettings = false;
    
    protected boolean needSettingsUpdate = false;

    /**
     * The highest priority settings, defined through
     * configuration.
     */
    protected MorphSettings activeSettings = null;
    
    /**
     * This is called to initialize settings for morphs, if
     * settings are out-of-date.
     */
    public void initializeSettings()
    {
        if (!this.needSettingsUpdate)
        {
        	if (this.settings == null)
        	{
	        	if (!FMLForgePlugin.RUNTIME_DEOBF)
	        	{
                    Metamorph.LOGGER.error("needSettingsUpdate was not set to true when changing morph settings, or the settings was set to null directly when it shouldn't be");
                }

                this.settings = MorphSettings.DEFAULT_MORPHED.copy();
        	}
        	
            return;
        }

        this.settings = MorphSettings.DEFAULT_MORPHED.copy();

        if (this.activeSettings != null)
        {
            this.settings.applyOverrides(this.activeSettings);
        }
        
        finishInitializingSettings();
    }
    
    protected void finishInitializingSettings()
    {
        this.needSettingsUpdate = false;
        this.forcedSettings = false;
    }

    /**
     * This sets the active settings for the morph, usually defined
     * by the user through JSON configuration. These settings usually
     * have the highest priority.
     */
    public void setActiveSettings(MorphSettings activeSettings)
    {
        this.activeSettings = activeSettings;
        this.needSettingsUpdate = true;
    }
    
    /**
     * This forces a morph to use the given settings. These settings
     * will not be overridden and must be complete settings
     * (no null fields allowed).
     */
    public void forceSettings(MorphSettings settingsToForce)
    {
    	if (settingsToForce == null)
    	{
        	if (FMLForgePlugin.RUNTIME_DEOBF)
        	{
        		settingsToForce = MorphSettings.DEFAULT_MORPHED.copy();
        	}
        	else
        	{
        		// Developer mode
        		throw new NullPointerException("Forced settings should never be null (are you trying to call clearForcedSettings()?)");
        	}
    	}
    	
        this.settings = settingsToForce;
        this.forcedSettings = true;
    }

    /**
     * This forces a morph to use the updated settings. These settings
     * will not be overridden and must be complete settings
     * (no null fields allowed).
     * If the settings have not been forced yet, the morph's existing
     * settings will be copied and used as the basis for the new forced
     * settings.
     */
    public void forceEditSettings(MorphSettings.Edit edit)
    {
    	MorphSettings settingsCopy = this.getSettings().copy();
    	edit.apply(settingsCopy);
    	forceSettings(settingsCopy);
    }
    
    /**
     * Undoes the effects of {@link #forceSettings}
     */
    public void clearForcedSettings()
    {
        this.settings = null;
        this.forcedSettings = false;
        this.needSettingsUpdate = true;
    }
    
    /**
     * Gets the morph settings or initializes them if
     * not defined.
     */
    public MorphSettings getSettings()
    {
        if (!this.forcedSettings)
        {
            initializeSettings();
        }

        return this.settings;
    }

    /**
     * Custom hitbox setting
     */
    public Hitbox hitbox = new Hitbox();

    /**
     * Whether this morph is erroring when rendering
     */
    public boolean errorRendering;

    /**
     * Get display name of this morph
     */
    @SideOnly(Side.CLIENT)
    public String getDisplayName()
    {
        if (this.displayName != null && !this.displayName.isEmpty())
        {
            return this.displayName;
        }

        return this.getSubclassDisplayName();
    }

    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return this.name;
    }

    @SideOnly(Side.CLIENT)
    public boolean hasCustomName()
    {
        return this.displayName != null && !this.displayName.isEmpty();
    }

    @Deprecated
    public boolean hasCustomSettings()
    {
    	if (this.settings != MorphSettings.DEFAULT)
    	{
    		return true;
    	}
    	
    	if (this.settings != MorphManager.INSTANCE.activeSettings.get(this.name))
    	{
    		return true;
    	}
    	
        return forcedSettings;
    }

    /* Render methods */

    /**
     * Render this morph on 2D screen (used in GUIs)
     */
    @SideOnly(Side.CLIENT)
    public abstract void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha);

    /**
     * Render the entity (in the world) 
     */
    @SideOnly(Side.CLIENT)
    public abstract void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks);

    /**
     * Render the arm for given hand 
     */
    @SideOnly(Side.CLIENT)
    public boolean renderHand(EntityPlayer player, EnumHand hand)
    {
        return !getSettings().hands;
    }

    /* Update loop */

    /**
     * Update the player based on its morph abilities and properties. This 
     * method also responsible for updating AABB size. 
     */
    public void update(EntityLivingBase target)
    {
        this.updateHitbox(target);

        MorphSettings settings = this.getSettings();

        if (settings.speed != 0.1F)
        {
            target.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(settings.speed);
        }

        for (IAbility ability : settings.abilities)
        {
            ability.update(target);
        }

        this.age++;
    }

    /* Morph and demorph handlers */

    /**
     * Morph into the current morph
     * 
     * This method responsible for setting up the health of the player to 
     * morph's health and invoke ability's onMorph methods.
     */
    public void morph(EntityLivingBase target)
    {
        for (IAbility ability : this.getSettings().abilities)
        {
            ability.onMorph(target);
        }
    }

    /**
     * Demorph from the current morph
     * 
     * This method responsible for setting up the health back to player's 
     * default health and invoke ability's onDemorph methods.
     */
    public void demorph(EntityLivingBase target)
    {
        for (IAbility ability : this.getSettings().abilities)
        {
            ability.onDemorph(target);
        }
    }

    /* Adjusting size */

    protected void updateHitbox(EntityLivingBase target)
    {
        if (this.hitbox.enabled)
        {
            float height = target.isSneaking() ? this.hitbox.sneakingHeight : this.hitbox.height;

            this.updateSize(target, this.hitbox.width, height, this.hitbox.eye);
        }
        else
        {
            this.updateUserHitbox(target);
        }
    }

    protected void updateUserHitbox(EntityLivingBase target)
    {}

    public void updateSize(EntityLivingBase target, float width, float height)
    {
        updateSizeDefault(target, width, height);
    }

    /**
     * Update player's size based on given width and height
     */
    public void updateSize(EntityLivingBase target, float width, float height, float eyeFactor)
    {
        updateSizeDefault(target, width, height, eyeFactor);
    }

    public static void updateSizeDefault(EntityLivingBase target, float width, float height)
    {
        updateSizeDefault(target, width, height, 0.9F);
    }

    public static void updateSizeDefault(EntityLivingBase target, float width, float height, float eyeFactor)
    {
        /* Any lower than this, and the morph will take damage when hitting the ceiling.
         * Likewise, an eye height less than this will cause suffocation damage when standing
         * on the ground.
         * This is hard-coded in vanilla.
         */
        float minEyeToHeadDifference = 0.1F;
        height = Math.max(height, minEyeToHeadDifference * 2);

        if (target instanceof EntityPlayer && !Metamorph.disablePov.get())
        {
            float eyeHeight = height * eyeFactor;
            if (eyeHeight + minEyeToHeadDifference > height)
            {
                eyeHeight = height - minEyeToHeadDifference;
            }
            ((EntityPlayer) target).eyeHeight = eyeHeight;
        }

        /* This is a total rip-off of EntityPlayer#setSize method */
        if (width != target.width || height != target.height)
        {
            AxisAlignedBB aabb = target.getEntityBoundingBox();

            target.width = width;
            target.height = height;
            target.setEntityBoundingBox(new AxisAlignedBB(target.posX - width / 2, aabb.minY, target.posZ - width / 2, target.posX + width / 2, aabb.minY + height, target.posZ + width / 2));
        }
    }

    /* Safe shortcuts for activating action and attack */

    /**
     * Execute action with (or on) given player 
     */
    public void action(EntityLivingBase target)
    {
        if (this.getSettings().action != null)
        {
            this.getSettings().action.execute(target, this);
        }
    }

    /**
     * Attack a target 
     */
    public void attack(Entity target, EntityLivingBase source)
    {
        if (this.getSettings().attack != null)
        {
            this.getSettings().attack.attack(target, source);
        }
    }

    /**
     * <p>Used when copying morphs</p>
     * 
     * <p>
     * <b>IMPORTANT</b>: When you subclass other morphs, don't forget to override
     * their method with your own.
     * </p>
     */
    public abstract AbstractMorph create();
    
    /**
     * Clone a morph
     */
    public final AbstractMorph copy()
    {
        AbstractMorph morph = this.create();
        // If this fails, then modder forgot to override copy()
        assert(this.getClass().isInstance(morph));

        morph.copy(this);

        return morph;
    }

    /**
     * <p>Copy this {@link AbstractMorph}</p>
     * 
     * <p>
     * <b>IMPORTANT</b>: If you subclass other morphs, and your morph contains new
     * data, don't for get to override their method with your own.
     * </p>
     */
    public void copy(AbstractMorph from)
    {
        this.name = from.name;
        this.displayName = from.displayName;
        this.favorite = from.favorite;
        this.settings = from.settings != null ? from.settings.copy() : null;
        this.activeSettings = from.activeSettings != null ? from.activeSettings.copy() : null;
        this.forcedSettings = from.forcedSettings;
        this.needSettingsUpdate = from.needSettingsUpdate;
        this.keybind = from.keybind;
        this.hitbox.copy(from.hitbox);
    }

    /* Getting size */

    /**
     * Get width of this morph 
     */
    public abstract float getWidth(EntityLivingBase target);

    /**
     * Get height of this morph 
     */
    public abstract float getHeight(EntityLivingBase target);

    /**
     * Get the eye height of this morph.
     * Not used by updateSize.
     */
    public float getEyeHeight(EntityLivingBase target)
    {
        if (!Metamorph.disablePov.get())
        {
            return this.getHeight(target) * 0.9F;
        }
        else
        {
            return 1.62F;
        }
    }

    /**
     * Get the default sound that this morph makes when it
     * is hurt
     */
    public final SoundEvent getHurtSound(EntityLivingBase target)
    {
        return getHurtSound(target, SoundHandler.GENERIC_DAMAGE);
    }

    /**
     * Get the sound that this morph makes when it
     * is hurt by the given DamageSource, or return null
     * for no change.
     */
    public SoundEvent getHurtSound(EntityLivingBase target, DamageSource damageSource)
    {
        return null;
    }

    /**
     * Get the sound that this morph makes when it
     * is killed, or return null for no change.
     */
    public SoundEvent getDeathSound(EntityLivingBase target)
    {
        return null;
    }

    /**
     * Make this return true if you override playStepSound(..)
     */
    public boolean hasCustomStepSound(EntityLivingBase target)
    {
        return false;
    }

    /**
     * Plays the sound that this morph makes when it
     * takes a step, but only if hasCustomStepSound(..) returns true
     */
    public void playStepSound(EntityLivingBase target)
    {}

    /**
     * Called when the player just changed dimensions
     */
    public void onChangeDimension(EntityPlayer player, int oldDim, int currentDim)
    {}

    /**
     * Check either if given object is the same as this morph 
     */
    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof AbstractMorph)
        {
            AbstractMorph morph = (AbstractMorph) obj;

            return Objects.equals(this.name, morph.name) &&
                Objects.equals(this.displayName, morph.displayName) &&
                Objects.equals(this.hitbox, morph.hitbox) &&
                Objects.equals(this.forcedSettings ? this.settings : null, morph.forcedSettings ? morph.settings : null);
        }

        return super.equals(obj);
    }

    /**
     * Check whether the morph can be merged (this should allow 
     * overwriting of a morph instead of completely replacing it)
     */
    public boolean canMerge(AbstractMorph morph)
    {
        return false;
    }

    /**
     * Collect the data from previous morph
     */
    public void afterMerge(AbstractMorph morph)
    {}

    /**
     * Whether to activate the use target option in GUIs like BodyPart GUI by default
     * @return false by default
     */
    public boolean useTargetDefault()
    {
        return false;
    }

    /**
     * This method should be used by any morphs that support merging to copy essential
     * whenever they merge
     */
    protected void mergeBasic(AbstractMorph morph)
    {
        this.displayName = morph.displayName;
        this.settings = morph.settings;
        this.forcedSettings = morph.forcedSettings;
        this.hitbox.copy(morph.hitbox);
    }

    /**
     * Reset data for editing 
     */
    public void reset()
    {
        setActiveSettings(null);
        clearForcedSettings();
        this.hitbox.reset();
    }

    /* Reading / writing to NBT */

    public final NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        this.toNBT(tag);

        return tag;
    }

    /**
     * Save abstract morph's properties to NBT compound 
     */
    public void toNBT(NBTTagCompound tag)
    {
        tag.setString("Name", this.name);

        if (this.forcedSettings)
        {
            NBTTagCompound settings = new NBTTagCompound();

            this.getSettings().toNBT(settings);

            if (!settings.hasNoTags())
            {
                tag.setTag("Settings", settings);
            }
        }
        
    	tag.setBoolean("ForcedSettings", this.forcedSettings);

        if (this.displayName != null && !this.displayName.isEmpty())
        {
            tag.setString("DisplayName", this.displayName);
        }

        if (this.favorite)
        {
            tag.setBoolean("Favorite", this.favorite);
        }

        if (this.keybind >= 0)
        {
            tag.setInteger("Keybind", this.keybind);
        }

        if (!this.hitbox.isDefault())
        {
            tag.setTag("Hitbox", this.hitbox.toNBT());
        }
    }

    /**
     * Read abstract morph's properties from NBT compound 
     */
    public void fromNBT(NBTTagCompound tag)
    {
        this.reset();

        this.name = tag.getString("Name");
        
        boolean hasForcedSettings = false;
        if (tag.hasKey("ForcedSettings"))
        {
        	hasForcedSettings = tag.getBoolean("ForcedSettings");
        }

        if (tag.hasKey("Settings"))
        {
            this.settings = new MorphSettings();
            this.settings.fromNBT(tag.getCompoundTag("Settings"));
            
            if (hasForcedSettings)
            {
            	this.forcedSettings = true;
            }
        }

        if (tag.hasKey("DisplayName"))
        {
            this.displayName = tag.getString("DisplayName");
        }

        if (tag.hasKey("Favorite"))
        {
            this.favorite = tag.getBoolean("Favorite");
        }

        if (tag.hasKey("Keybind"))
        {
            this.keybind = tag.getInteger("Keybind");
        }

        if (tag.hasKey("Hitbox"))
        {
            this.hitbox.fromNBT(tag.getCompoundTag("Hitbox"));
        }
    }
}


==================================================

--- Файл №35 ---
Путь: main\java\mchorse\metamorph\api\morphs\EntityMorph.java
--------------------
package mchorse.metamorph.api.morphs;

import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.EntityUtils;
import mchorse.metamorph.api.MorphSettings;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.BodyPartManager;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.entity.SoundHandler;
import mchorse.metamorph.util.InvokeUtil;
import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.model.ModelQuadruped;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.layers.LayerRenderer;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityAgeable;
import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.SharedMonsterAttributes;
import net.minecraft.entity.ai.attributes.IAttributeInstance;
import net.minecraft.entity.boss.EntityDragon;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.passive.EntityAnimal;
import net.minecraft.entity.passive.EntityHorse;
import net.minecraft.entity.passive.EntityPig;
import net.minecraft.entity.passive.EntityRabbit;
import net.minecraft.entity.passive.EntityWaterMob;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumHand;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.lang3.reflect.FieldUtils;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Entity morph class
 */
public class EntityMorph extends AbstractMorph implements IBodyPartProvider
{
    /**
     * Target entity which is going to be used for nametag rendering
     */
    @SideOnly(Side.CLIENT)
    public static EntityLivingBase renderEntity;

    /**
     * Cache map for registered body part layers
     */
    @SideOnly(Side.CLIENT)
    public static Map<Render, LayerBodyPart> bodyPartMap;

    /**
     * Body part manager
     */
    public BodyPartManager parts = new BodyPartManager();

    /**
     * Entity used by this morph to power morphing
     */
    protected EntityLivingBase entity;

    /**
     * Used for constructing an entity during loop 
     */
    protected NBTTagCompound entityData;

    /**
     * Custom settings were generated by this morph 
     */
    @Deprecated
    protected boolean customSettings;

    /**
     * If the associated entity is being updated
     */
    protected boolean updatingEntity = false;

    /* Rendering */

    @SideOnly(Side.CLIENT)
    public RenderLivingBase renderer;

    /**
     * Did this instance already tried to setup first-person hands
     */
    @SideOnly(Side.CLIENT)
    public boolean triedHands;

    /**
     * Linked body part layer
     */
    @SideOnly(Side.CLIENT)
    public LayerBodyPart layer;

    /**
     * Texture of the entity 
     */
    @SideOnly(Side.CLIENT)
    public ResourceLocation texture;

    /**
     * Cached model renderer for the left hand
     */
    @SideOnly(Side.CLIENT)
    public ModelRenderer leftHand;

    /**
     * Cached model renderer for the right hand
     */
    @SideOnly(Side.CLIENT)
    public ModelRenderer rightHand;

    @SideOnly(Side.CLIENT)
    public Map<String, ModelRenderer> limbs;

    public ResourceLocation userTexture;

    public float scale = 1F;

    @SideOnly(Side.CLIENT)
    private ITextureObject lastTexture;

    @Override
    public BodyPartManager getBodyPart()
    {
        return this.parts;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        String name = this.name;

        try
        {
            name = EntityList.getEntityString(this.getEntity(Minecraft.getMinecraft().world));
        }
        catch (Exception e)
        {}

        String key = "entity." + name + ".name";
        String result = I18n.format(key);

        return key.equals(result) ? name : result;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        EntityLivingBase entity = this.getEntity(player.world);

        if (entity.height > 2)
        {
            scale *= 2 / entity.height;
        }
        else if (entity.height < 0.6)
        {
            scale *= 0.5 / entity.height;
        }

        if (this.name.equals("minecraft:ghast"))
        {
            scale = 5F;
        }
        else if (this.name.equals("minecraft:guardian") && entity.height > 1.8)
        {
            scale *= 1 / entity.height;
        }

        this.parts.initBodyParts();

        if (!this.parts.parts.isEmpty())
        {
            this.setupLimbs();
        }

        this.setupBodyPart();
        this.replaceUserTexture();

        GuiUtils.drawEntityOnScreen(x, y, scale, entity, alpha);

        this.restoreMobTexture();
    }

    @Override
    @SideOnly(Side.CLIENT)
    @SuppressWarnings("rawtypes")
    public boolean renderHand(EntityPlayer player, EnumHand hand)
    {
        if (!getSettings().hands)
        {
            return true;
        }

        if (!this.triedHands && this.renderer != null)
        {
            this.setupTexture();
            this.setupHands();
            this.triedHands = true;
        }

        if (this.renderer == null || this.texture == null || this.leftHand == null || this.rightHand == null)
        {
            return true;
        }

        this.replaceUserTexture();
        Minecraft.getMinecraft().renderEngine.bindTexture(this.texture);
        ModelBase model = this.renderer.getMainModel();

        model.swingProgress = 0.0F;
        model.setRotationAngles(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0625F, this.entity);

        GlStateManager.color(1.0F, 1.0F, 1.0F);

        if (hand.equals(EnumHand.MAIN_HAND))
        {
            float rax = this.rightHand.rotateAngleX;
            float ray = this.rightHand.rotateAngleY;
            float raz = this.rightHand.rotateAngleZ;
            float rpx = this.rightHand.rotationPointX;
            float rpy = this.rightHand.rotationPointY;
            float rpz = this.rightHand.rotationPointZ;

            this.rightHand.rotateAngleX = 0;
            this.rightHand.rotateAngleY = 0;
            this.rightHand.rotateAngleZ = 0;
            this.rightHand.rotationPointX = -6;
            this.rightHand.rotationPointY = 4;
            this.rightHand.rotationPointZ = 0;
            this.rightHand.render(0.0625F);

            this.rightHand.rotateAngleX = rax;
            this.rightHand.rotateAngleY = ray;
            this.rightHand.rotateAngleZ = raz;
            this.rightHand.rotationPointX = rpx;
            this.rightHand.rotationPointY = rpy;
            this.rightHand.rotationPointZ = rpz;
        }
        else
        {
            float rax = this.leftHand.rotateAngleX;
            float rpx = this.leftHand.rotationPointX;
            float rpy = this.leftHand.rotationPointY;
            float rpz = this.leftHand.rotationPointZ;

            this.leftHand.rotateAngleX = 0;
            this.leftHand.rotationPointX = 6;
            this.leftHand.rotationPointY = 4;
            this.leftHand.rotationPointZ = 0;
            this.leftHand.render(0.0625F);

            this.leftHand.rotateAngleX = rax;
            this.leftHand.rotationPointX = rpx;
            this.leftHand.rotationPointY = rpy;
            this.leftHand.rotationPointZ = rpz;
        }

        this.restoreMobTexture();

        return true;
    }

    @Override
    @SideOnly(Side.CLIENT)
    @SuppressWarnings({"unchecked", "rawtypes"})
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        if (entity == null)
        {
            return;
        }

        RenderLivingBase render = this.renderer;

        if (render == null)
        {
            this.getEntity(entity.world);

            render = this.renderer;
        }

        if (render != null)
        {
            /* Make transformation seamless... */
            this.entity.rotationYaw = entity.rotationYaw;
            this.entity.rotationPitch = entity.rotationPitch;
            this.entity.rotationYawHead = entity.rotationYawHead;
            this.entity.renderYawOffset = entity.renderYawOffset;

            this.entity.prevRotationYaw = entity.prevRotationYaw;
            this.entity.prevRotationPitch = entity.prevRotationPitch;
            this.entity.prevRotationYawHead = entity.prevRotationYawHead;
            this.entity.prevRenderYawOffset = entity.prevRenderYawOffset;

            this.parts.initBodyParts();

            if (!this.parts.parts.isEmpty())
            {
                this.setupLimbs();
            }

            boolean wasSneak = false;

            ModelBase model = render.getMainModel();

            if (model instanceof ModelBiped)
            {
                wasSneak = ((ModelBiped) model).isSneak;
                ((ModelBiped) model).isSneak = entity.isSneaking();
            }

            renderEntity = entity;
            this.setupBodyPart();
            this.replaceUserTexture();

            GlStateManager.pushMatrix();
            GlStateManager.translate(x, y, z);
            GlStateManager.scale(this.scale, this.scale, this.scale);

            if (this.entity instanceof EntityDragon)
            {
                GlStateManager.rotate(180, 0.0F, 1.0F, 0.0F);

                Minecraft.getMinecraft().getRenderManager().renderEntity(this.entity, 0, 0, 0, entityYaw, partialTicks, false);
            }
            else
            {
                Minecraft.getMinecraft().getRenderManager().renderEntity(this.entity, 0, 0, 0, entityYaw, partialTicks, false);
            }

            GlStateManager.popMatrix();

            this.restoreMobTexture();

            if (model instanceof ModelBiped)
            {
                ((ModelBiped) model).isSneak = wasSneak;
            }

            renderEntity = null;
        }
    }
    
    /* Entity morph settings */

    /**
     * These are settings that are defined from the morph entity.
     * They have lower priority than activeSettings.
     */
    protected MorphSettings entitySettings = null;
    
    protected void setEntitySettings(MorphSettings entitySettings) {
        this.entitySettings = entitySettings;
        this.needSettingsUpdate = true;
    }
    
    @Override
    public void initializeSettings()
    {
        if (!this.needSettingsUpdate)
        {
            return;
        }

        this.settings = MorphSettings.DEFAULT_MORPHED.copy();
        
        if (this.entitySettings != null)
        {
            this.settings.applyOverrides(this.entitySettings);
        }
        
        if (this.activeSettings != null)
        {
            this.settings.applyOverrides(this.activeSettings);
        }
        
        finishInitializingSettings();
    }

    @SideOnly(Side.CLIENT)
    protected void setupBodyPart()
    {
        if (this.layer == null)
        {
            return;
        }

        this.layer.morph = this;
    }

    @SideOnly(Side.CLIENT)
    protected void renderBodyParts(EntityLivingBase target, float partialTicks)
    {
        GlStateManager.pushMatrix();

        final float scale = 1 / 16F;

        for (BodyPart part : this.parts.parts)
        {
            for (Map.Entry<String, ModelRenderer> entry : this.limbs.entrySet())
            {
                if (entry.getKey().equals(part.limb))
                {
                    GlStateManager.pushMatrix();
                    entry.getValue().postRender(scale);
                    part.render(this, target, partialTicks);
                    GlStateManager.popMatrix();

                    break;
                }
            }
        }

        GlStateManager.popMatrix();
    }

    /**
     * This is pretty ugly, but it's the only way to replace entity's textures...
     */
    @SideOnly(Side.CLIENT)
    private void replaceUserTexture()
    {
        if (this.userTexture == null)
        {
            return;
        }

        if (this.texture == null)
        {
            this.setupTexture();
        }

        if (this.texture != null)
        {
            if (this.userTexture.equals(this.texture))
            {
                return;
            }

            TextureManager textureManager = Minecraft.getMinecraft().renderEngine;
            Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(textureManager);

            if (map != null)
            {
                ITextureObject object = map.get(this.userTexture);

                if (object == null)
                {
                    textureManager.bindTexture(this.userTexture);
                    object = map.get(this.userTexture);
                }

                if (object != null)
                {
                    this.lastTexture = map.get(this.texture);

                    if (this.lastTexture == null)
                    {
                        textureManager.bindTexture(this.texture);
                        this.lastTexture = map.get(this.texture);
                    }

                    if (this.lastTexture != null)
                    {
                        map.put(this.texture, object);
                    }
                }
            }
        }
    }

    @SideOnly(Side.CLIENT)
    private void restoreMobTexture()
    {
        if (this.lastTexture != null)
        {
            TextureManager textureManager = Minecraft.getMinecraft().renderEngine;
            Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(textureManager);

            map.put(this.texture, this.lastTexture);

            this.lastTexture = null;
        }
    }

    /* Other stuff */

    /**
     * Set entity for this morph
     */
    public void setEntity(EntityLivingBase entity)
    {
        this.entity = entity;

        entity.setHealth(entity.getMaxHealth());
        entity.noClip = true;
        entity.setAlwaysRenderNameTag(true);

        if (entity instanceof EntityLiving)
        {
            ((EntityLiving) entity).setLeftHanded(false);
        }

        MorphSettings entitySettings = new MorphSettings();
        entitySettings.health = (int)entity.getMaxHealth();
        entitySettings.hostile = entity instanceof EntityMob || entity instanceof EntityAnimal;
        IAttributeInstance speedAttribute = entity.getEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED);

        if (speedAttribute != null)
        {
            // By vanilla convention, mob movement speeds tend to be 2.5x
            // what the equivalent player speed would be.
            // Squids and players being the major exceptions.

            if ((entity instanceof EntityWaterMob))
            {
                // Check for EntityWaterMob rather than EntitySquid,
                // as EntityWaterMob would be deleted in an entity class refactor.
                entitySettings.speed = 0.1F;
            }
            else if (entity instanceof EntityPlayer)
            {
                entitySettings.speed = (float)speedAttribute.getBaseValue();
            }
            else
            {
                entitySettings.speed = 0.4F * (float)speedAttribute.getBaseValue();
            }
        }

        setEntitySettings(entitySettings);

        if (entity instanceof EntityLiving && !(entity instanceof EntityDragon))
        {
            ((EntityLiving) entity).setNoAI(true);
        }

        if (entity instanceof EntityAgeable && !entity.world.isRemote)
        {
            ((EntityAgeable) entity).setScaleForAge(entity.isChild());
        }

        if (this.entityData == null)
        {
            this.entityData = EntityUtils.stripEntityNBT(this.entity.serializeNBT());
        }
    }

    /**
     * Get used entity of this morph 
     */
    public EntityLivingBase getEntity()
    {
        return this.entity;
    }

    /**
     * Get used entity of this morph, if there's no entity, just create it with 
     * provided world.
     */
    public EntityLivingBase getEntity(World world)
    {
        if (this.entity == null)
        {
            this.setupEntity(world);
        }

        return this.entity;
    }

    @Override
    public void update(EntityLivingBase target)
    {
        if (entity == null)
        {
            this.setupEntity(target.world);
        }

        /* Update entity */
        this.updatingEntity = true;
        this.entity.setEntityInvulnerable(true);
        this.updateEntity(target);
        this.updatingEntity = false;
        this.entity.deathTime = target.deathTime;
        this.entity.hurtTime = target.hurtTime;

        if (this.entity instanceof EntityRabbit)
        {
            if (target.ticksExisted % 10 == 0 && target.limbSwingAmount > 0.4)
            {
                ((EntityRabbit) this.entity).startJumping();
            }
        }

        /* Update player */
        super.update(target);

        /* Update entity's inventory */
        if (target.world.isRemote)
        {
            int i = 0;

            for (ItemStack stack : target.getEquipmentAndArmor())
            {
                this.entity.setItemStackToSlot(EntityUtils.slotForIndex(i), stack);

                i++;
            }

            entity.setInvisible(target.isInvisible());
        }

        /* Injecting player's properties */
        this.entity.setPosition(target.posX, target.posY, target.posZ);

        this.entity.lastTickPosX = target.lastTickPosX;
        this.entity.lastTickPosY = target.lastTickPosY;
        this.entity.lastTickPosZ = target.lastTickPosZ;

        this.entity.prevPosX = target.prevPosX;
        this.entity.prevPosY = target.prevPosY;
        this.entity.prevPosZ = target.prevPosZ;

        this.entity.rotationYaw = target.rotationYaw;
        this.entity.rotationPitch = target.rotationPitch;
        this.entity.rotationYawHead = target.rotationYawHead;
        this.entity.renderYawOffset = target.renderYawOffset;

        this.entity.motionX = target.motionX;
        this.entity.motionY = target.motionY;
        this.entity.motionZ = target.motionZ;

        this.entity.isSwingInProgress = target.isSwingInProgress;
        this.entity.swingProgress = target.swingProgress;
        this.entity.limbSwing = target.limbSwing;
        this.entity.limbSwingAmount = target.limbSwingAmount;

        this.entity.prevRotationYaw = target.prevRotationYaw;
        this.entity.prevRotationPitch = target.prevRotationPitch;
        this.entity.prevRotationYawHead = target.prevRotationYawHead;
        this.entity.prevRenderYawOffset = target.prevRenderYawOffset;

        this.entity.prevSwingProgress = target.prevSwingProgress;
        this.entity.prevLimbSwingAmount = target.prevLimbSwingAmount;
        this.entity.swingingHand = target.swingingHand;

        if (this.entity instanceof EntityLiving)
        {
            ((EntityLiving) this.entity).setLeftHanded(target.getPrimaryHand() == EnumHandSide.LEFT);
        }

        if (target instanceof EntityPlayer && ((EntityPlayer) target).isCreative())
        {
            this.entity.fallDistance = 0;
        }
        else
        {
            this.entity.fallDistance = target.fallDistance;
        }

        this.entity.setSneaking(target.isSneaking());
        this.entity.setSprinting(target.isSprinting());
        this.entity.onGround = target.onGround;
        this.entity.isAirBorne = target.isAirBorne;
        this.entity.ticksExisted = target.ticksExisted;
        /* Fighting with death of entities like zombies */
        this.entity.setHealth(target.getHealth());

        if (target instanceof EntityPlayer)
        {
            IMorphing cap = Morphing.get((EntityPlayer) target);

            if (cap != null)
            {
                this.entity.setAir(cap.getHasSquidAir() ? cap.getSquidAir() : target.getAir());
            }
        }

        /* Now goes the code responsible for achieving somewhat riding 
         * support. This is ridiculous... */
        boolean targetRiding = target.isRiding();
        boolean entityRiding = this.entity.isRiding();

        if (targetRiding && !entityRiding)
        {
            this.entity.startRiding(new EntityPig(this.entity.world));
        }
        else if (!targetRiding && entityRiding)
        {
            this.entity.dismountRidingEntity();
        }

        if (targetRiding)
        {
            /* One day, this cast is going to backfire, I'll wait for it... */
            EntityPig ride = (EntityPig) this.entity.getRidingEntity();
            Entity targetRide = target.getRidingEntity();

            if (ride == null || targetRide == null)
            {
                return;
            }

            ride.rotationYaw = targetRide.rotationYaw;
            ride.rotationPitch = targetRide.rotationPitch;

            ride.prevRotationYaw = targetRide.prevRotationYaw;
            ride.prevRotationPitch = targetRide.prevRotationPitch;

            if (targetRide instanceof EntityLivingBase)
            {
                EntityLivingBase trr = (EntityLivingBase) targetRide;

                ride.rotationYawHead = trr.rotationYawHead;
                ride.renderYawOffset = trr.renderYawOffset;

                ride.prevRotationYawHead = trr.prevRotationYawHead;
                ride.prevRenderYawOffset = trr.prevRenderYawOffset;
            }
            else
            {
                ride.rotationYawHead = target.rotationYawHead;
                ride.renderYawOffset = target.renderYawOffset;

                ride.prevRotationYawHead = target.prevRotationYawHead;
                ride.prevRenderYawOffset = target.prevRenderYawOffset;
            }
        }

        if (this.entity instanceof EntityHorse)
        {
            EntityHorse horse = (EntityHorse) this.entity;

            horse.setHorseSaddled(this.entityData.hasKey("SaddleItem"));
        }

        this.parts.updateBodyLimbs(this, target);
    }

    protected void updateEntity(EntityLivingBase target)
    {
        if (getSettings().updates)
        {
            if (!Metamorph.showMorphIdleSounds.get())
            {
                this.entity.setSilent(true);
            }

            this.entity.onUpdate();
            this.entity.setSilent(false);
        }
    }

    public boolean isUpdatingEntity()
    {
        return this.updatingEntity;
    }

    @Override
    protected void updateUserHitbox(EntityLivingBase target)
    {
        float width = this.entity.width;
        float height = this.entity.height;

        boolean isAnimalChild = this.entity instanceof EntityAgeable && this.entityData.getInteger("Age") < 0;

        /* Because Minecraft is shit at syncing data!
         *
         * The problem is that Minecraft changes to correct size of baby
         * animals on the client, but on the server it doesn't change anything
         * thus I have to rely on proivded NBT data for figuring out if an
         * animal entity is being a baby */
        if (!target.world.isRemote && isAnimalChild)
        {
            width *= 0.5;
            height *= 0.5;
        }

        this.updateSize(target, width, height);
    }

    /**
     * Setup entity
     * 
     * This is responsible for setting the entity
     */
    public void setupEntity(World world)
    {
        EntityLivingBase created = (EntityLivingBase) EntityList.createEntityByIDFromName(new ResourceLocation(this.name), world);

        try
        {
            created.deserializeNBT(this.entityData);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        created.deathTime = 0;
        created.hurtTime = 0;
        created.limbSwing = 0;
        created.setFire(0);

        this.setEntity(created);

        if (world.isRemote)
        {
            this.setupRenderer();
        }
    }

    /**
     * Setup renderer
     * 
     * This method is responsible for setting up any client side stuff like 
     * the renderer, texture of the entity and the "hands"
     */
    @SideOnly(Side.CLIENT)
    protected void setupRenderer()
    {
        Render renderer = Minecraft.getMinecraft().getRenderManager().getEntityRenderObject(this.entity);

        if (renderer instanceof RenderLivingBase)
        {
            this.renderer = (RenderLivingBase) renderer;
            ModelBase model = this.renderer.getMainModel();

            if (this.entity != null && model instanceof ModelBiped || model instanceof ModelQuadruped)
            {
                // Entity settings should have been defined when setEntity(...) was called
                assert(this.entitySettings != null);
                MorphSettings entitySettings = this.entitySettings != null ? this.entitySettings : new MorphSettings();
                entitySettings.hands = true;
                setEntitySettings(entitySettings);
            }

            if (bodyPartMap == null)
            {
                bodyPartMap = new HashMap<Render, LayerBodyPart>();
            }

            this.layer = bodyPartMap.get(renderer);

            if (this.layer == null)
            {
                bodyPartMap.put(this.renderer, this.layer = new LayerBodyPart());
                this.renderer.addLayer(layer);
            }
        }
    }

    /**
     * Get the renderer's texture
     * 
     * Very hard stuff are going on here
     */
    @SideOnly(Side.CLIENT)
    @SuppressWarnings({"unchecked", "rawtypes"})
    protected void setupTexture()
    {
        if (this.texture != null)
        {
            return;
        }

        Class<RenderLivingBase> clazz = (Class<RenderLivingBase>) this.renderer.getClass();

        for (Method method : clazz.getDeclaredMethods())
        {
            Class[] args = method.getParameterTypes();

            boolean hasEntityArg = args.length == 1 && Entity.class.isAssignableFrom(args[0]);
            boolean returnsRL = method.getReturnType().isAssignableFrom(ResourceLocation.class);

            if (hasEntityArg && returnsRL)
            {
                try
                {
                    method.setAccessible(true);
                    this.texture = (ResourceLocation) method.invoke(this.renderer, this.entity);
                }
                catch (Exception e)
                {
                    Metamorph.log("Failed to get texture of a morph '" + this.name + "'!");
                    e.printStackTrace();
                }

                break;
            }
        }
    }

    /**
     * Setup this entity's hands
     * 
     * This guy is responsible for finding {@link ModelRenderer} in renderer's  
     * main model.
     */
    @SideOnly(Side.CLIENT)
    @SuppressWarnings("rawtypes")
    protected void setupHands()
    {
        ModelBase model = this.renderer.getMainModel();

        model.setRotationAngles(0, 0, 0, 0, 0, 0.0625F, this.entity);

        if (model instanceof ModelBiped)
        {
            this.leftHand = ((ModelBiped) model).bipedLeftArm;
            this.rightHand = ((ModelBiped) model).bipedRightArm;
        }
        else if (model instanceof ModelQuadruped)
        {
            this.leftHand = ((ModelQuadruped) model).leg2;
            this.rightHand = ((ModelQuadruped) model).leg3;
        }
        else
        {
            /* For anything else, pretty bad algorithm */
            List<ModelRenderer> left = new ArrayList<ModelRenderer>();
            List<ModelRenderer> right = new ArrayList<ModelRenderer>();

            left.addAll(model.boxList);
            right.addAll(model.boxList);

            Collections.sort(left, new Comparator<ModelRenderer>()
            {
                @Override
                public int compare(ModelRenderer a, ModelRenderer b)
                {
                    return (int) (a.rotationPointX - b.rotationPointX < 0 ? Math.floor(a.rotationPointX - b.rotationPointX) : Math.ceil(a.rotationPointX - b.rotationPointX));
                }
            });

            Collections.sort(right, new Comparator<ModelRenderer>()
            {
                @Override
                public int compare(ModelRenderer a, ModelRenderer b)
                {
                    return (int) (b.rotationPointX - a.rotationPointX < 0 ? Math.floor(b.rotationPointX - a.rotationPointX) : Math.ceil(b.rotationPointX - a.rotationPointX));
                }
            });

            this.leftHand = left.isEmpty() ? null : left.get(0);
            this.rightHand = right.isEmpty() ? null : right.get(0);
        }
    }

    @SideOnly(Side.CLIENT)
    public void setupLimbs()
    {
        if (this.limbs != null)
        {
            return;
        }

        ModelBase model = this.renderer.getMainModel();

        /* Setup model limbs map */
        this.limbs = new HashMap<String, ModelRenderer>();

        Field[] fields = FieldUtils.getAllFields(model.getClass());

        for (Field field : fields)
        {
            field.setAccessible(true);

            if (field.getType().isAssignableFrom(ModelRenderer.class))
            {
                try
                {
                    ModelRenderer renderer = (ModelRenderer) field.get(model);

                    this.limbs.put(field.getName(), renderer);
                }
                catch (Exception e)
                {}
            }
        }
    }

    /**
     * Set entity data 
     */
    public void setEntityData(NBTTagCompound tag)
    {
        this.entityData = tag;
    }

    /**
     * Get entity serialized {@link NBTTagCompound}
     * 
     * This method is going to be used for saving entity state to morph 
     * capability. 
     */
    public NBTTagCompound getEntityData()
    {
        return this.entityData;
    }

    /**
     * Check if this and given EntityMorphs are equal 
     */
    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof EntityMorph)
        {
            EntityMorph morph = (EntityMorph) obj;
            boolean theSame = EntityUtils.compareData(morph.entityData, this.entityData);

            result = result && theSame;
            result = result && Objects.equals(morph.parts, this.parts);
            result = result && morph.scale == this.scale;
            result = result && Objects.equals(morph.userTexture, this.userTexture);
        }

        return result;
    }

    @Override
    public void reset()
    {
        this.parts.reset();
        this.resetEntity();
        this.entityData = null;
        this.scale = 1F;
        this.userTexture = null;

        super.reset();
    }

    public void resetEntity()
    {
        if (this.entity != null)
        {
            if (this.entity.world.isRemote)
            {
                this.renderer = null;
                this.triedHands = false;
            }

            this.entity = null;
            setEntitySettings(null);
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new EntityMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof EntityMorph)
        {
            EntityMorph morph = (EntityMorph) from;
            
            this.entitySettings = this.entitySettings != null ? this.entitySettings.copy() : null;
            this.entityData = morph.entityData != null ? morph.entityData.copy() : null;
            this.parts.copy(morph.parts);
            this.scale = morph.scale;
            this.userTexture = RLUtils.clone(morph.userTexture);
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        if (this.entity == null)
        {
            this.setupEntity(target.world);
        }

        return this.entity.width;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        if (this.entity == null)
        {
            this.setupEntity(target.world);
        }

        return this.entity.height;
    }

    @Override
    public SoundEvent getHurtSound(EntityLivingBase target, DamageSource damageSource)
    {
        EntityLivingBase entity = this.getEntity(target.world);

        try
        {
            Method methodHurtSound = InvokeUtil.getPrivateMethod(entity.getClass(), EntityLivingBase.class, SoundHandler.GET_HURT_SOUND.getName(), DamageSource.class);
            SoundEvent hurtSound = (SoundEvent) methodHurtSound.invoke(entity, damageSource);
            if (hurtSound == null)
            {
                hurtSound = SoundHandler.NO_SOUND;
            }
            return hurtSound;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public SoundEvent getDeathSound(EntityLivingBase target)
    {
        EntityLivingBase entity = this.getEntity(target.world);
        try
        {
            Method methodDeathSound = InvokeUtil.getPrivateMethod(entity.getClass(), EntityLivingBase.class, SoundHandler.GET_DEATH_SOUND.getName());
            SoundEvent deathSound = (SoundEvent) methodDeathSound.invoke(entity);
            if (deathSound == null)
            {
                deathSound = SoundHandler.NO_SOUND;
            }
            return deathSound;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    @Override
    public boolean hasCustomStepSound(EntityLivingBase target)
    {
        return true;
    }

    @Override
    public void playStepSound(EntityLivingBase target)
    {
        EntityLivingBase entity = this.getEntity(target.world);
        try
        {
            Method methodPlayStep = InvokeUtil.getPrivateMethod(entity.getClass(), Entity.class, SoundHandler.PLAY_STEP_SOUND.getName(), BlockPos.class, Block.class);

            int x = MathHelper.floor(entity.posX);
            int y = MathHelper.floor(entity.posY - 0.20000000298023224D);
            int z = MathHelper.floor(entity.posZ);
            BlockPos pos = new BlockPos(x, y, z);
            Block block = entity.world.getBlockState(pos).getBlock();

            methodPlayStep.invoke(entity, pos, block);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    @Override
    public void onChangeDimension(EntityPlayer player, int oldDim, int currentDim)
    {
        if (this.entity != null)
        {
            this.entity.world = player.world;
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        tag.setTag("EntityData", this.entityData);
        tag.setFloat("Scale", this.scale);

        if (this.userTexture != null)
        {
            tag.setTag("Texture", RLUtils.writeNbt(this.userTexture));
        }

        NBTTagList bodyParts = this.parts.toNBT();

        if (bodyParts != null)
        {
            tag.setTag("BodyParts", bodyParts);
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.entityData = tag.getCompoundTag("EntityData");

        if (tag.hasKey("Scale"))
        {
            this.scale = tag.getFloat("Scale");
        }

        if (tag.hasKey("Texture"))
        {
            this.userTexture = RLUtils.create(tag.getTag("Texture"));
        }

        if (tag.hasKey("BodyParts", 9))
        {
            this.parts.fromNBT(tag.getTagList("BodyParts", 10));
        }
    }

    @SideOnly(Side.CLIENT)
    public static class LayerBodyPart implements LayerRenderer<EntityLivingBase>
    {
        public EntityMorph morph;

        @Override
        public void doRenderLayer(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
        {
            if (this.morph != null)
            {
                if (entity.isSneaking())
                {
                    GlStateManager.translate(0.0F, 0.2F, 0.0F);
                }

                this.morph.renderBodyParts(entity, 1F);
            }
        }

        @Override
        public boolean shouldCombineTextures()
        {
            return false;
        }
    }
}


==================================================

--- Файл №36 ---
Путь: main\java\mchorse\metamorph\api\morphs\utils\Animation.java
--------------------
package mchorse.metamorph.api.morphs.utils;

import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.nbt.NBTTagCompound;

public class Animation
{
    public boolean animates;
    public boolean ignored;
    public int duration = 10;
    public Interpolation interp = Interpolation.LINEAR;

    public int progress;
    public boolean paused;

    public void pause()
    {
        this.pause(0);
    }

    public void pause(int progress)
    {
        this.paused = true;
        this.progress = progress;
    }

    public float getFactor(float partialTicks)
    {
        if (!this.animates || this.duration <= 0)
        {
            return 1F;
        }

        return MathUtils.clamp((this.progress + (this.paused ? 0 : partialTicks)) / (float) this.duration, 0F, 1F);
    }

    public void reset()
    {
        this.progress = this.duration;
    }

    public void merge(Animation animation)
    {
        this.copy(animation);
        this.progress = 0;
    }

    public void copy(Animation animation)
    {
        this.animates = animation.animates;
        this.duration = animation.duration;
        this.interp = animation.interp;
        this.ignored = animation.ignored;
        this.paused = animation.paused;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Animation)
        {
            Animation animation = (Animation) obj;

            return this.animates == animation.animates &&
                this.duration == animation.duration &&
                this.ignored == animation.ignored &&
                this.interp == animation.interp;
        }

        return super.equals(obj);
    }

    public void update()
    {
        if (this.animates && !this.paused)
        {
            this.progress++;
        }
    }

    public boolean isInProgress()
    {
        return this.animates && (this.paused || this.progress < this.duration);
    }

    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        if (this.animates) tag.setBoolean("Animates", this.animates);
        if (this.ignored) tag.setBoolean("Ignored", this.ignored);
        if (this.duration != 10) tag.setInteger("Duration", this.duration);
        if (this.interp != Interpolation.LINEAR) tag.setInteger("Interp", this.interp.ordinal());

        return tag;
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Animates")) this.animates = tag.getBoolean("Animates");
        if (tag.hasKey("Ignored")) this.ignored = tag.getBoolean("Ignored");
        if (tag.hasKey("Duration")) this.duration = tag.getInteger("Duration");
        if (tag.hasKey("Interp")) this.interp = Interpolation.values()[tag.getInteger("Interp")];

        this.reset();
    }
}

==================================================

--- Файл №37 ---
Путь: main\java\mchorse\metamorph\api\morphs\utils\Hitbox.java
--------------------
package mchorse.metamorph.api.morphs.utils;

import net.minecraft.nbt.NBTTagCompound;

public class Hitbox
{
    private static final Hitbox DEFAULT = new Hitbox();

    public boolean enabled;
    public float width;
    public float height;
    public float eye;
    public float sneakingHeight;

    public Hitbox()
    {
        this.reset();
    }

    public void reset()
    {
        this.enabled = false;
        this.width = 0.6F;
        this.height = 1.8F;
        this.eye = 0.9F;
        this.sneakingHeight = 1.65F;
    }

    public void copy(Hitbox hitbox)
    {
        this.enabled = hitbox.enabled;
        this.width = hitbox.width;
        this.height = hitbox.height;
        this.eye = hitbox.eye;
        this.sneakingHeight = hitbox.sneakingHeight;
    }

    public boolean isDefault()
    {
        return this.equals(DEFAULT);
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Hitbox)
        {
            Hitbox hitbox = (Hitbox) obj;

            return this.enabled == hitbox.enabled
                && this.width == hitbox.width
                && this.height == hitbox.height
                && this.eye == hitbox.eye
                && this.sneakingHeight == hitbox.sneakingHeight;
        }

        return super.equals(obj);
    }

    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        if (this.enabled) tag.setBoolean("Enabled", true);
        if (this.width != 0.6F) tag.setFloat("Width", this.width);
        if (this.height != 0.6F) tag.setFloat("Height", this.height);
        if (this.eye != 0.6F) tag.setFloat("Eye", this.eye);
        if (this.sneakingHeight != 0.6F) tag.setFloat("Sneak", this.sneakingHeight);

        return tag;
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Enabled"))
        {
            this.enabled = tag.getBoolean("Enabled");
        }

        if (tag.hasKey("Width"))
        {
            this.width = tag.getFloat("Width");
        }

        if (tag.hasKey("Height"))
        {
            this.height = tag.getFloat("Height");
        }

        if (tag.hasKey("Eye"))
        {
            this.eye = tag.getFloat("Eye");
        }

        if (tag.hasKey("Sneak"))
        {
            this.sneakingHeight = tag.getFloat("Sneak");
        }
    }
}

==================================================

--- Файл №38 ---
Путь: main\java\mchorse\metamorph\api\morphs\utils\IAnimationProvider.java
--------------------
package mchorse.metamorph.api.morphs.utils;

public interface IAnimationProvider
{
    public Animation getAnimation();
}

==================================================

--- Файл №39 ---
Путь: main\java\mchorse\metamorph\api\morphs\utils\IMorphGenerator.java
--------------------
package mchorse.metamorph.api.morphs.utils;

import mchorse.metamorph.api.morphs.AbstractMorph;

public interface IMorphGenerator
{
    public boolean canGenerate();

    public AbstractMorph genCurrentMorph(float partialTicks);
}


==================================================

--- Файл №40 ---
Путь: main\java\mchorse\metamorph\api\morphs\utils\ISyncableMorph.java
--------------------
package mchorse.metamorph.api.morphs.utils;

import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.IBodyPartProvider;

public interface ISyncableMorph
{
    public void pause(AbstractMorph previous, int offset);

    public boolean isPaused();

    default public void resume()
    {
        Object morph = this;

        if (morph instanceof IMorphProvider)
        {
            morph = ((IMorphProvider) morph).getMorph();
        }
        
        if (morph instanceof IAnimationProvider)
        {
            ((IAnimationProvider) morph).getAnimation().paused = false;
        }
        
        if (morph instanceof IBodyPartProvider)
        {
            for (BodyPart part : ((IBodyPartProvider) morph).getBodyPart().parts)
            {
                if (!part.morph.isEmpty() && part.morph.get() instanceof ISyncableMorph)
                {
                    ((ISyncableMorph) part.morph.get()).resume();
                }
            }
        }
    }
}

==================================================

--- Файл №41 ---
Путь: main\java\mchorse\metamorph\bodypart\BodyPart.java
--------------------
package mchorse.metamorph.bodypart;

import javax.vecmath.Matrix3f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.utils.ITransformationObject;
import mchorse.mclib.utils.RenderingUtils;
import org.lwjgl.opengl.GL11;

import com.google.common.base.Objects;

import mchorse.mclib.client.Draw;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.NBTUtils;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * Morph body part
 */
public class BodyPart implements ITransformationObject
{
    public static Vector3f cachedTranslation = new Vector3f();
    public static Vector3f cachedAngularVelocity = new Vector3f();
    public static Matrix4f modelViewMatrix = new Matrix4f();
    public static boolean recording = false;

    public Morph morph = new Morph();
    public ItemStack[] slots = new ItemStack[] {ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY};
    public Vector3f translate = new Vector3f();
    public Vector3f scale = new Vector3f(1, 1, 1);
    public Vector3f rotate = new Vector3f(180, 0, 0);
    public boolean useTarget = false;
    public boolean enabled = true;
    public boolean animate = true;
    public String limb = "";

    private EntityLivingBase entity;

    private Vector3f lastTranslate;
    private Vector3f lastScale;
    private Vector3f lastRotate;
    private Vector3f previousRotation = new Vector3f();
    
    public Matrix4f lastMatrix = null;

    @SideOnly(Side.CLIENT)
    public static void recordMatrix(AbstractMorph parent, EntityLivingBase entity, float partialTicks)
    {
        recording = true;

        int lastMatrixMode = GL11.glGetInteger(GL11.GL_MATRIX_MODE);
        GL11.glMatrixMode(GL11.GL_MODELVIEW);

        GL11.glPushMatrix();
        GL11.glLoadIdentity();
        MorphUtils.renderDirect(parent, entity, 0, 0, 0, 0, partialTicks);
        GL11.glPopMatrix();

        GL11.glMatrixMode(lastMatrixMode);

        recording = false;
    }

    @SideOnly(Side.CLIENT)
    public void init()
    {
        this.entity = new DummyEntity(Minecraft.getMinecraft().world);
        this.entity.rotationYaw = this.entity.prevRotationYaw;
        this.entity.rotationYawHead = this.entity.prevRotationYawHead;
        this.entity.onGround = true;

        this.updateEntity();
    }

    @SideOnly(Side.CLIENT)
    public void updateEntity()
    {
        if (this.entity == null)
        {
            return;
        }

        for (int i = 0; i < this.slots.length; i++)
        {
            this.entity.setItemStackToSlot(EntityEquipmentSlot.values()[i], this.slots[i]);
        }
    }

    @Override
    public void addTranslation(double x, double y, double z, GuiTransformations.TransformOrientation orientation)
    {
        Vector4f trans = new Vector4f((float) x,(float) y,(float) z, 1);

        if (orientation == GuiTransformations.TransformOrientation.LOCAL)
        {
            float rotX = (float) Math.toRadians(this.rotate.x);
            float rotY = (float) Math.toRadians(this.rotate.y);
            float rotZ = (float) Math.toRadians(this.rotate.z);

            MatrixUtils.getRotationMatrix(rotX, rotY, rotZ, MatrixUtils.RotationOrder.XYZ).transform(trans);
        }

        this.translate.add(new Vector3f(trans.x, trans.y, trans.z));
    }

    @SideOnly(Side.CLIENT)
    public void render(AbstractMorph parent, EntityLivingBase entity, float partialTicks)
    {
    	if (recording)
    	{
    		this.lastMatrix = MatrixUtils.readModelView(new Matrix4f());
    		return;
    	}
    	
        entity = this.useTarget ? entity : this.entity;

        if (this.morph.get() == null || entity == null || !this.enabled)
        {
            return;
        }

        Animation animation = parent instanceof IAnimationProvider ? ((IAnimationProvider) parent).getAnimation() : null;

        float tx = this.translate.x;
        float ty = this.translate.y;
        float tz = this.translate.z;
        float sx = this.scale.x;
        float sy = this.scale.y;
        float sz = this.scale.z;
        float rx = this.rotate.x;
        float ry = this.rotate.y;
        float rz = this.rotate.z;

        if (animation != null && animation.isInProgress() && this.lastTranslate != null && this.animate)
        {
            Interpolation inter = animation.interp;
            float factor = animation.getFactor(partialTicks);

            tx = inter.interpolate(this.lastTranslate.x, tx, factor);
            ty = inter.interpolate(this.lastTranslate.y, ty, factor);
            tz = inter.interpolate(this.lastTranslate.z, tz, factor);
            sx = inter.interpolate(this.lastScale.x, sx, factor);
            sy = inter.interpolate(this.lastScale.y, sy, factor);
            sz = inter.interpolate(this.lastScale.z, sz, factor);
            rx = inter.interpolate(this.lastRotate.x, rx, factor);
            ry = inter.interpolate(this.lastRotate.y, ry, factor);
            rz = inter.interpolate(this.lastRotate.z, rz, factor);
        }

        if (!this.morph.isEmpty())
        {
            MatrixUtils.Transformation modelView = new MatrixUtils.Transformation();

            if (MatrixUtils.matrix != null)
            {
                modelView = MatrixUtils.extractTransformations(MatrixUtils.matrix, MatrixUtils.readModelView(modelViewMatrix));
            }

            /* translation */

            this.morph.get().cachedTranslation.set(cachedTranslation);

            Vector3f translate = new Vector3f(tx, ty, tz);
            Matrix3f transformation = new Matrix3f(modelView.getRotation3f());

            transformation.mul(modelView.getScale3f());
            transformation.transform(translate);

            this.morph.get().cachedTranslation.add(translate);

            /* angular velocity */
            /*Matrix3f rotation1 = MatrixUtils.getZYXrotationMatrix(rx, ry, rz);
            Matrix3f rotation0 = MatrixUtils.getZYXrotationMatrix(this.previousRotation.x, this.previousRotation.y, this.previousRotation.z);
            rotation0.invert();
            rotation1.mul(rotation0);
            this.morph.get().angularVelocity.set(MatrixUtils.getAngularVelocity(rotation1));
            this.morph.get().angularVelocity.add(cachedAngularVelocity);
            if (this.morph.get().age != this.lastAge) this.previousRotation.set(rx, ry, rz);
            this.lastAge = this.morph.get().age;*/
        }

        cachedTranslation.set(0,0,0);
        //cachedAngularVelocity.set(0,0,0);

        GL11.glPushMatrix();
        GL11.glTranslatef(tx, ty, tz);

        GL11.glRotatef(rz, 0, 0, 1);
        GL11.glRotatef(ry, 0, 1, 0);
        GL11.glRotatef(rx, 1, 0, 0);

        GL11.glScalef(sx, sy, sz);

        float yaw = entity.rotationYaw;
        float prevYaw = entity.prevRotationYaw;
        float rotationYaw = entity.renderYawOffset;
        float prevRotationYaw = entity.prevRenderYawOffset;
        float rotationYawHead = entity.rotationYawHead;
        float prevRotationYawHead = entity.prevRotationYawHead;

        entity.rotationYaw = entity.rotationYaw - entity.renderYawOffset;
        entity.prevRotationYaw = entity.prevRotationYaw - entity.prevRenderYawOffset;
        entity.rotationYawHead = entity.rotationYawHead - entity.renderYawOffset;
        entity.prevRotationYawHead = entity.prevRotationYawHead - entity.prevRenderYawOffset;
        entity.renderYawOffset = entity.prevRenderYawOffset = 0;

        MorphUtils.render(this.morph.get(), entity, 0, 0, 0, 0, partialTicks);

        this.drawAxis();

        entity.rotationYaw = yaw;
        entity.prevRotationYaw = prevYaw;
        entity.renderYawOffset = rotationYaw;
        entity.prevRenderYawOffset = prevRotationYaw;
        entity.rotationYawHead = rotationYawHead;
        entity.prevRotationYawHead = prevRotationYawHead;

        GL11.glPopMatrix();
    }

    protected void drawAxis()
    {
        List<GuiBodyPartEditor> childList = GuiBase.getCurrentChildren(GuiBodyPartEditor.class);

        /* Draw axis point for body part renderer */
        if (GuiModelRenderer.isRendering() && childList != null && childList.get(0).isSelected(this))
        {
            GlStateManager.pushMatrix();

            if (GuiTransformations.GuiStaticTransformOrientation.getOrientation() == GuiTransformations.TransformOrientation.GLOBAL)
            {
                Vector3d rot = new Vector3d(Math.toRadians(this.rotate.x), Math.toRadians(this.rotate.y), Math.toRadians(this.rotate.z));

                RenderingUtils.glRevertRotationScale(rot, new Vector3d(this.scale), MatrixUtils.RotationOrder.XYZ);
            }

            GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
            GlStateManager.disableTexture2D();
            GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
            GlStateManager.disableTexture2D();

            GlStateManager.disableDepth();
            GlStateManager.disableLighting();

            Draw.point(0, 0, 0);

            if (Metamorph.renderBodyPartAxis.get())
            {
                Draw.axis(0.2F);
            }

            GlStateManager.popMatrix();

            GlStateManager.enableLighting();
            GlStateManager.enableDepth();

            GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
            GlStateManager.enableTexture2D();
            GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
            GlStateManager.enableTexture2D();
        }
    }

    public void update(AbstractMorph parent, EntityLivingBase entity)
    {
        entity = this.useTarget ? entity : this.entity;

        if (entity != null && this.enabled)
        {
            if (!this.useTarget)
            {
                this.entity.ticksExisted++;
            }

            AbstractMorph morph = this.morph.get();

            if (morph != null)
            {
                float rotationYaw = entity.renderYawOffset;
                float prevRotationYaw = entity.prevRenderYawOffset;
                float rotationYawHead = entity.rotationYawHead;
                float prevRotationYawHead = entity.prevRotationYawHead;

                entity.rotationYawHead = entity.rotationYawHead - entity.renderYawOffset;
                entity.prevRotationYawHead = entity.prevRotationYawHead - entity.prevRenderYawOffset;
                entity.renderYawOffset = entity.prevRenderYawOffset = 0;

                morph.update(entity);

                entity.renderYawOffset = rotationYaw;
                entity.prevRenderYawOffset = prevRotationYaw;
                entity.rotationYawHead = rotationYawHead;
                entity.prevRotationYawHead = prevRotationYawHead;
            }
        }
    }

    public boolean canMerge(BodyPart part)
    {
        this.morph.set(part.morph.copy());

        if (Objects.equal(this.limb, part.limb))
        {
            this.lastTranslate = new Vector3f(this.translate);
            this.lastScale = new Vector3f(this.scale);
            this.lastRotate = new Vector3f(this.rotate);
        }
        else
        {
            this.lastTranslate = null;
            this.lastScale = null;
            this.lastRotate = null;
        }

        this.translate.set(part.translate);
        this.scale.set(part.scale);
        this.rotate.set(part.rotate);
        this.useTarget = part.useTarget;
        this.enabled = part.enabled;
        this.animate = part.animate;

        for (int i = 0; i < part.slots.length; i++)
        {
            this.slots[i] = part.slots[i];
        }

        this.limb = part.limb;

        return true;
    }

    public void pause(BodyPart previous, int offset)
    {
        if (previous != null && Objects.equal(this.limb, previous.limb))
        {
            this.lastTranslate = new Vector3f(previous.translate);
            this.lastScale = new Vector3f(previous.scale);
            this.lastRotate = new Vector3f(previous.rotate);
        }

        MorphUtils.pause(this.morph.get(), previous == null ? null : previous.morph.get(), offset);
    }

    public BodyPart genCurrentBodyPart(AbstractMorph morph, float partialTicks)
    {
        BodyPart part = this.copy();

        if (morph instanceof IAnimationProvider)
        {
            Animation animation = ((IAnimationProvider) morph).getAnimation();

            if (animation.isInProgress() && this.lastTranslate != null && this.animate)
            {
                Interpolation inter = animation.interp;
                float factor = animation.getFactor(partialTicks);

                part.translate.x = inter.interpolate(this.lastTranslate.x, this.translate.x, factor);
                part.translate.y = inter.interpolate(this.lastTranslate.y, this.translate.y, factor);
                part.translate.z = inter.interpolate(this.lastTranslate.z, this.translate.z, factor);
                part.scale.x = inter.interpolate(this.lastScale.x, this.scale.x, factor);
                part.scale.y = inter.interpolate(this.lastScale.y, this.scale.y, factor);
                part.scale.z = inter.interpolate(this.lastScale.z, this.scale.z, factor);
                part.rotate.x = inter.interpolate(this.lastRotate.x, this.rotate.x, factor);
                part.rotate.y = inter.interpolate(this.lastRotate.y, this.rotate.y, factor);
                part.rotate.z = inter.interpolate(this.lastRotate.z, this.rotate.z, factor);
            }
        }

        if (this.morph.get() instanceof IMorphGenerator)
        {
            IMorphGenerator generator = (IMorphGenerator) this.morph.get();

            if (generator.canGenerate())
            {
                part.morph.setDirect(generator.genCurrentMorph(partialTicks));
            }
        }

        return part;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof BodyPart)
        {
            BodyPart part = (BodyPart) obj;

            result = Objects.equal(this.morph, part.morph);
            result = result && Objects.equal(this.translate, part.translate);
            result = result && Objects.equal(this.scale, part.scale);
            result = result && Objects.equal(this.rotate, part.rotate);
            result = result && this.useTarget == part.useTarget;
            result = result && this.enabled == part.enabled;
            result = result && this.animate == part.animate;

            for (int i = 0; i < this.slots.length; i++)
            {
                result = result && ItemStack.areItemStacksEqual(this.slots[i], part.slots[i]);
            }

            result = result && Objects.equal(this.limb, part.limb);
        }

        return result;
    }

    public BodyPart copy()
    {
        BodyPart part = new BodyPart();

        part.morph.copy(this.morph);
        part.translate.set(this.translate);
        part.scale.set(this.scale);
        part.rotate.set(this.rotate);
        part.useTarget = this.useTarget;
        part.enabled = this.enabled;
        part.animate = this.animate;

        for (int i = 0; i < this.slots.length; i++)
        {
            part.slots[i] = this.slots[i];
        }

        part.limb = this.limb;

        return part;
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Morph", 10))
        {
            this.morph.fromNBT(tag.getCompoundTag("Morph"));
        }

        if (tag.hasKey("Items", 9))
        {
            NBTTagList items = tag.getTagList("Items", 10);

            for (int i = 0, c = items.tagCount(); i < c; i++)
            {
                NBTTagCompound compound = items.getCompoundTagAt(i);
                ItemStack stack = new ItemStack(compound);

                this.slots[i] = stack;
            }
        }

        NBTUtils.readFloatList(tag.getTagList("T", 5), this.translate);
        NBTUtils.readFloatList(tag.getTagList("S", 5), this.scale);
        NBTUtils.readFloatList(tag.getTagList("R", 5), this.rotate);

        if (tag.hasKey("Target")) this.useTarget = tag.getBoolean("Target");
        if (tag.hasKey("Enabled")) this.enabled = tag.getBoolean("Enabled");
        if (tag.hasKey("Animate")) this.animate = tag.getBoolean("Animate");
        if (tag.hasKey("Limb")) this.limb = tag.getString("Limb");
    }

    public void toNBT(NBTTagCompound tag)
    {
        NBTTagCompound morph = this.morph.toNBT();

        if (morph != null)
        {
            tag.setTag("Morph", morph);
        }

        NBTTagList list = new NBTTagList();
        int empty = 0;

        for (int i = 0; i < this.slots.length; i++)
        {
            NBTTagCompound compound = new NBTTagCompound();
            ItemStack stack = this.slots[i];

            if (!stack.isEmpty())
            {
                stack.writeToNBT(compound);
            }
            else
            {
                empty += 1;
            }

            list.appendTag(compound);
        }

        if (empty != this.slots.length)
        {
            tag.setTag("Items", list);
        }

        if (this.translate.x != 0 || this.translate.y != 0 || this.translate.z != 0)
        {
            tag.setTag("T", NBTUtils.writeFloatList(new NBTTagList(), this.translate));
        }

        if (this.scale.x != 1 || this.scale.y != 1 || this.scale.z != 1)
        {
            tag.setTag("S", NBTUtils.writeFloatList(new NBTTagList(), this.scale));
        }

        if (this.rotate.x != 180 || this.rotate.y != 0 || this.rotate.z != 0)
        {
            tag.setTag("R", NBTUtils.writeFloatList(new NBTTagList(), this.rotate));
        }

        if (this.useTarget) tag.setBoolean("Target", this.useTarget);
        if (!this.enabled) tag.setBoolean("Enabled", this.enabled);
        if (!this.animate) tag.setBoolean("Animate", this.animate);
        if (!this.limb.isEmpty()) tag.setString("Limb", this.limb);
    }
}

==================================================

--- Файл №42 ---
Путь: main\java\mchorse\metamorph\bodypart\BodyPartManager.java
--------------------
package mchorse.metamorph.bodypart;

import java.util.ArrayList;
import java.util.List;

import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Body part manager
 * 
 * Simplifies management of body parts for mods that use it. Besides 
 * that it allows in the future to implement different types of body 
 * parts such as particle body part...
 */
public class BodyPartManager
{
    /**
     * List of body parts (on client side only)
     */
    public List<BodyPart> parts = new ArrayList<BodyPart>();

    /**
     * Whether body parts were initiated 
     */
    private boolean initiated;

    /**
     * Reset initiated state
     */
    public void reset()
    {
        this.initiated = false;
    }

    @SideOnly(Side.CLIENT)
    public void reinitBodyParts()
    {
        this.reset();
        this.initBodyParts();
    }

    @SideOnly(Side.CLIENT)
    public void initBodyParts()
    {
        if (!this.initiated)
        {
            for (BodyPart part : this.parts)
            {
                part.init();
            }

            this.initiated = true;
        }
    }

    /**
     * Update body limbs 
     */
    public void updateBodyLimbs(AbstractMorph parent, EntityLivingBase target)
    {
        for (BodyPart part : this.parts)
        {
            part.update(parent, target);
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof BodyPartManager)
        {
            BodyPartManager manager = (BodyPartManager) obj;

            return this.parts.equals(manager.parts);
        }

        return super.equals(obj);
    }

    public void copy(BodyPartManager manager)
    {
        this.reset();
        this.parts.clear();

        for (BodyPart part : manager.parts)
        {
            this.parts.add(part.copy());
        }
    }

    public void merge(BodyPartManager manager)
    {
        this.initiated = false;

        for (int i = 0, c = manager.parts.size(); i < c; i++)
        {
            BodyPart part = i < this.parts.size() ? this.parts.get(i) : null;
            BodyPart other = manager.parts.get(i);

            if (part == null)
            {
                this.parts.add(other);
            }
            else if (!part.canMerge(other))
            {
                this.parts.set(i, other.copy());
            }
        }

        this.ensureCount(manager.parts.size());
    }

    public void afterMerge(BodyPartManager manager)
    {
        if (manager.parts.size() != this.parts.size())
        {
            this.copy(manager);

            return;
        }

        for (int i = 0, c = this.parts.size(); i < c; i++)
        {
            BodyPart part = this.parts.get(i);
            BodyPart other = manager.parts.get(i);

            if (part.morph.isEmpty() || other.morph.isEmpty())
            {
                continue;
            }

            part.morph.get().afterMerge(other.morph.get());
        }
    }

    public void pause(AbstractMorph previous, int offset)
    {
        BodyPartManager parts = previous instanceof IBodyPartProvider ? ((IBodyPartProvider) previous).getBodyPart() : null;

        for (int i = 0; i < this.parts.size(); i++)
        {
            BodyPart current = this.parts.get(i);
            BodyPart past = null;

            if (parts != null)
            {
                past = i < parts.parts.size() ? parts.parts.get(i) : null;
            }

            current.pause(past, offset);
        }
    }

    private void ensureCount(int count)
    {
        count = Math.max(count, 0);

        while (this.parts.size() > count)
        {
            this.parts.remove(this.parts.size() - 1);
        }
    }

    /* NBT */

    public NBTTagList toNBT()
    {
        if (!this.parts.isEmpty())
        {
            NBTTagList bodyParts = new NBTTagList();

            for (BodyPart part : this.parts)
            {
                NBTTagCompound bodyPart = new NBTTagCompound();

                part.toNBT(bodyPart);

                if (!bodyPart.hasNoTags())
                {
                    bodyParts.appendTag(bodyPart);
                }
            }

            return bodyParts;
        }

        return null;
    }

    public void fromNBT(NBTTagList bodyParts)
    {
        this.parts.clear();

        for (int i = 0, c = bodyParts.tagCount(); i < c; i++)
        {
            NBTTagCompound bodyPart = bodyParts.getCompoundTagAt(i);
            BodyPart part = new BodyPart();

            part.fromNBT(bodyPart);
            this.parts.add(part);
        }
    }
}

==================================================

--- Файл №43 ---
Путь: main\java\mchorse\metamorph\bodypart\GuiBodyPartEditor.java
--------------------
package mchorse.metamorph.bodypart;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.MatrixUtils.Transformation;
import mchorse.mclib.utils.MatrixUtils.RotationOrder;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList.OnionSkin;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;

import com.google.common.collect.ImmutableList;

@SideOnly(Side.CLIENT)
public class GuiBodyPartEditor extends GuiMorphPanel<AbstractMorph, GuiAbstractMorph>
{
    public static List<BodyPart> buffer = new ArrayList<BodyPart>();

    protected GuiBodyPartListElement bodyParts;
    protected GuiNestedEdit pickMorph;
    protected GuiToggleElement useTarget;
    protected GuiToggleElement enabled;
    protected GuiToggleElement animate;

    protected GuiIconElement add;
    protected GuiIconElement dupe;
    protected GuiIconElement remove;
    protected GuiIconElement copy;
    protected GuiIconElement paste;

    protected GuiBodyPartTransformations transformations;

    protected GuiStringListElement limbs;
    protected GuiElement elements;
    protected GuiElement bottomEditor;

    protected BodyPartManager parts;
    protected BodyPart part;

    protected GuiElement stacks;
    protected GuiSlotElement[] slots = new GuiSlotElement[6];

    public GuiBodyPartEditor(Minecraft mc, GuiAbstractMorph editor)
    {
        super(mc, editor);

        this.limbs = new GuiStringListElement(mc, (str) -> this.pickLimb(str.get(0)));
        this.limbs.background();

        this.bodyParts = new GuiBodyPartListElement(mc, (part) -> this.setPart(part.isEmpty() ? null : part.get(0)));
        this.bodyParts.background().sorting();
        this.bodyParts.context(this::bodyPartContextMenu);

        this.pickMorph = new GuiNestedEdit(mc, (editing) ->
        {
            BodyPart part = this.part;
            GuiCreativeMorphsList morphs = this.editor.morphs;
            OnionSkin skin = this.generateOnionSkin(part);

            morphs.nestEdit(part.morph.get(), editing, (morph) ->
            {
                if (part != null)
                {
                    AbstractMorph copy = MorphUtils.copy(morph);

                    part.morph.setDirect(copy);
                    this.applyUseTarget(part, copy);
                }
            });

            if (skin != null)
            {
                morphs.lastOnionSkins = ImmutableList.<OnionSkin>of(skin);
            }
        });

        this.add = new GuiIconElement(mc, Icons.ADD, this::addPart);
        this.add.tooltip(IKey.lang("metamorph.gui.body_parts.add_tooltip"));
        this.add.flex().w(20);
        this.dupe = new GuiIconElement(mc, Icons.DUPE, this::dupePart);
        this.dupe.tooltip(IKey.lang("metamorph.gui.body_parts.dupe_tooltip"));
        this.remove = new GuiIconElement(mc, Icons.REMOVE, this::removePart);
        this.remove.tooltip(IKey.lang("metamorph.gui.body_parts.remove_tooltip"));
        this.copy = new GuiIconElement(mc, Icons.COPY, this::copyParts);
        this.copy.tooltip(IKey.lang("metamorph.gui.body_parts.copy_tooltip"));
        this.paste = new GuiIconElement(mc, Icons.PASTE, this::pasteParts);
        this.paste.tooltip(IKey.lang("metamorph.gui.body_parts.paste_tooltip"));
        this.paste.flex().w(20);

        this.useTarget = new GuiToggleElement(mc, IKey.lang("metamorph.gui.body_parts.use_target"), false, this::toggleTarget);
        this.enabled = new GuiToggleElement(mc, IKey.lang("metamorph.gui.body_parts.enabled"), false, this::toggleEnabled);
        this.animate = new GuiToggleElement(mc, IKey.lang("metamorph.gui.body_parts.animate"), false, this::toggleAnimate);
        this.animate.tooltip(IKey.lang("metamorph.gui.body_parts.animate_tooltip"), Direction.LEFT);
        this.transformations = new GuiBodyPartTransformations(mc);

        int width = 110;

        GuiElement sidebar = new GuiElement(mc);

        sidebar.flex().relative(this).x(10).y(1, -30).wh(width, 20).row(0).height(20);
        sidebar.add(this.add, this.dupe, this.remove, this.copy, this.paste);

        this.bottomEditor = new GuiElement(mc);
        this.bottomEditor.flex().relative(this).x(1, -115).y(1, -10).w(width).anchorY(1F);
        this.bottomEditor.flex().column(5).vertical().stretch();
        this.bottomEditor.add(this.enabled, this.animate, this.useTarget);

        this.transformations.flex().relative(this.area).x(0.5F, -128).y(1, -10).wh(256, 70).anchorY(1F);
        this.limbs.flex().relative(this).set(0, 50, width, 90).x(1, -115).hTo(this.bottomEditor.area, -5);
        this.pickMorph.flex().relative(this).set(0, 10, width, 20).x(1, -115);
        this.bodyParts.flex().relative(this).set(10, 22, width, 0).hTo(this.transformations.flex(), 1F, -20);

        this.elements = new GuiElement(mc).noCulling();
        this.elements.add(this.bottomEditor, this.limbs, this.pickMorph, this.transformations);
        this.add(sidebar, this.bodyParts, this.elements);

        /* Inventory */
        this.stacks = new GuiElement(mc);
        this.stacks.flex().relative(this).x(0.5F).y(10).anchor(0.5F, 0).row(5).resize();

        for (int i = 0; i < this.slots.length; i++)
        {
            int slot = i;

            this.slots[i] = new GuiSlotElement(mc, i, (stack) -> this.pickItem(stack, slot));
            this.stacks.add(this.slots[i]);
        }

        this.elements.add(this.stacks);

        this.bodyParts.keys().register(IKey.lang("metamorph.gui.body_parts.keys.select_prev"), Keyboard.KEY_UP, () -> this.moveIndex(-1)).category(GuiAbstractMorph.KEY_CATEGORY);
        this.bodyParts.keys().register(IKey.lang("metamorph.gui.body_parts.keys.select_next"), Keyboard.KEY_DOWN, () -> this.moveIndex(1)).category(GuiAbstractMorph.KEY_CATEGORY);
    }

    /**
     * @param part
     * @return true if the provided instance reference matches the current selected bodypart
     */
    public boolean isSelected(BodyPart part)
    {
        return part == this.part;
    }

    private void applyUseTarget(BodyPart part, AbstractMorph copy)
    {
        if (copy == null)
        {
            return;
        }

        if (copy.useTargetDefault())
        {
            part.useTarget = true;
            this.useTarget.toggled(part.useTarget);
        }
    }

    private GuiContextMenu bodyPartContextMenu()
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(mc);
        String text = GuiScreen.getClipboardString();
        BodyPart part = null;

        try
        {
            NBTTagCompound tag = JsonToNBT.getTagFromJson(text);

            part = new BodyPart();
            part.fromNBT(tag);
        }
        catch (Exception e)
        {}

        if (!this.bodyParts.isDeselected())
        {
            menu.action(Icons.COPY, IKey.lang("metamorph.gui.body_parts.context.copy"), () ->
            {
                NBTTagCompound tag = new NBTTagCompound();

                this.bodyParts.getCurrentFirst().toNBT(tag);
                GuiScreen.setClipboardString(tag.toString());
            });
        }

        if (part != null)
        {
            final BodyPart destination = part;

            menu.action(Icons.PASTE, IKey.lang("metamorph.gui.body_parts.context.paste"), () -> this.addPart(destination.copy()));
        }

        return menu.actions.getList().isEmpty() ? null : menu;
    }

    private OnionSkin generateOnionSkin(BodyPart part)
    {
        EntityLivingBase entity = this.editor.renderer.getEntity();

        entity.prevRotationPitch = entity.rotationPitch = 0;
        entity.prevRotationYawHead = entity.rotationYawHead = 0;
        entity.prevRenderYawOffset = entity.renderYawOffset = 0;

        part.lastMatrix = null;
        BodyPart.recordMatrix(this.morph, entity, 0F);
        Matrix4f last = part.lastMatrix;

        if (last != null)
        {
            Matrix4f transform = new Matrix4f();

            transform.setIdentity();
            transform.setTranslation(part.translate);
            last.mul(transform);
            transform.rotZ((float) Math.toRadians(part.rotate.z));
            last.mul(transform);
            transform.rotY((float) Math.toRadians(part.rotate.y));
            last.mul(transform);
            transform.rotX((float) Math.toRadians(part.rotate.x));
            last.mul(transform);
            transform.setIdentity();
            transform.m00 = part.scale.x;
            transform.m11 = part.scale.y;
            transform.m22 = part.scale.z;
            last.mul(transform);

            transform.setIdentity();
            Transformation extract = MatrixUtils.extractTransformations(last, transform);

            if (extract.getCreationException() == null)
            {
                Vector3f rotate = extract.getRotation(RotationOrder.XYZ);

                if (rotate != null)
                {
                    TransformedOnionSkinMorph morph = new TransformedOnionSkinMorph();

                    Vector3f vec = extract.getTranslation3f();
                    morph.translate[0] = vec.x;
                    morph.translate[1] = vec.y;
                    morph.translate[2] = vec.z;

                    vec = rotate;
                    morph.rotate[0] = vec.x;
                    morph.rotate[1] = vec.y;
                    morph.rotate[2] = vec.z;

                    vec = extract.getScale();
                    morph.scale[0] = vec.x;
                    morph.scale[1] = vec.y;
                    morph.scale[2] = vec.z;

                    boolean enabled = part.enabled;

                    part.enabled = false;

                    AbstractMorph copy = this.morph.copy();

                    if (copy instanceof IAnimationProvider)
                    {
                        ((IAnimationProvider) copy).getAnimation().animates = false;
                    }

                    morph.morph = copy;

                    part.enabled = enabled;

                    return new OnionSkin().morph(morph).color(0.5F, 0.5F, 0.5F, 0.5F);
                }
            }
        }

        return null;
    }

    protected void addPart(GuiIconElement b)
    {
        BodyPart part = new BodyPart();

        this.setupNewBodyPart(part);
        this.addPart(part);
    }

    protected void addPart(BodyPart part)
    {
        part.init();

        this.parts.parts.add(part);
        this.setPart(part);

        this.bodyParts.setCurrentDirect(part);
        this.bodyParts.update();
    }

    protected void setupNewBodyPart(BodyPart part)
    {}

    protected void dupePart(GuiIconElement b)
    {
        if (this.bodyParts.isDeselected())
        {
            return;
        }

        BodyPart part = this.bodyParts.getCurrentFirst().copy();

        part.init();

        this.parts.parts.add(part);
        this.setPart(part);

        this.bodyParts.setCurrentDirect(part);
        this.bodyParts.update();
    }

    protected void removePart(GuiIconElement b)
    {
        if (this.bodyParts.isDeselected())
        {
            return;
        }

        List<BodyPart> parts = this.parts.parts;
        int index = -1;

        for (int i = 0; i < parts.size(); i ++)
        {
            if (parts.get(i) == this.part)
            {
                index = i;

                break;
            }
        }

        if (index != -1)
        {
            parts.remove(this.part);
            this.bodyParts.update();
            index--;

            if (parts.size() >= 1)
            {
                this.setPart(parts.get(MathUtils.clamp(index, 0, parts.size() - 1)));
            }
            else
            {
                this.setPart(null);
            }
        }

        this.bodyParts.update();
    }

    protected void copyParts(GuiIconElement b)
    {
        buffer.clear();

        for (BodyPart part : this.parts.parts)
        {
            buffer.add(part.copy());
        }
    }

    protected void pasteParts(GuiIconElement b)
    {
        for (BodyPart part : buffer)
        {
            BodyPart clone = part.copy();

            this.parts.parts.add(clone);
            clone.init();
        }

        if (!this.parts.parts.isEmpty())
        {
            this.setPart(this.parts.parts.get(this.parts.parts.size() - 1));
        }

        this.bodyParts.update();
    }

    protected void toggleTarget(GuiToggleElement b)
    {
        if (this.part != null)
        {
            this.part.useTarget = b.isToggled();
        }
    }

    protected void toggleEnabled(GuiToggleElement b)
    {
        if (this.part != null)
        {
            this.part.enabled = b.isToggled();
        }
    }

    protected void toggleAnimate(GuiToggleElement b)
    {
        if (this.part != null)
        {
            this.part.animate = b.isToggled();
        }
    }

    protected void pickItem(ItemStack stack, int slot)
    {
        if (this.part == null)
        {
            return;
        }

        this.part.slots[slot] = stack;
        this.part.updateEntity();
    }

    @Override
    public void fillData(AbstractMorph morph)
    {
        super.fillData(morph);

        if (morph instanceof IBodyPartProvider)
        {
            BodyPartManager manager = ((IBodyPartProvider) morph).getBodyPart();

            this.parts = manager;

            this.bodyParts.setList(manager.parts);
            this.bodyParts.update();
        }
    }

    @Override
    public void startEditing()
    {
        super.startEditing();

        if (this.parts != null)
        {
            this.setPart(this.parts.parts.isEmpty() ? null : this.parts.parts.get(0));
        }
    }

    public void setLimbs(Collection<String> limbs)
    {
        this.limbs.clear();
        this.limbs.add(limbs);
        this.limbs.sort();
    }

    protected void setPart(BodyPart part)
    {
        this.part = part;
        this.elements.setVisible(part != null);

        if (this.part != null)
        {
            this.fillBodyPart(part);
            this.limbs.setCurrent(part.limb);
            this.bodyParts.setCurrentDirect(part);
            this.pickMorph.setMorph(part.morph.get());
        }
    }

    protected void pickLimb(String str)
    {
        BodyPart part = this.part;
        boolean convert = GuiScreen.isAltKeyDown();

        if (part.limb.equals(str))
        {
            return;
        }

        if (part.limb.isEmpty() || !convert)
        {
            part.limb = str;
            return;
        }

        part.lastMatrix = null;
        BodyPart.recordMatrix(this.morph, this.editor.renderer.getEntity(), GuiBase.getCurrent().partialTicks);
        Matrix4f last = part.lastMatrix;

        if (last == null)
        {
            part.limb = str;
            return;
        }

        Matrix4f transform = new Matrix4f();
        transform.setIdentity();
        transform.setTranslation(part.translate);
        last.mul(transform);
        transform.rotZ((float) Math.toRadians(part.rotate.z));
        last.mul(transform);
        transform.rotY((float) Math.toRadians(part.rotate.y));
        last.mul(transform);
        transform.rotX((float) Math.toRadians(part.rotate.x));
        last.mul(transform);
        transform.setIdentity();
        transform.m00 = part.scale.x;
        transform.m11 = part.scale.y;
        transform.m22 = part.scale.z;
        last.mul(transform);

        part.limb = str;

        part.lastMatrix = null;
        BodyPart.recordMatrix(this.morph, this.editor.renderer.getEntity(), GuiBase.getCurrent().partialTicks);
        Matrix4f current = part.lastMatrix;

        if (current == null)
        {
            return;
        }

        Transformation extract = MatrixUtils.extractTransformations(current, last);

        if (extract.getCreationException() == null)
        {
            Vector3f rotate = extract.getRotation(RotationOrder.XYZ);

            if (rotate != null)
            {
                part.translate.set(extract.getTranslation3f());
                part.rotate.set(rotate);
                part.scale.set(extract.getScale());
            }
        }

        this.fillBodyPart(part);
    }

    public void fillBodyPart(BodyPart part)
    {
        if (part != null)
        {
            this.bottomEditor.removeAll();

            if (this.morph instanceof IAnimationProvider)
            {
                this.bottomEditor.add(this.enabled, this.animate, this.useTarget);
            }
            else
            {
                this.bottomEditor.add(this.enabled, this.useTarget);
            }

            this.elements.resize();
            this.transformations.setBodyPart(part);

            this.enabled.toggled(part.enabled);
            this.useTarget.toggled(part.useTarget);
            this.animate.toggled(part.animate);

            for (int i = 0; i < this.slots.length; i++)
            {
                this.slots[i].setStack(part.slots[i]);
            }
        }
    }

    private void moveIndex(int index)
    {
        if (index != 0)
        {
            index = MathUtils.cycler(this.bodyParts.getIndex() + index, 0, this.bodyParts.getList().size() - 1);

            this.bodyParts.setIndex(index);
            this.fillBodyPart(this.bodyParts.getCurrentFirst());
        }
    }

    @Override
    public void draw(GuiContext context)
    {
        this.font.drawStringWithShadow(I18n.format("metamorph.gui.body_parts.parts"), this.bodyParts.area.x, this.bodyParts.area.y - 12, 0xffffff);

        if (this.elements.isVisible())
        {
            this.font.drawStringWithShadow(I18n.format("metamorph.gui.body_parts.limbs"), this.limbs.area.x, this.limbs.area.y - 12, 0xffffff);
        }

        super.draw(context);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.bodyParts.setIndex(tag.getInteger("Index"));

        BodyPart part = this.bodyParts.getCurrentFirst();

        if (part != null)
        {
            this.setPart(part);
        }
    }

    @Override
    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = super.toNBT();

        tag.setInteger("Index", this.bodyParts.getIndex());

        return tag;
    }

    public static class GuiBodyPartTransformations extends GuiTransformations
    {
        public BodyPart part;

        public GuiBodyPartTransformations(Minecraft mc)
        {
            super(mc);
        }

        @Override
        public void localTranslate(double x, double y, double z)
        {
            this.part.addTranslation(x, y, z, GuiStaticTransformOrientation.getOrientation());

            this.fillT(this.part.translate.x, this.part.translate.y, this.part.translate.z);
        }

        public void setBodyPart(BodyPart part)
        {
            this.part = part;

            if (part != null)
            {
                this.fillT(part.translate.x, part.translate.y, part.translate.z);
                this.fillS(part.scale.x, part.scale.y, part.scale.z);
                this.fillR(part.rotate.x, part.rotate.y, part.rotate.z);
            }
        }

        @Override
        public void setT(double x, double y, double z)
        {
            this.part.translate.x = (float) x;
            this.part.translate.y = (float) y;
            this.part.translate.z = (float) z;
        }

        @Override
        public void setS(double x, double y, double z)
        {
            this.part.scale.x = (float) x;
            this.part.scale.y = (float) y;
            this.part.scale.z = (float) z;
        }

        @Override
        public void setR(double x, double y, double z)
        {
            this.part.rotate.x = (float) x;
            this.part.rotate.y = (float) y;
            this.part.rotate.z = (float) z;
        }
    }

    public static class TransformedOnionSkinMorph extends AbstractMorph
    {
        public float[] translate = new float[3];
        public float[] rotate = new float[3];
        public float[] scale = new float[3];
        public AbstractMorph morph = null;

        @Override
        public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
        {}

        @Override
        public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
        {
            if (this.morph == null)
            {
                return;
            }

            GlStateManager.pushMatrix();

            GlStateManager.translate(this.translate[0], this.translate[1], this.translate[2]);
            GlStateManager.rotate(this.rotate[2], 0, 0, 1);
            GlStateManager.rotate(this.rotate[1], 0, 1, 0);
            GlStateManager.rotate(this.rotate[0], 1, 0, 0);
            GlStateManager.scale(this.scale[0], this.scale[1], this.scale[2]);

            MorphUtils.renderDirect(morph, entity, x, y, z, entityYaw, partialTicks);

            GlStateManager.popMatrix();
        }

        @Override
        public AbstractMorph create()
        {
            return null;
        }

        @Override
        public float getWidth(EntityLivingBase target)
        {
            return 0;
        }

        @Override
        public float getHeight(EntityLivingBase target)
        {
            return 0;
        }
        
    }
}

==================================================

--- Файл №44 ---
Путь: main\java\mchorse\metamorph\bodypart\GuiBodyPartListElement.java
--------------------
package mchorse.metamorph.bodypart;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;

import java.util.List;
import java.util.function.Consumer;

/**
 * Body part list which displays body parts
 */
public class GuiBodyPartListElement extends GuiListElement<BodyPart>
{
    public GuiBodyPartListElement(Minecraft mc, Consumer<List<BodyPart>> callback)
    {
        super(mc, callback);

        this.scroll.scrollItemSize = 24;
    }

    @Override
    protected void drawElementPart(BodyPart element, int i, int x, int y, boolean hover, boolean selected)
    {
        GuiContext context = GuiBase.getCurrent();

        if (!element.morph.isEmpty())
        {
            GuiDraw.scissor(x, y, this.scroll.w, this.scroll.scrollItemSize, context);
            element.morph.get().renderOnScreen(this.mc.player, x + this.scroll.w - 16, y + 30, 20, 1);
            GuiDraw.unscissor(context);
        }

        super.drawElementPart(element, i, x, y, hover, selected);
    }

    @Override
    protected String elementToString(BodyPart element)
    {
        String label = element.limb.isEmpty() ? "_" : element.limb;

        if (!element.morph.isEmpty())
        {
            AbstractMorph morph = element.morph.get();

            if (morph.hasCustomName())
            {
                label += " - " + element.morph.get().getDisplayName();
            }
        }

        return label;
    }
}

==================================================

--- Файл №45 ---
Путь: main\java\mchorse\metamorph\bodypart\IBodyPartProvider.java
--------------------
package mchorse.metamorph.bodypart;

/**
 * Body part provider 
 */
public interface IBodyPartProvider
{
    public BodyPartManager getBodyPart();
}

==================================================

--- Файл №46 ---
Путь: main\java\mchorse\metamorph\capabilities\CapabilityHandler.java
--------------------
package mchorse.metamorph.capabilities;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.capabilities.morphing.MorphingProvider;
import mchorse.metamorph.capabilities.render.IModelRenderer;
import mchorse.metamorph.capabilities.render.ModelProvider;
import mchorse.metamorph.capabilities.render.ModelRenderer;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.survival.PacketAcquiredMorphs;
import mchorse.metamorph.network.common.PacketBlacklist;
import mchorse.metamorph.network.common.creative.PacketMorph;
import mchorse.metamorph.network.common.survival.PacketMorphPlayer;
import mchorse.metamorph.network.common.survival.PacketMorphState;
import mchorse.metamorph.network.common.PacketSettings;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.event.AttachCapabilitiesEvent;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;
import net.minecraftforge.event.entity.player.PlayerEvent;
import net.minecraftforge.event.entity.player.PlayerEvent.StartTracking;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerLoggedInEvent;

/**
 * Capability handler class
 *
 * This class is responsible for managing capabilities, i.e. attaching
 * capabilities and syncing values on the client.
 */
public class CapabilityHandler
{
    public static final ResourceLocation MORPHING_CAP = new ResourceLocation(Metamorph.MOD_ID, "morphing_capability");
    public static final ResourceLocation MODEL_CAP = new ResourceLocation(Metamorph.MOD_ID, "model");

    private static Boolean isMohist;

    private static boolean isMohist()
    {
        if (isMohist != null)
        {
            return isMohist;
        }

        try
        {
            Class.forName("com.mohistmc.MohistMC");

            isMohist = true;
        }
        catch (Exception e)
        {
            isMohist = false;
        }

        return isMohist;
    }

    /**
     * Attach capabilities
     */
    @SubscribeEvent
    public void attachCapability(AttachCapabilitiesEvent<Entity> event)
    {
        if (event == null) return;

        if (event.getObject() instanceof EntityLivingBase && event.getObject().world != null && event.getObject().world.isRemote)
        {
            event.addCapability(MODEL_CAP, new ModelProvider());
        }

        if (event.getObject() instanceof EntityPlayer)
        {
            event.addCapability(MORPHING_CAP, new MorphingProvider());
        }
    }

    /**
     * When player logs in, sent him his server counter partner's values.
     */
    @SubscribeEvent
    public void playerLogsIn(PlayerLoggedInEvent event)
    {
        EntityPlayer player = event.player;
        IMorphing cap = Morphing.get(player);

        if (cap != null)
        {
            this.sendAcquiredMorphs(cap, player);

            /* Ensure that player was morphed */
            if (cap.isMorphed())
            {
                cap.getCurrentMorph().morph(player);
            }

            /* Send data */
            Dispatcher.sendTo(new PacketBlacklist(MorphManager.INSTANCE.activeBlacklist), (EntityPlayerMP) player);
            Dispatcher.sendTo(new PacketSettings(MorphManager.INSTANCE.activeSettings), (EntityPlayerMP) player);
            Dispatcher.sendTo(new PacketMorphState(player, cap), (EntityPlayerMP) player);
        }
    }

    /**
     * When player starts tracking another player, server has to send its
     * morphing values.
     */
    @SubscribeEvent
    public void playerStartsTracking(StartTracking event)
    {
        if (event.getTarget() instanceof EntityPlayer)
        {
            Entity target = event.getTarget();
            EntityPlayerMP player = (EntityPlayerMP) event.getEntityPlayer();
            IMorphing cap = target.getCapability(MorphingProvider.MORPHING_CAP, null);

            Dispatcher.sendTo(new PacketMorphPlayer(target.getEntityId(), cap.getCurrentMorph()), player);
        }
    }

    /**
     * On player's spawn in the world (when player travels in other dimension 
     * and spawns there or when player dies and then respawns).
     * 
     * This method is responsible for sending morphing data on the client.
     */
    @SubscribeEvent
    public void onPlayerSpawn(EntityJoinWorldEvent event)
    {
        Entity entity = event.getEntity();

        if (entity instanceof EntityPlayer && !entity.world.isRemote)
        {
            EntityPlayer player = (EntityPlayer) entity;
            IMorphing morphing = Morphing.get(player);

            this.sendAcquiredMorphs(morphing, player);
            Dispatcher.sendTo(new PacketMorphState(player, morphing), (EntityPlayerMP) player);
        }
        else if (entity instanceof EntityLivingBase && entity.world.isRemote)
        {
            IModelRenderer renderer = ModelRenderer.get(entity);

            renderer.updateSelector((EntityLivingBase) entity);
        }
    }

    /**
     * Copy data from dead player (or player returning from end) to the new player
     */
    @SubscribeEvent
    public void onPlayerClone(PlayerEvent.Clone event)
    {
        EntityPlayer player = event.getEntityPlayer();
        IMorphing morphing = Morphing.get(player);
        IMorphing oldMorphing = Morphing.get(event.getOriginal());

        if (!isMohist())
        {
            if (Metamorph.keepMorphs.get() || !event.isWasDeath())
            {
                morphing.copy(oldMorphing, player);
            }
        }
    }

    /**
     * Send acquired morphs (and currently morphed morph) to the given player. 
     */
    private void sendAcquiredMorphs(IMorphing cap, EntityPlayer player)
    {
        EntityPlayerMP mp = (EntityPlayerMP) player;

        Dispatcher.sendTo(new PacketMorph(cap.getCurrentMorph()), mp);
        Dispatcher.sendTo(new PacketAcquiredMorphs(cap.getAcquiredMorphs()), mp);
    }
}

==================================================

--- Файл №47 ---
Путь: main\java\mchorse\metamorph\capabilities\morphing\IMorphing.java
--------------------
package mchorse.metamorph.capabilities.morphing;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.DamageSource;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * Morphing interface
 *
 * This interface is responsible for morphing. See {@link Morphing} class for
 * default implementation.
 */
public interface IMorphing
{
    public static final float REASONABLE_HEALTH_VALUE = Float.MIN_VALUE * 100;

    /**
     * Whether this morph is in the process of animation 
     */
    public boolean isAnimating();

    /**
     * Get animation tick
     */
    @SideOnly(Side.CLIENT)
    public int getAnimation();

    /**
     * Get previous animation morph 
     */
    @SideOnly(Side.CLIENT)
    public AbstractMorph getPreviousMorph();

    /**
     * Render player as a morph
     */
    @SideOnly(Side.CLIENT)
    public boolean renderPlayer(EntityPlayer player, double x, double y, double z, float yaw, float partialTick);
    
    /**
     * Check the last damage source received by the
     * player. (This value is volatile and not stored)
     */
    public DamageSource getLastDamageSource();
    
    /**
     * Record the last damage source received by the
     * player. (This value is volatile and not stored)
     */
    public void setLastDamageSource(DamageSource damageSource);

    /**
     * Add a morph
     */
    public boolean acquireMorph(AbstractMorph morph);

    /**
     * Check if this capability has acquired a morph
     */
    public boolean acquiredMorph(AbstractMorph morph);

    /**
     * Get all acquired morph
     */
    public List<AbstractMorph> getAcquiredMorphs();

    /**
     * Set acquired morph
     */
    public void setAcquiredMorphs(List<AbstractMorph> morphs);

    /**
     * Get current morph 
     */
    public AbstractMorph getCurrentMorph();

    /**
     * Set current morph
     */
    public boolean setCurrentMorph(AbstractMorph morph, EntityPlayer player, boolean force);

    /**
     * Demorph this capability 
     */
    public void demorph(EntityPlayer player);

    /**
     * Is this capability is morphed at all 
     */
    public boolean isMorphed();

    /**
     * Favorite or unfavorite a morph by given index
     * 
     * @return if true then given favorite was added, or false if it was 
     *         removed
     */
    public void favorite(int index);

    /**
     * Change keybind
     */
    public void keybind(int index, int keybind);

    /**
     * Remove a morph at given index
     */
    public boolean remove(int index);

    /**
     * Remove all acquired morphs
     */
    public void removeAcquired();

    /**
     * Copy data from other morph 
     */
    public void copy(IMorphing morphing, EntityPlayer player);

    /**
     * Get the last recorded finite health fraction of the player
     */
    public float getLastHealthRatio();

    /**
     * Determines what the player's new health will be if the player morphs out of a morph with very low health
     */
    public void setLastHealthRatio(float lastHealthRatio);
    
    /**
     * Gets whether the player is in a morph which drowns on hand due to the Swim ability
     */
    public boolean getHasSquidAir();
    
    /**
     * Sets whether the player is in a morph which drowns on hand due to the Swim ability
     */
    public void setHasSquidAir(boolean hasSquidAir);
    
    /**
     * Gets the air value used when in a morph with the Swim ability
     */
    public int getSquidAir();
    
    /**
     * Sets the air value of a morph in the Swim ability
     */
    public void setSquidAir(int squidAir);

    /**
     * Get last health
     */
    public float getLastHealth();

    /**
     * Set last health
     */
    public void setLastHealth(float lastHealth);

    /**
     * Update the player 
     */
    public void update(EntityPlayer player);
}

==================================================

--- Файл №48 ---
Путь: main\java\mchorse\metamorph\capabilities\morphing\Morphing.java
--------------------
package mchorse.metamorph.capabilities.morphing;

import java.util.ArrayList;
import java.util.List;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.SharedMonsterAttributes;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.SoundEvents;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumParticleTypes;
import net.minecraft.world.WorldServer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Default implementation of {@link IMorphing} interface.
 *
 * This class is responsible for storing current morphing, setting and retrieval
 * of current morphing.
 */
public class Morphing implements IMorphing
{
    /**
     * List of acquired abstract morphs 
     */
    private List<AbstractMorph> acquiredMorphs = new ArrayList<AbstractMorph>();

    /**
     * Current used morph
     */
    private Morph morph = new Morph();

    /**
     * Used for animation
     */
    private AbstractMorph previousMorph;

    /**
     * Animation timer 
     */
    private int animation;

    /**
     * The last damage source received by the player
     */
    private DamageSource lastDamageSource;

    /**
     * (health / max health) is stored here when the new max health ends up
     * very close to zero, and retrieved when the fraction is meaningful again
     */
    private float lastHealthRatio;

    /**
     * Whether or not the current player is in a morph which can drown on land
     * due to having the Swim ability
     */
    private boolean hasSquidAir = false;

    /**
     * The air value used for morphs with the Swim ability in place of regular
     * player air
     */
    private int squidAir = 300;

    /**
     * Last health that player had before morphing, should fix issue that people complain about
     */
    private float lastHealth;

    public static IMorphing get(EntityPlayer player)
    {
        if (player == null)
        {
            return null;
        }

        return player.getCapability(MorphingProvider.MORPHING_CAP, null);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public boolean isAnimating()
    {
        if (Metamorph.disableMorphAnimation.get())
        {
            return false;
        }

        return this.animation != -1;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public int getAnimation()
    {
        return this.animation;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public AbstractMorph getPreviousMorph()
    {
        return this.previousMorph;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public boolean renderPlayer(EntityPlayer player, double x, double y, double z, float yaw, float partialTick)
    {
        if (player.isSpectator())
        {
            return false;
        }

        if (this.morph.isEmpty() && !this.isAnimating())
        {
            return false;
        }

        if (this.morph.isEmpty() && this.animation <= 10 || this.previousMorph == null && this.animation > 10)
        {
            return false;
        }

        if (!this.isAnimating())
        {
            if (MorphUtils.render(this.morph.get(), player, x, y, z, yaw, partialTick))
            {
                return true;
            }
        }

        GlStateManager.pushMatrix();

        /* Render morph in after transition */
        if (this.animation <= 10)
        {
            float anim = (this.animation - partialTick) / 10.0F;
            float offset = 0;

            if (anim >= 0)
            {
                offset = -anim * anim * 2F;
            }

            GlStateManager.translate(x, y + offset, z);

            if (anim >= 0)
            {
                GlStateManager.rotate(anim * -90.0F, 1, 0, 0);
                GlStateManager.scale(1 - anim, 1 - anim, 1 - anim);
            }

            MorphUtils.render(this.morph.get(), player, 0, 0, 0, yaw, partialTick);
        }
        else if (this.previousMorph != null)
        {
            /* Render morph before the transition */
            float anim = (this.animation - 10 - partialTick) / 10.0F;
            float offset = 0;

            if (anim >= 0)
            {
                offset = (1 - anim);
            }

            GlStateManager.translate(x, y + offset, z);

            if (anim >= 0)
            {
                GlStateManager.rotate((1 - anim) * 90.0F, 1, 0, 0);
                GlStateManager.scale(anim, anim, anim);
            }

            MorphUtils.render(this.previousMorph, player, 0, 0, 0, yaw, partialTick);
        }

        GlStateManager.popMatrix();

        return true;
    }

    @Override
    public DamageSource getLastDamageSource()
    {
        return lastDamageSource;
    }

    @Override
    public void setLastDamageSource(DamageSource damageSource)
    {
        this.lastDamageSource = damageSource;
    }

    @Override
    public boolean acquireMorph(AbstractMorph morph)
    {
        if (morph == null || this.acquiredMorph(morph))
        {
            return false;
        }

        this.acquiredMorphs.add(morph);

        return true;
    }

    @Override
    public boolean acquiredMorph(AbstractMorph morph)
    {
        for (AbstractMorph acquired : this.acquiredMorphs)
        {
            if (acquired.equals(morph))
            {
                return true;
            }
        }

        return false;
    }

    @Override
    public List<AbstractMorph> getAcquiredMorphs()
    {
        return acquiredMorphs;
    }

    @Override
    public void setAcquiredMorphs(List<AbstractMorph> morphs)
    {
        this.acquiredMorphs.clear();
        this.acquiredMorphs.addAll(morphs);
    }

    @Override
    public AbstractMorph getCurrentMorph()
    {
        return this.morph.get();
    }

    @Override
    public boolean setCurrentMorph(AbstractMorph morph, EntityPlayer player, boolean force)
    {
        if (morph == null)
        {
            this.demorph(player);

            return true;
        }

        boolean creative = player != null && player.isCreative();

        if (force || creative || this.acquiredMorph(morph))
        {
            if (player != null)
            {
                if (this.morph.isEmpty())
                {
                    this.lastHealth = (float) player.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).getBaseValue();
                }
                else
                {
                    this.morph.get().demorph(player);
                }
            }

            this.setMorph(morph);

            if (player != null && !this.morph.isEmpty())
            {
                AbstractMorph current = this.morph.get();

                this.setHealth(player, current.getSettings().health);
                current.morph(player);
            }

            return true;
        }

        return false;
    }

    @Override
    public void demorph(EntityPlayer player)
    {
        if (player != null && !this.morph.isEmpty())
        {
            this.morph.get().demorph(player);
        }

        if (player != null)
        {
            /* 20 is default player's health */
            this.setHealth(player, this.lastHealth <= 0.0F ? 20.0F : this.lastHealth);
        }

        this.setMorph(null);
    }

    /**
     * Set current morph, as well as update animation information  
     */
    protected void setMorph(AbstractMorph morph)
    {
        AbstractMorph previous = this.morph.get();

        if (this.morph.set(morph))
        {
            if (!Metamorph.disableMorphAnimation.get())
            {
                this.animation = 20;
            }

            this.previousMorph = previous;
        }
    }

    @Override
    public boolean isMorphed()
    {
        return !this.morph.isEmpty();
    }

    @Override
    public void favorite(int index)
    {
        if (index >= 0 && index < this.acquiredMorphs.size())
        {
            AbstractMorph morph = this.acquiredMorphs.get(index);

            morph.favorite = !morph.favorite;
        }
    }

    @Override
    public void keybind(int index, int keycode)
    {
        if (index >= 0 && index < this.acquiredMorphs.size())
        {
            AbstractMorph morph = this.acquiredMorphs.get(index);

            morph.keybind = keycode;
        }
    }

    @Override
    public boolean remove(int index)
    {
        if (index >= 0 && index < this.acquiredMorphs.size())
        {
            this.acquiredMorphs.remove(index);

            return true;
        }

        return false;
    }

    @Override
    public void removeAcquired()
    {
        this.acquiredMorphs.clear();
    }

    @Override
    public void copy(IMorphing morphing, EntityPlayer player)
    {
        this.acquiredMorphs.addAll(morphing.getAcquiredMorphs());

        if (morphing.getCurrentMorph() != null)
        {
            this.setCurrentMorph(morphing.getCurrentMorph().copy(), player, true);
        }
        else
        {
            this.setCurrentMorph(null, player, true);
        }
    }

    @Override
    public float getLastHealthRatio()
    {
        return lastHealthRatio;
    }

    @Override
    public void setLastHealthRatio(float lastHealthRatio)
    {
        this.lastHealthRatio = lastHealthRatio;
    }

    @Override
    public boolean getHasSquidAir()
    {
        return hasSquidAir;
    }

    @Override
    public void setHasSquidAir(boolean hasSquidAir)
    {
        this.hasSquidAir = hasSquidAir;
    }

    @Override
    public int getSquidAir()
    {
        return squidAir;
    }

    @Override
    public void setSquidAir(int squidAir)
    {
        this.squidAir = squidAir;
    }

    @Override
    public float getLastHealth()
    {
        return this.lastHealth;
    }

    @Override
    public void setLastHealth(float lastHealth)
    {
        this.lastHealth = lastHealth;
    }

    @Override
    public void update(EntityPlayer player)
    {
        if (this.animation >= 0)
        {
            this.animation--;
        }

        if (this.animation == 16 && !player.world.isRemote && !Metamorph.disableMorphAnimation.get())
        {
            /* Pop! */
            ((WorldServer) player.world).spawnParticle(EnumParticleTypes.EXPLOSION_NORMAL, false, player.posX, player.posY + 0.5, player.posZ, 25, 0.5, 0.5, 0.5, 0.05);

            player.playSound(SoundEvents.ENTITY_ITEM_PICKUP, 1.0F, 1.0F);
        }

        if (!this.morph.isEmpty())
        {
            AbstractMorph morph = this.morph.get();

            if (!Metamorph.disableHealth.get())
            {
                this.setMaxHealth(player, morph.getSettings().health);
            }

            morph.update(player);
        }
    }

    /* Adjusting health */

    /**
     * Set player's health proportional to the current health with given max
     * health.
     *
     * @author asanetargoss
     */
    protected void setHealth(EntityLivingBase target, float health)
    {
        if (Metamorph.disableHealth.get())
        {
            return;
        }

        float maxHealth = target.getMaxHealth();
        float currentHealth = target.getHealth();
        float ratio = currentHealth / maxHealth;

        // A sanity check to prevent "healing" health when morphing to and from
        // a mob with essentially zero health
        if (target instanceof EntityPlayer)
        {
            IMorphing capability = Morphing.get((EntityPlayer) target);
            if (capability != null)
            {
                // Check if a health ratio makes sense for the old health value
                if (maxHealth > IMorphing.REASONABLE_HEALTH_VALUE)
                {
                    // If it makes sense, store that ratio in the capability
                    capability.setLastHealthRatio(ratio);
                }
                else if (health > IMorphing.REASONABLE_HEALTH_VALUE)
                {
                    // If it doesn't make sense, BUT the new max health makes
                    // sense, retrieve the ratio from the capability and use that instead
                    ratio = capability.getLastHealthRatio();
                }
            }
        }

        this.setMaxHealth(target, health);
        // We need to retrieve the max health of the target after modifiers are
        // applied to get a sensible value
        float proportionalHealth = target.getMaxHealth() * ratio;
        target.setHealth(proportionalHealth <= 0.0F ? Float.MIN_VALUE : proportionalHealth);
    }

    /**
     * Set player's max health
     */
    protected void setMaxHealth(EntityLivingBase target, float health)
    {
        if (target.getMaxHealth() != health)
        {
            target.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(health);
        }
    }
}

==================================================

--- Файл №49 ---
Путь: main\java\mchorse\metamorph\capabilities\morphing\MorphingProvider.java
--------------------
package mchorse.metamorph.capabilities.morphing;

import net.minecraft.nbt.NBTBase;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityInject;
import net.minecraftforge.common.capabilities.ICapabilitySerializable;

/**
 * Morhping capability provider
 *
 * Now that I understand capability system, it seems pretty easy to use!
 */
public class MorphingProvider implements ICapabilitySerializable<NBTBase>
{
    @CapabilityInject(IMorphing.class)
    public static final Capability<IMorphing> MORPHING_CAP = null;

    private IMorphing instance = MORPHING_CAP.getDefaultInstance();

    @Override
    public boolean hasCapability(Capability<?> capability, EnumFacing facing)
    {
        return capability == MORPHING_CAP;
    }

    @Override
    public <T> T getCapability(Capability<T> capability, EnumFacing facing)
    {
        return capability == MORPHING_CAP ? MORPHING_CAP.<T> cast(this.instance) : null;
    }

    @Override
    public NBTBase serializeNBT()
    {
        return MORPHING_CAP.getStorage().writeNBT(MORPHING_CAP, this.instance, null);
    }

    @Override
    public void deserializeNBT(NBTBase nbt)
    {
        MORPHING_CAP.getStorage().readNBT(MORPHING_CAP, this.instance, null, nbt);
    }
}

==================================================

--- Файл №50 ---
Путь: main\java\mchorse\metamorph\capabilities\morphing\MorphingStorage.java
--------------------
package mchorse.metamorph.capabilities.morphing;

import java.util.ArrayList;
import java.util.List;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagByte;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagFloat;
import net.minecraft.nbt.NBTTagInt;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.Capability.IStorage;

/**
 * Morphing storage
 *
 * This class is responsible for saving IMorphing capability to... Hey, Houston,
 * where these data are getting saved? Basically, I don't know.
 *
 * Further research in Minecraft sources shows that capabilities are stored
 * in target's NBT (i.e. ItemStack's, TE's or Entity's NBT) in field "ForgeCaps."
 */
public class MorphingStorage implements IStorage<IMorphing>
{
    @Override
    public NBTBase writeNBT(Capability<IMorphing> capability, IMorphing instance, EnumFacing side)
    {
        NBTTagCompound tag = new NBTTagCompound();
        NBTTagList acquired = new NBTTagList();

        tag.setFloat("lastHealthRatio", instance.getLastHealthRatio());
        tag.setBoolean("HasSquidAir", instance.getHasSquidAir());
        tag.setInteger("SquidAir", instance.getSquidAir());
        tag.setFloat("lastHealth", instance.getLastHealth());

        if (instance.getCurrentMorph() != null)
        {
            NBTTagCompound morph = new NBTTagCompound();
            instance.getCurrentMorph().toNBT(morph);

            tag.setTag("Morph", morph);
        }

        tag.setTag("Morphs", acquired);

        for (AbstractMorph acquiredMorph : instance.getAcquiredMorphs())
        {
            NBTTagCompound acquiredTag = new NBTTagCompound();

            acquiredMorph.toNBT(acquiredTag);
            acquired.appendTag(acquiredTag);
        }

        return tag;
    }

    @Override
    public void readNBT(Capability<IMorphing> capability, IMorphing instance, EnumFacing side, NBTBase nbt)
    {
        if (nbt instanceof NBTTagCompound)
        {
            NBTTagCompound tag = (NBTTagCompound) nbt;
            NBTTagList acquired = tag.getTagList("Morphs", 10);
            NBTTagCompound morphTag = tag.getCompoundTag("Morph");

            instance.setLastHealthRatio(tag.getFloat("LastHealthRatio"));
            instance.setHasSquidAir(tag.getBoolean("HasSquidAir"));
            instance.setSquidAir(tag.getInteger("SquidAir"));
            instance.setLastHealth(tag.getFloat("lastHealth"));

            if (!tag.hasNoTags())
            {
                instance.setCurrentMorph(MorphManager.INSTANCE.morphFromNBT(morphTag), null, true);
            }

            List<AbstractMorph> acquiredMorphs = new ArrayList<AbstractMorph>();

            if (!acquired.hasNoTags())
            {
                for (int i = 0; i < acquired.tagCount(); i++)
                {
                    NBTTagCompound acquiredTag = acquired.getCompoundTagAt(i);
                    AbstractMorph morph = MorphManager.INSTANCE.morphFromNBT(acquiredTag);

                    if (morph != null)
                    {
                        acquiredMorphs.add(morph);
                    }
                }

                instance.setAcquiredMorphs(acquiredMorphs);
            }
        }
    }
}


==================================================

--- Файл №51 ---
Путь: main\java\mchorse\metamorph\capabilities\render\EntitySelector.java
--------------------
package mchorse.metamorph.capabilities.render;

import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;

public class EntitySelector
{
    public boolean enabled = true;
    public String name = "";
    public String type = "";
    public NBTTagCompound match;
    public NBTTagCompound morph;

    public boolean matches(EntityLivingBase target)
    {
        if (target == null || !this.enabled)
        {
            return false;
        }

        String nameTag = target.getName();
        ResourceLocation entityName = EntityList.getKey(target);

        if (entityName == null)
        {
            entityName = new ResourceLocation(target instanceof EntityPlayer ? "player" : "");
        }

        String n = this.name;
        String t = this.type;

        boolean negativeName = n.startsWith("!");
        boolean negativeType = t.startsWith("!");

        if (negativeName) n = n.substring(1);
        if (negativeType) t = t.substring(1);

        ResourceLocation rt = new ResourceLocation(t);

        boolean matchesName = this.name.isEmpty() || negativeName != nameTag.equals(n);
        boolean matchesType = this.type.equals("*") || negativeType != entityName.equals(rt);

        if (matchesName && matchesType)
        {
            if (this.match != null && !this.match.hasNoTags())
            {
                return this.match(target.writeToNBT(new NBTTagCompound()));
            }

            return true;
        }

        return false;
    }

    private boolean match(NBTTagCompound entityTag)
    {
        for (String key : this.match.getKeySet())
        {
            NBTBase value = this.match.getTag(key);
            NBTBase entityValue = entityTag.getTag(key);

            if (!value.equals(entityValue))
            {
                return false;
            }
        }

        return true;
    }
}

==================================================

--- Файл №52 ---
Путь: main\java\mchorse\metamorph\capabilities\render\EntitySelectorAdapter.java
--------------------
package mchorse.metamorph.capabilities.render;

import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import net.minecraft.nbt.JsonToNBT;

import java.lang.reflect.Type;

/**
 * Entity selector JSON adapter 
 */
public class EntitySelectorAdapter implements JsonDeserializer<EntitySelector>, JsonSerializer<EntitySelector>
{
    @Override
    public EntitySelector deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
    {
        if (!json.isJsonObject())
        {
            return null;
        }

        EntitySelector selector = new EntitySelector();
        JsonObject object = json.getAsJsonObject();

        if (object.has("name"))
        {
            selector.name = object.get("name").getAsString();
        }

        if (object.has("type"))
        {
            selector.type = object.get("type").getAsString();
        }

        if (object.has("enabled"))
        {
            selector.enabled = object.get("enabled").getAsBoolean();
        }

        if (object.has("match"))
        {
            try
            {
                selector.match = JsonToNBT.getTagFromJson(object.get("match").getAsString());
            }
            catch (Exception e)
            {}
        }

        if (object.has("morph"))
        {
            try
            {
                selector.morph = JsonToNBT.getTagFromJson(object.get("morph").getAsString());
            }
            catch (Exception e)
            {}
        }

        return selector;
    }

    @Override
    public JsonElement serialize(EntitySelector src, Type typeOfSrc, JsonSerializationContext context)
    {
        JsonObject object = new JsonObject();

        object.addProperty("name", src.name);
        object.addProperty("type", src.type);
        object.addProperty("enabled", src.enabled);

        if (src.match != null && !src.match.hasNoTags())
        {
            object.addProperty("match", src.match.toString());
        }

        if (src.morph != null)
        {
            object.addProperty("morph", src.morph.toString());
        }

        return object;
    }
}

==================================================

--- Файл №53 ---
Путь: main\java\mchorse\metamorph\capabilities\render\IModelRenderer.java
--------------------
package mchorse.metamorph.capabilities.render;

import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public interface IModelRenderer
{
    public void update(EntityLivingBase entity);

    @SideOnly(Side.CLIENT)
    public void updateSelector(EntityLivingBase entity);

    public boolean canRender();

    public boolean render(EntityLivingBase entity, double x, double y, double z, float partialTicks);
}

==================================================

--- Файл №54 ---
Путь: main\java\mchorse\metamorph\capabilities\render\ModelProvider.java
--------------------
package mchorse.metamorph.capabilities.render;

import net.minecraft.util.EnumFacing;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityInject;
import net.minecraftforge.common.capabilities.ICapabilityProvider;

public class ModelProvider implements ICapabilityProvider
{
    @CapabilityInject(IModelRenderer.class)
    public static final Capability<IModelRenderer> MODEL = null;

    private IModelRenderer instance = MODEL.getDefaultInstance();

    @Override
    public boolean hasCapability(Capability<?> capability, EnumFacing facing)
    {
        return capability == MODEL;
    }

    @Override
    public <T> T getCapability(Capability<T> capability, EnumFacing facing)
    {
        return capability == MODEL ? MODEL.<T>cast(this.instance) : null;
    }
}

==================================================

--- Файл №55 ---
Путь: main\java\mchorse\metamorph\capabilities\render\ModelRenderer.java
--------------------
package mchorse.metamorph.capabilities.render;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.EntityModelHandler;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ModelRenderer implements IModelRenderer
{
    public static long selectorsUpdate = System.currentTimeMillis();

    public EntitySelector selector;
    public AbstractMorph morph;
    public long lastUpdate = -1;

    private int timer;
    private float lastW = -1;
    private float lastH = -1;

    public static IModelRenderer get(Entity entity)
    {
        return entity.getCapability(ModelProvider.MODEL, null);
    }

    @Override
    public void update(EntityLivingBase target)
    {
        if (this.lastUpdate < selectorsUpdate || this.IsNotMatchedAnymore(target))
        {
            this.lastUpdate = selectorsUpdate;

            this.updateSelector(target);
        }

        if (this.selector != null && this.morph != null)
        {
            this.morph.update(target);
        }
    }

    private boolean IsNotMatchedAnymore(EntityLivingBase target)
    {
        this.timer += 1;

        if (this.timer > 10)
        {
            this.timer = 0;

            if (this.selector == null)
            {
                return true;
            }

            return !this.selector.matches(target);
        }

        return false;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void updateSelector(EntityLivingBase target)
    {
        this.selector = null;
        this.morph = null;

        for (EntitySelector selector : EntityModelHandler.selectors)
        {
            if (selector.matches(target))
            {
                this.selector = selector;
                this.morph = MorphManager.INSTANCE.morphFromNBT(this.selector.morph);

                if (this.lastW < 0)
                {
                    this.lastW = target.width;
                    this.lastH = target.height;
                }

                return;
            }
        }

        if (this.selector == null && this.lastW > 0 && this.lastH > 0)
        {
            target.width = this.lastW;
            target.height = this.lastH;

            this.lastW = -1;
            this.lastH = -1;
        }
    }

    @Override
    public boolean canRender()
    {
        return this.selector != null;
    }

    /**
     * Render the animator controller based on given entity
     */
    @Override
    public boolean render(EntityLivingBase entity, double x, double y, double z, float partialTicks)
    {
        return this.selector != null && MorphUtils.render(this.morph, entity, x, y, z, 0, partialTicks);
    }
}

==================================================

--- Файл №56 ---
Путь: main\java\mchorse\metamorph\capabilities\render\ModelRendererStorage.java
--------------------
package mchorse.metamorph.capabilities.render;

import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.Capability.IStorage;

public class ModelRendererStorage implements IStorage<IModelRenderer>
{
    @Override
    public NBTBase writeNBT(Capability<IModelRenderer> capability, IModelRenderer instance, EnumFacing side)
    {
        return new NBTTagCompound();
    }

    @Override
    public void readNBT(Capability<IModelRenderer> capability, IModelRenderer instance, EnumFacing side, NBTBase nbt)
    {}
}

==================================================

--- Файл №57 ---
Путь: main\java\mchorse\metamorph\client\EntityModelHandler.java
--------------------
package mchorse.metamorph.client;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.reflect.TypeToken;
import mchorse.mclib.utils.JsonUtils;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.capabilities.render.EntitySelector;
import mchorse.metamorph.capabilities.render.EntitySelectorAdapter;
import mchorse.metamorph.capabilities.render.IModelRenderer;
import mchorse.metamorph.capabilities.render.ModelRenderer;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.client.event.RenderLivingEvent;
import net.minecraftforge.event.entity.living.LivingEvent.LivingUpdateEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;

/**
 * Entity model handler. This handler is responsible for rendering 
 * models on player.
 */
@SideOnly(Side.CLIENT)
public class EntityModelHandler
{
    /**
     * Entity selectors
     */
    public static final List<EntitySelector> selectors = new ArrayList<EntitySelector>();

    /**
     * Entity selector GSON 
     */
    public Gson entitySelector;

    public Entity currentRendering;

    public EntityModelHandler()
    {
        /* Create GSON builder */
        GsonBuilder gson = new GsonBuilder();

        gson.registerTypeAdapter(EntitySelector.class, new EntitySelectorAdapter());
        gson.setPrettyPrinting();

        this.entitySelector = gson.create();
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onRenderLiving(RenderLivingEvent.Pre<EntityLivingBase> event)
    {
        EntityLivingBase entity = event.getEntity();
        IModelRenderer cap = ModelRenderer.get(entity);

        if (cap != null && currentRendering == null)
        {
            currentRendering = entity;

            if (cap.render(entity, event.getX(), event.getY(), event.getZ(), Minecraft.getMinecraft().getRenderPartialTicks()))
            {
                event.setCanceled(true);
            }

            currentRendering = null;
        }
    }

    @SubscribeEvent
    public void onUpdateEntity(LivingUpdateEvent event)
    {
        EntityLivingBase entity = event.getEntityLiving();
        IModelRenderer cap = ModelRenderer.get(entity);

        if (cap != null && entity.world.isRemote)
        {
            cap.update(entity);
        }
    }

    public void loadSelectors()
    {
        File selectorsFile = Metamorph.proxy.selectors;

        if (selectorsFile.exists())
        {
            try
            {
                Type token = (new TypeToken<List<EntitySelector>>() {}).getType();
                List<EntitySelector> selectors = this.entitySelector.fromJson(FileUtils.readFileToString(selectorsFile, StandardCharsets.UTF_8), token);

                EntityModelHandler.selectors.clear();
                EntityModelHandler.selectors.addAll(selectors);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }

    public void saveSelectors()
    {
        try
        {
            JsonElement element = this.entitySelector.toJsonTree(selectors);

            FileUtils.writeStringToFile(Metamorph.proxy.selectors, JsonUtils.jsonToPretty(element), StandardCharsets.UTF_8);
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}

==================================================

--- Файл №58 ---
Путь: main\java\mchorse\metamorph\client\KeyboardHandler.java
--------------------
package mchorse.metamorph.client;

import mchorse.metamorph.ClientProxy;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.client.gui.creative.GuiCreativeScreen;
import mchorse.metamorph.client.gui.creative.GuiSelectorsScreen;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.survival.PacketAction;
import mchorse.metamorph.network.common.survival.PacketSelectMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.client.registry.ClientRegistry;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.InputEvent;
import org.lwjgl.input.Keyboard;

/**
 * Keyboard handler 
 * 
 * This class (handler) is responsible for handling the keyboard input for 
 * executing an action and morphing the player using survival morphing menu.
 * 
 * This handler is also responsible for opening up creative morphing menu.
 */
public class KeyboardHandler
{
    /* Action key */
    private KeyBinding keyAction;
    private KeyBinding keyCreativeMenu;
    private KeyBinding keySelectorMenu;
    private KeyBinding keySurvivalMenu;

    /* Morph related keys */
    public KeyBinding keyDemorph;

    public KeyboardHandler()
    {
        String category = "key.metamorph";

        /* Create key bindings */
        keyAction = new KeyBinding("key.metamorph.action", Keyboard.KEY_V, category);
        keyCreativeMenu = new KeyBinding("key.metamorph.creative_menu", Keyboard.KEY_B, category);
        keySelectorMenu = new KeyBinding("key.metamorph.selector_menu", Keyboard.KEY_MINUS, category);
        keySurvivalMenu = new KeyBinding("key.metamorph.survival_menu", Keyboard.KEY_X, category);

        keyDemorph = new KeyBinding("key.metamorph.demorph", Keyboard.KEY_PERIOD, category);

        /* Register them in the client registry */
        ClientRegistry.registerKeyBinding(keyAction);
        ClientRegistry.registerKeyBinding(keyCreativeMenu);
        ClientRegistry.registerKeyBinding(keySelectorMenu);
        ClientRegistry.registerKeyBinding(keySurvivalMenu);

        ClientRegistry.registerKeyBinding(keyDemorph);
    }

    @SubscribeEvent
    public void onKey(InputEvent.KeyInputEvent event)
    {
        Minecraft mc = Minecraft.getMinecraft();
        EntityPlayer player = mc.player;
        IMorphing morphing = Morphing.get(player);

        boolean wasUsed = false;
        boolean spectator = player.isSpectator();

        if (this.keyCreativeMenu.isPressed() && Metamorph.proxy.canUse(player))
        {
            mc.displayGuiScreen(new GuiCreativeScreen(mc));
            wasUsed = true;
        }

        if (this.keySelectorMenu.isPressed() && Metamorph.proxy.canEditSelectors())
        {
            mc.displayGuiScreen(new GuiSelectorsScreen(mc));
            wasUsed = true;
        }

        /* Action */
        if (this.keyAction.isPressed() && !spectator)
        {
            Dispatcher.sendToServer(new PacketAction());

            if (morphing != null && morphing.isMorphed())
            {
                morphing.getCurrentMorph().action(player);
                wasUsed = true;
            }
        }

        /* Survival morphing key handling */
        if (this.keySurvivalMenu.isPressed() && !spectator)
        {
            mc.displayGuiScreen(ClientProxy.getSurvivalScreen().open());
            wasUsed = true;
        }

        /* Demorph from current morph */
        if (this.keyDemorph.isPressed() && !spectator)
        {
            if (morphing != null && morphing.isMorphed())
            {
                Dispatcher.sendToServer(new PacketSelectMorph(-1));
                wasUsed = true;
            }
        }

        if (!wasUsed && Keyboard.getEventKeyState())
        {
            int key = Keyboard.getEventKey() == 0 ? Keyboard.getEventCharacter() + 256 : Keyboard.getEventKey();

            MorphManager.INSTANCE.list.keyTyped(player, key);
        }
    }
}

==================================================

--- Файл №59 ---
Путь: main\java\mchorse\metamorph\client\NetworkHandler.java
--------------------
package mchorse.metamorph.client;

import java.nio.charset.Charset;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphSettings;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.Morphing;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.network.PacketBuffer;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent.ClientCustomPacketEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Custom payload network hander
 * 
 * This network handler allows plugins to give morphs to players
 */
@SideOnly(Side.CLIENT)
public class NetworkHandler
{
    /**
     * This handler handles custom payload messages 
     */
    @SubscribeEvent
    public void onCustomMessage(ClientCustomPacketEvent event)
    {
        try
        {
            PacketBuffer buffer = (PacketBuffer) event.getPacket().payload();
            byte[] array = new byte[buffer.capacity()];

            for (int i = 0, c = array.length; i < c; i++)
            {
                array[i] = buffer.readByte();
            }

            String data = new String(array, Charset.forName("UTF-8")).trim();
            String[] args = data.split(" ");

            if (args.length >= 1)
            {
                Minecraft.getMinecraft().addScheduledTask(new MorphRunnable(args));
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Morph runnable
     * 
     * This class is responsible for morphing a player into a morph or 
     * demorph him based on the arguments passed in the payload packet.
     */
    public static class MorphRunnable implements Runnable
    {
        public String[] args;

        public MorphRunnable(String[] args)
        {
            this.args = args;
        }

        @Override
        public void run()
        {
            EntityPlayer player = Minecraft.getMinecraft().world.getPlayerEntityByName(this.args[0]);

            if (player == null)
            {
                return;
            }

            if (this.args.length >= 3)
            {
                String data = this.args[2];

                for (int i = 3; i < this.args.length; i++)
                {
                    data += " " + this.args[i];
                }

                try
                {
                    NBTTagCompound tag = JsonToNBT.getTagFromJson(data);
                    tag.setString("Name", this.args[1]);
                    this.morph(tag, player);
                }
                catch (Exception e)
                {}
            }
            else if (this.args.length == 2)
            {
                NBTTagCompound tag = new NBTTagCompound();
                tag.setString("Name", this.args[1]);
                this.morph(tag, player);
            }
            else if (this.args.length == 1)
            {
                Morphing.get(player).setCurrentMorph(null, player, true);
            }
        }

        private void morph(NBTTagCompound tag, EntityPlayer player)
        {
            AbstractMorph morph = MorphManager.INSTANCE.morphFromNBT(tag);

            if (morph != null)
            {
                /* No fancy stuff or actions */
                morph.forceSettings(MorphSettings.DEFAULT);

                Morphing.get(player).setCurrentMorph(morph, player, true);
            }
        }
    }
}

==================================================

--- Файл №60 ---
Путь: main\java\mchorse\metamorph\client\RenderingHandler.java
--------------------
package mchorse.metamorph.client;

import mchorse.metamorph.ClientProxy;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.client.gui.overlays.GuiHud;
import mchorse.metamorph.client.gui.overlays.GuiOverlay;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.renderer.EntityRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.scoreboard.Team;
import net.minecraftforge.client.event.RenderGameOverlayEvent;
import net.minecraftforge.client.event.RenderLivingEvent;
import net.minecraftforge.client.event.RenderPlayerEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Rendering handler
 *
 * This handler is rendering handler which is responsible for few things:
 * 
 * - Overlays (survival morph menu, morph acquiring)
 * - Player model
 */
@SideOnly(Side.CLIENT)
public class RenderingHandler
{
    private GuiOverlay morphOverlay;
    private GuiHud hud;
    private RenderManager manager;

    public RenderingHandler(GuiOverlay morphOverlay, GuiHud hud)
    {
        this.morphOverlay = morphOverlay;
        this.hud = hud;
        this.manager = Minecraft.getMinecraft().getRenderManager();
    }

    /**
     * Draw HUD additions 
     */
    @SubscribeEvent
    public void onHUDRender(RenderGameOverlayEvent.Post event)
    {
        ScaledResolution resolution = event.getResolution();

        if (event.getType() == RenderGameOverlayEvent.ElementType.ALL)
        {
            this.morphOverlay.render(resolution.getScaledWidth(), resolution.getScaledHeight());
        }
    }

    /**
     * Draw replacement air bar for morphs that can't breathe on land
     */
    @SubscribeEvent
    public void onAirRenderPre(RenderGameOverlayEvent.Pre event)
    {
        if (event.getType() != RenderGameOverlayEvent.ElementType.AIR || event.isCanceled())
        {
            return;
        }

        if (this.hud.renderSquidAir)
        {
            event.setCanceled(true);

            ScaledResolution resolution = event.getResolution();
            this.hud.renderSquidAir(resolution.getScaledWidth(), resolution.getScaledHeight());
        }
    }

    /**
     * Render player hook
     * 
     * This method is responsible for rendering player, in case if he's morphed, 
     * into morphed entity. This method is also responsible for down scaling
     * oversized entities in inventory GUIs.
     * 
     * I wish devs at Mojang scissored the inventory area where those the 
     * player model is rendered. 
     */
    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerRender(RenderPlayerEvent.Pre event)
    {
        EntityPlayer player = event.getEntityPlayer();
        IMorphing capability = Morphing.get(player);

        /* No morph, no problem */
        if (capability == null)
        {
            return;
        }

        int animation = capability.getAnimation();

        /* Render the morph */
        if (capability.renderPlayer(player, event.getX(), event.getY(), event.getZ(), player.rotationYaw, event.getPartialRenderTick()))
        {
            event.setCanceled(true);
        }
        else if (capability.isAnimating())
        {
            float partialTick = event.getPartialRenderTick();
            float anim = 0;

            if (capability.getCurrentMorph() == null && animation <= 10)
            {
                anim = 1 - (animation - partialTick) / 10.0F;
            }
            else if (capability.getPreviousMorph() == null && animation > 10)
            {
                anim = (animation - 10 - partialTick) / 10.0F;
            }

            GlStateManager.color(1, 1, 1, anim);
        }
    }

    /**
     * On name render, simply render the name of the user, instead of the name of 
     * the entity.
     */
    @SubscribeEvent
    public void onNameRender(RenderLivingEvent.Specials.Pre<EntityLivingBase> event)
    {
        EntityLivingBase host = EntityMorph.renderEntity;

        if (host == null)
        {
            return;
        }

        event.setCanceled(true);

        EntityLivingBase target = event.getEntity();
        Entity camera = Minecraft.getMinecraft().getRenderViewEntity();

        if (!this.canRenderName(host) || camera == null)
        {
            return;
        }

        double dist = target.getDistanceSq(camera);
        float factor = target.isSneaking() ? 32.0F : 64.0F;

        if (dist < factor * factor)
        {
            GlStateManager.alphaFunc(516, 0.1F);
            this.renderEntityName(target, host.getDisplayName().getFormattedText(), event.getX(), event.getY(), event.getZ());
        }
    }

    /**
     * Can render the morph's name 
     */
    protected boolean canRenderName(EntityLivingBase host)
    {
        EntityPlayerSP entityplayersp = Minecraft.getMinecraft().player;
        boolean flag = !host.isInvisibleToPlayer(entityplayersp);

        if (host != entityplayersp)
        {
            Team team = host.getTeam();
            Team team1 = entityplayersp.getTeam();

            if (team != null)
            {
                Team.EnumVisible team$enumvisible = team.getNameTagVisibility();

                switch (team$enumvisible)
                {
                    case ALWAYS:
                        return flag;
                    case NEVER:
                        return false;
                    case HIDE_FOR_OTHER_TEAMS:
                        return team1 == null ? flag : team.isSameTeam(team1) && (team.getSeeFriendlyInvisiblesEnabled() || flag);
                    case HIDE_FOR_OWN_TEAM:
                        return team1 == null ? flag : !team.isSameTeam(team1) && flag;
                    default:
                        return true;
                }
            }
        }

        if (!(host instanceof EntityPlayer))
        {
            flag = flag && host.hasCustomName();
        }

        return Minecraft.isGuiEnabled() && host != this.manager.renderViewEntity && flag && !host.isBeingRidden();
    }

    /**
     * Renders an entity's name above its head (copied and modified from 
     * {@link RenderLivingBase})
     */
    protected void renderEntityName(EntityLivingBase entity, String name, double x, double y, double z)
    {
        if (name.isEmpty())
        {
            return;
        }

        boolean sneaking = entity.isSneaking();
        boolean thirdFrontal = this.manager.options.thirdPersonView == 2;

        float px = this.manager.playerViewY;
        float py = this.manager.playerViewX;
        float pz = entity.height + 0.5F - (sneaking ? 0.25F : 0.0F);

        int i = "deadmau5".equals(name) ? -10 : 0;

        EntityRenderer.drawNameplate(this.manager.getFontRenderer(), name, (float) x, (float) y + pz, (float) z, i, px, py, thirdFrontal, sneaking);
    }

    @SubscribeEvent
    public void onClientDisconnect(FMLNetworkEvent.ClientDisconnectionFromServerEvent event)
    {
        MorphManager.INSTANCE.list.reset();
        ClientProxy.survivalScreen = null;
    }
}

==================================================

--- Файл №61 ---
Путь: main\java\mchorse\metamorph\client\gui\GuiMorphs.java
--------------------
package mchorse.metamorph.client.gui;

import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiMorphSection;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;

public class GuiMorphs extends GuiScrollElement
{
    private static final MorphCategory EMPTY_CATEGORY = new MorphCategory(null, null);

    /**
     * Cached previous filter. Used for avoiding double recalculations
     */
    public String filter = "";

    public List<GuiMorphSection> sections = new ArrayList<GuiMorphSection>();
    public GuiMorphSection selected;

    public int x;
    public int y;

    private boolean scrollTo;

    public GuiMorphs(Minecraft mc)
    {
        super(mc);

        this.scroll.scrollSpeed = 45;

        IKey category = IKey.lang("metamorph.gui.morphs.keys.category");

        this.keys().register(IKey.lang("metamorph.gui.morphs.keys.down"), Keyboard.KEY_DOWN, () -> this.pickMorph(0, 1)).category(category);
        this.keys().register(IKey.lang("metamorph.gui.morphs.keys.up"), Keyboard.KEY_UP, () -> this.pickMorph(0, -1)).category(category);
        this.keys().register(IKey.lang("metamorph.gui.morphs.keys.right"), Keyboard.KEY_RIGHT, () -> this.pickMorph(1, 0)).category(category);
        this.keys().register(IKey.lang("metamorph.gui.morphs.keys.left"), Keyboard.KEY_LEFT, () -> this.pickMorph(-1, 0)).category(category);
    }

    private void pickMorph(int x, int y)
    {
        if (this.selected == null || this.selected.morph == null)
        {
            x = 0;
            y = 0;

            this.selected = this.sections.get(0);
            this.selected.category = this.selected.section.categories.get(0);
            this.x = this.y = 0;
        }
        else
        {
            this.selected.calculateXY(this);
        }

        int ox = this.x;

        this.x += x;
        this.y += y;

        AbstractMorph morph = this.selected.getMorphAt(this);

        if (morph != null)
        {
            this.selected.morph = morph;
            this.selected.pick(this.selected.morph, this.selected.category);
            this.scrollTo();

            return;
        }

        if (y < 0 && this.isFirstCategory(this.selected))
        {
            return;
        }
        else if (y > 0 && this.isLastCategory(this.selected))
        {
            return;
        }

        if (y == 0)
        {
            y = 1;
        }

        GuiMorphSection original = this.selected;
        GuiMorphSection section = this.selected;
        MorphCategory category = this.selected.category;

        do
        {
            int index = section.section.categories.indexOf(category) + y;

            if (index < 0)
            {
                int sectionIndex = this.sections.indexOf(section) - 1;

                if (sectionIndex < 0)
                {
                    return;
                }

                section = this.sections.get(sectionIndex);
                category = section.section.categories.isEmpty() ? EMPTY_CATEGORY : section.section.categories.get(section.section.categories.size() - 1);
            }
            else if (index >= section.section.categories.size())
            {
                int sectionIndex = this.sections.indexOf(section) + 1;

                if (sectionIndex >= this.sections.size())
                {
                    return;
                }

                section = this.sections.get(sectionIndex);
                category = section.section.categories.isEmpty() ? EMPTY_CATEGORY : section.section.categories.get(0);
            }
            else
            {
                category = section.section.categories.get(index);
            }
        }
        while (this.isCategoryEmpty(section, category));

        if (category.getMorphs().isEmpty())
        {
            return;
        }

        original.reset();
        this.selected = section;
        this.selected.category = category;
        this.selected.morph = this.getFirstMorph(ox, y);
        this.selected.pick(this.selected.morph, this.selected.category);
        this.scrollTo();
    }

    private boolean isFirstCategory(GuiMorphSection section)
    {
        return section == this.sections.get(0) && section.category == section.section.categories.get(0);
    }

    private boolean isLastCategory(GuiMorphSection section)
    {
        return section == this.sections.get(this.sections.size() - 1) && section.category == section.section.categories.get(section.section.categories.size() - 1);
    }

    private boolean isCategoryEmpty(GuiMorphSection section, MorphCategory category)
    {
        if (category.getMorphs().isEmpty())
        {
            return true;
        }

        return section.getMorphsSize(category) == 0;
    }

    private AbstractMorph getFirstMorph(int ox, int y)
    {
        List<AbstractMorph> list = this.selected.category.getMorphs();
        AbstractMorph first = null;

        int row = this.selected.getPerRow();
        int j = 0;
        int c = this.selected.getMorphsSize(this.selected.category);
        int firstIndex = y < 0 ? c - 1 : 0;
        int lastIndex = y < 0 ? (c - 1) / row * row + ox : ox;

        for (AbstractMorph morph : list)
        {
            if (this.selected.isMatching(morph))
            {
                if (j == firstIndex)
                {
                    first = morph;
                }

                if (j == lastIndex)
                {
                    return morph;
                }

                j ++;
            }
        }

        return first;
    }

    /* Morph selection */

    public void setSelected(AbstractMorph morph)
    {
        this.resetSelected();
    }

    public void setSelectedDirect(GuiMorphSection selected)
    {
        this.setSelectedDirect(selected, selected.morph, selected.category);
    }

    public void setSelectedDirect(GuiMorphSection section, AbstractMorph morph, MorphCategory category)
    {
        this.resetSelected();

        this.selected = section;
        this.selected.set(morph, category);
    }

    public void resetSelected()
    {
        if (this.selected != null)
        {
            this.selected.reset();
        }
    }

    public AbstractMorph getSelected()
    {
        return this.selected == null ? null : this.selected.morph;
    }

    /* Section management */

    /**
     * Set filter for search
     *
     * This method is responsible for recalculating the hidden flag of the
     * individual cells and changing heights and y position of each category.
     */
    public void setFilter(String filter)
    {
        if (filter.equals(this.filter))
        {
            return;
        }

        String lcfilter = filter.toLowerCase().trim();

        for (GuiMorphSection section : this.sections)
        {
            section.setFilter(lcfilter);
        }

        this.filter = lcfilter;
    }

    public void setFavorite(boolean favorite)
    {
        for (GuiMorphSection section : this.sections)
        {
            section.favorite = favorite;
        }
    }

    /**
     * Scroll to the selected morph
     *
     * This method heavily relies on the elements drawn before hand
     */
    public void scrollTo()
    {
        if (this.area.w == 0)
        {
            this.scrollTo = true;

            return;
        }

        AbstractMorph morph = this.getSelected();

        if (morph == null)
        {
            return;
        }

        int y = 0;

        for (GuiMorphSection section : this.sections)
        {
            if (section.morph == morph)
            {
                this.scroll.scrollIntoView(y + section.getY(section.morph), section.cellHeight + 30);

                break;
            }

            y += section.getFullHeight();
        }
    }

    @Override
    public void resize()
    {
        super.resize();

        for (GuiMorphSection section : this.sections)
        {
            section.flex().h(section.getFullHeight());
        }

        super.resize();

        if (this.scrollTo)
        {
            this.scrollTo = false;
            this.scrollTo();
        }
    }
}

==================================================

--- Файл №62 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiCreativeMorphs.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.MorphList;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.creative.sections.UserSection;
import mchorse.metamorph.api.events.ReloadMorphs;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.GuiMorphs;
import net.minecraft.client.Minecraft;
import net.minecraftforge.common.MinecraftForge;

import java.util.function.Consumer;

public class GuiCreativeMorphs extends GuiMorphs
{
    public UserSection user;
    public GuiMorphSection userSection;

    private GuiCreativeMorphsList parent;

    public GuiCreativeMorphs(Minecraft mc, GuiCreativeMorphsList parent)
    {
        super(mc);

        this.parent = parent;
    }

    public void setupSections(GuiCreativeMorphsList menu, Consumer<GuiMorphSection> callback)
    {
        MorphList list = MorphManager.INSTANCE.list;

        list.update(this.mc.world);
        MinecraftForge.EVENT_BUS.post(new ReloadMorphs());

        this.sections.clear();
        this.removeAll();

        for (MorphSection section : list.sections)
        {
            GuiMorphSection element = section.getGUI(this.mc, menu, callback);

            if (section instanceof UserSection)
            {
                this.user = (UserSection) section;
                this.userSection = element;
            }

            element.flex();
            this.sections.add(element);
            this.add(element);
        }

        this.sections.get(this.sections.size() - 1).last = true;
    }

    @Override
    public void setSelected(AbstractMorph morph)
    {
        super.setSelected(morph);

        if (this.selected != null)
        {
            this.selected.reset();
        }

        if (morph != null)
        {
            AbstractMorph found = null;
            MorphCategory selectedCategory = null;
            GuiMorphSection selectedSection = null;

            searchForMorph:
            for (GuiMorphSection section : this.sections)
            {
                for (MorphCategory category : section.section.categories)
                {
                    found = category.getEqual(morph);

                    if (found != null)
                    {
                        selectedCategory = category;
                        selectedSection = section;

                        break searchForMorph;
                    }
                }
            }

            if (found == null)
            {
                this.copyToRecent(morph);
            }
            else
            {
                this.selected = selectedSection;
                this.scrollTo();

                selectedSection.morph = found;
                selectedSection.category = selectedCategory;
                this.parent.pickMorph(found);
            }
        }
        else
        {
            this.selected = null;
        }
    }

    public void syncSelected()
    {
        AbstractMorph morph = this.getSelected();

        if (morph != null && this.selected != null && this.selected.category != null)
        {
            this.selected.category.edit(morph);
        }
    }

    public AbstractMorph copyToRecent(AbstractMorph morph)
    {
        if (this.selected != null)
        {
            this.selected.reset();
        }

        morph = morph.copy();

        this.user.recent.add(morph);
        this.selected = this.userSection;
        this.selected.morph = morph;
        this.selected.category = this.user.recent;
        this.parent.pickMorph(morph);

        this.scrollTo();

        return morph;
    }

    public boolean isSelectedMorphIsEditable()
    {
        return this.selected != null && this.selected.category != null && this.selected.category.isEditable(this.getSelected());
    }
}

==================================================

--- Файл №63 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiCreativeMorphsList.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiDelegateElement;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDrawable;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Keybind;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.Timer;
import mchorse.mclib.utils.shaders.Shader;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.categories.UserCategory;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.NBTTagCompound;

import org.apache.commons.io.IOUtils;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL20;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;
import java.util.function.Consumer;

import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;

/**
 * Scroll list of available morphs
 * 
 * More morphs than presented in this menu are available, but the problem that 
 * it's impossible to list all variation of those morphs. iChun probably knows 
 * it, that's why he doesn't bother with a GUI of all available morphs.
 */
public class GuiCreativeMorphsList extends GuiElement
{
    public static Shader shader;
    public static int skinColor = -1;

    /**
     * Morph consumer 
     */
    public Consumer<AbstractMorph> callback;

    /**
     * Available morph editors 
     */
    private List<GuiAbstractMorph> editors;

    /**
     * Morph editor 
     */
    public GuiDelegateElement<GuiAbstractMorph> editor;

    public GuiElement bar;
    public GuiTextElement search;
    public GuiButtonElement edit;

    public GuiElement screen;
    public GuiQuickEditor quickEditor;
    public GuiCreativeMorphs morphs;

    public List<OnionSkin> onionSkins = new ArrayList<OnionSkin>();
    public List<OnionSkin> lastOnionSkins;

    private Timer timer = new Timer(100);
    private Stack<NestedEdit> nestedEdits = new Stack<NestedEdit>();

    protected Keybind exitKey;

    protected boolean keepViewport;

    protected Vector3f lastPos = new Vector3f();
    protected float lastYaw;
    protected float lastPitch;
    protected float lastScale;

    protected boolean doRenderOnionSkin;

    private DummyEntity entity;

    /**
     * Initiate this GUI.
     * 
     * Compile the categories list and compute the scroll height of this scroll pane 
     */
    public GuiCreativeMorphsList(Minecraft mc, Consumer<AbstractMorph> callback)
    {
        super(mc);

        this.callback = callback;
        this.editor = new GuiDelegateElement<GuiAbstractMorph>(mc, null);
        this.editor.flex().relative(this).wh(1F, 1F);

        this.screen = new GuiElement(mc);
        this.screen.flex().relative(this).wh(1F, 1F);

        /* Create quick editor */
        this.quickEditor = new GuiQuickEditor(mc, this);
        this.quickEditor.flex().relative(this).x(1F, -200).wTo(this.flex(), 1F).h(1F);
        this.quickEditor.setVisible(false);

        /* Create morph panels */
        this.morphs = new GuiCreativeMorphs(mc, this);
        this.morphs.flex().relative(this).wh(1F, 1F).column(0).vertical().stretch().scroll();

        /* Initiate bottom bar */
        this.bar = new GuiElement(mc);
        this.search = new GuiTextElement(mc, this.morphs::setFilter);
        this.edit = new GuiButtonElement(mc, IKey.lang("metamorph.gui.edit"),  (b) -> this.enterEditMorph());
        this.edit.setEnabled(false);
        this.edit.flex().w(60);

        this.bar.flex().relative(this.morphs).set(10, 0, 0, 20).y(1, -30).w(1, -20).row(5).preferred(0).height(20);
        this.bar.add(this.search, this.edit);

        this.screen.add(this.morphs, this.bar, this.quickEditor);
        this.add(this.screen, new GuiDrawable(this::drawOverlay), this.editor);

        /* Onion skin */
        this.doRenderOnionSkin = true;
        this.entity = new DummyEntity(mc.world);

        if (shader == null)
        {
            try
            {
                String vert = IOUtils.toString(this.getClass().getResourceAsStream("/assets/metamorph/shaders/onionskin.vert"), StandardCharsets.UTF_8);
                String frag = IOUtils.toString(this.getClass().getResourceAsStream("/assets/metamorph/shaders/onionskin.frag"), StandardCharsets.UTF_8);

                shader = new Shader();
                shader.compile(vert, frag, true);

                GL20.glUniform1i(GL20.glGetUniformLocation(shader.programId, "texture"), 0);

                skinColor = GL20.glGetUniformLocation(shader.programId, "onionskin");
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }

        /* Morph editor keybinds */
        IKey category = IKey.lang("metamorph.gui.creative.keys.category");

        this.exitKey = this.keys().register(IKey.lang("metamorph.gui.creative.keys.exit"), Keyboard.KEY_ESCAPE, this::exit).category(category).active(this::updateExitKey);

        this.reload();

        this.morphs.keys().register(IKey.lang("metamorph.gui.creative.keys.edit"), Keyboard.KEY_E, this::enterEditMorph).category(category);
        this.morphs.keys().register(IKey.lang("metamorph.gui.creative.keys.quick"), Keyboard.KEY_Q, this::toggleQuickEdit).category(category);
        this.morphs.keys().register(IKey.lang("metamorph.gui.creative.keys.focus"), Keyboard.KEY_F, () -> GuiBase.getCurrent().focus(this.search, true)).held(Keyboard.KEY_LCONTROL).category(category);

        this.keys().register(IKey.lang("metamorph.gui.creative.keys.onionskin"), Keyboard.KEY_Q, () -> this.doRenderOnionSkin = !this.doRenderOnionSkin).active(() -> this.isEditMode() && this.haveOnionSkin()).category(category);
    }

    public void reload()
    {
        this.morphs.setupSections(this, this::pickMorph);
        this.search.setText("");
    }

    public void exit()
    {
        if (this.isEditMode())
        {
            this.exitEditMorph(this.nestedEdits.isEmpty(), false);
        }
        else
        {
            this.restoreEdit();
        }

        GuiBase.getCurrent().setContextMenu(null);
    }

    protected boolean updateExitKey()
    {
        return this.editor.delegate != null || !this.nestedEdits.isEmpty();
    }

    public Runnable showGlobalMorphs(AbstractMorph morph)
    {
        if (this.morphs.user.global.isEmpty() || morph == null)
        {
            return null;
        }
        
        return () -> 
        {
            GuiSimpleContextMenu contextMenu = new GuiSimpleContextMenu(this.mc);

            for (UserCategory category : this.morphs.user.global) 
            {
                contextMenu.action(IKey.str(category.getTitle()), () ->
                {
                    AbstractMorph added = morph.copy();

                    category.add(added);
                    this.setSelected(added);
                });
            }

            GuiBase.getCurrent().replaceContextMenu(contextMenu);
        };
    }

    public void markDirty()
    {
        this.timer.mark();
    }

    public void disableDirty()
    {
        if (this.timer.enabled)
        {
            this.timer.enabled = false;
            this.morphs.syncSelected();
        }
    }

    /* Quick mode */

    public void toggleQuickEdit()
    {
        if (this.isEditMode() || !this.quickEditor.isVisible() && this.getSelected() == null)
        {
            return;
        }

        this.quickEditor.toggleVisible();

        if (this.quickEditor.isVisible())
        {
            AbstractMorph morph = this.getSelected();

            if (!this.isSelectedMorphIsEditable())
            {
                morph = this.morphs.copyToRecent(morph);
            }

            this.quickEditor.setMorph(morph, this.getMorphEditor(morph));
            this.morphs.flex().wTo(this.quickEditor.flex());
        }
        else
        {
            this.morphs.flex().w(1F);
        }

        this.resize();
    }

    /* Nested editing */

    public boolean isNested()
    {
        return !this.nestedEdits.isEmpty();
    }

    public void nestEdit(AbstractMorph selected, boolean editing, Consumer<AbstractMorph> callback)
    {
        this.nestEdit(selected, editing, false, callback);
    }

    public void nestEdit(AbstractMorph selected, boolean editing, boolean keepViewport, Consumer<AbstractMorph> callback)
    {
        NestedEdit edit = new NestedEdit(this.morphs.filter, this.editor.delegate.morph, this.editor.delegate.toNBT(), this.callback, this.morphs.selected, editing, this.keepViewport, this.lastOnionSkins);
        this.callback = callback;
        this.keepViewport = keepViewport;

        if (keepViewport)
        {
            this.saveViewport();

            this.lastOnionSkins = this.lastOnionSkins == null ? new ArrayList<OnionSkin>() : new ArrayList<OnionSkin>(this.lastOnionSkins);
            this.lastOnionSkins.addAll(this.onionSkins);
        }
        else
        {
            this.lastOnionSkins = null;
        }

        this.nestedEdits.add(edit);
        this.updateExitKey();

        if (editing)
        {
            this.enterEditMorph(selected);
        }
        else
        {
            this.exitEditMorph(false, true);
            this.morphs.setFilter("");
            this.setSelected(selected);
        }
    }

    public void restoreEdit()
    {
        if (this.nestedEdits.isEmpty())
        {
            return;
        }

        NestedEdit edit = this.nestedEdits.pop();

        if (!edit.editing)
        {
            this.pickMorph(this.getSelected());
        }
        this.morphs.setFilter("");
        this.morphs.setSelectedDirect(edit.selected, edit.selectedMorph, edit.selectedCategory);
        this.callback = edit.callback;
        this.morphs.scrollTo();

        this.enterEditMorph(edit.editMorph);
        this.editor.delegate.fromNBT(edit.data);

        if (this.keepViewport)
        {
            this.loadViewport();
        }

        this.keepViewport = edit.keepViewport;
        this.lastOnionSkins = edit.lastOnionSkins;
    }

    /* Edit mode */

    public boolean isEditMode()
    {
        return this.editor.delegate != null;
    }

    public void enterEditMorph()
    {
        AbstractMorph morph = this.getSelected();

        if (morph == null)
        {
            return;
        }

        if (!this.isSelectedMorphIsEditable() || !this.nestedEdits.isEmpty())
        {
            morph = morph.copy();
            this.pickMorph(morph);
        }

        this.enterEditMorph(morph);
    }

    public void enterEditMorph(AbstractMorph morph)
    {
        if (morph == null)
        {
            return;
        }

        this.disableDirty();

        this.onionSkins.clear();

        GuiAbstractMorph editor = this.getMorphEditor(morph);

        if (editor != null)
        {
            this.setEditor(editor);

            if (this.keepViewport)
            {
                this.loadViewport();
            }

            editor.renderer.beforeRender = this::beforeRenderModel;
            editor.renderer.afterRender = this::afterRenderModel;
        }
    }

    public void exitEditMorph(boolean add, boolean ignore)
    {
        if (!this.isEditMode())
        {
            return;
        }

        this.editor.delegate.renderer.beforeRender = null;
        this.editor.delegate.renderer.afterRender = null;

        if (this.keepViewport)
        {
            this.saveViewport();
        }

        this.editor.delegate.finishEdit();

        AbstractMorph edited = this.editor.delegate.morph;

        if (!this.nestedEdits.isEmpty() && !ignore)
        {
            this.pickMorph(edited);
            this.restoreEdit();

            return;
        }

        this.morphs.syncSelected();

        if (add && edited != null && !this.isSelectedMorphIsEditable())
        {
            this.setSelected(edited);
        }

        this.setEditor(null);
    }

    protected void setEditor(GuiAbstractMorph editor)
    {
        this.editor.setDelegate(editor);
        this.screen.setVisible(editor == null);
        this.updateExitKey();
    }

    public void finish()
    {
        int i = 0;

        while (this.isNested() || this.isEditMode())
        {
            this.exit();

            i ++;
        }

        if (i > 0)
        {
            this.pickMorph(MorphUtils.copy(this.getSelected()));
        }

        this.keepViewport = false;
        this.lastOnionSkins = null;
    }

    private GuiAbstractMorph getMorphEditor(AbstractMorph morph)
    {
        if (this.editors == null)
        {
            this.editors = new ArrayList<GuiAbstractMorph>();
            MorphManager.INSTANCE.registerMorphEditors(this.mc, this.editors);
        }

        for (GuiAbstractMorph editor : this.editors)
        {
            if (editor.canEdit(morph))
            {
                editor.setMorphs(this);
                editor.startEdit(morph);

                return editor;
            }
        }

        return null;
    }

    private void saveViewport()
    {
        GuiModelRenderer renderer = this.editor.delegate.renderer;

        this.lastPos.set(renderer.pos);
        this.lastPitch = renderer.pitch;
        this.lastYaw = renderer.yaw;
        this.lastScale = renderer.scale;
    }

    private void loadViewport()
    {
        GuiModelRenderer renderer = this.editor.delegate.renderer;

        renderer.setPosition(this.lastPos.x, this.lastPos.y, this.lastPos.z);
        renderer.setRotation(this.lastYaw, this.lastPitch);
        renderer.setScale(this.lastScale);
    }

    protected void beforeRenderModel(GuiContext context)
    {}

    protected void afterRenderModel(GuiContext context)
    {
        this.renderOnionSkin(context);
    }

    /* Onion skin */

    public boolean haveOnionSkin()
    {
        return !this.onionSkins.isEmpty() || this.lastOnionSkins != null && !this.lastOnionSkins.isEmpty();
    }

    private void renderOnionSkin(GuiContext context)
    {
        if (!this.doRenderOnionSkin)
        {
            return;
        }

        this.entity.ticksExisted = this.editor.delegate.renderer.getEntity().ticksExisted;

        shader.bind();
        GuiModelRenderer.disableRenderingFlag();

        if (this.lastOnionSkins != null)
        {
            for (OnionSkin skin : this.lastOnionSkins)
            {
                renderSingleOnionSkin(skin, context.partialTicks);
            }
        }

        for (OnionSkin skin : this.onionSkins)
        {
            renderSingleOnionSkin(skin, context.partialTicks);
        }

        shader.unbind();
    }

    private void renderSingleOnionSkin(OnionSkin skin, float partialTicks)
    {
        if (skin.morph == null)
        {
            return;
        }

        GL20.glUniform4f(skinColor, skin.color.r, skin.color.g, skin.color.b, skin.color.a);

        entity.prevRotationPitch = entity.rotationPitch = skin.pitch;
        entity.prevRenderYawOffset = entity.renderYawOffset = skin.yawBody;
        entity.prevRotationYawHead = entity.rotationYawHead = skin.yawHead;

        GlStateManager.pushMatrix();
        MorphUtils.render(skin.morph, entity, skin.offset.x, skin.offset.y, skin.offset.z, 0, partialTicks);
        GlStateManager.popMatrix();
    }

    /* Morph selection and filtering */

    /**
     * Get currently selected morph
     */
    public AbstractMorph getSelected()
    {
        if (this.isEditMode())
        {
            AbstractMorph morph = this.editor.delegate.morph;

            if (morph != null)
            {
                return morph;
            }
        }

        return this.morphs.getSelected();
    }

    public void pickMorph(GuiMorphSection selected)
    {
        this.disableDirty();

        this.morphs.setSelectedDirect(selected);

        this.pickMorph(selected.morph);
        this.syncQuickEditor();
    }

    public void pickMorph(AbstractMorph morph)
    {
        this.edit.setEnabled(morph != null);

        if (this.callback != null)
        {
            this.callback.accept(morph);
        }
    }

    /**
     * Set selected morph 
     */
    public AbstractMorph setSelected(AbstractMorph morph)
    {
        this.disableDirty();
        this.morphs.setSelected(morph);
        this.syncQuickEditor();

        morph = this.getSelected();

        this.edit.setEnabled(morph != null);

        return morph;
    }

    protected void syncQuickEditor()
    {
        if (this.quickEditor.isVisible())
        {
            AbstractMorph morph = this.getSelected();

            if (morph != null && this.isSelectedMorphIsEditable())
            {
                this.quickEditor.setMorph(morph, this.getMorphEditor(morph));
            }
            else
            {
                this.toggleQuickEdit();
            }
        }
    }
    
    protected boolean isSelectedMorphIsEditable()
    {
        return this.morphs.isSelectedMorphIsEditable();
    }

    /* Element overrides */

    @Override
    public void draw(GuiContext context)
    {
        if (this.timer.checkReset())
        {
            this.morphs.syncSelected();
        }

        super.draw(context);
    }

    private void drawOverlay(GuiContext context)
    {
        /* Draw the name of the morph */
        if (!this.isEditMode())
        {
            AbstractMorph morph = this.getSelected();
            String selected = morph != null ? morph.getDisplayName() : I18n.format("metamorph.gui.no_morph");
            boolean error = morph != null && morph.errorRendering;

            if (error)
            {
                selected = I18n.format("metamorph.gui.morph_render_error");
            }

            Area area = this.search.area;
            int w = Math.max(this.font.getStringWidth(selected), morph != null ? this.font.getStringWidth(morph.name) : 0);

            if (morph != null && !morph.errorRendering)
            {
                Gui.drawRect(area.x, area.y - 27, area.x + w + 8, area.y, 0xdd000000);
                this.font.drawStringWithShadow(selected, area.x + 4, area.y - 23, 0xffffffff);
                this.font.drawStringWithShadow(morph.name, area.x + 4, area.y - 12, 0x888888);
            }
            else
            {
                Gui.drawRect(area.x, area.y - 16, area.x + w + 8, area.y, 0xdd000000);
                this.font.drawStringWithShadow(selected, area.x + 4, area.y - 12, error ? 0xff1833 : 0xffffff);
            }
        }

        if (!this.isEditMode() && !this.search.field.isFocused() && this.search.field.getText().isEmpty())
        {
            this.font.drawStringWithShadow(I18n.format("metamorph.gui.search"), this.search.area.x + 5, this.search.area.y + 6, 0x888888);
        }
    }

    /**
     * Data stored about currently nested editing
     */
    public static class NestedEdit
    {
        public String filter;
        public NBTTagCompound data;
        public Consumer<AbstractMorph> callback;

        public GuiMorphSection selected;
        public MorphCategory selectedCategory;
        public AbstractMorph selectedMorph;
        public AbstractMorph editMorph;
        public boolean editing;
        public boolean keepViewport;
        public List<OnionSkin> lastOnionSkins;

        public NestedEdit(String filter, AbstractMorph editMorph, NBTTagCompound data, Consumer<AbstractMorph> callback, GuiMorphSection selected, boolean editing, boolean keepViewport, List<OnionSkin> lastOnionSkins)
        {
            this.filter = filter;
            this.data = data;
            this.editMorph = editMorph;
            this.callback = callback;
            this.editing = editing;
            this.keepViewport = keepViewport;
            this.lastOnionSkins = lastOnionSkins;

            this.selected = selected;
            this.selectedCategory = selected == null ? null : selected.category;
            this.selectedMorph = selected == null ? null : selected.morph;
        }
    }

    /**
     * Onion skin data
     */
    public static class OnionSkin
    {
        public Color color = new Color();

        public AbstractMorph morph;

        public Vector3d offset = new Vector3d(0, 0, 0);

        public float pitch = 0f;

        public float yawHead = 0f;

        public float yawBody = 0f;

        public OnionSkin color(float r, float g, float b, float a)
        {
            this.color.set(r, g, b, a);
            return this;
        }

        public OnionSkin morph(AbstractMorph morph)
        {
            this.morph = morph;
            return this;
        }

        public OnionSkin offset(double x, double y, double z, float pitch, float yawHead, float yawBody)
        {
            this.offset.set(x, y, z);
            this.pitch = pitch;
            this.yawHead = yawHead;
            this.yawBody = yawBody;
            return this;
        }
    }
}

==================================================

--- Файл №64 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiCreativeMorphsMenu.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;

import java.util.function.Consumer;

/**
 * Creative morph menu, but with a close button 
 */
public class GuiCreativeMorphsMenu extends GuiCreativeMorphsList
{
    private GuiButtonElement close;
    private GuiButtonElement acquire;
    private boolean menu;
    private boolean pickUponExit;

    public GuiCreativeMorphsMenu(Minecraft mc, Consumer<AbstractMorph> callback)
    {
        this(mc, false, callback);
    }

    public GuiCreativeMorphsMenu(Minecraft mc, boolean menu, Consumer<AbstractMorph> callback)
    {
        super(mc, callback);

        this.menu = menu;
        this.acquire = new GuiButtonElement(mc, IKey.lang("metamorph.gui.acquire"), (b) ->
        {
            AbstractMorph cell = this.getSelected();

            if (cell != null)
            {
                Dispatcher.sendToServer(new PacketAcquireMorph(cell));
            }
        });

        this.close = new GuiButtonElement(mc, IKey.str("X"), (b) -> this.exit());

        this.acquire.flex().w(60);
        this.close.flex().w(20);

        this.bar.flex().row(0).preferred(1);
        this.bar.prepend(this.acquire);

        if (!this.menu)
        {
            this.bar.add(this.close);
        }

        this.markContainer();

        this.keys().register(IKey.lang("metamorph.gui.creative.keys.acquire"), Keyboard.KEY_A, () -> this.acquire.clickItself(GuiBase.getCurrent())).category(this.exitKey.category).active(() -> !this.isEditMode());
    }

    public GuiCreativeMorphsMenu pickUponExit()
    {
        this.pickUponExit = true;

        return this;
    }

    @Override
    public void exit()
    {
        if (!this.menu && !this.isEditMode() && !this.isNested())
        {
            this.finish();
            this.removeFromParent();

            if (this.pickUponExit)
            {
                this.pickMorph(this.getSelected());
            }

            GuiBase.getCurrent().setContextMenu(null);
        }
        else
        {
            super.exit();
        }
    }

    @Override
    protected boolean updateExitKey()
    {
        if (this.menu)
        {
            return this.isEditMode() || this.isNested();
        }

        return true;
    }

    @Override
    public boolean isSelectedMorphIsEditable()
    {
        return this.morphs.selected != null && this.morphs.selected.category == this.morphs.user.recent;
    }

    /* Don't let click event pass through the background... */

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        return super.mouseClicked(context) || this.area.isInside(context.mouseX, context.mouseY);
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return super.mouseScrolled(context) || this.area.isInside(context.mouseX, context.mouseY);
    }

    @Override
    public void draw(GuiContext context)
    {
        GL11.glClear(GL11.GL_DEPTH_BUFFER_BIT);

        if (!this.menu)
        {
            Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), 0xaa000000);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №65 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiCreativeScreen.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.tooltips.LabelTooltip;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.OpHelper;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import mchorse.metamorph.network.common.creative.PacketMorph;
import mchorse.metamorph.util.MMIcons;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.NBTTagCompound;
import org.lwjgl.input.Keyboard;

/**
 * Creative morphs GUI
 * 
 * This class is responsible for allowing creative players to open up 
 * this GUI and select one of the available morphs in the game.
 * 
 * When player selects a morph and presses "Morph" button, he turns into 
 * this morphs, however, selected morph doesn't saves in player's 
 * acquired morphs.
 * 
 * This menu also allows player to edit morphs.
 */
public class GuiCreativeScreen extends GuiBase
{
    private GuiSelectorEditor selectors;
    private GuiIconElement icon;
    private GuiIconElement copy;
    private GuiButtonElement morph;
    private GuiButtonElement acquire;
    private GuiButtonElement close;
    private GuiCreativeMorphsList pane;

    public GuiCreativeScreen(Minecraft mc)
    {
        this.selectors = new GuiSelectorEditor(mc);
        this.selectors.setVisible(false);

        this.icon = new GuiIconElement(mc, MMIcons.PROPERTIES, this::toggleEntitySelector);
        this.icon.tooltip(IKey.lang("metamorph.gui.selectors.title"));
        this.icon.setVisible(Metamorph.proxy.canEditSelectors());
        this.copy = new GuiIconElement(mc, Icons.COPY, this::copyMorphCommand);
        this.copy.tooltip(IKey.lang("metamorph.gui.creative.command"));
        this.morph = new GuiButtonElement(mc, IKey.lang("metamorph.gui.morph"), (b) ->
        {
            this.pane.finish();

            AbstractMorph morph = this.pane.getSelected();

            if (morph != null)
            {
                Dispatcher.sendToServer(new PacketMorph(morph));
                this.closeScreen();
            }
        });
        this.acquire = new GuiButtonElement(mc, IKey.lang("metamorph.gui.acquire"), (b) ->
        {
            this.pane.finish();

            AbstractMorph morph = this.pane.getSelected();

            if (morph != null)
            {
                Dispatcher.sendToServer(new PacketAcquireMorph(morph));
            }
        });
        this.close = new GuiButtonElement(mc, IKey.lang("metamorph.gui.close"), (b) -> this.closeScreen());
        this.pane = new GuiCreativeMorphsList(mc, this::setMorph);
        this.pane.setSelected(Morphing.get(mc.player).getCurrentMorph());

        this.morph.flex().relative(this.viewport).set(0, 10, 60, 20).x(1, -200);
        this.acquire.flex().relative(this.morph).set(65, 0, 60, 20);
        this.close.flex().relative(this.acquire).set(65, 0, 60, 20);
        this.icon.flex().relative(this.morph).set(-18, 2, 16, 16);
        this.copy.flex().relative(this.icon).set(-20, 0, 16, 16);
        this.pane.flex().relative(this.viewport).set(0, 40, 0, 0).w(1, 0).h(1, -40);
        this.selectors.flex().relative(this.viewport).wTo(this.pane.flex()).h(1F);

        this.root.add(this.pane, this.morph, this.acquire, this.close, this.selectors, this.icon, this.copy);

        this.root.keys().register(((LabelTooltip) this.icon.tooltip).label, Keyboard.KEY_S, () -> this.icon.clickItself(this.context)).active(Metamorph.proxy.canEditSelectors()).category(this.pane.exitKey.category);
        this.root.keys().register(IKey.lang("metamorph.gui.creative.keys.acquire"), Keyboard.KEY_A, () -> this.acquire.clickItself(this.context)).category(this.pane.exitKey.category).active(() -> !this.pane.isEditMode());
        this.root.keys().register(IKey.lang("metamorph.gui.creative.keys.morph"), Keyboard.KEY_RETURN, () -> this.morph.clickItself(this.context)).category(this.pane.exitKey.category).active(() -> !this.pane.isEditMode());
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return Metamorph.pauseGUIInSP.get();
    }

    private void copyMorphCommand(GuiIconElement button)
    {
        GuiScreen.setClipboardString(GuiMorphSection.getMorphCommand(this.pane.getSelected()));
    }

    private void toggleEntitySelector(GuiIconElement button)
    {
        this.selectors.toggleVisible();

        if (this.selectors.isVisible())
        {
            this.pane.flex().x(140).wTo(this.root.flex(), 1F);
        }
        else
        {
            this.pane.flex().x(0).w(1F);
        }

        this.pane.resize();
        this.selectors.resize();
    }

    private void setMorph(AbstractMorph morph)
    {
        this.selectors.setMorph(morph);
        this.copy.setVisible(morph != null);
    }

    @Override
    protected void closeScreen()
    {
        this.pane.finish();

        super.closeScreen();
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        /* Draw panel backgrounds */
        GuiDraw.drawCustomBackground(0, 0, this.width, this.height);
        Gui.drawRect(this.pane.area.x, 0, this.width, 40, 0xaa000000);

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

==================================================

--- Файл №66 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiMorphRenderer.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;

public class GuiMorphRenderer extends GuiModelRenderer
{
    public AbstractMorph morph;

    public GuiMorphRenderer(Minecraft mc)
    {
        super(mc);
    }

    @Override
    protected void drawUserModel(GuiContext context)
    {
        if (this.morph == null)
        {
            return;
        }

        MorphUtils.render(this.morph, this.entity, 0, 0, 0, this.yaw, context.partialTicks);
    }
}

==================================================

--- Файл №67 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiMorphSection.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Keys;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.categories.UserCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.GuiMorphs;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.nbt.NBTTagCompound;
import org.lwjgl.opengl.GL11;

import java.util.function.Consumer;

public class GuiMorphSection extends GuiElement
{
    public static final int HEADER_HEIGHT = 20;
    public static final int CATEGORY_HEIGHT = 16;

    public GuiCreativeMorphsList parent;
    public MorphSection section;
    public Consumer<GuiMorphSection> callback;

    public int cellWidth = 55;
    public int cellHeight = 70;
    public boolean last;
    public boolean favorite;

    public AbstractMorph morph;
    public MorphCategory category;

    protected AbstractMorph hoverMorph;
    protected MorphCategory hoverCategory;

    public int height;

    private String filter = "";

    public static String getMorphCommand(AbstractMorph morph)
    {
        if (morph != null)
        {
            NBTTagCompound nbt = morph.toNBT();

            nbt.removeTag("Name");

            return "/morph @p " + morph.name + " " + nbt.toString();
        }

        return "";
    }

    public GuiMorphSection(Minecraft mc, GuiCreativeMorphsList parent, MorphSection section, Consumer<GuiMorphSection> callback)
    {
        super(mc);

        this.parent = parent;
        this.section = section;
        this.callback = callback;
    }

    public GuiMorphSection size(int w, int h)
    {
        this.cellWidth = w;
        this.cellHeight = h;

        return this;
    }

    public void set(AbstractMorph morph, MorphCategory category)
    {
        this.morph = morph;
        this.category = category;
    }

    public void pick(AbstractMorph morph, MorphCategory category)
    {
        this.set(morph, category);

        if (this.callback != null)
        {
            this.callback.accept(this);
        }
    }

    public void reset()
    {
        this.set(null, null);
    }

    /* Searching methods */

    public void setFilter(String filter)
    {
        this.filter = filter;
    }

    public boolean noFilter()
    {
        return this.filter.isEmpty() && !this.favorite;
    }

    public boolean isMatching(AbstractMorph morph)
    {
        if (this.favorite)
        {
            return morph.favorite;
        }

        if (this.filter.isEmpty())
        {
            return true;
        }

        return morph.name.toLowerCase().contains(this.filter) || morph.getDisplayName().toLowerCase().contains(this.filter);
    }

    public void calculateXY(GuiMorphs morphs)
    {
        int j = 0;

        for (AbstractMorph morph : this.category.getMorphs())
        {
            if (morph == this.morph)
            {
                int row = this.getPerRow();

                morphs.x = j % row;
                morphs.y = j / row;

                return;
            }

            if (this.isMatching(morph))
            {
                j ++;
            }
        }
    }

    public AbstractMorph getMorphAt(GuiMorphs morphs)
    {
        int row = this.getPerRow();
        int size = this.category.getMorphs().size();

        /* Shortcuts */
        if (morphs.y < 0 || size == 0)
        {
            return null;
        }
        else if (morphs.y < size / row + 1)
        {
            int i = morphs.x + morphs.y * row;

            if (i >= size)
            {
                return this.category.getMorphs().get(size - 1);
            }
        }

        /* Find the actual morph */
        int j = 0;

        if (morphs.x < 0) morphs.x = row - 1;
        if (morphs.x > row - 1) morphs.x = 0;

        for (AbstractMorph morph : this.category.getMorphs())
        {
            if (this.isMatching(morph))
            {
                if (j % row == morphs.x && j / row == morphs.y)
                {
                    return morph;
                }

                j ++;
            }
        }

        return null;
    }

    public int getY(AbstractMorph selected)
    {
        if (this.section.categories.isEmpty())
        {
            return 0;
        }

        int y = HEADER_HEIGHT;
        int row = this.getPerRow();

        for (MorphCategory category : this.section.categories)
        {
            int count = this.getMorphsSize(category);

            if (category.isHidden() || (count == 0 && !this.noFilter()))
            {
                continue;
            }

            y += CATEGORY_HEIGHT + 5;

            for (int i = 0, j = 0; i < category.getMorphs().size(); i ++)
            {
                AbstractMorph morph = category.getMorphs().get(i);

                if (!this.isMatching(morph))
                {
                    continue;
                }

                if (j != 0 && j % row == 0)
                {
                    y += this.cellHeight;
                }

                if (morph == selected)
                {
                    return y;
                }

                j ++;
            }

            y += this.cellHeight + 5;
        }

        return -1;
    }

    /* Calculation methods */

    public int getMorphsSize(MorphCategory category)
    {
        if (this.noFilter())
        {
            return category.getMorphs().size();
        }

        int count = 0;

        for (AbstractMorph morph : category.getMorphs())
        {
            count += this.isMatching(morph) ? 1 : 0;
        }

        return count;
    }

    public int getPerRow()
    {
        return Math.max(this.area.w / this.cellWidth, 1);
    }

    public int getCategoryHeight(MorphCategory category)
    {
        return this.getCategoryHeight(this.getMorphsSize(category));
    }

    public int getCategoryHeight(int given)
    {
        int size = Math.max(given, 1);

        return (int) Math.ceil(size / (float) this.getPerRow()) * this.cellHeight;
    }

    public int getFullHeight()
    {
        int h = HEADER_HEIGHT + (this.last ? 30 : 0);

        if (!this.section.hidden)
        {
            int visibleCategories = 0;

            for (MorphCategory category : this.section.categories)
            {
                int count = this.getMorphsSize(category);

                h += CATEGORY_HEIGHT + 5;

                if (category.isHidden() || (count == 0 && !this.noFilter()))
                {
                    continue;
                }

                h += this.getCategoryHeight(category) + 5;
                visibleCategories += 1;
            }

            if (visibleCategories > 0)
            {
                h -= 5;
            }
        }

        return h;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        boolean result = false;

        if (this.area.isInside(context) && !this.section.categories.isEmpty())
        {
            if (context.mouseY - this.area.y < HEADER_HEIGHT && context.mouseButton == 0)
            {
                this.section.hidden = !this.section.hidden;

                return true;
            }

            int x = context.mouseX - this.area.x;
            int y = context.mouseY - this.area.y - HEADER_HEIGHT;
            int row = this.getPerRow();

            category:
            for (MorphCategory category : this.section.categories)
            {
                int count = this.getMorphsSize(category);

                if (y < CATEGORY_HEIGHT && context.mouseButton == 0)
                {
                    category.hidden = !category.hidden;

                    return true;
                }

                y -= CATEGORY_HEIGHT + 5;

                if (category.isHidden() || (count == 0 && !this.noFilter()))
                {
                    continue;
                }

                int ix = (int) (x / (this.area.w / (float) row));
                int iy = y / this.cellHeight;
                int i = ix + (y < 0 ? -1 : iy) * row;

                if (i >= 0 && i < count)
                {
                    int real = category.getMorphs().size();

                    if (count == real)
                    {
                        this.pick(category.getMorphs().get(i), category);

                        result = true;

                        break;
                    }
                    else
                    {
                        for (int j = 0, k = -1; j < real; j ++)
                        {
                            AbstractMorph morph = category.getMorphs().get(j);

                            if (this.isMatching(morph))
                            {
                                k ++;
                            }

                            if (i == k)
                            {
                                this.pick(morph, category);

                                result = true;
                                break category;
                            }
                        }
                    }
                }

                y -= this.getCategoryHeight(count) + 5;
            }

            if (!result)
            {
                this.pick(null, null);
            }
        }

        return super.mouseClicked(context) || result;
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        if (this.parent == null)
        {
            return super.createContextMenu(context);
        }

        GuiSimpleContextMenu contextMenu = new GuiSimpleContextMenu(this.mc);
        AbstractMorph morph = this.hoverMorph;

        if (morph != null)
        {
            if (!(this.hoverCategory instanceof UserCategory))
            {
                Runnable runnable = this.parent.showGlobalMorphs(morph);

                if (runnable != null)
                {
                    contextMenu.action(Icons.UPLOAD, IKey.lang("metamorph.gui.creative.context.add_global"), runnable);
                }
            }

            contextMenu.action(Icons.EDIT, IKey.lang("metamorph.gui.creative.context.edit"), () -> this.parent.enterEditMorph(morph));
            contextMenu.action(Icons.COPY, IKey.lang("metamorph.gui.creative.context.copy_command"), () -> GuiScreen.setClipboardString(getMorphCommand(morph)));
            contextMenu.action(Icons.COPY, IKey.lang("metamorph.gui.creative.context.copy"), () -> GuiScreen.setClipboardString(morph.toNBT().toString()));
        }

        return contextMenu;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.drawMorphs(context);

        int h = this.getFullHeight();

        if (this.area.h != h)
        {
            this.flex().h(h);
            this.getParent().getParent().resize();
        }

        super.draw(context);
    }

    /**
     * Draw morphs
     */
    protected void drawMorphs(GuiContext context)
    {
        if (this.section.categories.isEmpty())
        {
            return;
        }

        /* Draw header */
        Icon toggleIcon = this.section.hidden ? Icons.MOVE_DOWN : Icons.MOVE_UP;

        Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.y + HEADER_HEIGHT, 0xbb000000);

        this.font.drawStringWithShadow(this.section.getTitle(), this.area.x + 7, this.area.y + 10 - this.font.FONT_HEIGHT / 2, 0xffffff);
        toggleIcon.render(this.area.ex() - 18 - 3, this.area.y + 10 + (this.section.hidden ? 1 : -1), 0, 0.5F);

        /* Draw categories */
        int y = HEADER_HEIGHT;

        this.hoverMorph = null;
        this.hoverCategory = null;

        if (this.section.hidden)
        {
            return;
        }

        Area viewport = context.getViewport();
        int row = this.getPerRow();

        category:
        for (MorphCategory category : this.section.categories)
        {
            int count = this.getMorphsSize(category);

            GuiDraw.drawTextBackground(this.font, category.getTitle(), this.area.x + 7, this.area.y + y + 8 - this.font.FONT_HEIGHT / 2, 0xeeeeee, ColorUtils.HALF_BLACK, 2);

            (category.hidden ? Icons.MOVE_DOWN : Icons.MOVE_UP).render(this.area.ex() - 18 - 3, this.area.y + y + CATEGORY_HEIGHT / 2 + (category.hidden ? 1 : -1), 0, 0.5F);

            Area.SHARED.copy(this.area);
            Area.SHARED.y = this.area.y + y;
            Area.SHARED.h = CATEGORY_HEIGHT + this.getCategoryHeight(category);

            if (Area.SHARED.isInside(context.mouseX, context.mouseY))
            {
                this.hoverCategory = category;
            }

            float x = 0;
            y += CATEGORY_HEIGHT + 5;

            if (category.isHidden() || (count == 0 && !this.noFilter()))
            {
                continue;
            }

            for (int i = 0, j = 0; i < category.getMorphs().size(); i ++)
            {
                AbstractMorph morph = category.getMorphs().get(i);

                if (!this.isMatching(morph))
                {
                    continue;
                }

                if (j != 0 && j % row == 0)
                {
                    x = 0;
                    y += this.cellHeight;
                }

                int mx = this.area.x + Math.round(x);
                int my = this.area.y + y;

                x += this.area.w / (float) row;
                int w = Math.round(x - (mx - this.area.x));

                Area.SHARED.set(mx, my, w, this.cellHeight);

                if (Area.SHARED.isInside(context.mouseX, context.mouseY))
                {
                    this.hoverMorph = morph;
                }

                if (Area.SHARED.intersects(viewport))
                {
                    GuiDraw.scissor(mx, my, w, this.cellHeight, context);
                    this.drawMorph(context, morph, mx, my, w, this.cellHeight, this.hoverMorph == morph, this.morph == morph);
                    GuiDraw.unscissor(context);
                }

                if (Area.SHARED.y > viewport.ey())
                {
                    break category;
                }

                j ++;
            }

            y += this.cellHeight + 5;
        }
    }

    /**
     * Draw individual morph
     */
    protected void drawMorph(GuiContext context, AbstractMorph morph, int x, int y, int w, int h, boolean hover, boolean selected)
    {
        if (selected && !morph.errorRendering)
        {
            Gui.drawRect(x, y, x + w, y + h, 0xaa000000 + McLib.primaryColor.get());
        }
        else if (hover)
        {
            Gui.drawRect(x, y, x + w, y + h, 0x66000000);
        }

        int spot = (int) (w * 0.4F);
        int spotX = x + w / 2;
        int spotY = y + h / 2;

        GuiDraw.drawDropCircleShadow(spotX, spotY, spot, (int) (spot * 0.65F), 10, 0x44000000, 0);

        if (morph.errorRendering)
        {
            GuiDraw.drawOutline(x, y, x + w, y + h, 0x88ff0000, 4);
            GuiDraw.drawOutline(x, y, x + w, y + h, 0xffff0000, 2);

            return;
        }

        if (!MorphUtils.renderOnScreen(morph, this.mc.player, x + w / 2, y + (int) (h * 0.7F), w * 0.4F, 1))
        {
            return;
        }

        if (selected)
        {
            GuiDraw.drawOutline(x, y, x + w, y + h, 0xff000000 + McLib.primaryColor.get(), 2);
        }

        if (morph.keybind != -1)
        {
            String key = Keys.getKeyName(morph.keybind);
            int kw = this.font.getStringWidth(key);
            int kx = x + w - 6 - kw;
            int ky = y + h - 6 - this.font.FONT_HEIGHT;

            Gui.drawRect(kx - 3, ky - 2, kx + kw + 3, ky + this.font.FONT_HEIGHT + 2, 0xff000000);
            this.font.drawStringWithShadow(key, kx, ky, 0xffffff);
        }

        if (morph.favorite)
        {
            /* Stupid hack because the morph seems to change the blend function or something */
            GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);
            GuiDraw.drawOutlinedIcon(Icons.FAVORITE, x + 2, y + 2, 0xffffffff);
        }
    }
}

==================================================

--- Файл №68 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiNestedEdit.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

import java.util.function.Consumer;

public class GuiNestedEdit extends GuiElement
{
    public GuiButtonElement pick;
    public GuiButtonElement edit;

    public GuiNestedEdit(Minecraft mc, Consumer<Boolean> callback)
    {
        this(mc, true, callback);
    }

    public GuiNestedEdit(Minecraft mc, boolean keybinds, Consumer<Boolean> callback)
    {
        super(mc);

        this.edit = new GuiButtonElement(mc, IKey.lang("metamorph.gui.creative.edit"), (b) -> callback.accept(true));
        this.pick = new GuiButtonElement(mc, IKey.lang("metamorph.gui.creative.pick"), (b) -> callback.accept(false));

        this.edit.flex().relative(this).h(1F);
        this.pick.flex().relative(this).h(1F);

        this.flex().h(20).row(0);
        this.add(this.pick, this.edit);

        if (keybinds)
        {
            this.keys().register(this.pick.label, Keyboard.KEY_P, () -> this.pick.clickItself(GuiBase.getCurrent()));
            this.keys().register(this.edit.label, Keyboard.KEY_E, () -> this.edit.clickItself(GuiBase.getCurrent()));
        }
    }

    public void setMorph(AbstractMorph morph)
    {
        this.edit.setEnabled(morph != null);
    }
}

==================================================

--- Файл №69 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiQuickEditor.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiLabelSearchListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;

import java.util.List;
import java.util.Objects;

/**
 * Quick morph editor
 *
 * This GUI is responsible for providing quick access editing of the most used
 * fields in the morph editor
 */
public class GuiQuickEditor extends GuiElement
{
    public GuiCreativeMorphsList parent;

    public GuiButtonElement presetsButton;
    public GuiButtonElement randomPreset;
    public GuiButtonElement quickAccessButton;

    public GuiLabelSearchListElement<NBTTagCompound> presets;
    public GuiScrollElement quickAccess;

    private AbstractMorph last;

    public GuiQuickEditor(Minecraft mc, GuiCreativeMorphsList parent)
    {
        super(mc);

        this.parent = parent;

        this.presetsButton = new GuiButtonElement(mc, IKey.lang("metamorph.gui.creative.presets"), this::toggleVisibility);
        this.quickAccessButton = new GuiButtonElement(mc, IKey.lang("metamorph.gui.creative.quick"), this::toggleVisibility);

        this.presets = new GuiLabelSearchListElement<NBTTagCompound>(mc, this::setPreset);
        this.presets.flex().relative(this).set(10, 30, 0, 0).w(1F, -20).h(1F, -60);
        this.randomPreset = new GuiButtonElement(mc, IKey.lang("metamorph.gui.creative.random"), this::pickRandomPreset);
        this.randomPreset.flex().relative(this.presets).y(1F).w(1F);

        this.quickAccess = new GuiScrollElement(mc);
        this.quickAccess.setVisible(false);
        this.quickAccess.flex().relative(this).y(20).w(1F).h(1F, -20).column(5).vertical().stretch().scroll().padding(10).height(20);

        GuiElement row = Elements.row(mc, 0, this.presetsButton, this.quickAccessButton);
        row.flex().relative(this).w(1F).h(20);

        this.presets.add(this.randomPreset);
        this.add(row, this.presets, this.quickAccess);
    }

    private void toggleVisibility(GuiButtonElement button)
    {
        if (button == this.presetsButton)
        {
            this.presetsButton.setEnabled(false);
            this.quickAccessButton.setEnabled(true);

            this.presets.setVisible(true);
            this.quickAccess.setVisible(false);
        }
        else
        {
            this.presetsButton.setEnabled(true);
            this.quickAccessButton.setEnabled(false);

            this.presets.setVisible(false);
            this.quickAccess.setVisible(true);
        }
    }

    private void pickRandomPreset(GuiButtonElement button)
    {
        int i = (int) (Math.random() * this.presets.list.getList().size());

        this.presets.list.setIndex(i);
        this.setPreset(this.presets.list.getCurrent());
    }

    public void setMorph(AbstractMorph morph, GuiAbstractMorph<AbstractMorph> editor)
    {
        if (Objects.equals(this.last, morph))
        {
            return;
        }

        /* Fill quick access */
        this.quickAccess.removeAll();

        for (GuiElement element : editor.getFields(this.mc, this.parent, morph))
        {
            this.quickAccess.add(element);
        }

        /* Fill presets */
        List<Label<NBTTagCompound>> presets = editor.getPresets(morph);

        this.presets.list.clear();
        this.presets.list.add(presets);
        this.presets.list.sort();
        this.presets.filter("", true);

        this.toggleVisibility(this.presets.isVisible() ? this.presetsButton : this.quickAccessButton);
        this.resize();

        this.last = morph;
    }

    protected void setPreset(List<Label<NBTTagCompound>> label)
    {
        if (!label.isEmpty())
        {
            this.parent.getSelected().fromNBT(label.get(0).value);
        }
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xaa000000);

        if (this.presets.isVisible() && this.presets.list.getList().isEmpty())
        {
            this.drawCenteredString(this.font, "No factory presets found...", this.presets.area.mx(), this.presets.area.my() - this.font.FONT_HEIGHT / 2, 0xffffff);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №70 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiSelectorEditor.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Timer;
import mchorse.metamorph.ClientProxy;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.render.EntitySelector;
import mchorse.metamorph.capabilities.render.ModelRenderer;
import mchorse.metamorph.client.EntityModelHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.JsonToNBT;

import java.util.List;
import java.util.function.Consumer;

public class GuiSelectorEditor extends GuiElement
{
    public GuiListElement<EntitySelector> selectors;

    public GuiElement form;
    public GuiTextElement name;
    public GuiTextElement type;
    public GuiTextElement match;
    public GuiToggleElement active;
    public GuiButtonElement pick;

    private EntitySelector selector;
    private Timer timer = new Timer(200);
    private boolean selecting;
    private boolean menu;

    public GuiSelectorEditor(Minecraft mc)
    {
        this(mc, false);
    }

    public GuiSelectorEditor(Minecraft mc, boolean menu)
    {
        super(mc);

        this.menu = menu;

        this.selectors = new GuiSelectorListElement(mc, this::fillData);
        this.selectors.sorting().background().setList(EntityModelHandler.selectors);
        this.selectors.context(() ->
        {
            GuiSimpleContextMenu contextMenu = new GuiSimpleContextMenu(mc).action(Icons.ADD, IKey.lang("metamorph.gui.selectors.add"), this::addSelector);

            if (!this.selectors.getCurrent().isEmpty())
            {
                contextMenu.action(Icons.REMOVE, IKey.lang("metamorph.gui.selectors.remove"), this::removeSelector);
            }

            return contextMenu;
        });

        this.form = new GuiElement(mc);
        this.name = new GuiTextElement(mc, 1000, (name) ->
        {
            this.selector.name = name;
            this.updateTime();
            this.timer.mark();
        });
        this.type = new GuiTextElement(mc, 1000, (name) ->
        {
            this.selector.type = name;
            this.updateTime();
            this.timer.mark();
        });
        this.match = new GuiTextElement(mc, 10000, (value) ->
        {
            try
            {
                this.selector.match = JsonToNBT.getTagFromJson(value);
                this.updateTime();
                this.timer.mark();
            }
            catch (Exception e)
            {
                this.selector.match = null;
                this.updateTime();
                this.timer.mark();
            }
        });
        this.match.tooltip(IKey.lang("metamorph.gui.selectors.match_tooltip"));
        this.active = new GuiToggleElement(mc, IKey.lang("metamorph.gui.selectors.enabled"), (toggle) ->
        {
            this.selector.enabled = toggle.isToggled();
            this.updateTime();
            this.timer.mark();
        });
        this.pick = new GuiButtonElement(mc, IKey.lang("metamorph.gui.body_parts.pick"), (button) ->
        {
            this.selecting = true;
            button.setEnabled(false);
        });

        this.form.flex().relative(this).w(1F).column(5).vertical().stretch().height(20).padding(10);
        this.selectors.flex().relative(this.form).y(1F).w(1F).hTo(this.flex(), 1F);

        GuiLabel title = Elements.label(IKey.lang("metamorph.gui.selectors.title"));
        GuiLabel name = Elements.label(IKey.lang("metamorph.gui.selectors.name"));
        GuiLabel type = Elements.label(IKey.lang("metamorph.gui.selectors.type"));
        GuiLabel match = Elements.label(IKey.lang("metamorph.gui.selectors.match"));

        name.marginTop(8);
        type.marginTop(8);
        match.marginTop(8);

        this.form.add(title.tooltip(IKey.lang("metamorph.gui.selectors.tooltip")), name, this.name, type, this.type, match, this.match, this.active);

        if (!this.menu)
        {
            this.form.add(this.pick);
        }

        this.markContainer().add(this.form, this.selectors);

        this.selectors.setIndex(0);
        this.fillData(this.selectors.getCurrent());
    }

    private void updateTime()
    {
        ModelRenderer.selectorsUpdate = System.currentTimeMillis();
    }

    public EntitySelector getSelector()
    {
        return this.selector;
    }

    private void addSelector()
    {
        EntityModelHandler.selectors.add(new EntitySelector());
        this.selectors.update();
        this.timer.mark();

        this.selectors.setIndex(this.selectors.getList().size() - 1);
        this.fillData(this.selectors.getCurrent());
    }

    private void removeSelector()
    {
        if (!this.selectors.current.isEmpty())
        {
            EntitySelector selector = this.selectors.getCurrent().get(0);

            selector.name = "";
            selector.type = "";
            selector.morph = null;
            this.updateTime();

            int current = this.selectors.current.get(0);

            EntityModelHandler.selectors.remove(current);
            this.selectors.setIndex(current - 1);
            this.fillData(this.selectors.getCurrent());
            this.selectors.update();
            this.timer.mark();
        }
    }

    private void fillData(List<EntitySelector> selectors)
    {
        this.selector = null;
        this.selecting = false;
        this.form.setVisible(!selectors.isEmpty());
        this.pick.setEnabled(true);

        if (selectors.isEmpty())
        {
            return;
        }

        EntitySelector selector = selectors.get(0);

        this.selector = selector;
        this.name.setText(selector.name);
        this.type.setText(selector.type);
        this.match.setText(selector.match == null ? "" : selector.match.toString());
        this.active.toggled(selector.enabled);
    }

    public void setMorph(AbstractMorph morph)
    {
        if (!this.isVisible() || this.selector == null)
        {
            return;
        }

        if (this.selecting || this.menu)
        {
            this.selector.morph = morph == null ? null : morph.toNBT();
        }

        this.pick.setEnabled(true);
        this.selecting = false;
        this.updateTime();
        this.timer.mark();
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.timer.checkReset())
        {
            ClientProxy.models.saveSelectors();
        }

        this.area.draw(0xaa000000);

        super.draw(context);

        if (this.selectors.getList().isEmpty())
        {
            this.drawCenteredString(this.font, "Right click here...", this.selectors.area.mx(), this.selectors.area.my(), 0x888888);
        }
    }

    public static class GuiSelectorListElement extends GuiListElement<EntitySelector>
    {
        public GuiSelectorListElement(Minecraft mc, Consumer<List<EntitySelector>> callback)
        {
            super(mc, callback);

            this.scroll.scrollItemSize = 16;
        }

        @Override
        protected String elementToString(EntitySelector element)
        {
            return element.name + " (" + element.type + ") - " + (element.morph == null ? "null" : element.morph.getString("Name"));
        }
    }
}

==================================================

--- Файл №71 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiSelectorsScreen.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.creative.sections.UserSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.render.EntitySelector;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;

public class GuiSelectorsScreen extends GuiBase
{
    public GuiSelectorEditor editor;
    public GuiCreativeMorphsMenu menu;

    public GuiSelectorsScreen(Minecraft mc)
    {
        this.editor = new GuiSelectorEditor(mc, true);
        this.menu = new GuiCreativeMorphsMenu(mc, true, this::setMorph);
        this.menu.setVisible(true);

        this.editor.flex().relative(this.viewport).wTo(this.menu.flex()).h(1F);
        this.menu.flex().relative(this.viewport).x(140).h(1F).wTo(this.root.flex(), 1F);

        this.root.add(this.menu, this.editor);
    }

    private void setMorph(AbstractMorph morph)
    {
        EntitySelector selector = this.editor.getSelector();
        NBTTagCompound tag =null;

        if (selector != null)
        {
            tag = selector.morph;
        }

        this.editor.setMorph(morph);

        if (tag != null)
        {
            AbstractMorph oldMorph = MorphManager.INSTANCE.morphFromNBT(tag);

            if (oldMorph != null)
            {
                this.addToRecent(oldMorph);
            }
        }
    }

    private void addToRecent(AbstractMorph oldMorph)
    {
        for (MorphSection section : MorphManager.INSTANCE.list.sections)
        {
            if (section instanceof UserSection)
            {
                UserSection user = (UserSection) section;

                if (user.recent.getEqual(oldMorph) == null)
                {
                    user.recent.add(oldMorph);

                    return;
                }
            }
        }
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return Metamorph.pauseGUIInSP.get();
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        GuiDraw.drawCustomBackground(0, 0, this.width, this.height);

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

==================================================

--- Файл №72 ---
Путь: main\java\mchorse\metamorph\client\gui\creative\GuiUserSection.java
--------------------
package mchorse.metamorph.client.gui.creative;

import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.modals.GuiConfirmModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.categories.AcquiredCategory;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.categories.RecentCategory;
import mchorse.metamorph.api.creative.categories.UserCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.creative.sections.UserSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.JsonToNBT;

import java.util.function.Consumer;

public class GuiUserSection extends GuiMorphSection
{
    public GuiUserSection(Minecraft mc, GuiCreativeMorphsList parent, MorphSection section, Consumer<GuiMorphSection> callback)
    {
        super(mc, parent, section, callback);
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        GuiSimpleContextMenu contextMenu = (GuiSimpleContextMenu) super.createContextMenu(context);

        if (this.parent == null)
        {
            return contextMenu;
        }

        MorphCategory category = this.hoverCategory;
        AbstractMorph morph = this.hoverMorph;

        boolean user = category instanceof UserCategory;
        boolean acquired = category instanceof AcquiredCategory;
        boolean recent = category instanceof RecentCategory;

        if (category != null)
        {
            contextMenu.action(Icons.PASTE, IKey.lang("metamorph.gui.creative.context.paste"), () -> this.pasteMorph(category));
        }

        if (morph != null && (user || acquired))
        {
            contextMenu.action(Icons.REFRESH, IKey.lang("metamorph.gui.creative.context.to_recent"), () -> this.copyToRecent(morph));
        }

        contextMenu.action(Icons.ADD, IKey.lang("metamorph.gui.creative.context.add_category"), () -> section.add(new UserCategory(this.section, "User category")));

        if (user)
        {
            contextMenu.action(Icons.EDIT, IKey.lang("metamorph.gui.creative.context.rename_category"), () -> this.renameCategory(category));
            contextMenu.action(Icons.CLOSE, IKey.lang("metamorph.gui.creative.context.remove_category"), () -> this.removeCategory(category));
        }

        if (recent || acquired)
        {
            contextMenu.action(Icons.CLOSE, IKey.lang("metamorph.gui.creative.context.clear_category"), () -> this.clearCategory(category));
        }

        if (morph != null && category != null)
        {
            contextMenu.action(Icons.CLOSE, IKey.lang("metamorph.gui.creative.context.remove_morph"), () -> this.removeMorph(category, morph));
        }

        return contextMenu;
    }

    private void pasteMorph(MorphCategory category)
    {
        String clipboard = GuiScreen.getClipboardString();

        if (!GuiScreen.isCtrlKeyDown())
        {
            try
            {
                category.add(MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson(clipboard)));

                return;
            }
            catch (Exception e)
            {}
        }

        GuiModal.addFullModal(this.parent, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(this.mc, IKey.lang("metamorph.gui.creative.context.paste_modal"), (string) ->
            {
                try
                {
                    category.add(MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson(string)));
                }
                catch (Exception e)
                {}
            });

            modal.text.field.setMaxStringLength(100000);
            modal.setValue(clipboard);

            return modal;
        });
    }

    private void renameCategory(MorphCategory category)
    {
        GuiModal.addModal(this.parent, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(this.mc, IKey.lang("metamorph.gui.creative.context.rename_category_modal"), (string) ->
            {
                category.title = string;
                ((UserSection) this.section).save();
            });

            modal.setValue(category.getTitle());
            modal.flex().relative(this.parent).xy(0.5F, 0.5F).wh(160, 180).anchor(0.5F, 0.5F);

            return modal;
        });
    }

    private void removeCategory(MorphCategory category)
    {
        GuiModal.addModal(this.parent, () ->
        {
            return GuiConfirmModal.createTemplate(this.mc, this.parent, IKey.lang("metamorph.gui.creative.context.remove_category_modal"), (value) ->
            {
                if (value)
                {
                    this.section.remove(category);
                }
            });
        });
    }

    private void removeMorph(MorphCategory category, AbstractMorph morph)
    {
        GuiModal.addModal(this.parent, () ->
        {
            return GuiConfirmModal.createTemplate(this.mc, this.parent, IKey.lang("metamorph.gui.creative.context.remove_morph_modal"), (value) ->
            {
                if (value)
                {
                    category.remove(morph);
                }
            });
        });
    }

    private void clearCategory(MorphCategory category)
    {
        GuiModal.addModal(this.parent, () ->
        {
            GuiConfirmModal modal = new GuiConfirmModal(this.mc, IKey.lang("metamorph.gui.creative.context.clear_category_modal"), (value) ->
            {
                if (value)
                {
                    category.clear();
                }
            });

            modal.flex().relative(this.parent).xy(0.5F, 0.5F).wh(160, 180).anchor(0.5F, 0.5F);

            return modal;
        });
    }

    private void copyToRecent(AbstractMorph morph)
    {
        ((UserSection) this.section).recent.add(morph.copy());
    }
}

==================================================

--- Файл №73 ---
Путь: main\java\mchorse\metamorph\client\gui\editor\GuiAbstractMorph.java
--------------------
package mchorse.metamorph.client.gui.editor;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.GuiPanelBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.bodypart.GuiBodyPartEditor;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import mchorse.metamorph.util.MMIcons;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@SideOnly(Side.CLIENT)
@SuppressWarnings({"rawtypes", "unchecked"})
public class GuiAbstractMorph<T extends AbstractMorph> extends GuiPanelBase<GuiMorphPanel>
{
    public static final IKey KEY_CATEGORY = IKey.lang("metamorph.gui.editor.keys.category");

    public GuiCreativeMorphsList morphs;

    public GuiIconElement finish;
    public GuiModelRenderer renderer;
    public GuiSettingsPanel settings;

    protected GuiMorphPanel defaultPanel;

    public T morph;

    public GuiAbstractMorph(Minecraft mc)
    {
        super(mc);

        this.finish = new GuiIconElement(mc, Icons.CLOSE, (b) -> this.morphs.exit());
        this.finish.flex().relative(this).set(0, 0, 20, 20).y(1F, -20);
        this.renderer = this.createMorphRenderer(mc);
        this.renderer.flex().relative(this).wh(1F, 1F);
        this.defaultPanel = this.settings = new GuiSettingsPanel(mc, this);

        this.registerPanel(this.settings, IKey.lang("metamorph.gui.editor.settings"), MMIcons.PROPERTIES);
        this.prepend(this.renderer);

        this.add(this.finish);

        this.keys().register(IKey.lang("metamorph.gui.editor.keys.cycle"), Keyboard.KEY_TAB, this::cycle).category(KEY_CATEGORY);
    }

    protected void cycle()
    {
        int index = -1;

        for (int i = 0; i < this.panels.size(); i ++)
        {
            if (this.view.delegate == this.panels.get(i))
            {
                index = i;

                break;
            }
        }

        index += GuiScreen.isShiftKeyDown() ? 1 : -1;
        index = MathUtils.cycler(index, 0, this.panels.size() - 1);

        this.buttons.elements.get(index).clickItself(GuiBase.getCurrent());
    }

    protected GuiModelRenderer createMorphRenderer(Minecraft mc)
    {
        return new GuiMorphRenderer(mc);
    }

    public void setMorphs(GuiCreativeMorphsList morphs)
    {
        this.morphs = morphs;
    }

    /**
     * Switch current morph panel to given one
     */
    @Override
    public void setPanel(GuiMorphPanel panel)
    {
        if (this.view.delegate != null)
        {
            this.view.delegate.finishEditing();
        }

        super.setPanel(panel);
        panel.startEditing();
    }

    public boolean canEdit(AbstractMorph morph)
    {
        return morph != null;
    }

    public void startEdit(T morph)
    {
        this.morph = morph;
        this.setupRenderer(morph);

        for (GuiMorphPanel panel : this.panels)
        {
            panel.fillData(morph);
        }

        this.setPanel(this.defaultPanel);
    }

    protected void setupRenderer(T morph)
    {
        this.renderer.reset();

        if (this.renderer instanceof GuiMorphRenderer)
        {
            ((GuiMorphRenderer) this.renderer).morph = morph;
        }
    }

    public void finishEdit()
    {
        if (this.view.delegate != null)
        {
            this.view.delegate.finishEditing();
        }
    }

    /**
     * Get presets
     */
    public List<Label<NBTTagCompound>> getPresets(T morph)
    {
        return Collections.emptyList();
    }

    protected void addPreset(AbstractMorph morph, List<Label<NBTTagCompound>> list, String label, String json)
    {
        try
        {
            this.addPreset(morph, list, label, JsonToNBT.getTagFromJson(json));
        }
        catch (Exception e)
        {}
    }

    protected void addPreset(AbstractMorph morph, List<Label<NBTTagCompound>> list, String label, NBTTagCompound tag)
    {
        NBTTagCompound morphTag = morph.toNBT();

        morphTag.merge(tag);
        list.add(new Label<NBTTagCompound>(IKey.str(label), morphTag));
    }

    /**
     * Get quick access editing fields
     */
    public List<GuiElement> getFields(Minecraft mc, GuiCreativeMorphsList morphs, T morph)
    {
        List<GuiElement> elements = new ArrayList<GuiElement>();
        GuiTextElement displayName = new GuiTextElement(mc, (name) ->
        {
            morphs.getSelected().displayName = name;
            morphs.markDirty();
        });

        displayName.setText(morph.displayName);
        elements.add(Elements.label(IKey.lang("metamorph.gui.editor.display_name")));
        elements.add(displayName);

        return elements;
    }

    /**
     * Get current tick for preview
     */
    public int getCurrentTick()
    {
        int tick = 0;

        if (this.morph instanceof IAnimationProvider)
        {
            Animation animation = ((IAnimationProvider) this.morph).getAnimation();

            if (animation.animates)
            {
                tick = animation.duration;
            }
        }

        return tick;
    }

    @Override
    public GuiIconElement registerPanel(GuiMorphPanel panel, IKey tooltip, Icon icon)
    {
        GuiIconElement button = super.registerPanel(panel, tooltip, icon);

        if (panel instanceof GuiBodyPartEditor)
        {
            this.registerKeybind(button, IKey.lang("metamorph.gui.body_parts.open"), Keyboard.KEY_B).category(KEY_CATEGORY);
        }

        return button;
    }

    @Override
    protected void drawBackground(GuiContext context, int x, int y, int w, int h)
    {
        Gui.drawRect(x, y, x + w, y + h, 0xee000000);
    }

    /* Saving and restoring the store */

    public void fromNBT(NBTTagCompound tag)
    {
        /* Restore model renderer's position */
        this.renderer.setPosition(tag.getFloat("MX"), tag.getFloat("MY"), tag.getFloat("MZ"));
        this.renderer.setScale(tag.getFloat("MS"));
        this.renderer.setRotation(tag.getFloat("MRY"), tag.getFloat("MRX"));

        /* Restore panel */
        int hash = tag.getInteger("PanelHash");

        for (GuiMorphPanel panel : this.panels)
        {
            if (panel.hashCode() == hash)
            {
                this.setPanel(panel);
                panel.fromNBT(tag.getCompoundTag("Panel"));

                return;
            }
        }
    }

    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        /* Save model renderer's position */
        tag.setFloat("MX", this.renderer.pos.x);
        tag.setFloat("MY", this.renderer.pos.y);
        tag.setFloat("MZ", this.renderer.pos.z);
        tag.setFloat("MS", this.renderer.scale);
        tag.setFloat("MRX", this.renderer.pitch);
        tag.setFloat("MRY", this.renderer.yaw);

        /* Save panel */
        tag.setTag("Panel", this.view.delegate.toNBT());
        tag.setInteger("PanelHash", this.view.delegate.hashCode());

        return tag;
    }
}

==================================================

--- Файл №74 ---
Путь: main\java\mchorse\metamorph\client\gui\editor\GuiAnimation.java
--------------------
package mchorse.metamorph.client.gui.editor;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiInterpolationList;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.tooltips.InterpolationTooltip;
import mchorse.mclib.client.gui.utils.InterpolationRenderer;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Interpolation;
import mchorse.metamorph.api.morphs.utils.Animation;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiAnimation extends GuiElement
{
    /* Animated poses */
    public GuiToggleElement animates;
    public GuiToggleElement ignored;
    public GuiTrackpadElement animationDuration;
    public GuiButtonElement pickInterpolation;
    public GuiListElement<Interpolation> interpolations;

    public Animation animation;

    private InterpolationTooltip interpolationTooltip = new InterpolationTooltip(0F, 0, () -> this.animation.interp, () -> this.animation.duration);

    public GuiAnimation(Minecraft mc)
    {
        this(mc, false);
    }

    public GuiAnimation(Minecraft mc, boolean addIgnore)
    {
        super(mc);

        /* Animated poses */
        this.animates = new GuiToggleElement(mc, IKey.lang("metamorph.gui.animation.animates"), false, (b) ->
        {
            this.animation.animates = this.animates.isToggled();
            this.animation.reset();
        });

        this.ignored = new GuiToggleElement(mc, IKey.lang("metamorph.gui.animation.ignored"), false, (b) ->
        {
            this.animation.ignored = this.ignored.isToggled();
        });

        this.animationDuration = new GuiTrackpadElement(mc, (value) ->
        {
            this.animation.duration = value.intValue();
            this.animation.reset();
        });
        this.animationDuration.tooltip(IKey.lang("metamorph.gui.animation.animation_duration"));
        this.animationDuration.limit(0).integer();
        this.animationDuration.values(2, 1, 5);

        this.pickInterpolation = new GuiButtonElement(mc, IKey.lang("metamorph.gui.animation.pick_interpolation"), (b) ->
        {
            this.interpolations.toggleVisible();
        });
        this.pickInterpolation.tooltip(this.interpolationTooltip);

        this.interpolations = new GuiInterpolationList(mc, (interp) ->
        {
            this.animation.interp = interp.get(0);
        });
        this.interpolations.tooltip(this.interpolationTooltip).markIgnored().flex().relative(this.pickInterpolation).y(1F).w(1F).h(96);

        this.flex().column(5).vertical().stretch().height(20).padding(10);

        this.add(this.animates, this.animationDuration, this.pickInterpolation);

        if (addIgnore)
        {
            this.addAfter(this.animationDuration, this.ignored);
        }

        this.add(this.interpolations);
    }

    public void fill(Animation animation)
    {
        this.animation = animation;
        this.animation.reset();

        this.animates.toggled(animation.animates);
        this.ignored.toggled(animation.ignored);
        this.animationDuration.setValue(animation.duration);
        this.interpolations.setCurrent(animation.interp);
        this.interpolations.setVisible(false);
    }
}


==================================================

--- Файл №75 ---
Путь: main\java\mchorse\metamorph\client\gui\editor\GuiMorphPanel.java
--------------------
package mchorse.metamorph.client.gui.editor;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
@SuppressWarnings("rawtypes")
public class GuiMorphPanel<T extends AbstractMorph, E extends GuiAbstractMorph> extends GuiElement
{
    public E editor;
    public T morph;

    public GuiMorphPanel(Minecraft mc, E editor)
    {
        super(mc);

        this.editor = editor;
    }

    public void startEditing()
    {}

    public void finishEditing()
    {}

    public void fillData(T morph)
    {
        this.morph = morph;
    }

    public void fromNBT(NBTTagCompound tag)
    {}

    public NBTTagCompound toNBT()
    {
        return new NBTTagCompound();
    }
}

==================================================

--- Файл №76 ---
Путь: main\java\mchorse\metamorph\client\gui\editor\GuiSettingsPanel.java
--------------------
package mchorse.metamorph.client.gui.editor;

import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiKeybindElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.BetterLightsHelper;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphSettings;
import mchorse.metamorph.api.abilities.IAbility;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;

public class GuiSettingsPanel extends GuiMorphPanel<AbstractMorph, GuiAbstractMorph>
{
    public GuiScrollElement left;

    public GuiKeybindElement keybind;
    public GuiButtonElement reset;
    public GuiTextElement displayName;
    public GuiStringListElement abilities;
    public GuiStringListElement attack;
    public GuiStringListElement action;
    public GuiTrackpadElement health;
    public GuiTrackpadElement speed;

    public GuiScrollElement right;

    public GuiToggleElement hitboxEnabled;
    public GuiTrackpadElement hitboxWidth;
    public GuiTrackpadElement hitboxHeight;
    public GuiTrackpadElement hitboxSneakingHeight;
    public GuiTrackpadElement hitboxEyePosition;
    
    public GuiCirculateElement shadowOption;
    public GuiToggleElement betterLightsShadow;

    public GuiTextElement data;
    public boolean error;

    public GuiSettingsPanel(Minecraft mc, GuiAbstractMorph editor)
    {
        super(mc, editor);

        this.left = new GuiScrollElement(mc);
        this.left.scroll.opposite = true;
        this.left.cancelScrollEdge();
        this.left.flex().relative(this).w(130).h(1F).column(5).vertical().stretch().scroll().height(20).padding(10);

        this.keybind = new GuiKeybindElement(mc, (key) ->
        {
            if (key == Keyboard.KEY_ESCAPE)
            {
                this.morph.keybind = -1;
                this.keybind.setKeybind(-1);
            }
            else
            {
                this.morph.keybind = key;
            }
        });
        this.keybind.tooltip(IKey.lang("metamorph.gui.editor.keybind_tooltip"));
        this.reset = new GuiButtonElement(mc, IKey.lang("metamorph.gui.editor.reset"), (button) ->
        {
            this.morph.clearForcedSettings();

            MorphManager.INSTANCE.applySettings(this.morph);
            this.editor.setPanel(this.editor.defaultPanel);
        });
        this.displayName = new GuiTextElement(mc, (string) -> this.morph.displayName = string);
        this.abilities = new GuiStringListElement(mc, (values) ->
        {
        	this.morph.forceEditSettings((settings) ->
        	{
                settings.abilities.clear();

                for (String value : values)
                {
                    IAbility ability = MorphManager.INSTANCE.abilities.get(value);

                    if (ability != null)
                    {
                        settings.abilities.add(ability);
                    }
                }
        	});
        	this.updateNBT();
        });
        this.abilities.multi().background().tooltip(IKey.lang("metamorph.gui.editor.abilities_tooltip"));
        this.attack = new GuiStringListElement(mc, (values) ->
        {
        	this.morph.forceEditSettings((settings) ->
        	{
        		settings.attack = MorphManager.INSTANCE.attacks.get(values.get(0));
        	});
        	this.updateNBT();
        });
        this.attack.background();
        this.action = new GuiStringListElement(mc, (values) ->
        {
        	this.morph.forceEditSettings((settings) ->
        	{
        		settings.action = MorphManager.INSTANCE.actions.get(values.get(0));
        	});
        	this.updateNBT();
        });
        this.action.background();
        this.health = new GuiTrackpadElement(mc, (value) ->
        {
        	this.morph.forceEditSettings((settings) ->
        	{
                settings.health = value.intValue();
        	});
        	this.updateNBT();
        })
            .limit(0, Float.POSITIVE_INFINITY, true);
        this.speed = new GuiTrackpadElement(mc, (value) ->
        {
        	this.morph.forceEditSettings((settings) ->
        	{
                settings.speed = value.floatValue();
        	});
        	this.updateNBT();
        })
            .limit(0, Float.POSITIVE_INFINITY)
            .values(0.05F, 0.01F, 0.1F)
            .increment(0.25F);
        this.data = new GuiTextElement(mc, 1000000, this::editNBT);

        this.abilities.flex().h(80);
        this.attack.flex().h(80);
        this.action.flex().h(80);

        this.data.flex().relative(this).relative(this.left).x(1F, 10).y(1, -30).wTo(this.flex(), 1F, -10);

        this.left.add(this.reset);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.keybind")).marginTop(8), this.keybind);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.display_name")).marginTop(8), this.displayName);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.health")).marginTop(8), this.health);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.speed")).marginTop(8), this.speed);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.abilities")).marginTop(8), this.abilities);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.attack")).marginTop(8), this.attack);
        this.left.add(Elements.label(IKey.lang("metamorph.gui.editor.action")).marginTop(8), this.action);

        this.right = new GuiScrollElement(mc);
        this.right.flex().relative(this).x(1F).w(130).h(1F).anchorX(1F).column(5).vertical().stretch().scroll().height(20).padding(10);

        this.hitboxEnabled = new GuiToggleElement(mc, IKey.lang("metamorph.gui.editor.hitbox.enabled"), (b) -> this.morph.hitbox.enabled = b.isToggled());
        this.hitboxWidth = new GuiTrackpadElement(mc, (value) -> this.morph.hitbox.width = value.floatValue());
        this.hitboxWidth.limit(0.01, Integer.MAX_VALUE).tooltip(IKey.lang("metamorph.gui.editor.hitbox.width"));
        this.hitboxHeight = new GuiTrackpadElement(mc, (value) -> this.morph.hitbox.height = value.floatValue());
        this.hitboxHeight.limit(0.01, Integer.MAX_VALUE).tooltip(IKey.lang("metamorph.gui.editor.hitbox.height"));
        this.hitboxSneakingHeight = new GuiTrackpadElement(mc, (value) -> this.morph.hitbox.sneakingHeight = value.floatValue());
        this.hitboxSneakingHeight.limit(0.01, Integer.MAX_VALUE).tooltip(IKey.lang("metamorph.gui.editor.hitbox.sneaking_height"));
        this.hitboxEyePosition = new GuiTrackpadElement(mc, (value) -> this.morph.hitbox.eye = value.floatValue());
        this.hitboxEyePosition.limit(0.01, Integer.MAX_VALUE).tooltip(IKey.lang("metamorph.gui.editor.hitbox.eye_tooltip"));

        this.right.add(this.hitboxEnabled);
        this.right.add(Elements.label(IKey.lang("metamorph.gui.editor.hitbox.size")).marginTop(8), this.hitboxWidth, this.hitboxHeight, this.hitboxSneakingHeight);
        this.right.add(Elements.label(IKey.lang("metamorph.gui.editor.hitbox.eye")).marginTop(8), this.hitboxEyePosition);

        /* Optifine shadowpass control */
        this.shadowOption = new GuiCirculateElement(mc, (element) -> 
        {
        	this.morph.forceEditSettings((settings) ->
        	{
                settings.shadowOption = element.getValue();
        	});
        	this.updateNBT();
        });
        for (OptifineShadowOption option : OptifineShadowOption.values())
        {
            this.shadowOption.addLabel(IKey.lang("metamorph.gui.editor.shadow." + option.name().toLowerCase()));
        }

        try
        {
            Class.forName("net.optifine.shaders.Shaders");
            this.right.add(Elements.label(IKey.str("Optifine")).marginTop(8), this.shadowOption);
        }
        catch (ClassNotFoundException e)
        {}

        /* BetterLights shadowpass control */
        this.betterLightsShadow = new GuiToggleElement(mc, IKey.lang("metamorph.gui.editor.betterlights_shadow"), (element) ->
        {
            this.morph.forceEditSettings((settings) ->
            {
                settings.betterLightsShadow = element.isToggled();
            });
        });

        if (BetterLightsHelper.isBetterLightsLoaded())
        {
            this.right.add(Elements.label(IKey.str("BetterLights")).marginTop(8), this.betterLightsShadow);
        }

        this.add(this.left, this.right, this.data);
    }

    @Override
    public void fillData(AbstractMorph morph)
    {
        super.fillData(morph);

        this.abilities.clear();
        this.abilities.add(MorphManager.INSTANCE.abilities.keySet());
        this.attack.clear();
        this.attack.add(MorphManager.INSTANCE.attacks.keySet());
        this.action.clear();
        this.action.add(MorphManager.INSTANCE.actions.keySet());

        this.hitboxEnabled.toggled(morph.hitbox.enabled);
        this.hitboxWidth.setValue(morph.hitbox.width);
        this.hitboxHeight.setValue(morph.hitbox.height);
        this.hitboxSneakingHeight.setValue(morph.hitbox.sneakingHeight);
        this.hitboxEyePosition.setValue(morph.hitbox.eye);

        this.shadowOption.setValue(morph.getSettings().shadowOption);
        this.betterLightsShadow.toggled(morph.getSettings().betterLightsShadow);
    }

    public void updateNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        this.morph.toNBT(tag);
        this.data.setText(tag.toString());
    }

    public void editNBT(String str)
    {
        try
        {
            this.morph.fromNBT(JsonToNBT.getTagFromJson(str));
            this.error = false;
        }
        catch (Exception e)
        {
            this.error = true;
        }
    }

    @Override
    public void startEditing()
    {
        super.startEditing();

        this.error = false;

        this.updateNBT();

        this.keybind.setKeybind(morph.keybind);
        this.displayName.setText(morph.displayName);
        this.health.setValue(morph.getSettings().health);
        this.speed.setValue(morph.getSettings().speed);

        List<String> abilities = new ArrayList<String>();

        for (IAbility ability : morph.getSettings().abilities)
        {
            String key = MorphSettings.getKey(MorphManager.INSTANCE.abilities, ability);

            if (key != null)
            {
                abilities.add(key);
            }
        }

        this.abilities.sort();
        this.attack.sort();
        this.action.sort();

        this.abilities.setCurrent(abilities);
        this.attack.setCurrent(MorphSettings.getKey(MorphManager.INSTANCE.attacks, morph.getSettings().attack));
        this.action.setCurrent(MorphSettings.getKey(MorphManager.INSTANCE.actions, morph.getSettings().action));
    }

    @Override
    public void draw(GuiContext context)
    {
        super.draw(context);

        if (this.data.isVisible())
        {
            this.font.drawStringWithShadow(I18n.format("metamorph.gui.panels.nbt_data"), this.data.area.x, this.data.area.y - 12, this.error ? 0xffff3355 : 0xffffff);
        }
    }

    public enum OptifineShadowOption
    {
        ALL, NOSHADOW, ONLYSHADOW
    }
}

==================================================

--- Файл №77 ---
Путь: main\java\mchorse\metamorph\client\gui\overlays\GuiHud.java
--------------------
package mchorse.metamorph.client.gui.overlays;

import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.client.GuiIngameForge;

public class GuiHud extends Gui
{
    /**
     * Whether or not squid air should be rendered
     * in place of regular player air.
     * Checked by RenderingHandler
     */
    public boolean renderSquidAir = false;
    public int squidAir = 300;

    public void renderSquidAir(int width, int height)
    {
        if (squidAir < 300)
        {
            GlStateManager.enableBlend();
            int left = width / 2 + 91;
            int top = height - GuiIngameForge.right_height;

            int full = MathHelper.ceil((squidAir - 2) * 10.0D / 300.0D);
            int partial = MathHelper.ceil(squidAir * 10.0D / 300.0D) - full;

            for (int i = 0; i < full + partial; ++i)
            {
                drawTexturedModalRect(left - i * 8 - 9, top, (i < full ? 16 : 25), 18, 9, 9);
            }

            GuiIngameForge.right_height += 10;
            GlStateManager.disableBlend();
        }
    }
}


==================================================

--- Файл №78 ---
Путь: main\java\mchorse\metamorph\client\gui\overlays\GuiOverlay.java
--------------------
package mchorse.metamorph.client.gui.overlays;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.resources.I18n;

/**
 * GUI acquired morph overlay class
 * 
 * This class is responsible for displaying acquired morph in a more graphic
 * way than with chat message.
 */
public class GuiOverlay extends Gui
{
    /**
     * List of acquired morphs 
     */
    public List<AcquiredMorph> morphs = new ArrayList<AcquiredMorph>();

    /**
     * Disappearing cap 
     */
    public final int cap = 60;

    /**
     * Render acquired morph overlays 
     */
    public void render(int width, int height)
    {
        if (this.morphs.size() == 0)
        {
            return;
        }

        Minecraft mc = Minecraft.getMinecraft();
        FontRenderer font = mc.fontRenderer;
        Iterator<AcquiredMorph> iterator = this.morphs.iterator();

        while (iterator.hasNext())
        {
            AcquiredMorph morph = iterator.next();
            String string = I18n.format("metamorph.gui.acquired");

            /* Let's calculate some stuff */
            boolean disappear = morph.timer <= this.cap;

            int progress = this.cap - morph.timer;
            int alpha = (255 * morph.timer / this.cap);
            int y = height - 10 + (disappear ? (int) (40 * (float) progress / this.cap) : 0);
            int color = disappear ? 0x00ffffff + (alpha << 24) : 0xffffffff;

            MorphUtils.renderOnScreen(morph.morph, mc.player, 15, y, 15, (float) alpha / 255);

            /* Render overlay */
            font.drawString(string, 30, y - 7, color);

            morph.timer--;

            /* Remove the morph is the timer is run out */
            if (morph.timer <= 0)
            {
                iterator.remove();
            }
        }
    }

    /**
     * Add an acquired morph to this overlay. 
     */
    public void add(AbstractMorph acquired)
    {
        for (AcquiredMorph morph : this.morphs)
        {
            if (morph.timer > this.cap)
            {
                morph.timer = this.cap;
            }
        }

        this.morphs.add(new AcquiredMorph(acquired));
    }

    /**
     * Acquired morph class
     * 
     * This class is responsible for containing information about currently 
     * acquired morph.
     */
    public static class AcquiredMorph
    {
        public AbstractMorph morph;
        public int timer = 240;

        public AcquiredMorph(AbstractMorph morph)
        {
            this.morph = morph;
        }
    }
}

==================================================

--- Файл №79 ---
Путь: main\java\mchorse\metamorph\client\gui\survival\GuiSurvivalMorphs.java
--------------------
package mchorse.metamorph.client.gui.survival;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.MorphList;
import mchorse.metamorph.api.creative.categories.AcquiredCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.creative.sections.UserSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.client.gui.GuiMorphs;
import mchorse.metamorph.client.gui.creative.GuiMorphSection;
import net.minecraft.client.Minecraft;

import java.util.Collections;
import java.util.function.Consumer;

public class GuiSurvivalMorphs extends GuiMorphs
{
    public AcquiredCategory acquired;

    public GuiSurvivalMorphs(Minecraft mc)
    {
        super(mc);
    }

    public void setupSections(boolean creative, Consumer<GuiMorphSection> callback)
    {
        Minecraft mc = Minecraft.getMinecraft();
        MorphList list = MorphManager.INSTANCE.list;
        IMorphing cap = Morphing.get(mc.player);

        MorphSection section;
        AcquiredCategory category;

        if (creative || Metamorph.allowMorphingIntoCategoryMorphs.get())
        {
            UserSection user = (UserSection) list.sections.get(0);

            section = user;
            section.update(mc.world);
            category = user.acquired;
        }
        else
        {
            section = new MorphSection("user");
            category = new AcquiredCategory(section, "acquired");

            category.setMorphs(cap == null ? Collections.emptyList() : cap.getAcquiredMorphs());
            section.add(category);
        }

        GuiMorphSection element = section.getGUI(mc, null, callback);

        element.flex();

        this.removeAll();
        this.add(element);
        this.selected = element;
        this.acquired = category;

        this.sections.clear();
        this.sections.add(this.selected);
    }

    @Override
    public void setSelected(AbstractMorph morph)
    {
        super.setSelected(morph);

        if (morph != null)
        {
            AbstractMorph found = this.acquired.getEqual(morph);

            if (found != null)
            {
                this.selected.category = this.acquired;
                this.selected.morph = found;
            }
        }
    }

    public boolean isAcquiredSelected()
    {
        return this.selected != null && this.selected.category == this.acquired;
    }
}

==================================================

--- Файл №80 ---
Путь: main\java\mchorse\metamorph\client\gui\survival\GuiSurvivalScreen.java
--------------------
package mchorse.metamorph.client.gui.survival;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiKeybindElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.metamorph.ClientProxy;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.creative.PacketMorph;
import mchorse.metamorph.network.common.survival.PacketFavorite;
import mchorse.metamorph.network.common.survival.PacketKeybind;
import mchorse.metamorph.network.common.survival.PacketRemoveMorph;
import mchorse.metamorph.network.common.survival.PacketSelectMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.EntityPlayer;
import org.lwjgl.input.Keyboard;

/**
 * Survival morph menu GUI
 * 
 * This is menu which allows users to manage their acquired morphs, favorite them,
 * setup keybinds, and when they're in creative mode, they can also manage
 * recent and morphs from custom categories.
 */
public class GuiSurvivalScreen extends GuiBase
{
    public GuiSurvivalMorphs morphs;
    public GuiElement sidebar;
    public GuiToggleElement onlyFavorite;

    public GuiButtonElement morph;
    public GuiButtonElement remove;
    public GuiKeybindElement keybind;
    public GuiToggleElement favorite;

    private boolean creative;
    private boolean allowed;

    public GuiSurvivalScreen()
    {
        super();

        Minecraft mc = this.context.mc;

        this.morph = new GuiButtonElement(mc, IKey.lang("metamorph.gui.morph"), this::morph);
        this.remove = new GuiButtonElement(mc, IKey.lang("metamorph.gui.remove"), this::remove);
        this.keybind = new GuiKeybindElement(mc, this::setKeybind);
        this.keybind.tooltip(IKey.lang("metamorph.gui.survival.keybind_tooltip"));
        this.favorite = new GuiToggleElement(mc, IKey.lang("metamorph.gui.survival.favorite"), this::favorite);

        this.sidebar = new GuiScrollElement(mc);
        this.sidebar.flex().relative(this.root).y(20).w(140).hTo(this.root.resizer(), 1F).column(5).stretch().height(20).padding(10);
        this.sidebar.add(Elements.row(mc, 5, 0, 20, this.morph, this.remove), this.keybind, this.favorite);

        this.onlyFavorite = new GuiToggleElement(mc, IKey.lang("metamorph.gui.survival.only_favorites"), (button) -> this.morphs.setFavorite(button.isToggled()));
        this.onlyFavorite.flex().relative(this.root).x(1F).w(120).h(20).anchor(1F, 0F);

        this.morphs = new GuiSurvivalMorphs(mc);
        this.morphs.flex().relative(this.root).x(140).y(20).wTo(this.root.resizer(), 1F).hTo(this.root.resizer(), 1F).column(0).vertical().stretch().scroll();

        this.root.flex().xy(0.5F, 0.5F).wh(1F, 1F).anchor(0.5F, 0.5F).maxW(500).maxH(300);
        this.root.add(this.morphs, this.sidebar, this.onlyFavorite);

        /* Setup keybinds */
        IKey category = IKey.lang("metamorph.gui.survival.keys.category");

        this.root.keys().register(this.morph.label, Keyboard.KEY_RETURN, () -> this.morph.clickItself(GuiBase.getCurrent())).category(category);
        this.root.keys().register(this.remove.label, Keyboard.KEY_BACK, () -> this.remove.clickItself(GuiBase.getCurrent())).category(category);
        this.root.keys().register(this.favorite.label, Keyboard.KEY_F, () -> this.favorite.clickItself(GuiBase.getCurrent())).category(category);
        this.root.keys().register(IKey.lang("metamorph.gui.survival.keys.toggle_favorites"), Keyboard.KEY_O, () -> this.onlyFavorite.clickItself(GuiBase.getCurrent())).category(category);
        this.root.keys().register(IKey.lang("metamorph.gui.survival.keys.focus_keybind"), Keyboard.KEY_K, () -> this.keybind.clickItself(GuiBase.getCurrent())).category(category);
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return Metamorph.pauseGUIInSP.get();
    }

    /**
     * Open the survival morph menu and update the morphs element
     */
    public GuiSurvivalScreen open()
    {
        EntityPlayer player = Minecraft.getMinecraft().player;
        IMorphing cap = Morphing.get(player);
        boolean creative = player.isCreative();
        boolean allowed = Metamorph.allowMorphingIntoCategoryMorphs.get();

        if (this.creative != creative || this.allowed != allowed || creative || this.morphs.sections.isEmpty())
        {
            this.creative = creative;
            this.allowed = allowed;
            this.morphs.setupSections(creative, (section) -> this.fill(section.morph));
        }

        this.setSelected(cap.getCurrentMorph());

        return this;
    }

    /**
     * Set given morph selected
     */
    public void setSelected(AbstractMorph morph)
    {
        this.morphs.setSelected(morph);
        this.fill(this.morphs.getSelected());
    }

    /**
     * Fill the fields with the data from current morph
     */
    public void fill(AbstractMorph morph)
    {
        this.morph.setEnabled(morph != null);
        this.remove.setEnabled(morph != null);
        this.keybind.setEnabled(morph != null);
        this.keybind.setKeybind(Keyboard.KEY_NONE);
        this.favorite.setEnabled(morph != null);

        if (morph != null)
        {
            this.favorite.toggled(morph.favorite);
            this.keybind.setKeybind(morph.keybind);
        }
    }

    /**
     * Morph player into currently selected morph
     */
    private void morph(GuiButtonElement button)
    {
        AbstractMorph morph = this.morphs.getSelected();

        if (morph != null)
        {
            if (this.morphs.isAcquiredSelected())
            {
                Dispatcher.sendToServer(new PacketSelectMorph(this.indexOf(morph)));
            }
            else
            {
                Dispatcher.sendToServer(new PacketMorph(morph));
            }

            this.closeScreen();
        }
    }

    /**
     * Remove currently selected morph
     */
    private void remove(GuiButtonElement button)
    {
        AbstractMorph morph = this.morphs.getSelected();

        if (morph != null)
        {
            if (this.morphs.isAcquiredSelected())
            {
                Dispatcher.sendToServer(new PacketRemoveMorph(this.indexOf(morph)));
            }
            else
            {
                this.morphs.selected.category.remove(morph);
            }

            this.setSelected(null);
        }
    }

    /**
     * Set keybind of the current morph
     */
    private void setKeybind(int keybind)
    {
        AbstractMorph morph = this.morphs.getSelected();

        if (morph != null)
        {
            if (keybind == ClientProxy.keys.keyDemorph.getKeyCode())
            {
                this.keybind.setKeybind(morph.keybind);

                return;
            }

            keybind = keybind == Keyboard.KEY_ESCAPE ? -1 : keybind;
            morph.keybind = keybind;

            if (keybind == -1)
            {
                this.keybind.setKeybind(Keyboard.KEY_NONE);
            }

            if (this.morphs.isAcquiredSelected())
            {
                Dispatcher.sendToServer(new PacketKeybind(this.indexOf(morph), keybind));
            }
            else
            {
                this.morphs.selected.category.edit(morph);
            }
        }
    }

    /**
     * Favorite or unfavorite current morph
     */
    private void favorite(GuiToggleElement button)
    {
        AbstractMorph morph = this.morphs.getSelected();

        if (morph != null)
        {
            if (this.morphs.isAcquiredSelected())
            {
                Dispatcher.sendToServer(new PacketFavorite(this.indexOf(morph)));
            }
            else
            {
                morph.favorite = button.isToggled();
                this.morphs.selected.category.edit(morph);
            }
        }
    }

    private int indexOf(AbstractMorph morph)
    {
        return this.morphs.acquired.getMorphs().indexOf(morph);
    }

    @Override
    public void keyPressed(char typedChar, int keyCode)
    {
        if (keyCode == ClientProxy.keys.keyDemorph.getKeyCode())
        {
            Dispatcher.sendToServer(new PacketSelectMorph(-1));
        }
        else if (MorphManager.INSTANCE.list.keyTyped(this.mc.player, keyCode))
        {
            this.closeScreen();
        }
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        GuiDraw.drawCustomBackground(this.root.area.x, this.root.area.y, this.root.area.w, this.root.area.h);
        this.sidebar.area.draw(ColorUtils.HALF_BLACK);
        Gui.drawRect(this.root.area.x, this.root.area.y, this.root.area.ex(), this.root.area.y + 20, 0xcc000000);
        this.context.font.drawStringWithShadow(I18n.format("metamorph.gui.survival.title"), this.root.area.x + 6, this.root.area.y + 10 - this.context.font.FONT_HEIGHT / 2, 0xffffff);

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

==================================================

--- Файл №81 ---
Путь: main\java\mchorse\metamorph\client\render\RenderMorph.java
--------------------
package mchorse.metamorph.client.render;

import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.entity.EntityMorph;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.client.registry.IRenderFactory;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class RenderMorph extends RenderLivingBase<EntityMorph>
{
    public RenderMorph(RenderManager manager, ModelBase model, float shadowSize)
    {
        super(manager, model, shadowSize);
    }

    /**
     * Render morph's name only if the player is pointed at the entity
     */
    @Override
    protected boolean canRenderName(EntityMorph entity)
    {
        return super.canRenderName(entity) && entity.hasCustomName() && entity == this.renderManager.pointedEntity;
    }

    /**
     * Get entity texture
     * 
     * Returns null, because this method isn't used
     */
    @Override
    protected ResourceLocation getEntityTexture(EntityMorph entity)
    {
        return null;
    }

    /**
     * Render the morph entity with some blending going on and blue-ish 
     * coloring. 
     */
    @Override
    public void doRender(EntityMorph entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        if (entity.morph == null)
        {
            return;
        }

        this.shadowSize = 0.35F;

        float range = (entity.timer - partialTicks) / 30.0F;
        float alpha = 0.7F - (range <= 0 ? 0.0F : range) * 0.7F;

        GlStateManager.pushMatrix();
        GlStateManager.color(0.1F, 0.9F, 1.0F, alpha > 0.7F ? 0.7F : alpha);

        GlStateManager.enableNormalize();
        GlStateManager.enableBlend();
        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        float ticks = entity.ticksExisted + partialTicks;
        float rotation = (ticks) * 5.0F;

        GlStateManager.translate(x, y + Math.sin(ticks / 5.0F) * 0.1F + 0.2F, z);
        GlStateManager.rotate(rotation, 0, 1, 0);
        GlStateManager.scale(alpha, alpha, alpha);

        MorphUtils.render(entity.morph, entity, 0, 0, 0, entityYaw, partialTicks);

        GlStateManager.disableBlend();
        GlStateManager.disableNormalize();
        GlStateManager.popMatrix();
    }

    /**
     * Scale shit out of this morph
     * 
     * This method is responsible for scaling the model. This suppose to make 
     * a very cool effect of entity appearing.
     */
    @Override
    protected void preRenderCallback(EntityMorph entity, float partialTickTime)
    {
        /* Interpolate scale */
        float scale = 1.0F - ((float) entity.timer / 30);

        if (scale > 1)
        {
            scale = 1.0F;
        }

        float x = 1.0F;
        float y = 1.0F;
        float z = 1.0F;

        x = MathHelper.clamp(x, 0.0F, 1.5F);
        y = MathHelper.clamp(y, 0.0F, 1.5F);
        z = MathHelper.clamp(z, 0.0F, 1.5F);

        GlStateManager.scale(x * scale, y * scale, z * scale);
    }

    /**
     * Rendering factory
     * 
     * Returns new instance of the morph renderer
     */
    public static class MorphFactory implements IRenderFactory<EntityMorph>
    {
        @Override
        public Render<? super EntityMorph> createRenderFor(RenderManager manager)
        {
            return new RenderMorph(manager, null, 0.5F);
        }
    }
}

==================================================

--- Файл №82 ---
Путь: main\java\mchorse\metamorph\commands\CommandAcquireMorph.java
--------------------
package mchorse.metamorph.commands;

import java.util.List;

import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphManager;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.tileentity.CommandBlockBaseLogic;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.TextComponentTranslation;

/**
 * Command /acquire_morph
 * 
 * This command is responsible for sending a morph to given player as an 
 * acquired morph.
 */
public class CommandAcquireMorph extends CommandBase
{
    @Override
    public String getName()
    {
        return "acquire_morph";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "metamorph.commands.acquire_morph";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        /* Because /op command has the same level, and I trust it */
        return 3;
    }

    @Override
    public boolean checkPermission(MinecraftServer server, ICommandSender sender)
    {
        return sender instanceof CommandBlockBaseLogic || super.checkPermission(server, sender);
    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (args.length < 2)
        {
            throw new WrongUsageException(this.getUsage(sender));
        }

        Entity entity = getEntity(server, sender, args[0]);

        if (!(entity instanceof EntityPlayer))
        {
            throw new CommandException("metamorph.error.morph.not_player", entity.getDisplayName());
        }

        EntityPlayer player = (EntityPlayer) entity;

        NBTTagCompound tag = null;

        if (args.length >= 3)
        {
            try
            {
                tag = JsonToNBT.getTagFromJson(CommandMorph.mergeArgs(args, 2));
            }
            catch (Exception e)
            {
                throw new CommandException("metamorph.error.morph.nbt", e.getMessage());
            }
        }

        if (tag == null)
        {
            tag = new NBTTagCompound();
        }

        tag.setString("Name", args[1]);

        if (!MorphAPI.acquire(player, MorphManager.INSTANCE.morphFromNBT(tag)))
        {
            throw new CommandException("metamorph.error.acquire", args[1]);
        }

        if (sender.sendCommandFeedback())
        {
            sender.sendMessage(new TextComponentTranslation("metamorph.success.acquire", args[0], args[1]));
        }
    }

    /**
     * Provide completion for player usernames for first argument
     */
    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, server.getOnlinePlayerNames());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №83 ---
Путь: main\java\mchorse\metamorph\commands\CommandMetamorph.java
--------------------
package mchorse.metamorph.commands;

import java.util.List;
import java.util.Map;
import java.util.Set;

import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphSettings;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.PacketBlacklist;
import mchorse.metamorph.network.common.PacketSettings;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.management.PlayerList;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * Command /metamorph
 * 
 * This command allows to manage
 */
public class CommandMetamorph extends CommandBase
{
    @Override
    public String getName()
    {
        return "metamorph";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "metamorph.commands.metamorph";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 3;
    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (args.length < 1)
        {
            throw new WrongUsageException(this.getUsage(sender));
        }

        if (args.length >= 1)
        {
            String action = args[0];

            if (action.equals("reload") && args.length >= 2)
            {
                this.reload(sender.getEntityWorld(), args[1]);
            }
        }
    }

    /**
     * Reload something (blacklist or morph configuration) 
     */
    private void reload(World world, String string)
    {
        /* Reload blacklist */
        if (string.equals("blacklist"))
        {
            Set<String> blacklist = MorphUtils.reloadBlacklist();

            MorphManager.INSTANCE.setActiveBlacklist(world, blacklist);
            this.broadcastPacket(new PacketBlacklist(blacklist));
        }
        else if (string.equals("morphs"))
        {
            /* Reload morph config */
            Map<String, MorphSettings> settings = MorphUtils.reloadMorphSettings();

            MorphManager.INSTANCE.setActiveSettings(settings);
            this.broadcastPacket(new PacketSettings(settings));
        }
        else if (string.equals("remapper"))
        {
            /* Reload morph config */
            Map<String, String> map = MorphUtils.reloadRemapper();

            MorphManager.INSTANCE.setActiveMap(map);
        }
    }

    /**
     * Broadcast a packet to all players 
     */
    private void broadcastPacket(IMessage packet)
    {
        PlayerList players = FMLCommonHandler.instance().getMinecraftServerInstance().getPlayerList();

        for (String username : players.getOnlinePlayerNames())
        {
            EntityPlayerMP player = players.getPlayerByUsername(username);

            if (player != null)
            {
                Dispatcher.sendTo(packet, player);
            }
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos targetPos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, "reload");
        }

        if (args.length == 2)
        {
            if (args[0].equals("reload"))
            {
                return getListOfStringsMatchingLastWord(args, "blacklist", "morphs", "remapper");
            }
        }

        return super.getTabCompletions(server, sender, args, targetPos);
    }
}

==================================================

--- Файл №84 ---
Путь: main\java\mchorse\metamorph\commands\CommandMorph.java
--------------------
package mchorse.metamorph.commands;

import java.util.List;

import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.tileentity.CommandBlockBaseLogic;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.TextComponentTranslation;

/**
 * Command /morph
 * 
 * This command is responsible for morphing a player into given morph.
 */
public class CommandMorph extends CommandBase
{
    @Override
    public String getName()
    {
        return "morph";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "metamorph.commands.morph";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }

    @Override
    public boolean checkPermission(MinecraftServer server, ICommandSender sender)
    {
        return sender instanceof CommandBlockBaseLogic || super.checkPermission(server, sender);
    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (args.length < 1)
        {
            throw new WrongUsageException(this.getUsage(sender));
        }

        Entity entity = getEntity(server, sender, args[0]);

        if (!(entity instanceof EntityPlayer))
        {
            throw new CommandException("metamorph.error.morph.not_player", entity.getDisplayName());
        }

        EntityPlayer player = (EntityPlayer) entity;

        if (args.length < 2)
        {
            MorphAPI.demorph(player);

            if (sender.sendCommandFeedback())
            {
                sender.sendMessage(new TextComponentTranslation("metamorph.success.demorph", args[0]));
            }
        }
        else
        {
            NBTTagCompound tag = null;
            String mergedTagArgs = "";

            if (args.length >= 3)
            {
                try
                {
                    mergedTagArgs = mergeArgs(args, 2);
                    tag = JsonToNBT.getTagFromJson(mergedTagArgs);
                }
                catch (Exception e)
                {
                    throw new CommandException("metamorph.error.morph.nbt", e.getMessage());
                }
            }

            if (tag == null)
            {
                tag = new NBTTagCompound();
            }

            tag.setString("Name", args[1]);

            AbstractMorph newMorph = MorphManager.INSTANCE.morphFromNBT(tag);
            boolean morphFound = newMorph != null;
            
            if (!morphFound)
            {
                throw new CommandException("metamorph.error.morph.factory", args[0], args[1], mergedTagArgs);
            }
            
            MorphAPI.morph(player, newMorph, true);

            if (sender.sendCommandFeedback())
            {
                sender.sendMessage(new TextComponentTranslation("metamorph.success.morph", args[0], args[1]));
            }
        }
    }

    /**
     * Provide completion for player usernames for first argument
     */
    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, server.getOnlinePlayerNames());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }

    /**
     * Merge given args from given index
     * 
     * Basically fold back string array argument back into string from given 
     * index.
     */
    public static String mergeArgs(String[] args, int i)
    {
        String dataTag = "";

        for (; i < args.length; i++)
        {
            dataTag += args[i] + (i == args.length - 1 ? "" : " ");
        }

        return dataTag;
    }
}

==================================================

--- Файл №85 ---
Путь: main\java\mchorse\metamorph\entity\EntityMorph.java
--------------------
package mchorse.metamorph.entity;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.entity.item.EntityXPOrb;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.SoundEvents;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.network.play.server.SPacketCollectItem;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.world.World;
import net.minecraft.world.WorldServer;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.registry.IEntityAdditionalSpawnData;

import java.util.Arrays;
import java.util.UUID;

/**
 * Entity morph
 * 
 * This entity is responsible for showing up the morph which will player 
 * acquire.
 * 
 * This entity is similar to {@link EntityXPOrb} or {@link EntityItem}, in terms 
 * of picking up.
 */
public class EntityMorph extends EntityLivingBase implements IEntityAdditionalSpawnData, IMorphProvider
{
    private String username;
    private UUID owner;
    private boolean ownerless = true;

    private EntityPlayer player;

    public int timer = 30;
    public int lifetime = 2400;
    public AbstractMorph morph;

    /**
     * Initiate the morph and make this entity invulnerable
     */
    public EntityMorph(World worldIn)
    {
        super(worldIn);

        this.setEntityInvulnerable(true);
        this.setCustomNameTag("Morph");
    }

    /**
     * Initiate the morph with morph and owner's UUID 
     */
    public EntityMorph(World worldIn, UUID owner, AbstractMorph morph)
    {
        this(worldIn);

        this.owner = owner;
        this.morph = morph;
        this.ownerless = false;

        this.setSize(morph);
    }

    @Override
    public AbstractMorph getMorph()
    {
        return this.morph;
    }

    /**
     * Get display name
     */
    @Override
    public ITextComponent getDisplayName()
    {
        if (this.morph != null)
        {
            return new TextComponentTranslation("entity." + this.morph.name + ".name");
        }

        return super.getDisplayName();
    }

    /**
     * Set size based on the morph's characteristics
     */
    private void setSize(AbstractMorph morph)
    {
        if (morph != null)
        {
            this.setSize(MathHelper.clamp(morph.getWidth(this), 0, 1.5F), MathHelper.clamp(morph.getHeight(this), 0, 2.0F));
        }
    }

    @Override
    protected boolean canTriggerWalking()
    {
        return false;
    }

    @Override
    public boolean canBeCollidedWith()
    {
        return false;
    }

    @Override
    public boolean canBePushed()
    {
        return false;
    }

    /**
     * Can't collide with other entities 
     */
    @Override
    protected void collideWithNearbyEntities()
    {}

    /**
     * Update method
     * 
     * This method is responsible for looking for player owner and advancing 
     * itself toward the player. It will also die and grant the morph to the 
     * player when it will be very close to player.
     */
    @Override
    public void onUpdate()
    {
        /* Don't allow it move horizontally */
        this.motionX = this.motionZ = 0;

        super.onUpdate();

        if (this.timer > 0)
        {
            this.timer--;

            return;
        }

        /* Find an owner */
        if (!this.world.isRemote && !this.isDead)
        {
            if (this.lifetime > 0)
            {
                this.lifetime--;
            }
            else if (this.lifetime == 0)
            {
                /* I.e. kill only if lifetime was above 0 (in this case
                 * only /summon'd morph with custom name tag can have 
                 * negative lifetime) */
                this.setDead();
            }

            this.updateMorph();
        }
    }

    /**
     * Do morph things which morphs should do on update. 
     */
    private void updateMorph()
    {
        /* Grant ownerless morph to the first collided player */
        if (this.ownerless)
        {
            for (EntityPlayer player : this.world.getEntitiesWithinAABB(EntityPlayer.class, this.getEntityBoundingBox()))
            {
                this.grantMorph(player);

                break;
            }
        }
        else
        {
            /* Find the owner */
            if (this.player == null || this.player.isDead)
            {
                if (this.owner != null)
                {
                    this.player = this.world.getPlayerEntityByUUID(this.owner);
                }
                else if (this.username != null)
                {
                    this.player = this.world.getPlayerEntityByName(this.username);
                }
            }

            /* Acquire morph when owner collides with a morph */
            if (this.player != null && this.getEntityBoundingBox().intersects(this.player.getEntityBoundingBox()))
            {
                this.grantMorph(this.player);
            }
        }
    }

    /**
     * Grant morph to the player
     * 
     * This method is responsible for giving this morph to the player. 
     */
    protected void grantMorph(EntityPlayer player)
    {
        if (this.world.isRemote)
        {
            return;
        }

        if (MorphAPI.acquire(player, this.morph))
        {
            this.world.playSound(player, this.posX, this.posY, this.posZ, SoundEvents.ENTITY_ITEM_PICKUP, SoundCategory.AMBIENT, 1.0F, 1.0F);

            /* Make the pickup animation */
            ((WorldServer) this.world).getEntityTracker().sendToTracking(this, new SPacketCollectItem(this.getEntityId(), player.getEntityId(), 1));
        }

        this.setDead();
    }

    /* Read / write */

    @Override
    public void writeEntityToNBT(NBTTagCompound compound)
    {
        compound.setInteger("LifeTime", this.lifetime);
        compound.setBoolean("Ownerless", this.ownerless);

        if (this.username != null && !this.username.isEmpty())
        {
            compound.setString("Username", this.username);
        }

        if (this.owner != null)
        {
            compound.setString("Owner", this.owner.toString());
        }

        if (this.morph != null)
        {
            NBTTagCompound tag = new NBTTagCompound();

            this.morph.toNBT(tag);
            compound.setTag("Morph", tag);
        }
    }

    @Override
    public void readEntityFromNBT(NBTTagCompound compound)
    {
        String owner = compound.getString("Owner");

        this.owner = owner.isEmpty() ? null : UUID.fromString(owner);

        if (compound.hasKey("LifeTime", 99))
        {
            this.lifetime = compound.getInteger("LifeTime");
        }

        if (this.owner != null)
        {
            this.ownerless = false;
        }

        if (compound.hasKey("Username", 8))
        {
            this.username = compound.getString("Username");
            this.ownerless = false;
        }
        else if (compound.hasKey("Ownerless"))
        {
            this.ownerless = compound.getBoolean("Ownerless");
        }

        if (compound.hasKey("Morph", 10))
        {
            this.morph = MorphManager.INSTANCE.morphFromNBT(compound.getCompoundTag("Morph"));
        }

        this.setSize(morph);
    }

    /* Spawn data read / write */

    @Override
    public void writeSpawnData(ByteBuf buffer)
    {
        ByteBufUtils.writeUTF8String(buffer, this.owner != null ? this.owner.toString() : "");
        MorphUtils.morphToBuf(buffer, this.morph);
    }

    @Override
    public void readSpawnData(ByteBuf buffer)
    {
        String owner = ByteBufUtils.readUTF8String(buffer);

        this.owner = owner.isEmpty() ? null : UUID.fromString(owner);
        this.morph = MorphUtils.morphFromBuf(buffer);

        this.setSize(morph);
    }

    /* Unused methods */

    @Override
    public Iterable<ItemStack> getArmorInventoryList()
    {
        return Arrays.<ItemStack>asList();
    }

    @Override
    public ItemStack getItemStackFromSlot(EntityEquipmentSlot slotIn)
    {
        return ItemStack.EMPTY;
    }

    @Override
    public void setItemStackToSlot(EntityEquipmentSlot slotIn, ItemStack stack)
    {}

    @Override
    public EnumHandSide getPrimaryHand()
    {
        return EnumHandSide.RIGHT;
    }
}

==================================================

--- Файл №86 ---
Путь: main\java\mchorse\metamorph\entity\SoundHandler.java
--------------------
package mchorse.metamorph.entity;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.util.ObfuscatedName;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.DamageSource;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.SoundEvent;
import net.minecraftforge.event.entity.PlaySoundAtEntityEvent;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

/**
 * Replaces the sounds that players usually make when they are in morphs
 */
public class SoundHandler
{
    public static final ObfuscatedName GET_HURT_SOUND = new ObfuscatedName("func_184601_bQ" /* getHurtSound */);
    public static final ObfuscatedName GET_DEATH_SOUND = new ObfuscatedName("func_184615_bR" /* getDeathSound */);
    public static final ObfuscatedName PLAY_STEP_SOUND = new ObfuscatedName("func_180429_a" /* playStepSound */);

    public static final DamageSource GENERIC_DAMAGE = DamageSource.GENERIC;

    public static final SoundEvent NO_SOUND = new SoundEvent(new ResourceLocation(Metamorph.MOD_ID, "no_sound"));

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onPlayerHurt(LivingAttackEvent event)
    {
        if (event.isCanceled())
        {
            return;
        }

        Entity entity = event.getEntity();
        if (!(entity instanceof EntityPlayer))
        {
            return;
        }
        IMorphing morphing = Morphing.get((EntityPlayer) entity);
        if (morphing == null)
        {
            return;
        }

        morphing.setLastDamageSource(event.getSource());
    }

    @SubscribeEvent
    public void onPlaySound(PlaySoundAtEntityEvent event)
    {
        Entity entity = event.getEntity();
        if (!(entity instanceof EntityPlayer))
        {
            return;
        }
        EntityPlayer player = (EntityPlayer) entity;
        IMorphing morphing = Morphing.get(player);
        if (morphing == null)
        {
            return;
        }
        AbstractMorph morph = morphing.getCurrentMorph();
        if (morph == null)
        {
            return;
        }

        SoundEvent sound = event.getSound();
        if (sound == null) {
            // Sounds can be null, apparently
            return;
        }
        ResourceLocation soundResource = sound.getRegistryName();
        if (soundResource == null) {
            return;
        }
        String soundType = soundResource.getResourcePath();
        
        if (soundType.endsWith(".hurt"))
        {
            SoundEvent newSound = morph.getHurtSound(player, morphing.getLastDamageSource());
            if (newSound == NO_SOUND)
            {
                event.setCanceled(true);
            }
            else if (newSound != null)
            {
                event.setSound(newSound);
            }
        }
        else if (soundType.endsWith(".death"))
        {
            SoundEvent newSound = morph.getDeathSound(player);
            if (newSound == NO_SOUND)
            {
                event.setCanceled(true);
            }
            else if (newSound != null)
            {
                event.setSound(newSound);
            }
        }
        else if (soundType.endsWith(".step"))
        {
            if (player.width != morph.getWidth(player) || player.height != morph.getHeight(player))
            {
                /*
                 * Check if the player's current hitbox does not
                 * match the morph hitbox.
                 * 
                 * Each tick, the player entity attempts to revert
                 * back to the default player hitbox. If the current
                 * morph hitbox is smaller than the player hitbox,
                 * movement can be triggered, which in turn triggers
                 * a step sound.
                 */
                event.setCanceled(true);
            }
            else if (morph.hasCustomStepSound(player))
            {
                event.setCanceled(true);
                morph.playStepSound(player);
            }
        }
    }
}


==================================================

--- Файл №87 ---
Путь: main\java\mchorse\metamorph\network\Dispatcher.java
--------------------
package mchorse.metamorph.network;

import mchorse.mclib.network.AbstractDispatcher;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.network.client.creative.ClientHandlerAcquireMorph;
import mchorse.metamorph.network.client.survival.ClientHandlerAcquiredMorphs;
import mchorse.metamorph.network.client.ClientHandlerBlacklist;
import mchorse.metamorph.network.client.survival.ClientHandlerFavorite;
import mchorse.metamorph.network.client.survival.ClientHandlerKeybind;
import mchorse.metamorph.network.client.creative.ClientHandlerMorph;
import mchorse.metamorph.network.client.survival.ClientHandlerMorphPlayer;
import mchorse.metamorph.network.client.survival.ClientHandlerMorphState;
import mchorse.metamorph.network.client.survival.ClientHandlerRemoveMorph;
import mchorse.metamorph.network.client.ClientHandlerSettings;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import mchorse.metamorph.network.common.creative.PacketClearAcquired;
import mchorse.metamorph.network.common.survival.PacketAcquiredMorphs;
import mchorse.metamorph.network.common.survival.PacketAction;
import mchorse.metamorph.network.common.PacketBlacklist;
import mchorse.metamorph.network.common.survival.PacketFavorite;
import mchorse.metamorph.network.common.survival.PacketKeybind;
import mchorse.metamorph.network.common.creative.PacketMorph;
import mchorse.metamorph.network.common.survival.PacketMorphPlayer;
import mchorse.metamorph.network.common.survival.PacketMorphState;
import mchorse.metamorph.network.common.survival.PacketRemoveMorph;
import mchorse.metamorph.network.common.survival.PacketSelectMorph;
import mchorse.metamorph.network.common.PacketSettings;
import mchorse.metamorph.network.common.creative.PacketSyncMorph;
import mchorse.metamorph.network.server.creative.ServerHandlerAcquireMorph;
import mchorse.metamorph.network.server.creative.ServerHandlerClearAcquired;
import mchorse.metamorph.network.server.survival.ServerHandlerAction;
import mchorse.metamorph.network.server.survival.ServerHandlerFavorite;
import mchorse.metamorph.network.server.survival.ServerHandlerKeybind;
import mchorse.metamorph.network.server.creative.ServerHandlerMorph;
import mchorse.metamorph.network.server.survival.ServerHandlerRemoveMorph;
import mchorse.metamorph.network.server.survival.ServerHandlerSelectMorph;
import mchorse.metamorph.network.server.creative.ServerHandlerSyncMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.relauncher.Side;

/**
 * Network dispatcher
 */
public class Dispatcher
{
    public static final AbstractDispatcher DISPATCHER = new AbstractDispatcher(Metamorph.MOD_ID)
    {
        @Override
        public void register()
        {
            /* Action */
            register(PacketAction.class, ServerHandlerAction.class, Side.SERVER);

            /* Morphing */
            register(PacketMorph.class, ClientHandlerMorph.class, Side.CLIENT);
            register(PacketMorph.class, ServerHandlerMorph.class, Side.SERVER);
            register(PacketMorphPlayer.class, ClientHandlerMorphPlayer.class, Side.CLIENT);

            register(PacketAcquireMorph.class, ClientHandlerAcquireMorph.class, Side.CLIENT);
            register(PacketAcquireMorph.class, ServerHandlerAcquireMorph.class, Side.SERVER);
            register(PacketAcquiredMorphs.class, ClientHandlerAcquiredMorphs.class, Side.CLIENT);
            register(PacketSyncMorph.class, ServerHandlerSyncMorph.class, Side.SERVER);

            register(PacketSelectMorph.class, ServerHandlerSelectMorph.class, Side.SERVER);
            register(PacketClearAcquired.class, ServerHandlerClearAcquired.class, Side.SERVER);

            /* Morph state */
            register(PacketMorphState.class, ClientHandlerMorphState.class, Side.CLIENT);

            /* Managing morphs */
            register(PacketFavorite.class, ClientHandlerFavorite.class, Side.CLIENT);
            register(PacketFavorite.class, ServerHandlerFavorite.class, Side.SERVER);

            register(PacketKeybind.class, ClientHandlerKeybind.class, Side.CLIENT);
            register(PacketKeybind.class, ServerHandlerKeybind.class, Side.SERVER);

            register(PacketRemoveMorph.class, ClientHandlerRemoveMorph.class, Side.CLIENT);
            register(PacketRemoveMorph.class, ServerHandlerRemoveMorph.class, Side.SERVER);

            /* Syncing data */
            register(PacketBlacklist.class, ClientHandlerBlacklist.class, Side.CLIENT);
            register(PacketSettings.class, ClientHandlerSettings.class, Side.CLIENT);
        }
    };

    /**
     * Send message to players who are tracking given entity
     */
    public static void sendToTracked(Entity entity, IMessage message)
    {
        DISPATCHER.sendToTracked(entity, message);
    }

    /**
     * Send message to given player
     */
    public static void sendTo(IMessage message, EntityPlayerMP player)
    {
        DISPATCHER.sendTo(message, player);
    }

    /**
     * Send message to the server
     */
    public static void sendToServer(IMessage message)
    {
        DISPATCHER.sendToServer(message);
    }

    /**
     * Register all the networking messages and message handlers
     */
    public static void register()
    {
        DISPATCHER.register();
    }
}

==================================================

--- Файл №88 ---
Путь: main\java\mchorse\metamorph\network\client\ClientHandlerBlacklist.java
--------------------
package mchorse.metamorph.network.client;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.network.common.PacketBlacklist;
import net.minecraft.client.entity.EntityPlayerSP;

/**
 * Client handler blacklist loader 
 */
public class ClientHandlerBlacklist extends ClientMessageHandler<PacketBlacklist>
{
    @Override
    public void run(EntityPlayerSP player, PacketBlacklist message)
    {
        MorphManager.INSTANCE.setActiveBlacklist(player.world, message.blacklist);
    }
}


==================================================

--- Файл №89 ---
Путь: main\java\mchorse\metamorph\network\client\ClientHandlerSettings.java
--------------------
package mchorse.metamorph.network.client;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.network.common.PacketSettings;
import net.minecraft.client.entity.EntityPlayerSP;

public class ClientHandlerSettings extends ClientMessageHandler<PacketSettings>
{
    @Override
    public void run(EntityPlayerSP player, PacketSettings message)
    {
        MorphManager.INSTANCE.setActiveSettings(message.settings);
    }
}

==================================================

--- Файл №90 ---
Путь: main\java\mchorse\metamorph\network\client\creative\ClientHandlerAcquireMorph.java
--------------------
package mchorse.metamorph.network.client.creative;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.ClientProxy;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerAcquireMorph extends ClientMessageHandler<PacketAcquireMorph>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketAcquireMorph message)
    {
        IMorphing morphing = Morphing.get(player);

        morphing.acquireMorph(message.morph);

        ClientProxy.morphOverlay.add(message.morph);
    }
}

==================================================

--- Файл №91 ---
Путь: main\java\mchorse\metamorph\network\client\creative\ClientHandlerMorph.java
--------------------
package mchorse.metamorph.network.client.creative;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.creative.PacketMorph;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerMorph extends ClientMessageHandler<PacketMorph>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketMorph message)
    {
        IMorphing capability = Morphing.get(player);

        if (capability != null)
        {
            capability.setCurrentMorph(message.morph, player, true);
        }
    }
}

==================================================

--- Файл №92 ---
Путь: main\java\mchorse\metamorph\network\client\survival\ClientHandlerAcquiredMorphs.java
--------------------
package mchorse.metamorph.network.client.survival;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketAcquiredMorphs;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerAcquiredMorphs extends ClientMessageHandler<PacketAcquiredMorphs>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketAcquiredMorphs message)
    {
        IMorphing morphing = Morphing.get(player);

        morphing.setAcquiredMorphs(message.morphs);
    }
}

==================================================

--- Файл №93 ---
Путь: main\java\mchorse\metamorph\network\client\survival\ClientHandlerFavorite.java
--------------------
package mchorse.metamorph.network.client.survival;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketFavorite;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerFavorite extends ClientMessageHandler<PacketFavorite>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketFavorite message)
    {
        Morphing.get(player).favorite(message.index);
    }
}

==================================================

--- Файл №94 ---
Путь: main\java\mchorse\metamorph\network\client\survival\ClientHandlerKeybind.java
--------------------
package mchorse.metamorph.network.client.survival;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketKeybind;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerKeybind extends ClientMessageHandler<PacketKeybind>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketKeybind message)
    {
        Morphing.get(player).keybind(message.index, message.keybind);
    }
}

==================================================

--- Файл №95 ---
Путь: main\java\mchorse\metamorph\network\client\survival\ClientHandlerMorphPlayer.java
--------------------
package mchorse.metamorph.network.client.survival;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.MorphingProvider;
import mchorse.metamorph.network.common.survival.PacketMorphPlayer;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerMorphPlayer extends ClientMessageHandler<PacketMorphPlayer>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketMorphPlayer message)
    {
        Entity entity = player.world.getEntityByID(message.id);
        IMorphing capability = entity.getCapability(MorphingProvider.MORPHING_CAP, null);

        if (capability != null)
        {
            capability.setCurrentMorph(message.morph, (EntityPlayer) entity, true);
        }
    }
}


==================================================

--- Файл №96 ---
Путь: main\java\mchorse\metamorph\network\client\survival\ClientHandlerMorphState.java
--------------------
package mchorse.metamorph.network.client.survival;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketMorphState;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerMorphState extends ClientMessageHandler<PacketMorphState>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketMorphState message)
    {
        IMorphing capability = Morphing.get(player);
        AbstractMorph morph = capability.getCurrentMorph();

        if (morph instanceof EntityMorph)
        {
            Entity entity = ((EntityMorph) morph).getEntity(player.world);

            entity.setEntityId(message.entityID);
        }

        capability.setHasSquidAir(message.hasSquidAir);
        capability.setSquidAir(message.squidAir);
    }
}


==================================================

--- Файл №97 ---
Путь: main\java\mchorse\metamorph\network\client\survival\ClientHandlerRemoveMorph.java
--------------------
package mchorse.metamorph.network.client.survival;

import mchorse.mclib.network.ClientMessageHandler;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketRemoveMorph;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerRemoveMorph extends ClientMessageHandler<PacketRemoveMorph>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketRemoveMorph message)
    {
        Morphing.get(player).remove(message.index);
    }
}

==================================================

--- Файл №98 ---
Путь: main\java\mchorse\metamorph\network\common\PacketBlacklist.java
--------------------
package mchorse.metamorph.network.common;

import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketBlacklist implements IMessage
{
    public Set<String> blacklist = new TreeSet<String>();

    public PacketBlacklist()
    {}

    public PacketBlacklist(Set<String> blacklist)
    {
        this.blacklist.addAll(blacklist);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        for (int i = 0, c = buf.readInt(); i < c; i++)
        {
            this.blacklist.add(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.blacklist.size());

        Iterator<String> it = this.blacklist.iterator();

        while (it.hasNext())
        {
            ByteBufUtils.writeUTF8String(buf, it.next());
        }
    }
}

==================================================

--- Файл №99 ---
Путь: main\java\mchorse\metamorph\network\common\PacketSettings.java
--------------------
package mchorse.metamorph.network.common;

import java.util.HashMap;
import java.util.Map;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.MorphSettings;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * Packet that sents settings 
 */
public class PacketSettings implements IMessage
{
    public Map<String, MorphSettings> settings = new HashMap<String, MorphSettings>();

    public PacketSettings()
    {}

    public PacketSettings(Map<String, MorphSettings> settings)
    {
        this.settings.clear();
        this.settings.putAll(settings);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        for (int i = 0, c = buf.readInt(); i < c; i++)
        {
            String key = ByteBufUtils.readUTF8String(buf);
            MorphSettings setting = new MorphSettings();

            setting.fromBytes(buf);
            this.settings.put(key, setting);
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.settings.size());

        for (Map.Entry<String, MorphSettings> setting : this.settings.entrySet())
        {
            ByteBufUtils.writeUTF8String(buf, setting.getKey());
            setting.getValue().toBytes(buf);
        }
    }
}

==================================================

--- Файл №100 ---
Путь: main\java\mchorse\metamorph\network\common\creative\PacketAcquireMorph.java
--------------------
package mchorse.metamorph.network.common.creative;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.morphs.AbstractMorph;

/**
 * Acquire morph packet
 */
public class PacketAcquireMorph extends PacketMorph
{
    public boolean notify;

    public PacketAcquireMorph()
    {
        super();
    }

    public PacketAcquireMorph(AbstractMorph morph)
    {
        this(morph, true);
    }

    public PacketAcquireMorph(AbstractMorph morph, boolean notify)
    {
        super(morph);

        this.notify = notify;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.notify = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeBoolean(this.notify);
    }
}

==================================================

--- Файл №101 ---
Путь: main\java\mchorse\metamorph\network\common\creative\PacketClearAcquired.java
--------------------
package mchorse.metamorph.network.common.creative;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketClearAcquired implements IMessage
{
    public PacketClearAcquired()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №102 ---
Путь: main\java\mchorse\metamorph\network\common\creative\PacketMorph.java
--------------------
package mchorse.metamorph.network.common.creative;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.NBTUtils;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketMorph implements IMessage
{
    public AbstractMorph morph;

    public PacketMorph()
    {}

    public PacketMorph(AbstractMorph morph)
    {
        this.morph = morph;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.morph = MorphManager.INSTANCE.morphFromNBT(NBTUtils.readInfiniteTag(buf));
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        MorphUtils.morphToBuf(buf, this.morph);
    }
}

==================================================

--- Файл №103 ---
Путь: main\java\mchorse\metamorph\network\common\creative\PacketSyncMorph.java
--------------------
package mchorse.metamorph.network.common.creative;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.morphs.AbstractMorph;

public class PacketSyncMorph extends PacketMorph
{
    public int index;

    public PacketSyncMorph()
    {}

    public PacketSyncMorph(AbstractMorph morph, int index)
    {
        super(morph);
        this.index = index;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.index = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.index);
    }
}

==================================================

--- Файл №104 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketAcquiredMorphs.java
--------------------
package mchorse.metamorph.network.common.survival;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import java.util.ArrayList;
import java.util.List;

/**
 * Acquired morphs packet
 */
public class PacketAcquiredMorphs implements IMessage
{
    public List<AbstractMorph> morphs;

    public PacketAcquiredMorphs()
    {
        this.morphs = new ArrayList<AbstractMorph>();
    }

    public PacketAcquiredMorphs(List<AbstractMorph> morphs)
    {
        this.morphs = morphs;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        for (int i = 0, c = buf.readInt(); i < c; i++)
        {
            AbstractMorph morph = MorphUtils.morphFromBuf(buf);

            if (morph != null)
            {
                this.morphs.add(morph);
            }
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.morphs.size());

        for (AbstractMorph morph : this.morphs)
        {
            MorphUtils.morphToBuf(buf, morph);
        }
    }
}


==================================================

--- Файл №105 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketAction.java
--------------------
package mchorse.metamorph.network.common.survival;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketAction implements IMessage
{
    public PacketAction()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №106 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketFavorite.java
--------------------
package mchorse.metamorph.network.common.survival;

/**
 * Packet favorite a morph
 */
public class PacketFavorite extends PacketIndex
{
    public PacketFavorite()
    {
        super();
    }

    public PacketFavorite(int index)
    {
        super(index);
    }
}

==================================================

--- Файл №107 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketIndex.java
--------------------
package mchorse.metamorph.network.common.survival;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public abstract class PacketIndex implements IMessage
{
    public int index;

    public PacketIndex()
    {}

    public PacketIndex(int index)
    {
        this.index = index;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.index = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(index);
    }
}

==================================================

--- Файл №108 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketKeybind.java
--------------------
package mchorse.metamorph.network.common.survival;

import io.netty.buffer.ByteBuf;

public class PacketKeybind extends PacketIndex
{
    public int keybind;

    public PacketKeybind()
    {
        super();
    }

    public PacketKeybind(int index, int keybind)
    {
        super(index);

        this.keybind = keybind;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.keybind = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.keybind);
    }
}

==================================================

--- Файл №109 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketMorphPlayer.java
--------------------
package mchorse.metamorph.network.common.survival;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketMorphPlayer implements IMessage
{
    public int id;
    public AbstractMorph morph;

    public PacketMorphPlayer()
    {}

    public PacketMorphPlayer(int id, AbstractMorph morph)
    {
        this.id = id;
        this.morph = morph;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.morph = MorphUtils.morphFromBuf(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        MorphUtils.morphToBuf(buf, this.morph);
    }
}

==================================================

--- Файл №110 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketMorphState.java
--------------------
package mchorse.metamorph.network.common.survival;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketMorphState implements IMessage
{
    public int entityID = 0;
    public boolean hasSquidAir = true;
    public int squidAir = 300;

    public PacketMorphState()
    {}

    public PacketMorphState(EntityPlayer player, IMorphing morphing)
    {
        if (morphing != null)
        {
            AbstractMorph morph = morphing.getCurrentMorph();

            if (morph instanceof EntityMorph)
            {
                entityID = ((EntityMorph) morph).getEntity(player.world).getEntityId();
            }

            this.hasSquidAir = morphing.getHasSquidAir();
            this.squidAir = morphing.getSquidAir();
        }
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.entityID = buf.readInt();
        this.hasSquidAir = buf.readBoolean();
        this.squidAir = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.entityID);
        buf.writeBoolean(this.hasSquidAir);
        buf.writeInt(this.squidAir);
    }

}


==================================================

--- Файл №111 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketRemoveMorph.java
--------------------
package mchorse.metamorph.network.common.survival;

public class PacketRemoveMorph extends PacketIndex
{
    public PacketRemoveMorph()
    {
        super();
    }

    public PacketRemoveMorph(int index)
    {
        super(index);
    }
}

==================================================

--- Файл №112 ---
Путь: main\java\mchorse\metamorph\network\common\survival\PacketSelectMorph.java
--------------------
package mchorse.metamorph.network.common.survival;

public class PacketSelectMorph extends PacketIndex
{
    public PacketSelectMorph()
    {
        super();
    }

    public PacketSelectMorph(int index)
    {
        super(index);
    }
}

==================================================

--- Файл №113 ---
Путь: main\java\mchorse\metamorph\network\server\creative\ServerHandlerAcquireMorph.java
--------------------
package mchorse.metamorph.network.server.creative;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.network.common.creative.PacketAcquireMorph;
import net.minecraft.entity.player.EntityPlayerMP;

/**
 * Server handler acquire morph
 * 
 * This handler is responsible for sending acquired morph for players in 
 * creative morph.
 */
public class ServerHandlerAcquireMorph extends ServerMessageHandler<PacketAcquireMorph>
{
    @Override
    public void run(EntityPlayerMP player, PacketAcquireMorph message)
    {
        if (player.isCreative() || player.isSpectator())
        {
            MorphAPI.acquire(player, message.morph);
        }
    }
}

==================================================

--- Файл №114 ---
Путь: main\java\mchorse\metamorph\network\server\creative\ServerHandlerClearAcquired.java
--------------------
package mchorse.metamorph.network.server.creative;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.creative.PacketClearAcquired;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerClearAcquired extends ServerMessageHandler<PacketClearAcquired>
{
    @Override
    public void run(EntityPlayerMP player, PacketClearAcquired message)
    {
        IMorphing cap = Morphing.get(player);

        if (cap != null)
        {
            cap.removeAcquired();
        }
    }
}

==================================================

--- Файл №115 ---
Путь: main\java\mchorse\metamorph\network\server\creative\ServerHandlerMorph.java
--------------------
package mchorse.metamorph.network.server.creative;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.network.common.creative.PacketMorph;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerMorph extends ServerMessageHandler<PacketMorph>
{
    @Override
    public void run(EntityPlayerMP player, PacketMorph message)
    {
        if (Metamorph.proxy.canUse(player))
        {
            MorphAPI.morph(player, message.morph, Metamorph.allowMorphingIntoCategoryMorphs.get());
        }
    }
}

==================================================

--- Файл №116 ---
Путь: main\java\mchorse\metamorph\network\server\creative\ServerHandlerSyncMorph.java
--------------------
package mchorse.metamorph.network.server.creative;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.creative.PacketSyncMorph;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerSyncMorph extends ServerMessageHandler<PacketSyncMorph>
{
    @Override
    public void run(EntityPlayerMP player, PacketSyncMorph message)
    {
        IMorphing cap = Morphing.get(player);

        if (cap != null && message.morph != null)
        {
            cap.getAcquiredMorphs().set(message.index, message.morph);
        }
    }
}

==================================================

--- Файл №117 ---
Путь: main\java\mchorse\metamorph\network\server\survival\ServerHandlerAction.java
--------------------
package mchorse.metamorph.network.server.survival;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.api.events.MorphActionEvent;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketAction;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.common.MinecraftForge;

public class ServerHandlerAction extends ServerMessageHandler<PacketAction>
{
    @Override
    public void run(EntityPlayerMP player, PacketAction message)
    {
        IMorphing capability = Morphing.get(player);

        if (capability != null && capability.isMorphed() && !player.isSpectator())
        {
            AbstractMorph morph = capability.getCurrentMorph();

            morph.action(player);
            MinecraftForge.EVENT_BUS.post(new MorphActionEvent(player, morph.getSettings().action, morph));
        }
    }
}

==================================================

--- Файл №118 ---
Путь: main\java\mchorse\metamorph\network\server\survival\ServerHandlerFavorite.java
--------------------
package mchorse.metamorph.network.server.survival;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.survival.PacketFavorite;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerFavorite extends ServerMessageHandler<PacketFavorite>
{
    @Override
    public void run(EntityPlayerMP player, PacketFavorite message)
    {
        Morphing.get(player).favorite(message.index);
        Dispatcher.sendTo(message, player);
    }
}

==================================================

--- Файл №119 ---
Путь: main\java\mchorse\metamorph\network\server\survival\ServerHandlerKeybind.java
--------------------
package mchorse.metamorph.network.server.survival;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.survival.PacketKeybind;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerKeybind extends ServerMessageHandler<PacketKeybind>
{
    @Override
    public void run(EntityPlayerMP player, PacketKeybind message)
    {
        Morphing.get(player).keybind(message.index, message.keybind);
        Dispatcher.sendTo(message, player);
    }
}

==================================================

--- Файл №120 ---
Путь: main\java\mchorse\metamorph\network\server\survival\ServerHandlerRemoveMorph.java
--------------------
package mchorse.metamorph.network.server.survival;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.Dispatcher;
import mchorse.metamorph.network.common.survival.PacketRemoveMorph;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRemoveMorph extends ServerMessageHandler<PacketRemoveMorph>
{
    @Override
    public void run(EntityPlayerMP player, PacketRemoveMorph message)
    {
        if (Morphing.get(player).remove(message.index))
        {
            Dispatcher.sendTo(message, player);
        }
    }
}

==================================================

--- Файл №121 ---
Путь: main\java\mchorse\metamorph\network\server\survival\ServerHandlerSelectMorph.java
--------------------
package mchorse.metamorph.network.server.survival;

import java.util.List;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import mchorse.metamorph.network.common.survival.PacketSelectMorph;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.world.GameType;

public class ServerHandlerSelectMorph extends ServerMessageHandler<PacketSelectMorph>
{
    @Override
    public void run(EntityPlayerMP player, PacketSelectMorph message)
    {
        if (player.interactionManager.getGameType() == GameType.ADVENTURE)
        {
            return;
        }

        int index = message.index;

        IMorphing capability = Morphing.get(player);
        List<AbstractMorph> morphs = capability.getAcquiredMorphs();
        AbstractMorph morph = null;

        if (!morphs.isEmpty() && index >= 0 && index < morphs.size())
        {
            morph = morphs.get(index);
        }

        MorphAPI.morph(player, MorphUtils.copy(morph), false);
    }
}

==================================================

--- Файл №122 ---
Путь: main\java\mchorse\metamorph\util\DevMappings.java
--------------------
package mchorse.metamorph.util;

import java.io.File;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.common.base.Charsets;
import com.google.common.base.Strings;
import com.google.common.io.Files;

/**
 * Utility class for converting srgnames
 * (used in a release environment)
 * to mcp names (used in a development environment)
 * Protects function/field string constants from
 * the whims of mcp renames.
 * 
 * For use in a development environment only.
 * 
 * @author asanetargoss
 */
public class DevMappings
{
    static Map<String, String> srgToMcp;
    
    /**
     * Convert srgnames to mcp names
     * (methods and fields) in a dev environment.
     */
    public static String get(String srgname)
    {
        return srgToMcp.get(srgname);
    }
    
    static
    {
        String mappingFileProp = System.getProperty("net.minecraftforge.gradle.GradleStart.srg.srg-mcp");
        if (!Strings.isNullOrEmpty(mappingFileProp))
        {
            try
            {
                srgToMcp = new HashMap<String, String>();
                
                List<String> mappingLines = Files.readLines(new File(mappingFileProp), Charsets.UTF_8);
                for (String line : mappingLines)
                {
                    /* Get rid of all the
                     * fully qualified junk since the srgnames
                     * themselves should be unique.
                     */
                    String[] parts = line.split(" ");
                    if (parts[0].equals("FD:"))
                    {
                        // Field: check 1st and 2rd ending part (after the slashes)
                        String srg = parts[1].substring(parts[1].lastIndexOf("/")+1);
                        String mcp = parts[2].substring(parts[2].lastIndexOf("/")+1);
                        srgToMcp.put(srg, mcp);
                    }
                    else if (parts[0].equals("MD:"))
                    {
                        // Method: check 1st and 3rd ending part (after the slashes)
                        //     (the other two parts are the descriptors)
                        String srg = parts[1].substring(parts[1].lastIndexOf("/")+1);
                        String mcp = parts[3].substring(parts[3].lastIndexOf("/")+1);
                        srgToMcp.put(srg, mcp);
                    }
                }
            } catch (IOException e)
            {
                e.printStackTrace();
            }
            
        }
    }
}


==================================================

--- Файл №123 ---
Путь: main\java\mchorse\metamorph\util\InvokeUtil.java
--------------------
package mchorse.metamorph.util;

import java.lang.reflect.Method;

public class InvokeUtil
{

    /**
     * Ascends up a class chain until it finds the specified method, regardless
     * of access modifier. Assumes finalClazz is the original declarer of the specified method.
     */
    public static Method getPrivateMethod(Class<?> clazz, Class<?> finalClazz, String methodName, Class<?>... paramVarArgs)
            throws NoSuchMethodException, SecurityException
    {
        Method privateMethod = null;
        
        for (Class<?> testClazz = clazz;
                testClazz != finalClazz && privateMethod == null;
                testClazz = testClazz.getSuperclass())
        {
            for (Method method : testClazz.getDeclaredMethods())
            {
                if (!method.getName().equals(methodName))
                {
                    continue;
                }
                
                Class<?>[] parameters = method.getParameterTypes();
                if (!(parameters.length == paramVarArgs.length))
                {
                    continue;
                }
                boolean matchingMethod = true;
                for (int i = 0; i < parameters.length; i++)
                {
                    if (!(parameters[i] == paramVarArgs[i]))
                    {
                        matchingMethod = false;
                        break;
                    }
                }
                
                if (matchingMethod)
                {
                    privateMethod = method;
                    break;
                }
            }
        }
        
        if (privateMethod == null)
        {
            privateMethod = finalClazz.getDeclaredMethod(methodName, paramVarArgs);
        }
        
        privateMethod.setAccessible(true);
        return privateMethod;
    }

}


==================================================

--- Файл №124 ---
Путь: main\java\mchorse\metamorph\util\MMIcons.java
--------------------
package mchorse.metamorph.util;

import mchorse.mclib.client.gui.utils.Icon;
import net.minecraft.util.ResourceLocation;

/**
 * Metamorph icons
 */
public class MMIcons
{
    public static final ResourceLocation PANEL_ICONS = new ResourceLocation("metamorph:textures/gui/icons.png");

    public static final Icon USER = new Icon(PANEL_ICONS, 0, 0);
    public static final Icon PROPERTIES = new Icon(PANEL_ICONS, 16, 0);
    public static final Icon ITEM = new Icon(PANEL_ICONS, 32, 0);
    public static final Icon LABEL = new Icon(PANEL_ICONS, 48, 0);
}

==================================================

--- Файл №125 ---
Путь: main\java\mchorse\metamorph\util\ObfuscatedName.java
--------------------
package mchorse.metamorph.util;

import javax.annotation.Nonnull;

import net.minecraftforge.classloading.FMLForgePlugin;

/**
 * Object for storing a method/field string. If a srgname
 * is given, it will provide the appropriate mcp name if
 * in a development environment environment. Otherwise
 * it will just provide the given string.
 * 
 * @author asanetargoss
 */
public class ObfuscatedName
{
    private final String srgName;
    /** Initially null. Given cached value when get()
     * is called in a development environment */
    private String mcpName = null;
    
    public ObfuscatedName(@Nonnull String srgName)
    {
        this.srgName = srgName;
    }
    
    /**
     * Get name relevant for current environment.
     * In development environment, default to srgName
     * if mcpName is not present in the mapping.
     */
    public @Nonnull String getName()
    {
        if (FMLForgePlugin.RUNTIME_DEOBF)
        {
            return srgName;
        }
        else
        {
            if (mcpName == null)
            {
                mcpName = DevMappings.get(srgName);
                if (mcpName == null)
                {
                    mcpName = srgName;
                }
            }
            return mcpName;
        }
    }
}


==================================================

--- Файл №126 ---
Путь: main\java\mchorse\vanilla_pack\MetamorphFactory.java
--------------------
package mchorse.vanilla_pack;

import mchorse.metamorph.api.IMorphFactory;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.abilities.IAbility;
import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.abilities.IAttackAbility;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.vanilla_pack.abilities.Climb;
import mchorse.vanilla_pack.abilities.FireProof;
import mchorse.vanilla_pack.abilities.Fly;
import mchorse.vanilla_pack.abilities.Glide;
import mchorse.vanilla_pack.abilities.Hungerless;
import mchorse.vanilla_pack.abilities.Jumping;
import mchorse.vanilla_pack.abilities.NightVision;
import mchorse.vanilla_pack.abilities.PreventFall;
import mchorse.vanilla_pack.abilities.Rotten;
import mchorse.vanilla_pack.abilities.SnowWalk;
import mchorse.vanilla_pack.abilities.StepUp;
import mchorse.vanilla_pack.abilities.SunAllergy;
import mchorse.vanilla_pack.abilities.Swim;
import mchorse.vanilla_pack.abilities.WaterAllergy;
import mchorse.vanilla_pack.abilities.WaterBreath;
import mchorse.vanilla_pack.actions.Endermite;
import mchorse.vanilla_pack.actions.Explode;
import mchorse.vanilla_pack.actions.FireBreath;
import mchorse.vanilla_pack.actions.Fireball;
import mchorse.vanilla_pack.actions.Jump;
import mchorse.vanilla_pack.actions.Potions;
import mchorse.vanilla_pack.actions.ShulkerBullet;
import mchorse.vanilla_pack.actions.Sliverfish;
import mchorse.vanilla_pack.actions.SmallFireball;
import mchorse.vanilla_pack.actions.Snowball;
import mchorse.vanilla_pack.actions.Spit;
import mchorse.vanilla_pack.actions.Teleport;
import mchorse.vanilla_pack.attacks.KnockbackAttack;
import mchorse.vanilla_pack.attacks.MobAttack;
import mchorse.vanilla_pack.attacks.PoisonAttack;
import mchorse.vanilla_pack.attacks.WitherAttack;
import mchorse.vanilla_pack.editors.GuiBlockMorph;
import mchorse.vanilla_pack.editors.GuiEntityMorph;
import mchorse.vanilla_pack.editors.GuiItemMorph;
import mchorse.vanilla_pack.editors.GuiLabelMorph;
import mchorse.vanilla_pack.editors.GuiPlayerMorph;
import mchorse.vanilla_pack.morphs.BlockMorph;
import mchorse.vanilla_pack.morphs.IronGolemMorph;
import mchorse.vanilla_pack.morphs.ItemMorph;
import mchorse.vanilla_pack.morphs.LabelMorph;
import mchorse.vanilla_pack.morphs.PlayerMorph;
import mchorse.vanilla_pack.morphs.ShulkerMorph;
import mchorse.vanilla_pack.morphs.UndeadMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.registry.EntityEntry;
import net.minecraftforge.fml.common.registry.ForgeRegistries;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;
import java.util.Map;

/**
 * Metamorph factory
 * 
 * This is underlying morph factory. It's responsible for registering vanilla actions
 * and morph sections
 */
public class MetamorphFactory implements IMorphFactory
{
    /**
     * Nothing to register here, since all of the morphs are generated on 
     * runtime 
     */
    @Override
    public void register(MorphManager manager)
    {
        /* Define shortcuts */
        Map<String, IAbility> abilities = manager.abilities;
        Map<String, IAttackAbility> attacks = manager.attacks;
        Map<String, IAction> actions = manager.actions;

        /* Register default abilities */
        abilities.put("climb", new Climb());
        abilities.put("fire_proof", new FireProof());
        abilities.put("fly", new Fly());
        abilities.put("glide", new Glide());
        abilities.put("hungerless", new Hungerless());
        abilities.put("jumping", new Jumping());
        abilities.put("night_vision", new NightVision());
        abilities.put("prevent_fall", new PreventFall());
        abilities.put("rotten", new Rotten());
        abilities.put("snow_walk", new SnowWalk());
        abilities.put("step_up", new StepUp());
        abilities.put("sun_allergy", new SunAllergy());
        abilities.put("swim", new Swim());
        abilities.put("water_allergy", new WaterAllergy());
        abilities.put("water_breath", new WaterBreath());

        /* Register default actions */
        actions.put("endermite", new Endermite());
        actions.put("explode", new Explode());
        actions.put("fireball", new Fireball());
        actions.put("fire_breath", new FireBreath());
        actions.put("jump", new Jump());
        actions.put("potions", new Potions());
        actions.put("shulker_bullet", new ShulkerBullet());
        actions.put("silverfish", new Sliverfish());
        actions.put("small_fireball", new SmallFireball());
        actions.put("snowball", new Snowball());
        actions.put("spit", new Spit());
        actions.put("teleport", new Teleport());

        /* Register default attacks */
        attacks.put("knockback", new KnockbackAttack());
        attacks.put("mob", new MobAttack());
        attacks.put("poison", new PoisonAttack());
        attacks.put("wither", new WitherAttack());

        /* Register main section */
        manager.list.register(new MetamorphSection(this, "entity"));
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void registerMorphEditors(Minecraft mc, List<GuiAbstractMorph> editors)
    {
        editors.add(new GuiLabelMorph(mc));
        editors.add(new GuiItemMorph(mc));
        editors.add(new GuiBlockMorph(mc));
        editors.add(new GuiPlayerMorph(mc));
        editors.add(new GuiEntityMorph(mc));
        editors.add(new GuiAbstractMorph(mc));
    }

    /**
     * Checks if the {@link EntityList} has an entity with given name does 
     * exist and the entity is a living base.
     */
    @Override
    public boolean hasMorph(String name)
    {
        if (name.equalsIgnoreCase("player"))
        {
            return true;
        }

        if (name.equals("block") || name.equals("item") || name.equals("label"))
        {
            return true;
        }

        Class<? extends Entity> clazz = null;
        ResourceLocation key = new ResourceLocation(name);

        for (EntityEntry entity : ForgeRegistries.ENTITIES)
        {
            if (entity.getRegistryName().equals(key))
            {
                clazz = entity.getEntityClass();
            }
        }

        return clazz == null ? false : EntityLivingBase.class.isAssignableFrom(clazz);
    }

    /**
     * Create an {@link EntityMorph} from NBT
     */
    @Override
    public AbstractMorph getMorphFromNBT(NBTTagCompound tag)
    {
        String name = tag.getString("Name");
        AbstractMorph morph;

        if (tag.getString("Name").equalsIgnoreCase("player"))
        {
            PlayerMorph player = new PlayerMorph();

            player.fromNBT(tag);

            return player.profile != null ? player : null;
        }

        if (name.equals("block"))
        {
            morph = new BlockMorph();
        }
        else if (name.equals("item"))
        {
            morph = new ItemMorph();
        }
        else if (name.equals("label"))
        {
            morph = new LabelMorph();
        }
        else
        {
            morph = morphFromName(name);
        }

        morph.fromNBT(tag);

        return morph;
    }

    /**
     * Get a morph from a name 
     */
    public EntityMorph morphFromName(String name)
    {
        if (name.equals("minecraft:zombie") || name.equals("minecraft:skeleton") || name.equals("minecraft:zombie_villager"))
        {
            return new UndeadMorph();
        }
        else if (name.equals("minecraft:villager_golem"))
        {
            return new IronGolemMorph();
        }
        else if (name.equals("minecraft:shulker"))
        {
            return new ShulkerMorph();
        }

        return new EntityMorph();
    }
}


==================================================

--- Файл №127 ---
Путь: main\java\mchorse\vanilla_pack\MetamorphSection.java
--------------------
package mchorse.vanilla_pack;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.EntityUtils;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.vanilla_pack.morphs.BlockMorph;
import mchorse.vanilla_pack.morphs.ItemMorph;
import mchorse.vanilla_pack.morphs.LabelMorph;
import mchorse.vanilla_pack.morphs.PlayerMorph;
import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.boss.EntityDragon;
import net.minecraft.entity.boss.EntityWither;
import net.minecraft.entity.monster.EntityGiantZombie;
import net.minecraft.entity.monster.EntityMob;
import net.minecraft.entity.passive.EntityAnimal;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.World;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class MetamorphSection extends MorphSection
{
    private MetamorphFactory factory;
    private Map<String, MorphCategory> categoryMap = new HashMap<String, MorphCategory>();

    public MetamorphSection(MetamorphFactory factory, String title)
    {
        super(title);

        this.factory = factory;
    }

    @Override
    public void update(World world)
    {
        boolean full = !this.categories.isEmpty();
        boolean loading = Metamorph.loadEntityMorphs.get();

        if (full || !loading)
        {
            if (full && !loading)
            {
                this.reset();
            }

            return;
        }

        for (ResourceLocation rl : EntityList.getEntityNameList())
        {
            String name = MorphManager.INSTANCE.remap(rl.toString());

            if (this.factory.hasMorph(name))
            {
                this.addMorph(world, name);
            }
        }

        /* Miscellaneous morphs */
        PlayerMorph notch = new PlayerMorph();
        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Name", "player");
        tag.setString("Username", "Notch");
        notch.fromNBT(tag);

        this.get("generic").add(new BlockMorph());
        this.get("generic").add(new ItemMorph());
        this.get("generic").add(new LabelMorph());
        this.get("generic").add(notch);

        /* Add categories to the main list */
        Iterator<MorphCategory> it = this.categoryMap.values().iterator();

        while (it.hasNext())
        {
            if (it.next().getMorphs().isEmpty())
            {
                it.remove();
            }
        }

        this.categories.addAll(this.categoryMap.values());
        this.categoryMap.clear();

        for (MorphCategory category : this.categories)
        {
            category.sort();
        }
    }

    /**
     * Add an entity morph to the morph list
     */
    private void addMorph(World world, String name)
    {
        try
        {
            EntityMorph morph = this.factory.morphFromName(name);
            EntityLivingBase entity = (EntityLivingBase) EntityList.createEntityByIDFromName(new ResourceLocation(name), world);

            if (entity == null)
            {
                System.out.println("Couldn't add morph " + name + ", because it's null!");
                return;
            }

            NBTTagCompound data = entity.serializeNBT();

            morph.name = name;

            /* Setting up a category */
            String category = "generic";

            /* Category for third-party modded mobs */
            if (!name.startsWith("minecraft:"))
            {
                category = name.substring(0, name.indexOf(":"));
            }
            else if (entity instanceof EntityDragon || entity instanceof EntityWither || entity instanceof EntityGiantZombie)
            {
                category = "boss";
            }
            else if (entity instanceof EntityAnimal || name.equals("minecraft:bat") || name.equals("minecraft:squid"))
            {
                category = "animal";
            }
            else if (entity instanceof EntityMob || name.equals("minecraft:ghast") || name.equals("minecraft:magma_cube") || name.equals("minecraft:slime") || name.equals("minecraft:shulker"))
            {
                category = "hostile";
            }

            EntityUtils.stripEntityNBT(data);
            morph.setEntityData(data);

            this.get(category).add(morph);
        }
        catch (Exception e)
        {
            System.out.println("An error occured during insertion of " + name + " morph!");
            e.printStackTrace();
        }
    }

    /**
     * Get a temporary category
     */
    private MorphCategory get(String name)
    {
        MorphCategory cat = this.categoryMap.get(name);

        if (cat == null)
        {
            this.categoryMap.put(name, cat = new MorphCategory(this, name));
        }

        return cat;
    }

    @Override
    public void reset()
    {
        this.categories.clear();
    }
}

==================================================

--- Файл №128 ---
Путь: main\java\mchorse\vanilla_pack\package-info.java
--------------------
/**
 * Vanilla (and not only) default morph pack
 * 
 * This package is responsible for providing with abilities, actions and 
 * attacks for default vanilla morphs, and also patches to some of the entities 
 * to make them look much cooler.
 * 
 * It's a lot of work to make all those entities look cool. 
 */
package mchorse.vanilla_pack;

==================================================

--- Файл №129 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Climb.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;

/**
 * Climbing ability
 * 
 * This ability makes player climb on the wall. Don't add this ability to the 
 * any other mobs except Spiders, otherwise player will turn into Spider man.
 */
public class Climb extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        /* Works properly only on client side :( */
        if (target.collidedHorizontally)
        {
            target.motionY = target.isSneaking() ? 0 : 0.2D;
        }

        /* Fucking server doesn't handles climbing properly, that's why I 
         * have to reset fall distance in order to save player lifes */
        target.fallDistance = 0.0F;
    }
}

==================================================

--- Файл №130 ---
Путь: main\java\mchorse\vanilla_pack\abilities\FireProof.java
--------------------
package mchorse.vanilla_pack.abilities;

import net.minecraft.init.MobEffects;

/**
 * Fire proof ability
 * 
 * This abilitiy grants you fire immunity. So basically you're fire proof.
 */
public class FireProof extends PotionAbility
{
    public FireProof()
    {
        this.potion = MobEffects.FIRE_RESISTANCE;
    }
}

==================================================

--- Файл №131 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Fly.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;

/**
 * Fly ability
 * 
 * Allows player to fly as in creative. Mostly used by flying (captain) morphs. 
 */
public class Fly extends Ability
{
    @Override
    public void onMorph(EntityLivingBase target)
    {
        if (target instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) target;

            if (!player.capabilities.allowFlying)
            {
                player.capabilities.allowFlying = true;
                player.sendPlayerAbilities();
            }
        }
    }

    @Override
    public void update(EntityLivingBase target)
    {
        this.onMorph(target);
    }

    @Override
    public void onDemorph(EntityLivingBase target)
    {
        if (target instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) target;

            if (!player.isCreative())
            {
                player.capabilities.allowFlying = false;
                player.capabilities.isFlying = false;
                player.sendPlayerAbilities();
            }
        }
    }
}

==================================================

--- Файл №132 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Glide.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;

/**
 * Glide ability
 * 
 * This ability makes player fall much slower. Sneak to disable gliding effect.
 */
public class Glide extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        boolean isFlying = target instanceof EntityPlayer && ((EntityPlayer) target).capabilities.isFlying;

        if (!target.onGround && target.motionY < 0.0D && !isFlying && !target.isElytraFlying() && !target.isSneaking())
        {
            target.motionY *= 0.6D;
            target.fallDistance = 0.0F;
        }
    }
}

==================================================

--- Файл №133 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Hungerless.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.MobEffects;

/**
 * Hungerless ability
 * 
 * This ability is responsible for removing hunger potion effect from given 
 * morph. Really good for zombies, since they're the only one who're going 
 * to use them.
 */
public class Hungerless extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        if (target.isPotionActive(MobEffects.HUNGER))
        {
            this.onMorph(target);
        }
    }

    @Override
    public void onMorph(EntityLivingBase target)
    {
        target.removePotionEffect(MobEffects.HUNGER);
    }
}

==================================================

--- Файл №134 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Jumping.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;

/**
 * Jumping ability
 * 
 * Makes player jump whenever he moves and on the ground. Just like a slime!
 */
public class Jumping extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        boolean moving = target.moveStrafing != 0 || target.moveForward != 0;

        if (target.onGround && moving && !target.isInWater())
        {
            target.motionY += 0.5D;
        }
    }
}


==================================================

--- Файл №135 ---
Путь: main\java\mchorse\vanilla_pack\abilities\NightVision.java
--------------------
package mchorse.vanilla_pack.abilities;

import net.minecraft.init.MobEffects;

/**
 * Night vision ability
 * 
 * Grants night vision effect for given morph. Mostly used by bat.
 */
public class NightVision extends PotionAbility
{
    public NightVision()
    {
        this.potion = MobEffects.NIGHT_VISION;
    }
}

==================================================

--- Файл №136 ---
Путь: main\java\mchorse\vanilla_pack\abilities\PotionAbility.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.potion.Potion;
import net.minecraft.potion.PotionEffect;

/**
 * Abstract potion ability
 * 
 * This is class is responsible for adding specific given potion effect from 
 * subclasses. You can also give the duration for the potion effect. 
 */
public abstract class PotionAbility extends Ability
{
    protected Potion potion;
    protected int duration = 1200;

    @Override
    public void update(EntityLivingBase target)
    {
        PotionEffect effect = target.getActivePotionEffect(this.potion);

        if (effect == null || effect.getDuration() < 300)
        {
            this.onDemorph(target);
            this.onMorph(target);
        }
    }

    @Override
    public void onMorph(EntityLivingBase target)
    {
        target.addPotionEffect(new PotionEffect(this.potion, this.duration, 0, false, false));
    }

    @Override
    public void onDemorph(EntityLivingBase target)
    {
        target.removePotionEffect(this.potion);
    }
}

==================================================

--- Файл №137 ---
Путь: main\java\mchorse\vanilla_pack\abilities\PreventFall.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;

/**
 * Prevent fall damage ability
 * 
 * This ability is responsible for prevent the fall damage, and it is doing it 
 * by modifying player's "fallDistance" field and setting it (or rather reseting) 
 * to 0.0F.
 */
public class PreventFall extends Ability
{
    @Override
    public void update(EntityLivingBase player)
    {
        player.fallDistance = 0.0F;
    }
}

==================================================

--- Файл №138 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Rotten.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.MobEffects;

/**
 * Rotten ability
 * 
 * Prevents a character from being posion.
 * Mostly used for undead.
 */
public class Rotten extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        if (target.isPotionActive(MobEffects.POISON))
        {
            this.onMorph(target);
        }
    }

    @Override
    public void onMorph(EntityLivingBase target)
    {
        target.removePotionEffect(MobEffects.POISON);
    }
}

==================================================

--- Файл №139 ---
Путь: main\java\mchorse\vanilla_pack\abilities\SnowWalk.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.block.material.Material;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.monster.EntitySnowman;
import net.minecraft.init.Blocks;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;

/**
 * Snow walk ability
 * 
 * This ability grants player snowy walk. This ability is really cool and 
 * probably only will be used for snow man morph.
 * 
 * Totally not taken from {@link EntitySnowman#onLivingUpdate()}.
 */
public class SnowWalk extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        if (!target.onGround)
        {
            return;
        }

        int i = MathHelper.floor(target.posX);
        int j = MathHelper.floor(target.posY);
        int k = MathHelper.floor(target.posZ);

        BlockPos blockpos = new BlockPos(i, j, k);

        if (target.world.getBlockState(blockpos).getMaterial() == Material.AIR && Blocks.SNOW_LAYER.canPlaceBlockAt(target.world, blockpos))
        {
            target.world.setBlockState(blockpos, Blocks.SNOW_LAYER.getDefaultState());
        }
    }
}

==================================================

--- Файл №140 ---
Путь: main\java\mchorse\vanilla_pack\abilities\StepUp.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;

/**
 * Step Up ability
 * 
 * This ability makes player walk up blocks, like a horse.
 */
public class StepUp extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        target.stepHeight = 1.0f;
    }
    
    @Override
    public void onMorph(EntityLivingBase target)
    {
        target.stepHeight = 1.0f;
    }
    
    @Override
    public void onDemorph(EntityLivingBase target)
    {
        target.stepHeight = 0.6f;
    }
}

==================================================

--- Файл №141 ---
Путь: main\java\mchorse\vanilla_pack\abilities\SunAllergy.java
--------------------
package mchorse.vanilla_pack.abilities;

import java.util.Random;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.util.math.BlockPos.MutableBlockPos;

/**
 * Sun allergy ability 
 * 
 * This abilitiy does cool stuff. It sets player on fire when he's on the sun. 
 * It will be used by the coolest mobs in the game skeleton and zombie.
 * 
 * This is more like a disability than an ability *Ba-dum-pam-dum-tsss*
 */
public class SunAllergy extends Ability
{
    private MutableBlockPos pos = new MutableBlockPos(0, 0, 0);
    private Random random = new Random();

    @Override
    public void update(EntityLivingBase target)
    {
        if (!target.world.isDaytime() || target.world.isRemote)
        {
            return;
        }

        float brightness = target.getBrightness();
        boolean random = this.random.nextFloat() * 30.0F < (brightness - 0.4F) * 2.0F;
        this.pos.setPos(target.posX, target.posY + target.getEyeHeight(), target.posZ);

        /* Taken from EntityZombie class and slightly modified */
        if (brightness > 0.5 && random && target.world.canSeeSky(pos))
        {
            boolean flag = true;
            ItemStack itemstack = target.getItemStackFromSlot(EntityEquipmentSlot.HEAD);

            /* If target has a head slot on the head, then damage it */
            if (!itemstack.isEmpty())
            {
                boolean isCreativePlayer = target instanceof EntityPlayer && ((EntityPlayer) target).isCreative();

                /* Unless it's damagable or creative player wears it */
                if (itemstack.isItemStackDamageable() && !isCreativePlayer)
                {
                    itemstack.setItemDamage(itemstack.getItemDamage() + this.random.nextInt(2));

                    if (itemstack.getItemDamage() >= itemstack.getMaxDamage())
                    {
                        target.renderBrokenItemStack(itemstack);
                        target.setItemStackToSlot(EntityEquipmentSlot.HEAD, ItemStack.EMPTY);
                    }
                }

                flag = false;
            }

            if (flag)
            {
                target.setFire(8);
            }
        }
    }
}

==================================================

--- Файл №142 ---
Путь: main\java\mchorse\vanilla_pack\abilities\Swim.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.math.MathHelper;

/**
 * Swim ability
 * 
 * This ability makes player a better swimmer. What it does, it basically 
 * increases the swim speed and also gives player more control over vertical 
 * movement. 
 */
public class Swim extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        updateMotion(target);
    }
    
    private void updateMotion(EntityLivingBase target)
    {
        double speed = 0.35;

        if (target.isInWater())
        {
            if (target.moveForward != 0 || target.moveStrafing != 0)
            {
                float a = target.rotationYaw / 180 * (float) Math.PI;

                float f1 = MathHelper.sin(a);
                float f2 = MathHelper.cos(a);

                target.motionX = (double) (target.moveStrafing * f2 - target.moveForward * f1) * speed;
                target.motionZ = (double) (target.moveForward * f2 + target.moveStrafing * f1) * speed;
                target.motionY = -MathHelper.sin((float) (target.rotationPitch / 180 * Math.PI)) * target.moveForward * speed;
            }
            else
            {
                target.motionX *= 0.6;
                target.motionY *= 0.6;

                if (target.motionY < 0)
                {
                    target.motionY = 0;
                }
            }
        }
    }
}

==================================================

--- Файл №143 ---
Путь: main\java\mchorse\vanilla_pack\abilities\WaterAllergy.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.DamageSource;

/**
 * Water allergy ability
 * 
 * This ability is responsible for damaging the player when he is in the water 
 * primarily will be used in Enderman's morph.
 * 
 * This is more like a disability than an ability *Ba-dum-pam-dum-tsss*
 */
public class WaterAllergy extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        if (target.isWet())
        {
            target.attackEntityFrom(DamageSource.DROWN, 1.0F);
        }
    }
}

==================================================

--- Файл №144 ---
Путь: main\java\mchorse\vanilla_pack\abilities\WaterBreath.java
--------------------
package mchorse.vanilla_pack.abilities;

import mchorse.metamorph.api.abilities.Ability;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.DamageSource;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Water breath ability
 * 
 * This ability grants its owner ability to stay in water and refill its air. 
 */
public class WaterBreath extends Ability
{
    @Override
    public void update(EntityLivingBase target)
    {
        updateAir(target);
    }

    private void updateAir(EntityLivingBase target)
    {
        if (target instanceof EntityPlayer)
        {
            IMorphing morphing = Morphing.get((EntityPlayer) target);

            if (morphing != null)
            {
                if (target.isInWater())
                {
                    morphing.setSquidAir(300);
                    target.setAir(300);
                }
                else
                {
                    int air = morphing.getSquidAir() - 1;

                    if (air <= -20)
                    {
                        air = 0;
                        target.attackEntityFrom(DamageSource.DROWN, 2.0F);
                    }

                    morphing.setSquidAir(air);
                }
            }
        }
    }

    /**
     * On morph, show squid air
     */
    @Override
    public void onMorph(EntityLivingBase target)
    {
        IMorphing morphing = Morphing.get((EntityPlayer) target);

        if (morphing != null)
        {
            morphing.setSquidAir(target.getAir());
            morphing.setHasSquidAir(true);
        }
    }

    /**
     * On demorph, show regular player air again
     */
    @Override
    public void onDemorph(EntityLivingBase target)
    {
        IMorphing morphing = Morphing.get((EntityPlayer) target);

        if (morphing != null)
        {
            target.setAir(morphing.getSquidAir());
            morphing.setHasSquidAir(false);
        }
    }
}

==================================================

--- Файл №145 ---
Путь: main\java\mchorse\vanilla_pack\actions\Endermite.java
--------------------
package mchorse.vanilla_pack.actions;

import java.util.Random;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.SoundEvents;

/**
 * Endermite action
 * 
 * Teleports player to a random location nearby.
 */
public class Endermite implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        Random rand = target.getRNG();

        /* Teleports within 32 block radius */
        double x = target.posX + (rand.nextDouble() - 0.5D) * 64.0D;
        double y = target.posY + (double) (rand.nextInt(64) - 32);
        double z = target.posZ + (rand.nextDouble() - 0.5D) * 64.0D;

        if (target.attemptTeleport(x, y, z))
        {
            target.playSound(SoundEvents.ENTITY_ENDERMEN_TELEPORT, 1.0F, 1.0F);
            target.world.playSound((EntityPlayer) null, target.prevPosX, target.prevPosY, target.prevPosZ, SoundEvents.ENTITY_ENDERMEN_TELEPORT, target.getSoundCategory(), 1.0F, 1.0F);
        }
    }
}

==================================================

--- Файл №146 ---
Путь: main\java\mchorse\vanilla_pack\actions\Explode.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.monster.EntityCreeper;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.DamageSource;
import net.minecraftforge.fml.relauncher.ReflectionHelper;

/**
 * Explode action
 * 
 * This action makes an explosion and also kills the player. Why kill also the 
 * player? Because it won't be so creeper if he won't die. 
 * 
 * EXPLOSIONS!!! Mr. Torgue approves this action. 
 */
public class Explode implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        if (target.world.isRemote)
        {
            return;
        }
        
        int explosionPower = 3;
        boolean isPowered = false;
        
        if (morph instanceof EntityMorph)
        {
            EntityLivingBase entity = ((EntityMorph) morph).getEntity();

            if (entity instanceof EntityCreeper)
            {
                explosionPower = ReflectionHelper.getPrivateValue(EntityCreeper.class, (EntityCreeper) entity, "explosionRadius", "field_82226_g");
                isPowered = ((EntityCreeper) entity).getPowered();
            }
        }

        float f = isPowered ? 2.0F : 1.0F;
        target.world.createExplosion(target, target.posX, target.posY, target.posZ, explosionPower * f, true);

        if (!(target instanceof EntityPlayer) || (target instanceof EntityPlayer && !((EntityPlayer) target).isCreative()))
        {
            target.attackEntityFrom(DamageSource.OUT_OF_WORLD, target.getMaxHealth());
        }
    }
}

==================================================

--- Файл №147 ---
Путь: main\java\mchorse\vanilla_pack\actions\Fireball.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntityLargeFireball;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;

/**
 * Fireball action
 * 
 * This action is responsible for shooting a fireball from player's face. Used 
 * by ghast morph.
 */
public class Fireball implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        World world = target.world;

        if (world.isRemote)
        {
            return;
        }

        if (target instanceof EntityPlayer && ((EntityPlayer) target).getCooledAttackStrength(0.0F) < 1)
        {
            return;
        }

        Vec3d vec3d = target.getLook(1.0F);

        double d1 = 4.0D;
        double d2 = vec3d.x * d1;
        double d3 = vec3d.y * d1;
        double d4 = vec3d.z * d1;

        world.playEvent((EntityPlayer) null, 1016, new BlockPos(target), 0);

        EntityLargeFireball fireball = new EntityLargeFireball(world, target, d2, d3, d4);

        fireball.explosionPower = 1;
        fireball.posX = target.posX;
        fireball.posY = target.posY + target.height * 0.9;
        fireball.posZ = target.posZ;

        world.spawnEntity(fireball);

        if (target instanceof EntityPlayer)
        {
            ((EntityPlayer) target).resetCooldown();
        }
    }
}

==================================================

--- Файл №148 ---
Путь: main\java\mchorse\vanilla_pack\actions\FireBreath.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntityDragonFireball;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

/**
 * Ender dragon's fire breath 
 */
public class FireBreath implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        if (target.world.isRemote)
        {
            return;
        }

        if (target instanceof EntityPlayer && ((EntityPlayer) target).getCooledAttackStrength(0.0F) < 1)
        {
            return;
        }

        Vec3d vec3d = target.getLook(1.0F);

        double d1 = 4.0D;
        double d2 = vec3d.x * d1;
        double d3 = vec3d.y * d1;
        double d4 = vec3d.z * d1;

        target.world.playEvent((EntityPlayer) null, 1017, new BlockPos(target), 0);

        EntityDragonFireball fireball = new EntityDragonFireball(target.world, target, d2, d3, d4);

        fireball.posX = target.posX + d2 / d1;
        fireball.posY = target.posY + target.height * 0.9;
        fireball.posZ = target.posZ + d4 / d1;

        target.world.spawnEntity(fireball);

        if (target instanceof EntityPlayer)
        {
            ((EntityPlayer) target).resetCooldown();
        }
    }
}

==================================================

--- Файл №149 ---
Путь: main\java\mchorse\vanilla_pack\actions\Jump.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;

/**
 * Jump action
 * 
 * Makes player jump very high like a <s>horse</s> rabbit. The strength of 
 * this jump is about 3 blocks high. 
 */
public class Jump implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        if (target.onGround && !target.isWet())
        {
            target.motionX *= 4.0;
            target.motionY = 0.75;
            target.motionZ *= 4.0;
        }
    }
}

==================================================

--- Файл №150 ---
Путь: main\java\mchorse\vanilla_pack\actions\Potions.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.monster.EntityWitch;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntityPotion;
import net.minecraft.init.Items;
import net.minecraft.init.PotionTypes;
import net.minecraft.item.ItemStack;
import net.minecraft.potion.PotionType;
import net.minecraft.potion.PotionUtils;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;

/**
 * Potions action
 * 
 * This action is responsible for throwing a splash potion in the direction 
 * where player looks.
 * 
 * This action may throw instant harm, slowness, weakness or poison splash 
 * potions depending on randomness, but most of the time it'll be instant harm 
 * potion.
 * 
 * Of course, some of the code of this action was taken fron 
 * {@link EntityWitch}.
 */
public class Potions implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        World world = target.world;

        if (world.isRemote)
        {
            return;
        }

        if (target instanceof EntityPlayer && ((EntityPlayer) target).getCooledAttackStrength(0.0F) < 1)
        {
            return;
        }

        Vec3d look = target.getLook(1.0F);
        PotionType effect = PotionTypes.HARMING;

        if (target.getRNG().nextFloat() < 0.2)
        {
            effect = PotionTypes.SLOWNESS;
        }
        else if (target.getRNG().nextFloat() < 0.1)
        {
            effect = PotionTypes.WEAKNESS;
        }
        else if (target.getRNG().nextFloat() < 0.05)
        {
            effect = PotionTypes.POISON;
        }

        ItemStack stack = PotionUtils.addPotionToItemStack(new ItemStack(Items.SPLASH_POTION), effect);
        EntityPotion potion = new EntityPotion(world, target, stack);

        potion.rotationPitch += 20.0F;
        potion.shoot(look.x, look.y, look.z, 0.85F, 2.0F);

        world.spawnEntity(potion);

        if (target instanceof EntityPlayer)
        {
            ((EntityPlayer) target).resetCooldown();
        }
    }
}

==================================================

--- Файл №151 ---
Путь: main\java\mchorse\vanilla_pack\actions\ShulkerBullet.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.EntityUtils;
import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntityShulkerBullet;
import net.minecraft.init.SoundEvents;
import net.minecraft.util.EnumFacing.Axis;
import net.minecraft.world.World;

public class ShulkerBullet implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        World world = target.world;

        if (world.isRemote)
        {
            return;
        }

        if (target instanceof EntityPlayer && ((EntityPlayer) target).getCooledAttackStrength(0.0F) < 1)
        {
            return;
        }

        Entity toShoot = EntityUtils.getTargetEntity(target, 32);

        if (toShoot != null)
        {
            target.playSound(SoundEvents.ENTITY_SHULKER_SHOOT, 2.0F, (target.getRNG().nextFloat() - target.getRNG().nextFloat()) * 0.2F + 1.0F);

            EntityShulkerBullet fireball = new EntityShulkerBullet(world, target, toShoot, Axis.Z);

            fireball.posX = target.posX;
            fireball.posZ = target.posZ;

            world.spawnEntity(fireball);
        }

        if (target instanceof EntityPlayer)
        {
            ((EntityPlayer) target).resetCooldown();
        }
    }
}

==================================================

--- Файл №152 ---
Путь: main\java\mchorse\vanilla_pack\actions\Sliverfish.java
--------------------
package mchorse.vanilla_pack.actions;

import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.vanilla_pack.morphs.BlockMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.RayTraceResult.Type;
import net.minecraft.util.math.Vec3d;

/**
 * Silverfish action
 * 
 * Turns silverfish into immovable block at which it was looking
 */
public class Sliverfish implements IAction
{
    @Override
    public void execute(EntityLivingBase target, AbstractMorph morph)
    {
        if (target.world.isRemote)
        {
            return;
        }

        float reachDistance = 5;

        Vec3d pos = new Vec3d(target.posX, target.posY + target.getEyeHeight(), target.posZ);
        Vec3d look = target.getLook(1.0F);
        Vec3d vec = pos.addVector(look.x * reachDistance, look.y * reachDistance, look.z * reachDistance);

        RayTraceResult result = target.world.rayTraceBlocks(pos, vec, false, false, true);

        if (result != null && result.typeOfHit == Type.BLOCK && target instanceof EntityPlayer)
        {
            BlockMorph block = new BlockMorph();

            block.blockPos = result.getBlockPos();
            block.block = target.world.getBlockState(block.blockPos);
            block.name = "metamorph.Block";

            target.world.setBlockToAir(block.blockPos);

            MorphAPI.morph((EntityPlayer) target, block, true);
        }
    }
}

==================================================

--- Файл №153 ---
Путь: main\java\mchorse\vanilla_pack\actions\SmallFireball.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntitySmallFireball;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;

/**
 * Small fireball action
 * 
 * This action is responsible for shooting a fireball from player's face. Used 
 * by blaze morph.
 */
public class SmallFireball implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        World world = target.world;

        if (world.isRemote)
        {
            return;
        }

        if (target instanceof EntityPlayer && ((EntityPlayer) target).getCooledAttackStrength(0.0F) < 1)
        {
            return;
        }

        Vec3d vec3d = target.getLook(1.0F);

        double d1 = 4.0D;
        double d2 = vec3d.x * d1;
        double d3 = vec3d.y * d1;
        double d4 = vec3d.z * d1;

        world.playEvent((EntityPlayer) null, 1016, new BlockPos(target), 0);

        EntitySmallFireball fireball = new EntitySmallFireball(world, target, d2, d3, d4);

        fireball.posX = target.posX;
        fireball.posY = target.posY + target.height * 0.9;
        fireball.posZ = target.posZ;

        world.spawnEntity(fireball);

        if (target instanceof EntityPlayer)
        {
            ((EntityPlayer) target).resetCooldown();
        }
    }
}

==================================================

--- Файл №154 ---
Путь: main\java\mchorse\vanilla_pack\actions\Snowball.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.monster.EntitySnowman;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntitySnowball;
import net.minecraft.init.SoundEvents;
import net.minecraft.util.math.Vec3d;

/**
 * Snowball action
 * 
 * Throws a snowball in the look direction of the player. The code is taken 
 * from {@link Fireball#execute(EntityPlayer)} and 
 * {@link EntitySnowman#attackEntityWithRangedAttack(net.minecraft.entity.EntityLivingBase, float)}
 */
public class Snowball implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        if (!target.world.isRemote)
        {
            EntitySnowball snowball = new EntitySnowball(target.world, target);
            Vec3d vec3d = target.getLook(1.0F);

            double d1 = 4.0D;
            double d2 = vec3d.x * d1;
            double d3 = vec3d.y * d1;
            double d4 = vec3d.z * d1;

            snowball.setPosition(target.posX, target.posY + target.height * 0.9F, target.posZ);
            snowball.motionX = d2;
            snowball.motionY = d3;
            snowball.motionZ = d4;

            target.playSound(SoundEvents.ENTITY_SNOWMAN_SHOOT, 1.0F, 1.0F / (target.getRNG().nextFloat() * 0.4F + 0.8F));
            target.world.spawnEntity(snowball);
        }
    }
}

==================================================

--- Файл №155 ---
Путь: main\java\mchorse\vanilla_pack\actions\Spit.java
--------------------
package mchorse.vanilla_pack.actions;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.passive.EntityLlama;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.projectile.EntityLlamaSpit;
import net.minecraft.init.SoundEvents;
import net.minecraft.util.math.Vec3d;

public class Spit implements IAction
{
    @Override
    public void execute(EntityLivingBase target, AbstractMorph morph)
    {
        if (target.world.isRemote)
        {
            return;
        }

        EntityLlamaSpit spit = new EntityLlamaSpit(target.world);

        Vec3d vec3d = target.getLook(1.0F);

        double d1 = 4.0D;
        double d2 = vec3d.x;
        double d3 = vec3d.y;
        double d4 = vec3d.z;

        spit.setPosition(target.posX + d2 * 1.5, target.posY + target.height * 0.8F, target.posZ + d4 * 1.5);
        spit.shoot(d2, d3, d4, (float) 1.0F, 1.0F);

        if (morph instanceof EntityMorph)
        {
            EntityLivingBase entity = ((EntityMorph) morph).getEntity();

            if (entity instanceof EntityLlama)
            {
                spit.owner = (EntityLlama) entity;
            }
        }

        target.world.playSound((EntityPlayer) null, target.posX, target.posY, target.posZ, SoundEvents.ENTITY_LLAMA_SPIT, target.getSoundCategory(), 1.0F, 1.0F + (target.getRNG().nextFloat() - target.getRNG().nextFloat()) * 0.2F);
        target.world.spawnEntity(spit);
    }
}

==================================================

--- Файл №156 ---
Путь: main\java\mchorse\vanilla_pack\actions\Teleport.java
--------------------
package mchorse.vanilla_pack.actions;

import javax.annotation.Nullable;

import mchorse.metamorph.api.abilities.IAction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.SoundEvents;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.RayTraceResult.Type;
import net.minecraft.util.math.Vec3d;

/**
 * Teleport action
 * 
 * This action will teleport given player there where he's looking.
 * 
 * If the point where player is about to teleport have a block above, it will 
 * teleport player beside the block. Optionally, you can sneak to teleport 
 * beside the block.
 * 
 * Teleport action also has cooldown and limited distance to teleport in 
 * radius of 32 blocks.
 */
public class Teleport implements IAction
{
    @Override
    public void execute(EntityLivingBase target, @Nullable AbstractMorph morph)
    {
        float reachDistance = 32;

        Vec3d pos = new Vec3d(target.posX, target.posY + target.getEyeHeight(), target.posZ);
        Vec3d look = target.getLook(1.0F);
        Vec3d vec = pos.addVector(look.x * reachDistance, look.y * reachDistance, look.z * reachDistance);

        RayTraceResult result = target.world.rayTraceBlocks(pos, vec, false, false, true);

        if (result != null && result.typeOfHit == Type.BLOCK)
        {
            BlockPos block = result.getBlockPos();

            if (target instanceof EntityPlayer && ((EntityPlayer) target).getCooledAttackStrength(0.0F) < 1)
            {
                return;
            }

            if (target.isSneaking() || !target.world.getBlockState(block.offset(EnumFacing.UP)).getBlock().equals(Blocks.AIR))
            {
                block = block.offset(result.sideHit);
            }

            double x = block.getX() + 0.5F;
            double y = block.getY() + 1.0F;
            double z = block.getZ() + 0.5F;

            target.world.playSound(null, target.prevPosX, target.prevPosY, target.prevPosZ, SoundEvents.ENTITY_ENDERMEN_TELEPORT, SoundCategory.HOSTILE, 1.0F, 1.0F);
            target.setPositionAndUpdate(x, y, z);

            if (target instanceof EntityPlayer)
            {
                ((EntityPlayer) target).resetCooldown();
            }

            target.world.playSound(null, target.posX, target.posY, target.posZ, SoundEvents.ENTITY_ENDERMEN_TELEPORT, SoundCategory.HOSTILE, 1.0F, 1.0F);
        }
    }
}

==================================================

--- Файл №157 ---
Путь: main\java\mchorse\vanilla_pack\attacks\KnockbackAttack.java
--------------------
package mchorse.vanilla_pack.attacks;

import mchorse.metamorph.api.MorphHandler;
import mchorse.metamorph.api.abilities.IAttackAbility;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.math.Vec3d;

/**
 * Knock back attack
 * 
 * This makes the entity go up in the air. Really cool!
 */
public class KnockbackAttack implements IAttackAbility
{
    @Override
    public void attack(final Entity target, EntityLivingBase source)
    {
        final Vec3d look = source.getLook(1.0F);
        final double d = 1;

        Runnable task = new Runnable()
        {
            @Override
            public void run()
            {
                target.motionX = look.x * d;
                target.motionY = 1;
                target.motionZ = look.z * d;
            }
        };

        if (!source.world.isRemote)
        {
            MorphHandler.FUTURE_TASKS_SERVER.add(task);
        }
        else
        {
            MorphHandler.FUTURE_TASKS_CLIENT.add(task);
        }
    }
}

==================================================

--- Файл №158 ---
Путь: main\java\mchorse\vanilla_pack\attacks\MobAttack.java
--------------------
package mchorse.vanilla_pack.attacks;

import mchorse.metamorph.api.abilities.IAttackAbility;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import net.minecraft.entity.player.EntityPlayer;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;

/**
 * Mob attack ability
 * 
 * This ability uses the mob's attack when the player attacks.
 * Both attacks will go through, taking the highest damage between
 * the player and the mob, and triggering any special effects the
 * mob does on attack.
 */
public class MobAttack implements IAttackAbility
{
    @Override
    public void attack(Entity target, EntityLivingBase source)
    {
        if (source instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) source;
            IMorphing capability = Morphing.get(player);
            if(capability == null)
                return;
            AbstractMorph currentMorph = capability.getCurrentMorph();
            if(currentMorph == null)
                return;
            if(currentMorph instanceof EntityMorph)
            {
                EntityMorph currentEntityMorph = (EntityMorph) currentMorph;
                currentEntityMorph.getEntity(source.world).attackEntityAsMob(target);
            }
        }
    }
}


==================================================

--- Файл №159 ---
Путь: main\java\mchorse\vanilla_pack\attacks\PoisonAttack.java
--------------------
package mchorse.vanilla_pack.attacks;

import mchorse.metamorph.api.abilities.IAttackAbility;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.MobEffects;
import net.minecraft.potion.PotionEffect;

/**
 * Poison attack
 * 
 * This attack poisons the target. Used by cave spider morph in the main mod.
 */
public class PoisonAttack implements IAttackAbility
{
    @Override
    public void attack(Entity target, EntityLivingBase source)
    {
        if (target instanceof EntityLivingBase)
        {
            ((EntityLivingBase) target).addPotionEffect(new PotionEffect(MobEffects.POISON, 200));
        }
    }
}

==================================================

--- Файл №160 ---
Путь: main\java\mchorse\vanilla_pack\attacks\WitherAttack.java
--------------------
package mchorse.vanilla_pack.attacks;

import mchorse.metamorph.api.abilities.IAttackAbility;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.MobEffects;
import net.minecraft.potion.PotionEffect;

/**
 * Wither attack ability
 * 
 * This ability simple adds on a target wither effect
 */
public class WitherAttack implements IAttackAbility
{
    @Override
    public void attack(Entity target, EntityLivingBase source)
    {
        if (target instanceof EntityLivingBase)
        {
            ((EntityLivingBase) target).addPotionEffect(new PotionEffect(MobEffects.WITHER, 200));
        }
    }
}

==================================================

--- Файл №161 ---
Путь: main\java\mchorse\vanilla_pack\editors\GuiBlockMorph.java
--------------------
package mchorse.vanilla_pack.editors;

import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.vanilla_pack.editors.panels.GuiItemStackPanel;
import mchorse.vanilla_pack.morphs.BlockMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;

@SideOnly(Side.CLIENT)
public class GuiBlockMorph extends GuiAbstractMorph<BlockMorph>
{
    public GuiItemStackPanel block;

    public GuiBlockMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.block = new GuiItemStackPanel(mc, this);
        this.registerPanel(this.block, IKey.lang("metamorph.gui.panels.block"), Icons.BLOCK);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof BlockMorph;
    }

    @Override
    public List<Label<NBTTagCompound>> getPresets(BlockMorph morph)
    {
        List<Label<NBTTagCompound>> presets = new ArrayList<Label<NBTTagCompound>>();

        this.addPreset(morph, presets, "Stone", "{Block:\"minecraft:stone\"}");
        this.addPreset(morph, presets, "Cobblestone", "{Block:\"minecraft:cobblestone\"}");
        this.addPreset(morph, presets, "Grass", "{Block:\"minecraft:grass\"}");
        this.addPreset(morph, presets, "Dirt", "{Block:\"minecraft:dirt\"}");
        this.addPreset(morph, presets, "Log", "{Block:\"minecraft:log\"}");
        this.addPreset(morph, presets, "Diamond block", "{Block:\"minecraft:diamond_block\"}");
        this.addPreset(morph, presets, "Sponge", "{Block:\"minecraft:sponge\"}");
        this.addPreset(morph, presets, "Deadbush", "{Block:\"minecraft:deadbush\"}");

        return presets;
    }
}

==================================================

--- Файл №162 ---
Путь: main\java\mchorse\vanilla_pack\editors\GuiEntityMorph.java
--------------------
package mchorse.vanilla_pack.editors;

import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.bodypart.GuiBodyPartEditor;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.vanilla_pack.editors.panels.GuiEntityPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

@SideOnly(Side.CLIENT)
public class GuiEntityMorph extends GuiAbstractMorph<EntityMorph>
{
    public static final List<String> animals = Arrays.asList("minecraft:pig", "minecraft:chicken", "minecraft:cow", "minecraft:mooshroom", "minecraft:polar_bear", "minecraft:sheep", "minecraft:ocelot");

    public GuiEntityPanel entityPanel;
    public GuiBodyPartEditor bodyPart;

    public GuiEntityMorph(Minecraft mc)
    {
        super(mc);

        this.bodyPart = new GuiBodyPartEditor(mc, this);
        this.entityPanel = new GuiEntityPanel(mc, this);

        this.registerPanel(this.bodyPart, IKey.lang("metamorph.gui.body_parts.parts"), Icons.LIMB);
        this.registerPanel(this.entityPanel, IKey.lang("metamorph.gui.editor.entity"), Icons.POSE);
        this.defaultPanel = this.entityPanel;
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof EntityMorph;
    }

    @Override
    public void startEdit(EntityMorph morph)
    {
        if (morph.getEntity() == null)
        {
            morph.setupEntity(this.mc.world);
        }

        morph.parts.reinitBodyParts();
        morph.setupLimbs();
        this.bodyPart.setLimbs(morph.limbs.keySet());

        super.startEdit(morph);
    }

    @Override
    public List<Label<NBTTagCompound>> getPresets(EntityMorph morph)
    {
        List<Label<NBTTagCompound>> presets = new ArrayList<Label<NBTTagCompound>>();
        String name = morph.name;

        if (animals.contains(name))
        {
            this.addPreset(morph, presets, "Baby", "{Age:-1}");
        }

        if (name.equals("minecraft:sheep"))
        {
            this.addPreset(morph, presets, "Sheared", "{Sheared:1b}");
            this.addPreset(morph, presets, "Sheared (baby)", "{Age:-1,Sheared:1b}");

            for (int i = 1; i < 16; i++)
            {
                this.addPreset(morph, presets, "Colored sheep #" + i, "{Color:" + i + "}");
            }

            this.addPreset(morph, presets, "Jeb", "{CustomName:\"jeb_\"}");
            this.addPreset(morph, presets, "Baby Jeb", "{Age:-1,CustomName:\"jeb_\"}");
        }

        if (name.equals("minecraft:slime") || name.equals("minecraft:magma_cube"))
        {
            this.addPreset(morph, presets, "Medium", "{Size:1}");
            this.addPreset(morph, presets, "Big", "{Size:2}");
        }

        if (name.equals("minecraft:ocelot"))
        {
            for (int i = 1; i < 4; i++)
            {
                this.addPreset(morph, presets, "Cat #" + i, "{CatType:" + i + "}");
                this.addPreset(morph, presets, "Cat #" + i + " (baby)", "{CatType:" + i + ",Age:-1}");
            }
        }

        if (name.equals("minecraft:parrot"))
        {
            for (int i = 1; i <= 4; i++)
            {
                this.addPreset(morph, presets, "Parrot #" + i, "{Variant:" + i + "}");
            }
        }

        if (name.equals("minecraft:horse"))
        {
            for (int i = 1; i <= 6; i++)
            {
                this.addPreset(morph, presets, "Horse #" + i, "{Variant:" + i + "}");
            }
        }

        if (name.equals("minecraft:llama"))
        {
            for (int i = 1; i < 4; i++)
            {
                this.addPreset(morph, presets, "Llama #" + i, "{Variant:" + i + "}");
            }
        }

        if (name.equals("minecraft:bat"))
        {
            this.addPreset(morph, presets, "Flying", "{BatFlags:2}");
        }

        if (name.equals("minecraft:rabbit"))
        {
            for (int i = 1; i < 6; i++)
            {
                this.addPreset(morph, presets, "Rabbit #" + i, "{RabbitType:" + i + "}");
            }

            this.addPreset(morph, presets, "Toast", "{CustomName:\"Toast\"}");
        }

        if (name.equals("minecraft:zombie"))
        {
            this.addPreset(morph, presets, "Baby", "{IsBaby:1b}");
        }

        if (name.equals("minecraft:villager") || name.equals("minecraft:zombie_villager"))
        {
            this.addPreset(morph, presets, "Librarian", "{ProfessionName:\"minecraft:librarian\"}");
            this.addPreset(morph, presets, "Priest", "{ProfessionName:\"minecraft:priest\"}");
            this.addPreset(morph, presets, "Smith", "{ProfessionName:\"minecraft:smith\"}");
            this.addPreset(morph, presets, "Butcher", "{ProfessionName:\"minecraft:butcher\"}");
            this.addPreset(morph, presets, "Nitwit", "{ProfessionName:\"minecraft:nitwit\"}");
        }

        return presets;
    }

    @Override
    protected void addPreset(AbstractMorph morph, List<Label<NBTTagCompound>> list, String label, String json)
    {
        try
        {
            NBTTagCompound tag = morph.toNBT();
            NBTTagCompound entity = new NBTTagCompound();

            tag.removeTag("EntityData");
            entity.setTag("EntityData", JsonToNBT.getTagFromJson(json));
            tag.merge(entity);
            list.add(new Label<NBTTagCompound>(IKey.str(label), tag));
        }
        catch (Exception e)
        {}
    }
}

==================================================

--- Файл №163 ---
Путь: main\java\mchorse\vanilla_pack\editors\GuiItemMorph.java
--------------------
package mchorse.vanilla_pack.editors;

import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.util.MMIcons;
import mchorse.vanilla_pack.editors.panels.GuiItemPanel;
import mchorse.vanilla_pack.morphs.ItemMorph;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiItemMorph extends GuiAbstractMorph<ItemMorph>
{
    public GuiItemPanel item;

    public GuiItemMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.item = new GuiItemPanel(mc, this);
        this.registerPanel(this.item, IKey.lang("metamorph.gui.editor.item_morph"), MMIcons.ITEM);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof ItemMorph;
    }
}

==================================================

--- Файл №164 ---
Путь: main\java\mchorse\vanilla_pack\editors\GuiLabelMorph.java
--------------------
package mchorse.vanilla_pack.editors;

import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.util.MMIcons;
import mchorse.vanilla_pack.editors.panels.GuiLabelPanel;
import mchorse.vanilla_pack.morphs.LabelMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;

public class GuiLabelMorph extends GuiAbstractMorph<LabelMorph>
{
    public GuiLabelPanel label;

    public GuiLabelMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.label = new GuiLabelPanel(mc, this);
        this.registerPanel(this.label, IKey.lang("metamorph.gui.label.label"), MMIcons.LABEL);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof LabelMorph;
    }
}

==================================================

--- Файл №165 ---
Путь: main\java\mchorse\vanilla_pack\editors\GuiPlayerMorph.java
--------------------
package mchorse.vanilla_pack.editors;

import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.util.MMIcons;
import mchorse.vanilla_pack.editors.panels.GuiUsernamePanel;
import mchorse.vanilla_pack.morphs.PlayerMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiPlayerMorph extends GuiAbstractMorph<PlayerMorph>
{
    public GuiUsernamePanel username;

    public GuiPlayerMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.username = new GuiUsernamePanel(mc, this);
        this.registerPanel(this.username, IKey.lang("metamorph.gui.panels.username"), MMIcons.USER);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof PlayerMorph;
    }
}

==================================================

--- Файл №166 ---
Путь: main\java\mchorse\vanilla_pack\editors\panels\GuiEntityPanel.java
--------------------
package mchorse.vanilla_pack.editors.panels;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import mchorse.vanilla_pack.editors.GuiEntityMorph;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiEntityPanel extends GuiMorphPanel<EntityMorph, GuiEntityMorph>
{
    public GuiButtonElement texture;
    public GuiTrackpadElement scale;
    public GuiTexturePicker picker;

    public GuiEntityPanel(Minecraft mc, GuiEntityMorph editor)
    {
        super(mc, editor);

        GuiElement element = new GuiElement(mc);

        element.flex().relative(this).y(1F).w(130).anchor(0, 1F).column(4).vertical().stretch().padding(10);

        this.scale = new GuiTrackpadElement(mc, (v) -> this.morph.scale = v.floatValue());
        this.texture = new GuiButtonElement(mc, IKey.lang("metamorph.gui.editor.texture"), (b) ->
        {
            this.picker.refresh();
            this.picker.fill(this.morph.userTexture);
            this.add(this.picker);
            this.picker.resize();
        });
        this.texture.tooltip(IKey.lang("metamorph.gui.editor.texture_tooltip"), Direction.TOP);
        this.picker = new GuiTexturePicker(mc, (rl) -> this.morph.userTexture = RLUtils.clone(rl));
        this.picker.flex().relative(this).wh(1F, 1F);

        element.add(this.texture);
        element.add(Elements.label(IKey.lang("metamorph.gui.editor.scale")).marginTop(12), this.scale);
        this.add(element);
    }

    @Override
    public void fillData(EntityMorph morph)
    {
        super.fillData(morph);

        this.scale.setValue(morph.scale);
    }
}

==================================================

--- Файл №167 ---
Путь: main\java\mchorse\vanilla_pack\editors\panels\GuiItemPanel.java
--------------------
package mchorse.vanilla_pack.editors.panels;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import mchorse.vanilla_pack.morphs.ItemMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiItemPanel extends GuiMorphPanel<ItemMorph, GuiAbstractMorph<? extends ItemMorph>>
{
    public GuiSlotElement slot;

    public GuiToggleElement lighting;
    public GuiCirculateElement transform;
    public GuiButtonElement texture;
    public GuiToggleElement animation;
    public GuiToggleElement itemFromEquipment;
    public GuiCirculateElement equipmentSlot;

    public GuiTexturePicker picker;

    public GuiItemPanel(Minecraft mc, GuiAbstractMorph<? extends ItemMorph> editor)
    {
        super(mc, editor);

        this.slot = new GuiSlotElement(mc, 0, (stack) -> this.morph.setStack(stack));
        this.lighting = new GuiToggleElement(mc, IKey.lang("metamorph.gui.label.lighting"), (b) -> this.morph.lighting = b.isToggled());
        this.transform = new GuiCirculateElement(mc, (b) ->
        {
            ItemCameraTransforms.TransformType type = ItemCameraTransforms.TransformType.values()[b.getValue()];

            this.morph.transform = ItemMorph.getTransformTypes().inverse().get(type);
        });
        this.animation = new GuiToggleElement(mc, IKey.lang("metamorph.gui.item.animation"), (b) -> this.morph.animation = b.isToggled());
        this.itemFromEquipment = new GuiToggleElement(mc, IKey.lang("metamorph.gui.item.item_from_equipment"), (b) -> this.morph.itemFromEquipment = b.isToggled());
        this.equipmentSlot = new GuiCirculateElement(mc, (b) -> this.morph.equipmentSlot = EntityEquipmentSlot.values()[b.getValue()]);

        this.slot.flex().relative(this).x(0.5F, 0).y(1, -10).wh(32, 32).anchor(0.5F, 1);

        for (ItemCameraTransforms.TransformType transform : ItemCameraTransforms.TransformType.values())
        {
            String key = ItemMorph.getTransformTypes().inverse().get(transform);

            this.transform.addLabel(IKey.lang("metamorph.gui.item.transform." + key));
        }

        for (EntityEquipmentSlot slot : EntityEquipmentSlot.values())
        {
            this.equipmentSlot.addLabel(IKey.lang("metamorph.gui.item.equipment_slot." + slot.getName()));
        }

        this.texture = new GuiButtonElement(mc, IKey.lang("metamorph.gui.editor.texture"), (b) ->
        {
            this.picker.refresh();
            this.picker.fill(this.morph.texture);
            this.add(this.picker);
            this.picker.resize();
        });
        this.picker = new GuiTexturePicker(mc, (rl) -> this.morph.texture = RLUtils.clone(rl));
        this.picker.flex().relative(this).wh(1F, 1F);

        GuiElement column = Elements.column(mc, 5, this.lighting, this.transform, this.texture, this.animation, this.itemFromEquipment.marginTop(12), this.equipmentSlot);

        column.flex().relative(this).xy(10, 10).w(110);

        this.add(this.slot, column);
    }

    @Override
    public void fillData(ItemMorph morph)
    {
        super.fillData(morph);

        ItemCameraTransforms.TransformType type = morph.getTransformType();

        this.slot.setStack(morph.getStack());
        this.lighting.toggled(morph.lighting);
        this.transform.setValue(type.ordinal());
        this.animation.toggled(morph.animation);
        this.itemFromEquipment.toggled(morph.itemFromEquipment);
        this.equipmentSlot.setValue(morph.equipmentSlot.ordinal());
    }
}

==================================================

--- Файл №168 ---
Путь: main\java\mchorse\vanilla_pack\editors\panels\GuiItemStackPanel.java
--------------------
package mchorse.vanilla_pack.editors.panels;

import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import mchorse.vanilla_pack.morphs.ItemStackMorph;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiItemStackPanel extends GuiMorphPanel<ItemStackMorph, GuiAbstractMorph<? extends ItemStackMorph>>
{
    public GuiSlotElement slot;
    public GuiToggleElement lighting;

    public GuiItemStackPanel(Minecraft mc, GuiAbstractMorph<? extends ItemStackMorph> editor)
    {
        super(mc, editor);

        this.slot = new GuiSlotElement(mc, 0, (stack) -> this.morph.setStack(stack));
        this.lighting = new GuiToggleElement(mc, IKey.lang("metamorph.gui.label.lighting"), (b) -> this.morph.lighting = b.isToggled());

        this.slot.flex().relative(this).x(0.5F, 0).y(1, -10).wh(32, 32).anchor(0.5F, 1);
        this.lighting.flex().relative(this).xy(10, 10).w(110);

        this.add(this.slot, this.lighting);
    }

    @Override
    public void fillData(ItemStackMorph morph)
    {
        super.fillData(morph);

        this.slot.setStack(morph.getStack());
        this.lighting.toggled(morph.lighting);
    }
}

==================================================

--- Файл №169 ---
Путь: main\java\mchorse\vanilla_pack\editors\panels\GuiLabelPanel.java
--------------------
package mchorse.vanilla_pack.editors.panels;

import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import mchorse.vanilla_pack.editors.GuiLabelMorph;
import mchorse.vanilla_pack.morphs.LabelMorph;
import net.minecraft.client.Minecraft;

public class GuiLabelPanel extends GuiMorphPanel<LabelMorph, GuiLabelMorph>
{
    public GuiScrollElement element;

    public GuiTextElement label;
    public GuiTrackpadElement max;
    public GuiTrackpadElement anchorX;
    public GuiTrackpadElement anchorY;
    public GuiColorElement color;
    public GuiToggleElement lighting;

    public GuiToggleElement shadow;
    public GuiTrackpadElement shadowX;
    public GuiTrackpadElement shadowY;
    public GuiColorElement shadowColor;

    public GuiColorElement background;
    public GuiTrackpadElement offset;

    public GuiToggleElement billboard;

    public GuiLabelPanel(Minecraft mc, GuiLabelMorph editor)
    {
        super(mc, editor);

        this.label = new GuiTextElement(mc, 10000, (label) -> this.morph.label = label);
        this.max = new GuiTrackpadElement(mc, (value) -> this.morph.max = value.intValue());
        this.max.limit(-1, Integer.MAX_VALUE, true).increment(10);
        this.anchorX = new GuiTrackpadElement(mc, (value) -> this.morph.anchorX = value.floatValue());
        this.anchorX.values(0.01F);
        this.anchorY = new GuiTrackpadElement(mc, (value) -> this.morph.anchorY = value.floatValue());
        this.anchorY.values(0.01F);
        this.color = new GuiColorElement(mc, (value) -> this.morph.color = value);
        this.lighting = new GuiToggleElement(mc, IKey.lang("metamorph.gui.label.lighting"), (button) -> this.morph.lighting = button.isToggled());
        this.lighting.tooltip(IKey.lang("metamorph.gui.label.lighting_tooltip"));

        this.shadow = new GuiToggleElement(mc, IKey.lang("metamorph.gui.label.shadow"), (button) -> this.morph.shadow = button.isToggled());
        this.shadowX = new GuiTrackpadElement(mc, (value) -> this.morph.shadowX = value.floatValue());
        this.shadowX.limit(-100, 100).values(0.1F, 0.01F, 0.5F).increment(0.1F);
        this.shadowY = new GuiTrackpadElement(mc, (value) -> this.morph.shadowY = value.floatValue());
        this.shadowY.limit(-100, 100).values(0.1F, 0.01F, 0.5F).increment(0.1F);
        this.shadowColor = new GuiColorElement(mc, (value) -> this.morph.shadowColor = value);

        this.background = new GuiColorElement(mc, (value) -> this.morph.background = value);
        this.background.picker.editAlpha();
        this.offset = new GuiTrackpadElement(mc, (value) -> this.morph.offset = value.floatValue());

        this.billboard = new GuiToggleElement(mc, IKey.lang("metamorph.gui.label.billboard"), (b) -> this.morph.billboard = b.isToggled());

        this.element = new GuiScrollElement(mc);
        this.element.scroll.opposite = true;
        this.element.flex().relative(this).w(120).h(1F).column(5).vertical().stretch().scroll().height(20).padding(10);

        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.label")).marginTop(8), this.label);
        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.max_width")).marginTop(8), this.max);
        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.anchor")).marginTop(8), this.anchorX, this.anchorY);
        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.color")).marginTop(8), this.color, this.lighting);

        this.element.add(this.shadow);
        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.shadow_offset")).marginTop(8), this.shadowX, this.shadowY);
        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.shadow_color")).marginTop(8), this.shadowColor);

        this.element.add(Elements.label(IKey.lang("metamorph.gui.label.background")).marginTop(8), this.background, this.offset);
        this.element.add(this.billboard.marginTop(8));

        this.add(this.element);
    }

    @Override
    public void fillData(LabelMorph morph)
    {
        super.fillData(morph);

        this.label.setText(morph.label);
        this.max.setValue(morph.max);
        this.anchorX.setValue(morph.anchorX);
        this.anchorY.setValue(morph.anchorY);
        this.color.picker.setColor(morph.color);
        this.lighting.toggled(morph.lighting);

        this.shadow.toggled(morph.shadow);
        this.shadowX.setValue(morph.shadowX);
        this.shadowY.setValue(morph.shadowY);
        this.shadowColor.picker.setColor(morph.shadowColor);

        this.background.picker.setColor(morph.background);
        this.offset.setValue(morph.offset);
        this.billboard.toggled(morph.billboard);
    }
}

==================================================

--- Файл №170 ---
Путь: main\java\mchorse\vanilla_pack\editors\panels\GuiUsernamePanel.java
--------------------
package mchorse.vanilla_pack.editors.panels;

import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import mchorse.vanilla_pack.editors.GuiPlayerMorph;
import mchorse.vanilla_pack.morphs.PlayerMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Username morph panel allows editing username of the player morph 
 */
@SideOnly(Side.CLIENT)
@SuppressWarnings("rawtypes")
public class GuiUsernamePanel extends GuiMorphPanel<PlayerMorph, GuiPlayerMorph>
{
    public GuiTextElement username;
    private int counter = -1;

    public GuiUsernamePanel(Minecraft mc, GuiPlayerMorph editor)
    {
        super(mc, editor);

        this.username = new GuiTextElement(mc, 120, (str) -> this.editUsername(str));
        this.username.flex().relative(this).set(10, 10, 0, 20).w(1, -20).y(1, -30);

        this.add(this.username);
    }

    private void editUsername(String str)
    {
        if (str.isEmpty())
        {
            return;
        }

        this.counter = 15;
    }

    @Override
    public void fillData(PlayerMorph morph)
    {
        super.fillData(morph);

        this.username.setText(morph.profile.getName());
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.counter >= 0)
        {
            if (this.counter == 0 && !this.username.field.getText().isEmpty())
            {
                PlayerMorph morph = this.morph;

                morph.resetEntity();
                morph.setProfile(this.username.field.getText());
            }

            String updating = I18n.format("metamorph.gui.panels.updating");
            int w = this.font.getStringWidth(updating);

            this.font.drawStringWithShadow(updating, this.username.area.ex() - w, this.username.area.y - 12, 0xaaaaaa);
            this.counter--;
        }

        super.draw(context);

        if (this.username.isVisible())
        {
            this.font.drawStringWithShadow(I18n.format("metamorph.gui.panels.username"), this.username.area.x, this.username.area.y - 12, 0xffffff);
        }
    }
}

==================================================

--- Файл №171 ---
Путь: main\java\mchorse\vanilla_pack\morphs\BlockMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import com.google.common.base.Objects;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BlockRendererDispatcher;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.registry.ForgeRegistries;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Block morph
 * 
 * This morph allows players to disguise themselves as blocks.
 */
public class BlockMorph extends ItemStackMorph
{
    /**
     * Block state to render, doesn't really mean anything on the server 
     * side. Used for rendering 
     */
    public IBlockState block = Blocks.STONE.getDefaultState();

    /**
     * Block position to lock the target in
     */
    public BlockPos blockPos;

    /**
     * Set the name 
     */
    public BlockMorph()
    {
        this.name = "block";
    }

    @Override
    public void setStack(ItemStack stack)
    {
        if (stack.getItem() instanceof ItemBlock)
        {
            this.block = ((ItemBlock) stack.getItem()).getBlock().getStateFromMeta(stack.getItemDamage());
        }
    }

    @Override
    public ItemStack getStack()
    {
        return new ItemStack(this.block.getBlock(), 1, this.block.getBlock().getMetaFromState(this.block));
    }

    /**
     * Render in GUIs just like any other entity, 45 degree rotate  by 
     * X and Y. 
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        Minecraft mc = Minecraft.getMinecraft();

        GlStateManager.enableDepth();
        BlockRendererDispatcher blockrendererdispatcher = mc.getBlockRendererDispatcher();
        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, 0);
        GlStateManager.scale((-scale), -scale, -scale);
        GlStateManager.rotate(45.0F, -1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(45.0F, 0.0F, 1.0F, 0.0F);
        GlStateManager.translate(0, 1, 0);

        mc.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
        blockrendererdispatcher.renderBlockBrightness(this.block, 1.0F);
        GlStateManager.popMatrix();
        GlStateManager.disableDepth();
    }

    /**
     * Render the block morph on player's position
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        Minecraft mc = Minecraft.getMinecraft();

        float lastBrightnessX = OpenGlHelper.lastBrightnessX;
        float lastBrightnessY = OpenGlHelper.lastBrightnessY;

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, 240);
        }

        GlStateManager.enableCull();
        GlStateManager.enableRescaleNormal();
        BlockRendererDispatcher blockrendererdispatcher = mc.getBlockRendererDispatcher();
        GlStateManager.pushMatrix();
        GlStateManager.translate((float) x, (float) y + 0.5F, (float) z);

        mc.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
        GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
        GlStateManager.translate(-0.5F, -0.5F, 0.5F);
        blockrendererdispatcher.renderBlockBrightness(this.block, 1.0F);
        GlStateManager.translate(0.0F, 0.0F, 1.0F);
        GlStateManager.popMatrix();
        GlStateManager.disableRescaleNormal();
        GlStateManager.disableCull();

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastBrightnessX, lastBrightnessY);
        }
    }

    /**
     * Update the entity
     * 
     * This particular morph sets the AABB to almost 1 (so it would be 
     * easy enough to slip into 1x1 block area, and also so other players 
     * won't see the AABB when debug AABB is enabled).
     * 
     * This method as well locks the character in block position if 
     * it has the block position.
     */
    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        if (this.blockPos != null)
        {
            target.motionX = target.motionY = target.motionZ = 0;
            target.setPosition(this.blockPos.getX() + 0.5, this.blockPos.getY(), this.blockPos.getZ() + 0.5);
        }

        this.updateSize(target, getWidth(target), getHeight(target));
    }

    @Override
    public AbstractMorph create()
    {
        return new BlockMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof BlockMorph)
        {
            BlockMorph morph = (BlockMorph) from;

            this.block = morph.block;
            this.blockPos = morph.blockPos;
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof BlockMorph)
        {
            BlockMorph morph = (BlockMorph) obj;

            result = result && Objects.equal(morph.block, this.block);
            result = result && Objects.equal(morph.blockPos, this.blockPos);
        }

        return result;
    }

    @Override
    @SuppressWarnings(value = {"deprecation"})
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Block"))
        {
            Block block = ForgeRegistries.BLOCKS.getValue(new ResourceLocation(tag.getString("Block")));

            if (block != null)
            {
                this.block = tag.hasKey("Meta") ? block.getStateFromMeta(tag.getByte("Meta")) : block.getDefaultState();
            }
        }

        if (tag.hasKey("Pos"))
        {
            int[] pos = tag.getIntArray("Pos");

            if (pos.length == 3)
            {
                this.blockPos = new BlockPos(pos[0], pos[1], pos[2]);
            }
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.block != null)
        {
            tag.setString("Block", ForgeRegistries.BLOCKS.getKey(this.block.getBlock()).toString());
            tag.setByte("Meta", (byte) this.block.getBlock().getMetaFromState(this.block));
        }

        if (this.blockPos != null)
        {
            tag.setIntArray("Pos", new int[] {this.blockPos.getX(), this.blockPos.getY(), this.blockPos.getZ()});
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return 0.99F;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return 0.99F;
    }
}

==================================================

--- Файл №172 ---
Путь: main\java\mchorse\vanilla_pack\morphs\IronGolemMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;

/**
 * Iron golem morph
 * 
 * This morph is responsible for making IronGolem morph great again! This morph 
 * is very powerful. I should make him much slower.
 */
public class IronGolemMorph extends EntityMorph
{
    @Override
    public void update(EntityLivingBase target)
    {
        if (target.motionY > 0)
        {
            target.motionY *= 0.9;
        }
        else
        {
            target.motionX *= 0.5;
            target.motionZ *= 0.5;

            target.motionY *= 1.3;
        }

        target.motionX *= 0.5;
        target.motionZ *= 0.5;

        super.update(target);
    }

    @Override
    public AbstractMorph create()
    {
        return new IronGolemMorph();
    }
}


==================================================

--- Файл №173 ---
Путь: main\java\mchorse\vanilla_pack\morphs\ItemMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.utils.GuiInventoryElement;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.vanilla_pack.render.CachedExtrusion;
import mchorse.vanilla_pack.render.ItemExtruder;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.RenderItem;
import net.minecraft.client.renderer.block.model.IBakedModel;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.client.ForgeHooksClient;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Objects;

public class ItemMorph extends ItemStackMorph
{
    @SideOnly(Side.CLIENT)
    private static BiMap<String, ItemCameraTransforms.TransformType> transformTypes;

    public ItemStack stack = new ItemStack(Items.DIAMOND_HOE, 1);
    public String transform = "";
    public ResourceLocation texture;
    public boolean animation;
    public boolean itemFromEquipment;
    public EntityEquipmentSlot equipmentSlot = EntityEquipmentSlot.MAINHAND;

    @SideOnly(Side.CLIENT)
    public static BiMap<String, ItemCameraTransforms.TransformType> getTransformTypes()
    {
        if (transformTypes == null)
        {
            transformTypes = HashBiMap.create();

            transformTypes.put("none", ItemCameraTransforms.TransformType.NONE);
            transformTypes.put("third_person_left_hand", ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND);
            transformTypes.put("third_person_right_hand", ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND);
            transformTypes.put("first_person_left_hand", ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND);
            transformTypes.put("first_person_right_hand", ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND);
            transformTypes.put("head", ItemCameraTransforms.TransformType.HEAD);
            transformTypes.put("gui", ItemCameraTransforms.TransformType.GUI);
            transformTypes.put("ground", ItemCameraTransforms.TransformType.GROUND);
            transformTypes.put("fixed", ItemCameraTransforms.TransformType.FIXED);
        }

        return transformTypes;
    }

    public ItemMorph()
    {
        this.name = "item";
    }

    @SideOnly(Side.CLIENT)
    private ItemStack getStackForRender(EntityLivingBase entity)
    {
        if (this.itemFromEquipment)
        {
            if (GuiModelRenderer.isRendering())
            {
                entity = Minecraft.getMinecraft().player;
            }

            return entity.getItemStackFromSlot(this.equipmentSlot);
        }

        return this.stack;
    }

    @Override
    public void setStack(ItemStack stack)
    {
        this.stack = stack;
    }

    @Override
    public ItemStack getStack()
    {
        return this.stack;
    }

    @SideOnly(Side.CLIENT)
    public ItemCameraTransforms.TransformType getTransformType()
    {
        if (this.transform == null || this.transform.isEmpty())
        {
            return ItemCameraTransforms.TransformType.NONE;
        }
        
        ItemCameraTransforms.TransformType transformType = getTransformTypes().get(this.transform);

        return transformType == null ? ItemCameraTransforms.TransformType.NONE : transformType;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        GlStateManager.disableCull();
        GlStateManager.enableDepth();
        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240.0F, 240.0F);

        scale = scale / 16F;

        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y - 12, 0);

        if (this.texture != null)
        {
            GlStateManager.color(1, 1, 1);
            GlStateManager.scale(scale * 16F, -scale * 16F, scale * 16F);

            CachedExtrusion extrusion = ItemExtruder.extrude(this.texture);

            if (extrusion != null)
            {
                extrusion.render();
            }
        }
        else
        {
            GlStateManager.scale(scale, scale, scale);

            RenderHelper.enableGUIStandardItemLighting();

            GuiInventoryElement.drawItemStack(this.stack, -8, -8, 0, null);

            RenderHelper.disableStandardItemLighting();
        }

        GlStateManager.popMatrix();
        GlStateManager.enableCull();
        GlStateManager.disableDepth();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        float lastBrightnessX = OpenGlHelper.lastBrightnessX;
        float lastBrightnessY = OpenGlHelper.lastBrightnessY;

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, 240);
        }

        GlStateManager.enableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, z);

        Minecraft.getMinecraft().renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
        RenderItem render = Minecraft.getMinecraft().getRenderItem();
        ItemStack stack = this.getStackForRender(entity);
        IBakedModel model = render.getItemModelWithOverrides(stack, entity.world, entity);

        ItemCameraTransforms.TransformType transform = this.getTransformType();

        if (transform != ItemCameraTransforms.TransformType.NONE)
        {
            model = ForgeHooksClient.handleCameraTransforms(model, transform, false);
        }

        if (this.animation)
        {
            long ticks = entity.world.getTotalWorldTime();
            float bobbing = MathHelper.sin((ticks + partialTicks) / 10F) * 0.1F + 0.1F;

            GlStateManager.translate(0F, bobbing, 0F);
            GlStateManager.rotate((entity.ticksExisted + partialTicks) * 2F, 0F, 1F, 0F);
        }

        if (this.texture != null)
        {
            CachedExtrusion extrusion = ItemExtruder.extrude(this.texture);

            if (extrusion != null)
            {
                extrusion.render();
            }
        }
        else
        {
            render.renderItem(stack, model);
        }

        GlStateManager.popMatrix();

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastBrightnessX, lastBrightnessY);
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof ItemMorph)
        {
            ItemMorph item = (ItemMorph) obj;

            result = result && ItemStack.areItemStacksEqualUsingNBTShareTag(this.stack, item.stack);
            result = result && Objects.equals(this.transform, item.transform);
            result = result && Objects.equals(this.texture, item.texture);
            result = result && this.animation == item.animation;
            result = result && this.itemFromEquipment == item.itemFromEquipment;
            result = result && this.equipmentSlot == item.equipmentSlot;
        }

        return result;
    }

    @Override
    public AbstractMorph create()
    {
        return new ItemMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof ItemMorph)
        {
            ItemMorph item = (ItemMorph) from;

            this.stack = item.stack.copy();
            this.transform = item.transform;
            this.texture = item.texture;
            this.animation = item.animation;
            this.itemFromEquipment = item.itemFromEquipment;
            this.equipmentSlot = item.equipmentSlot;
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return target.width;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return target.height;
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (!this.stack.isEmpty())
        {
            tag.setTag("Stack", this.stack.serializeNBT());
        }

        tag.setString("Transform", this.transform);

        if (this.texture != null)
        {
            tag.setString("Texture", this.texture.toString());
        }

        if (this.animation)
        {
            tag.setBoolean("Animation", this.animation);
        }

        if (this.itemFromEquipment)
        {
            tag.setBoolean("ItemFromEquipment", this.itemFromEquipment);
        }

        if (this.equipmentSlot != EntityEquipmentSlot.MAINHAND)
        {
            tag.setString("EquipmentSlot", this.equipmentSlot.getName());
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Stack"))
        {
            this.stack = new ItemStack(tag.getCompoundTag("Stack"));
        }

        this.transform = tag.getString("Transform");

        if (tag.hasKey("Texture"))
        {
            this.texture = RLUtils.create(tag.getString("Texture"));
        }

        if (tag.hasKey("Animation"))
        {
            this.animation = tag.getBoolean("Animation");
        }

        if (tag.hasKey("ItemFromEquipment"))
        {
            this.itemFromEquipment = tag.getBoolean("ItemFromEquipment");
        }

        if (tag.hasKey("EquipmentSlot"))
        {
            this.equipmentSlot = EntityEquipmentSlot.fromString(tag.getString("EquipmentSlot"));
        }
    }
}


==================================================

--- Файл №174 ---
Путь: main\java\mchorse\vanilla_pack\morphs\ItemStackMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

public abstract class ItemStackMorph extends AbstractMorph
{
    public boolean lighting = true;

    public abstract void setStack(ItemStack stack);

    public abstract ItemStack getStack();

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof ItemStackMorph)
        {
            ItemStackMorph morph = (ItemStackMorph) obj;

            result = result && this.lighting == morph.lighting;
        }

        return result;
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof ItemStackMorph)
        {
            ItemStackMorph morph = (ItemStackMorph) from;

            this.lighting = morph.lighting;
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (!this.lighting)
        {
            tag.setBoolean("Lighting", this.lighting);
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Lighting"))
        {
            this.lighting = tag.getBoolean("Lighting");
        }
    }
}

==================================================

--- Файл №175 ---
Путь: main\java\mchorse\vanilla_pack\morphs\LabelMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.TextUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;
import java.util.List;
import java.util.Objects;

public class LabelMorph extends AbstractMorph
{
    public static final String DEFAULT_LABEL = "Lorem ipsum";
    public static final Matrix4f matrix = new Matrix4f();

    public String label = DEFAULT_LABEL;
    public int max = -1;
    public float anchorX = 0.5F;
    public float anchorY = 0.5F;
    public int color = 0xffffff;
    public boolean lighting = true;

    /* Shadow properties */
    public boolean shadow = false;
    public float shadowX = 1F;
    public float shadowY = 1F;
    public int shadowColor = 0;

    /* Background */
    public int background = 0x00000000;
    public float offset = 3;

    public boolean billboard;

    public LabelMorph()
    {
        this.name = "label";
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, 10);

        this.renderString();

        GlStateManager.popMatrix();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        /* Approximately 16 letters per block */
        double scale = 1D / 6D / 8D;

        float lastBrightnessX = OpenGlHelper.lastBrightnessX;
        float lastBrightnessY = OpenGlHelper.lastBrightnessY;

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, 240);
        }

        GlStateManager.disableLighting();
        GlStateManager.disableCull();
        GlStateManager.pushMatrix();

        GlStateManager.translate(x, y, z);
        GlStateManager.scale(scale, -scale, scale);

        if (this.billboard)
        {
            /* Get matrix */
            Matrix4f matrix4f = MatrixUtils.readModelView(matrix);
            Vector4f zero = new Vector4f(0, 0, 0, 1);

            matrix4f.transform(zero);
            matrix4f.setIdentity();
            matrix4f.setTranslation(new Vector3f(zero.x, zero.y, zero.z));
            matrix4f.transpose();

            MatrixUtils.loadModelView(matrix4f);
            GlStateManager.scale(-scale, scale, scale);

            GL11.glRotatef(180.0F, 0.0F, 1.0F, 0.0F);
            GL11.glRotatef(180.0F, 1.0F, 0.0F, 0.0F);
        }

        this.renderString();

        GlStateManager.popMatrix();
        GlStateManager.enableCull();
        GlStateManager.enableLighting();

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastBrightnessX, lastBrightnessY);
        }

    }

    @SideOnly(Side.CLIENT)
    private void renderString()
    {
        FontRenderer font = Minecraft.getMinecraft().fontRenderer;
        String text = TextUtils.processColoredText(this.label);

        if (this.max <= 0)
        {
            int w = font.getStringWidth(text);
            int x = -(int) (w * this.anchorX);
            int y = -(int) (font.FONT_HEIGHT * this.anchorY);

            this.drawShadow(x, y, w, font.FONT_HEIGHT);

            if (this.shadow)
            {
                GlStateManager.pushMatrix();
                GlStateManager.translate(this.shadowX, this.shadowY, -0.1F);
                font.drawString(text, x, y, this.shadowColor);
                GlStateManager.popMatrix();
            }

            font.drawString(text, x, y, this.color);
        }
        else
        {
            int min = 6;

            for (int i = 0; i < text.length(); i++)
            {
                min = Math.max(font.getCharWidth(text.charAt(i)), min);
            }
            
            int max = MathUtils.clamp(this.max, min, Integer.MAX_VALUE);
            List<String> labels = font.listFormattedStringToWidth(text, max);
            int h = MathUtils.clamp(labels.size() - 1, 0, 100) * 12 + font.FONT_HEIGHT;
            int y = -(int) (h * this.anchorY);

            this.drawShadow(-(int) (max * this.anchorX), y, max, h);

            if (this.shadow)
            {
                GlStateManager.pushMatrix();
                GlStateManager.translate(this.shadowX, this.shadowY, -0.1F);

                for (String label : labels)
                {
                    int w = font.getStringWidth(label);

                    font.drawString(label, -(int) (w * this.anchorX), y, this.shadowColor);
                    y += 12;
                }

                GlStateManager.popMatrix();
            }

            y = -(int) (h * this.anchorY);

            for (String label : labels)
            {
                int w = font.getStringWidth(label);

                font.drawString(label, -(int) (w * this.anchorX), y, this.color);
                y += 12;
            }
        }
    }

    @SideOnly(Side.CLIENT)
    private void drawShadow(int x, int y, int w, int h)
    {
        Color color = ColorUtils.COLOR.set(this.background, true);

        if (color.a <= 0)
        {
            return;
        }

        GlStateManager.disableTexture2D();
        GlStateManager.pushMatrix();
        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.translate(0, 0, -0.2F);

        BufferBuilder buffer = Tessellator.getInstance().getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(x + w + this.offset, y - this.offset, 0).color(color.r, color.g, color.b, color.a).endVertex();
        buffer.pos(x - this.offset, y - this.offset, 0).color(color.r, color.g, color.b, color.a).endVertex();
        buffer.pos(x - this.offset, y + h + this.offset, 0).color(color.r, color.g, color.b, color.a).endVertex();
        buffer.pos(x + w + this.offset, y + h + this.offset, 0).color(color.r, color.g, color.b, color.a).endVertex();

        Tessellator.getInstance().draw();

        GlStateManager.popMatrix();
        GlStateManager.enableTexture2D();
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof LabelMorph)
        {
            LabelMorph label = (LabelMorph) obj;

            result = result && Objects.equals(this.label, label.label);
            result = result && this.max == label.max;
            result = result && this.anchorX == label.anchorX;
            result = result && this.anchorY == label.anchorY;
            result = result && this.color == label.color;
            result = result && this.shadow == label.shadow;
            result = result && this.shadowX == label.shadowX;
            result = result && this.shadowY == label.shadowY;
            result = result && this.shadowColor == label.shadowColor;
            result = result && this.lighting == label.lighting;
            result = result && this.background == label.background;
            result = result && this.offset == label.offset;
            result = result && this.billboard == label.billboard;
        }

        return result;
    }

    @Override
    public AbstractMorph create()
    {
        return new LabelMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof LabelMorph)
        {
            LabelMorph label = (LabelMorph) from;

            this.label = label.label;
            this.max = label.max;
            this.anchorX = label.anchorX;
            this.anchorY = label.anchorY;
            this.color = label.color;
            this.shadow = label.shadow;
            this.shadowX = label.shadowX;
            this.shadowY = label.shadowY;
            this.shadowColor = label.shadowColor;
            this.lighting = label.lighting;
            this.background = label.background;
            this.offset = label.offset;
            this.billboard = label.billboard;
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return target.width;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return target.height;
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (!this.label.equals(DEFAULT_LABEL)) tag.setString("Label", this.label);
        if (this.max > 0) tag.setInteger("Max", this.max);
        if (this.anchorX != 0.5F) tag.setFloat("AnchorX", this.anchorX);
        if (this.anchorY != 0.5F) tag.setFloat("AnchorY", this.anchorY);
        if (this.color != 0xffffff) tag.setInteger("Color", this.color);
        if (this.shadow) tag.setBoolean("Shadow", this.shadow);
        if (this.shadowX != 1F) tag.setFloat("ShadowX", this.shadowX);
        if (this.shadowY != 1F) tag.setFloat("ShadowY", this.shadowY);
        if (this.shadowColor != 0) tag.setInteger("ShadowColor", this.shadowColor);
        if (!this.lighting) tag.setBoolean("Lighting", this.lighting);
        if (this.background != 0) tag.setInteger("Background", this.background);
        if (this.offset != 3) tag.setFloat("Offset", this.offset);
        if (this.billboard) tag.setBoolean("Billboard", this.billboard);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Label")) this.label = tag.getString("Label");
        if (tag.hasKey("Max")) this.max = tag.getInteger("Max");
        if (tag.hasKey("AnchorX")) this.anchorX = tag.getFloat("AnchorX");
        if (tag.hasKey("AnchorY")) this.anchorY = tag.getFloat("AnchorY");
        if (tag.hasKey("Color")) this.color = tag.getInteger("Color");
        if (tag.hasKey("Shadow")) this.shadow = tag.getBoolean("Shadow");
        if (tag.hasKey("ShadowX")) this.shadowX = tag.getFloat("ShadowX");
        if (tag.hasKey("ShadowY")) this.shadowY = tag.getFloat("ShadowY");
        if (tag.hasKey("ShadowColor")) this.shadowColor = tag.getInteger("ShadowColor");
        if (tag.hasKey("Lighting")) this.lighting = tag.getBoolean("Lighting");
        if (tag.hasKey("Background")) this.background = tag.getInteger("Background");
        if (tag.hasKey("Offset")) this.offset = tag.getFloat("Offset");
        if (tag.hasKey("Billboard")) this.billboard = tag.getBoolean("Billboard");
    }
}

==================================================

--- Файл №176 ---
Путь: main\java\mchorse\vanilla_pack\morphs\PlayerMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import com.mojang.authlib.GameProfile;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import net.minecraft.client.entity.EntityOtherPlayerMP;
import net.minecraft.client.network.NetworkPlayerInfo;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EnumPlayerModelParts;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTUtil;
import net.minecraft.tileentity.TileEntitySkull;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Player morph
 * 
 * This morph basically does nothing than providing some code for 
 * bootstrapping a player isolated in this morph.
 */
public class PlayerMorph extends EntityMorph
{
    /**
     * Player's profile 
     */
    public GameProfile profile;

    public PlayerMorph()
    {
        this.name = "player";
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return this.profile == null ? super.getSubclassDisplayName() : this.profile.getName();
    }

    public void setProfile(String username)
    {
        this.profile = new GameProfile(null, username);
        this.profile = TileEntitySkull.updateGameprofile(this.profile);
    }

    /**
     * Create a player morph 
     */
    @Override
    public void setupEntity(World world)
    {
        EntityLivingBase created = null;

        if (world.isRemote)
        {
            created = this.getPlayerClient(world);
        }
        else
        {
            created = new EntityPlayer(world, this.profile)
            {
                @Override
                public boolean isSpectator()
                {
                    return true;
                }

                @Override
                public boolean isCreative()
                {
                    return false;
                }
            };
        }

        created.deserializeNBT(this.entityData);
        created.deathTime = 0;
        created.hurtTime = 0;
        created.limbSwing = 0;
        created.setFire(0);

        this.setEntity(created);

        if (world.isRemote)
        {
            this.setupRenderer();
        }
    }

    /**
     * Encapsulate the code into removable (on client side) method 
     */
    @SideOnly(Side.CLIENT)
    private EntityPlayer getPlayerClient(World world)
    {
        return new PlayerMorphClientEntity(world, this.profile);
    }

    /**
     * Updates the player entity, but not using its update methods, but 
     * rather some code that only updates player's cape and some other 
     * stuff.
     */
    @Override
    protected void updateEntity(EntityLivingBase target)
    {
        EntityPlayer entity = (EntityPlayer) this.entity;
        EnumHandSide hand = target.getPrimaryHand();

        hand = hand == EnumHandSide.LEFT ? EnumHandSide.RIGHT : EnumHandSide.LEFT;
        entity.setPrimaryHand(hand);

        /* Update the cape */
        entity.prevChasingPosX = entity.chasingPosX;
        entity.prevChasingPosY = entity.chasingPosY;
        entity.prevChasingPosZ = entity.chasingPosZ;
        double d0 = entity.posX - entity.chasingPosX;
        double d1 = entity.posY - entity.chasingPosY;
        double d2 = entity.posZ - entity.chasingPosZ;

        if (d0 > 10.0D)
        {
            entity.chasingPosX = entity.posX;
            entity.prevChasingPosX = entity.chasingPosX;
        }

        if (d2 > 10.0D)
        {
            entity.chasingPosZ = entity.posZ;
            entity.prevChasingPosZ = entity.chasingPosZ;
        }

        if (d1 > 10.0D)
        {
            entity.chasingPosY = entity.posY;
            entity.prevChasingPosY = entity.chasingPosY;
        }

        if (d0 < -10.0D)
        {
            entity.chasingPosX = entity.posX;
            entity.prevChasingPosX = entity.chasingPosX;
        }

        if (d2 < -10.0D)
        {
            entity.chasingPosZ = entity.posZ;
            entity.prevChasingPosZ = entity.chasingPosZ;
        }

        if (d1 < -10.0D)
        {
            entity.chasingPosY = entity.posY;
            entity.prevChasingPosY = entity.chasingPosY;
        }

        entity.chasingPosX += d0 * 0.25D;
        entity.chasingPosZ += d2 * 0.25D;
        entity.chasingPosY += d1 * 0.25D;
    }

    @Override
    public AbstractMorph create()
    {
        return new PlayerMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof PlayerMorph)
        {
            PlayerMorph morph = (PlayerMorph) from;

            this.profile = morph.profile;
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof PlayerMorph)
        {
            PlayerMorph morph = (PlayerMorph) obj;

            result = result && morph.profile.equals(this.profile);
        }

        return result;
    }

    @Override
    public void reset()
    {
        super.reset();

        this.profile = null;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("PlayerProfile", 10))
        {
            this.profile = NBTUtil.readGameProfileFromNBT(tag.getCompoundTag("PlayerProfile"));
        }
        else if (tag.hasKey("Username"))
        {
            this.setProfile(tag.getString("Username"));
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.profile != null)
        {
            NBTTagCompound profileTag = new NBTTagCompound();

            NBTUtil.writeGameProfile(profileTag, this.profile);
            tag.setTag("PlayerProfile", profileTag);
        }
    }

    /**
     * Placeholder player morph entity
     * 
     * This player entity is used for overriding some of its methods to 
     * provide stable functionality of player morph in its isolated 
     * environment.
     */
    @SideOnly(Side.CLIENT)
    public static class PlayerMorphClientEntity extends EntityOtherPlayerMP
    {
        public GameProfile profile;
        public boolean isBaby;
        public String skinType = "";

        /**
         * Player's network info
         */
        public NetworkPlayerInfo info;

        public PlayerMorphClientEntity(World world, GameProfile profile)
        {
            super(world, profile);

            this.profile = profile;
        }

        /**
         * Initiate network info property thing 
         */
        protected void initiateNetworkInfo()
        {
            if (this.info == null)
            {
                this.info = new NetworkPlayerInfo(this.profile);
            }
        }

        @Override
        public boolean isChild()
        {
            return this.isBaby;
        }

        @Override
        public String getSkinType()
        {
            if (this.skinType.isEmpty())
            {
                this.initiateNetworkInfo();
                return this.info.getSkinType();
            }

            return this.skinType.equals("alex") ? "slim" : "default";
        }

        /**
         * Get this player's skin 
         */
        @Override
        public ResourceLocation getLocationSkin()
        {
            this.initiateNetworkInfo();
            return this.info.getLocationSkin();
        }

        /**
         * Get this player's custom cape skin 
         */
        @Override
        public ResourceLocation getLocationCape()
        {
            this.initiateNetworkInfo();
            return this.info.getLocationCape();
        }

        /**
         * This player is always wearing every part of the body 
         */
        @Override
        @SideOnly(Side.CLIENT)
        public boolean isWearing(EnumPlayerModelParts part)
        {
            return true;
        }

        @Override
        public boolean hasPlayerInfo()
        {
            return this.info != null;
        }

        @Override
        public void readEntityFromNBT(NBTTagCompound compound)
        {
            super.readEntityFromNBT(compound);

            this.isBaby = compound.getBoolean("IsBaby");
            this.skinType = compound.getString("SkinType");
        }

        @Override
        public void writeEntityToNBT(NBTTagCompound compound)
        {
            super.writeEntityToNBT(compound);

            compound.setBoolean("IsBaby", this.isBaby);
            compound.setString("SkinType", this.skinType);
        }
    }
}

==================================================

--- Файл №177 ---
Путь: main\java\mchorse\vanilla_pack\morphs\ShulkerMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.BlockPos;

/**
 * Shulker morph class
 * 
 * This method is responsible for freezing the player on the place where 
 * s/he was morphed and also disabling the movement of the body (shell).
 */
public class ShulkerMorph extends EntityMorph
{
    public BlockPos blockPos;

    @Override
    public void morph(EntityLivingBase target)
    {
        super.morph(target);

        this.blockPos = new BlockPos(target);
    }

    @Override
    public void demorph(EntityLivingBase target)
    {
        super.demorph(target);

        this.blockPos = null;
    }

    /**
     * Update the entity
     * 
     * This method is responsible holding the player in the player on 
     * morphed block position, and also aligns the body to the north.
     */
    @Override
    public void update(EntityLivingBase target)
    {
        if (this.blockPos != null)
        {
            target.motionX = target.motionY = target.motionZ = 0;
            target.setPosition(this.blockPos.getX() + 0.5, this.blockPos.getY(), this.blockPos.getZ() + 0.5);
        }

        super.update(target);

        this.entity.renderYawOffset = this.entity.prevRenderYawOffset = 0;
    }

    @Override
    public AbstractMorph create()
    {
        return new ShulkerMorph();
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Pos"))
        {
            int[] pos = tag.getIntArray("Pos");

            if (pos.length == 3)
            {
                this.blockPos = new BlockPos(pos[0], pos[1], pos[2]);
            }
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.blockPos != null)
        {
            tag.setIntArray("Pos", new int[] {this.blockPos.getX(), this.blockPos.getY(), this.blockPos.getZ()});
        }
    }
}

==================================================

--- Файл №178 ---
Путь: main\java\mchorse\vanilla_pack\morphs\UndeadMorph.java
--------------------
package mchorse.vanilla_pack.morphs;

import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.EntityMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.Items;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

/**
 * Undead morph 
 * 
 * This morph is responsible for preventing hurt noises caused by sun 
 * allergy.
 */
public class UndeadMorph extends EntityMorph
{
    protected static final ItemStack HELMET;

    static
    {
        NBTTagCompound unbreakable = new NBTTagCompound();

        unbreakable.setBoolean("Unbreakable", true);

        HELMET = new ItemStack(Items.LEATHER_HELMET);
        HELMET.setTagCompound(unbreakable);
    }

    @Override
    protected void updateEntity(EntityLivingBase target)
    {
        boolean preventNoise = !target.isBurning();

        if (preventNoise)
        {
            this.entity.setItemStackToSlot(EntityEquipmentSlot.HEAD, HELMET);
        }

        super.updateEntity(target);

        if (preventNoise)
        {
            this.entity.setItemStackToSlot(EntityEquipmentSlot.HEAD, ItemStack.EMPTY);
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new UndeadMorph();
    }
}

==================================================

--- Файл №179 ---
Путь: main\java\mchorse\vanilla_pack\render\CachedExtrusion.java
--------------------
package mchorse.vanilla_pack.render;

import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL15;

import java.nio.ByteBuffer;

public class CachedExtrusion
{
    /* 6 vertices * (3f vertex + 3f normal + 2f uv) */
    private static final int BYTES_PER_VERTEX = (3 * 4 + 3 * 4 + 2 * 4);
    private static final int BYTES_PER_QUAD = 6 * BYTES_PER_VERTEX;

    private ResourceLocation texture;
    private int vertices;
    private int vbo;
    private ByteBuffer buffer;

    public CachedExtrusion(ResourceLocation texture, int w, int h)
    {
        this.texture = texture;
        this.buffer = BufferUtils.createByteBuffer(w * h * BYTES_PER_QUAD);

        this.vbo = GL15.glGenBuffers();
    }

    public void addVertex(float x, float y, float z, float nx, float ny, float nz, float u, float v)
    {
        this.buffer.putFloat(x);
        this.buffer.putFloat(y);
        this.buffer.putFloat(z);

        this.buffer.putFloat(nx);
        this.buffer.putFloat(ny);
        this.buffer.putFloat(nz);

        this.buffer.putFloat(u);
        this.buffer.putFloat(v);

        this.vertices += 1;
    }

    public void flush()
    {
        this.buffer.flip();

        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, this.vbo);
        GL15.glBufferData(GL15.GL_ARRAY_BUFFER, this.buffer, GL15.GL_DYNAMIC_DRAW);
    }

    public void render()
    {
        GlStateManager.disableCull();

        Minecraft.getMinecraft().renderEngine.bindTexture(this.texture);

        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, this.vbo);
        GL11.glVertexPointer(3, GL11.GL_FLOAT, BYTES_PER_VERTEX, 0);
        GL11.glNormalPointer(GL11.GL_FLOAT, BYTES_PER_VERTEX, 3 * 4);
        GL11.glTexCoordPointer(2, GL11.GL_FLOAT, BYTES_PER_VERTEX, 6 * 4);

        GL11.glEnableClientState(GL11.GL_VERTEX_ARRAY);
        GL11.glEnableClientState(GL11.GL_NORMAL_ARRAY);
        GL11.glEnableClientState(GL11.GL_TEXTURE_COORD_ARRAY);

        /* Render with index buffer */
        GL11.glDrawArrays(GL11.GL_TRIANGLES, 0, this.vertices);

        /* Unbind the buffer. REQUIRED to avoid OpenGL crash */
        GL15.glBindBuffer(GL15.GL_ELEMENT_ARRAY_BUFFER, 0);
        GL15.glBindBuffer(GL15.GL_ARRAY_BUFFER, 0);

        GL11.glDisableClientState(GL11.GL_VERTEX_ARRAY);
        GL11.glDisableClientState(GL11.GL_NORMAL_ARRAY);
        GL11.glDisableClientState(GL11.GL_TEXTURE_COORD_ARRAY);

        GlStateManager.enableCull();
    }
}

==================================================

--- Файл №180 ---
Путь: main\java\mchorse\vanilla_pack\render\ItemExtruder.java
--------------------
package mchorse.vanilla_pack.render;

import mchorse.mclib.utils.Color;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Map;

@SideOnly(Side.CLIENT)
public class ItemExtruder
{
    private static Map<ResourceLocation, CachedExtrusion> cache = new HashMap<ResourceLocation, CachedExtrusion>();

    public static CachedExtrusion extrude(ResourceLocation texture)
    {
        CachedExtrusion extrusion = cache.get(texture);

        if (extrusion != null)
        {
            return extrusion;
        }

        BufferedImage pixels = null;

        try
        {
            pixels = ImageIO.read(Minecraft.getMinecraft().getResourceManager().getResource(texture).getInputStream());
        }
        catch (Exception e)
        {
            cache.put(texture, null);

            return null;
        }

        int w = pixels.getWidth();
        int h = pixels.getHeight();
        extrusion = new CachedExtrusion(texture, w, h);

        int uv_x = 0;
        int uv_y = 0;

        float p = 0.5F;
        float n = -0.5F;
        float u1 = uv_x / (float) w;
        float v1 = uv_y / (float) h;
        float u2 = (uv_x + w) / (float) w;
        float v2 = (uv_y + h) / (float) h;
        float d = 0.5F / 16F;

        fillTexturedNormalQuad(extrusion,
            p, n, d,
            n, n, d,
            n, p, d,
            p, p, d,
            u1, v1, u2, v2,
            0F, 0F, 1F
        );

        fillTexturedNormalQuad(extrusion,
            n, n, -d,
            p, n, -d,
            p, p, -d,
            n, p, -d,
            u2, v1, u1, v2,
            0F, 0F, -1F
        );

        for (int i = 0; i < w; i++)
        {
            for (int j = 0; j < h; j++)
            {
                int x = uv_x + i;
                int y = uv_y + j;

                if (hasPixel(pixels, x, y))
                {
                    generateNeighbors(pixels, extrusion, i, j, x, y, d, w, h);
                }
            }
        }

        extrusion.flush();

        cache.put(texture, extrusion);

        return extrusion;
    }

    private static void generateNeighbors(BufferedImage pixels, CachedExtrusion extrusion, int i, int j, int x, int y, float d, float w, float h)
    {
        float u = (x + 0.5F) / w;
        float v = (y + 0.5F) / h;

        if (!hasPixel(pixels, x - 1, y) || i == 0)
        {
            fillTexturedNormalQuad(extrusion,
                i / w - 0.5F, -(j + 1) / h + 0.5F, -d,
                i / w - 0.5F, -j / h + 0.5F, -d,
                i / w - 0.5F, -j / h + 0.5F, d,
                i / w - 0.5F, -(j + 1) / h + 0.5F, d,
                u, v, u, v,
                -1F, 0F, 0F
            );
        }

        if (!hasPixel(pixels, x + 1, y) || i == 15)
        {
            fillTexturedNormalQuad(extrusion,
                (i + 1) / w - 0.5F, -(j + 1) / h + 0.5F, d,
                (i + 1) / w - 0.5F, -j / h + 0.5F, d,
                (i + 1) / w - 0.5F, -j / h + 0.5F, -d,
                (i + 1) / w - 0.5F, -(j + 1) / h + 0.5F, -d,
                u, v, u, v,
                1F, 0F, 0F
            );
        }

        if (!hasPixel(pixels, x, y - 1) || j == 0)
        {
            fillTexturedNormalQuad(extrusion,
                (i + 1) / w - 0.5F, -j / h + 0.5F, d,
                i / w - 0.5F, -j / h + 0.5F, d,
                i / w - 0.5F, -j / h + 0.5F, -d,
                (i + 1) / w - 0.5F, -j / h + 0.5F, -d,
                u, v, u, v,
                0F, 1F, 0F
            );
        }

        if (!hasPixel(pixels, x, y + 1) || j == 15)
        {
            fillTexturedNormalQuad(extrusion,
                (i + 1) / w - 0.5F, -(j + 1) / h + 0.5F, -d,
                i / w - 0.5F, -(j + 1) / h + 0.5F, -d,
                i / w - 0.5F, -(j + 1) / h + 0.5F, d,
                (i + 1) / w - 0.5F, -(j + 1) / h + 0.5F, d,
                u, v, u, v,
                0F, -1F, 0F
            );
        }
    }

    private static boolean hasPixel(BufferedImage pixels, int x, int y)
    {
        if (x < 0 || x >= pixels.getWidth() || y < 0 || y >= pixels.getHeight())
        {
            return false;
        }

        Color pixel = new Color().set(pixels.getRGB(x, y));

        return pixel != null && pixel.a >= 1;
    }

    /**
     * Fill a quad for vertex-normal-uv-rgba. Points should
     * be supplied in this order:
     *
     *     3 -------> 4
     *     ^
     *     |
     *     |
     *     2 <------- 1
     *
     * I.e. bottom left, bottom right, top left, top right, where left is -X and right is +X,
     * in case of a quad on fixed on Z axis.
     */
    public static void fillTexturedNormalQuad(CachedExtrusion extrusion, float x1, float y1, float z1, float x2, float y2, float z2, float x3, float y3, float z3, float x4, float y4, float z4, float u1, float v1, float u2, float v2, float nx, float ny, float nz)
    {
        /* 1 - BL, 2 - BR, 3 - TR, 4 - TL */
        extrusion.addVertex(x2, y2, z2, nx, ny, nz, u1, v2);
        extrusion.addVertex(x1, y1, z1, nx, ny, nz, u2, v2);
        extrusion.addVertex(x4, y4, z4, nx, ny, nz, u2, v1);

        extrusion.addVertex(x2, y2, z2, nx, ny, nz, u1, v2);
        extrusion.addVertex(x4, y4, z4, nx, ny, nz, u2, v1);
        extrusion.addVertex(x3, y3, z3, nx, ny, nz, u1, v1);
    }
}

==================================================

--- Файл №181 ---
Путь: main\java\net\minecraft\client\renderer\entity\RenderSubPlayer.java
--------------------
package net.minecraft.client.renderer.entity;

import mchorse.metamorph.Metamorph;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.capabilities.morphing.IMorphing;
import mchorse.metamorph.capabilities.morphing.Morphing;
import net.minecraft.client.entity.AbstractClientPlayer;
import net.minecraft.client.model.ModelPlayer;
import net.minecraft.client.renderer.entity.layers.LayerRenderer;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.EnumHand;
import net.minecraft.util.ResourceLocation;

/**
 * Render sub player renderer
 *
 * This class is responsible for substituting native player renderer classes
 * in the skinMap to achieve the rendering of the custom morphed hands.
 *
 * I hope nobody will want to substitute the same map as I did :D
 */
public class RenderSubPlayer extends RenderPlayer
{
    public RenderPlayer original;

    /**
     * Initiate with render manager, player renderer and smallArms flag.
     */
    public RenderSubPlayer(RenderManager renderManager, RenderPlayer original, boolean smallArms)
    {
        super(renderManager, smallArms);
        this.original = original;
        // This improves compat with render override code that thinks this is the original RenderPlayer
        this.layerRenderers = original.layerRenderers;
    }

    /**
     * Should make layers added to the original player renderer
     */
    @Override
    public <V extends EntityLivingBase, U extends LayerRenderer<V>> boolean addLayer(U layer)
    {
        if (this.original == null)
        {
            return false;
        }
        
        return this.original.addLayer(layer);
    }

    /**
     * Render default or morphed left hand.
     */
    @Override
    public void renderLeftArm(AbstractClientPlayer clientPlayer)
    {
        if (!this.renderHand(clientPlayer, EnumHand.OFF_HAND))
        {
            this.original.renderLeftArm(clientPlayer);
        }
    }

    /**
     * Render default or morphed right hand.
     */
    @Override
    public void renderRightArm(AbstractClientPlayer clientPlayer)
    {
        if (!this.renderHand(clientPlayer, EnumHand.MAIN_HAND))
        {
            this.original.renderRightArm(clientPlayer);
        }
    }

    private boolean renderHand(EntityPlayer player, EnumHand hand)
    {
        if (Metamorph.disableFirstPersonHand.get())
        {
            return false;
        }

        IMorphing cap = Morphing.get(player);

        if (cap != null && cap.isMorphed())
        {
            AbstractMorph morph = cap.getCurrentMorph();

            try
            {
                if (!morph.errorRendering && morph.renderHand(player, hand))
                {
                    return true;
                }
            }
            catch (Exception e)
            {
                morph.errorRendering = true;
            }
        }

        return false;
    }

    /* Overriding RenderPlayer methods */

    @Override
    public ModelPlayer getMainModel()
    {
        return this.original == null ? super.getMainModel() : this.original.getMainModel();
    }

    @Override
    public void doRender(AbstractClientPlayer entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        this.original.doRender(entity, x, y, z, entityYaw, partialTicks);
    }

    @Override
    public ResourceLocation getEntityTexture(AbstractClientPlayer entity)
    {
        return this.original.getEntityTexture(entity);
    }

    @Override
    public void transformHeldFull3DItemLayer()
    {
        this.original.transformHeldFull3DItemLayer();
    }

    @Override
    protected void preRenderCallback(AbstractClientPlayer entitylivingbaseIn, float partialTickTime)
    {
        this.original.preRenderCallback(entitylivingbaseIn, partialTickTime);
    }

    @Override
    protected void renderEntityName(AbstractClientPlayer entityIn, double x, double y, double z, String name, double distanceSq)
    {
        this.original.renderEntityName(entityIn, x, y, z, name, distanceSq);
    }

    @Override
    protected void renderLivingAt(AbstractClientPlayer entityLivingBaseIn, double x, double y, double z)
    {
        this.original.renderLivingAt(entityLivingBaseIn, x, y, z);
    }

    @Override
    protected void applyRotations(AbstractClientPlayer entityLiving, float p_77043_2_, float p_77043_3_, float partialTicks)
    {
        this.original.applyRotations(entityLiving, p_77043_2_, p_77043_3_, partialTicks);
    }
}

==================================================

--- Файл №182 ---
Путь: main\resources\mcmod.info
--------------------
[
	{
		"modid": "metamorph",
  		"name": "Metamorph",
  		"description": "Allows players to morph into different mobs and more!",
  		"version": "${version}",
  		"mcversion": "${mcversion}",
  		"url": "https://www.curseforge.com/minecraft/mc-mods/metamorph/",
  		"updateJSON": "https://raw.githubusercontent.com/mchorse/metamorph/1.12/version.json",
  		"updateUrl": "",
  		"authorList": ["mchorse", "asanetargoss"],
  		"credits": "asanetargoss for mod development. SCtester for ideas, feedback and testing. Morph and Shape Shifter Z mods for inspiration. Also big thanks to ycwei982 for testing, adding few features and localization!",
		"logoFile": "",
		"screenshots": [],
		"requiredMods": ["mclib"],
		"dependencies": ["moreplayermodels", "mclib"]
	}
]

==================================================

--- Файл №183 ---
Путь: main\resources\assets\metamorph\morphs.json
--------------------
{
    "metamorph.Block": {
        "hands": false,
        "hostile": true
    },
    "Player": {
        "health": 20,
        "hands": true
    },
    
    "minecraft:bat": {
        "abilities": ["fly", "night_vision", "prevent_fall"],
        "health": 6,
        "hostile": true
    },
    "minecraft:cave_spider": {
        "abilities": ["climb"],
        "attack": "poison",
        "health": 12,
        "hostile": true
    },
    "minecraft:chicken": {
        "abilities": ["glide"],
        "health": 4,
        "hands": true
    },
    "minecraft:cow": {
        "health": 10,
		"hands": true
    },
    "minecraft:llama": {
        "health": 20,
        "action": "spit",
        "hostile": true
    },
    "minecraft:horse": {
        "abilities": ["prevent_fall", "step_up"],
        "action": "jump",
        "health": 24,
        "speed": 0.15
    },
    "minecraft:donkey": {
        "abilities": ["prevent_fall", "step_up"],
        "action": "jump",
        "health": 24,
        "speed": 0.15
    },
    "minecraft:mule": {
        "abilities": ["prevent_fall", "step_up"],
        "action": "jump",
        "health": 24,
        "speed": 0.15
    },
    "minecraft:parrot": {
    	"abilities": ["fly", "prevent_fall"],
    	"health": 6,
    	"hostile": true
    },
    "minecraft:skeleton_horse": {
        "abilities": ["prevent_fall", "step_up", "rotten"],
        "action": "jump",
        "health": 24,
        "speed": 0.15
    },
    "minecraft:zombie_horse": {
        "abilities": ["prevent_fall", "step_up", "rotten"],
        "action": "jump",
        "health": 24,
        "speed": 0.15,
        "hands": false
    },
    "minecraft:mooshroom": {
        "health": 10,
        "hands": true
    },
    "minecraft:ocelot": {
        "health": 10,
        "speed": 0.15,
        "hands": true
    },
    "minecraft:pig": {
        "health": 10,
        "hands": true
    },
    "minecraft:polar_bear": {
        "health": 30,
		"hands": true
    },
    "minecraft:rabbit": {
        "abilities": ["prevent_fall", "jumping"],
        "action": "jump",
        "health": 3,
        "speed": 0.13
    },
    "minecraft:sheep": {
        "health": 8,
        "hands": true
    },
    "minecraft:spider": {
        "abilities": ["climb"],
        "health": 16,
        "hostile": true
    },
    "minecraft:squid": {
        "abilities": ["water_breath", "swim", "night_vision"],
        "health": 10,
        "hands": true
    },
    "minecraft:wolf": {
        "health": 8,
        "hostile": true,
        "hands": true
    },
    
    "minecraft:enderman": {
        "abilities": ["water_allergy"],
        "action": "teleport",
        "health": 40,
        "hostile": true,
        "hands": true
    },
    "minecraft:endermite": {
        "action": "endermite",
        "health": 8,
        "hostile": true
    },
    "minecraft:zombie_pigman": {
        "abilities": ["fire_proof", "hungerless", "rotten"],
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:snowman": {
        "abilities": ["snow_walk"],
        "action": "snowball",
        "health": 4
    },
	"minecraft:villager": {
        "health": 20,
        "hands": true
    },
    "minecraft:villager_golem": {
        "abilities": ["prevent_fall", "step_up"],
	"attack": "mob",
        "health": 100,
	"hands": true
    },
    "minecraft:blaze": {
        "abilities": ["fly", "fire_proof", "water_allergy"],
        "action": "small_fireball",
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:creeper": {
        "action": "explode",
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:ghast": {
        "abilities": ["fly", "fire_proof"],
        "action": "fireball",
        "health": 10,
        "hostile": true,
        "hands": true
    },
    "minecraft:guardian": {
        "abilities": ["water_breath", "night_vision", "swim", "jumping"],
        "health": 30,
        "hostile": true
    },
    "minecraft:elder_guardian": {
        "abilities": ["water_breath", "night_vision", "swim", "jumping"],
        "health": 30,
        "hostile": true
    },
    "minecraft:magma_cube": {
        "abilities": ["jumping", "fire_proof"],
        "health": 4,
        "hostile": true
    },
    "minecraft:silverfish": {
        "action": "silverfish",
        "health": 8,
        "hostile": true
    },
    "minecraft:shulker": {
        "action": "shulker_bullet",
        "health": 15,
        "hostile": true
    },
    "minecraft:slime": {
        "abilities": ["jumping"],
        "health": 4,
        "hostile": true
    },
    "minecraft:skeleton": {
        "abilities": ["sun_allergy", "rotten"],
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:stray": {
        "abilities": ["sun_allergy", "rotten"],
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:wither_skeleton": {
        "abilities": ["fire_proof", "rotten"],
        "attack": "wither",
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:witch": {
        "action": "potions",
        "health": 26,
        "hostile": true,
        "hands": true
    },
    "minecraft:zombie": {
        "abilities": ["sun_allergy", "hungerless", "rotten"],
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:husk": {
        "abilities": ["sun_allergy", "hungerless", "rotten"],
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:zombie_villager": {
        "abilities": ["sun_allergy", "hungerless", "rotten"],
        "health": 20,
        "hostile": true,
        "hands": true
    },
    "minecraft:ender_dragon": {
        "abilities": ["fly"],
        "action": "fire_breath",
        "health": 200,
        "hostile": true
    }
}


==================================================

--- Файл №184 ---
Путь: main\resources\assets\metamorph\lang\de_DE.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=Aktion verwenden
key.metamorph.creative_menu=Kreativ-Morphmenü öffnen
key.metamorph.selector_menu=Open entity selectors menu
key.metamorph.survival_menu=Überlebens-Morphmenü öffnen
key.metamorph.demorph=Demorph (turn back to player)

# GUI
metamorph.gui.body_parts.pick=Pick morph
metamorph.gui.body_parts.use_target=Use target
metamorph.gui.body_parts.enabled=Enabled
metamorph.gui.body_parts.animate=Animate
metamorph.gui.body_parts.animate_tooltip=This option enables animation of body part's transformations when parent morph gets animated
metamorph.gui.body_parts.parts=Body parts
metamorph.gui.body_parts.limbs=Limbs
metamorph.gui.body_parts.open=Open body parts
metamorph.gui.body_parts.add_tooltip=Add a new body part...
metamorph.gui.body_parts.dupe_tooltip=Dupe currently selected body part...
metamorph.gui.body_parts.remove_tooltip=Remove currently selected body part...
metamorph.gui.body_parts.copy_tooltip=Copy all body parts...
metamorph.gui.body_parts.paste_tooltip=Paste copied body parts...
metamorph.gui.body_parts.context.copy=Copy body part
metamorph.gui.body_parts.context.paste=Paste copied body part

metamorph.gui.add=Add
metamorph.gui.remove=Entfernen
metamorph.gui.morph=Morphen
metamorph.gui.acquire=Erwerben
metamorph.gui.acquired=Acquired
metamorph.gui.close=Schließen
metamorph.gui.search=Suchen
metamorph.gui.no_morph=Kein Morph ausgewählt
metamorph.gui.morph_render_error=Error occurred rendering this morph

metamorph.gui.selectors.title=Entity selectors
metamorph.gui.selectors.tooltip=With this feature, you can add morphs to entities by specific name or their type...
metamorph.gui.selectors.add=Add a selector
metamorph.gui.selectors.remove=Remove a selector
metamorph.gui.selectors.name=Name
metamorph.gui.selectors.type=Type
metamorph.gui.selectors.match=Matching NBT
metamorph.gui.selectors.match_tooltip=Here you can specify an NBT tag that has to partially match entity's NBT tag
metamorph.gui.selectors.enabled=Enabled

metamorph.gui.morphs.keys.category=Morph navigation
metamorph.gui.morphs.keys.up=Select morph above
metamorph.gui.morphs.keys.down=Select morph below
metamorph.gui.morphs.keys.right=Select morph to the right
metamorph.gui.morphs.keys.left=Select morph to the left

metamorph.gui.creative.command=Copy /morph command for selected morph
metamorph.gui.creative.edit=Edit
metamorph.gui.creative.pick=Pick
metamorph.gui.creative.quick=Quick edit
metamorph.gui.creative.presets=Presets
metamorph.gui.creative.random=Random preset
metamorph.gui.creative.keys.category=Creative morph menu
metamorph.gui.creative.keys.exit=Exit the morph editor
metamorph.gui.creative.keys.edit=Edit currently selected morph
metamorph.gui.creative.keys.focus=Focus search bar
metamorph.gui.creative.keys.quick=Toggle quick edit menu
metamorph.gui.creative.keys.acquire=Acquire currently selected morph
metamorph.gui.creative.keys.morph=Morph into currently selected morph
metamorph.gui.creative.context.add_global=Add to global morphs...
metamorph.gui.creative.context.edit=Edit morph...
metamorph.gui.creative.context.add_category=Add a new category
metamorph.gui.creative.context.rename_category=Rename category
metamorph.gui.creative.context.rename_category_modal=Give a new name to given category...
metamorph.gui.creative.context.remove_category=Remove category
metamorph.gui.creative.context.remove_morph_modal=Are you sure you want to remove this morph? It will be gone forever...
metamorph.gui.creative.context.remove_category_modal=Are you sure you want to remove this morph category? It will be gone forever...
metamorph.gui.creative.context.clear_category=Remove all morphs
metamorph.gui.creative.context.clear_category_modal=Are you sure you want to remove all morphs in this category? It will be gone forever... 
metamorph.gui.creative.context.to_recent=Copy to recent
metamorph.gui.creative.context.remove_morph=Remove the morph
metamorph.gui.creative.context.copy_command=Copy /morph command
metamorph.gui.creative.context.copy=Copy NBT
metamorph.gui.creative.context.paste=Paste NBT
metamorph.gui.creative.context.paste_modal=Paste or input the NBT tag of your morph...

metamorph.gui.survival.title=Survival Morph Menu
metamorph.gui.survival.keybind_tooltip=With this field, you can bind a key which will morph you into this particular morph (when you press it either in this menu or in the world)
metamorph.gui.survival.only_favorites=Only favorites
metamorph.gui.survival.favorite=Favorite
metamorph.gui.survival.keys.category=Survival morph menu
metamorph.gui.survival.keys.toggle_favorites=Toggle favorite morphs
metamorph.gui.survival.keys.focus_keybind=Focus keybind

metamorph.gui.editor.entity=Entity properties
metamorph.gui.editor.settings=Morph settings
metamorph.gui.editor.keybind=Keybind
metamorph.gui.editor.keybind_tooltip=Setting keybind here will allow you to morph into this morph by pressing this key either in the world or in survival morph menu
metamorph.gui.editor.display_name=Display name
metamorph.gui.editor.health=Health
metamorph.gui.editor.speed=Speed
metamorph.gui.editor.abilities=Abilities
metamorph.gui.editor.abilities_tooltip=Shift + click on the abilities in the list, to select multiple abilities
metamorph.gui.editor.attack=Attack
metamorph.gui.editor.action=Action
metamorph.gui.editor.reset=Reset
metamorph.gui.editor.item_morph=Item
metamorph.gui.editor.scale=Entity scale
metamorph.gui.editor.texture=Pick a texture...
metamorph.gui.editor.texture_tooltip=This feature won't work for all mobs, because some mobs can have custom rendering implementation
metamorph.gui.editor.keys.category=Morph editor keybinds
metamorph.gui.editor.keys.cycle=Cycle between morph panels

metamorph.gui.editor.hitbox.enabled=Custom hitbox
metamorph.gui.editor.hitbox.size=Size
metamorph.gui.editor.hitbox.width=Hitbox width
metamorph.gui.editor.hitbox.height=Hitbox height
metamorph.gui.editor.hitbox.sneaking_height=Hitbox sneaking height
metamorph.gui.editor.hitbox.eye=Eye position
metamorph.gui.editor.hitbox.eye_tooltip=Eye height factor of the height, where 0 is at the bottom and 1 on the top of the hitbox

metamorph.gui.label.label=Label
metamorph.gui.label.max_width=Max width
metamorph.gui.label.anchor=Anchor
metamorph.gui.label.color=Text color
metamorph.gui.label.shadow=Shadow
metamorph.gui.label.shadow_offset=Shadow offset
metamorph.gui.label.shadow_color=Shadow color
metamorph.gui.label.lighting=Lighting
metamorph.gui.label.lighting_tooltip=When disabled, Minecraft's lightmap won't be applied, meaning it would glow in the dark. Shader packs, that have bloom effect, will make this morph look like neon sign
metamorph.gui.label.background=Background
metamorph.gui.label.billboard=Look at player

metamorph.gui.edit=Edit
metamorph.gui.panels.nbt_data=NBT data
metamorph.gui.panels.username=Username
metamorph.gui.panels.updating=Updating...

metamorph.gui.animation.animates=Animates
metamorph.gui.animation.ignored=Ignored
metamorph.gui.animation.animation_duration=Duration
metamorph.gui.animation.pick_interpolation=Pick interpolation

metamorph.gui.status.tight_space=There is not enough space to morph here

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=Morph acquiring
metamorph.config.acquiring.tooltip=All the options related to ways of getting morphs

metamorph.config.acquiring.prevent_ghosts=Prevent ghost
metamorph.config.comments.acquiring.prevent_ghosts=Prevents ghosts from spawning if the player has already a currently killed mob's morph
metamorph.config.acquiring.prevent_kill_acquire=Prevent acquiring by killing
metamorph.config.comments.acquiring.prevent_kill_acquire=Prevent acquiring morphs by killing morphs
metamorph.config.acquiring.acquire_immediately=Acquire morph immediately
metamorph.config.comments.acquiring.acquire_immediately=Acquires morph immediately after player kills an entity instead of spawning a ghost

metamorph.config.morphs.title=Morphs
metamorph.config.morphs.tooltip=All the options related to morphing and morph settings

metamorph.config.morphs.keep_morphs=Retain morphs on death
metamorph.config.comments.morphs.keep_morphs=Retain morphs when player died
metamorph.config.morphs.disable_pov=Disable POV
metamorph.config.comments.morphs.disable_pov=Disable modifying Point-of-View. Requested because of MorePlayerModels
metamorph.config.morphs.disable_health=Disable health scaling
metamorph.config.comments.morphs.disable_health=Disable modifying health. Requested because of Tough as Nails
metamorph.config.morphs.disable_morph_animation=Disable morph animation
metamorph.config.comments.morphs.disable_morph_animation=Disables morphing animation
metamorph.config.morphs.disable_morph_disguise=Disable morph hostility
metamorph.config.comments.morphs.disable_morph_disguise=Disable the ability of morphs labeled as "hostile" to avoid being attacked by hostile mobs
metamorph.config.morphs.disable_first_person_hand=Disable first person hand
metamorph.config.comments.morphs.disable_first_person_hand=Completely hide first person hand rendering
metamorph.config.morphs.morph_in_tight_spaces=Allow morphing in tight spaces
metamorph.config.comments.morphs.morph_in_tight_spaces=Allows morphing even if it could cause suffocation and allow passing through walls
metamorph.config.morphs.show_morph_idle_sounds=Show morph idle sounds
metamorph.config.comments.morphs.show_morph_idle_sounds=Whether players make entity idle sounds when morphed
metamorph.config.morphs.pause_gui_in_sp=Pause morph GUIs
metamorph.config.comments.morphs.pause_gui_in_sp=Whether creative and survival morph GUIs should be paused in singleplayer
metamorph.config.morphs.max_recent_morphs=Max. recent morphs
metamorph.config.comments.morphs.max_recent_morphs=The maximum amount of recent morphs that can be added in the morph menu before being discarded
metamorph.config.morphs.allow_morphing_into_category_morphs=Allow morphing into category morphs
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=When enabled, this option allows to morph into recent and custom category morphs while being in survival. This option also allows to open creative morph menu in survival
metamorph.config.morphs.load_entity_morphs=Load entity morphs
metamorph.config.comments.morphs.load_entity_morphs=Whether entity morphs should be loaded in creative morph menu
metamorph.config.morphs.render_bodypart_axis=Achsen für Bodyparts anzeigen
metamorph.config.comments.morphs.render_bodypart_axis=Aktiviert das Anzeigen von Achsen für jeden Bodypart in dem GUI

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Metamorph's OP access options

op_access.config.metamorph.entity_selectors=Entity selectors
op_access.config.comments.metamorph.entity_selectors=Can non-OP players edit entity selectors?

# Commands
metamorph.commands.morph=Morph-Befehl. Dieser Befehl ist für die Verwandlung eines Spielers in den angegebenen Morph verantwortlich.\n\n/morph <username> [morph_name] [data_tag]
metamorph.commands.acquire_morph=Morph-Erwerben-Befehl. Dieser Befehl ist für das Senden eines Morphs an einen Spieler verantwortlich.\n\n/morph <username> <morph_name> [data_tag]
metamorph.commands.metamorph=Metamorph server command. This command allows to manage Metamorph stuff on the server side.\n\n/metamorph reload <blacklist|morphs> - reloads Metamorph's blacklist or morph configuration

metamorph.error.morph.not_player=Lebewesen %s ist kein Spieler!
metamorph.error.morph.nbt=Beim Daten-Tag-Parsing ist ein Fehler aufgetreten:\n%s
metamorph.error.morph.factory=Could not morph into %2$s with given data tag
metamorph.error.acquire=Konnte keinen Morph namens %s erwerben!
metamorph.success.morph=Spieler namens %s wurde erfolgreich in %s gemorpht!
metamorph.success.demorph=Spieler namens %s wurde erfolgreich gedemorpht!
metamorph.success.acquire=Spieler namens %s hat erfolgreich den Morph %s erworben!

# Morph categories
morph.category.generic=Unsorted morphs
morph.category.animal=Tiermorphs
morph.category.boss=Boss morphs
morph.category.acquired=Deine Morphs
morph.category.hostile=Feindliche Morphs
morph.category.modded=Morphs von %s
morph.category.recent=Recent morphs

# Morph sections and categories
morph.section.entity=Entity morphs (Metamorph)
morph.section.user=User morphs

==================================================

--- Файл №185 ---
Путь: main\resources\assets\metamorph\lang\en_US.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=Use action
key.metamorph.creative_menu=Open creative morph menu
key.metamorph.selector_menu=Open entity selectors menu
key.metamorph.survival_menu=Open survival morph menu
key.metamorph.demorph=Demorph (turn back to player)

# GUI
metamorph.gui.body_parts.pick=Pick morph
metamorph.gui.body_parts.use_target=Use target
metamorph.gui.body_parts.enabled=Enabled
metamorph.gui.body_parts.animate=Animate
metamorph.gui.body_parts.animate_tooltip=This option enables animation of body part's transformations when parent morph gets animated
metamorph.gui.body_parts.parts=Body parts
metamorph.gui.body_parts.limbs=Limbs
metamorph.gui.body_parts.open=Open body parts
metamorph.gui.body_parts.add_tooltip=Add a new body part...
metamorph.gui.body_parts.dupe_tooltip=Dupe currently selected body part...
metamorph.gui.body_parts.remove_tooltip=Remove currently selected body part...
metamorph.gui.body_parts.copy_tooltip=Copy all body parts...
metamorph.gui.body_parts.paste_tooltip=Paste copied body parts...
metamorph.gui.body_parts.keys.select_prev=Select previous body part
metamorph.gui.body_parts.keys.select_next=Select next body part
metamorph.gui.body_parts.context.copy=Copy body part
metamorph.gui.body_parts.context.paste=Paste copied body part

metamorph.gui.add=Add
metamorph.gui.remove=Remove
metamorph.gui.morph=Morph
metamorph.gui.acquire=Acquire
metamorph.gui.acquired=Acquired
metamorph.gui.close=Close
metamorph.gui.search=Search
metamorph.gui.no_morph=No morph selected...
metamorph.gui.morph_render_error=Error occurred rendering this morph

metamorph.gui.selectors.title=Entity selectors
metamorph.gui.selectors.tooltip=With this feature, you can add morphs to entities by specific name or their type...
metamorph.gui.selectors.add=Add a selector
metamorph.gui.selectors.remove=Remove a selector
metamorph.gui.selectors.name=Name
metamorph.gui.selectors.type=Type
metamorph.gui.selectors.match=Matching NBT
metamorph.gui.selectors.match_tooltip=Here you can specify an NBT tag that has to partially match entity's NBT tag
metamorph.gui.selectors.enabled=Enabled

metamorph.gui.morphs.keys.category=Morph navigation
metamorph.gui.morphs.keys.up=Select morph above
metamorph.gui.morphs.keys.down=Select morph below
metamorph.gui.morphs.keys.right=Select morph to the right
metamorph.gui.morphs.keys.left=Select morph to the left

metamorph.gui.creative.command=Copy /morph command for selected morph
metamorph.gui.creative.edit=Edit
metamorph.gui.creative.pick=Pick
metamorph.gui.creative.quick=Quick edit
metamorph.gui.creative.presets=Presets
metamorph.gui.creative.random=Random preset
metamorph.gui.creative.keys.category=Creative morph menu
metamorph.gui.creative.keys.exit=Exit the morph editor
metamorph.gui.creative.keys.edit=Edit currently selected morph
metamorph.gui.creative.keys.focus=Focus search bar
metamorph.gui.creative.keys.quick=Toggle quick edit menu
metamorph.gui.creative.keys.acquire=Acquire currently selected morph
metamorph.gui.creative.keys.morph=Morph into currently selected morph
metamorph.gui.creative.context.add_global=Add to global morphs...
metamorph.gui.creative.context.edit=Edit morph...
metamorph.gui.creative.context.add_category=Add a new category
metamorph.gui.creative.context.rename_category=Rename category
metamorph.gui.creative.context.rename_category_modal=Give a new name to given category...
metamorph.gui.creative.context.remove_category=Remove category
metamorph.gui.creative.context.remove_morph_modal=Are you sure you want to remove this morph? It will be gone forever...
metamorph.gui.creative.context.remove_category_modal=Are you sure you want to remove this morph category? It will be gone forever...
metamorph.gui.creative.context.clear_category=Remove all morphs
metamorph.gui.creative.context.clear_category_modal=Are you sure you want to remove all morphs in this category? It will be gone forever... 
metamorph.gui.creative.context.to_recent=Copy to recent
metamorph.gui.creative.context.remove_morph=Remove the morph
metamorph.gui.creative.context.copy_command=Copy /morph command
metamorph.gui.creative.context.copy=Copy NBT
metamorph.gui.creative.context.paste=Paste NBT
metamorph.gui.creative.context.paste_modal=Paste or input the NBT tag of your morph...

metamorph.gui.survival.title=Survival Morph Menu
metamorph.gui.survival.keybind_tooltip=With this field, you can bind a key which will morph you into this particular morph (when you press it either in this menu or in the world)
metamorph.gui.survival.only_favorites=Only favorites
metamorph.gui.survival.favorite=Favorite
metamorph.gui.survival.keys.category=Survival morph menu
metamorph.gui.survival.keys.toggle_favorites=Toggle favorite morphs
metamorph.gui.survival.keys.focus_keybind=Focus keybind

metamorph.gui.editor.entity=Entity properties
metamorph.gui.editor.settings=Morph settings
metamorph.gui.editor.keybind=Keybind
metamorph.gui.editor.keybind_tooltip=Setting keybind here will allow you to morph into this morph by pressing this key either in the world or in survival morph menu
metamorph.gui.editor.display_name=Display name
metamorph.gui.editor.health=Health
metamorph.gui.editor.speed=Speed
metamorph.gui.editor.abilities=Abilities
metamorph.gui.editor.abilities_tooltip=Shift + click on the abilities in the list, to select multiple abilities
metamorph.gui.editor.attack=Attack
metamorph.gui.editor.action=Action
metamorph.gui.editor.reset=Reset
metamorph.gui.editor.item_morph=Item
metamorph.gui.editor.scale=Entity scale
metamorph.gui.editor.texture=Pick a texture...
metamorph.gui.editor.texture_tooltip=This feature won't work for all mobs, because some mobs can have custom rendering implementation
metamorph.gui.editor.keys.category=Morph editor keybinds
metamorph.gui.editor.keys.cycle=Cycle between morph panels
metamorph.gui.creative.keys.onionskin=Toggle onion skins
metamorph.gui.editor.shadow.all=Render all
metamorph.gui.editor.shadow.noshadow=No shadow
metamorph.gui.editor.shadow.onlyshadow=Only shaodws
metamorph.gui.editor.betterlights_shadow=Shadow

metamorph.gui.editor.hitbox.enabled=Custom hitbox
metamorph.gui.editor.hitbox.size=Size
metamorph.gui.editor.hitbox.width=Hitbox width
metamorph.gui.editor.hitbox.height=Hitbox height
metamorph.gui.editor.hitbox.sneaking_height=Hitbox sneaking height
metamorph.gui.editor.hitbox.eye=Eye position
metamorph.gui.editor.hitbox.eye_tooltip=Eye height factor of the height, where 0 is at the bottom and 1 on the top of the hitbox

metamorph.gui.label.label=Label
metamorph.gui.label.max_width=Max width
metamorph.gui.label.anchor=Anchor
metamorph.gui.label.color=Text color
metamorph.gui.label.shadow=Shadow
metamorph.gui.label.shadow_offset=Shadow offset
metamorph.gui.label.shadow_color=Shadow color
metamorph.gui.label.lighting=Lighting
metamorph.gui.label.lighting_tooltip=When disabled, Minecraft's lightmap won't be applied, meaning it would glow in the dark. Shader packs, that have bloom effect, will make this morph look like neon sign
metamorph.gui.label.background=Background
metamorph.gui.label.billboard=Look at player

metamorph.gui.item.animation=Animation
metamorph.gui.item.item_from_equipment=From equipment
metamorph.gui.item.transform.none=None
metamorph.gui.item.transform.third_person_left_hand=Left hand (3rd)
metamorph.gui.item.transform.third_person_right_hand=Right hand (3rd)
metamorph.gui.item.transform.first_person_left_hand=Left hand (1st)
metamorph.gui.item.transform.first_person_right_hand=Right hand (1st)
metamorph.gui.item.transform.head=On head
metamorph.gui.item.transform.gui=Inventory
metamorph.gui.item.transform.ground=On ground
metamorph.gui.item.transform.fixed=Item frame
metamorph.gui.item.equipment_slot.mainhand=Main hand
metamorph.gui.item.equipment_slot.offhand=Off hand
metamorph.gui.item.equipment_slot.feet=Feet
metamorph.gui.item.equipment_slot.legs=Legs
metamorph.gui.item.equipment_slot.chest=Chest
metamorph.gui.item.equipment_slot.head=Head

metamorph.gui.edit=Edit
metamorph.gui.panels.nbt_data=NBT data
metamorph.gui.panels.username=Username
metamorph.gui.panels.updating=Updating...

metamorph.gui.animation.animates=Animates
metamorph.gui.animation.ignored=Ignored
metamorph.gui.animation.animation_duration=Duration
metamorph.gui.animation.pick_interpolation=Pick interpolation

metamorph.gui.status.tight_space=There is not enough space to morph here

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=Morph acquiring
metamorph.config.acquiring.tooltip=All the options related to ways of getting morphs

metamorph.config.acquiring.prevent_ghosts=Prevent ghost
metamorph.config.comments.acquiring.prevent_ghosts=Prevents ghosts from spawning if the player has already a currently killed mob's morph
metamorph.config.acquiring.prevent_kill_acquire=Prevent acquiring by killing
metamorph.config.comments.acquiring.prevent_kill_acquire=Prevent acquiring morphs by killing morphs
metamorph.config.acquiring.acquire_immediately=Acquire morph immediately
metamorph.config.comments.acquiring.acquire_immediately=Acquires morph immediately after player kills an entity instead of spawning a ghost

metamorph.config.morphs.title=Morphs
metamorph.config.morphs.tooltip=All the options related to morphing and morph settings

metamorph.config.morphs.keep_morphs=Retain morphs on death
metamorph.config.comments.morphs.keep_morphs=Retain morphs when player died
metamorph.config.morphs.disable_pov=Disable POV
metamorph.config.comments.morphs.disable_pov=Disable modifying Point-of-View. Requested because of MorePlayerModels
metamorph.config.morphs.disable_health=Disable health scaling
metamorph.config.comments.morphs.disable_health=Disable modifying health. Requested because of Tough as Nails
metamorph.config.morphs.disable_morph_animation=Disable morph animation
metamorph.config.comments.morphs.disable_morph_animation=Disables morphing animation
metamorph.config.morphs.disable_morph_disguise=Disable morph hostility
metamorph.config.comments.morphs.disable_morph_disguise=Disable the ability of morphs labeled as "hostile" to avoid being attacked by hostile mobs
metamorph.config.morphs.disable_first_person_hand=Disable first person hand
metamorph.config.comments.morphs.disable_first_person_hand=Completely hide first person hand rendering
metamorph.config.morphs.morph_in_tight_spaces=Allow morphing in tight spaces
metamorph.config.comments.morphs.morph_in_tight_spaces=Allows morphing even if it could cause suffocation and allow passing through walls
metamorph.config.morphs.show_morph_idle_sounds=Show morph idle sounds
metamorph.config.comments.morphs.show_morph_idle_sounds=Whether players make entity idle sounds when morphed
metamorph.config.morphs.pause_gui_in_sp=Pause morph GUIs
metamorph.config.comments.morphs.pause_gui_in_sp=Whether creative and survival morph GUIs should be paused in singleplayer
metamorph.config.morphs.max_recent_morphs=Max. recent morphs
metamorph.config.comments.morphs.max_recent_morphs=The maximum amount of recent morphs that can be added in the morph menu before being discarded
metamorph.config.morphs.allow_morphing_into_category_morphs=Allow morphing into category morphs
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=When enabled, this option allows to morph into recent and custom category morphs while being in survival. This option also allows to open creative morph menu in survival
metamorph.config.morphs.load_entity_morphs=Load entity morphs
metamorph.config.comments.morphs.load_entity_morphs=Whether entity morphs should be loaded in creative morph menu
metamorph.config.morphs.render_bodypart_axis=Render Axis for body parts
metamorph.config.comments.morphs.render_bodypart_axis=When enabled, body part axes are displayed in the body part editor GUI

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Metamorph's OP access options

op_access.config.metamorph.entity_selectors=Entity selectors
op_access.config.comments.metamorph.entity_selectors=Can non-OP players edit entity selectors?

# Commands
metamorph.commands.morph=Morph command. This command is responsible for morphing player into specified morph.\n\n/morph <username> [morph_name] [data_tag]
metamorph.commands.acquire_morph=Acquire morph command. This command is responsible for sending a morph to a player in acquired morphs.\n\n/morph <username> <morph_name> [data_tag]
metamorph.commands.metamorph=Metamorph server command. This command allows to manage Metamorph stuff on the server side.\n\n/metamorph reload <blacklist|morphs> - reloads Metamorph's blacklist or morph configuration

metamorph.error.morph.not_player=Entity %s isn't not a player!
metamorph.error.morph.nbt=Error occurred during data tag parsing:\n%s
metamorph.error.morph.factory=Could not morph into %2$s with given data tag
metamorph.error.acquire=Couldn't acquire a morph by name %s!
metamorph.success.morph=Player by username %s was successfully morphed into %s!
metamorph.success.demorph=Player by username %s was successfully demorphed!
metamorph.success.acquire=Player by username %s was successfully acquired %s morph!

# Morph categories
morph.category.generic=Unsorted morphs
morph.category.animal=Animal morphs
morph.category.boss=Boss morphs
morph.category.acquired=Your morphs
morph.category.hostile=Hostile morphs
morph.category.modded=Morphs from %s
morph.category.recent=Recent morphs

# Morph sections and categories
morph.section.entity=Entity morphs (Metamorph)
morph.section.user=User morphs

==================================================

--- Файл №186 ---
Путь: main\resources\assets\metamorph\lang\es_ES.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=Acción de uso
key.metamorph.creative_menu=Abrir Menú Morphs para el modo Creativo
key.metamorph.selector_menu=Abrir Menú Selector de entidades
key.metamorph.survival_menu=Abrir Menú Morphs para el modo Supervivencia
key.metamorph.demorph=Eliminar morph (Recupera el aspecto antiguo)

# GUI
metamorph.gui.body_parts.pick=Elegir morph
metamorph.gui.body_parts.use_target=Usar objetivo
metamorph.gui.body_parts.enabled=Activado
metamorph.gui.body_parts.animate=Animar
metamorph.gui.body_parts.animate_tooltip=Esta opción habilita las animaciones de las partes del cuerpo a las cuales se les ha asignado un morph
metamorph.gui.body_parts.parts=Partes del cuerpo
metamorph.gui.body_parts.limbs=Extremidades
metamorph.gui.body_parts.open=Abrir Menú Partes del cuerpo
metamorph.gui.body_parts.add_tooltip=Añadir una nueva parte del cuerpo..
metamorph.gui.body_parts.dupe_tooltip=Duplicar parte del cuerpo seleccionada...
metamorph.gui.body_parts.remove_tooltip=Elimina la parte del cuerpo seleccionada...
metamorph.gui.body_parts.copy_tooltip=Copiar todas las partes del cuerpo...
metamorph.gui.body_parts.paste_tooltip=Pegar todas las partes del cuerpo...
metamorph.gui.body_parts.context.copy=Copiar todas las partes del cuerpo
metamorph.gui.body_parts.context.paste=Pegar partes del cuerpo copiadas

metamorph.gui.add=Agregar
metamorph.gui.remove=Eliminar
metamorph.gui.morph=Morph
metamorph.gui.acquire=Adquirir
metamorph.gui.acquired=Adquirido
metamorph.gui.close=Cerrar
metamorph.gui.search=Buscar
metamorph.gui.no_morph=No se seleccionó ningún morph...
metamorph.gui.morph_render_error=Se produjo un error al procesar este morph

metamorph.gui.selectors.title=Selector de entidades
metamorph.gui.selectors.tooltip=Con esta característica, puedes agregar morphs a entidades por nombre específico o por su tipo...
metamorph.gui.selectors.add=Agregar un selector
metamorph.gui.selectors.remove=Eliminar un selector
metamorph.gui.selectors.name=Nombre
metamorph.gui.selectors.type=Tipo
metamorph.gui.selectors.match=Coincidencia NBT
metamorph.gui.selectors.match_tooltip=Aquí puedes espicificar una etiqueta NBT que debe coincidir parcialmente con la etiqueta NBT de la entidad
metamorph.gui.selectors.enabled=Activado

metamorph.gui.morphs.keys.category=Navegador de moprhs
metamorph.gui.morphs.keys.up=Seleccionar morph de arriba
metamorph.gui.morphs.keys.down=Seleccionar morph de abajo
metamorph.gui.morphs.keys.right=Seleccionar morph de la derecha
metamorph.gui.morphs.keys.left=Seleccionar morph de la izquierda

metamorph.gui.creative.command=Copiar comando /morph para el morph seleccionado
metamorph.gui.creative.edit=Editar
metamorph.gui.creative.pick=Escoger
metamorph.gui.creative.quick=Edición rápida
metamorph.gui.creative.presets=Preajustes
metamorph.gui.creative.random=Preajuste aleatorio
metamorph.gui.creative.keys.category=Menú Morphs del modo Creativo
metamorph.gui.creative.keys.exit=Salir del editor de morph
metamorph.gui.creative.keys.edit=Editar morph seleccionada
metamorph.gui.creative.keys.focus=Enfocar barra de búsqueda
metamorph.gui.creative.keys.quick=Alternar menú de edición rápida
metamorph.gui.creative.keys.acquire=Adquirir el morph seleccionado
metamorph.gui.creative.keys.morph=Transformar en morph seleccionado
metamorph.gui.creative.context.add_global=Agregar a Morphs globales...
metamorph.gui.creative.context.edit=Editar morph...
metamorph.gui.creative.context.add_category=Agregar una nueva categoría
metamorph.gui.creative.context.rename_category=Renombrar categoría
metamorph.gui.creative.context.rename_category_modal=Agrega un nombre a dicha categoría...
metamorph.gui.creative.context.remove_category=Eliminar categoría
metamorph.gui.creative.context.remove_morph_modal=Are you sure you want to remove this morph? It will be gone forever...
metamorph.gui.creative.context.remove_category_modal=¿Estás seguro que quieres borrar esta categoría de morph? Será eliminado para siempre...
metamorph.gui.creative.context.clear_category=Eliminar todos los morphs
metamorph.gui.creative.context.clear_category_modal=¿Estás seguro que quieres eliminar todos los morphs en esta categpría? Será eliminado para siempre... 
metamorph.gui.creative.context.to_recent=Copiar a reciente
metamorph.gui.creative.context.remove_morph=Eliminar morph
metamorph.gui.creative.context.copy_command=Copiar /morph command
metamorph.gui.creative.context.copy=Copiar NBT
metamorph.gui.creative.context.paste=Pegar NBT
metamorph.gui.creative.context.paste_modal=Pegue o ingrese la etiqueta NBT de su morph...

metamorph.gui.survival.title=Menú Morphs del modo Supervivencia
metamorph.gui.survival.keybind_tooltip=Con este campo puedes vincular una tecla que te transformará en este morph en particular(aunque la presiones en este menú o en el mundo)
metamorph.gui.survival.only_favorites=Solo favoritos
metamorph.gui.survival.favorite=Favoritos
metamorph.gui.survival.keys.category=Menú Morphs del modo Supervivencia
metamorph.gui.survival.keys.toggle_favorites=Alternar morphs favoritas
metamorph.gui.survival.keys.focus_keybind=Enfocar combinación de teclas

metamorph.gui.editor.entity=Entity properties
metamorph.gui.editor.settings=Ajustes de morph
metamorph.gui.editor.keybind=Combinación de teclas
metamorph.gui.editor.keybind_tooltip=Configurar la combinación de teclas aquí le permitirá transformarse en este morph pulsando esta tecla ya sea en el Modo Supervivencia o el Menú Morphs
metamorph.gui.editor.display_name=Nombre a mostar
metamorph.gui.editor.health=Vida
metamorph.gui.editor.speed=Velocidad
metamorph.gui.editor.abilities=Habilidades
metamorph.gui.editor.abilities_tooltip=Shift + click en la lista de habilidades para seleccionar múltiples habilidades
metamorph.gui.editor.attack=Atacar
metamorph.gui.editor.action=Acción
metamorph.gui.editor.reset=Reniciar
metamorph.gui.editor.item_morph=Item
metamorph.gui.editor.scale=Entity scale
metamorph.gui.editor.texture=Pick a texture...
metamorph.gui.editor.texture_tooltip=This feature won't work for all mobs, because some mobs can have custom rendering implementation
metamorph.gui.editor.keys.category=Combinación de teclas del Editor de Morphs
metamorph.gui.editor.keys.cycle=Ciclo entre paneles de morphs

metamorph.gui.editor.hitbox.enabled=Casillas personalidaas
metamorph.gui.editor.hitbox.size=tamaño
metamorph.gui.editor.hitbox.width=Ancho de la casilla
metamorph.gui.editor.hitbox.height=Altura de la casilla
metamorph.gui.editor.hitbox.sneaking_height=Hitbox sneaking height
metamorph.gui.editor.hitbox.eye=Posición de los ojos
metamorph.gui.editor.hitbox.eye_tooltip=Factor de altura del ojo, donde 0 está en la parte inferior y 1 en la parte superior de la casilla

metamorph.gui.label.label=Etiqueta
metamorph.gui.label.max_width=Anchura máxima
metamorph.gui.label.anchor=Anclaje
metamorph.gui.label.color=Color del texto
metamorph.gui.label.shadow=Sombra
metamorph.gui.label.shadow_offset=Desplazamiento de sombra
metamorph.gui.label.shadow_color=Color de sombra
metamorph.gui.label.lighting=Iluminación
metamorph.gui.label.lighting_tooltip=Cuando está deshabilitado, el lightmap de Minecraft no se aplicará, lo que significa que brillará en la oscuridad. Los Shaders, que tengan incluído el efecto Bloom, harán que este morph parezca un cartel de Neón
metamorph.gui.label.background=Fondo
metamorph.gui.label.billboard=Mira al jugador

metamorph.gui.edit=Editar
metamorph.gui.panels.nbt_data=Datos NBT
metamorph.gui.panels.username=Nombre de usuario
metamorph.gui.panels.updating=Actualizando...

metamorph.gui.animation.animates=Anima
metamorph.gui.animation.ignored=Ignorado
metamorph.gui.animation.animation_duration=Duración
metamorph.gui.animation.pick_interpolation=Elegir interpolación

metamorph.gui.status.tight_space=No hay suficiente espacio para transformar aquí

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=Adquisición del morph
metamorph.config.acquiring.tooltip=Todas las opciones relacionadas con las formas de obtener morphs

metamorph.config.acquiring.prevent_ghosts=Prevenir fantasmas
metamorph.config.comments.acquiring.prevent_ghosts=Evita que aparezca el fantasma del jugador si este ya tiene asignado un morph para usar después de haber muerto
metamorph.config.acquiring.prevent_kill_acquire=Evitar adquirir un morph al matar
metamorph.config.comments.acquiring.prevent_kill_acquire=Evitar la adqusición de morphs al matar a otros morphs
metamorph.config.acquiring.acquire_immediately=Adquirir morph inmediatamente
metamorph.config.comments.acquiring.acquire_immediately=Aquirir un morph inmediatamente después de que el jugador mate a una entidad en lugar de generar un fantasma

metamorph.config.morphs.title=Morphs
metamorph.config.morphs.tooltip=Todas las opciones relacionadas con la transformación y los ajustes de morphs

metamorph.config.morphs.keep_morphs=Conservar morph al morir
metamorph.config.comments.morphs.keep_morphs=EL jugador conserva su morph incluso después de morir
metamorph.config.morphs.disable_pov=Desactivar POV
metamorph.config.comments.morphs.disable_pov=Desactivar la modificaión del punto de vista. Solicitado debido a MorePlayerModel
metamorph.config.morphs.disable_health=Desactivar la escala de salud
metamorph.config.comments.morphs.disable_health=Desactivar la modificación de salud. Solicitado debido a Tough as Nails
metamorph.config.morphs.disable_morph_animation=Morphs sin animaciones
metamorph.config.comments.morphs.disable_morph_animation=Desactiva las animaciones de los morphs
metamorph.config.morphs.disable_morph_disguise=Desactivar la hostilidad de los morphs
metamorph.config.comments.morphs.disable_morph_disguise=Desactiva la hostilidad de los morph nombrados como "hostiles" para evitar ser atacados por entidades hostiles
metamorph.config.morphs.disable_first_person_hand=Desactivar la mano en primera persona
metamorph.config.comments.morphs.disable_first_person_hand=Oculta completamente la mano en primera persona
metamorph.config.morphs.morph_in_tight_spaces=Transformación en espacios reducidos	
metamorph.config.comments.morphs.morph_in_tight_spaces=Permite transformarse en lugares estrechos incluso si pudiera causar asfixia y/o permitir el paso a través de paredes
metamorph.config.morphs.show_morph_idle_sounds=Mostrar sonidos de morphs inactivos
metamorph.config.comments.morphs.show_morph_idle_sounds=Si los jugadores hacen una entidad inactiva emitirá sonidos cuando se transforme
metamorph.config.morphs.pause_gui_in_sp=Pausar las GUIs de Morphs
metamorph.config.comments.morphs.pause_gui_in_sp=Las GUI de Morphs de los modos Creativo y Supervivencia deben detenerse en el modo Un solo jugador
metamorph.config.morphs.max_recent_morphs=Máx. de morphs recientes
metamorph.config.comments.morphs.max_recent_morphs=La cantidad máxima de morphs recientes que se pueden agregar en el menú de morphs antes de ser descartadas
metamorph.config.morphs.allow_morphing_into_category_morphs=Permite transformarse en moprhs de la categoría
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=Cuando está habilitada, esta opción permite transformarse en morphs de categorías recientes y personalizadas mientras está en supervivencia. Esta opción también permite abrir el Menú de Morphs creativo en supervivencia
metamorph.config.morphs.load_entity_morphs=Cargar morphs de entidade
metamorph.config.comments.morphs.load_entity_morphs=Si los morphs de entidades deben cargarse en el Menú de Morph para el Modo Creativo
metamorph.config.morphs.render_bodypart_axis=Mostrar ejes de las partes del cuerpo
metamorph.config.comments.morphs.render_bodypart_axis=Cuando está habilitadolas los ejes de las partes del cuerpo se muestran en la GUI del editor de partes del cuerpo

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Opciones de acceso OP de Metamorph

op_access.config.metamorph.entity_selectors=Selectores de entidades
op_access.config.comments.metamorph.entity_selectors=¿Pueden los jugadores no OP editar selectores de entidades?

# Commands
metamorph.commands.morph=Comando Morph. Este comando es responsable de transformar al jugador en un morph específico.\n\n/morph <username> [morph_name] [data_tag]
metamorph.commands.acquire_morph=Comando Acquire morph. Este comando es responsable de enviar un morph a un jugador en Morphs adquiridas.\n\n/morph <username> <morph_name> [data_tag]
metamorph.commands.metamorph=Comando Metamorph server. Este comando permite administrar las cosas de Metamorph en el servidor.\n\n/metamorph reload <blacklist|morphs> - recarga la lista negra de Metamorph o la configuración de morph

metamorph.error.morph.not_player=Entidad %s no es un jugador!
metamorph.error.morph.nbt=Ocurrió un error durante el análisis de la etiqueta de datos:\n%s
metamorph.error.morph.factory=Imposible transformar en %2$s con esta etiqueta de datos
metamorph.error.acquire=Imposible adquirir un morph con el nombre %s!
metamorph.success.morph=El jugador %s fue exitosamente transformado en %s!
metamorph.success.demorph=El jugador con el nombre %s fue exitosamente destransformado!
metamorph.success.acquire=El jugador %s adquirió exitosamente el morph %s!

# Morph categories
morph.category.generic=Morphs sin clasificar
morph.category.animal=Morphs de animales
morph.category.boss=Morphs de jefes
morph.category.acquired=Tus morphs
morph.category.hostile=Morphs hostiles
morph.category.modded=Morphs de %s
morph.category.recent=Morphs recientes

# Morph sections and categories
morph.section.entity=Morphs de las entidades (Metamorph)
morph.section.user=Morphs del usuario

==================================================

--- Файл №187 ---
Путь: main\resources\assets\metamorph\lang\fr_FR.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=Use action
key.metamorph.creative_menu=Ouvrir le menu morph créatif
key.metamorph.selector_menu=Open entity selectors menu
key.metamorph.survival_menu=Ouvrir le menu morph survie
key.metamorph.demorph=Demorph (turn back to player)

# GUI
metamorph.gui.body_parts.pick=Pick morph
metamorph.gui.body_parts.use_target=Use target
metamorph.gui.body_parts.enabled=Enabled
metamorph.gui.body_parts.animate=Animate
metamorph.gui.body_parts.animate_tooltip=This option enables animation of body part's transformations when parent morph gets animated
metamorph.gui.body_parts.parts=Body parts
metamorph.gui.body_parts.limbs=Limbs
metamorph.gui.body_parts.open=Open body parts
metamorph.gui.body_parts.add_tooltip=Add a new body part...
metamorph.gui.body_parts.dupe_tooltip=Dupe currently selected body part...
metamorph.gui.body_parts.remove_tooltip=Remove currently selected body part...
metamorph.gui.body_parts.copy_tooltip=Copy all body parts...
metamorph.gui.body_parts.paste_tooltip=Paste copied body parts...
metamorph.gui.body_parts.context.copy=Copy body part
metamorph.gui.body_parts.context.paste=Paste copied body part

metamorph.gui.add=Ajouter
metamorph.gui.remove=Retirer
metamorph.gui.morph=Morph
metamorph.gui.acquire=Choisir
metamorph.gui.acquired=Acquired
metamorph.gui.close=Fermer
metamorph.gui.search=Rechercher
metamorph.gui.no_morph=Aucun Morph selectionné
metamorph.gui.morph_render_error=Error occurred rendering this morph

metamorph.gui.selectors.title=Entity selectors
metamorph.gui.selectors.tooltip=With this feature, you can add morphs to entities by specific name or their type...
metamorph.gui.selectors.add=Add a selector
metamorph.gui.selectors.remove=Remove a selector
metamorph.gui.selectors.name=Name
metamorph.gui.selectors.type=Type
metamorph.gui.selectors.match=Matching NBT
metamorph.gui.selectors.match_tooltip=Here you can specify an NBT tag that has to partially match entity's NBT tag
metamorph.gui.selectors.enabled=Enabled

metamorph.gui.morphs.keys.category=Morph navigation
metamorph.gui.morphs.keys.up=Select morph above
metamorph.gui.morphs.keys.down=Select morph below
metamorph.gui.morphs.keys.right=Select morph to the right
metamorph.gui.morphs.keys.left=Select morph to the left

metamorph.gui.creative.command=Copy /morph command for selected morph
metamorph.gui.creative.edit=Edit
metamorph.gui.creative.pick=Pick
metamorph.gui.creative.quick=Quick edit
metamorph.gui.creative.presets=Presets
metamorph.gui.creative.random=Random preset
metamorph.gui.creative.keys.category=Creative morph menu
metamorph.gui.creative.keys.exit=Exit the morph editor
metamorph.gui.creative.keys.edit=Edit currently selected morph
metamorph.gui.creative.keys.focus=Focus search bar
metamorph.gui.creative.keys.quick=Toggle quick edit menu
metamorph.gui.creative.keys.acquire=Acquire currently selected morph
metamorph.gui.creative.keys.morph=Morph into currently selected morph
metamorph.gui.creative.context.add_global=Add to global morphs...
metamorph.gui.creative.context.edit=Edit morph...
metamorph.gui.creative.context.add_category=Add a new category
metamorph.gui.creative.context.rename_category=Rename category
metamorph.gui.creative.context.rename_category_modal=Give a new name to given category...
metamorph.gui.creative.context.remove_category=Remove category
metamorph.gui.creative.context.remove_morph_modal=Are you sure you want to remove this morph? It will be gone forever...
metamorph.gui.creative.context.remove_category_modal=Are you sure you want to remove this morph category? It will be gone forever...
metamorph.gui.creative.context.clear_category=Remove all morphs
metamorph.gui.creative.context.clear_category_modal=Are you sure you want to remove all morphs in this category? It will be gone forever... 
metamorph.gui.creative.context.to_recent=Copy to recent
metamorph.gui.creative.context.remove_morph=Remove the morph
metamorph.gui.creative.context.copy_command=Copy /morph command
metamorph.gui.creative.context.copy=Copy NBT
metamorph.gui.creative.context.paste=Paste NBT
metamorph.gui.creative.context.paste_modal=Paste or input the NBT tag of your morph...

metamorph.gui.survival.title=Survival Morph Menu
metamorph.gui.survival.keybind_tooltip=With this field, you can bind a key which will morph you into this particular morph (when you press it either in this menu or in the world)
metamorph.gui.survival.only_favorites=Only favorites
metamorph.gui.survival.favorite=Favorite
metamorph.gui.survival.keys.category=Survival morph menu
metamorph.gui.survival.keys.toggle_favorites=Toggle favorite morphs
metamorph.gui.survival.keys.focus_keybind=Focus keybind

metamorph.gui.editor.entity=Entity properties
metamorph.gui.editor.settings=Morph settings
metamorph.gui.editor.keybind=Keybind
metamorph.gui.editor.keybind_tooltip=Setting keybind here will allow you to morph into this morph by pressing this key either in the world or in survival morph menu
metamorph.gui.editor.display_name=Display name
metamorph.gui.editor.health=Health
metamorph.gui.editor.speed=Speed
metamorph.gui.editor.abilities=Abilities
metamorph.gui.editor.abilities_tooltip=Shift + click on the abilities in the list, to select multiple abilities
metamorph.gui.editor.attack=Attack
metamorph.gui.editor.action=Action
metamorph.gui.editor.reset=Reset
metamorph.gui.editor.item_morph=Item
metamorph.gui.editor.scale=Entity scale
metamorph.gui.editor.texture=Pick a texture...
metamorph.gui.editor.texture_tooltip=This feature won't work for all mobs, because some mobs can have custom rendering implementation
metamorph.gui.editor.keys.category=Morph editor keybinds
metamorph.gui.editor.keys.cycle=Cycle between morph panels

metamorph.gui.editor.hitbox.enabled=Custom hitbox
metamorph.gui.editor.hitbox.size=Size
metamorph.gui.editor.hitbox.width=Hitbox width
metamorph.gui.editor.hitbox.height=Hitbox height
metamorph.gui.editor.hitbox.sneaking_height=Hitbox sneaking height
metamorph.gui.editor.hitbox.eye=Eye position
metamorph.gui.editor.hitbox.eye_tooltip=Eye height factor of the height, where 0 is at the bottom and 1 on the top of the hitbox

metamorph.gui.label.label=Label
metamorph.gui.label.max_width=Max width
metamorph.gui.label.anchor=Anchor
metamorph.gui.label.color=Text color
metamorph.gui.label.shadow=Shadow
metamorph.gui.label.shadow_offset=Shadow offset
metamorph.gui.label.shadow_color=Shadow color
metamorph.gui.label.lighting=Lighting
metamorph.gui.label.lighting_tooltip=When disabled, Minecraft's lightmap won't be applied, meaning it would glow in the dark. Shader packs, that have bloom effect, will make this morph look like neon sign
metamorph.gui.label.background=Background
metamorph.gui.label.billboard=Look at player

metamorph.gui.edit=Editer
metamorph.gui.panels.nbt_data=données NBT
metamorph.gui.panels.username=Nom d'utilisateur
metamorph.gui.panels.updating=Mise à jour...

metamorph.gui.animation.animates=Animates
metamorph.gui.animation.ignored=Ignored
metamorph.gui.animation.animation_duration=Duration
metamorph.gui.animation.pick_interpolation=Pick interpolation

metamorph.gui.status.tight_space=Il n'y a pas assez d'expace pour le morphing ici

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=Morph acquiring
metamorph.config.acquiring.tooltip=All the options related to ways of getting morphs

metamorph.config.acquiring.prevent_ghosts=Prevent ghost
metamorph.config.comments.acquiring.prevent_ghosts=Prevents ghosts from spawning if the player has already a currently killed mob's morph
metamorph.config.acquiring.prevent_kill_acquire=Prevent acquiring by killing
metamorph.config.comments.acquiring.prevent_kill_acquire=Prevent acquiring morphs by killing morphs
metamorph.config.acquiring.acquire_immediately=Acquire morph immediately
metamorph.config.comments.acquiring.acquire_immediately=Acquires morph immediately after player kills an entity instead of spawning a ghost

metamorph.config.morphs.title=Morphs
metamorph.config.morphs.tooltip=All the options related to morphing and morph settings

metamorph.config.morphs.keep_morphs=Retain morphs on death
metamorph.config.comments.morphs.keep_morphs=Retain morphs when player died
metamorph.config.morphs.disable_pov=Disable POV
metamorph.config.comments.morphs.disable_pov=Disable modifying Point-of-View. Requested because of MorePlayerModels
metamorph.config.morphs.disable_health=Disable health scaling
metamorph.config.comments.morphs.disable_health=Disable modifying health. Requested because of Tough as Nails
metamorph.config.morphs.disable_morph_animation=Disable morph animation
metamorph.config.comments.morphs.disable_morph_animation=Disables morphing animation
metamorph.config.morphs.disable_morph_disguise=Disable morph hostility
metamorph.config.comments.morphs.disable_morph_disguise=Disable the ability of morphs labeled as "hostile" to avoid being attacked by hostile mobs
metamorph.config.morphs.disable_first_person_hand=Disable first person hand
metamorph.config.comments.morphs.disable_first_person_hand=Completely hide first person hand rendering
metamorph.config.morphs.morph_in_tight_spaces=Allow morphing in tight spaces
metamorph.config.comments.morphs.morph_in_tight_spaces=Allows morphing even if it could cause suffocation and allow passing through walls
metamorph.config.morphs.show_morph_idle_sounds=Show morph idle sounds
metamorph.config.comments.morphs.show_morph_idle_sounds=Whether players make entity idle sounds when morphed
metamorph.config.morphs.pause_gui_in_sp=Pause morph GUIs
metamorph.config.comments.morphs.pause_gui_in_sp=Whether creative and survival morph GUIs should be paused in singleplayer
metamorph.config.morphs.max_recent_morphs=Max. recent morphs
metamorph.config.comments.morphs.max_recent_morphs=The maximum amount of recent morphs that can be added in the morph menu before being discarded
metamorph.config.morphs.allow_morphing_into_category_morphs=Allow morphing into category morphs
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=When enabled, this option allows to morph into recent and custom category morphs while being in survival. This option also allows to open creative morph menu in survival
metamorph.config.morphs.load_entity_morphs=Load entity morphs
metamorph.config.comments.morphs.load_entity_morphs=Whether entity morphs should be loaded in creative morph menu
metamorph.config.morphs.render_bodypart_axis=Render Axis for body parts
metamorph.config.comments.morphs.render_bodypart_axis=When enabled, body part axes are displayed in the body part editor GUI

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Metamorph's OP access options

op_access.config.metamorph.entity_selectors=Entity selectors
op_access.config.comments.metamorph.entity_selectors=Can non-OP players edit entity selectors?

# Commands
metamorph.commands.morph=Commande morph. Cette commande permet au joueur de se transformer en un morph.\n\n/morph <username> [morph_name] [data_tag]
metamorph.commands.acquire_morph=Commande pour l'acquisition de morph. Cette commande permet d'attribuer au joueur un morph parmis les morphs acquis.\n\n/morph <username> <morph_name> [data_tag]
metamorph.commands.metamorph=Commande Metamorph serveur. Cette commande permet la gestion de Metamoprh côté serveur.\n\n/metamorph reload <blacklist|morphs> - reloads Metamorph's blacklist or morph configuration

metamorph.error.morph.not_player=L'entité %s n'est pas un joueur!
metamorph.error.morph.nbt=Une erreur est surnevue lors de l'analyse des balises de données:\n%s
metamorph.error.morph.factory=Could not morph into %2$s with given data tag
metamorph.error.acquire=Impossible d'acquérir le morph de nom %s!
metamorph.success.morph=Le joueur %s a été transformé en morph %s!
metamorph.success.demorph=Le joueur %s a retrouvé son apparence !
metamorph.success.acquire=Le joueur %s a acquis le morph %s !

# Morph categories
morph.category.generic=Unsorted morphs
morph.category.animal=Morphs Animaux
morph.category.boss=Morphs Boss
morph.category.acquired=Vos morphs
morph.category.hostile=Morphs Hostiles
morph.category.modded=Morphs de %s
morph.category.recent=Recent morphs

# Morph sections and categories
morph.section.entity=Entity morphs (Metamorph)
morph.section.user=User morphs

==================================================

--- Файл №188 ---
Путь: main\resources\assets\metamorph\lang\pt_BR.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=Usar ação
key.metamorph.creative_menu=Abrir menu morph do criativo
key.metamorph.selector_menu=Abrir menu seletor de entidades
key.metamorph.survival_menu=Abrir menu morph do sobrêvivencia
key.metamorph.demorph=Demorph (Voltar para o jogador)

# GUI
metamorph.gui.body_parts.pick=Selecionar Morph
metamorph.gui.body_parts.use_target=Usar trajeto
metamorph.gui.body_parts.enabled=Habilitado
metamorph.gui.body_parts.animate=Animar
metamorph.gui.body_parts.animate_tooltip=This option enables animation of body part's transformations when parent morph gets animated
metamorph.gui.body_parts.parts=Partes do corpo
metamorph.gui.body_parts.limbs=Membros
metamorph.gui.body_parts.open=Abrir partes do corpo
metamorph.gui.body_parts.add_tooltip=Adicionar uma nova parte do corpo...
metamorph.gui.body_parts.dupe_tooltip=Duplicar a parte do corpo atualmente selecionada...
metamorph.gui.body_parts.remove_tooltip=Remover parte do corpo atualmente selecionada...
metamorph.gui.body_parts.copy_tooltip=Copiar todas as partes do corpo...
metamorph.gui.body_parts.paste_tooltip=Colar partes do corpo copiadas...
metamorph.gui.body_parts.keys.select_prev=Selecione a parte anterior do corpo
metamorph.gui.body_parts.keys.select_next=Selecione a próxima parte do corpo
metamorph.gui.body_parts.context.copy=Copiar parte do corpo
metamorph.gui.body_parts.context.paste=Colar parte do corpo

metamorph.gui.add=Adicionar
metamorph.gui.remove=Remover
metamorph.gui.morph=Morph
metamorph.gui.acquire=Adquirir
metamorph.gui.acquired=Adquirido
metamorph.gui.close=Fechar
metamorph.gui.search=Pesquisar
metamorph.gui.no_morph=Nenhum morph selecionado...
metamorph.gui.morph_render_error=Ocorreu um erro ao renderizar esse morph

metamorph.gui.selectors.title=Seletores de entidade
metamorph.gui.selectors.tooltip=Com esse recurso, você pode adicionar morphs a entidades por nome específico ou tipo...
metamorph.gui.selectors.add=Adicionar seletore
metamorph.gui.selectors.remove=Remover seletor
metamorph.gui.selectors.name=Nome
metamorph.gui.selectors.type=Tipo
metamorph.gui.selectors.match=NBT correspondente
metamorph.gui.selectors.match_tooltip=Aqui você pode especificar uma tag NBT que deve corresponder parcialmente à tag NBT da entidade
metamorph.gui.selectors.enabled=Habilitado

metamorph.gui.morphs.keys.category=Navegação de morph
metamorph.gui.morphs.keys.up=Selecionar morph acima
metamorph.gui.morphs.keys.down=Selecionar morph abaixo
metamorph.gui.morphs.keys.right=Selecionar morph à direita
metamorph.gui.morphs.keys.left=Selecionar morph à esquerda

metamorph.gui.creative.command=Copiar /morph command para o morph selecionado
metamorph.gui.creative.edit=Editar
metamorph.gui.creative.pick=Selecionar
metamorph.gui.creative.quick=Editar rápido
metamorph.gui.creative.presets=Predefinições
metamorph.gui.creative.random=Predefinição aleatoria
metamorph.gui.creative.keys.category=Menu de morph criativo
metamorph.gui.creative.keys.exit=Sair do editor de morph
metamorph.gui.creative.keys.edit=Editar morph atualmente selecionado
metamorph.gui.creative.keys.focus=Barra de pesquisa em foco
metamorph.gui.creative.keys.quick=Alternar menu de edição rápida
metamorph.gui.creative.keys.acquire=Adquirir morph atualmente selecionado
metamorph.gui.creative.keys.morph=Morph no morph atualmente selecionada
metamorph.gui.creative.context.add_global=Adicionar aos morphs globais...
metamorph.gui.creative.context.edit=Editar morph...
metamorph.gui.creative.context.add_category=Adicionar uma nova categoria
metamorph.gui.creative.context.rename_category=Renomear categoria
metamorph.gui.creative.context.rename_category_modal=Dê um novo nome a determinada categoria...
metamorph.gui.creative.context.remove_category=Remover categoria
metamorph.gui.creative.context.remove_morph_modal=Tem certeza de que deseja remover esse morph? Irá desaparecer para sempre...
metamorph.gui.creative.context.remove_category_modal=Tem certeza de que deseja remover esta categoria de morphs? Irá desaparecer para sempre...
metamorph.gui.creative.context.clear_category=Remover todos os morphs
metamorph.gui.creative.context.clear_category_modal=Tem certeza de que deseja remover todos os morphs nessa categoria? Irá desaparecer para sempre...
metamorph.gui.creative.context.to_recent=Copiar para recente
metamorph.gui.creative.context.remove_morph=Remover morph
metamorph.gui.creative.context.copy_command=Copiar /morph command
metamorph.gui.creative.context.copy=Copiar NBT
metamorph.gui.creative.context.paste=Colar NBT
metamorph.gui.creative.context.paste_modal=Cole ou insira a tag NBT do seu morph...

metamorph.gui.survival.title=Menu morph do sobrêvivencia
metamorph.gui.survival.keybind_tooltip=Com esse campo, você pode vincular uma tecla que irá transformá-lo nesse morph específico (quando você a pressiona neste menu ou no mundo)
metamorph.gui.survival.only_favorites=Apenas favoritos
metamorph.gui.survival.favorite=Favorito
metamorph.gui.survival.keys.category=Menu morph do sobrêvivencia
metamorph.gui.survival.keys.toggle_favorites=Alternar morphs favoritos
metamorph.gui.survival.keys.focus_keybind=Tecla de foco

metamorph.gui.editor.entity=Propriadades da entidade
metamorph.gui.editor.settings=Opções do morph
metamorph.gui.editor.keybind=Tecla
metamorph.gui.editor.keybind_tooltip=Definir o atalho de teclado aqui permitirá que você se transforme nesse morph selecionado dessa tecla no mundo ou no menu de metamorfose de sobrevivência
metamorph.gui.editor.display_name=Nome de exibição
metamorph.gui.editor.health=Vida
metamorph.gui.editor.speed=Velocidade
metamorph.gui.editor.abilities=Abilidades
metamorph.gui.editor.abilities_tooltip=Shift + clique nas habilidades da lista para selecionar múltiplas habilidades
metamorph.gui.editor.attack=Ataque
metamorph.gui.editor.action=Ação
metamorph.gui.editor.reset=Redefinir
metamorph.gui.editor.item_morph=Item
metamorph.gui.editor.scale=Tamnho da entidade
metamorph.gui.editor.texture=Selecionar textura...
metamorph.gui.editor.texture_tooltip=Esse recurso não funcionará para todos os mobs, porque alguns mobs podem ter implementação de renderização personalizada
metamorph.gui.editor.keys.category=Atalhos de teclado do editor Morph
metamorph.gui.editor.keys.cycle=Alternar entre painéis de morphs
metamorph.gui.creative.keys.onionskin=Alternar onion skins
metamorph.gui.editor.shadow.all=Renderizar todos
metamorph.gui.editor.shadow.noshadow=Sem sombra
metamorph.gui.editor.shadow.onlyshadow=Apenas sombras
metamorph.gui.editor.betterlights_shadow=Sombra

metamorph.gui.editor.hitbox.enabled=Hitbox personalizada
metamorph.gui.editor.hitbox.size=Tamanho
metamorph.gui.editor.hitbox.width=Largura da hitbox
metamorph.gui.editor.hitbox.height=Altura da hitbox
metamorph.gui.editor.hitbox.sneaking_height=Altura agachado da Hitbox
metamorph.gui.editor.hitbox.eye=Posição dos olhos
metamorph.gui.editor.hitbox.eye_tooltip=Fator de altura dos olhos da altura, onde 0 está na parte inferior e 1 na parte superior da hitbox

metamorph.gui.label.label=Título
metamorph.gui.label.max_width=Largura máxima
metamorph.gui.label.anchor=Âncora
metamorph.gui.label.color=Cor do texto
metamorph.gui.label.shadow=Sombra
metamorph.gui.label.shadow_offset=Deslocamento da sombra
metamorph.gui.label.shadow_color=Cor da sombra
metamorph.gui.label.lighting=Iluminação
metamorph.gui.label.lighting_tooltip=Quando desativado, o mapa de luzes do Minecraft não será aplicado, o que significa que brilhará no escuro. Pacotes de shaders, que têm efeito de bloom, farão com que esse morph pareça um letreiro néon
metamorph.gui.label.background=Fundo
metamorph.gui.label.billboard=Olhar para o jogador

metamorph.gui.item.animation=Animação
metamorph.gui.item.item_from_equipment=Do equipamento
metamorph.gui.item.transform.none=Nenhum
metamorph.gui.item.transform.third_person_left_hand=Left hand (3rd)
metamorph.gui.item.transform.third_person_right_hand=Right hand (3rd)
metamorph.gui.item.transform.first_person_left_hand=Left hand (1st)
metamorph.gui.item.transform.first_person_right_hand=Right hand (1st)
metamorph.gui.item.transform.head=Na cabeça
metamorph.gui.item.transform.gui=Inventário
metamorph.gui.item.transform.ground=No chão
metamorph.gui.item.transform.fixed=Quadro de item
metamorph.gui.item.equipment_slot.mainhand=Main hand
metamorph.gui.item.equipment_slot.offhand=Off hand
metamorph.gui.item.equipment_slot.feet=Feet
metamorph.gui.item.equipment_slot.legs=Legs
metamorph.gui.item.equipment_slot.chest=Chest
metamorph.gui.item.equipment_slot.head=Head

metamorph.gui.edit=Editar
metamorph.gui.panels.nbt_data=Dados NBT
metamorph.gui.panels.username=Nome de usuário
metamorph.gui.panels.updating=Atualizando...

metamorph.gui.animation.animates=Animar
metamorph.gui.animation.ignored=Ignorado
metamorph.gui.animation.animation_duration=Duração
metamorph.gui.animation.pick_interpolation=Selecionar interpolação

metamorph.gui.status.tight_space=Não há espaço suficiente para se transformar aqui

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=Aquisição de morphs
metamorph.config.acquiring.tooltip=Todas as opções relacionadas às formas de obter morphs
metamorph.config.acquiring.prevent_ghosts=Impedir fantasma
metamorph.config.comments.acquiring.prevent_ghosts=Impede que fantasmas apareçam se o jogador já tiver o morph de um mob morto
metamorph.config.acquiring.prevent_kill_acquire=Evitar adquirir matando
metamorph.config.comments.acquiring.prevent_kill_acquire=Evite adquirir morphs matando morphs
metamorph.config.acquiring.acquire_immediately=Adquir morphs imediatamente
metamorph.config.comments.acquiring.acquire_immediately=Adquire morphs imediatamente após o jogador matar uma entidade em vez de gerar um fantasma

metamorph.config.morphs.title=Morphs
metamorph.config.morphs.tooltip=Todas as opções relacionadas ao morphing e configurações de transformação

metamorph.config.morphs.keep_morphs=Reter morphs na morte
metamorph.config.comments.morphs.keep_morphs=Reter morphs quando o jogador morrer
metamorph.config.morphs.disable_pov=Desativar POV
metamorph.config.comments.morphs.disable_pov=Desativa a modificação do ponto de vista. Solicitado por causa do MorePlayerModels
metamorph.config.morphs.disable_health=Disable health scaling
metamorph.config.comments.morphs.disable_health=Disable modifying health. Requested because of Tough as Nails
metamorph.config.morphs.disable_morph_animation=Desativar animação de transformação
metamorph.config.comments.morphs.disable_morph_animation=Desativa a animação de transformação
metamorph.config.morphs.disable_morph_disguise=Disable morph hostility
metamorph.config.comments.morphs.disable_morph_disguise=Disable the ability of morphs labeled as "hostile" to avoid being attacked by hostile mobs
metamorph.config.morphs.disable_first_person_hand=Desabilitar mão em primeira pessoa
metamorph.config.comments.morphs.disable_first_person_hand=Ocultar completamente a renderização manual em primeira pessoag
metamorph.config.morphs.morph_in_tight_spaces=Permitir transformação em espaços apertados
metamorph.config.comments.morphs.morph_in_tight_spaces=Permite a transformação mesmo que possa causar asfixia e permitir a passagem através das paredes
metamorph.config.morphs.show_morph_idle_sounds=Mostrar sons inativos do morph
metamorph.config.comments.morphs.show_morph_idle_sounds=Se os jogadores emitem sons de entidade inativa quando transformados
metamorph.config.morphs.pause_gui_in_sp=Pause morph GUIs
metamorph.config.comments.morphs.pause_gui_in_sp=Whether creative and survival morph GUIs should be paused in singleplayer
metamorph.config.morphs.max_recent_morphs=Max. recent morphs
metamorph.config.comments.morphs.max_recent_morphs=The maximum amount of recent morphs that can be added in the morph menu before being discarded
metamorph.config.morphs.allow_morphing_into_category_morphs=Allow morphing into category morphs
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=When enabled, this option allows to morph into recent and custom category morphs while being in survival. This option also allows to open creative morph menu in survival
metamorph.config.morphs.load_entity_morphs=Carregar morphs de entidades
metamorph.config.comments.morphs.load_entity_morphs=Se os morphs de entidades devem ser carregados no menu de morph do criativo
metamorph.config.morphs.render_bodypart_axis=Render Axis for body parts
metamorph.config.comments.morphs.render_bodypart_axis=When enabled, body part axes are displayed in the body part editor GUI

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Opções de acesso OP do Metamorph

op_access.config.metamorph.entity_selectors=Seletores de entidades
op_access.config.comments.metamorph.entity_selectors=Jogadores não-OP podem editar seletores de entidades?

# Commands
metamorph.commands.morph=Morph command. This command is responsible for morphing player into specified morph.\n\n/morph <username> [morph_name] [data_tag]
metamorph.commands.acquire_morph=Acquire morph command. This command is responsible for sending a morph to a player in acquired morphs.\n\n/morph <username> <morph_name> [data_tag]
metamorph.commands.metamorph=Metamorph server command. This command allows to manage Metamorph stuff on the server side.\n\n/metamorph reload <blacklist|morphs> - reloads Metamorph's blacklist or morph configuration

metamorph.error.morph.not_player=A entidade %s não é um jogador!
metamorph.error.morph.nbt=Ocorreu um erro durante a análise da tag de dados:\n%s
metamorph.error.morph.factory=Não foi possível transformar em %2$s com a tag de dados fornecida
metamorph.error.acquire=Não foi possível adquirir o morph pelo nome de %s!
metamorph.success.morph=O jogador com o nome de %s foi transformado com sucesso em %s!
metamorph.success.demorph=O jogador com o nome de %s foi destransformado com sucesso!
metamorph.success.acquire=O jogador com o nome de %s foi adquirido o morph %s!

# Morph categories
morph.category.generic=Morphs não classificados
morph.category.animal=Morphs animais
morph.category.boss=Morphs chefe
morph.category.acquired=Seus morphs
morph.category.hostile=Morphs hostis
morph.category.modded=Morphs de %s
morph.category.recent=Morphs recentes

# Morph sections and categories
morph.section.entity=Morphs de entidade (Metamorph)
morph.section.user=Morphs de usuário

==================================================

--- Файл №189 ---
Путь: main\resources\assets\metamorph\lang\ru_RU.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Морф

# Keyboard bindings strings
key.metamorph=Метаморф
key.metamorph.action=Использовать действие
key.metamorph.creative_menu=Открыть меню превращения творчества
key.metamorph.selector_menu=Открыть меню селекторов сущностей
key.metamorph.survival_menu=Открыть меню превращения выживания
key.metamorph.demorph=Сбросить морф (обратно стать игроком)

# GUI
metamorph.gui.body_parts.pick=Выбрать морф
metamorph.gui.body_parts.use_target=Использовать цель
metamorph.gui.body_parts.enabled=Включено
metamorph.gui.body_parts.animate=Анимируется
metamorph.gui.body_parts.animate_tooltip=Этот параметр включает анимацию трансформаций частей тела вместе с анимацией родительского морфа
metamorph.gui.body_parts.parts=Части тела
metamorph.gui.body_parts.limbs=Конечности
metamorph.gui.body_parts.open=Открыть части тела
metamorph.gui.body_parts.add_tooltip=Добавить новую часть тела...
metamorph.gui.body_parts.dupe_tooltip=Клонировать выбранную часть тела...
metamorph.gui.body_parts.remove_tooltip=Удалить выбранную часть тела...
metamorph.gui.body_parts.copy_tooltip=Скопировать все части тела...
metamorph.gui.body_parts.paste_tooltip=Вставить скопированные части тела...
metamorph.gui.body_parts.keys.select_prev=Выбрать предыдущую часть тела
metamorph.gui.body_parts.keys.select_next=Выбрать следующую часть тела
metamorph.gui.body_parts.context.copy=Скопировать часть тела
metamorph.gui.body_parts.context.paste=Вставить скопированную часть тела

metamorph.gui.add=Добавить
metamorph.gui.remove=Удалить
metamorph.gui.morph=Превратиться
metamorph.gui.acquire=Приобрести
metamorph.gui.acquired=Приобретён
metamorph.gui.close=Закрыть
metamorph.gui.search=Поиск
metamorph.gui.no_morph=Не выбрано ни одного морфа...
metamorph.gui.morph_render_error=В отображении этого морфа произошла ошибка

metamorph.gui.selectors.title=Селектор существ
metamorph.gui.selectors.tooltip=С этой функцией, вы можете добавлять морфы существам по точному имени или типу...
metamorph.gui.selectors.add=Добавить селектор
metamorph.gui.selectors.remove=Удалить селектор
metamorph.gui.selectors.name=Название
metamorph.gui.selectors.type=Тип
metamorph.gui.selectors.match=Сходящийся NBT
metamorph.gui.selectors.match_tooltip=Здесь вы можете указать NBT-тэг который должен частично сходиться с NBT-тэгом существа
metamorph.gui.selectors.enabled=Включён

metamorph.gui.morphs.keys.category=Навигация по морфам
metamorph.gui.morphs.keys.up=Выбрать морф сверху
metamorph.gui.morphs.keys.down=Выбрать морф снизу
metamorph.gui.morphs.keys.right=Выбрать морф справа
metamorph.gui.morphs.keys.left=Выбрать морф слева

metamorph.gui.creative.command=Копировать компанду /morph для выбранного морфа
metamorph.gui.creative.edit=Редактировать
metamorph.gui.creative.pick=Выбрать
metamorph.gui.creative.quick=Быстрое редактирование
metamorph.gui.creative.presets=Предустановки
metamorph.gui.creative.random=Случайная предустановка
metamorph.gui.creative.keys.category=Меню превращения творчества
metamorph.gui.creative.keys.exit=Выйти из редактора морфов
metamorph.gui.creative.keys.edit=Редактировать выбранный морф
metamorph.gui.creative.keys.focus=Панель поиска
metamorph.gui.creative.keys.quick=Включить меню быстрого редактирования
metamorph.gui.creative.keys.acquire=Приобрести выбранный морф
metamorph.gui.creative.keys.morph=Превратиться в выбранный морф
metamorph.gui.creative.context.add_global=Добавить к глобальным морфам...
metamorph.gui.creative.context.edit=Редактировать морф...
metamorph.gui.creative.context.add_category=Добавить новую категорию
metamorph.gui.creative.context.rename_category=Переименовать категорию
metamorph.gui.creative.context.rename_category_modal=Дайте новое имя выбранной категории...
metamorph.gui.creative.context.remove_category=Удалить категорию
metamorph.gui.creative.context.remove_morph_modal=Уверенны, что хотите удалить этот морф? Он пропадёт навсегда...
metamorph.gui.creative.context.remove_category_modal=Вы уверены, что хотите удалить эту категорию морфов? Она пропадёт навсегда...
metamorph.gui.creative.context.clear_category=Удалить все морфы
metamorph.gui.creative.context.clear_category_modal=Вы уверены, что хотите удалить все морфы из этой категории? Они пропадут оттуда навсегда... 
metamorph.gui.creative.context.to_recent=Скопировать к недавним
metamorph.gui.creative.context.remove_morph=Удалить морф
metamorph.gui.creative.context.copy_command=Скопировать команду /morph
metamorph.gui.creative.context.copy=Копировать NBT
metamorph.gui.creative.context.paste=Вставить NBT
metamorph.gui.creative.context.paste_modal=Вставьте или введите NBT-тэг вашего морфа...

metamorph.gui.survival.title=Меню Превращения Выживания
metamorph.gui.survival.keybind_tooltip=В этом поле вы можете назначить клавишу, на которую вы превратитесь в конкретный морф (всякий раз когда вы нажмёте её в этом меню или при игре)
metamorph.gui.survival.only_favorites=Только избранные
metamorph.gui.survival.favorite=Избранные
metamorph.gui.survival.keys.category=Меню превращения выживания
metamorph.gui.survival.keys.toggle_favorites=Включить избранные морфы
metamorph.gui.survival.keys.focus_keybind=Клавиша

metamorph.gui.editor.entity=Свойства сущности
metamorph.gui.editor.settings=Параметры морфа
metamorph.gui.editor.keybind=Комбинация клавиш
metamorph.gui.editor.keybind_tooltip=Привязка морфа к клавише позволит вам превращаться в этот морф посредством нажатия назначенной клавиши либо при игре, либо в меню превращения выживания
metamorph.gui.editor.display_name=Отображать имя
metamorph.gui.editor.health=Здоровье
metamorph.gui.editor.speed=Скорость
metamorph.gui.editor.abilities=Способности
metamorph.gui.editor.abilities_tooltip=Нажмите клавишу шифт и кликните на способности из списка, чтобы выбрать сразу несколько способностей
metamorph.gui.editor.attack=Атака
metamorph.gui.editor.action=Действие
metamorph.gui.editor.reset=Сбросить
metamorph.gui.editor.item_morph=Предмет
metamorph.gui.editor.scale=Размер сущности
metamorph.gui.editor.texture=Выбрать текстуру...
metamorph.gui.editor.texture_tooltip=Эта опция работает не для всех мобов, так как у некоторых присутствует свой собственный метод рендера
metamorph.gui.editor.keys.category=Клавиши редактора морфов
metamorph.gui.editor.keys.cycle=Зацикливание между панелями морфов

metamorph.gui.editor.hitbox.enabled=Пользовательский хитбокс
metamorph.gui.editor.hitbox.size=Размер
metamorph.gui.editor.hitbox.width=Ширина хитбокса
metamorph.gui.editor.hitbox.height=Высота хитбокса
metamorph.gui.editor.hitbox.sneaking_height=Высота хитбокса в крадущейся позе
metamorph.gui.editor.hitbox.eye=Местоположение глаз
metamorph.gui.editor.hitbox.eye_tooltip=Фактор высоты глаз от общей высоты, где 0 означает низ, а 1 - верх хитбокса

metamorph.gui.label.label=Название
metamorph.gui.label.max_width=Максимальная ширина
metamorph.gui.label.anchor=Якорная точка
metamorph.gui.label.color=Цвет текста
metamorph.gui.label.shadow=Тень
metamorph.gui.label.shadow_offset=Смещение тени
metamorph.gui.label.shadow_color=Цвет тени
metamorph.gui.label.lighting=Свечение
metamorph.gui.label.lighting_tooltip=Если отключить этот параметр, то карта свечения из Майнкрафта не будет примененятся на морф, то есть морф применения будет светиться в темноте. С шейдерами, у которых есть опция блума (bloom), отключение этой настройки у морфа даст результат в виде "неонового" свечения
metamorph.gui.label.background=Фон
metamorph.gui.label.billboard=Смотреть на игрока

metamorph.gui.edit=Редактировать
metamorph.gui.panels.nbt_data=NBT-данные
metamorph.gui.panels.username=Имя пользователя
metamorph.gui.panels.updating=Обновление...

metamorph.gui.animation.animates=Анимируется
metamorph.gui.animation.ignored=Игнорируется
metamorph.gui.animation.animation_duration=Длительность
metamorph.gui.animation.pick_interpolation=Выбрать интерполяцию

metamorph.gui.status.tight_space=Здесь не хватает места для превращения

# Config
metamorph.config.title=Метаморф

metamorph.config.acquiring.title=Приобретение морфов
metamorph.config.acquiring.tooltip=Все параметры, касающиеся получения морфов

metamorph.config.acquiring.prevent_ghosts=Отключить появление призраков
metamorph.config.comments.acquiring.prevent_ghosts=Отключить появление призраков если у игрока уже есть морф убитого существа
metamorph.config.acquiring.prevent_kill_acquire=Отключить приобретение убийством
metamorph.config.comments.acquiring.prevent_kill_acquire=Отключить приобретение морфов убийством морфов
metamorph.config.acquiring.acquire_immediately=Приобретать морф мгновенно
metamorph.config.comments.acquiring.acquire_immediately=Приобретать морфы сразу после того как игрок убивает существо вместо необходимости ловить призрака

metamorph.config.morphs.title=Морфы
metamorph.config.morphs.tooltip=Все параметры, касающиеся морфов и их настроек

metamorph.config.morphs.keep_morphs=Сохранять приобретённые морфы после смерти
metamorph.config.comments.morphs.keep_morphs=Сохранять приобретённые морфы после смерти игрока
metamorph.config.morphs.disable_pov=Отключить поле зрения
metamorph.config.comments.morphs.disable_pov=Отключить изменение значения поля зрения. Опцию запросили из-за проблем с модом MorePlayerModels (поставьте на true если у вас дёргается экран)
metamorph.config.morphs.disable_health=Отключить масштабирование здоровья
metamorph.config.comments.morphs.disable_health=Отключить изменение очков здоровья. Опцию запросили из-за мода Tough as Nails
metamorph.config.morphs.disable_morph_animation=Отключить анимацию превращения
metamorph.config.comments.morphs.disable_morph_animation=Отключает анимацию превращения (частицы и так далее)
metamorph.config.morphs.disable_morph_disguise=Отключить враждебность морфов
metamorph.config.comments.morphs.disable_morph_disguise=Отключает способности морфов с пометкой "враждебные" дабы не быть атакованным враждебными мобами
metamorph.config.morphs.disable_first_person_hand=Отключить руку в режиме от первого лица
metamorph.config.comments.morphs.disable_first_person_hand=Полностью отключить отображение руки в режиме от первого лица
metamorph.config.morphs.morph_in_tight_spaces=Разрешить превращение в узких пространствах
metamorph.config.comments.morphs.morph_in_tight_spaces=Разрешает превращение даже при возможности удушья, а также разрешает проходить сквозь стены
metamorph.config.morphs.show_morph_idle_sounds=Проигрывать звуки бездействия морфов
metamorph.config.comments.morphs.show_morph_idle_sounds=Проигрываются ли звуки бездействия морфа, в который превратился игрок
metamorph.config.morphs.pause_gui_in_sp=Остановка интерфейса превращения
metamorph.config.comments.morphs.pause_gui_in_sp=Происходит ли остановка времени при открытии интерфейса превращения режимов выживания и творчества в одиночной игре
metamorph.config.morphs.max_recent_morphs=Максимальное количество недавних морфов
metamorph.config.comments.morphs.max_recent_morphs=Максимально возможное количество недавних морфов, которые добавляются в меню морфов перед удалением
metamorph.config.morphs.allow_morphing_into_category_morphs=Позволить превращение в категории морфов
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=Если включена, эта опция позволит превращаться в недавние морфы и морфы из пользовательских категорий во время нахождения в режиме выживания. Эта опция также позволяет открывать меню метаморфа из режима творчества в режиме выживания
metamorph.config.morphs.load_entity_morphs=Загрузить морфы существ
metamorph.config.comments.morphs.load_entity_morphs=Должны ли морфы существ быть загруженными в меню превращения творчества
metamorph.config.morphs.render_bodypart_axis=Отображать оси частей тела 
metamorph.config.comments.morphs.render_bodypart_axis=Если включена, опция будет показывать оси частей тела в интерфейса редактора

# OP access config
op_access.config.metamorph.title=Метаморф
op_access.config.metamorph.tooltip=Настройки ОП-доступа к Метаморфу

op_access.config.metamorph.entity_selectors=Селекторы сущностей
op_access.config.comments.metamorph.entity_selectors=Может ли игрок, не являющийся оператором, редактировать селекторы сущностей?

# Commands
metamorph.commands.morph=Команда превращения. Эта команда отвечает за превращение игрока в какой-либо конкретный морф.\n\n/morph <username> [morph_name] [data_tag]
metamorph.commands.acquire_morph=Команда приобретения морфа. Эта команда отвечает за добавление морфа в список морфов приобретённых игроком.\n\n/morph <username> <morph_name> [data_tag]
metamorph.commands.metamorph=Серверная команда Метаморфа. Эта команда позволяет вам управлять серверными параметрами Метаморфа.\n\n/metamorph reload <blacklist|morphs> - перезагрузить черный список Метаморфа или конфигурацию морфа

metamorph.error.morph.not_player=Сущность %s не является игроком!
metamorph.error.morph.nbt=Произошла ошибка во время синтаксического анализа (парсинга) дата-тэга:\n%s
metamorph.error.morph.factory=Невозможно превратиться в морф %2$s с заданным тэгом данных
metamorph.error.acquire=Невозможно приобрести морф с названием %s!
metamorph.success.morph=Игрок с никнеймом %s успешно превратился в морф %s!
metamorph.success.demorph=Игрок с никнеймом %s успешно сбросил морф!
metamorph.success.acquire=Игрок с никнеймом %s успешно приобрёл морф %s!

# Morph categories
morph.category.generic=Неотсортированные морфы
morph.category.animal=Морфы животных
morph.category.boss=Морфы боссов
morph.category.acquired=Ваши морфы
morph.category.hostile=Враждебные морфы
morph.category.modded=Морфы из %s
morph.category.recent=Последние морфы

# Секции и категории морфов
morph.section.entity=Морфы сущностей (Метаморфа)
morph.section.user=Пользовательские морфы


==================================================

--- Файл №190 ---
Путь: main\resources\assets\metamorph\lang\zh_CN.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=使用动作
key.metamorph.creative_menu=打开创造模式伪装菜单
key.metamorph.selector_menu=打开实体选择器菜单
key.metamorph.survival_menu=打开生存模式伪装菜单
key.metamorph.demorph=取消伪装（变回玩家）

# GUI
metamorph.gui.body_parts.pick=选择伪装
metamorph.gui.body_parts.use_target=使用目标
metamorph.gui.body_parts.enabled=启用
metamorph.gui.body_parts.animate=动画
metamorph.gui.body_parts.animate_tooltip=当父级伪装启用动画功能时，该选项可以将身体附件的变换信息直接动画化
metamorph.gui.body_parts.parts=身体附件
metamorph.gui.body_parts.limbs=肢体
metamorph.gui.body_parts.open=打开身体附件
metamorph.gui.body_parts.add_tooltip=添加一个新的身体附件...
metamorph.gui.body_parts.dupe_tooltip=复制当前所选的身体附件...
metamorph.gui.body_parts.remove_tooltip=移除当前所选的身体附件...
metamorph.gui.body_parts.copy_tooltip=拷贝所有身体附件...
metamorph.gui.body_parts.paste_tooltip=粘贴所有拷贝的身体附件...
metamorph.gui.body_parts.keys.select_prev=选择前一个身体附件
metamorph.gui.body_parts.keys.select_next=选择后一个身体附件
metamorph.gui.body_parts.context.copy=拷贝身体附件
metamorph.gui.body_parts.context.paste=粘贴身体附件

metamorph.gui.add=添加
metamorph.gui.remove=移除
metamorph.gui.morph=伪装
metamorph.gui.acquire=获取
metamorph.gui.acquired=已获取
metamorph.gui.close=关闭
metamorph.gui.search=搜索
metamorph.gui.no_morph=没有选中伪装...
metamorph.gui.morph_render_error=渲染该伪装时发生错误

metamorph.gui.selectors.title=实体选择器
metamorph.gui.selectors.tooltip=通过此功能，您可以为指定名称或指定类型的实体添加伪装...
metamorph.gui.selectors.add=添加选择器
metamorph.gui.selectors.remove=移除选择器
metamorph.gui.selectors.name=名称
metamorph.gui.selectors.type=类型
metamorph.gui.selectors.match=匹配 NBT
metamorph.gui.selectors.match_tooltip=您可以在此处指定一个 NBT 标签，该标签必须与实体的 NBT 标签部分匹配
metamorph.gui.selectors.enabled=启用

metamorph.gui.morphs.keys.category=伪装列表导航
metamorph.gui.morphs.keys.up=向上选择伪装
metamorph.gui.morphs.keys.down=向下选择伪装
metamorph.gui.morphs.keys.right=向右选择伪装
metamorph.gui.morphs.keys.left=向左选择伪装

metamorph.gui.creative.command=为所选的伪装拷贝 /morph 命令
metamorph.gui.creative.edit=编辑
metamorph.gui.creative.pick=选取
metamorph.gui.creative.quick=快速编辑
metamorph.gui.creative.presets=预设
metamorph.gui.creative.random=随机预设
metamorph.gui.creative.keys.category=创造模式伪装菜单
metamorph.gui.creative.keys.exit=退出伪装编辑器
metamorph.gui.creative.keys.edit=编辑当前所选的伪装
metamorph.gui.creative.keys.focus=聚焦至搜索框
metamorph.gui.creative.keys.quick=调出快速编辑菜单
metamorph.gui.creative.keys.acquire=获取当前所选的伪装
metamorph.gui.creative.keys.morph=伪装成当前所选的伪装
metamorph.gui.creative.context.add_global=添加为全局伪装...
metamorph.gui.creative.context.edit=编辑伪装...
metamorph.gui.creative.context.add_category=添加新分类
metamorph.gui.creative.context.rename_category=重命名分类
metamorph.gui.creative.context.rename_category_modal=为该分类命名...
metamorph.gui.creative.context.remove_category=移除分类
metamorph.gui.creative.context.remove_morph_modal=您确定要移除该伪装吗？它将永远消失...
metamorph.gui.creative.context.remove_category_modal=您确定要删除这一伪装分类吗？它将永远消失...
metamorph.gui.creative.context.clear_category=移除所有伪装
metamorph.gui.creative.context.clear_category_modal=您确定要删除该分类下的所有伪装吗？它们将永远消失...
metamorph.gui.creative.context.to_recent=拷贝到最近的伪装
metamorph.gui.creative.context.remove_morph=移除伪装
metamorph.gui.creative.context.copy_command=拷贝 /morph 命令
metamorph.gui.creative.context.copy=拷贝 NBT
metamorph.gui.creative.context.paste=粘贴 NBT
metamorph.gui.creative.context.paste_modal=粘贴或输入您伪装的 NBT 标签...

metamorph.gui.survival.title=生存模式伪装菜单
metamorph.gui.survival.keybind_tooltip=您可以通过此输入框绑定一个快捷键，该快捷键会让您变成这个伪装（当您在菜单或游戏世界中按下时触发）
metamorph.gui.survival.only_favorites=仅显示收藏
metamorph.gui.survival.favorite=收藏
metamorph.gui.survival.keys.category=生存模式伪装菜单
metamorph.gui.survival.keys.toggle_favorites=将伪装切换为收藏
metamorph.gui.survival.keys.focus_keybind=聚焦快捷键

metamorph.gui.editor.entity=实体参数
metamorph.gui.editor.settings=伪装设置
metamorph.gui.editor.keybind=快捷键
metamorph.gui.editor.keybind_tooltip=在此设置快捷键后，你就可以按下这个按钮变形为当前的伪装，无论是在游戏还是在生存模式伪装菜单中都可以
metamorph.gui.editor.display_name=显示名称
metamorph.gui.editor.health=生命值
metamorph.gui.editor.speed=速度
metamorph.gui.editor.abilities=技能
metamorph.gui.editor.abilities_tooltip=按住 Shift 并单击列表中的技能，即可进行多选
metamorph.gui.editor.attack=攻击
metamorph.gui.editor.action=动作
metamorph.gui.editor.reset=重置
metamorph.gui.editor.item_morph=物品
metamorph.gui.editor.scale=实体缩放
metamorph.gui.editor.texture=选取材质贴图...
metamorph.gui.editor.texture_tooltip=该功能不一定适用于所有生物，因为部分生物拥有非常规的渲染实现。
metamorph.gui.editor.keys.category=伪装编辑器快捷键
metamorph.gui.editor.keys.cycle=在伪装面板间循环切换
metamorph.gui.creative.keys.onionskin=切换洋葱皮开关
metamorph.gui.editor.shadow.all=渲染全部
metamorph.gui.editor.shadow.noshadow=不渲染阴影
metamorph.gui.editor.shadow.onlyshadow=只渲染阴影

metamorph.gui.editor.hitbox.enabled=自定义碰撞箱
metamorph.gui.editor.hitbox.size=大小
metamorph.gui.editor.hitbox.width=碰撞箱宽度
metamorph.gui.editor.hitbox.height=碰撞箱高度
metamorph.gui.editor.hitbox.sneaking_height=碰撞箱潜行状态高度
metamorph.gui.editor.hitbox.eye=眼睛位置
metamorph.gui.editor.hitbox.eye_tooltip=眼睛高度系数的高低，其中 0 表示在碰撞箱的底部，1 表示在碰撞箱的顶部

metamorph.gui.label.label=标签
metamorph.gui.label.max_width=最大宽度
metamorph.gui.label.anchor=锚点
metamorph.gui.label.color=文字颜色
metamorph.gui.label.shadow=阴影
metamorph.gui.label.shadow_offset=阴影偏移
metamorph.gui.label.shadow_color=阴影颜色
metamorph.gui.label.lighting=发光
metamorph.gui.label.lighting_tooltip=禁用时，将不会应用 Minecraft 的光照图，这意味着它会在暗处发光。带有泛光（Bloom）效果的光影包，可以让这个伪装看起来像霓虹灯一样。
metamorph.gui.label.background=背景
metamorph.gui.label.billboard=看向玩家

metamorph.gui.edit=编辑
metamorph.gui.panels.nbt_data=NBT 数据
metamorph.gui.panels.username=用户名
metamorph.gui.panels.updating=更新中...

metamorph.gui.animation.animates=动画
metamorph.gui.animation.ignored=跳过
metamorph.gui.animation.animation_duration=持续时间
metamorph.gui.animation.pick_interpolation=选择插值

metamorph.gui.status.tight_space=此处没有足够的空间来进行伪装

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=伪装获取
metamorph.config.acquiring.tooltip=所有与伪装获取方式相关的选项

metamorph.config.acquiring.prevent_ghosts=避免幽灵
metamorph.config.comments.acquiring.prevent_ghosts=若玩家已有当前被杀死生物的伪装，则会避免幽灵的生成
metamorph.config.acquiring.prevent_kill_acquire=避免通过击杀获取
metamorph.config.comments.acquiring.prevent_kill_acquire=避免通过击杀生物的方式获取伪装
metamorph.config.acquiring.acquire_immediately=立即获取伪装
metamorph.config.comments.acquiring.acquire_immediately=在玩家杀死实体后立即获取伪装，而不是生成幽灵

metamorph.config.morphs.title=伪装
metamorph.config.morphs.tooltip=所有与伪装方式和伪装相关的设置

metamorph.config.morphs.keep_morphs=死后保持伪装
metamorph.config.comments.morphs.keep_morphs=在玩家死后继续保持伪装
metamorph.config.morphs.disable_pov=禁用 POV
metamorph.config.comments.morphs.disable_pov=禁用视点高度修改。应 MorePlayerModels 的要求加入该功能
metamorph.config.morphs.disable_health=禁用生命值伸缩
metamorph.config.comments.morphs.disable_health=禁用生命值修改。应意志坚定（Tough As Nails）的要求加入该功能
metamorph.config.morphs.disable_morph_animation=禁用伪装动画
metamorph.config.comments.morphs.disable_morph_animation=禁用伪装时的动画效果
metamorph.config.morphs.disable_morph_disguise=禁用伪装无敌
metamorph.config.comments.morphs.disable_morph_disguise=禁用带有“无敌”技能标签的伪装，避免被敌对生物攻击
metamorph.config.morphs.disable_first_person_hand=禁用第一人称手臂
metamorph.config.comments.morphs.disable_first_person_hand=完全隐藏第一人称手臂的显示
metamorph.config.morphs.morph_in_tight_spaces=允许在狭窄空间伪装
metamorph.config.comments.morphs.morph_in_tight_spaces=即使在可能造成窒息时进行伪装，并允许穿墙
metamorph.config.morphs.show_morph_idle_sounds=播放伪装的空闲音效
metamorph.config.comments.morphs.show_morph_idle_sounds=伪装后玩家是否发出实体的空闲音效
metamorph.config.morphs.pause_gui_in_sp=打开伪装 GUI 后暂停
metamorph.config.comments.morphs.pause_gui_in_sp=不论是创造模式或生存模式伪装菜单，在单人模式下打开伪装 GUI 后暂停游戏
metamorph.config.morphs.max_recent_morphs=最近伪装最大值
metamorph.config.comments.morphs.max_recent_morphs=在被丢弃之前可以添加到伪装菜单中最近的伪装的最大值
metamorph.config.morphs.allow_morphing_into_category_morphs=允许伪装为分类中的伪装
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=启用后，该选项允许在生存模式下伪装为最近的和自定义分类伪装。该选项还允许你在生存模式下打开创造模式伪装菜单
metamorph.config.morphs.load_entity_morphs=加载实体伪装
metamorph.config.comments.morphs.load_entity_morphs=实体伪装是否会被加载至创造模式伪装菜单
metamorph.config.morphs.render_bodypart_axis=为身体附件渲染座标轴
metamorph.config.comments.morphs.render_bodypart_axis=启用后，身体附件的座标轴就会在身体附件编辑器 GUI 中进行显示。

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Metamorph OP 访问权限选项

op_access.config.metamorph.entity_selectors=实体选择器
op_access.config.comments.metamorph.entity_selectors=非 OP 玩家是否可以编辑实体选择器？

# Commands
metamorph.commands.morph=伪装命令。该命令可以让玩家伪装成指定的伪装。\n\n/morph <用户名> [伪装名称] [数据标签]
metamorph.commands.acquire_morph=获取伪装命令。该命令可以将伪装发送到指定玩家的已获取伪装列表。\n\n/morph <用户名> <伪装名称> [数据标签]
metamorph.commands.metamorph=Metamorph 服务器命令。该命令可用于在服务端管理 Metamorph 的东西。\n\n/metamorph reload <blacklist|morphs> - 重新载入 Metamorph 的黑名单或伪装配置

metamorph.error.morph.not_player=实体 %s 不是玩家！
metamorph.error.morph.nbt=在解析数据标签: \n%s 时出现错误
metamorph.error.morph.factory=无法通过给定的数据标签伪装为 %2$s
metamorph.error.acquire=无法通过名称: %s 获取伪装！
metamorph.success.morph=玩家 %s 成功伪装成了 %s！
metamorph.success.demorph=玩家 %s 成功取消了伪装！
metamorph.success.acquire=玩家 %s 成功获取了 %s 伪装！

# Morph categories
morph.category.generic=未分类伪装
morph.category.animal=动物伪装
morph.category.boss=Boss 伪装
morph.category.acquired=您的伪装
morph.category.hostile=敌对生物伪装
morph.category.modded=来自 %s 的伪装
morph.category.recent=最近的伪装

# Morph sections and categories
morph.section.entity=实体伪装（Metamorph）
morph.section.user=玩家伪装

==================================================

--- Файл №191 ---
Путь: main\resources\assets\metamorph\lang\zh_TW.lang
--------------------
#PARSE_ESCAPES

entity.metamorph.Morph.name=Morph

# Keyboard bindings strings
key.metamorph=Metamorph
key.metamorph.action=使用動作
key.metamorph.creative_menu=打開創造模式偽裝菜單
key.metamorph.selector_menu=打開實體選擇器菜單
key.metamorph.survival_menu=打開生存模式偽裝菜單
key.metamorph.demorph=取消偽裝（變回玩家）

# GUI
metamorph.gui.body_parts.pick=選擇偽裝
metamorph.gui.body_parts.use_target=使用目標
metamorph.gui.body_parts.enabled=啟用
metamorph.gui.body_parts.animate=動畫
metamorph.gui.body_parts.animate_tooltip=當父級偽裝啟用動畫功能時，該選項可以將身體附件的變換信息直接動畫化
metamorph.gui.body_parts.parts=身體附件
metamorph.gui.body_parts.limbs=肢體
metamorph.gui.body_parts.open=打開身體附件
metamorph.gui.body_parts.add_tooltip=添加一個新的身體附件...
metamorph.gui.body_parts.dupe_tooltip=複製當前所選的身體附件...
metamorph.gui.body_parts.remove_tooltip=移除當前所選的身體附件...
metamorph.gui.body_parts.copy_tooltip=拷貝所有身體附件...
metamorph.gui.body_parts.paste_tooltip=粘貼所有拷貝的身體附件...
metamorph.gui.body_parts.keys.select_prev=選擇前一個身體附件
metamorph.gui.body_parts.keys.select_next=選擇後一個身體附件
metamorph.gui.body_parts.context.copy=拷貝身體附件
metamorph.gui.body_parts.context.paste=粘貼身體附件

metamorph.gui.add=添加
metamorph.gui.remove=移除
metamorph.gui.morph=偽裝
metamorph.gui.acquire=獲取
metamorph.gui.acquired=已獲取
metamorph.gui.close=關閉
metamorph.gui.search=搜索
metamorph.gui.no_morph=沒有選中偽裝...
metamorph.gui.morph_render_error=渲染該偽裝時發生錯誤

metamorph.gui.selectors.title=實體選擇器
metamorph.gui.selectors.tooltip=通過此功能，您可以為指定名稱或指定類型的實體添加偽裝...
metamorph.gui.selectors.add=添加選擇器
metamorph.gui.selectors.remove=移除選擇器
metamorph.gui.selectors.name=名稱
metamorph.gui.selectors.type=類型
metamorph.gui.selectors.match=匹配 NBT
metamorph.gui.selectors.match_tooltip=您可以在此處指定一個 NBT 標籤，該標籤必須與實體的 NBT 標籤部分匹配
metamorph.gui.selectors.enabled=啟用

metamorph.gui.morphs.keys.category=偽裝列表導航
metamorph.gui.morphs.keys.up=向上選擇偽裝
metamorph.gui.morphs.keys.down=向下選擇偽裝
metamorph.gui.morphs.keys.right=向右選擇偽裝
metamorph.gui.morphs.keys.left=向左選擇偽裝

metamorph.gui.creative.command=為所選的偽裝拷貝 /morph 命令
metamorph.gui.creative.edit=編輯
metamorph.gui.creative.pick=選取
metamorph.gui.creative.quick=快速編輯
metamorph.gui.creative.presets=預設
metamorph.gui.creative.random=隨機預設
metamorph.gui.creative.keys.category=創造模式偽裝菜單
metamorph.gui.creative.keys.exit=退出偽裝編輯器
metamorph.gui.creative.keys.edit=編輯當前所選的偽裝
metamorph.gui.creative.keys.focus=聚焦至搜索框
metamorph.gui.creative.keys.quick=調出快速編輯菜單
metamorph.gui.creative.keys.acquire=獲取當前所選的偽裝
metamorph.gui.creative.keys.morph=偽裝成當前所選的偽裝
metamorph.gui.creative.context.add_global=添加為全局偽裝...
metamorph.gui.creative.context.edit=編輯偽裝...
metamorph.gui.creative.context.add_category=添加新分類
metamorph.gui.creative.context.rename_category=重命名分類
metamorph.gui.creative.context.rename_category_modal=為該分類命名...
metamorph.gui.creative.context.remove_category=移除分類
metamorph.gui.creative.context.remove_morph_modal=您確定要移除該偽裝嗎？它將永遠消失...
metamorph.gui.creative.context.remove_category_modal=您確定要刪除這一偽裝分類嗎？它將永遠消失...
metamorph.gui.creative.context.clear_category=移除所有偽裝
metamorph.gui.creative.context.clear_category_modal=您確定要刪除該分類下的所有偽裝嗎？它們將永遠消失...
metamorph.gui.creative.context.to_recent=拷貝到最近的偽裝
metamorph.gui.creative.context.remove_morph=移除偽裝
metamorph.gui.creative.context.copy_command=拷貝 /morph 命令
metamorph.gui.creative.context.copy=拷貝 NBT
metamorph.gui.creative.context.paste=粘貼 NBT
metamorph.gui.creative.context.paste_modal=粘貼或輸入您偽裝的 NBT 標籤...

metamorph.gui.survival.title=生存模式偽裝菜單
metamorph.gui.survival.keybind_tooltip=您可以通過此輸入框綁定一個快捷鍵，該快捷鍵會讓您變成這個偽裝（當您在菜單或遊戲世界中按下時觸發）
metamorph.gui.survival.only_favorites=僅顯示收藏
metamorph.gui.survival.favorite=收藏
metamorph.gui.survival.keys.category=生存模式偽裝菜單
metamorph.gui.survival.keys.toggle_favorites=將偽裝切換為收藏
metamorph.gui.survival.keys.focus_keybind=聚焦快捷鍵

metamorph.gui.editor.entity=實體參數
metamorph.gui.editor.settings=偽裝設置
metamorph.gui.editor.keybind=快捷鍵
metamorph.gui.editor.keybind_tooltip=在此設置快捷鍵後，你就可以按下這個按鈕變形為當前的偽裝，無論是在遊戲還是在生存模式偽裝菜單中都可以
metamorph.gui.editor.display_name=顯示名稱
metamorph.gui.editor.health=生命值
metamorph.gui.editor.speed=速度
metamorph.gui.editor.abilities=技能
metamorph.gui.editor.abilities_tooltip=按住 Shift 並單擊列表中的技能，即可進行多選
metamorph.gui.editor.attack=攻擊
metamorph.gui.editor.action=動作
metamorph.gui.editor.reset=重置
metamorph.gui.editor.item_morph=物品
metamorph.gui.editor.scale=實體縮放
metamorph.gui.editor.texture=選取材質貼圖...
metamorph.gui.editor.texture_tooltip=該功能不一定適用於所有生物，因為部分生物擁有非常規的渲染實現。
metamorph.gui.editor.keys.category=偽裝編輯器快捷鍵
metamorph.gui.editor.keys.cycle=在偽裝面板間循環切換
metamorph.gui.creative.keys.onionskin=切換洋葱皮開關
metamorph.gui.editor.shadow.all=渲染全部
metamorph.gui.editor.shadow.noshadow=不渲染陰影
metamorph.gui.editor.shadow.onlyshadow=只渲染陰影

metamorph.gui.editor.hitbox.enabled=自定義碰撞箱
metamorph.gui.editor.hitbox.size=大小
metamorph.gui.editor.hitbox.width=碰撞箱寬度
metamorph.gui.editor.hitbox.height=碰撞箱高度
metamorph.gui.editor.hitbox.sneaking_height=碰撞箱潛行狀態高度
metamorph.gui.editor.hitbox.eye=眼睛位置
metamorph.gui.editor.hitbox.eye_tooltip=眼睛高度係數的高低，其中 0 表示在碰撞箱的底部，1 表示在碰撞箱的頂部

metamorph.gui.label.label=標籤
metamorph.gui.label.max_width=最大寬度
metamorph.gui.label.anchor=錨點
metamorph.gui.label.color=文字顏色
metamorph.gui.label.shadow=陰影
metamorph.gui.label.shadow_offset=陰影偏移
metamorph.gui.label.shadow_color=陰影顏色
metamorph.gui.label.lighting=發光
metamorph.gui.label.lighting_tooltip=禁用時，將不會應用 Minecraft 的光照圖，這意味著它會在暗處發光。帶有泛光（Bloom）效果的光影包，可以讓這個偽裝看起來像霓虹燈一樣。
metamorph.gui.label.background=背景
metamorph.gui.label.billboard=看向玩家

metamorph.gui.edit=編輯
metamorph.gui.panels.nbt_data=NBT 數據
metamorph.gui.panels.username=用戶名
metamorph.gui.panels.updating=更新中...

metamorph.gui.animation.animates=動畫
metamorph.gui.animation.ignored=跳過
metamorph.gui.animation.animation_duration=持續時間
metamorph.gui.animation.pick_interpolation=選擇插值

metamorph.gui.status.tight_space=此處沒有足夠的空間來進行偽裝

# Config
metamorph.config.title=Metamorph

metamorph.config.acquiring.title=偽裝獲取
metamorph.config.acquiring.tooltip=所有與偽裝獲取方式相關的選項

metamorph.config.acquiring.prevent_ghosts=避免幽靈
metamorph.config.comments.acquiring.prevent_ghosts=若玩家已有當前被殺死生物的偽裝，則會避免幽靈的生成
metamorph.config.acquiring.prevent_kill_acquire=避免通過擊殺獲取
metamorph.config.comments.acquiring.prevent_kill_acquire=避免通過擊殺生物的方式獲取偽裝
metamorph.config.acquiring.acquire_immediately=立即獲取偽裝
metamorph.config.comments.acquiring.acquire_immediately=在玩家殺死實體後立即獲取偽裝，而不是生成幽靈

metamorph.config.morphs.title=偽裝
metamorph.config.morphs.tooltip=所有與偽裝方式和偽裝相關的設置

metamorph.config.morphs.keep_morphs=死後保持偽裝
metamorph.config.comments.morphs.keep_morphs=在玩家死後繼續保持偽裝
metamorph.config.morphs.disable_pov=禁用 POV
metamorph.config.comments.morphs.disable_pov=禁用視點高度修改。應 MorePlayerModels 的要求加入該功能
metamorph.config.morphs.disable_health=禁用生命值伸縮
metamorph.config.comments.morphs.disable_health=禁用生命值修改。應意志堅定（Tough As Nails）的要求加入該功能
metamorph.config.morphs.disable_morph_animation=禁用偽裝動畫
metamorph.config.comments.morphs.disable_morph_animation=禁用偽裝時的動畫效果
metamorph.config.morphs.disable_morph_disguise=禁用偽裝無敵
metamorph.config.comments.morphs.disable_morph_disguise=禁用帶有“無敵”技能標籤的偽裝，避免被敵對生物攻擊
metamorph.config.morphs.disable_first_person_hand=禁用第一人稱手臂
metamorph.config.comments.morphs.disable_first_person_hand=完全隱藏第一人稱手臂的顯示
metamorph.config.morphs.morph_in_tight_spaces=允許在狹窄空間偽裝
metamorph.config.comments.morphs.morph_in_tight_spaces=即使在可能造成窒息時進行偽裝，並允許穿牆
metamorph.config.morphs.show_morph_idle_sounds=播放偽裝的空閒音效
metamorph.config.comments.morphs.show_morph_idle_sounds=偽裝後玩家是否發出實體的空閒音效
metamorph.config.morphs.pause_gui_in_sp=打開偽裝 GUI 後暫停
metamorph.config.comments.morphs.pause_gui_in_sp=不論是創造模式或生存模式偽裝菜單，在單人模式下打開偽裝 GUI 後暫停遊戲
metamorph.config.morphs.max_recent_morphs=最近偽裝最大值
metamorph.config.comments.morphs.max_recent_morphs=在被丟棄之前可以添加到偽裝菜單中最近的偽裝的最大值
metamorph.config.morphs.allow_morphing_into_category_morphs=允許偽裝為分類中的偽裝
metamorph.config.comments.morphs.allow_morphing_into_category_morphs=啟用後，該選項允許在生存模式下偽裝為最近的和自定義分類偽裝。該選項還允許你在生存模式下打開創造模式偽裝菜單
metamorph.config.morphs.load_entity_morphs=加載實體偽裝
metamorph.config.comments.morphs.load_entity_morphs=實體偽裝是否會被加載至創造模式偽裝菜單
metamorph.config.morphs.render_bodypart_axis=為身體附件渲染座標軸
metamorph.config.comments.morphs.render_bodypart_axis=啟用後，身體附件的座標軸就會在身體附件編輯器 GUI 中進行顯示。

# OP access config
op_access.config.metamorph.title=Metamorph
op_access.config.metamorph.tooltip=Metamorph OP 訪問權限選項

op_access.config.metamorph.entity_selectors=實體選擇器
op_access.config.comments.metamorph.entity_selectors=非 OP 玩家是否可以編輯實體選擇器？

# Commands
metamorph.commands.morph=偽裝命令。該命令可以讓玩家偽裝成指定的偽裝。\n\n/morph <用戶名> [偽裝名稱] [數據標籤]
metamorph.commands.acquire_morph=獲取偽裝命令。該命令可以將偽裝發送到指定玩家的已獲取偽裝列表。\n\n/morph <用戶名> <偽裝名稱> [數據標籤]
metamorph.commands.metamorph=Metamorph 服務器命令。該命令可用於在服務端管理 Metamorph 的東西。\n\n/metamorph reload <blacklist|morphs> - 重新載入 Metamorph 的黑名單或偽裝配置

metamorph.error.morph.not_player=實體 %s 不是玩家！
metamorph.error.morph.nbt=在解析數據標籤: \n%s 時出現錯誤
metamorph.error.morph.factory=無法通過給定的數據標籤偽裝為 %2$s
metamorph.error.acquire=無法通過名稱: %s 獲取偽裝！
metamorph.success.morph=玩家 %s 成功偽裝成了 %s！
metamorph.success.demorph=玩家 %s 成功取消了偽裝！
metamorph.success.acquire=玩家 %s 成功獲取了 %s 偽裝！

# Morph categories
morph.category.generic=未分類偽裝
morph.category.animal=動物偽裝
morph.category.boss=Boss 偽裝
morph.category.acquired=您的偽裝
morph.category.hostile=敵對生物偽裝
morph.category.modded=來自 %s 的偽裝
morph.category.recent=最近的偽裝

# Morph sections and categories
morph.section.entity=實體偽裝（Metamorph）
morph.section.user=玩家偽裝

==================================================

--- Файл №192 ---
Путь: main\resources\assets\metamorph\shaders\onionskin.frag
--------------------
#version 120

uniform sampler2D texture;

varying vec4 color;
varying vec4 texcoord;

void main()
{
    gl_FragColor = texture2D(texture, texcoord.st) * color;
}

==================================================

--- Файл №193 ---
Путь: main\resources\assets\metamorph\shaders\onionskin.vert
--------------------
#version 120

uniform vec4 onionskin;

varying vec4 color;
varying vec4 texcoord;

void main()
{
    gl_Position = ftransform();

    color = gl_Color * onionskin;
    texcoord = gl_TextureMatrix[0] * gl_MultiTexCoord0;
}

==================================================

--- Файл №194 ---
Путь: main\resources\assets\metamorph\textures\gui\icons.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3842 байт]

==================================================

