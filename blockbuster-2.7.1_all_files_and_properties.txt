Анализ содержимого папки: C:\Users\User\Desktop\mody\blockbuster-2.7.1\src
==================================================

--- Файл №1 ---
Путь: main\java\at\dhyan\open_imaging\GifDecoder.java
--------------------
package at.dhyan.open_imaging;

import static java.lang.System.arraycopy;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

/*
 * Copyright 2014 Dhyan Blum
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * <p>
 * A decoder capable of processing a GIF data stream to render the graphics
 * contained in it. This implementation follows the official
 * <A HREF="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">GIF
 * specification</A>.
 * </p>
 *
 * <p>
 * Example usage:
 * </p>
 *
 * <p>
 *
 * <pre>
 * final GifImage gifImage = GifDecoder.read(int[] data);
 * final int width = gifImage.getWidth();
 * final int height = gifImage.getHeight();
 * final int frameCount = gifImage.getFrameCount();
 * for (int i = 0; i < frameCount; i++) {
 * 	final BufferedImage image = gifImage.getFrame(i);
 * 	final int delay = gif.getDelay(i);
 * }
 * </pre>
 *
 * </p>
 *
 * @author Dhyan Blum
 * @version 1.09 November 2017
 *
 */
public final class GifDecoder
{
    static final class BitReader
    {
        private int bitPos; // Next bit to read
        private int numBits; // Number of bits to read
        private int bitMask; // Use to kill unwanted higher bits
        private byte[] in; // Data array

        // To avoid costly bounds checks, 'in' needs 2 more 0-bytes at the end
        private final void init(final byte[] in)
        {
            this.in = in;
            bitPos = 0;
        }

        private final int read()
        {
            // Byte indices: (bitPos / 8), (bitPos / 8) + 1, (bitPos / 8) + 2
            int i = bitPos >>> 3; // Byte = bit / 8
            // Bits we'll shift to the right, AND 7 is the same as MODULO 8
            final int rBits = bitPos & 7;
            // Byte 0 to 2, AND to get their unsigned values
            final int b0 = in[i++] & 0xFF, b1 = in[i++] & 0xFF,
                    b2 = in[i] & 0xFF;
            // Glue the bytes together, don't do more shifting than necessary
            final int buf = ((b2 << 8 | b1) << 8 | b0) >>> rBits;
            bitPos += numBits;
            return buf & bitMask; // Kill the unwanted higher bits
        }

        private final void setNumBits(final int numBits)
        {
            this.numBits = numBits;
            bitMask = (1 << numBits) - 1;
        }
    }

    static final class CodeTable
    {
        private final int[][] tbl; // Maps codes to lists of colors
        private int initTableSize; // Number of colors +2 for CLEAR + EOI
        private int initCodeSize; // Initial code size
        private int initCodeLimit; // First code limit
        private int codeSize; // Current code size, maximum is 12 bits
        private int nextCode; // Next available code for a new entry
        private int nextCodeLimit; // Increase codeSize when nextCode == limit
        private BitReader br; // Notify when code sizes increases

        public CodeTable()
        {
            tbl = new int[4096][1];
        }

        private final int add(final int[] indices)
        {
            if (nextCode < 4096)
            {
                if (nextCode == nextCodeLimit && codeSize < 12)
                {
                    codeSize++; // Max code size is 12
                    br.setNumBits(codeSize);
                    nextCodeLimit = (1 << codeSize) - 1; // 2^codeSize - 1
                }
                tbl[nextCode++] = indices;
            }
            return codeSize;
        }

        private final int clear()
        {
            codeSize = initCodeSize;
            br.setNumBits(codeSize);
            nextCodeLimit = initCodeLimit;
            nextCode = initTableSize; // Don't recreate table, reset pointer
            return codeSize;
        }

        private final void init(final GifFrame fr, final int[] activeColTbl, final BitReader br)
        {
            this.br = br;
            final int numColors = activeColTbl.length;
            initCodeSize = fr.firstCodeSize;
            initCodeLimit = (1 << initCodeSize) - 1; // 2^initCodeSize - 1
            initTableSize = fr.endOfInfoCode + 1;
            nextCode = initTableSize;
            for (int c = numColors - 1; c >= 0; c--)
            {
                tbl[c][0] = activeColTbl[c]; // Translated color
            } // A gap may follow with no colors assigned if numCols < CLEAR
            tbl[fr.clearCode] = new int[] {fr.clearCode}; // CLEAR
            tbl[fr.endOfInfoCode] = new int[] {fr.endOfInfoCode}; // EOI
            // Locate transparent color in code table and set to 0
            if (fr.transpColFlag && fr.transpColIndex < numColors)
            {
                tbl[fr.transpColIndex][0] = 0;
            }
        }
    }

    final class GifFrame
    {
        // Graphic control extension (optional)
        // Disposal: 0=NO_ACTION, 1=NO_DISPOSAL, 2=RESTORE_BG, 3=RESTORE_PREV
        private int disposalMethod; // 0-3 as above, 4-7 undefined
        private boolean transpColFlag; // 1 Bit
        private int delay; // Unsigned, LSByte first, n * 1/100 * s
        private int transpColIndex; // 1 Byte
        // Image descriptor
        private int x; // Position on the canvas from the left
        private int y; // Position on the canvas from the top
        private int w; // May be smaller than the base image
        private int h; // May be smaller than the base image
        private int wh; // width * height
        private boolean hasLocColTbl; // Has local color table? 1 Bit
        private boolean interlaceFlag; // Is an interlace image? 1 Bit
        @SuppressWarnings("unused")
        private boolean sortFlag; // True if local colors are sorted, 1 Bit
        private int sizeOfLocColTbl; // Size of the local color table, 3 Bits
        private int[] localColTbl; // Local color table (optional)
        // Image data
        private int firstCodeSize; // LZW minimum code size + 1 for CLEAR & EOI
        private int clearCode;
        private int endOfInfoCode;
        private byte[] data; // Holds LZW encoded data
        private BufferedImage img; // Full drawn image, not just the frame area
    }

    public final class GifImage
    {
        public String header; // Bytes 0-5, GIF87a or GIF89a
        private int w; // Unsigned 16 Bit, least significant byte first
        private int h; // Unsigned 16 Bit, least significant byte first
        private int wh; // Image width * image height
        public boolean hasGlobColTbl; // 1 Bit
        public int colorResolution; // 3 Bits
        public boolean sortFlag; // True if global colors are sorted, 1 Bit
        public int sizeOfGlobColTbl; // 2^(val(3 Bits) + 1), see spec
        public int bgColIndex; // Background color index, 1 Byte
        public int pxAspectRatio; // Pixel aspect ratio, 1 Byte
        public int[] globalColTbl; // Global color table
        private final List<GifFrame> frames = new ArrayList<GifFrame>(64);
        public String appId = ""; // 8 Bytes at in[i+3], usually "NETSCAPE"
        public String appAuthCode = ""; // 3 Bytes at in[i+11], usually "2.0"
        public int repetitions = 0; // 0: infinite loop, N: number of loops
        private BufferedImage img = null; // Currently drawn frame
        private int[] prevPx = null; // Previous frame's pixels
        private final BitReader bits = new BitReader();
        private final CodeTable codes = new CodeTable();
        private Graphics2D g;

        private final int[] decode(final GifFrame fr, final int[] activeColTbl)
        {
            codes.init(fr, activeColTbl, bits);
            bits.init(fr.data); // Incoming codes
            final int clearCode = fr.clearCode, endCode = fr.endOfInfoCode;
            final int[] out = new int[wh]; // Target image pixel array
            final int[][] tbl = codes.tbl; // Code table
            int outPos = 0; // Next pixel position in the output image array
            codes.clear(); // Init code table
            bits.read(); // Skip leading clear code
            int code = bits.read(); // Read first code
            int[] pixels = tbl[code]; // Output pixel for first code
            arraycopy(pixels, 0, out, outPos, pixels.length);
            outPos += pixels.length;
            try
            {
                while (true)
                {
                    final int prevCode = code;
                    code = bits.read(); // Get next code in stream
                    if (code == clearCode)
                    { // After a CLEAR table, there is
                        codes.clear(); // no previous code, we need to read
                        code = bits.read(); // a new one
                        pixels = tbl[code]; // Output pixels
                        arraycopy(pixels, 0, out, outPos, pixels.length);
                        outPos += pixels.length;
                        continue; // Back to the loop with a valid previous code
                    }
                    else if (code == endCode)
                    {
                        break;
                    }
                    final int[] prevVals = tbl[prevCode];
                    final int[] prevValsAndK = new int[prevVals.length + 1];
                    arraycopy(prevVals, 0, prevValsAndK, 0, prevVals.length);
                    if (code < codes.nextCode)
                    { // Code table contains code
                        pixels = tbl[code]; // Output pixels
                        arraycopy(pixels, 0, out, outPos, pixels.length);
                        outPos += pixels.length;
                        prevValsAndK[prevVals.length] = tbl[code][0]; // K
                    }
                    else
                    {
                        prevValsAndK[prevVals.length] = prevVals[0]; // K
                        arraycopy(prevValsAndK, 0, out, outPos, prevValsAndK.length);
                        outPos += prevValsAndK.length;
                    }
                    codes.add(prevValsAndK); // Previous indices + K
                }
            }
            catch (final ArrayIndexOutOfBoundsException e)
            {}
            return out;
        }

        private final int[] deinterlace(final int[] src, final GifFrame fr)
        {
            final int w = fr.w, h = fr.h, wh = fr.wh;
            final int[] dest = new int[src.length];
            // Interlaced images are organized in 4 sets of pixel lines
            final int set2Y = (h + 7) >>> 3; // Line no. = ceil(h/8.0)
            final int set3Y = set2Y + ((h + 3) >>> 3); // ceil(h-4/8.0)
            final int set4Y = set3Y + ((h + 1) >>> 2); // ceil(h-2/4.0)
            // Sets' start indices in source array
            final int set2 = w * set2Y, set3 = w * set3Y, set4 = w * set4Y;
            // Line skips in destination array
            final int w2 = w << 1, w4 = w2 << 1, w8 = w4 << 1;
            // Group 1 contains every 8th line starting from 0
            int from = 0, to = 0;
            for (; from < set2; from += w, to += w8)
            {
                arraycopy(src, from, dest, to, w);
            } // Group 2 contains every 8th line starting from 4
            for (to = w4; from < set3; from += w, to += w8)
            {
                arraycopy(src, from, dest, to, w);
            } // Group 3 contains every 4th line starting from 2
            for (to = w2; from < set4; from += w, to += w4)
            {
                arraycopy(src, from, dest, to, w);
            } // Group 4 contains every 2nd line starting from 1 (biggest group)
            for (to = w; from < wh; from += w, to += w2)
            {
                arraycopy(src, from, dest, to, w);
            }
            return dest; // All pixel lines have now been rearranged
        }

        private final void drawFrame(final GifFrame fr)
        {
            // Determine the color table that will be active for this frame
            final int[] activeColTbl = fr.hasLocColTbl ? fr.localColTbl : globalColTbl;
            // Get pixels from data stream
            int[] pixels = decode(fr, activeColTbl);
            if (fr.interlaceFlag)
            {
                pixels = deinterlace(pixels, fr); // Rearrange pixel lines
            }
            // Create image of type 2=ARGB for frame area
            final BufferedImage frame = new BufferedImage(fr.w, fr.h, 2);
            arraycopy(pixels, 0, ((DataBufferInt) frame.getRaster().getDataBuffer()).getData(), 0, fr.wh);
            // Draw frame area on top of working image
            g.drawImage(frame, fr.x, fr.y, null);

            // Visualize frame boundaries during testing
            // if (DEBUG_MODE) {
            // if (prev != null) {
            // g.setColor(Color.RED); // Previous frame color
            // g.drawRect(prev.x, prev.y, prev.w - 1, prev.h - 1);
            // }
            // g.setColor(Color.GREEN); // New frame color
            // g.drawRect(fr.x, fr.y, fr.w - 1, fr.h - 1);
            // }

            // Keep one copy as "previous frame" in case we need to restore it
            prevPx = new int[wh];
            arraycopy(((DataBufferInt) img.getRaster().getDataBuffer()).getData(), 0, prevPx, 0, wh);

            // Create another copy for the end user to not expose internal state
            fr.img = new BufferedImage(w, h, 2); // 2 = ARGB
            arraycopy(prevPx, 0, ((DataBufferInt) fr.img.getRaster().getDataBuffer()).getData(), 0, wh);

            // Handle disposal of current frame
            if (fr.disposalMethod == 2)
            {
                // Restore to background color (clear frame area only)
                g.clearRect(fr.x, fr.y, fr.w, fr.h);
            }
            else if (fr.disposalMethod == 3 && prevPx != null)
            {
                // Restore previous frame
                arraycopy(prevPx, 0, ((DataBufferInt) img.getRaster().getDataBuffer()).getData(), 0, wh);
            }
        }

        /**
         * Returns the background color of the first frame in this GIF image. If
         * the frame has a local color table, the returned color will be from
         * that table. If not, the color will be from the global color table.
         * Returns 0 if there is neither a local nor a global color table.
         *
         * @param index
         *            Index of the current frame, 0 to N-1
         * @return 32 bit ARGB color in the form 0xAARRGGBB
         */
        public final int getBackgroundColor()
        {
            final GifFrame frame = frames.get(0);
            if (frame.hasLocColTbl)
            {
                return frame.localColTbl[bgColIndex];
            }
            else if (hasGlobColTbl)
            {
                return globalColTbl[bgColIndex];
            }
            return 0;
        }

        /**
         * If not 0, the delay specifies how many hundredths (1/100) of a second
         * to wait before displaying the frame <i>after</i> the current frame.
         *
         * @param index
         *            Index of the current frame, 0 to N-1
         * @return Delay as number of hundredths (1/100) of a second
         */
        public final int getDelay(final int index)
        {
            return frames.get(index).delay;
        }

        /**
         * @param index
         *            Index of the frame to return as image, starting from 0.
         *            For incremental calls such as [0, 1, 2, ...] the method's
         *            run time is O(1) as only one frame is drawn per call. For
         *            random access calls such as [7, 12, ...] the run time is
         *            O(N+1) with N being the number of previous frames that
         *            need to be drawn before N+1 can be drawn on top. Once a
         *            frame has been drawn it is being cached and the run time
         *            is more or less O(0) to retrieve it from the list.
         * @return A BufferedImage for the specified frame.
         */
        public final BufferedImage getFrame(final int index)
        {
            if (img == null)
            { // Init
                img = new BufferedImage(w, h, 2); // 2 = ARGB
                g = img.createGraphics();
                g.setBackground(new Color(0, true)); // Transparent color
            }
            GifFrame fr = frames.get(index);
            if (fr.img == null)
            {
                // Draw all frames until and including the requested frame
                for (int i = 0; i <= index; i++)
                {
                    fr = frames.get(i);
                    if (fr.img == null)
                    {
                        drawFrame(fr);
                    }
                }
            }
            return fr.img;
        }

        /**
         * @return The number of frames contained in this GIF image
         */
        public final int getFrameCount()
        {
            return frames.size();
        }

        /**
         * @return The height of the GIF image
         */
        public final int getHeight()
        {
            return h;
        }

        /**
         * @return The width of the GIF image
         */
        public final int getWidth()
        {
            return w;
        }
    }

    static final boolean DEBUG_MODE = false;

    /**
     * @param in
     *            Raw image data as a byte[] array
     * @return A GifImage object exposing the properties of the GIF image.
     * @throws IOException
     *             If the image violates the GIF specification or is truncated.
     */
    public static final GifImage read(final byte[] in) throws IOException
    {
        final GifDecoder decoder = new GifDecoder();
        final GifImage img = decoder.new GifImage();
        GifFrame frame = null; // Currently open frame
        int pos = readHeader(in, img); // Read header, get next byte position
        pos = readLogicalScreenDescriptor(img, in, pos);
        if (img.hasGlobColTbl)
        {
            img.globalColTbl = new int[img.sizeOfGlobColTbl];
            pos = readColTbl(in, img.globalColTbl, pos);
        }
        while (pos < in.length)
        {
            final int block = in[pos] & 0xFF;
            switch (block)
            {
                case 0x21: // Extension introducer
                    if (pos + 1 >= in.length)
                    {
                        throw new IOException("Unexpected end of file.");
                    }
                    switch (in[pos + 1] & 0xFF)
                    {
                        case 0xFE: // Comment extension
                            pos = readTextExtension(in, pos);
                        break;
                        case 0xFF: // Application extension
                            pos = readAppExt(img, in, pos);
                        break;
                        case 0x01: // Plain text extension
                            frame = null; // End of current frame
                            pos = readTextExtension(in, pos);
                        break;
                        case 0xF9: // Graphic control extension
                            if (frame == null)
                            {
                                frame = decoder.new GifFrame();
                                img.frames.add(frame);
                            }
                            pos = readGraphicControlExt(frame, in, pos);
                        break;
                        default:
                            throw new IOException("Unknown extension at " + pos);
                    }
                break;
                case 0x2C: // Image descriptor
                    if (frame == null)
                    {
                        frame = decoder.new GifFrame();
                        img.frames.add(frame);
                    }
                    pos = readImgDescr(frame, in, pos);
                    if (frame.hasLocColTbl)
                    {
                        frame.localColTbl = new int[frame.sizeOfLocColTbl];
                        pos = readColTbl(in, frame.localColTbl, pos);
                    }
                    pos = readImgData(frame, in, pos);
                    frame = null; // End of current frame
                break;
                case 0x3B: // GIF Trailer
                    return img; // Found trailer, finished reading.
                default:
                    // Unknown block. The image is corrupted. Strategies: a) Skip
                    // and wait for a valid block. Experience: It'll get worse. b)
                    // Throw exception. c) Return gracefully if we are almost done
                    // processing. The frames we have so far should be error-free.
                    final double progress = 1.0 * pos / in.length;
                    if (progress < 0.9)
                    {
                        throw new IOException("Unknown block at: " + pos);
                    }
                    pos = in.length; // Exit loop
            }
        }
        return img;
    }

    /**
     * @param is
     *            Image data as input stream. This method will read from the
     *            input stream's current position. It will not reset the
     *            position before reading and won't reset or close the stream
     *            afterwards. Call these methods before and after calling this
     *            method as needed.
     * @return A GifImage object exposing the properties of the GIF image.
     * @throws IOException
     *             If an I/O error occurs, the image violates the GIF
     *             specification or the GIF is truncated.
     */
    public static final GifImage read(final InputStream is) throws IOException
    {
        final byte[] data = new byte[is.available()];
        is.read(data, 0, data.length);
        return read(data);
    }

    /**
     * @param ext
     *            Empty application extension object
     * @param in
     *            Raw data
     * @param i
     *            Index of the first byte of the application extension
     * @return Index of the first byte after this extension
     */
    static final int readAppExt(final GifImage img, final byte[] in, int i)
    {
        img.appId = new String(in, i + 3, 8); // should be "NETSCAPE"
        img.appAuthCode = new String(in, i + 11, 3); // should be "2.0"
        i += 14; // Go to sub-block size, it's value should be 3
        final int subBlockSize = in[i] & 0xFF;
        // The only app extension widely used is NETSCAPE, it's got 3 data bytes
        if (subBlockSize == 3)
        {
            // in[i+1] should have value 01, in[i+5] should be block terminator
            img.repetitions = in[i + 2] & 0xFF | in[i + 3] & 0xFF << 8; // Short
            return i + 5;
        } // Skip unknown application extensions
        while ((in[i] & 0xFF) != 0)
        { // While sub-block size != 0
            i += (in[i] & 0xFF) + 1; // Skip to next sub-block
        }
        return i + 1;
    }

    /**
     * @param in
     *            Raw data
     * @param colors
     *            Pre-initialized target array to store ARGB colors
     * @param i
     *            Index of the color table's first byte
     * @return Index of the first byte after the color table
     */
    static final int readColTbl(final byte[] in, final int[] colors, int i)
    {
        final int numColors = colors.length;
        for (int c = 0; c < numColors; c++)
        {
            final int a = 0xFF; // Alpha 255 (opaque)
            final int r = in[i++] & 0xFF; // 1st byte is red
            final int g = in[i++] & 0xFF; // 2nd byte is green
            final int b = in[i++] & 0xFF; // 3rd byte is blue
            colors[c] = ((a << 8 | r) << 8 | g) << 8 | b;
        }
        return i;
    }

    /**
     * @param ext
     *            Graphic control extension object
     * @param in
     *            Raw data
     * @param i
     *            Index of the extension introducer
     * @return Index of the first byte after this block
     */
    static final int readGraphicControlExt(final GifFrame fr, final byte[] in, final int i)
    {
        fr.disposalMethod = (in[i + 3] & 0b00011100) >>> 2; // Bits 4-2
        fr.transpColFlag = (in[i + 3] & 1) == 1; // Bit 0
        fr.delay = in[i + 4] & 0xFF | (in[i + 5] & 0xFF) << 8; // 16 bit LSB
        fr.transpColIndex = in[i + 6] & 0xFF; // Byte 6
        return i + 8; // Skipped byte 7 (blockTerminator), as it's always 0x00
    }

    /**
     * @param in
     *            Raw data
     * @param img
     *            The GifImage object that is currently read
     * @return Index of the first byte after this block
     * @throws IOException
     *             If the GIF header/trailer is missing, incomplete or unknown
     */
    static final int readHeader(final byte[] in, final GifImage img) throws IOException
    {
        if (in.length < 6)
        { // Check first 6 bytes
            throw new IOException("Image is truncated.");
        }
        img.header = new String(in, 0, 6);
        if (!img.header.equals("GIF87a") && !img.header.equals("GIF89a"))
        {
            throw new IOException("Invalid GIF header.");
        }
        return 6;
    }

    /**
     * @param fr
     *            The GIF frame to whom this image descriptor belongs
     * @param in
     *            Raw data
     * @param i
     *            Index of the first byte of this block, i.e. the minCodeSize
     * @return
     */
    static final int readImgData(final GifFrame fr, final byte[] in, int i)
    {
        final int fileSize = in.length;
        final int minCodeSize = in[i++] & 0xFF; // Read code size, go to block
        final int clearCode = 1 << minCodeSize; // CLEAR = 2^minCodeSize
        fr.firstCodeSize = minCodeSize + 1; // Add 1 bit for CLEAR and EOI
        fr.clearCode = clearCode;
        fr.endOfInfoCode = clearCode + 1;
        final int imgDataSize = readImgDataSize(in, i);
        final byte[] imgData = new byte[imgDataSize + 2];
        int imgDataPos = 0;
        int subBlockSize = in[i] & 0xFF;
        while (subBlockSize > 0)
        { // While block has data
            try
            { // Next line may throw exception if sub-block size is fake
                final int nextSubBlockSizePos = i + subBlockSize + 1;
                final int nextSubBlockSize = in[nextSubBlockSizePos] & 0xFF;
                arraycopy(in, i + 1, imgData, imgDataPos, subBlockSize);
                imgDataPos += subBlockSize; // Move output data position
                i = nextSubBlockSizePos; // Move to next sub-block size
                subBlockSize = nextSubBlockSize;
            }
            catch (final Exception e)
            {
                // Sub-block exceeds file end, only use remaining bytes
                subBlockSize = fileSize - i - 1; // Remaining bytes
                arraycopy(in, i + 1, imgData, imgDataPos, subBlockSize);
                imgDataPos += subBlockSize; // Move output data position
                i += subBlockSize + 1; // Move to next sub-block size
                break;
            }
        }
        fr.data = imgData; // Holds LZW encoded data
        i++; // Skip last sub-block size, should be 0
        return i;
    }

    static final int readImgDataSize(final byte[] in, int i)
    {
        final int fileSize = in.length;
        int imgDataPos = 0;
        int subBlockSize = in[i] & 0xFF;
        while (subBlockSize > 0)
        { // While block has data
            try
            { // Next line may throw exception if sub-block size is fake
                final int nextSubBlockSizePos = i + subBlockSize + 1;
                final int nextSubBlockSize = in[nextSubBlockSizePos] & 0xFF;
                imgDataPos += subBlockSize; // Move output data position
                i = nextSubBlockSizePos; // Move to next sub-block size
                subBlockSize = nextSubBlockSize;
            }
            catch (final Exception e)
            {
                // Sub-block exceeds file end, only use remaining bytes
                subBlockSize = fileSize - i - 1; // Remaining bytes
                imgDataPos += subBlockSize; // Move output data position
                break;
            }
        }
        return imgDataPos;
    }

    /**
     * @param fr
     *            The GIF frame to whom this image descriptor belongs
     * @param in
     *            Raw data
     * @param i
     *            Index of the image separator, i.e. the first block byte
     * @return Index of the first byte after this block
     */
    static final int readImgDescr(final GifFrame fr, final byte[] in, int i)
    {
        fr.x = in[++i] & 0xFF | (in[++i] & 0xFF) << 8; // Byte 1-2: left
        fr.y = in[++i] & 0xFF | (in[++i] & 0xFF) << 8; // Byte 3-4: top
        fr.w = in[++i] & 0xFF | (in[++i] & 0xFF) << 8; // Byte 5-6: width
        fr.h = in[++i] & 0xFF | (in[++i] & 0xFF) << 8; // Byte 7-8: height
        fr.wh = fr.w * fr.h;
        final byte b = in[++i]; // Byte 9 is a packed byte
        fr.hasLocColTbl = (b & 0b10000000) >>> 7 == 1; // Bit 7
        fr.interlaceFlag = (b & 0b01000000) >>> 6 == 1; // Bit 6
        fr.sortFlag = (b & 0b00100000) >>> 5 == 1; // Bit 5
        final int colTblSizePower = (b & 7) + 1; // Bits 2-0
        fr.sizeOfLocColTbl = 1 << colTblSizePower; // 2^(N+1), As per the spec
        return ++i;
    }

    /**
     * @param img
     * @param i
     *            Start index of this block.
     * @return Index of the first byte after this block.
     */
    static final int readLogicalScreenDescriptor(final GifImage img, final byte[] in, final int i)
    {
        img.w = in[i] & 0xFF | (in[i + 1] & 0xFF) << 8; // 16 bit, LSB 1st
        img.h = in[i + 2] & 0xFF | (in[i + 3] & 0xFF) << 8; // 16 bit
        img.wh = img.w * img.h;
        final byte b = in[i + 4]; // Byte 4 is a packed byte
        img.hasGlobColTbl = (b & 0b10000000) >>> 7 == 1; // Bit 7
        final int colResPower = ((b & 0b01110000) >>> 4) + 1; // Bits 6-4
        img.colorResolution = 1 << colResPower; // 2^(N+1), As per the spec
        img.sortFlag = (b & 0b00001000) >>> 3 == 1; // Bit 3
        final int globColTblSizePower = (b & 7) + 1; // Bits 0-2
        img.sizeOfGlobColTbl = 1 << globColTblSizePower; // 2^(N+1), see spec
        img.bgColIndex = in[i + 5] & 0xFF; // 1 Byte
        img.pxAspectRatio = in[i + 6] & 0xFF; // 1 Byte
        return i + 7;
    }

    /**
     * @param in
     *            Raw data
     * @param pos
     *            Index of the extension introducer
     * @return Index of the first byte after this block
     */
    static final int readTextExtension(final byte[] in, final int pos)
    {
        int i = pos + 2; // Skip extension introducer and label
        int subBlockSize = in[i++] & 0xFF;
        while (subBlockSize != 0 && i < in.length)
        {
            i += subBlockSize;
            subBlockSize = in[i++] & 0xFF;
        }
        return i;
    }
}

==================================================

--- Файл №2 ---
Путь: main\java\mchorse\blockbuster\Blockbuster.java
--------------------
package mchorse.blockbuster;

import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.commands.CommandAction;
import mchorse.blockbuster.commands.CommandDamage;
import mchorse.blockbuster.commands.CommandModelBlock;
import mchorse.blockbuster.commands.CommandMount;
import mchorse.blockbuster.commands.CommandOnHead;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.commands.CommandScene;
import mchorse.blockbuster.commands.CommandSpectate;
import mchorse.blockbuster.common.BlockbusterPermissions;
import mchorse.blockbuster.utils.mclib.ValueAudioButtons;
import mchorse.blockbuster.utils.mclib.ValueMainButtons;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.mclib.McLib;
import mchorse.mclib.commands.utils.L10n;
import mchorse.mclib.config.ConfigBuilder;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueFloat;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueString;
import mchorse.mclib.events.RegisterConfigEvent;
import mchorse.mclib.events.RegisterPermissionsEvent;
import mchorse.mclib.permissions.McLibPermissions;
import mchorse.mclib.permissions.PermissionCategory;
import net.minecraft.block.Block;
import net.minecraft.client.resources.I18n;
import net.minecraft.creativetab.CreativeTabs;
import net.minecraft.item.Item;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.SidedProxy;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.event.FMLServerStartingEvent;
import net.minecraftforge.fml.common.event.FMLServerStoppingEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import net.minecraftforge.server.permission.DefaultPermissionLevel;
import org.apache.logging.log4j.Logger;

/**
 * <p>Blockbuster's main entry</p>
 *
 * <p>
 * This mod allows you to create machinimas in minecraft. Blockbuster provides
 * you with the most needed tools to create machinimas alone (without bunch of
 * complaining body actors).
 * </p>
 *
 * <p>
 * This mod is possible thanks to the following code/examples/resources/people:
 * </p>
 *
 * <ul>
 * <li>Jabelar's and TGG's minecraft modding tutorials</li>
 * <li>AnimalBikes and Mocap mods (EchebKeso)</li>
 * <li>MinecraftByExample</li>
 * <li>Ernio for helping with camera attributes sync, sharing with his own
 * network abstract layer code, and fixing the code so it would work on
 * dedicated server</li>
 * <li>diesieben07 for giving idea for actor skins</li>
 * <li>Choonster for pointing out that processInteract triggers for each
 * hand + TestMod3 config example</li>
 * <li>Lightwave for porting some of the code to 1.9.4</li>
 * <li>NlL5 for a lot of testing, giving lots of feedback and ideas for
 * Blockbuster mod</li>
 * <li>daipenger for giving me consultation on how to make cameras and
 * actors frame-based</li>
 * <li>TheImaginationCrafter for suggesting the OBJ feature which made
 * Blockbuster super popular and also more customizable (in terms
 * of custom models)</li>
 * </ul>
 */
@Mod(modid = Blockbuster.MOD_ID, name = Blockbuster.MODNAME, version = Blockbuster.VERSION, dependencies = "after:minema@[%MINEMA%,);before:better_lights@[%BETTERLIGHTS%,);before:aperture@[%APERTURE%,);before:emoticons@[%EMOTICONS%,);required-after:metamorph@[%METAMORPH%,);required-after:mclib@[%MCLIB%,);required-after:forge@[14.23.2.2638,)", updateJSON = "https://raw.githubusercontent.com/mchorse/blockbuster/1.12/version.json")
public class Blockbuster
{
    /* Mod info */
    public static final String MOD_ID = "blockbuster";
    public static final String MODNAME = "Blockbuster";
    public static final String VERSION = "%VERSION%";

    @SideOnly(Side.CLIENT)
    public static String WIKI_URL()
    {
        return langOrDefault("blockbuster.gui.links.wiki", "https://github.com/mchorse/blockbuster/wiki");
    }

    @SideOnly(Side.CLIENT)
    public static String DISCORD_URL()
    {
        return langOrDefault("blockbuster.gui.links.discord", "https://discord.gg/qfxrqUF");
    }

    @SideOnly(Side.CLIENT)
    public static String CHANNEL_URL()
    {
        return langOrDefault("blockbuster.gui.links.channel", "https://www.youtube.com/c/McHorsesMods");
    }

    @SideOnly(Side.CLIENT)
    public static String TWITTER_URL()
    {
        return langOrDefault("blockbuster.gui.links.twitter", "https://twitter.com/McHorsy");
    }

    @SideOnly(Side.CLIENT)
    public static String TUTORIAL_URL()
    {
        return langOrDefault("blockbuster.gui.links.tutorial", "https://www.youtube.com/watch?v=qDPEjf2TxAc&list=PLLnllO8nnzE-xmqdymsLpxnXTaAbyIVjM&index=2");
    }

    @SideOnly(Side.CLIENT)
    public static String langOrDefault(String lang, String orDefault)
    {
        String result = I18n.format(lang);

        return result.equals(lang) ? orDefault : result;
    }

    /* Proxies */
    public static final String CLIENT_PROXY = "mchorse.blockbuster.ClientProxy";
    public static final String SERVER_PROXY = "mchorse.blockbuster.CommonProxy";

    /* Creative tab */
    public static CreativeTabs blockbusterTab;

    /* Items */
    public static Item playbackItem;
    public static Item registerItem;
    public static Item actorConfigItem;
    public static Item[] modelBlockItems = new Item[16];
    public static Item gunItem;

    /* Blocks */
    public static Block directorBlock;
    public static Block modelBlock;
    public static Block greenBlock;
    public static Block dimGreenBlock;

    /* Forge stuff */
    @Mod.Instance
    public static Blockbuster instance;

    @SidedProxy(clientSide = CLIENT_PROXY, serverSide = SERVER_PROXY)
    public static CommonProxy proxy;

    public static Logger LOGGER;

    public static L10n l10n = new L10n(MOD_ID);

    /* Configuration */
    public static ValueBoolean generalFirstTime;
    public static ValueBoolean debugPlaybackTicks;
    public static ValueBoolean chromaSky;
    public static ValueInt chromaSkyColor;
    public static ValueBoolean syncedURLTextureDownload;
    public static ValueBoolean addUtilityBlocks;
    public static ValueFloat bbGunSyncDistance;

    public static ValueBoolean modelBlockDisableRendering;
    public static ValueBoolean modelBlockDisableItemRendering;
    public static ValueBoolean modelBlockRestore;
    public static ValueBoolean modelBlockResetOnPlayback;
    public static ValueBoolean modelBlockRenderMissingName;
    public static ValueBoolean modelBlockRenderDebuginf1;

    public static ValueFloat recordingCountdown;
    public static ValueInt recordUnloadTime;
    public static ValueBoolean recordUnload;
    public static ValueInt recordSyncRate;
    public static ValueBoolean recordAttackOnSwipe;
    public static ValueBoolean recordCommands;
    public static ValueString recordChatPrefix;
    public static ValueBoolean recordPausePreview;
    public static ValueBoolean recordRenderDebugPaths;

    public static ValueBoolean sceneSaveUpdate;

    public static ValueBoolean actorFallDamage;
    public static ValueInt actorTrackingRange;
    public static ValueInt actorRenderingRange;
    public static ValueBoolean actorAlwaysRender;
    public static ValueBoolean actorAlwaysRenderNames;
    public static ValueBoolean actorSwishSwipe;
    public static ValueBoolean actorFixY;
    public static ValueBoolean actorDisableRiding;
    public static ValueBoolean actorPlaybackBodyYaw;

    public static ValueBoolean damageControl;
    public static ValueInt damageControlDistance;
    public static ValueBoolean damageControlMessage;

    public static ValueString modelFolderPath;

    public static ValueBoolean snowstormDepthSorting;

    public static ValueBoolean audioWaveformVisible;
    public static ValueInt audioWaveformDensity;
    public static ValueFloat audioWaveformWidth;
    public static ValueInt audioWaveformHeight;
    public static ValueBoolean audioWaveformFilename;
    public static ValueBoolean audioWaveformTime;
    public static ValueBoolean audioSync;

    public static ValueInt morphActionOnionSkinColor;
    public static ValueInt seqOnionSkinPrev;
    public static ValueInt seqOnionSkinPrevColor;
    public static ValueInt seqOnionSkinNext;
    public static ValueInt seqOnionSkinNextColor;
    public static ValueInt seqOnionSkinLoopColor;

    public static ValueBoolean immersiveModelBlock;
    public static ValueBoolean immersiveRecordEditor;
    public static ValueBoolean enableBetterLights;

    /**
     * "Macro" for getting resource location for Blockbuster mod items,
     * entities, blocks, etc.
     */
    public static String path(String path)
    {
        return MOD_ID + ":" + path;
    }

    /**
     * Reloads server side models
     */
    public static void reloadServerModels(boolean force)
    {
        proxy.loadModels(force);
    }

    @SubscribeEvent
    public void onConfigRegister(RegisterConfigEvent event)
    {
        ConfigBuilder builder = event.createBuilder(MOD_ID);

        /* General */
        builder.category("general").register(new ValueMainButtons("buttons").clientSide());

        generalFirstTime = builder.getBoolean("show_first_time_modal", true);
        generalFirstTime.clientSide();
        debugPlaybackTicks = builder.getBoolean("debug_playback_ticks", false);
        chromaSky = builder.getBoolean("green_screen_sky", false);
        chromaSky.clientSide();
        chromaSkyColor = builder.getInt("green_screen_sky_color", 0xff00ff00).colorAlpha();
        chromaSkyColor.clientSide();
        syncedURLTextureDownload = builder.getBoolean("url_skins_sync_download", true);
        syncedURLTextureDownload.clientSide();
        addUtilityBlocks = builder.getBoolean("add_utility_blocks", false);
        addUtilityBlocks.clientSide();
        bbGunSyncDistance = builder.getFloat("bb_gun_sync_distance", 0, 0, 100);
        bbGunSyncDistance.clientSide();

        /* Model block */
        modelBlockDisableRendering = builder.category("model_block").getBoolean("model_block_disable_rendering", false);
        modelBlockDisableItemRendering = builder.getBoolean("model_block_disable_item_rendering", false);
        modelBlockRestore = builder.getBoolean("restore", false);
        modelBlockRenderMissingName = builder.getBoolean("model_block_missing_name_rendering", true);
        modelBlockRenderDebuginf1 = builder.getBoolean("model_block_debug_rendering_f1", false);

        builder.getCategory().markClientSide();

        modelBlockResetOnPlayback = builder.getBoolean("reset_on_playback", false);

        /* Recording */
        recordingCountdown = builder.category("recording").getFloat("recording_countdown", 1.5F, 0, 10);
        recordUnloadTime = builder.getInt("record_unload_time", 2400, 600, 72000);
        recordUnload = builder.getBoolean("record_unload", true);
        recordSyncRate = builder.getInt("record_sync_rate", 6, 1, 30);
        recordAttackOnSwipe = builder.getBoolean("record_attack_on_swipe", true);
        recordCommands = builder.getBoolean("record_commands", true);
        recordChatPrefix = builder.getString("record_chat_prefix", "");
        recordPausePreview = builder.getBoolean("record_pause_preview", true);
        recordRenderDebugPaths = builder.getBoolean("record_render_debug_paths", true);

        /* Scene */
        sceneSaveUpdate = builder.category("scenes").getBoolean("save_update", true);

        /* Actor */
        actorFallDamage = builder.category("actor").getBoolean("actor_fall_damage", true);
        actorTrackingRange = builder.getInt("actor_tracking_range", 256, 64, 1024);
        actorRenderingRange = builder.getInt("actor_rendering_range", 256, 64, 1024);
        actorRenderingRange.clientSide();
        actorAlwaysRender = builder.getBoolean("actor_always_render", false);
        actorAlwaysRender.clientSide();
        actorAlwaysRenderNames = builder.getBoolean("actor_always_render_names", false);
        actorAlwaysRenderNames.clientSide();
        actorSwishSwipe = builder.getBoolean("actor_swish_swipe", false);
        actorFixY = builder.getBoolean("actor_y", false);
        actorFixY.clientSide();
        actorDisableRiding = builder.getBoolean("actor_disable_riding", false);
        actorPlaybackBodyYaw = builder.getBoolean("actor_playback_body_yaw", true);
        actorPlaybackBodyYaw.clientSide();

        /* Damage control */
        damageControl = builder.category("damage_control").getBoolean("damage_control", true);
        damageControlDistance = builder.getInt("damage_control_distance", 64, 1, 1024);
        damageControlMessage = builder.getBoolean("damage_control_message", true);

        /* Model Folder */
        modelFolderPath = builder.category("model_folders").getString("path", "");

        /* Snowstorm */
        snowstormDepthSorting = builder.category("snowstorm").getBoolean("depth_sorting", false);

        builder.getCategory().markClientSide();

        /* Audio */
        builder.category("audio").register(new ValueAudioButtons("buttons"));

        audioWaveformVisible = builder.getBoolean("waveform_visible", true);
        audioWaveformVisible.clientSide();

        audioWaveformDensity = builder.getInt("waveform_density", 20, 10, 100);
        audioWaveformDensity.clientSide();

        audioWaveformWidth = builder.getFloat("waveform_width", 0.5F, 0F, 1F);
        audioWaveformWidth.clientSide();

        audioWaveformHeight = builder.getInt("waveform_height", 24, 10, 40);
        audioWaveformHeight.clientSide();

        audioWaveformFilename = builder.getBoolean("waveform_filename", true);
        audioWaveformFilename.clientSide();

        audioWaveformTime = builder.getBoolean("waveform_time", true);
        audioWaveformTime.clientSide();

        audioSync = builder.getBoolean("audio_sync", true);

        /* Onion skin */
        builder.category("onion_skin");

        morphActionOnionSkinColor = builder.getInt("morph_action_color", 0x7FFFFF00).colorAlpha();
        seqOnionSkinPrev = builder.getInt("seq_prev", 0);
        seqOnionSkinPrevColor = builder.getInt("seq_prev_color", 0xCCFF0000).colorAlpha();
        seqOnionSkinNext = builder.getInt("seq_next", 0);
        seqOnionSkinNextColor = builder.getInt("seq_next_color", 0xCC00FF00).colorAlpha();
        seqOnionSkinLoopColor = builder.getInt("seq_loop_color", 0xC07F7FFF).colorAlpha();

        builder.getCategory().invisible().markClientSide();

        /* Immersive editor */
        builder.category("immersive_editor");

        immersiveModelBlock = builder.getBoolean("model_block", true);
        immersiveRecordEditor = builder.getBoolean("record_editor", true);

        builder.getCategory().markClientSide();

        builder.category("better_lights");
        enableBetterLights = builder.getBoolean("enable_better_lights", true);

        builder.getCategory().markClientSide();

        CameraHandler.registerConfig(builder);
    }

    @SubscribeEvent
    public void onPermissionRegister(RegisterPermissionsEvent event)
    {
        event.registerMod(MOD_ID, DefaultPermissionLevel.OP);

        event.registerCategory(new PermissionCategory("model_block"));
        event.registerPermission(BlockbusterPermissions.editModelBlock = new PermissionCategory("edit"));

        event.endCategory();

        event.registerCategory(new PermissionCategory("scenes"));
        event.registerPermission(BlockbusterPermissions.openScene = new PermissionCategory("open"));

        event.endMod();
    }

    @EventHandler
    public void preLoad(FMLPreInitializationEvent event)
    {
        LOGGER = event.getModLog();
        McLib.EVENT_BUS.register(this);

        proxy.preLoad(event);
    }

    @EventHandler
    public void load(FMLInitializationEvent event)
    {
        proxy.load(event);
    }

    @EventHandler
    public void postLoad(FMLPostInitializationEvent event)
    {
        proxy.postLoad(event);
    }

    @EventHandler
    public void serverStarting(FMLServerStartingEvent event)
    {
        StructureMorph.STRUCTURE_CACHE.clear();
        proxy.loadModels(false);

        /* Register commands */
        event.registerServerCommand(new CommandAction());
        event.registerServerCommand(new CommandDamage());
        event.registerServerCommand(new CommandRecord());
        event.registerServerCommand(new CommandOnHead());
        event.registerServerCommand(new CommandSpectate());
        event.registerServerCommand(new CommandScene());
        event.registerServerCommand(new CommandModelBlock());
        event.registerServerCommand(new CommandMount());
    }

    @EventHandler
    public void serverStopping(FMLServerStoppingEvent event)
    {
        CommonProxy.manager.reset();
        CommonProxy.damage.reset();
        CommonProxy.scenes.reset();
    }
}


==================================================

--- Файл №3 ---
Путь: main\java\mchorse\blockbuster\ClientProxy.java
--------------------
package mchorse.blockbuster;

import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.api.ModelClientHandler;
import mchorse.blockbuster.api.ModelHandler;
import mchorse.blockbuster.audio.AudioLibrary;
import mchorse.blockbuster.client.ActorsPack;
import mchorse.blockbuster.client.KeyboardHandler;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.gui.GuiRecordingOverlay;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanels;
import mchorse.blockbuster.client.render.GunMiscRender;
import mchorse.blockbuster.client.render.RenderActor;
import mchorse.blockbuster.client.render.RenderExpirableDummy;
import mchorse.blockbuster.client.render.RenderGunProjectile;
import mchorse.blockbuster.client.render.tileentity.TileEntityDirectorRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelRenderer;
import mchorse.blockbuster.commands.CommandItemNBT;
import mchorse.blockbuster.commands.CommandModel;
import mchorse.blockbuster.common.block.BlockGreen.ChromaColor;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.common.entity.ExpirableDummyEntity;
import mchorse.blockbuster.common.tileentity.TileEntityDirector;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.recording.RecordManager;
import mchorse.blockbuster.recording.capturing.FrameHandler;
import mchorse.blockbuster.utils.mclib.BlockbusterJarTree;
import mchorse.blockbuster.utils.mclib.BlockbusterTree;
import mchorse.blockbuster_pack.client.gui.trackers.GuiMorphTracking;
import mchorse.blockbuster_pack.client.gui.trackers.GuiBaseTracker;
import mchorse.blockbuster_pack.client.render.RenderCustomActor;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.blockbuster_pack.morphs.structure.StructureRenderer;
import mchorse.blockbuster_pack.trackers.ApertureCamera;
import mchorse.blockbuster_pack.trackers.MorphTracker;
import mchorse.blockbuster_pack.trackers.BaseTracker;
import mchorse.blockbuster_pack.trackers.TrackerRegistry;
import mchorse.mclib.McLib;
import mchorse.mclib.utils.files.FileTree;
import mchorse.mclib.utils.files.GlobalTree;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.ItemMeshDefinition;
import net.minecraft.client.renderer.ItemModelMesher;
import net.minecraft.client.renderer.block.model.ModelBakery;
import net.minecraft.client.renderer.block.model.ModelResourceLocation;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.resources.IReloadableResourceManager;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.client.resources.IResourcePack;
import net.minecraft.client.resources.SimpleReloadableResourceManager;
import net.minecraft.item.Item;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.client.ClientCommandHandler;
import net.minecraftforge.client.model.ModelLoader;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.client.FMLClientHandler;
import net.minecraftforge.fml.client.registry.ClientRegistry;
import net.minecraftforge.fml.client.registry.IRenderFactory;
import net.minecraftforge.fml.client.registry.RenderingRegistry;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.List;

/**
 * Client proxy
 *
 * This class is responsible for registering item models, block models, entity
 * renders and injecting actor skin resource pack.
 */
@SideOnly(Side.CLIENT)
public class ClientProxy extends CommonProxy
{
    public static ActorsPack actorPack;
    public static GuiRecordingOverlay recordingOverlay;
    public static GuiBlockbusterPanels panels;

    public static RecordManager manager = new RecordManager();

    public static RenderCustomActor actorRenderer;
    public static TileEntityModelRenderer modelRenderer;
    public static KeyboardHandler keys;
    public static BlockbusterTree tree;
    public static AudioLibrary audio;
    public static File skinsFolder;

    /**
     * Register mod items, blocks, tile entites and entities, load item,
     * block models and register entity renderer.
     */
    @Override
    public void preLoad(FMLPreInitializationEvent event)
    {
        super.preLoad(event);

        /* Items */
        this.registerItemModel(Blockbuster.playbackItem, Blockbuster.path("playback"));
        this.registerItemModel(Blockbuster.registerItem, Blockbuster.path("register"));
        this.registerItemModel(Blockbuster.actorConfigItem, Blockbuster.path("actor_config"));
        this.registerItemModel(Blockbuster.gunItem, Blockbuster.path("gun"));

        /* Blocks */
        this.registerItemModel(Blockbuster.directorBlock, Blockbuster.path("director"));

        final ModelResourceLocation modelStatic = new ModelResourceLocation(Blockbuster.path("model_static"), "inventory");
        final ModelResourceLocation model = new ModelResourceLocation(Blockbuster.path("model"), "inventory");

        /* Register model block's configurable render disable */
        ItemMeshDefinition meshDefinition = (stack) -> Blockbuster.modelBlockDisableItemRendering.get() ? modelStatic : model;
        TileEntityModelItemStackRenderer teModelItemSR = new TileEntityModelItemStackRenderer();

        for (int i = 0; i < Blockbuster.modelBlockItems.length; i++)
        {
            Item modelBlockItem = Blockbuster.modelBlockItems[i];

            ModelBakery.registerItemVariants(modelBlockItem, model, modelStatic);
            ModelLoader.setCustomMeshDefinition(modelBlockItem, meshDefinition);
            modelBlockItem.setTileEntityItemStackRenderer(teModelItemSR);
        }

        Blockbuster.gunItem.setTileEntityItemStackRenderer(new TileEntityGunItemStackRenderer());

        /* Entities */
        this.registerEntityRender(EntityActor.class, new RenderActor.FactoryActor());
        //this.registerEntityRender(ExpirableDummyEntity.class, new RenderExpirableDummy.FactoryExpirableDummy());
        this.registerEntityRender(EntityGunProjectile.class, new RenderGunProjectile.FactoryGunProjectile());

        /* Tile entity */
        ClientRegistry.bindTileEntitySpecialRenderer(TileEntityModel.class, modelRenderer = new TileEntityModelRenderer());
        ClientRegistry.bindTileEntitySpecialRenderer(TileEntityDirector.class, new TileEntityDirectorRenderer());

        this.injectResourcePack(CommonProxy.configFile.getAbsolutePath());

        /* Structure morph */
        StructureMorph.STRUCTURES = new HashMap<String, StructureRenderer>();

        audio = new AudioLibrary(new File(CommonProxy.configFile, "audio"));
        skinsFolder = new File(configFile, "skins");
        skinsFolder.mkdirs();

        ResourceLocation blockbusterIcon = RLUtils.create("blockbuster", "textures/gui/icon.png");
        File skinsDirectory = new File(configFile, "models/image/skins");
        File targetFile = new File(skinsDirectory, "default.png");

        if (!targetFile.exists()) {
            try {
                InputStream originalStream = Minecraft.getMinecraft().getResourceManager().getResource(blockbusterIcon).getInputStream();
                Files.copy(originalStream, targetFile.toPath());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * Inject actors skin pack into FML's resource packs list
     *
     * It's done by accessing private FMLClientHandler list (via reflection) and
     * appending actor pack.
     *
     * Thanks to diesieben07 for giving the idea.
     */
    @SuppressWarnings("unchecked")
    private void injectResourcePack(String path)
    {
        try
        {
            Field field = FMLClientHandler.class.getDeclaredField("resourcePackList");
            field.setAccessible(true);

            List<IResourcePack> packs = (List<IResourcePack>) field.get(FMLClientHandler.instance());
            packs.add(actorPack = new ActorsPack());
            IResourceManager manager = Minecraft.getMinecraft().getResourceManager();

            if (manager instanceof SimpleReloadableResourceManager)
            {
                ((SimpleReloadableResourceManager) manager).reloadResourcePack(actorPack);
            }

            /* File tree */
            BlockbusterJarTree jarTree = new BlockbusterJarTree();

            GlobalTree.TREE.register(tree = new BlockbusterTree(this.pack.folders.get(0)));
            GlobalTree.TREE.register(jarTree);

            FileTree.addBackEntry(jarTree.root);

            /* Create steve, alex and fred skins folders */
            new File(path + "/models/steve/skins").mkdirs();
            new File(path + "/models/alex/skins").mkdirs();
            new File(path + "/models/fred/skins").mkdirs();
            new File(path + "/models/image/skins").mkdirs();
            new File(path + "/models/cape/skins").mkdirs();
            new File(path + "/models/eyes/3.0/skins").mkdirs();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Subscribe all event listeners to EVENT_BUS and attach any client-side
     * commands to the ClientCommandRegistry.
     */
    @Override
    public void load(FMLInitializationEvent event)
    {
        Minecraft mc = Minecraft.getMinecraft();

        /* Register manually models for all chroma blocks */
        Item green = Item.getItemFromBlock(Blockbuster.greenBlock);
        Item dimGreen = Item.getItemFromBlock(Blockbuster.dimGreenBlock);
        ItemModelMesher mesher = mc.getRenderItem().getItemModelMesher();

        for (ChromaColor color : ChromaColor.values())
        {
            ModelResourceLocation location = new ModelResourceLocation("blockbuster:green", "color=" + color.name);

            mesher.register(green, color.ordinal(), location);
            mesher.register(dimGreen, color.ordinal(), location);
        }

        /* Initiate rendering overlay and renderer */
        recordingOverlay = new GuiRecordingOverlay(mc);
        actorRenderer = new RenderCustomActor(mc.getRenderManager(), null, 0);

        super.load(event);

        /* Event listeners */
        MinecraftForge.EVENT_BUS.register(new FrameHandler());
        MinecraftForge.EVENT_BUS.register(keys = new KeyboardHandler());
        MinecraftForge.EVENT_BUS.register(new RenderingHandler(recordingOverlay));
        MinecraftForge.EVENT_BUS.register(new GunMiscRender());
        McLib.EVENT_BUS.register(panels = new GuiBlockbusterPanels());

        CameraHandler.registerClient();

        /* Client commands */
        ClientCommandHandler.instance.registerCommand(new CommandModel());
        ClientCommandHandler.instance.registerCommand(new CommandItemNBT());

        ((IReloadableResourceManager) mc.getResourceManager()).registerReloadListener((manager) ->
        {
            audio.reset();

            if (Minecraft.getMinecraft().player != null)
            {
                StructureMorph.reloadStructures();
            }
        });

        /* Tracker editors */
        TrackerRegistry.CLIENT = new HashMap<Class<? extends BaseTracker>, GuiBaseTracker<? extends BaseTracker>>();
        TrackerRegistry.CLIENT.put(MorphTracker.class, new GuiMorphTracking(mc));
        TrackerRegistry.CLIENT.put(ApertureCamera.class, new GuiBaseTracker<>(mc));
    }

    protected void registerItemModel(Block block, String path)
    {
        this.registerItemModel(Item.getItemFromBlock(block), path);
    }

    protected void registerItemModel(Item item, String path)
    {
        ModelLoader.setCustomModelResourceLocation(item, 0, new ModelResourceLocation(path, "inventory"));
    }

    @SuppressWarnings({"unchecked", "rawtypes"})
    protected void registerEntityRender(Class eclass, IRenderFactory factory)
    {
        RenderingRegistry.registerEntityRenderingHandler(eclass, factory);
    }

    @Override
    public boolean isClient()
    {
        return true;
    }

    @Override
    public ModelHandler getHandler()
    {
        return new ModelClientHandler();
    }

    /**
     * Client version of get language string.
     */
    @Override
    public String getLanguageString(String key, String defaultComment)
    {
        String comment = I18n.format(key);

        return comment.equals(key) ? defaultComment : comment;
    }
}

==================================================

--- Файл №4 ---
Путь: main\java\mchorse\blockbuster\CommonProxy.java
--------------------
package mchorse.blockbuster;

import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.api.ModelHandler;
import mchorse.blockbuster.api.ModelPack;
import mchorse.blockbuster.capabilities.CapabilityHandler;
import mchorse.blockbuster.capabilities.recording.IRecording;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.capabilities.recording.RecordingStorage;
import mchorse.blockbuster.client.particles.BedrockLibrary;
import mchorse.blockbuster.common.BlockbusterTab;
import mchorse.blockbuster.common.GuiHandler;
import mchorse.blockbuster.common.block.BlockDimGreen;
import mchorse.blockbuster.common.block.BlockDirector;
import mchorse.blockbuster.common.block.BlockGreen;
import mchorse.blockbuster.common.block.BlockModel;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.common.item.ItemActorConfig;
import mchorse.blockbuster.common.item.ItemBlockGreen;
import mchorse.blockbuster.common.item.ItemBlockModel;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.common.item.ItemPlayback;
import mchorse.blockbuster.common.item.ItemRegister;
import mchorse.blockbuster.common.tileentity.TileEntityDirector;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.events.GunShootHandler;
import mchorse.blockbuster.events.PlayerHandler;
import mchorse.blockbuster.events.TickHandler;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.recording.RecordManager;
import mchorse.blockbuster.recording.capturing.ActionHandler;
import mchorse.blockbuster.recording.capturing.DamageControlManager;
import mchorse.blockbuster.recording.scene.SceneManager;
import mchorse.blockbuster.utils.mclib.BlockbusterResourceTransformer;
import mchorse.blockbuster_pack.BlockbusterFactory;
import mchorse.blockbuster_pack.MetamorphHandler;
import mchorse.blockbuster_pack.trackers.ApertureCamera;
import mchorse.blockbuster_pack.trackers.MorphTracker;
import mchorse.blockbuster_pack.trackers.TrackerRegistry;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.MorphManager;
import net.minecraft.block.Block;
import net.minecraft.entity.Entity;
import net.minecraft.item.Item;
import net.minecraft.item.ItemBlock;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.common.capabilities.CapabilityManager;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPostInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import net.minecraftforge.fml.common.registry.EntityRegistry;
import net.minecraftforge.fml.common.registry.ForgeRegistries;
import net.minecraftforge.fml.common.registry.GameRegistry;

import java.io.File;

/**
 * Common proxy
 *
 * This class is responsible for registering items, blocks, entities,
 * capabilities and event listeners on both sides (that's why it's a common
 * proxy).
 */
public class CommonProxy
{
    /**
     * Record manager for server side
     */
    public static RecordManager manager = new RecordManager();

    /**
     * Damage control manager
     */
    public static DamageControlManager damage = new DamageControlManager();

    /**
     * Remote scene manager
     */
    public static SceneManager scenes = new SceneManager();

    /**
     * Incremented ID for entities
     */
    protected int ID = 0;

    /**
     * Model manager, this class is responsible for managing domain custom
     * models for custom actors
     */
    public ModelHandler models;

    /**
     * Model pack
     */
    public ModelPack pack;

    /**
     * Bedrock particle library
     */
    public BedrockLibrary particles;

    /**
     * Blockbuster's morphing factory
     */
    public BlockbusterFactory factory;

    public static File configFile;
    public final TickHandler tickHandler = new TickHandler();

    /**
     * Registers network messages (and their handlers), items, blocks, director
     * block tile entities and actor entity.
     */
    public void preLoad(FMLPreInitializationEvent event)
    {
        Dispatcher.register();
        NetworkRegistry.INSTANCE.registerGuiHandler(Blockbuster.instance, new GuiHandler());

        /* Configuration */
        configFile = new File(event.getModConfigurationDirectory(), "blockbuster");
        this.particles = new BedrockLibrary(new File(configFile, "models/particles"));

        /* Creative tab */
        Blockbuster.blockbusterTab = new BlockbusterTab();

        /* Items */
        this.registerItem(Blockbuster.registerItem = new ItemRegister());
        this.registerItem(Blockbuster.playbackItem = new ItemPlayback());
        this.registerItem(Blockbuster.actorConfigItem = new ItemActorConfig());
        this.registerItem(Blockbuster.gunItem = new ItemGun());

        /* Blocks */
        Block director = new BlockDirector();
        Block model = new BlockModel();
        Block green = new BlockGreen();
        Block dimGreen = new BlockDimGreen();

        green.setRegistryName("green").setUnlocalizedName("blockbuster.green");
        dimGreen.setRegistryName("dim_green").setUnlocalizedName("blockbuster.dim_green");

        ForgeRegistries.BLOCKS.register(Blockbuster.directorBlock = director);
        ForgeRegistries.ITEMS.register(new ItemBlock(director).setRegistryName(director.getRegistryName()));

        ForgeRegistries.BLOCKS.register(Blockbuster.modelBlock = model);

        ForgeRegistries.ITEMS.register(Blockbuster.modelBlockItems[0] = new ItemBlock(model).setRegistryName(model.getRegistryName()));

        for (int i = 1; i < Blockbuster.modelBlockItems.length; i++)
        {
            ForgeRegistries.ITEMS.register(Blockbuster.modelBlockItems[i] = new ItemBlockModel(model, i));
        }

        ForgeRegistries.BLOCKS.register(Blockbuster.greenBlock = green);
        ForgeRegistries.ITEMS.register(new ItemBlockGreen(green, true).setRegistryName(green.getRegistryName()));

        ForgeRegistries.BLOCKS.register(Blockbuster.dimGreenBlock = dimGreen);
        ForgeRegistries.ITEMS.register(new ItemBlockGreen(dimGreen, true).setRegistryName(dimGreen.getRegistryName()));

        /* Tile Entities */
        GameRegistry.registerTileEntity(TileEntityDirector.class, "blockbuster_director_tile_entity");
        GameRegistry.registerTileEntity(TileEntityModel.class, "blockbuster_model_tile_entity");

        /* Capabilities */
        CapabilityManager.INSTANCE.register(IRecording.class, new RecordingStorage(), Recording::new);

        /* Models and morphing */
        this.pack = new ModelPack();
        this.models = this.getHandler();
        this.factory = new BlockbusterFactory();
        this.factory.models = this.models;

        MorphManager.INSTANCE.factories.add(this.factory);
        RLUtils.register(new BlockbusterResourceTransformer());
        
        /* Aperture Modifiers */
        CameraHandler.register();

        /* Trackers */
        TrackerRegistry.registerTracker("aperture_tracker", MorphTracker.class);
        TrackerRegistry.registerTracker("apcam", ApertureCamera.class);
    }

    /**
     * This method is responsible for registering Mocap's event handler which
     * is responsible for capturing <s>pokemons</s> player actions.
     */
    public void load(FMLInitializationEvent event)
    {
        /* Entities */
        this.registerEntityWithEgg(EntityActor.class, new ResourceLocation("blockbuster:actor"), "blockbuster.Actor", 0xffc1ab33, 0xffa08d2b);
        EntityRegistry.registerModEntity(new ResourceLocation("blockbuster:projectile"), EntityGunProjectile.class, "blockbuster.GunProjectile", this.ID++, Blockbuster.instance, Blockbuster.actorTrackingRange.get(), 10, true);

        /* Event handlers */
        MinecraftForge.EVENT_BUS.register(this.models);
        MinecraftForge.EVENT_BUS.register(new ActionHandler());
        MinecraftForge.EVENT_BUS.register(new GunShootHandler());
        MinecraftForge.EVENT_BUS.register(new CapabilityHandler());
        MinecraftForge.EVENT_BUS.register(new MetamorphHandler());
        MinecraftForge.EVENT_BUS.register(new PlayerHandler());
        MinecraftForge.EVENT_BUS.register(this.tickHandler);
    }

    /**
     * Post load
     */
    public void postLoad(FMLPostInitializationEvent event)
    {}

    /**
     * Load models from given model pack
     *
     * This method is responsible only for loading domain models (in form of
     * data).
     */
    public void loadModels(boolean force)
    {
        this.models.loadModels(this.pack, force);
    }

    /**
     * Register an item with Forge's game registry
     */
    protected void registerItem(Item item)
    {
        ForgeRegistries.ITEMS.register(item);
    }

    /**
     * Thanks to animal bikes mod for this wonderful example! Kids, wanna learn
     * how to mod minecraft with forge? That's simple. Find mods for specific
     * minecraft version and decompile the .jar files with JD-GUI. Isn't that
     * simple?
     *
     * Or go to minecraft(forge/forum) and ask people to help you #smartass
     */
    protected void registerEntityWithEgg(Class<? extends Entity> entity, ResourceLocation id, String name, int primary, int secondary)
    {
        EntityRegistry.registerModEntity(id, entity, name, this.ID++, Blockbuster.instance, Blockbuster.actorTrackingRange.get(), 3, false, primary, secondary);
    }

    /**
     * Whether physical side is client
     */
    public boolean isClient()
    {
        return false;
    }

    /**
     * Get model handler
     */
    public ModelHandler getHandler()
    {
        return new ModelHandler();
    }

    /**
     * Get language string
     */
    public String getLanguageString(String key, String defaultComment)
    {
        return defaultComment;
    }
}

==================================================

--- Файл №5 ---
Путь: main\java\mchorse\blockbuster\aperture\CameraHandler.java
--------------------
package mchorse.blockbuster.aperture;

import mchorse.aperture.Aperture;
import mchorse.aperture.ClientProxy;
import mchorse.aperture.camera.CameraAPI;
import mchorse.aperture.camera.minema.MinemaIntegration;
import mchorse.aperture.camera.ModifierRegistry;
import mchorse.aperture.client.gui.GuiCameraEditor;
import mchorse.aperture.client.gui.GuiModifiersManager;
import mchorse.aperture.events.CameraEditorEvent;
import mchorse.aperture.network.common.PacketCameraProfileList;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.aperture.camera.modifiers.TrackerModifier;
import mchorse.blockbuster.aperture.gui.GuiDirectorConfigOptions;
import mchorse.blockbuster.aperture.gui.GuiPlayback;
import mchorse.blockbuster.aperture.gui.panels.modifiers.GuiTrackerModifierPanel;
import mchorse.blockbuster.aperture.network.client.ClientHandlerCameraProfileList;
import mchorse.blockbuster.aperture.network.client.ClientHandlerSceneLength;
import mchorse.blockbuster.aperture.network.common.PacketAudioShift;
import mchorse.blockbuster.aperture.network.common.PacketRequestLength;
import mchorse.blockbuster.aperture.network.common.PacketRequestProfiles;
import mchorse.blockbuster.aperture.network.common.PacketSceneLength;
import mchorse.blockbuster.aperture.network.server.ServerHandlerAudioShift;
import mchorse.blockbuster.aperture.network.server.ServerHandlerRequestLength;
import mchorse.blockbuster.aperture.network.server.ServerHandlerRequestProfiles;
import mchorse.blockbuster.audio.AudioRenderer;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanels;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.item.ItemPlayback;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.PacketSceneRequestCast;
import mchorse.blockbuster.network.common.scene.sync.PacketSceneGoto;
import mchorse.blockbuster.network.common.scene.sync.PacketScenePlay;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDrawable;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.ConfigBuilder;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.common.Optional.Method;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

/**
 * Camera handler
 *
 * This is the event listener for soft dependency integration with Aperture mod.
 * Basically what it does is hooks up these event listeners to Aperture and GUI
 * events and control the director block playback based on these events.
 */
public class CameraHandler
{
    /**
     * Tick which is used to set the value of the camera editor scrub back
     */
    public static int tick = 0;

    /**
     * Whether director should be reloaded when entering camera editor GUI
     */
    public static ValueBoolean reload;

    /**
     * Whether actions should played back also
     */
    public static ValueBoolean actions;
    
    /**
     * Whether scene should be stopped when exiting camera editor GUI
     */
    public static ValueBoolean stopScene;

    /**
     * Camera editor integrations
     */
    @SideOnly(Side.CLIENT)
    public static GuiElement cameraEditorElements;

    @SideOnly(Side.CLIENT)
    public static GuiElement editorElement;

    public static SceneLocation location;

    /**
     * Check whether Aperture is loaded
     */
    public static boolean isApertureLoaded()
    {
        return Loader.isModLoaded(Aperture.MOD_ID);
    }

    /**
     * Check whether Aperture and Minema is loaded
     */
    public static boolean isApertureAndMinemaLoaded()
    {
        return isApertureLoaded() && isMinemaAvailable();
    }

    /**
     * Check whether Minema is available
     */
    @Method(modid = Aperture.MOD_ID)
    private static boolean isMinemaAvailable()
    {
        return MinemaIntegration.isAvailable();
    }

    public static void register()
    {
        if (CameraHandler.isApertureLoaded())
        {
            registerModifiers();
        }
    }

    public static void registerClient()
    {
        if (CameraHandler.isApertureLoaded())
        {
            registerHandlers();
            
            registerClientModifiers();
        }
    }

    @Method(modid = Aperture.MOD_ID)
    private static void registerModifiers()
    {
        ModifierRegistry.register("tracker", TrackerModifier.class);
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void registerClientModifiers()
    {
        GuiModifiersManager.PANELS.put(TrackerModifier.class, GuiTrackerModifierPanel.class);
        ModifierRegistry.registerClient(TrackerModifier.class, "blockbuster.gui.aperture.modifiers.tracker", new Color(0.5F, 0.5F, 0.5F));
    }

    @Method(modid = Aperture.MOD_ID)
    private static void registerHandlers()
    {
        ClientProxy.EVENT_BUS.register(new CameraHandler());
        MinecraftForge.EVENT_BUS.register(new CameraGUIHandler());
    }

    public static void registerMessages()
    {
        if (CameraHandler.isApertureLoaded())
        {
            registerApertureMessages();
        }
    }

    @Method(modid = Aperture.MOD_ID)
    private static void registerApertureMessages()
    {
        Dispatcher.DISPATCHER.register(PacketRequestProfiles.class, ServerHandlerRequestProfiles.class, Side.SERVER);
        Dispatcher.DISPATCHER.register(PacketCameraProfileList.class, ClientHandlerCameraProfileList.class, Side.CLIENT);

        Dispatcher.DISPATCHER.register(PacketRequestLength.class, ServerHandlerRequestLength.class, Side.SERVER);
        Dispatcher.DISPATCHER.register(PacketSceneLength.class, ClientHandlerSceneLength.class, Side.CLIENT);

        Dispatcher.DISPATCHER.register(PacketAudioShift.class, ServerHandlerAudioShift.class, Side.SERVER);
    }
    
    public static void registerConfig(ConfigBuilder builder)
    {
        if (CameraHandler.isApertureLoaded())
        {
            builder.category("aperture");
            reload = builder.getBoolean("reload", true);
            actions = builder.getBoolean("actions", true);
            stopScene = builder.getBoolean("stop_scene", false);
            
            builder.getCategory().clientSide().invisible();
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public static void openCameraEditor()
    {
        Minecraft mc = Minecraft.getMinecraft();
        EntityPlayer player = mc.player;
        GuiCameraEditor editor = ClientProxy.getCameraEditor();

        editor.updateCameraEditor(player);
        player.setVelocity(0, 0, 0);
        mc.displayGuiScreen(editor);
    }

    @Method(modid = Aperture.MOD_ID)
    public static void handlePlaybackItem(EntityPlayer player, NBTTagCompound tag)
    {
        /* To allow actors using playback item without a crash */
        if (player instanceof EntityPlayerMP)
        {
            if (tag.hasKey("CameraPlay"))
            {
                CameraAPI.playCurrentProfile((EntityPlayerMP) player);
            }
            else if (tag.hasKey("CameraProfile"))
            {
                CameraAPI.playCameraProfile((EntityPlayerMP) player, RLUtils.create(tag.getString("CameraProfile")));
            }
        }
    }

    public static int getModeFromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("CameraPlay"))
        {
            return 1;
        }
        else if (tag.hasKey("CameraProfile"))
        {
            return 2;
        }

        return 0;
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public static void attach(SceneLocation location, List<String> scenes)
    {
        GuiPlayback playback = new GuiPlayback();

        playback.setLocation(location, scenes);
        Minecraft.getMinecraft().displayGuiScreen(playback);
    }

    public static boolean isCameraEditorOpen()
    {
        if (isApertureLoaded())
        {
            return isCurrentScreenCameraEditor();
        }

        return false;
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static boolean isCurrentScreenCameraEditor()
    {
        return Minecraft.getMinecraft().currentScreen instanceof GuiCameraEditor;
    }

    @SideOnly(Side.CLIENT)
    public static float getRoll()
    {
        if (isApertureLoaded())
        {
            return getApertureRoll();
        }

        return 0;
    }

    @SideOnly(Side.CLIENT)
    public static float getRoll(float partialTicks)
    {
        if (isApertureLoaded())
        {
            return getApertureRoll(partialTicks);
        }

        return 0;
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static float getApertureRoll()
    {
        return ClientProxy.control.roll;
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static float getApertureRoll(float partialTicks)
    {
        return ClientProxy.control.getRoll(partialTicks);
    }

    @SideOnly(Side.CLIENT)
    public static void setRoll(float prevRoll, float roll)
    {
        if (isApertureLoaded())
        {
            setApertureRoll(prevRoll, roll);
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void setApertureRoll(float prevRoll, float roll)
    {
        ClientProxy.control.setRoll(prevRoll, roll);
    }

    @SideOnly(Side.CLIENT)
    public static void resetRoll()
    {
        if (isApertureLoaded())
        {
            resetApertureRoll();
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void resetApertureRoll()
    {
        ClientProxy.control.resetRoll();
    }

    @SideOnly(Side.CLIENT)
    public static int getOffset()
    {
        if (isApertureLoaded())
        {
            return getCameraOffset();
        }

        return -1;
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static int getCameraOffset()
    {
        GuiScreen screen = Minecraft.getMinecraft().currentScreen;

        if (screen instanceof GuiCameraEditor)
        {
            return ((GuiCameraEditor) screen).timeline.value;
        }

        return -1;
    }

    public static void closeScreenOrCameraEditor()
    {
        GuiScreen screen = Minecraft.getMinecraft().currentScreen;

        if (isApertureLoaded())
        {
            if (closeCameraEditor(screen))
            {
                return;
            }
        }

        Minecraft.getMinecraft().displayGuiScreen(null);
    }

    private static boolean closeCameraEditor(GuiScreen screen)
    {
        if (screen instanceof GuiCameraEditor)
        {
            ((GuiCameraEditor) screen).closeThisScreen();
        }

        return screen instanceof GuiCameraEditor;
    }

    @SideOnly(Side.CLIENT)
    public static void updatePlayerPosition()
    {
        if (isApertureLoaded())
        {
            updateCameraPlayerPosition();
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void updateCameraPlayerPosition()
    {
        ClientProxy.cameraEditor.position.set(Minecraft.getMinecraft().player);
    }

    @SideOnly(Side.CLIENT)
    public static void attachOutside()
    {
        if (isApertureLoaded())
        {
            attachCameraOutside();
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void attachCameraOutside()
    {
        ClientProxy.runner.attachOutside();
    }

    @SideOnly(Side.CLIENT)
    public static void detachOutside()
    {
        if (isApertureLoaded())
        {
            detachCameraOutside();
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void detachCameraOutside()
    {
        ClientProxy.runner.detachOutside();
    }

    /* Event listeners */

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public void onCameraScrub(CameraEditorEvent.Scrubbed event)
    {
        SceneLocation location = get();

        if (location != null)
        {
            Dispatcher.sendToServer(new PacketSceneGoto(location, event.position, CameraHandler.actions.get()));
        }

        GuiBlockbusterPanels dashboard = mchorse.blockbuster.ClientProxy.panels;

        if (dashboard != null && dashboard.recordingEditorPanel.timeline.isVisible())
        {
            ScrollArea scroll = dashboard.recordingEditorPanel.timeline.scroll;

            scroll.scrollIntoView(scroll.scrollItemSize * (event.position - dashboard.recordingEditorPanel.record.preDelay), 2);
            dashboard.recordingEditorPanel.timeline.cursor = event.position;
        }
    }

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public void onCameraPlause(CameraEditorEvent.Playback event)
    {
        SceneLocation location = get();

        if (location != null)
        {
            Dispatcher.sendToServer(new PacketScenePlay(location, event.play ? PacketScenePlay.PLAY : PacketScenePlay.PAUSE, event.position));
        }
    }

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public void onCameraRewind(CameraEditorEvent.Rewind event)
    {
        SceneLocation location = get();

        if (location != null)
        {
            Dispatcher.sendToServer(new PacketScenePlay(location, PacketScenePlay.RESTART, event.position));
            
            List<String> replays = new ArrayList<String>();
            
            for (Replay replay : mchorse.blockbuster.ClientProxy.panels.scenePanel.getReplays())
            {
                replays.add(replay.id);
            }
            
            for (EntityActor actor : Minecraft.getMinecraft().world.getEntities(EntityActor.class, actor -> {
                return actor.isEntityAlive() && EntityUtils.getRecordPlayer(actor) != null
                        && EntityUtils.getRecordPlayer(actor).record != null
                        && replays.contains(EntityUtils.getRecordPlayer(actor).record.filename);
            }))
            {
                actor.setDead();
            }
        }
    }

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public void onCameraOptions(CameraEditorEvent.Options event)
    {
        event.options.add(new GuiDirectorConfigOptions(Minecraft.getMinecraft(), event.editor));
    }

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    public void onCameraEditorInit(CameraEditorEvent.Init event)
    {
        location = null;

        GuiDashboard.get();

        Minecraft mc = Minecraft.getMinecraft();
        GuiCameraEditor editor = event.editor;
        GuiBlockbusterPanels panels = mchorse.blockbuster.ClientProxy.panels;
        GuiRecordingEditorPanel record = panels.recordingEditorPanel;

        /* Just in case */
        if (record == null)
        {
            return;
        }

        editorElement = new GuiElement(mc)
        {
            @Override
            public boolean mouseClicked(GuiContext context)
            {
                return super.mouseClicked(context) || (record.actionEditor.delegate != null && record.actionEditor.area.isInside(context));
            }

            @Override
            public boolean mouseScrolled(GuiContext context)
            {
                return super.mouseScrolled(context) || (record.actionEditor.delegate != null && record.actionEditor.area.isInside(context));
            }

            @Override
            public void draw(GuiContext context)
            {
                if (this.isVisible() && record.actionEditor.delegate != null)
                {
                    Area area = record.actionEditor.delegate.area;

                    area.draw(0x66000000);
                }

                if (editor.getRunner().isRunning())
                {
                    ScrollArea scroll = panels.recordingEditorPanel.timeline.scroll;

                    scroll.scrollIntoView(scroll.scrollItemSize * (int) (editor.getRunner().ticks - panels.recordingEditorPanel.record.preDelay), 2);
                    panels.recordingEditorPanel.timeline.cursor = (int) editor.getRunner().ticks;
                }

                super.draw(context);
            }
        };
        editorElement.noCulling();

        Consumer<GuiIconElement> refresh = (b) ->
        {
            boolean show = editorElement.isVisible();

            editor.panel.flex().h(1, show ? -150 : -70);
            editor.timeline.flex().y(1, show ? -100 : -20);
            record.records.flex().h(1, show ? -80 : 0);
            b.both(show ? Icons.DOWNLOAD : Icons.UPLOAD);

            editor.root.resize();
        };

        GuiIconElement open = new GuiIconElement(mc, BBIcons.EDITOR, (b) -> panels.recordingEditorPanel.records.toggleVisible());
        GuiIconElement toggle = new GuiIconElement(mc, Icons.UPLOAD, (b) ->
        {
            if (!record.timeline.isVisible())
            {
                return;
            }

            editorElement.setVisible(!editorElement.isVisible());
            refresh.accept(b);
        });

        GuiDrawable drawable = new GuiDrawable((context) ->
        {
            int w = (int) (editor.root.area.w * Blockbuster.audioWaveformWidth.get());

            AudioRenderer.renderAll(editor.root.area.x + (editor.root.area.w - w) / 2, editor.timeline.area.y - 15, w, Blockbuster.audioWaveformHeight.get(), context.screen.width, context.screen.height);
            record.timeline.cursor = editor.timeline.value;
        });

        IKey category = IKey.lang("blockbuster.gui.aperture.keys.category");
        IKey toggleEditor = IKey.lang("blockbuster.gui.aperture.keys.toggle_editor");
        IKey detachScene = IKey.lang("blockbuster.gui.aperture.keys.detach_scene");
        IKey reloadScene = IKey.lang("blockbuster.gui.aperture.keys.reload_scene");

        GuiDirectorConfigOptions directorOptions = editor.config.getChildren(GuiDirectorConfigOptions.class).get(0);

        open.tooltip(IKey.lang("blockbuster.gui.dashboard.player_recording"), Direction.TOP);
        open.keys().register(IKey.lang("blockbuster.gui.aperture.keys.toggle_list"), Keyboard.KEY_L, () -> open.clickItself(editor.context)).held(Keyboard.KEY_LCONTROL).category(category);
        toggle.tooltip(toggleEditor, Direction.TOP);
        toggle.keys().register(toggleEditor, Keyboard.KEY_E, () -> toggle.clickItself(editor.context)).held(Keyboard.KEY_LCONTROL).category(category);
        toggle.keys().register(detachScene, Keyboard.KEY_D, () -> directorOptions.detachScene.clickItself(editor.context)).held(Keyboard.KEY_LSHIFT).category(category).active(() -> !editor.flight.isFlightEnabled() && directorOptions.detachScene.isEnabled());
        toggle.keys().register(reloadScene, Keyboard.KEY_R, () -> directorOptions.reloadScene.clickItself(editor.context)).held(Keyboard.KEY_LSHIFT).category(category).active(() -> !editor.flight.isFlightEnabled());

        editorElement.setVisible(false);

        toggle.flex().relative(editor.timeline).set(0, 0, 20, 20).x(1F);
        open.flex().relative(editor.timeline).set(-20, 0, 20, 20);
        editor.timeline.flex().x(30).w(1, -60);

        editor.top.remove(editor.timeline);
        cameraEditorElements = new GuiElement(mc).noCulling();
        cameraEditorElements.add(drawable, editor.timeline, toggle, open, editorElement);

        editor.top.add(cameraEditorElements);
        refresh.accept(toggle);
    }

    /**
     * Get scene location from playback button
     */
    @SideOnly(Side.CLIENT)
    public static SceneLocation get()
    {
        ItemStack right = Minecraft.getMinecraft().player.getHeldItemMainhand();

        if (right.getItem() instanceof ItemPlayback && right.getTagCompound() != null && right.getTagCompound().hasKey("Scene"))
        {
            return new SceneLocation(right.getTagCompound().getString("Scene"));
        }

        return location;
    }

    public static boolean canSync()
    {
        return get() != null;
    }

    @SideOnly(Side.CLIENT)
    public static void moveRecordPanel(GuiRecordingEditorPanel panel)
    {
        if (isApertureLoaded())
        {
            moveRecordPanelToEditor(panel);
        }
    }

    @SideOnly(Side.CLIENT)
    @Method(modid = Aperture.MOD_ID)
    private static void moveRecordPanelToEditor(GuiRecordingEditorPanel panel)
    {
        GuiCameraEditor editor = ClientProxy.getCameraEditor();

        panel.timeline.removeFromParent();
        panel.timeline.flex().relative(editor.viewport);
        panel.actionEditor.removeFromParent();
        panel.actionEditor.flex().relative(editor.viewport);
        panel.records.removeFromParent();
        panel.records.flex().relative(editor.viewport).h(1F, editorElement.isVisible() ? -80 : 0);

        cameraEditorElements.prepend(panel.records);
        editorElement.add(panel.timeline, panel.actionEditor);
    }

    /**
     * Camera editor GUI handler
     *
     * This is also the part of the whole camera editor thing, but for
     * exception it only spawns actors when the camera editor GUI is getting
     * opened.
     */
    public static class CameraGUIHandler
    {
        @SubscribeEvent
        @SideOnly(Side.CLIENT)
        @Method(modid = Aperture.MOD_ID)
        public void onGuiOpen(GuiOpenEvent event)
        {
            if (Minecraft.getMinecraft().player == null)
            {
                return;
            }

            GuiScreen current = Minecraft.getMinecraft().currentScreen;
            GuiScreen toOpen = event.getGui();
            SceneLocation location = get();
            boolean toOpenCamera = toOpen instanceof GuiCameraEditor;

            if (location != null)
            {
                int tick = ClientProxy.getCameraEditor().timeline.value;

                if (!(current instanceof GuiCameraEditor) && toOpenCamera)
                {
                    /* Camera editor opens */
                    CameraHandler.tick = tick;

                    if (CameraHandler.reload.get())
                    {
                        Dispatcher.sendToServer(new PacketScenePlay(location, PacketScenePlay.START, tick));
                    }

                    Dispatcher.sendToServer(new PacketRequestLength(location));
                    Dispatcher.sendToServer(new PacketSceneRequestCast(location));
                }
            }

            if (toOpenCamera)
            {
                GuiDashboard.get();

                GuiRecordingEditorPanel panel = mchorse.blockbuster.ClientProxy.panels.recordingEditorPanel;

                panel.open();
                panel.appear();

                moveRecordPanelToEditor(panel);

                panel.records.setVisible(false);
            }
            else if (location != null && current instanceof GuiCameraEditor)
            {
                mchorse.blockbuster.ClientProxy.panels.recordingEditorPanel.saveAction();

                if (!((GuiCameraEditor) current).getRunner().isRunning() && stopScene.get())
                {
                    Dispatcher.sendToServer(new PacketScenePlay(location, PacketScenePlay.STOP, 0));
                }
            }
        }
    }
}

==================================================

--- Файл №6 ---
Путь: main\java\mchorse\blockbuster\aperture\camera\modifiers\TrackerModifier.java
--------------------
package mchorse.blockbuster.aperture.camera.modifiers;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import mchorse.aperture.camera.data.Angle;
import mchorse.metamorph.api.MorphUtils;
import org.lwjgl.opengl.GL11;

import mchorse.aperture.camera.CameraProfile;
import mchorse.aperture.camera.data.Position;
import mchorse.aperture.camera.fixtures.AbstractFixture;
import mchorse.aperture.camera.modifiers.AbstractModifier;
import mchorse.aperture.camera.modifiers.EntityModifier;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.blockbuster_pack.morphs.TrackerMorph;
import mchorse.blockbuster_pack.trackers.ApertureCamera;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueFloat;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.BodyPartManager;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;

public class TrackerModifier extends EntityModifier
{
    public final ValueFloat yaw = new ValueFloat("yaw");
    public final ValueFloat pitch = new ValueFloat("pitch");
    public final ValueFloat roll = new ValueFloat("roll");
    public final ValueBoolean relative = new ValueBoolean("relative", true);
    public final ValueBoolean mainCam = new ValueBoolean("main_cam", true);
    public final ValueBoolean lookAt = new ValueBoolean("look_at");

    public TrackerModifier()
    {
        super();

        this.register(this.yaw);
        this.register(this.pitch);
        this.register(this.roll);
        this.register(this.relative);
        this.register(this.mainCam);
        this.register(this.lookAt);
    }

    @Override
    public AbstractModifier create()
    {
        return new TrackerModifier();
    }

    @Override
    public void modify(long ticks, long offset, AbstractFixture fixture, float partialTick, float previewPartialTick, CameraProfile profile, Position pos)
    {
        if (this.checkForDead())
        {
            this.tryFindingEntity();
        }

        if (this.entities == null)
        {
            return;
        }

        if (!this.lookAt.get())
        {
            this.position.copy(pos);
        }

        if (fixture != null && this.relative.get())
        {
            fixture.applyFixture(0, 0, 0, profile, this.position);
        }

        if (!this.lookAt.get())
        {
            /* probably unnecessary, the other modifiers also dont have this */
            this.position.point.x = pos.point.x - this.position.point.x;
            this.position.point.y = pos.point.y - this.position.point.y;
            this.position.point.z = pos.point.z - this.position.point.z;

            this.position.angle.yaw = pos.angle.yaw - this.position.angle.yaw;
            this.position.angle.pitch = pos.angle.pitch - this.position.angle.pitch;
            this.position.angle.roll = pos.angle.roll - this.position.angle.roll;

            //TODO refactor this. Get rid of static buffer variables, I dont know why they exist
            ApertureCamera.tracking = this.selector.get();

            ApertureCamera.offsetPos.x = (float) this.offset.get().x;
            ApertureCamera.offsetPos.y = (float) this.offset.get().y;
            ApertureCamera.offsetPos.z = (float) this.offset.get().z;

            ApertureCamera.offsetRot.x = this.pitch.get();
            ApertureCamera.offsetRot.y = this.yaw.get();
            ApertureCamera.offsetRot.z = this.roll.get();

            if (this.mainCam.get())
            {
                ApertureCamera.offsetPos.x += this.position.point.x;
                ApertureCamera.offsetPos.y += this.position.point.y;
                ApertureCamera.offsetPos.z += this.position.point.z;

                ApertureCamera.offsetRot.x += this.position.angle.pitch;
                ApertureCamera.offsetRot.y += this.position.angle.yaw;
                ApertureCamera.offsetRot.z += this.position.angle.roll;
            }
        }

        Entity entity = this.entities.get(0);

        Render<Entity> render = Minecraft.getMinecraft().getRenderManager().getEntityRenderObject(entity);
        double baseX = entity.lastTickPosX + (entity.posX - entity.lastTickPosX) * (double) partialTick;
        double baseY = entity.lastTickPosY + (entity.posY - entity.lastTickPosY) * (double) partialTick;
        double baseZ = entity.lastTickPosZ + (entity.posZ - entity.lastTickPosZ) * (double) partialTick;
        float yaw = entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTick;
        GL11.glMatrixMode(GL11.GL_MODELVIEW);
        GL11.glPushMatrix();
        GL11.glLoadIdentity();
        ApertureCamera.enable = true;
        render.doRender(entity, baseX, baseY, baseZ, yaw, partialTick);
        ApertureCamera.enable = false;
        GL11.glPopMatrix();
        GlStateManager.disableLighting();

        if (this.lookAt.get())
        {
            double dX = ApertureCamera.pos.x - pos.point.x + this.offset.get().x;
            double dY = ApertureCamera.pos.y - pos.point.y + this.offset.get().y;
            double dZ = ApertureCamera.pos.z - pos.point.z + this.offset.get().z;

            Angle angle = Angle.angle(dX, dY, dZ);

            if (this.relative.get())
            {
                angle.yaw += pos.angle.yaw + this.yaw.get() - this.position.angle.yaw;
                angle.pitch += pos.angle.pitch + this.pitch.get() - this.position.angle.pitch;
            }

            pos.angle.set(angle.yaw, angle.pitch);
        }
        else
        {
            pos.point.set(ApertureCamera.pos.x, ApertureCamera.pos.y, ApertureCamera.pos.z);

            if (this.mainCam.get())
            {
                pos.angle.set(ApertureCamera.rot.y, ApertureCamera.rot.x, ApertureCamera.rot.z, pos.angle.fov);
            }
            else
            {
                pos.point.x += this.position.point.x;
                pos.point.y += this.position.point.y;
                pos.point.z += this.position.point.z;
            }
        }
    }

    @Override
    public void tryFindingEntity()
    {
        String selector = this.selector.get();
        this.entities = null;

        if (selector != null && !selector.isEmpty() && FMLCommonHandler.instance().getSide() == Side.CLIENT)
        {
            this.queryActor(selector);
        }
    }

    @Override
    protected boolean checkForDead()
    {
        if (!super.checkForDead())
        {
            Iterator<Entity> it = this.entities.iterator();

            while (it.hasNext())
            {
                if (!checkTracker(mchorse.metamorph.api.EntityUtils.getMorph((EntityLivingBase) it.next()), this.selector.get()))
                {
                    it.remove();
                }
            }

            if (this.entities.isEmpty())
            {
                this.entities = null;
            }
        }

        return this.entities == null;
    }

    private void queryActor(String selector)
    {
        if (CameraHandler.get() == null)
        {
            return;
        }

        List<String> replays = new ArrayList<String>();
        List<Entity> entities = new ArrayList<Entity>();

        for (Replay replay : ClientProxy.panels.scenePanel.getReplays())
        {
            replays.add(replay.id);
        }

        for (EntityLivingBase actor : Minecraft.getMinecraft().world.getEntities(EntityLivingBase.class, actor ->
        {
            return actor.isEntityAlive() && EntityUtils.getRecordPlayer(actor) != null && EntityUtils.getRecordPlayer(actor).record != null && replays.contains(EntityUtils.getRecordPlayer(actor).record.filename) && mchorse.metamorph.api.EntityUtils.getMorph(actor) != null;
        }))
        {
            if (checkTracker(mchorse.metamorph.api.EntityUtils.getMorph(actor), selector))
            {
                entities.add(actor);
            }
        }

        if (!entities.isEmpty())
        {
            this.entities = entities;
        }
    }

    private boolean checkTracker(AbstractMorph morph, String selector)
    {
        return MorphUtils.anyMatch(morph, (element) -> element instanceof TrackerMorph && ((TrackerMorph) element).tracker instanceof ApertureCamera && selector.equals(((TrackerMorph) element).tracker.name));
    }
}


==================================================

--- Файл №7 ---
Путь: main\java\mchorse\blockbuster\aperture\gui\GuiDirectorConfigOptions.java
--------------------
package mchorse.blockbuster.aperture.gui;

import mchorse.aperture.ClientProxy;
import mchorse.aperture.client.gui.GuiCameraEditor;
import mchorse.aperture.client.gui.config.GuiAbstractConfigOptions;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.aperture.network.common.PacketAudioShift;
import mchorse.blockbuster.client.gui.dashboard.panels.scene.GuiScenePanel;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.sync.PacketScenePlay;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiDirectorConfigOptions extends GuiAbstractConfigOptions
{
    private static GuiDirectorConfigOptions instance;

    public GuiButtonElement detachScene;
    public GuiToggleElement actions;
    public GuiToggleElement reload;
    public GuiToggleElement stopScene;
    public GuiButtonElement reloadScene;
    public GuiTrackpadElement audioShift;

    public static GuiDirectorConfigOptions getInstance()
    {
        return instance;
    }

    public GuiDirectorConfigOptions(Minecraft mc, GuiCameraEditor editor)
    {
        super(mc, editor);

        this.detachScene = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.aperture.config.detach"), (b) ->
        {
            if (CameraHandler.location != null)
            {
                Dispatcher.sendToServer(new PacketScenePlay(CameraHandler.location, PacketScenePlay.STOP, 0));

                CameraHandler.location = null;
                b.setEnabled(false);
            }
        });

        this.reload = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.aperture.config.reload"), CameraHandler.reload.get(), (b) ->
        {
            CameraHandler.reload.set(this.reload.isToggled());
        });

        this.actions = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.aperture.config.actions"), CameraHandler.actions.get(), (b) ->
        {
            CameraHandler.actions.set(this.actions.isToggled());
        });
        
        this.stopScene = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.aperture.config.stop_scene"), CameraHandler.stopScene.get(), (b) ->
        {
            CameraHandler.stopScene.set(this.stopScene.isToggled());
        });

        this.reloadScene = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.aperture.config.reload_scene"), (b) ->
        {
            SceneLocation location = CameraHandler.get();

            if (location != null)
            {
                Dispatcher.sendToServer(new PacketScenePlay(location, PacketScenePlay.RESTART, ClientProxy.getCameraEditor().timeline.value));
            }
        });

        this.audioShift = new GuiTrackpadElement(mc, (value) ->
        {
            SceneLocation location = CameraHandler.get();

            if (location != null)
            {
                Dispatcher.sendToServer(new PacketAudioShift(location, value.intValue()));

                GuiScenePanel panel = mchorse.blockbuster.ClientProxy.panels.scenePanel;

                if (panel.getLocation().equals(location))
                {
                    panel.getLocation().getScene().setAudioShift(value.intValue());
                }
            }
        });
        this.audioShift.integer().tooltip(IKey.lang("blockbuster.gui.director.audio_shift_tooltip"));

        this.add(this.detachScene, this.reload, this.actions, this.stopScene, this.reloadScene);
        this.add(Elements.label(IKey.lang("blockbuster.gui.director.audio_shift")).background(), this.audioShift);

        instance = this;
    }

    @Override
    public IKey getTitle()
    {
        return IKey.lang("blockbuster.gui.aperture.config.title");
    }

    @Override
    public void update()
    {
        this.reload.toggled(CameraHandler.reload.get());
        this.actions.toggled(CameraHandler.actions.get());
        this.stopScene.toggled(CameraHandler.stopScene.get());
    }

    @Override
    public void resize()
    {
        super.resize();

        this.detachScene.setEnabled(CameraHandler.location != null);
    }
}

==================================================

--- Файл №8 ---
Путь: main\java\mchorse\blockbuster\aperture\gui\GuiPlayback.java
--------------------
package mchorse.blockbuster.aperture.gui;

import mchorse.aperture.Aperture;
import mchorse.aperture.ClientProxy;
import mchorse.aperture.camera.CameraAPI;
import mchorse.aperture.camera.CameraProfile;
import mchorse.aperture.camera.destination.AbstractDestination;
import mchorse.aperture.camera.destination.ClientDestination;
import mchorse.aperture.client.gui.GuiProfilesManager;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.aperture.network.common.PacketRequestProfiles;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketPlaybackButton;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.Optional;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * GUI playback
 *
 * This GUI is responsible for attaching some properties to playback button's
 * ItemStack.
 */
@SideOnly(Side.CLIENT)
public class GuiPlayback extends GuiBase
{
    private String stringTitle = I18n.format("blockbuster.gui.playback.title");
    private String stringCameraMode = I18n.format("blockbuster.gui.playback.camera_mode");
    private String stringProfile = I18n.format("blockbuster.gui.playback.profile");
    private String stringScene = I18n.format("blockbuster.gui.playback.scene");

    private GuiCirculateElement cameraMode;
    private GuiButtonElement done;

    public GuiStringListElement scenes;
    public GuiListElement profiles;
    public Area frame = new Area();

    private SceneLocation location;
    private String profile = "";

    private boolean aperture;
    private int frameWidth = 150;

    public GuiPlayback()
    {
        Minecraft mc = Minecraft.getMinecraft();

        this.aperture = CameraHandler.isApertureLoaded();

        this.scenes = new GuiStringListElement(mc, (value) -> this.location = new SceneLocation(value.get(0)));
        this.scenes.background().flex().relative(this.frame).y(35).w(1F).h(1F, -65);

        this.done = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.done"), (b) -> this.saveAndQuit());
        this.done.flex().relative(this.frame).set(0, 0, 0, 20).y(1, -20).w(1F, 0);

        if (this.aperture)
        {
            this.frameWidth = 300;

            this.profiles = this.createListElement(mc);
            this.profiles.background().flex().set(153, 35, 0, 0).relative(this.frame).w(147).h(1, -105);

            this.scenes.flex().w(147);

            this.cameraMode = new GuiCirculateElement(mc, (b) -> this.setValue(this.cameraMode.getValue()));
            this.cameraMode.addLabel(IKey.lang("blockbuster.gui.playback.nothing"));
            this.cameraMode.addLabel(IKey.lang("blockbuster.gui.playback.play"));
            this.cameraMode.addLabel(IKey.lang("blockbuster.gui.playback.load_profile"));
            this.cameraMode.flex().relative(this.frame).set(153, 0, 0, 20).y(1, -50).w(147);

            this.root.add(this.profiles, this.cameraMode);
            this.fillData();
        }

        this.root.add(this.scenes, this.done);
    }

    /* Aperture specific methods */

    @Optional.Method(modid = Aperture.MOD_ID)
    private GuiListElement createListElement(Minecraft mc)
    {
        return new GuiProfilesManager.GuiCameraProfilesList(mc, null);
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    private void fillData()
    {
        /* Fill data */
        for (String filename : CameraAPI.getClientProfiles())
        {
            this.addDestination(new ClientDestination(filename));
        }

        this.profiles.sort();

        if (ClientProxy.server)
        {
            Dispatcher.sendToServer(new PacketRequestProfiles());
        }

        /* Fill the camera mode button */
        NBTTagCompound compound = Minecraft.getMinecraft().player.getHeldItemMainhand().getTagCompound();

        if (compound != null)
        {
            if (compound.hasKey("CameraPlay"))
            {
                this.setValue(1);
            }
            else if (compound.hasKey("CameraProfile"))
            {
                this.setValue(2, compound.getString("CameraProfile"));
            }
            else
            {
                this.setValue(0);
            }
        }
        else
        {
            this.setValue(0);
        }
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    public void selectCurrent()
    {
        this.selectCurrent(this.profile);
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    public void selectCurrent(String profile)
    {
        List<CameraProfile> list = (List<CameraProfile>) this.profiles.getList();

        for (int i = 0; i < list.size(); i ++)
        {
            if (list.get(i).getDestination().toResourceLocation().toString().equals(profile))
            {
                this.profiles.setIndex(i);

                break;
            }
        }
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    private void sendPlaybackButton()
    {
        Dispatcher.sendToServer(new PacketPlaybackButton(this.location, this.cameraMode.getValue(), this.getSelected()));
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    private String getSelected()
    {
        CameraProfile current = (CameraProfile) this.profiles.getCurrentFirst();

        if (current != null)
        {
            return current.getDestination().toResourceLocation().toString();
        }

        return "";
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    public void addDestination(AbstractDestination destination)
    {
        this.profiles.add(new CameraProfile(destination));
    }

    /* Remaining methods */

    public GuiPlayback setLocation(SceneLocation location, List<String> scenes)
    {
        this.location = location;

        this.scenes.clear();
        this.scenes.add(scenes);
        this.scenes.sort();
        this.scenes.setCurrentScroll(location.getFilename());

        return this;
    }

    public void setValue(int value)
    {
        this.cameraMode.setValue(value);
        this.profiles.setVisible(value == 2);
    }

    public void setValue(int value, String profile)
    {
        this.profile = profile;
        this.setValue(value);

        if (this.aperture)
        {
            this.selectCurrent(profile);
        }
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return false;
    }

    private void saveAndQuit()
    {
        if (this.aperture)
        {
            this.sendPlaybackButton();
        }
        else
        {
            Dispatcher.sendToServer(new PacketPlaybackButton(this.location, 0, ""));
        }

        this.mc.displayGuiScreen(null);
    }

    @Override
    public void initGui()
    {
        this.frame.set(this.width / 2 - this.frameWidth / 2, 10, this.frameWidth, this.height - 20);

        super.initGui();
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        GuiDraw.drawCustomBackground(0, 0, this.width, this.height);
        this.drawString(this.fontRenderer, this.stringTitle, this.frame.x, this.frame.y, 0xffffffff);

        if (this.cameraMode != null)
        {
            this.drawString(this.fontRenderer, this.stringCameraMode, this.cameraMode.area.x, this.cameraMode.area.y - 12, 0xffcccccc);

            if (this.cameraMode.getValue() == 2)
            {
                this.drawString(this.fontRenderer, this.stringProfile, this.profiles.area.x, this.profiles.area.y - 12, 0xffcccccc);
            }
        }

        this.drawString(this.fontRenderer, this.stringScene, this.scenes.area.x, this.scenes.area.y - 12, 0xffcccccc);

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

==================================================

--- Файл №9 ---
Путь: main\java\mchorse\blockbuster\aperture\gui\panels\modifiers\GuiTrackerModifierPanel.java
--------------------
package mchorse.blockbuster.aperture.gui.panels.modifiers;

import mchorse.aperture.camera.data.Point;
import mchorse.aperture.client.gui.GuiModifiersManager;
import mchorse.aperture.client.gui.panels.modifiers.GuiAbstractModifierPanel;
import mchorse.blockbuster.aperture.camera.modifiers.TrackerModifier;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiTrackerModifierPanel extends GuiAbstractModifierPanel<TrackerModifier>
{
    public GuiTextElement target;
    public GuiTrackpadElement x;
    public GuiTrackpadElement y;
    public GuiTrackpadElement z;
    public GuiTrackpadElement yaw;
    public GuiTrackpadElement pitch;
    public GuiTrackpadElement roll;
    public GuiToggleElement relative;
    public GuiToggleElement mainCam;
    public GuiToggleElement lookAt;
    
    public GuiTrackerModifierPanel(Minecraft mc, TrackerModifier modifier, GuiModifiersManager modifiers)
    {
        super(mc, modifier, modifiers);
        
        this.target = new GuiTextElement(mc, 500, (str) ->
        {
            this.modifiers.editor.postUndo(this.undo(this.modifier.selector, str));
            this.modifier.tryFindingEntity();
        });
        this.target.tooltip(IKey.lang("blockbuster.gui.aperture.modifiers.panels.tracker_tooltip"));

        this.x = new GuiTrackpadElement(mc, (value) ->
        {
            Point point = this.modifier.offset.get().copy();

            point.x = value;
            this.modifiers.editor.postUndo(this.undo(this.modifier.offset, point));
        });
        this.x.tooltip(IKey.lang("aperture.gui.panels.x"));

        this.y = new GuiTrackpadElement(mc, (value) ->
        {
            Point point = this.modifier.offset.get().copy();

            point.y = value;
            this.modifiers.editor.postUndo(this.undo(this.modifier.offset, point));
        });
        this.y.tooltip(IKey.lang("aperture.gui.panels.y"));

        this.z = new GuiTrackpadElement(mc, (value) ->
        {
            Point point = this.modifier.offset.get().copy();

            point.z = value;
            this.modifiers.editor.postUndo(this.undo(this.modifier.offset, point));
        });
        this.z.tooltip(IKey.lang("aperture.gui.panels.z"));

        this.yaw = new GuiTrackpadElement(mc, (value) ->
        {
            this.modifiers.editor.postUndo(this.undo(this.modifier.yaw, value.floatValue()));
        });
        this.yaw.tooltip(IKey.lang("aperture.gui.panels.yaw"));

        this.pitch = new GuiTrackpadElement(mc, (value) ->
        {
            this.modifiers.editor.postUndo(this.undo(this.modifier.pitch, value.floatValue()));
        });
        this.pitch.tooltip(IKey.lang("aperture.gui.panels.pitch"));

        this.roll = new GuiTrackpadElement(mc, (value) ->
        {
            this.modifiers.editor.postUndo(this.undo(this.modifier.roll, value.floatValue()));
        });
        this.roll.tooltip(IKey.lang("aperture.gui.panels.roll"));
        
        this.relative = new GuiToggleElement(mc, IKey.lang("aperture.gui.modifiers.panels.relative"), false, (b) ->
        {
            this.modifiers.editor.postUndo(this.undo(this.modifier.relative, b.isToggled()));
        });
        this.relative.tooltip(IKey.lang("aperture.gui.modifiers.panels.relative_tooltip"));
        
        this.mainCam = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.aperture.modifiers.panels.main_cam"), (b) ->
        {
            this.modifiers.editor.postUndo(this.undo(this.modifier.mainCam, b.isToggled()));
        });
        this.mainCam.tooltip(IKey.lang("blockbuster.gui.aperture.modifiers.panels.main_cam_tooltip"));

        this.lookAt = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.aperture.modifiers.panels.look_at"), (b) ->
        {
           this.modifiers.editor.postUndo(this.undo(this.modifier.lookAt, b.isToggled()));
        });
        this.lookAt.tooltip(IKey.lang("blockbuster.gui.aperture.modifiers.panels.look_at_tooltip"));

        this.fields.add(this.target, Elements.row(mc, 5, 0, 20, this.x, this.y, this.z), Elements.row(mc, 5, 0, 20, this.yaw, this.pitch, this.roll), this.relative, this.mainCam, this.lookAt);
    }

    @Override
    public void fillData()
    {
        super.fillData();

        this.target.setText(this.modifier.selector.get());
        this.x.setValue(this.modifier.offset.get().x);
        this.y.setValue(this.modifier.offset.get().y);
        this.z.setValue(this.modifier.offset.get().z);
        this.yaw.setValue(this.modifier.yaw.get());
        this.pitch.setValue(this.modifier.pitch.get());
        this.roll.setValue(this.modifier.roll.get());
        this.relative.toggled(this.modifier.relative.get());
        this.mainCam.toggled(this.modifier.mainCam.get());
        this.lookAt.toggled(this.modifier.lookAt.get());
    }

}


==================================================

--- Файл №10 ---
Путь: main\java\mchorse\blockbuster\aperture\network\client\ClientHandlerCameraProfileList.java
--------------------
package mchorse.blockbuster.aperture.network.client;

import mchorse.aperture.camera.destination.ServerDestination;
import mchorse.aperture.client.gui.GuiProfilesManager;
import mchorse.aperture.network.common.PacketCameraProfileList;
import mchorse.blockbuster.aperture.gui.GuiPlayback;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.GuiScreen;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerCameraProfileList extends ClientMessageHandler<PacketCameraProfileList>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketCameraProfileList message)
    {
        GuiScreen current = Minecraft.getMinecraft().currentScreen;

        if (current instanceof GuiPlayback)
        {
            GuiPlayback gui = (GuiPlayback) current;

            for (String filename : message.cameras)
            {
                gui.addDestination(new ServerDestination(filename));
            }

            gui.profiles.sort();
            gui.selectCurrent();
        }
    }
}

==================================================

--- Файл №11 ---
Путь: main\java\mchorse\blockbuster\aperture\network\client\ClientHandlerSceneLength.java
--------------------
package mchorse.blockbuster.aperture.network.client;

import mchorse.aperture.ClientProxy;
import mchorse.aperture.client.gui.GuiCameraEditor;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.aperture.gui.GuiDirectorConfigOptions;
import mchorse.blockbuster.aperture.network.common.PacketSceneLength;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerSceneLength extends ClientMessageHandler<PacketSceneLength>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketSceneLength message)
    {
        GuiCameraEditor editor = ClientProxy.getCameraEditor();

        editor.maxScrub = message.length;
        editor.timeline.value = CameraHandler.tick;
        editor.updateValues();
        editor.timeline.scale.view(editor.timeline.scale.getMinValue(), Math.max((int) editor.getProfile().getDuration(), message.length));

        GuiDirectorConfigOptions.getInstance().audioShift.setValue(message.shift);
    }
}

==================================================

--- Файл №12 ---
Путь: main\java\mchorse\blockbuster\aperture\network\common\PacketAudioShift.java
--------------------
package mchorse.blockbuster.aperture.network.common;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.network.common.scene.PacketScene;
import mchorse.blockbuster.recording.scene.SceneLocation;

public class PacketAudioShift extends PacketScene
{
    public int shift;

    public PacketAudioShift()
    {
        super();
    }

    public PacketAudioShift(SceneLocation location, int shift)
    {
        super(location);

        this.shift = shift;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.shift = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.shift);
    }
}

==================================================

--- Файл №13 ---
Путь: main\java\mchorse\blockbuster\aperture\network\common\PacketRequestLength.java
--------------------
package mchorse.blockbuster.aperture.network.common;

import mchorse.blockbuster.network.common.scene.PacketScene;
import mchorse.blockbuster.recording.scene.SceneLocation;

public class PacketRequestLength extends PacketScene
{
    public PacketRequestLength()
    {}

    public PacketRequestLength(SceneLocation location)
    {
        super(location);
    }
}

==================================================

--- Файл №14 ---
Путь: main\java\mchorse\blockbuster\aperture\network\common\PacketRequestProfiles.java
--------------------
package mchorse.blockbuster.aperture.network.common;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketRequestProfiles implements IMessage
{
    public PacketRequestProfiles()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №15 ---
Путь: main\java\mchorse\blockbuster\aperture\network\common\PacketSceneLength.java
--------------------
package mchorse.blockbuster.aperture.network.common;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketSceneLength implements IMessage
{
    public int length;
    public int shift;

    public PacketSceneLength()
    {}

    public PacketSceneLength(int length, int shift)
    {
        this.length = length;
        this.shift = shift;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.length = buf.readInt();
        this.shift = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.length);
        buf.writeInt(this.shift);
    }
}

==================================================

--- Файл №16 ---
Путь: main\java\mchorse\blockbuster\aperture\network\server\ServerHandlerAudioShift.java
--------------------
package mchorse.blockbuster.aperture.network.server;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.aperture.network.common.PacketAudioShift;
import mchorse.blockbuster.audio.AudioState;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerAudioShift extends ServerMessageHandler<PacketAudioShift>
{
    @Override
    public void run(EntityPlayerMP player, PacketAudioShift message)
    {
        Scene scene = message.get(player.world);

        if (scene != null)
        {
            scene.setAudioShift(message.shift);

            try
            {
                CommonProxy.scenes.save(scene.getId(), scene, false);
            }
            catch (Exception e)
            {}
        }
    }
}


==================================================

--- Файл №17 ---
Путь: main\java\mchorse\blockbuster\aperture\network\server\ServerHandlerRequestLength.java
--------------------
package mchorse.blockbuster.aperture.network.server;

import mchorse.blockbuster.aperture.network.common.PacketRequestLength;
import mchorse.blockbuster.aperture.network.common.PacketSceneLength;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestLength extends ServerMessageHandler<PacketRequestLength>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestLength message)
    {
        Scene scene = message.get(player.world);

        if (scene != null)
        {
            Dispatcher.sendTo(new PacketSceneLength(scene.getMaxLength(), scene.getAudioShift()), player);
        }
    }
}

==================================================

--- Файл №18 ---
Путь: main\java\mchorse\blockbuster\aperture\network\server\ServerHandlerRequestProfiles.java
--------------------
package mchorse.blockbuster.aperture.network.server;

import mchorse.aperture.camera.CameraAPI;
import mchorse.aperture.network.common.PacketCameraProfileList;
import mchorse.blockbuster.aperture.network.common.PacketRequestProfiles;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestProfiles extends ServerMessageHandler<PacketRequestProfiles>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestProfiles message)
    {
        Dispatcher.sendTo(new PacketCameraProfileList(CameraAPI.getServerProfiles()), player);
    }
}

==================================================

--- Файл №19 ---
Путь: main\java\mchorse\blockbuster\api\Model.java
--------------------
package mchorse.blockbuster.api;

import com.google.common.base.MoreObjects;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.annotations.Expose;
import mchorse.blockbuster.api.formats.obj.OBJMaterial;
import mchorse.blockbuster.api.json.ModelAdapter;
import mchorse.blockbuster.api.json.ModelLimbAdapter;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.resources.I18n;
import net.minecraft.util.ResourceLocation;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Scanner;

/**
 * Model class
 *
 * This class is a domain object that holds all information about the model like
 * its name, texture size, limbs, poses, interests and stuff.
 */
public class Model
{
    /**
     * Poses that are required by custom models
     */
    public static final List<String> REQUIRED_POSES = Arrays.asList("standing");

    /**
     * Scheme version. Would be used in future versions for extracting and
     * exporting purposes.
     */
    @Expose
    public String scheme = "1.3";

    /**
     * Not really sure what to do with this one.
     */
    @Expose
    public String name = "";

    /**
     * Default texture for this model
     */
    @Expose
    public ResourceLocation defaultTexture;

    /**
     * Texture size. First element is width, second is height.
     */
    @Expose
    public int[] texture = new int[] {64, 32};

    /**
     * Extrude max factor (allows to limit how many extruded sub levels you can have)
     */
    @Expose
    public int extrudeMaxFactor = 1;

    /**
     * Extrude inwards factor (allows to extrude inwards more bits)
     */
    @Expose
    public int extrudeInwards = 1;

    /**
     * Scale of the model 
     */
    @Expose
    public float[] scale = new float[] {1, 1, 1};

    /**
     * Scale to be displayed in GUI 
     */
    @Expose
    public float scaleGui = 1;

    /**
     * Class for the custom model 
     */
    @Expose
    public String model = "";

    /**
     * Does this model provides OBJ model
     */
    @Expose
    public boolean providesObj = false;

    /**
     * Does this model provides MTL file
     */
    @Expose
    public boolean providesMtl = false;

    @Expose
    public boolean legacyObj = true;

    /**
     * Skins folder 
     */
    @Expose
    public String skins = "";

    @Expose
    public Map<String, ModelLimb> limbs = new HashMap<String, ModelLimb>();

    @Expose
    public Map<String, ModelPose> poses = new HashMap<String, ModelPose>();

    @Expose
    public Map<String, String> presets = new HashMap<String, String>();

    public Map<String, OBJMaterial> materials = new HashMap<String, OBJMaterial>();

    public List<String> shapes = new ArrayList<String>();

    /**
     * Parse model from input stream
     */
    public static Model parse(InputStream stream) throws Exception
    {
        Scanner scanner = new Scanner(stream, "UTF-8");

        Model model = parse(scanner.useDelimiter("\\A").next());
        scanner.close();

        return model;
    }

    /**
     * This method parses an instance of Model class from provided JSON string.
     * This method also checks if model has all required poses for playing.
     */
    public static Model parse(String json) throws Exception
    {
        Gson gson = new GsonBuilder().registerTypeAdapter(Model.class, new ModelAdapter()).registerTypeAdapter(ModelLimb.class, new ModelLimbAdapter()).excludeFieldsWithoutExposeAnnotation().create();
        Model data = gson.fromJson(json, Model.class);

        for (String key : REQUIRED_POSES)
        {
            if (!data.poses.containsKey(key))
            {
                //throw new Exception(I18n.format("blockbuster.parsing.lacks_pose", data.name, key));
                throw new Exception("Error parsing model " + data.name + ": missing pose " + key);
            }
        }

        if (data.limbs.isEmpty())
        {
            //throw new Exception(I18n.format("blockbuster.parsing.lacks_limbs", data.name));
            throw new Exception("Error parsing model " + data.name + ": missing limbs");
        }

        data.fillInMissing();

        return data;
    }

    /**
     * Checks whether this model has textured materials 
     */
    public boolean hasTexturedMaterials()
    {
        if (this.materials.isEmpty())
        {
            return false;
        }

        for (OBJMaterial material : this.materials.values())
        {
            if (material.useTexture) return true;
        }

        return false;
    }

    /**
     * Add a limb into a model
     */
    public ModelLimb addLimb(String name)
    {
        return this.addLimb(new ModelLimb(name));
    }

    /**
     * Add a limb into a model
     */
    public ModelLimb addLimb(ModelLimb limb)
    {
        this.limbs.put(limb.name, limb);

        for (ModelPose pose : this.poses.values())
        {
            pose.limbs.put(limb.name, new ModelTransform());
        }

        return limb;
    }

    /**
     * Remove limb from a model
     *
     * If given any limb in the model is child of this limb, then they're
     * also getting removed.
     */
    public void removeLimb(ModelLimb limb)
    {
        this.limbs.remove(limb.name);

        List<ModelLimb> limbsToRemove = new ArrayList<ModelLimb>();

        for (ModelLimb child : this.limbs.values())
        {
            if (child.parent.equals(limb.name))
            {
                limbsToRemove.add(child);
            }
        }

        for (ModelPose pose : this.poses.values())
        {
            pose.limbs.remove(limb.name);
        }

        for (ModelLimb limbToRemove : limbsToRemove)
        {
            this.removeLimb(limbToRemove);
        }
    }

    /**
     * Rename given limb (this limb should already exist in this model)
     * @return 
     */
    public boolean renameLimb(ModelLimb limb, String newName)
    {
        if (this.limbs.containsKey(newName) || !this.limbs.containsValue(limb))
        {
            return false;
        }

        /* Rename limb name in poses */
        for (ModelPose pose : this.poses.values())
        {
            ModelTransform transform = pose.limbs.remove(limb.name);

            pose.limbs.put(newName, transform);
        }

        /* Rename all children limbs */
        for (ModelLimb child : this.limbs.values())
        {
            if (child.parent.equals(limb.name))
            {
                child.parent = newName;
            }
        }

        /* And finally remap the limb name to the new name */
        this.limbs.remove(limb.name);
        this.limbs.put(newName, limb);
        limb.name = newName;

        return true;
    }

    /**
     * Returns amount of limbs given limb hosts
     */
    public int getLimbCount(ModelLimb parent)
    {
        int count = 1;

        for (ModelLimb child : this.limbs.values())
        {
            if (child.parent.equals(parent.name))
            {
                count += this.getLimbCount(child);
            }
        }

        return count;
    }

    /**
     * Fill in missing transforms and assign name to every limb
     */
    public void fillInMissing()
    {
        for (Map.Entry<String, ModelLimb> entry : this.limbs.entrySet())
        {
            String key = entry.getKey();

            for (ModelPose pose : this.poses.values())
            {
                if (!pose.limbs.containsKey(key))
                {
                    pose.limbs.put(key, new ModelTransform());
                }
            }

            entry.getValue().name = key;
        }
    }

    /**
     * Get pose, or return default pose (which is the "standing" pose)
     */
    public ModelPose getPose(String key)
    {
        ModelPose pose = this.poses.get(key);

        return pose == null ? this.poses.get("standing") : pose;
    }

    /**
     * Clone a model
     */
    public Model copy()
    {
        Model b = new Model();

        b.texture = new int[] {this.texture[0], this.texture[1]};
        b.scale = new float[] {this.scale[0], this.scale[1], this.scale[2]};
        b.scaleGui = this.scaleGui;

        b.name = this.name;
        b.scheme = this.scheme;
        b.model = this.model;

        b.defaultTexture = this.defaultTexture == null ? null : RLUtils.clone(this.defaultTexture);
        b.providesObj = this.providesObj;
        b.providesMtl = this.providesMtl;
        b.legacyObj = this.legacyObj;
        b.skins = this.skins;

        for (Map.Entry<String, ModelLimb> entry : this.limbs.entrySet())
        {
            b.limbs.put(entry.getKey(), entry.getValue().clone());
        }

        for (Map.Entry<String, ModelPose> entry : this.poses.entrySet())
        {
            b.poses.put(entry.getKey(), entry.getValue().copy());
        }

        b.presets.putAll(this.presets);
        b.shapes.addAll(this.shapes);

        return b;
    }

    public List<String> getChildren(String limb)
    {
        Map<String, List<String>> tree = new HashMap<String, List<String>>();
        
        for (Map.Entry<String, ModelLimb> entry : this.limbs.entrySet())
        {
            String parent = entry.getValue().parent;

            if (tree.get(parent) == null)
            {
                tree.put(parent, new ArrayList<String>());
            }
            
            tree.get(parent).add(entry.getKey());
        }
        
        List<String> children = new ArrayList<String>();
        
        this.getChildren(tree, limb, children);
        
        return children;
    }
    
    private void getChildren(Map<String, List<String>> tree, String limb, List<String> out)
    {
        List<String> children = tree.get(limb);
        
        if (children != null)
        {
            out.addAll(children);
            
            for (String child : children)
            {
                getChildren(tree, child, out);
            }
        }
    }

    @Override
    public String toString()
    {
        return MoreObjects.toStringHelper(this).add("scheme", this.scheme).add("name", this.name).add("texture", Arrays.toString(this.texture)).add("limbs", this.limbs).add("poses", this.poses).toString();
    }
}

==================================================

--- Файл №20 ---
Путь: main\java\mchorse\blockbuster\api\ModelClientHandler.java
--------------------
package mchorse.blockbuster.api;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Client-side model handler
 * 
 * The difference between this class and its parent, is that this class 
 * is also compiling {@link ModelCustom} out of added {@link Model}s, 
 * and removes custom models from {@link ModelCustom#MODELS}.
 */
@SideOnly(Side.CLIENT)
public class ModelClientHandler extends ModelHandler
{
    @Override
    @SuppressWarnings("unchecked")
    public void addModel(String key, IModelLazyLoader loader) throws Exception
    {
        super.addModel(key, loader);

        ModelCustom.MODELS.put(key, loader.loadClientModel(key, this.models.get(key)));
    }

    @Override
    protected void addMorph(String key, Model model)
    {
        Blockbuster.proxy.factory.section.add(key, model, true);
    }

    @Override
    public void removeModel(String key)
    {
        super.removeModel(key);

        final ModelCustom model = ModelCustom.MODELS.remove(key);

        if (model == null)
        {
            return;
        }

        Minecraft.getMinecraft().addScheduledTask(() ->
        {
            /* If this gets run on the integrated server on the server 
             * side, then it kicks the player due to state exception
             * because OpenGL operations must be done on the client 
             * thread...
             * 
             * Hopefully scheduling it fix this issue 
             */
            model.delete();
            ModelExtrudedLayer.clearByModel(model);
        });
    }
}

==================================================

--- Файл №21 ---
Путь: main\java\mchorse\blockbuster\api\ModelHandler.java
--------------------
package mchorse.blockbuster.api;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent.ClientConnectedToServerEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.HashMap;
import java.util.Map;

/**
 * This class responsible for storing domain custom models and sending models to
 * players who are logged in.
 */
public class ModelHandler
{
    public static long lastUpdate;

    /**
     * Cached models, they're loaded from stuffs
     */
    public Map<String, Model> models = new HashMap<String, Model>();

    /**
     * Actors pack from which ModelHandler loads its models
     */
    public ModelPack pack;

    /**
     * Load user and default provided models into model map
     */
    public void loadModels(ModelPack pack, boolean force)
    {
        pack.reload();

        /* Load user provided models */
        for (Map.Entry<String, IModelLazyLoader> entry : (force ? pack.models : pack.changed).entrySet())
        {
            IModelLazyLoader loader = entry.getValue();

            try
            {
                if (force)
                {
                    this.removeModel(entry.getKey());
                }

                this.addModel(entry.getKey(), loader);
            }
            catch (Exception e)
            {
                e.printStackTrace();
                System.out.println("Error happened with " + entry.getKey());
            }
        }

        /* Remove unloaded models */
        for (String key : pack.removed)
        {
            this.removeModel(key);
        }

        lastUpdate = System.currentTimeMillis();
    }

    /**
     * Add model to the model handler 
     */
    public void addModel(String key, IModelLazyLoader loader) throws Exception
    {
        Model model = loader.loadModel(key);

        this.models.put(key, model);
        this.addMorph(key, model);
    }

    protected void addMorph(String key, Model model)
    {
        Blockbuster.proxy.factory.section.add(key, model, false);
    }

    /**
     * Remove model from model handler 
     */
    public void removeModel(String key)
    {
        Model model = this.models.remove(key);

        if (model != null)
        {
            Blockbuster.proxy.factory.section.remove(key);
        }
    }

    /**
     * Loads local models when connecting to the server
     */
    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public void onClientConnect(ClientConnectedToServerEvent event)
    {
        Blockbuster.proxy.loadModels(false);
        Blockbuster.proxy.particles.reload();
    }
}

==================================================

--- Файл №22 ---
Путь: main\java\mchorse\blockbuster\api\ModelLimb.java
--------------------
package mchorse.blockbuster.api;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.common.base.MoreObjects;
import com.google.gson.annotations.Expose;

import mchorse.blockbuster.common.OrientedBB;
import net.minecraft.inventory.EntityEquipmentSlot;

/**
 * Limb class
 *
 * This class is responsible for holding data that describing the limb.
 * It contains meta data and data about visuals and game play.
 */
public class ModelLimb
{
    /* OrientedBoundingBox */
    public transient List<OrientedBB> obbs = new ArrayList<>();

    /* Meta data */
    public String name = "";
    public String parent = "";

    /* Visuals */
    public int[] size = new int[] {4, 4, 4};
    public float sizeOffset = 0;
    public float itemScale = 1;
    public int[] texture = new int[] {0, 0};
    public float[] anchor = new float[] {0.5F, 0.5F, 0.5F};
    public float[] color = new float[] {1.0F, 1.0F, 1.0F};
    public float opacity = 1.0F;
    public boolean mirror;
    public boolean lighting = true;
    public boolean shading = true;
    public boolean smooth = false;
    public boolean is3D = false;

    /* Game play */
    public Holding holding = Holding.NONE;
    public ArmorSlot slot = ArmorSlot.NONE;
    public boolean hold = true;
    public boolean swiping;
    public boolean lookX;
    public boolean lookY;
    public boolean swinging;
    public boolean idle;
    public boolean invert;
    public boolean wheel;
    public boolean wing;
    public boolean roll;
    public boolean cape;

    /* OBJ */
    public float[] origin = new float[] {0F, 0F, 0F};

    /* VOX */
    public int specular = 0x00000000;

    public ModelLimb()
    {}

    public ModelLimb(String name)
    {
        this.name = name;
    }

    /**
     * Clone a model limb
     */
    @Override
    public ModelLimb clone()
    {
        ModelLimb b = new ModelLimb();

        if(!this.obbs.isEmpty()) 
        {
            for(OrientedBB obb : this.obbs)
            {
                b.obbs.add(obb.clone());
            }
        }
        
        b.name = this.name;
        b.parent = this.parent;

        b.size = new int[] {this.size[0], this.size[1], this.size[2]};
        b.sizeOffset = this.sizeOffset;
        b.itemScale = this.itemScale;
        b.texture = new int[] {this.texture[0], this.texture[1]};
        b.anchor = new float[] {this.anchor[0], this.anchor[1], this.anchor[2]};
        b.color = new float[] {this.color[0], this.color[1], this.color[2]};
        b.opacity = this.opacity;
        b.mirror = this.mirror;
        b.lighting = this.lighting;
        b.shading = this.shading;
        b.smooth = this.smooth;
        b.is3D = this.is3D;

        b.holding = this.holding;
        b.slot = this.slot;
        b.hold = this.hold;
        b.swiping = this.swiping;
        b.lookX = this.lookX;
        b.lookY = this.lookY;
        b.swinging = this.swinging;
        b.idle = this.idle;
        b.invert = this.invert;
        b.wheel = this.wheel;
        b.wing = this.wing;
        b.roll = this.roll;
        b.cape = this.cape;

        b.origin = new float[] {this.origin[0], this.origin[1], this.origin[2]};
        b.specular = this.specular;

        return b;
    }

    @Override
    public String toString()
    {
        return MoreObjects.toStringHelper(this).add("parent", this.parent).add("size", Arrays.toString(this.size)).add("texture", Arrays.toString(this.texture)).add("anchor", Arrays.toString(this.anchor)).add("mirror", this.mirror).toString();
    }

    public static enum Holding
    {
        NONE, RIGHT, LEFT;
    }

    /**
     * Armor slots
     */
    public static enum ArmorSlot
    {
        NONE(null, "none"), HEAD(EntityEquipmentSlot.HEAD, "head"), CHEST(EntityEquipmentSlot.CHEST, "chest"), LEFT_SHOULDER(EntityEquipmentSlot.CHEST, "left_shoulder"), RIGHT_SHOULDER(EntityEquipmentSlot.CHEST, "right_shoulder"), LEGGINGS(EntityEquipmentSlot.LEGS, "leggings"), LEFT_LEG(EntityEquipmentSlot.LEGS, "left_leg"), RIGHT_LEG(EntityEquipmentSlot.LEGS, "right_leg"), LEFT_FOOT(EntityEquipmentSlot.FEET, "left_foot"), RIGHT_FOOT(EntityEquipmentSlot.FEET, "right_foot");

        public final EntityEquipmentSlot slot;
        public final String name;

        public static ArmorSlot fromName(String str)
        {
            for (ArmorSlot slot : values())
            {
                if (slot.name.equals(str)) return slot;
            }

            return NONE;
        }

        private ArmorSlot(EntityEquipmentSlot slot, String name)
        {
            this.slot = slot;
            this.name = name;
        }
    }
}

==================================================

--- Файл №23 ---
Путь: main\java\mchorse\blockbuster\api\ModelPack.java
--------------------
package mchorse.blockbuster.api;

import com.google.common.collect.ImmutableList;
import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.api.loaders.IModelLoader;
import mchorse.blockbuster.api.loaders.ModelLoaderJSON;
import mchorse.blockbuster.api.loaders.ModelLoaderOBJ;
import mchorse.blockbuster.api.loaders.ModelLoaderVOX;
import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderJSON;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderOBJ;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderVOX;
import mchorse.blockbuster.api.resource.IResourceEntry;
import mchorse.blockbuster.api.resource.StreamEntry;
import mchorse.blockbuster.utils.mclib.ImageFolder;
import net.minecraftforge.common.DimensionManager;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Model pack class
 */
public class ModelPack
{
    /**
     * List of model loaders
     */
    public List<IModelLoader> loaders = new ArrayList<IModelLoader>();

    /**
     * Cached models
     */
    public Map<String, IModelLazyLoader> models = new HashMap<String, IModelLazyLoader>();

    /**
     * Folders which to check when reloading models
     */
    public List<File> folders = new ArrayList<File>();

    /**
     * Map for only changed models
     */
    public Map<String, IModelLazyLoader> changed = new HashMap<String, IModelLazyLoader>();

    /**
     * List of removed models
     */
    public List<String> removed = new ArrayList<String>();

    private long lastTime;

    private Map<String, ModelUserItem> packed = new HashMap<String, ModelUserItem>();

    public ModelPack()
    {
        this.loaders.add(new ModelLoaderVOX());
        this.loaders.add(new ModelLoaderOBJ());
        this.loaders.add(new ModelLoaderJSON());

        this.setupFolders();
        this.setupPackedModels();
    }

    private void setupPackedModels()
    {
        try
        {
            InputStream stream = this.getClass().getClassLoader().getResourceAsStream("assets/blockbuster/models/user.json");
            String json = IOUtils.toString(stream, StandardCharsets.UTF_8);

            this.packed = new Gson().fromJson(json, new TypeToken<Map<String, ModelUserItem>>(){}.getType());
        }
        catch (Exception e)
        {}
    }

    public IModelLazyLoader create(File file)
    {
        IModelLazyLoader lazyLoader = null;

        for (IModelLoader loader : this.loaders)
        {
            lazyLoader = loader.load(file);

            if (lazyLoader != null)
            {
                break;
            }
        }

        return lazyLoader;
    }

    /**
     * Setup folders
     */
    public void setupFolders()
    {
        this.folders.clear();
        this.addFolder(new ImageFolder(CommonProxy.configFile, "models"));

        if (Blockbuster.modelFolderPath != null && !Blockbuster.modelFolderPath.get().isEmpty())
        {
            this.addFolder(new File(Blockbuster.modelFolderPath.get()));
        }

        File server = DimensionManager.getCurrentSaveRootDirectory();

        if (server != null)
        {
            this.addFolder(new File(server, "blockbuster/models"));
        }
    }

    /**
     * Add a folder to the list of folders to where to look up models and skins
     */
    private void addFolder(File folder)
    {
        folder.mkdirs();

        if (folder.isDirectory())
        {
            this.folders.add(folder);
        }
    }

    /**
     * Reload model handler
     */
    public void reload()
    {
        this.setupFolders();

        this.changed.clear();
        this.removed.clear();
        this.lastTime = System.currentTimeMillis();

        for (File folder : this.folders)
        {
            this.reloadModels(folder, "");
        }

        this.removeOld();

        try
        {
            /* Load default provided models */
            this.addDefaultModel("alex");
            this.addDefaultModel("alex_3d");
            this.addDefaultModel("steve");
            this.addDefaultModel("steve_3d");
            this.addDefaultModel("fred");
            this.addDefaultModel("fred_3d");
            this.addDefaultModel("empty");
            this.addDefaultModel("cape");

            /* Eyes related models */
            List<String> shapes = ImmutableList.of(
                "eyebrow_l",
                "eyebrow_r",
                "eyelid_lb",
                "eyelid_lt",
                "eyelid_rb",
                "eyelid_rt"
            );

            this.addDefaultModel("eyes/3.0");
            this.addDefaultModel("eyes/3.0_1px");
            this.addDefaultModelWithShapes("eyes/3.1", shapes);
            this.addDefaultModelWithShapes("eyes/3.1_simple", shapes);
            this.addDefaultModel("eyes/alex");
            this.addDefaultModel("eyes/steve");
            this.addDefaultModel("eyes/fred");
            this.addDefaultModel("eyes/head");
            this.addDefaultModel("eyes/head_3d");

            /* Of course I know him, he's me */
            this.addDefaultModel("mchorse/head");

            if (this.packed != null)
            {
                for (Map.Entry<String, ModelUserItem> entry : this.packed.entrySet())
                {
                    this.addUserModel(entry.getKey(), entry.getValue());
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private void addUserModel(String id, ModelUserItem userItem)
    {
        IModelLazyLoader lazy = this.models.get(id);

        if (lazy == null)
        {
            String path = "assets/blockbuster/models/user/" + id;
            ClassLoader loader = this.getClass().getClassLoader();

            StreamEntry json = new StreamEntry(path + "/model.json", 0, loader);

            if (userItem.obj != null)
            {
                String mtlPath = userItem.mtl == null ? null : path + "/" + userItem.mtl;
                StreamEntry obj = new StreamEntry(path + "/" + userItem.obj, 0, loader);
                StreamEntry mtl = new StreamEntry(mtlPath, 0, loader);
                List<IResourceEntry> s = new ArrayList<IResourceEntry>();

                if (userItem.shapes != null)
                {
                    for (String shape : userItem.shapes)
                    {
                        s.add(new StreamEntry(path + "/"  + shape, 0, loader));
                    }
                }

                lazy = new ModelLazyLoaderOBJ(json, obj, mtl, s);
            }
            else if (userItem.vox != null)
            {
                lazy = new ModelLazyLoaderVOX(json, new StreamEntry(path + "/" + userItem.vox, 0, loader));
            }
            else
            {
                lazy = new ModelLazyLoaderJSON(json);
            }

            lazy.setLastTime(-1);

            this.models.put(id, lazy);
            this.changed.put(id, lazy);
            this.removed.remove(id);
        }
    }

    /**
     * Remove old entries
     */
    private void removeOld()
    {
        Iterator<Map.Entry<String, IModelLazyLoader>> it = this.models.entrySet().iterator();

        while (it.hasNext())
        {
            Map.Entry<String, IModelLazyLoader> entry = it.next();
            long lastTime = entry.getValue().getLastTime();

            if (lastTime < this.lastTime && lastTime >= 0)
            {
                it.remove();

                this.removed.add(entry.getKey());
            }
        }
    }

    /**
     * Add a default model bundled with the mod
     */
    private void addDefaultModel(String id) throws Exception
    {
        IModelLazyLoader lazy = this.models.get(id);

        if (lazy == null)
        {
            String path = "assets/blockbuster/models/entity/";
            ClassLoader loader = this.getClass().getClassLoader();

            lazy = new ModelLazyLoaderJSON(new StreamEntry(path + id + ".json", 0, loader));
            lazy.setLastTime(-1);

            this.models.put(id, lazy);
            this.changed.put(id, lazy);
            this.removed.remove(id);
        }
    }

    private void addDefaultModelWithShapes(String id, List<String> shapes) throws Exception
    {
        IModelLazyLoader lazy = this.models.get(id);

        if (lazy == null)
        {
            String path = "assets/blockbuster/models/entity/";
            ClassLoader loader = this.getClass().getClassLoader();

            StreamEntry json = new StreamEntry(path + id + ".json", 0, loader);
            StreamEntry obj = new StreamEntry(path + id + "/base.obj", 0, loader);
            List<IResourceEntry> s = new ArrayList<IResourceEntry>();

            for (String shape : shapes)
            {
                s.add(new StreamEntry(path + id + "/"  + shape + ".obj", 0, loader));
            }

            lazy = new ModelLazyLoaderOBJ(json, obj, new StreamEntry(null, 0, loader), s);
            lazy.setLastTime(-1);

            this.models.put(id, lazy);
            this.changed.put(id, lazy);
            this.removed.remove(id);
        }
    }

    /**
     * Reload models
     *
     * Simply caches files in the map
     */
    protected void reloadModels(File folder, String prefix)
    {
        for (File file : folder.listFiles())
        {
            String name = file.getName();

            if (name.startsWith("__") || name.equals("skins") || file.isFile() || (name.equals("particles") && prefix.isEmpty()))
            {
                continue;
            }

            String path = prefix + name;
            IModelLazyLoader lazyLoader = this.models.get(path);

            if (lazyLoader != null && lazyLoader.getLastTime() >= 0)
            {
                if (lazyLoader.stillExists())
                {
                    lazyLoader.setLastTime(this.lastTime);

                    if (lazyLoader.hasChanged())
                    {
                        this.changed.put(path, lazyLoader);
                    }

                    continue;
                }
            }
            else
            {
                /* Overwriting the default model */
                lazyLoader = null;
            }

            for (IModelLoader loader : this.loaders)
            {
                lazyLoader = loader.load(file);

                if (lazyLoader != null)
                {
                    lazyLoader.setLastTime(this.lastTime);

                    break;
                }
            }

            if (lazyLoader != null)
            {
                this.models.put(path, lazyLoader);
                this.changed.put(path, lazyLoader);
            }
            else
            {
                this.reloadModels(file, path + "/");
            }
        }
    }
}

==================================================

--- Файл №24 ---
Путь: main\java\mchorse\blockbuster\api\ModelPose.java
--------------------
package mchorse.blockbuster.api;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.common.base.MoreObjects;

import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.common.util.Constants;

/**
 * Pose class
 *
 * This class is responsible for holding transformation about every limb
 * available in the main model. Model parser should put default transforms
 * for limbs that don't have transformations.
 */
public class ModelPose
{
    public float[] size = new float[] {1, 1, 1};
    public Map<String, ModelTransform> limbs = new HashMap<String, ModelTransform>();

    /**
     * Shapes configurations
     */
    public final List<ShapeKey> shapes = new ArrayList<ShapeKey>();

    public void copy(ModelPose pose)
    {
        for (int i = 0, c = Math.min(pose.size.length, this.size.length); i < c; i++)
        {
            this.size[i] = pose.size[i];
        }

        for (Map.Entry<String, ModelTransform> entry : this.limbs.entrySet())
        {
            ModelTransform otherTransform = pose.limbs.get(entry.getKey());

            if (otherTransform != null)
            {
                entry.getValue().copy(otherTransform);
            }
        }
    }

    /**
     * Fill in missing transforms 
     */
    public void fillInMissing(ModelPose pose)
    {
        for (Map.Entry<String, ModelTransform> entry : pose.limbs.entrySet())
        {
            String key = entry.getKey();

            if (!this.limbs.containsKey(key))
            {
                this.limbs.put(key, entry.getValue().clone());
            }
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof ModelPose)
        {
            ModelPose pose = (ModelPose) obj;

            return ModelTransform.equalFloatArray(this.size, pose.size) && this.limbs.equals(pose.limbs) && this.shapes.equals(pose.shapes);
        }

        return super.equals(obj);
    }

    /**
     * Clone a model pose
     */
    public ModelPose copy()
    {
        ModelPose b = new ModelPose();

        b.size = new float[] {this.size[0], this.size[1], this.size[2]};

        for (Map.Entry<String, ModelTransform> entry : this.limbs.entrySet())
        {
            b.limbs.put(entry.getKey(), entry.getValue().clone());
        }

        for (ShapeKey key : this.shapes)
        {
            b.shapes.add(key.copy());
        }

        return b;
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Size", Constants.NBT.TAG_LIST))
        {
            NBTTagList list = tag.getTagList("Size", 5);

            if (list.tagCount() >= 3)
            {
                NBTUtils.readFloatList(list, this.size);
            }
        }

        if (tag.hasKey("Poses", Constants.NBT.TAG_COMPOUND))
        {
            this.limbs.clear();

            NBTTagCompound poses = tag.getCompoundTag("Poses");

            for (String key : poses.getKeySet())
            {
                ModelTransform trans = new ModelTransform();

                trans.fromNBT(poses.getCompoundTag(key));
                this.limbs.put(key, trans);
            }
        }

        if (tag.hasKey("Shapes"))
        {
            NBTTagList shapes = tag.getTagList("Shapes", Constants.NBT.TAG_COMPOUND);

            this.shapes.clear();

            for (int i = 0; i < shapes.tagCount(); i++)
            {
                NBTTagCompound key = shapes.getCompoundTagAt(i);

                if (key.hasKey("Name") && key.hasKey("Value"))
                {
                    ShapeKey shapeKey = new ShapeKey();

                    shapeKey.fromNBT(key);
                    this.shapes.add(shapeKey);
                }
            }
        }
    }

    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        NBTTagCompound poses = new NBTTagCompound();

        tag.setTag("Size", NBTUtils.writeFloatList(new NBTTagList(), this.size));
        tag.setTag("Poses", poses);

        for (Map.Entry<String, ModelTransform> entry : this.limbs.entrySet())
        {
            poses.setTag(entry.getKey(), entry.getValue().toNBT());
        }

        if (!this.shapes.isEmpty())
        {
            NBTTagList shapes = new NBTTagList();

            for (ShapeKey shape : this.shapes)
            {
                if (shape.value != 0)
                {
                    shapes.appendTag(shape.toNBT());
                }
            }

            tag.setTag("Shapes", shapes);
        }

        return tag;
    }

    @Override
    public String toString()
    {
        return MoreObjects.toStringHelper(this).add("size", this.size).add("limbs", this.limbs).toString();
    }

    public void setSize(float w, float h, float d)
    {
        this.size[0] = w;
        this.size[1] = h;
        this.size[2] = d;
    }
}

==================================================

--- Файл №25 ---
Путь: main\java\mchorse\blockbuster\api\ModelTransform.java
--------------------
package mchorse.blockbuster.api;

import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.utils.ITransformationObject;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.Minecraft;
import org.lwjgl.opengl.GL11;

import com.google.common.base.MoreObjects;

import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

/**
 * Transform class
 *
 * This class simply holds basic transformation data for every limb.
 */
public class ModelTransform implements ITransformationObject
{
    /**
     * Default model transform. Please don't modify its values. 
     */
    public static final ModelTransform DEFAULT = new ModelTransform();

    public float[] translate = new float[] {0, 0, 0};
    public float[] scale = new float[] {1, 1, 1};
    public float[] rotate = new float[] {0, 0, 0};

    @Override
    public void addTranslation(double x, double y, double z, GuiTransformations.TransformOrientation orientation)
    {
        Vector4f trans = new Vector4f((float) x,(float) y,(float) z, 1);

        if (orientation == GuiTransformations.TransformOrientation.LOCAL)
        {
            float rotX = (float) Math.toRadians(this.rotate[0]);
            float rotY = (float) Math.toRadians(this.rotate[1]);
            float rotZ = (float) Math.toRadians(this.rotate[2]);

            MatrixUtils.getRotationMatrix(rotX, rotY, rotZ, MatrixUtils.RotationOrder.XYZ).transform(trans);
        }

        this.translate[0] += trans.x;
        this.translate[1] += trans.y;
        this.translate[2] += trans.z;
    }

    public static boolean equalFloatArray(float[] a, float[] b)
    {
        if (a.length != b.length)
        {
            return false;
        }

        for (int i = 0; i < a.length; i++)
        {
            if (Math.abs(a[i] - b[i]) > 0.0001F)
            {
                return false;
            }
        }

        return true;
    }

    public boolean isDefault()
    {
        return this.equals(DEFAULT);
    }

    public void copy(ModelTransform transform)
    {
        for (int i = 0; i < 3; i++)
            this.translate[i] = transform.translate[i];
        for (int i = 0; i < 3; i++)
            this.scale[i] = transform.scale[i];
        for (int i = 0; i < 3; i++)
            this.rotate[i] = transform.rotate[i];
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof ModelTransform)
        {
            ModelTransform transform = (ModelTransform) obj;

            return equalFloatArray(this.translate, transform.translate) && equalFloatArray(this.rotate, transform.rotate) && equalFloatArray(this.scale, transform.scale);
        }

        return super.equals(obj);
    }

    /**
     * Clone a model transform
     */
    @Override
    public ModelTransform clone()
    {
        ModelTransform b = new ModelTransform();

        b.translate = new float[] {this.translate[0], this.translate[1], this.translate[2]};
        b.rotate = new float[] {this.rotate[0], this.rotate[1], this.rotate[2]};
        b.scale = new float[] {this.scale[0], this.scale[1], this.scale[2]};

        return b;
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("P", NBT.TAG_LIST)) NBTUtils.readFloatList(tag.getTagList("P", 5), this.translate);
        if (tag.hasKey("S", NBT.TAG_LIST)) NBTUtils.readFloatList(tag.getTagList("S", 5), this.scale);
        if (tag.hasKey("R", NBT.TAG_LIST)) NBTUtils.readFloatList(tag.getTagList("R", 5), this.rotate);
    }

    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        if (!this.isDefault())
        {
            if (!equalFloatArray(DEFAULT.translate, this.translate)) tag.setTag("P", NBTUtils.writeFloatList(new NBTTagList(), this.translate));
            if (!equalFloatArray(DEFAULT.scale, this.scale)) tag.setTag("S", NBTUtils.writeFloatList(new NBTTagList(), this.scale));
            if (!equalFloatArray(DEFAULT.rotate, this.rotate)) tag.setTag("R", NBTUtils.writeFloatList(new NBTTagList(), this.rotate));
        }

        return tag;
    }

    @SideOnly(Side.CLIENT)
    public void transform()
    {
        this.applyTranslate();
        this.applyRotate();
        this.applyScale();
    }

    @SideOnly(Side.CLIENT)
    public void applyTranslate()
    {
        GL11.glTranslatef(this.translate[0], this.translate[1], this.translate[2]);
    }

    @SideOnly(Side.CLIENT)
    public void applyRotate()
    {
        GL11.glRotatef(this.rotate[2], 0, 0, 1);
        GL11.glRotatef(this.rotate[1], 0, 1, 0);
        GL11.glRotatef(this.rotate[0], 1, 0, 0);
    }

    @SideOnly(Side.CLIENT)
    public void applyScale()
    {
        GL11.glScalef(this.scale[0], this.scale[1], this.scale[2]);
    }

    @Override
    public String toString()
    {
        return MoreObjects.toStringHelper(this).add("translate", this.translate).add("scale", this.scale).add("rotate", this.rotate).toString();
    }

    public void interpolate(ModelTransform a, ModelTransform b, float x, Interpolation interp)
    {
        for (int i = 0; i < this.translate.length; i++)
        {
            this.translate[i] = interp.interpolate(a.translate[i], b.translate[i], x);
            this.scale[i] = interp.interpolate(a.scale[i], b.scale[i], x);
            this.rotate[i] = interp.interpolate(a.rotate[i], b.rotate[i], x);
        }
    }
}

==================================================

--- Файл №26 ---
Путь: main\java\mchorse\blockbuster\api\ModelUserItem.java
--------------------
package mchorse.blockbuster.api;

import java.util.List;

public class ModelUserItem
{
    public String obj;
    public String mtl;
    public String vox;
    public List<String> shapes;
}

==================================================

--- Файл №27 ---
Путь: main\java\mchorse\blockbuster\api\formats\IMeshes.java
--------------------
package mchorse.blockbuster.api.formats;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;

import javax.vecmath.Vector3f;

public interface IMeshes
{
    public ModelCustomRenderer createRenderer(Model data, ModelCustom model, ModelLimb limb, ModelTransform transform);

    public Vector3f getMin();

    public Vector3f getMax();
}

==================================================

--- Файл №28 ---
Путь: main\java\mchorse\blockbuster\api\formats\Mesh.java
--------------------
package mchorse.blockbuster.api.formats;

/**
 * Holds the mesh data
 */
public class Mesh
{
    public float[] posData;
    public float[] texData;
    public float[] normData;
    public int triangles;

    public Mesh(int triangles)
    {
        this(new float[triangles * 9], new float[triangles * 6], new float[triangles * 9]);
    }

    public Mesh(float[] posData, float[] texData, float[] normData)
    {
        this.posData = posData;
        this.texData = texData;
        this.normData = normData;

        this.triangles = posData.length / 3;
    }
}


==================================================

--- Файл №29 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\MeshesOBJ.java
--------------------
package mchorse.blockbuster.api.formats.obj;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.ModelOBJRenderer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MeshesOBJ implements IMeshes
{
    public List<MeshOBJ> meshes = new ArrayList<MeshOBJ>();
    public Map<String, List<MeshOBJ>> shapes;

    public ModelCustomRenderer createRenderer(Model data, ModelCustom model, ModelLimb limb, ModelTransform transform)
    {
        if (!data.providesObj)
        {
            return null;
        }

        return new ModelOBJRenderer(model, limb, transform, this);
    }

    public void mergeShape(String name, MeshesOBJ shape)
    {
        this.shapes = this.shapes == null ? new HashMap<String, List<MeshOBJ>>() : this.shapes;
        this.shapes.put(name, shape.meshes);
    }

    @Override
    public javax.vecmath.Vector3f getMin()
    {
        javax.vecmath.Vector3f min = new javax.vecmath.Vector3f(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);

        for (MeshOBJ obj : this.meshes)
        {
            for (int i = 0, c = obj.posData.length / 3; i < c; i++)
            {
                min.x = Math.min(obj.posData[i * 3], min.x);
                min.y = Math.min(obj.posData[i * 3 + 1], min.y);
                min.z = Math.min(obj.posData[i * 3 + 2], min.z);
            }
        }

        return min;
    }

    @Override
    public javax.vecmath.Vector3f getMax()
    {
        javax.vecmath.Vector3f max = new javax.vecmath.Vector3f(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);

        for (MeshOBJ obj : this.meshes)
        {
            for (int i = 0, c = obj.posData.length / 3; i < c; i++)
            {
                max.x = Math.max(obj.posData[i * 3], max.x);
                max.y = Math.max(obj.posData[i * 3 + 1], max.y);
                max.z = Math.max(obj.posData[i * 3 + 2], max.z);
            }
        }

        return max;
    }
}


==================================================

--- Файл №30 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\MeshOBJ.java
--------------------
package mchorse.blockbuster.api.formats.obj;

import mchorse.blockbuster.api.formats.Mesh;

public class MeshOBJ extends Mesh
{
    public OBJMaterial material;

    public MeshOBJ(int faces)
    {
        super(faces);
    }

    public MeshOBJ(float[] posData, float[] texData, float[] normData)
    {
        super(posData, texData, normData);
    }
}

==================================================

--- Файл №31 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\OBJDataMesh.java
--------------------
package mchorse.blockbuster.api.formats.obj;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Mesh from OBJ file
 *
 * It holds faces for every object found in OBJ file
 */
public class OBJDataMesh
{
    public String name;
    public Map<OBJMaterial, List<OBJFace>> groups = new LinkedHashMap<OBJMaterial, List<OBJFace>>();
}


==================================================

--- Файл №32 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\OBJFace.java
--------------------
package mchorse.blockbuster.api.formats.obj;

/**
 * Face that holds indices for loading data
 */
class OBJFace
{
    /**
     * List of idxGroup groups for a face triangle (3 vertices per face).
     */
    public OBJIndexGroup[] idxGroups = new OBJIndexGroup[3];

    public OBJFace(String[] lines)
    {
        for (int i = 0; i < 3; i++)
        {
            this.idxGroups[i] = this.parseLine(lines[i]);
        }
    }

    /**
     * Parse index group from a string in format of "1/2/3". It can be also 
     * "1//3" if the model doesn't provides texture coordinates.
     */
    private OBJIndexGroup parseLine(String line)
    {
        OBJIndexGroup idxGroup = new OBJIndexGroup();
        String[] lineTokens = line.split("/");
        int length = lineTokens.length;

        idxGroup.idxPos = Integer.parseInt(lineTokens[0]) - 1;

        if (length > 1)
        {
            /* It can be empty if the obj does not define text coords */
            String textCoord = lineTokens[1];

            if (!textCoord.isEmpty())
            {
                idxGroup.idxTextCoord = Integer.parseInt(textCoord) - 1;
            }

            if (length > 2)
            {
                idxGroup.idxVecNormal = Integer.parseInt(lineTokens[2]) - 1;
            }
        }

        return idxGroup;
    }
}

==================================================

--- Файл №33 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\OBJIndexGroup.java
--------------------
package mchorse.blockbuster.api.formats.obj;

/**
 * Index group class
 * 
 * This class represents an index group. Used in {@link OBJFace} class to 
 * represent an index group for looking up vertices from the collected 
 * arrays. 
 */
class OBJIndexGroup
{
    public static final int NO_VALUE = -1;

    public int idxPos = NO_VALUE;
    public int idxTextCoord = NO_VALUE;
    public int idxVecNormal = NO_VALUE;
}

==================================================

--- Файл №34 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\OBJMaterial.java
--------------------
package mchorse.blockbuster.api.formats.obj;

import net.minecraft.util.ResourceLocation;

/**
 * OBJ material
 * 
 * This class stores information about OBJ material from MTL file
 */
public class OBJMaterial
{
    public String name;

    public float r = 1;
    public float g = 1;
    public float b = 1;

    public boolean useTexture;
    public boolean linear = false;
    public ResourceLocation texture;

    public OBJMaterial(String name)
    {
        this.name = name;
    }
}

==================================================

--- Файл №35 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\OBJParser.java
--------------------
package mchorse.blockbuster.api.formats.obj;

import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.api.formats.Mesh;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.utils.resources.RLUtils;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * OBJ and MTL parser and loader
 */
public class OBJParser
{
    /* Input files */
    public InputStream objFile;
    public InputStream mtlFile;

    /* Collected data */
    public List<Vector3f> vertices = new ArrayList<Vector3f>();
    public List<Vector2f> textures = new ArrayList<Vector2f>();
    public List<Vector3f> normals = new ArrayList<Vector3f>();
    public List<OBJDataMesh> objects = new ArrayList<OBJDataMesh>();
    public Map<String, OBJMaterial> materials = new HashMap<String, OBJMaterial>();

    public static String processMaterialName(String name)
    {
        /* Apparently material name can have slashes and backslashes, so
         * they must be replaced to avoid messing up texture paths...
         */
        return name.replaceAll("[/|\\\\]+", "-");
    }

    /**
     * Read all lines from a file (needs a text file)
     */
    public static List<String> readAllLines(InputStream stream) throws Exception
    {
        List<String> list = new ArrayList<String>();

        try
        {
            BufferedReader br = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8));

            String line;
            while ((line = br.readLine()) != null)
            {
                list.add(line);
            }

            br.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return list;
    }

    /**
     * Construct OBJ parser with OBJ and MTL file references
     */
    public OBJParser(InputStream objFile, InputStream mtlFile)
    {
        this.objFile = objFile;
        this.mtlFile = mtlFile;
    }

    public boolean equalData(OBJParser parser)
    {
        boolean result = this.vertices.size() == parser.vertices.size();

        result = result && this.textures.size() == parser.textures.size();
        result = result && this.normals.size() == parser.normals.size();
        result = result && this.objects.size() == parser.objects.size();

        here:
        for (OBJDataMesh mesh : this.objects)
        {
            for (OBJDataMesh dataMesh : parser.objects)
            {
                if (mesh.name.equals(dataMesh.name))
                {
                    result = result && mesh.groups.size() == dataMesh.groups.size();

                    continue here;
                }
            }

            return false;
        }

        return result;
    }

    /**
     * Read the data first
     */
    public void read() throws Exception
    {
        this.vertices.clear();
        this.textures.clear();
        this.normals.clear();
        this.objects.clear();
        this.materials.clear();

        this.readMTL();
        this.readOBJ();
    }

    /**
     * Setup material textures
     */
    public void setupTextures(String key, File folder)
    {
        /* Create a texture location for materials */
        for (OBJMaterial material : this.materials.values())
        {
            if (material.useTexture && material.texture == null)
            {
                material.texture = RLUtils.create("b.a", key + "/skins/" + material.name + "/default.png");

                /* Create folder for every material */
                new File(folder, "skins/" + material.name + "/").mkdirs();
            }
        }
    }

    /**
     * Read materials from MTL file. This method isn't necessarily will
     * read any materials because MTL file is optional
     */
    public void readMTL() throws Exception
    {
        if (this.mtlFile == null)
        {
            return;
        }

        List<String> lines = readAllLines(this.mtlFile);
        OBJMaterial material = null;

        for (String line : lines)
        {
            if (line.isEmpty())
            {
                continue;
            }

            String[] tokens = line.split("\\s+");
            String first = tokens[0];

            if (first.equals("newmtl"))
            {
                material = new OBJMaterial(processMaterialName(tokens[1]));

                this.materials.put(material.name, material);
            }
            /* Read diffuse color */
            else if (first.equals("Kd") && tokens.length == 4)
            {
                material.r = Float.parseFloat(tokens[1]);
                material.g = Float.parseFloat(tokens[2]);
                material.b = Float.parseFloat(tokens[3]);
            }
            /* Read texture */
            else if (first.equals("map_Kd"))
            {
                material.useTexture = true;
            }
            else if (first.equals("map_Kd_linear"))
            {
                material.linear = true;
            }
            else if (first.equals("map_Kd_path"))
            {
                String texture = String.join(" ", SubCommandBase.dropFirstArgument(tokens));

                material.texture = RLUtils.create(texture);
            }
        }
    }

    /**
     * Read objects from OBJ file
     */
    public void readOBJ() throws Exception
    {
        List<String> lines = readAllLines(this.objFile);

        OBJDataMesh mesh = null;
        OBJMaterial material = null;

        for (String line : lines)
        {
            String[] tokens = line.split("\\s+");
            String first = tokens[0];

            /* Blender uses "o" for objects, while C4D uses "g" */
            if ((first.equals("o") || first.equals("g")) && tokens.length >= 2)
            {
                String name = tokens[1];

                mesh = null;

                for (OBJDataMesh data : this.objects)
                {
                    if (data.name.equals(name))
                    {
                        mesh = data;

                        break;
                    }
                }

                if (mesh == null)
                {
                    mesh = new OBJDataMesh();
                    mesh.name = name;
                    this.objects.add(mesh);
                }

            }

            /* Vertices */
            if (first.equals("v"))
            {
                this.vertices.add(new Vector3f(Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2]), Float.parseFloat(tokens[3])));
            }
            /* Texture coordinates (UV) */
            else if (first.equals("vt"))
            {
                this.textures.add(new Vector2f(Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2])));
            }
            /* Who needs normals? */
            else if (first.equals("vn"))
            {
                this.normals.add(new Vector3f(Float.parseFloat(tokens[1]), Float.parseFloat(tokens[2]), Float.parseFloat(tokens[3])));
            }
            /* Material group */
            else if (first.equals("usemtl"))
            {
                material = this.materials.get(processMaterialName(tokens[1]));
            }
            /* Collect faces */
            else if (first.equals("f"))
            {
                List<OBJFace> faceList = mesh.groups.get(material);
                if (faceList == null) {
                    faceList = new ArrayList<OBJFace>();
                    mesh.groups.put(material, faceList);
                }
                
                String[] faces = SubCommandBase.dropFirstArgument(tokens);

                if (faces.length == 4)
                {
                    /* Support for quads, yay! */
                    faceList.add(new OBJFace(new String[] {faces[0], faces[1], faces[2]}));
                    faceList.add(new OBJFace(new String[] {faces[0], faces[2], faces[3]}));
                }
                else if (faces.length == 3)
                {
                    faceList.add(new OBJFace(faces));
                }
                else if (faces.length > 4)
                {
                    for (int i = 0, c = faces.length - 2; i < c; i++)
                    {
                        faceList.add(new OBJFace(new String[] {faces[0], faces[i + 1], faces[i + 2]}));
                    }
                }
            }
        }
    }

    /**
     * From collected information, form mesh data
     */
    public Map<String, IMeshes> compile()
    {
        Map<String, IMeshes> meshes = new HashMap<String, IMeshes>();

        for (OBJDataMesh obj : this.objects)
        {
            MeshesOBJ meshObject = new MeshesOBJ();

            for (Map.Entry<OBJMaterial, List<OBJFace>> group : obj.groups.entrySet())
            {
                List<OBJFace> faces = group.getValue();
                MeshOBJ mesh = new MeshOBJ(faces.size());

                int i = 0;

                for (OBJFace face : faces)
                {
                    for (OBJIndexGroup indexGroup : face.idxGroups)
                    {
                        processFaceVertex(i, indexGroup, mesh);

                        i++;
                    }
                }

                mesh.material = group.getKey();
                meshObject.meshes.add(mesh);
            }

            meshes.put(obj.name, meshObject);
        }

        return meshes;
    }

    /**
     * Place all the data to complementary arrays
     */
    private void processFaceVertex(int i, OBJIndexGroup indices, Mesh mesh)
    {
        if (indices.idxPos >= 0)
        {
            Vector3f vertex = this.vertices.get(indices.idxPos);

            mesh.posData[i * 3] = vertex.x;
            mesh.posData[i * 3 + 1] = vertex.y;
            mesh.posData[i * 3 + 2] = vertex.z;
        }

        if (indices.idxTextCoord >= 0)
        {
            Vector2f coord = this.textures.get(indices.idxTextCoord);

            mesh.texData[i * 2] = coord.x;
            mesh.texData[i * 2 + 1] = 1 - coord.y;
        }

        if (indices.idxVecNormal >= 0)
        {
            Vector3f normal = this.normals.get(indices.idxVecNormal);

            mesh.normData[i * 3] = normal.x;
            mesh.normData[i * 3 + 1] = normal.y;
            mesh.normData[i * 3 + 2] = normal.z;
        }
    }
}

==================================================

--- Файл №36 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\ShapeKey.java
--------------------
package mchorse.blockbuster.api.formats.obj;

import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;

import java.util.Objects;

public class ShapeKey
{
    public String name;
    public float value;
    public boolean relative = true;

    public ShapeKey()
    {}

    public ShapeKey(String name, float value)
    {
        this.name = name;
        this.value = value;
    }

    public ShapeKey(String name, float value, boolean relative)
    {
        this(name, value);
        this.relative = relative;
    }

    public ShapeKey setValue(float value)
    {
        this.value = value;

        return this;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof ShapeKey)
        {
            ShapeKey shape = (ShapeKey) obj;

            return this.value == shape.value && Objects.equals(this.name, shape.name) && this.relative == shape.relative;
        }

        return super.equals(obj);
    }

    public ShapeKey copy()
    {
        return new ShapeKey(this.name, this.value, this.relative);
    }

    public NBTBase toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Name", this.name);
        tag.setFloat("Value", this.value);
        tag.setBoolean("Relative", this.relative);

        return tag;
    }

    public void fromNBT(NBTTagCompound key)
    {
        this.name = key.getString("Name");
        this.value = key.getFloat("Value");
        this.relative = key.getBoolean("Relative");
    }
}

==================================================

--- Файл №37 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\Vector2f.java
--------------------
package mchorse.blockbuster.api.formats.obj;

/**
 * Substitute class for a 2d vector which comes with joml library
*/
public class Vector2f
{
    public float x;
    public float y;

    public Vector2f(float x, float y)
    {
        this.x = x;
        this.y = y;
    }
}


==================================================

--- Файл №38 ---
Путь: main\java\mchorse\blockbuster\api\formats\obj\Vector3f.java
--------------------
package mchorse.blockbuster.api.formats.obj;

/**
 * Substitute class for a 3d vector which comes with joml library
 */
public class Vector3f
{
    public float x;
    public float y;
    public float z;

    public Vector3f(float x, float y, float z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}


==================================================

--- Файл №39 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\MeshesVOX.java
--------------------
package mchorse.blockbuster.api.formats.vox;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.api.formats.Mesh;
import mchorse.blockbuster.api.formats.vox.data.Vox;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.ModelVoxRenderer;

import javax.vecmath.Matrix3f;
import javax.vecmath.Vector3f;

public class MeshesVOX implements IMeshes
{
    public Mesh mesh;
    public VoxDocument document;
    public Vox vox;
    public Matrix3f rotation;

    public MeshesVOX(VoxDocument document, VoxDocument.LimbNode node)
    {
        this.document = document;
        this.vox = node.chunk;
        this.rotation = node.rotation;
    }

    @Override
    public ModelCustomRenderer createRenderer(Model data, ModelCustom model, ModelLimb limb, ModelTransform transform)
    {
        if (this.mesh == null)
        {
            this.mesh = new VoxBuilder(this.rotation).build(this.vox);
        }

        return new ModelVoxRenderer(model, limb, transform, this);
    }

    @Override
    public Vector3f getMin()
    {
        Vector3f min = new Vector3f(Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY, Float.POSITIVE_INFINITY);

        for (int x = 0; x < this.vox.x; x++)
        {
            for (int y = 0; y < this.vox.y; y++)
            {
                for (int z = 0; z < this.vox.z; z++)
                {
                    if (this.vox.has(x, y, z))
                    {
                        min.x = Math.min(x, min.x);
                        min.y = Math.min(y, min.y);
                        min.z = Math.min(z, min.z);
                    }
                }
            }
        }

        return min;
    }

    @Override
    public Vector3f getMax()
    {
        Vector3f max = new Vector3f(Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NEGATIVE_INFINITY);

        for (int x = 0; x < this.vox.x; x++)
        {
            for (int y = 0; y < this.vox.y; y++)
            {
                for (int z = 0; z < this.vox.z; z++)
                {
                    if (this.vox.has(x, y, z))
                    {
                        max.x = Math.max(x, max.x);
                        max.y = Math.max(y, max.y);
                        max.z = Math.max(z, max.z);
                    }
                }
            }
        }

        return max;
    }
}

==================================================

--- Файл №40 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\VoxBuilder.java
--------------------
package mchorse.blockbuster.api.formats.vox;

import mchorse.blockbuster.api.formats.Mesh;
import mchorse.blockbuster.api.formats.vox.data.Vox;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Matrix3f;
import javax.vecmath.Vector3f;

@SideOnly(Side.CLIENT)
public class VoxBuilder
{
    public Matrix3f transform;
    public Vector3f vector = new Vector3f();

    private Vector3f right;
    private Vector3f left;
    private Vector3f front;
    private Vector3f back;
    private Vector3f bottom;
    private Vector3f top;

    public VoxBuilder(Matrix3f transform)
    {
        this.transform = transform;

        this.right = this.processNormal(new Vector3f(-1, 0, 0));
        this.left = this.processNormal(new Vector3f(1, 0, 0));
        this.front = this.processNormal(new Vector3f(0, 0, 1));
        this.back = this.processNormal(new Vector3f(0, 0, -1));
        this.bottom = this.processNormal(new Vector3f(0, -1, 0));
        this.top = this.processNormal(new Vector3f(0, 1, 0));
    }

    private Vector3f processNormal(Vector3f normal)
    {
        /* Transform the normal */
        normal.set(normal.x, normal.z, normal.y);
        this.transform.transform(normal);
        normal.set(normal.x, normal.z, normal.y);
        normal.normalize();

        return normal;
    }

    public Mesh build(Vox vox)
    {
        /* Worst case scenario */
        Mesh mesh = new Mesh(vox.blocks * 12);

        mesh.triangles = 0;

        for (int x = 0; x < vox.x; x++)
        {
            for (int y = 0; y < vox.y; y++)
            {
                for (int z = 0; z < vox.z; z++)
                {
                    int voxel = vox.voxels[vox.toIndex(x, y, z)];

                    if (voxel != 0)
                    {
                        this.buildVertex(mesh, x, y, z, voxel, vox);
                    }
                }
            }
        }

        return mesh;
    }

    private void buildVertex(Mesh mesh, int x, int y, int z, int voxel, Vox vox)
    {
        boolean top = vox.has(x, y + 1, z);
        boolean bottom = vox.has(x, y - 1, z);
        boolean left = vox.has(x + 1, y, z);
        boolean right = vox.has(x - 1, y, z);
        boolean front = vox.has(x, y, z + 1);
        boolean back = vox.has(x, y, z - 1);

        if (!top)
        {
            Vector3f normal = this.top;

            this.add(mesh, vox, x, y + 1, z, voxel, -0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y + 1, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x, y + 1, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z + 1, voxel, 0.5F, 0.5F, normal);
        }

        if (!bottom)
        {
            Vector3f normal = this.bottom;

            this.add(mesh, vox, x, y, z, voxel, -0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y, z + 1, voxel, 0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y, z, voxel, 0.5F, -0.5F, normal);
        }

        if (!left)
        {
            Vector3f normal = this.left;

            this.add(mesh, vox, x + 1, y, z, voxel, -0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z + 1, voxel, 0.5F, 0.5F, normal);
        }

        if (!right)
        {
            Vector3f normal = this.right;

            this.add(mesh, vox, x, y, z, voxel, -0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y + 1, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x, y + 1, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y + 1, z + 1, voxel, 0.5F, 0.5F, normal);
            this.add(mesh, vox, x, y, z + 1, voxel, -0.5F, 0.5F, normal);
        }

        if (!front)
        {
            Vector3f normal = this.front;

            this.add(mesh, vox, x, y, z + 1, voxel, -0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y + 1, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y, z + 1, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y + 1, z + 1, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z + 1, voxel, 0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y, z + 1, voxel, 0.5F, -0.5F, normal);
        }

        if (!back)
        {
            Vector3f normal = this.back;

            this.add(mesh, vox, x, y, z, voxel, -0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x, y + 1, z, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x, y + 1, z, voxel, -0.5F, 0.5F, normal);
            this.add(mesh, vox, x + 1, y, z, voxel, 0.5F, -0.5F, normal);
            this.add(mesh, vox, x + 1, y + 1, z, voxel, 0.5F, 0.5F, normal);
        }
    }

    private void add(Mesh mesh, Vox vox, int x, int y, int z, int voxel, float offsetU, float offsetV, Vector3f normal)
    {
        int tris = mesh.triangles;
        float u = (voxel + 0.5F + offsetU) / 256F;
        float v = 0.5F + offsetV;

        Vector3f vertex = this.process(x, y, z, vox);
        mesh.posData[tris * 3] = vertex.x;
        mesh.posData[tris * 3 + 1] = vertex.y;
        mesh.posData[tris * 3 + 2] = vertex.z;

        mesh.normData[tris * 3] = normal.x;
        mesh.normData[tris * 3 + 1] = normal.y;
        mesh.normData[tris * 3 + 2] = normal.z;

        mesh.texData[tris * 2] = u;
        mesh.texData[tris * 2 + 1] = v;

        mesh.triangles += 1;
    }

    private Vector3f process(int x, int y, int z, Vox vox)
    {
        int w = (int) (vox.x / 2F);
        int h = (int) (vox.y / 2F);
        int d = (int) (vox.z / 2F);

        this.vector.set(x - w, z - d, y - h);
        this.transform.transform(this.vector);
        this.vector.set(this.vector.x, this.vector.z, this.vector.y);

        return this.vector;
    }
}

==================================================

--- Файл №41 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\VoxDocument.java
--------------------
package mchorse.blockbuster.api.formats.vox;

import mchorse.blockbuster.api.formats.vox.data.Vox;
import mchorse.blockbuster.api.formats.vox.data.VoxBaseNode;
import mchorse.blockbuster.api.formats.vox.data.VoxGroup;
import mchorse.blockbuster.api.formats.vox.data.VoxLayer;
import mchorse.blockbuster.api.formats.vox.data.VoxShape;
import mchorse.blockbuster.api.formats.vox.data.VoxTransform;

import javax.vecmath.Matrix3f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class VoxDocument
{
    /**
     * RGBA palette
     */
    public int[] palette = VoxReader.DEFAULT_PALETTE;

    /**
     * List of all chunks
     */
    public List<Vox> chunks = new ArrayList<Vox>();

    /**
     * Nodes
     */
    public List<VoxBaseNode> nodes = new ArrayList<VoxBaseNode>();

    /**
     * Nodes
     */
    public List<VoxLayer> layers = new ArrayList<VoxLayer>();

    private int index;

    /**
     * Generate a list of nodes for easier limb generation
     */
    public List<LimbNode> generate()
    {
        List<LimbNode> nodes = new ArrayList<LimbNode>();
        Stack<Matrix3f> matStack = new Stack<Matrix3f>();
        Stack<Vector3f> vecStack = new Stack<Vector3f>();

        this.index = 0;

        if (this.nodes.size() == 0)
        {
            /* Legacy mode */
            Matrix3f identity = new Matrix3f();
            identity.setIdentity();

            for (Vox chunk : this.chunks)
            {
                Vector3f position = new Vector3f(0, 0, (chunk.z - 1) / 2);

                nodes.add(new LimbNode(chunk, identity, position, this.index == 0 ? "vox" : "vox_" + this.index));
                this.index ++;
            }
        }
        else
        {
            this.generateNodes((VoxTransform) this.nodes.get(0), nodes, matStack, vecStack);
        }

        return nodes;
    }

    private void generateNodes(VoxTransform transform, List<LimbNode> nodes, Stack<Matrix3f> matStack, Stack<Vector3f> vecStack)
    {
        VoxBaseNode child = this.nodes.get(transform.childId);
        String name = "vox_" + this.index;

        boolean hidden = transform.attrs.containsKey("_hidden") && transform.attrs.get("_hidden").equals("1");

        if (!hidden && transform.layerId < this.layers.size() && transform.layerId >= 0)
        {
            hidden = this.layers.get(transform.layerId).isHidden();
        }

        if (transform.attrs.containsKey("_name"))
        {
            name = transform.attrs.get("_name") + "_" + this.index;
        }

        Matrix3f parentMat;
        Vector3f parentVec;
        Matrix4f trans = transform.transforms.get(0);

        if (matStack.isEmpty())
        {
            parentMat = new Matrix3f();
            parentMat.m00 = trans.m00;
            parentMat.m01 = trans.m01;
            parentMat.m02 = trans.m02;
            parentMat.m10 = trans.m10;
            parentMat.m11 = trans.m11;
            parentMat.m12 = trans.m12;
            parentMat.m20 = trans.m20;
            parentMat.m21 = trans.m21;
            parentMat.m22 = trans.m22;

            parentVec = new Vector3f(trans.m03, trans.m13, trans.m23);
        }
        else
        {
            parentMat = new Matrix3f(matStack.peek());
            parentVec = new Vector3f(vecStack.peek());

            Matrix3f mat = new Matrix3f();

            mat.m00 = trans.m00;
            mat.m01 = trans.m01;
            mat.m02 = trans.m02;
            mat.m10 = trans.m10;
            mat.m11 = trans.m11;
            mat.m12 = trans.m12;
            mat.m20 = trans.m20;
            mat.m21 = trans.m21;
            mat.m22 = trans.m22;

            parentMat.mul(mat);
            parentVec.add(new Vector3f(trans.m03, trans.m13, trans.m23));
        }

        matStack.push(parentMat);
        vecStack.push(parentVec);

        if (child instanceof VoxGroup)
        {
            VoxGroup group = (VoxGroup) child;

            for (int id : group.ids)
            {
                this.index += 1;
                this.generateNodes((VoxTransform) this.nodes.get(id), nodes, matStack, vecStack);
            }
        }
        else if (child instanceof VoxShape)
        {
            Matrix3f mat = matStack.pop();
            Vector3f vec = vecStack.pop();

            if (!hidden)
            {
                Vox chunk = this.chunks.get(((VoxShape) child).modelAttrs.get(0).id);

                nodes.add(new LimbNode(chunk, mat, vec, name));
            }
        }
    }

    public static class LimbNode
    {
        public Vox chunk;
        public Matrix3f rotation;
        public Vector3f translation;
        public String name;

        public LimbNode(Vox chunk, Matrix3f rotation, Vector3f translation, String name)
        {
            this.chunk = chunk;
            this.rotation = rotation;
            this.translation = translation;
            this.name = name;
        }
    }
}

==================================================

--- Файл №42 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\VoxReader.java
--------------------
package mchorse.blockbuster.api.formats.vox;

import mchorse.blockbuster.api.formats.vox.data.Vox;
import mchorse.blockbuster.api.formats.vox.data.VoxChunk;
import mchorse.blockbuster.api.formats.vox.data.VoxGroup;
import mchorse.blockbuster.api.formats.vox.data.VoxLayer;
import mchorse.blockbuster.api.formats.vox.data.VoxShape;
import mchorse.blockbuster.api.formats.vox.data.VoxTransform;
import mchorse.mclib.utils.binary.BinaryReader;

import javax.vecmath.Matrix3f;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

/**
 * MagicaVoxel *.vox reader
 *
 * This class reads the file and returns vox model
 *
 * @link https://github.com/ephtracy/voxel-model/blob/master/MagicaVoxel-file-format-vox.txt
 * @link https://github.com/ephtracy/voxel-model/blob/master/MagicaVoxel-file-format-vox-extension.txt
 */
public class VoxReader extends BinaryReader
{
    public static int[] DEFAULT_PALETTE = new int[] {0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff, 0xff00ffff, 0xffffccff, 0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff, 0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff, 0xff6699ff, 0xff3399ff, 0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff, 0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff, 0xff0033ff, 0xffff00ff, 0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff, 0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc, 0xff66ffcc, 0xff33ffcc, 0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc, 0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc, 0xff0099cc, 0xffff66cc, 0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc, 0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc, 0xff6633cc, 0xff3333cc, 0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc, 0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99, 0xff00ff99, 0xffffcc99, 0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99, 0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999, 0xff669999, 0xff339999, 0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699, 0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399, 0xff003399, 0xffff0099, 0xffcc0099, 0xff990099, 0xff660099, 0xff330099, 0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66, 0xff66ff66, 0xff33ff66, 0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66, 0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966, 0xff009966, 0xffff6666, 0xffcc6666, 0xff996666, 0xff666666, 0xff336666, 0xff006666, 0xffff3366, 0xffcc3366, 0xff993366, 0xff663366, 0xff333366, 0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066, 0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33, 0xff00ff33, 0xffffcc33, 0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33, 0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933, 0xff669933, 0xff339933, 0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633, 0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333, 0xff003333, 0xffff0033, 0xffcc0033, 0xff990033, 0xff660033, 0xff330033, 0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00, 0xff66ff00, 0xff33ff00, 0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00, 0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900, 0xff009900, 0xffff6600, 0xffcc6600, 0xff996600, 0xff666600, 0xff336600, 0xff006600, 0xffff3300, 0xffcc3300, 0xff993300, 0xff663300, 0xff333300, 0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000, 0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077, 0xff000055, 0xff000044, 0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00, 0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700, 0xff005500, 0xff004400, 0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000, 0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000, 0xffeeeeee, 0xffdddddd, 0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777, 0xff555555, 0xff444444, 0xff222222, 0xff111111};

    public byte[] buf = new byte[4];

    public VoxDocument read(InputStream stream) throws Exception
    {
        if (this.readInt(stream) != this.fourChars("VOX "))
        {
            throw new Exception("Not a 'VOX ' file!");
        }

        int version = this.readInt(stream);
        if (version != 150)
        {
            System.out.println("Reading a vox file with version: " + version + ". This version might not be supported. Version 150 is supported.");
        }

        VoxChunk main = this.readChunk(stream);

        if (!main.id.equals("MAIN"))
        {
            throw new Exception("The first chunk isn't main!");
        }

        VoxDocument document = new VoxDocument();
        Vox vox = null;

        while (true)
        {
            VoxChunk chunk;

            try
            {
                chunk = this.readChunk(stream);
            }
            catch (Exception e)
            {
                break;
            }

            /* System.out.println(chunk.toString() + " " + chunk.size + " " + chunk.chunks); */

            if (chunk.id.equals("SIZE"))
            {
                vox = new Vox();
                vox.x = this.readInt(stream);
                vox.z = this.readInt(stream);
                vox.y = this.readInt(stream);
            }
            else if (chunk.id.equals("XYZI"))
            {
                int voxels = this.readInt(stream);

                vox.voxels = new int[vox.x * vox.z * vox.y];

                while (voxels > 0)
                {
                    stream.read(this.buf);

                    int x = this.buf[0] & 0xff;
                    int y = this.buf[2] & 0xff;
                    int z = this.buf[1] & 0xff;
                    int block = this.buf[3] & 0xff;

                    vox.set(x, y, z, block);
                    voxels--;
                }

                document.chunks.add(vox);
            }
            else if (chunk.id.equals("nTRN"))
            {
                document.nodes.add(new VoxTransform(stream, this));
            }
            else if (chunk.id.equals("nGRP"))
            {
                document.nodes.add(new VoxGroup(stream, this));
            }
            else if (chunk.id.equals("nSHP"))
            {
                document.nodes.add(new VoxShape(stream, this));
            }
            else if (chunk.id.equals("LAYR"))
            {
                document.layers.add(new VoxLayer(stream, this));
            }
            else if (chunk.id.equals("RGBA"))
            {
                document.palette = new int[256];

                for (int i = 0; i <= 254; i++)
                {
                    int color = this.readInt(stream);

                    int newColor = (((color >> 24) & 0xff) << 24);
                    newColor += (((color >> 0) & 0xff) << 16);
                    newColor += (((color >> 8) & 0xff) << 8);
                    newColor += (((color >> 16) & 0xff) << 0);

                    document.palette[i + 1] = newColor;
                }
            }
            else
            {
                stream.skip(chunk.size);
            }
        }

        stream.close();

        return document;
    }

    public VoxChunk readChunk(InputStream stream) throws Exception
    {
        return new VoxChunk(this.readFourString(stream), this.readInt(stream), this.readInt(stream));
    }

    public String readString(InputStream stream) throws Exception
    {
        int size = this.readInt(stream);
        byte[] bytes = new byte[size];

        if (stream.read(bytes) == size)
        {
            return new String(bytes, StandardCharsets.UTF_8);
        }

        throw new IOException("Not enough bytes for the string!");
    }

    public Map<String, String> readDictionary(InputStream stream) throws Exception
    {
        Map<String, String> dict = new HashMap<String, String>();

        int keys = this.readInt(stream);

        for (int i = 0; i < keys; i ++)
        {
            dict.put(this.readString(stream), this.readString(stream));
        }

        return dict;
    }

    public Matrix3f readRotation(int rotation)
    {
        Matrix3f matrix = new Matrix3f();

        int firstIndex  = (rotation & 0b0011);
        int secondIndex = (rotation & 0b1100) >> 2;
        int[] array = {-1, -1, -1};
        int index = 0;

        array[firstIndex] = 0;
        array[secondIndex] = 0;

        for (int i = 0; i < array.length; i ++)
        {
            if (array[i] == -1)
            {
                index = i;

                break;
            }
        }

        int thirdIndex = index;

        boolean negativeFirst  = ((rotation & 0b0010000) >> 4) == 1;
        boolean negativeSecond = ((rotation & 0b0100000) >> 5) == 1;
        boolean negativeThird  = ((rotation & 0b1000000) >> 6) == 1;

        matrix.setElement(0, firstIndex, negativeFirst ? -1 : 1);
        matrix.setElement(1, secondIndex, negativeSecond ? -1 : 1);
        matrix.setElement(2, thirdIndex, negativeThird ? -1 : 1);

        return matrix;
    }
}

==================================================

--- Файл №43 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\Vox.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

public class Vox
{
    public int x;
    public int y;
    public int z;
    public int blocks;

    public int[] voxels;

    public int toIndex(int x, int y, int z)
    {
        return x + y * this.x + z * this.x * this.y;
    }

    public boolean has(int x, int y, int z)
    {
        return x >= 0 && y >= 0 && z >= 0 && x < this.x && y < this.y && z < this.z && this.voxels[this.toIndex(x, y, z)] != 0;
    }

    public void set(int x, int y, int z, int block)
    {
        int index = this.toIndex(x, y, z);

        if (index < 0 || index >= this.x * this.y * this.z)
        {
            return;
        }

        int last = this.voxels[index];

        this.voxels[index] = block;

        if (last == 0 && block != 0)
        {
            this.blocks += 1;
        }
        else if (last != 0 && block == 0)
        {
            this.blocks -= 1;
        }
    }
}

==================================================

--- Файл №44 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxBaseNode.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import java.util.Map;

public abstract class VoxBaseNode
{
    public int id;
    public Map<String, String> attrs;
    public int num;
}

==================================================

--- Файл №45 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxChunk.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import mchorse.mclib.utils.binary.BinaryChunk;

/**
 * This represents a data chunk information in the VOX file
 * (not used anywhere outside of vox reader class)
 */
public class VoxChunk extends BinaryChunk
{
    public int chunks;

    public VoxChunk(String id, int size, int chunks)
    {
        super(id, size);

        this.chunks = chunks;
    }

    @Override
    public String toString()
    {
        return this.id;
    }
}


==================================================

--- Файл №46 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxGroup.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import mchorse.blockbuster.api.formats.vox.VoxReader;

import java.io.InputStream;

public class VoxGroup extends VoxBaseNode
{
    public int[] ids;

    public VoxGroup(InputStream stream, VoxReader reader) throws Exception 
    {
        this.id = reader.readInt(stream);
        this.attrs = reader.readDictionary(stream);
        this.num = reader.readInt(stream);
        this.ids = new int[this.num];

        for (int i = 0; i < num; i ++)
        {
            this.ids[i] = reader.readInt(stream);
        }
    }
}

==================================================

--- Файл №47 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxLayer.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import mchorse.blockbuster.api.formats.vox.VoxReader;

import java.io.InputStream;

public class VoxLayer extends VoxBaseNode
{
    public VoxLayer(InputStream stream, VoxReader reader) throws Exception
    {
        this.id = reader.readInt(stream);
        this.attrs = reader.readDictionary(stream);
        this.num = reader.readInt(stream);
    }

    public boolean isHidden()
    {
        return this.attrs.containsKey("_hidden") && this.attrs.get("_hidden").equals("1");
    }
}

==================================================

--- Файл №48 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxShape.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import mchorse.blockbuster.api.formats.vox.VoxReader;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class VoxShape extends VoxBaseNode
{
    public List<Attribute> modelAttrs;

    public VoxShape(InputStream stream, VoxReader reader) throws Exception
    {
        this.id = reader.readInt(stream);
        this.attrs = reader.readDictionary(stream);
        this.num = reader.readInt(stream);
        this.modelAttrs = new ArrayList<Attribute>();

        for (int i = 0; i < this.num; i ++)
        {
            this.modelAttrs.add(new Attribute(reader.readInt(stream), reader.readDictionary(stream)));
        }
    }

    public static class Attribute
    {
        public final int id;
        public final Map<String, String> attrs;

        public Attribute(int id, Map<String, String> attrs)
        {
            this.id = id;
            this.attrs = attrs;
        }
    }
}

==================================================

--- Файл №49 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxTexture.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import java.util.Arrays;

import net.minecraft.client.renderer.texture.DynamicTexture;

public class VoxTexture extends DynamicTexture
{
    private int[] palette;
    private int specular;

    public VoxTexture(int[] palette, int specular)
    {
        super(Math.max(palette.length, 1), 1);

        this.palette = palette;
        this.specular = specular;

        this.updatePalette();
    }

    public void updatePalette()
    {
        int[] tex = this.getTextureData();

        for (int i = 0; i < this.palette.length; i++)
        {
            tex[i] = this.palette[i];
        }

        if (tex.length == 3 * this.palette.length)
        {
            Arrays.fill(tex, 2 * this.palette.length, tex.length, specular);
        }

        this.updateDynamicTexture();
    }
}

==================================================

--- Файл №50 ---
Путь: main\java\mchorse\blockbuster\api\formats\vox\data\VoxTransform.java
--------------------
package mchorse.blockbuster.api.formats.vox.data;

import mchorse.blockbuster.api.formats.vox.VoxReader;

import javax.vecmath.Matrix3f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class VoxTransform extends VoxBaseNode
{
    public int childId;
    public int unusedId;
    public int layerId;
    public List<Matrix4f> transforms;

    public VoxTransform(InputStream stream, VoxReader reader) throws Exception
    {
        this.id = reader.readInt(stream);
        this.attrs = reader.readDictionary(stream);
        this.childId = reader.readInt(stream);
        this.unusedId = reader.readInt(stream);
        this.layerId = reader.readInt(stream);
        this.num = reader.readInt(stream);
        this.transforms = new ArrayList<Matrix4f>();

        for (int i = 0; i < this.num; i ++)
        {
            Map<String, String> dict = reader.readDictionary(stream);
            Matrix3f rotation = new Matrix3f();
            Vector3f translate = new Vector3f(0, 0, 0);

            rotation.setIdentity();

            if (dict.containsKey("_r"))
            {
                rotation = reader.readRotation(Integer.parseInt(dict.get("_r")));
            }

            if (dict.containsKey("_t"))
            {
                String[] splits = dict.get("_t").split(" ");

                if (splits.length == 3)
                {
                    /* Stupid coordinate systems... */
                    translate.set(-Integer.parseInt(splits[0]), Integer.parseInt(splits[1]), Integer.parseInt(splits[2]));
                }
            }

            /* Assemble the main result */
            Matrix4f transform = new Matrix4f();

            transform.set(rotation);
            transform.setTranslation(translate);

            this.transforms.add(transform);
        }
    }
}

==================================================

--- Файл №51 ---
Путь: main\java\mchorse\blockbuster\api\json\ModelAdapter.java
--------------------
package mchorse.blockbuster.api.json;

import java.lang.reflect.Type;
import java.util.Map;

import com.google.common.reflect.TypeToken;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.util.ResourceLocation;

/**
 * Model JSON adapter
 * 
 * This adapter is responsible for only deserializing a {@link Model} instance.
 */
public class ModelAdapter implements JsonDeserializer<Model>, JsonSerializer<Model>
{
    public static Gson plainGSON = new GsonBuilder().create();

    /**
     * Deserializes {@link Model}
     * 
     * This method is responsible mainly from translating "default" field into 
     * {@link ResourceLocation}.
     */
    @Override
    public Model deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
    {
        Model model = plainGSON.fromJson(json, Model.class);
        JsonObject object = json.getAsJsonObject();

        model.shapes.clear();

        if (object.has("limbs"))
        {
            model.limbs = context.deserialize(object.get("limbs"), new TypeToken<Map<String, ModelLimb>>()
            {}.getType());
        }

        if (object.has("default"))
        {
            model.defaultTexture = RLUtils.create(object.get("default"));
        }

        if (model.extrudeMaxFactor <= 0)
        {
            model.extrudeMaxFactor = 1;
        }

        if (model.extrudeInwards <= 0)
        {
            model.extrudeInwards = 1;
        }

        return model;
    }

    /**
     * Serializes {@link Model}
     * 
     * This method is responsible for cleaning up some of Model's fields (to 
     * make the file output more cleaner).
     */
    @Override
    public JsonElement serialize(Model src, Type typeOfSrc, JsonSerializationContext context)
    {
        JsonElement serial = plainGSON.toJsonTree(src, typeOfSrc);
        JsonObject map = serial.getAsJsonObject();

        map.remove("model");
        map.remove("defaultTexture");
        map.remove("skins");
        map.remove("scale");
        map.remove("scaleGui");
        map.remove("limbs");
        map.remove("poses");
        map.remove("providesObj");
        map.remove("providesMtl");
        map.remove("legacyObj");
        map.remove("materials");
        map.remove("shapes");
        map.remove("extrudeMaxFactor");
        map.remove("extrudeInwards");

        if (src.presets.isEmpty())
        {
            map.remove("presets");
        }

        if (!src.model.isEmpty())
        {
            map.addProperty("model", src.model);
        }

        if (src.defaultTexture != null)
        {
            map.add("default", RLUtils.writeJson(src.defaultTexture));
        }

        if (!src.skins.isEmpty())
        {
            map.addProperty("skins", src.skins);
        }

        if (src.scale[0] != 1 || src.scale[1] != 1 || src.scale[2] != 1)
        {
            JsonArray array = new JsonArray();

            array.add(new JsonPrimitive(src.scale[0]));
            array.add(new JsonPrimitive(src.scale[1]));
            array.add(new JsonPrimitive(src.scale[2]));

            map.add("scale", array);
        }

        if (src.scaleGui != 1)
        {
            map.addProperty("scaleGui", src.scaleGui);
        }

        if (src.providesObj)
        {
            map.addProperty("providesObj", src.providesObj);
        }

        if (src.providesMtl)
        {
            map.addProperty("providesMtl", src.providesMtl);
        }

        if (!src.skins.isEmpty())
        {
            map.addProperty("skins", src.skins);
        }

        if (src.extrudeMaxFactor > 1)
        {
            map.addProperty("extrudeMaxFactor", src.extrudeMaxFactor);
        }

        if (src.extrudeInwards > 1)
        {
            map.addProperty("extrudeInwards", src.extrudeInwards);
        }

        if (!src.legacyObj)
        {
            map.addProperty("legacyObj", src.legacyObj);
        }

        map.add("limbs", context.serialize(src.limbs));
        map.add("poses", context.serialize(src.poses));

        return map;
    }
}

==================================================

--- Файл №52 ---
Путь: main\java\mchorse\blockbuster\api\json\ModelLimbAdapter.java
--------------------
package mchorse.blockbuster.api.json;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.vecmath.Matrix3d;

import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelLimb.ArmorSlot;
import mchorse.blockbuster.api.ModelLimb.Holding;
import mchorse.blockbuster.common.OrientedBB;

/**
 * Model limb adapter
 */
public class ModelLimbAdapter implements JsonSerializer<ModelLimb>, JsonDeserializer<ModelLimb>
{
    @Override
    public JsonElement serialize(ModelLimb src, Type typeOfSrc, JsonSerializationContext context)
    {
        JsonElement serial = ModelAdapter.plainGSON.toJsonTree(src, typeOfSrc);
        JsonObject map = serial.getAsJsonObject();

        map.remove("sizeOffset");
        map.remove("itemScale");
        map.remove("holding");
        map.remove("slot");
        map.remove("parent");
        map.remove("name");
        map.remove("opacity");
        map.remove("color");

        if(!src.obbs.isEmpty())
        {
            JsonArray jsonOBBs = new JsonArray();
            
            for(OrientedBB obb : src.obbs) 
            {
                JsonObject jsonOBB = new JsonObject();
 
                JsonArray size = new JsonArray();
                
                size.add(obb.hw * 32D);
                size.add(obb.hu * 32D);
                size.add(obb.hv * 32D);
                jsonOBB.add("size", size);
                
                if(obb.anchorOffset.x != 0 || obb.anchorOffset.y != 0 || obb.anchorOffset.z != 0)
                {
                    JsonArray anchor = new JsonArray();
                    
                    anchor.add(obb.anchorOffset.x * 16D);
                    anchor.add(obb.anchorOffset.y * 16D);
                    anchor.add(obb.anchorOffset.z * 16D);
                    jsonOBB.add("anchor", anchor);
                }
                
                if(obb.limbOffset.x != 0 || obb.limbOffset.y != 0 || obb.limbOffset.z != 0)
                {
                    JsonArray translate = new JsonArray();
                    
                    translate.add(obb.limbOffset.x * 16D);
                    translate.add(obb.limbOffset.y * 16D);
                    translate.add(obb.limbOffset.z * 16D);
                    jsonOBB.add("translate", translate);
                }
                
                if(obb.rotation0[0] != 0 || obb.rotation0[1] != 0 || obb.rotation0[2] != 0)
                {
                    JsonArray rotation = new JsonArray();
                    
                    rotation.add(obb.rotation0[0]);
                    rotation.add(obb.rotation0[1]);
                    rotation.add(obb.rotation0[2]);
                    jsonOBB.add("rotate", rotation);
                }
                
                jsonOBBs.add(jsonOBB);
            }
            
            map.add("orientedBBs", jsonOBBs);
        }
        
        if (src.sizeOffset != 0)
        {
            map.addProperty("sizeOffset", src.sizeOffset);
        }

        if (src.itemScale != 1F)
        {
            map.addProperty("itemScale", src.itemScale);
        }

        if (src.holding != Holding.NONE)
        {
            map.addProperty("holding", src.holding == Holding.RIGHT ? "right" : "left");
        }

        if (src.slot != null && src.slot != ArmorSlot.NONE)
        {
            map.addProperty("slot", src.slot.name);
        }

        if (!src.parent.isEmpty())
        {
            map.addProperty("parent", src.parent);
        }

        if (!ModelPoseAdapter.isDefault(src.color, 1.0F))
        {
            ModelPoseAdapter.addFloatArray(map, "color", src.color);
        }

        if (src.opacity != 1.0F)
        {
            map.addProperty("opacity", src.opacity);
        }

        this.addBoolean(map, "lighting", src.lighting, true);
        this.addBoolean(map, "shading", src.shading, true);
        this.addBoolean(map, "smooth", src.smooth, false);
        this.addBoolean(map, "is3D", src.is3D, false);

        this.addBoolean(map, "hold", src.hold, true);
        this.addBoolean(map, "mirror", src.mirror, false);
        this.addBoolean(map, "lookX", src.lookX, false);
        this.addBoolean(map, "lookY", src.lookY, false);
        this.addBoolean(map, "idle", src.idle, false);
        this.addBoolean(map, "swinging", src.swinging, false);
        this.addBoolean(map, "swiping", src.swiping, false);
        this.addBoolean(map, "invert", src.invert, false);
        this.addBoolean(map, "wheel", src.wheel, false);
        this.addBoolean(map, "wing", src.wing, false);
        this.addBoolean(map, "roll", src.roll, false);
        this.addBoolean(map, "cape", src.cape, false);

        if (!ModelPoseAdapter.isDefault(src.origin, 0F))
        {
            ModelPoseAdapter.addFloatArray(map, "origin", src.origin);
        }

        return map;
    }

    @Override
    public ModelLimb deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
    {
        ModelLimb limb = ModelAdapter.plainGSON.fromJson(json, ModelLimb.class);
        JsonObject object = json.getAsJsonObject();

        if(object.has("orientedBBs"))
        {
            JsonArray obbs = object.getAsJsonArray("orientedBBs");
            
            for(JsonElement element : obbs) 
            {
                JsonObject jsonOBB = element.getAsJsonObject();
                OrientedBB obb = new OrientedBB();
                
                if(jsonOBB.has("size"))
                {
                    obb.hw = jsonOBB.getAsJsonArray("size").get(0).getAsDouble() / 32D;
                    obb.hu = jsonOBB.getAsJsonArray("size").get(1).getAsDouble() / 32D;
                    obb.hv = jsonOBB.getAsJsonArray("size").get(2).getAsDouble() / 32D;
                }
                
                if(jsonOBB.has("anchor"))
                {
                    obb.anchorOffset.x = jsonOBB.getAsJsonArray("anchor").get(0).getAsDouble() / 16D;
                    obb.anchorOffset.y = jsonOBB.getAsJsonArray("anchor").get(1).getAsDouble() / 16D;
                    obb.anchorOffset.z = jsonOBB.getAsJsonArray("anchor").get(2).getAsDouble() / 16D;
                }
                
                if(jsonOBB.has("translate"))
                {
                    obb.limbOffset.x = jsonOBB.getAsJsonArray("translate").get(0).getAsDouble() / 16D;
                    obb.limbOffset.y = jsonOBB.getAsJsonArray("translate").get(1).getAsDouble() / 16D;
                    obb.limbOffset.z = jsonOBB.getAsJsonArray("translate").get(2).getAsDouble() / 16D;
                }
                
                if(jsonOBB.has("rotate"))
                {
                    obb.rotation0[0] = jsonOBB.getAsJsonArray("rotate").get(0).getAsDouble();
                    obb.rotation0[1] = jsonOBB.getAsJsonArray("rotate").get(1).getAsDouble();
                    obb.rotation0[2] = jsonOBB.getAsJsonArray("rotate").get(2).getAsDouble();
                }
                
                limb.obbs.add(obb);
            }
        }
        
        if (object.has("looking") && object.get("looking").isJsonPrimitive())
        {
            boolean looking = object.get("looking").getAsBoolean();

            limb.lookX = limb.lookY = looking;
        }

        if (object.has("holding") && object.get("holding").isJsonPrimitive())
        {
            String holding = object.get("holding").getAsString();

            if (holding.equals("right"))
            {
                limb.holding = Holding.RIGHT;
            }
            else if (holding.equals("left"))
            {
                limb.holding = Holding.LEFT;
            }
        }

        if (limb.holding == null)
        {
            limb.holding = Holding.NONE;
        }

        if (object.has("slot"))
        {
            try
            {
                limb.slot = ArmorSlot.fromName(object.get("slot").getAsString());
            }
            catch (Exception e)
            {}
        }
        else
        {
            limb.slot = ArmorSlot.NONE;
        }

        return limb;
    }

    /**
     * Add a boolean to the map
     *
     * First remove the property from map, and then, if the given value isn't
     * the default one, add the value
     */
    private void addBoolean(JsonObject map, String name, boolean value, boolean defaultValue)
    {
        map.remove(name);

        if (value != defaultValue)
        {
            map.addProperty(name, value);
        }
    }
}

==================================================

--- Файл №53 ---
Путь: main\java\mchorse\blockbuster\api\json\ModelPoseAdapter.java
--------------------
package mchorse.blockbuster.api.json;

import java.lang.reflect.Type;
import java.util.Map;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;

/**
 * Model limb adapter
 */
public class ModelPoseAdapter implements JsonSerializer<ModelPose>
{
    @Override
    public JsonElement serialize(ModelPose src, Type typeOfSrc, JsonSerializationContext context)
    {
        JsonElement serial = ModelAdapter.plainGSON.toJsonTree(src, typeOfSrc);
        JsonObject map = serial.getAsJsonObject();
        JsonObject limbs = new JsonObject();

        map.remove("limbs");

        if (src.shapes.isEmpty())
        {
            map.remove("shapes");
        }

        for (Map.Entry<String, ModelTransform> limb : src.limbs.entrySet())
        {
            ModelTransform trans = limb.getValue();
            JsonObject transform = new JsonObject();
            boolean empty = true;

            if (!isDefault(trans.translate, 0))
            {
                addFloatArray(transform, "translate", trans.translate);
                empty = false;
            }

            if (!isDefault(trans.rotate, 0))
            {
                addFloatArray(transform, "rotate", trans.rotate);
                empty = false;
            }

            if (!isDefault(trans.scale, 1))
            {
                addFloatArray(transform, "scale", trans.scale);
                empty = false;
            }

            if (!empty)
            {
                limbs.add(limb.getKey(), transform);
            }
        }

        map.add("limbs", limbs);

        return map;
    }

    public static boolean isDefault(float[] array, float defaultValue)
    {
        return array[0] == defaultValue && array[1] == defaultValue && array[2] == defaultValue;
    }

    public static void addFloatArray(JsonObject map, String name, float[] array)
    {
        JsonArray jsonArray = new JsonArray();

        for (float num : array)
        {
            jsonArray.add(new JsonPrimitive(num));
        }

        map.add(name, jsonArray);
    }
}

==================================================

--- Файл №54 ---
Путь: main\java\mchorse\blockbuster\api\loaders\IModelLoader.java
--------------------
package mchorse.blockbuster.api.loaders;

import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;

import java.io.File;

/**
 * Model loader interface
 *
 * Detects whether a special model format can be loaded
 */
public interface IModelLoader
{
    public IModelLazyLoader load(File folder);
}

==================================================

--- Файл №55 ---
Путь: main\java\mchorse\blockbuster\api\loaders\ModelLoaderJSON.java
--------------------
package mchorse.blockbuster.api.loaders;

import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderJSON;
import mchorse.blockbuster.api.resource.FileEntry;

import java.io.File;

public class ModelLoaderJSON implements IModelLoader
{
    @Override
    public IModelLazyLoader load(File folder)
    {
        File file = new File(folder, "model.json");

        if (file.isFile())
        {
            return new ModelLazyLoaderJSON(new FileEntry(file));
        }

        return null;
    }

}

==================================================

--- Файл №56 ---
Путь: main\java\mchorse\blockbuster\api\loaders\ModelLoaderOBJ.java
--------------------
package mchorse.blockbuster.api.loaders;

import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderOBJ;
import mchorse.blockbuster.api.resource.FileEntry;
import mchorse.blockbuster.api.resource.IResourceEntry;

import java.io.File;

public class ModelLoaderOBJ implements IModelLoader
{
    @Override
    public IModelLazyLoader load(File folder)
    {
        IResourceEntry json = new FileEntry(new File(folder, "model.json"));
        File obj = new File(folder, "model.obj");
        File shapes = new File(folder, "shapes");

        if (obj.isFile())
        {
            File mtl = new File(folder, "model.mtl");

            return new ModelLazyLoaderOBJ(json, new FileEntry(obj), new FileEntry(mtl), shapes);
        }

        for (File file : folder.listFiles())
        {
            if (file.isFile() && file.getName().endsWith(".obj"))
            {
                String name = file.getName();
                File mtl = new File(folder, name.substring(0, name.length() - 3) + "mtl");

                return new ModelLazyLoaderOBJ(json, new FileEntry(file), new FileEntry(mtl), shapes);
            }
        }

        return null;
    }
}

==================================================

--- Файл №57 ---
Путь: main\java\mchorse\blockbuster\api\loaders\ModelLoaderVOX.java
--------------------
package mchorse.blockbuster.api.loaders;

import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderVOX;
import mchorse.blockbuster.api.resource.FileEntry;
import mchorse.blockbuster.api.resource.IResourceEntry;

import java.io.File;

public class ModelLoaderVOX implements IModelLoader
{
    @Override
    public IModelLazyLoader load(File folder)
    {
        IResourceEntry json = new FileEntry(new File(folder, "model.json"));
        File vox = new File(folder, "model.vox");

        if (vox.isFile())
        {
            return new ModelLazyLoaderVOX(json, new FileEntry(vox));
        }

        for (File file : folder.listFiles())
        {
            if (file.isFile() && file.getName().endsWith(".vox"))
            {
                return new ModelLazyLoaderVOX(json, new FileEntry(file));
            }
        }

        return null;
    }
}

==================================================

--- Файл №58 ---
Путь: main\java\mchorse\blockbuster\api\loaders\lazy\IModelLazyLoader.java
--------------------
package mchorse.blockbuster.api.loaders.lazy;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.io.IOException;

/**
 * Lazy model loader
 *
 * This class is actually responsible for creation of {@link Model}
 * or client side {@link ModelCustom} classes
 */
public interface IModelLazyLoader
{
    public long getLastTime();

    public void setLastTime(long time);

    public boolean stillExists();

    public boolean hasChanged();

    public boolean copyFiles(File folder);

    public Model loadModel(String key) throws Exception;

    @SideOnly(Side.CLIENT)
    public ModelCustom loadClientModel(String key, Model model) throws Exception;
}

==================================================

--- Файл №59 ---
Путь: main\java\mchorse\blockbuster\api\loaders\lazy\ModelLazyLoaderJSON.java
--------------------
package mchorse.blockbuster.api.loaders.lazy;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.api.formats.obj.MeshesOBJ;
import mchorse.blockbuster.api.resource.FileEntry;
import mchorse.blockbuster.api.resource.IResourceEntry;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import mchorse.blockbuster.client.model.parsing.ModelParser;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.util.Map;

public class ModelLazyLoaderJSON implements IModelLazyLoader
{
    public IResourceEntry model;
    public long lastTime;
    public int lastCount = -1;

    public ModelLazyLoaderJSON(IResourceEntry model)
    {
        this.model = model;
    }

    public int count()
    {
        return this.model.exists() ? 1 : 0;
    }

    @Override
    public long getLastTime()
    {
        return this.lastTime;
    }

    @Override
    public void setLastTime(long lastTime)
    {
        if (this.lastCount == -1)
        {
            this.lastCount = this.count();
        }

        this.lastTime = lastTime;
    }

    @Override
    public boolean stillExists()
    {
        return this.lastCount == this.count();
    }

    @Override
    public boolean hasChanged()
    {
        return this.model.hasChanged();
    }

    @Override
    public Model loadModel(String key) throws Exception
    {
        if (!this.model.exists())
        {
            return null;
        }

        return Model.parse(this.model.getStream());
    }

    @Override
    @SideOnly(Side.CLIENT)
    public ModelCustom loadClientModel(String key, Model model) throws Exception
    {
        /* GC the old model */
        ModelCustom modelCustom = ModelCustom.MODELS.get(key);
        Minecraft.getMinecraft().addScheduledTask(() -> ModelExtrudedLayer.clearByModel(modelCustom));

        Map<String, IMeshes> meshes = this.getMeshes(key, model);
        
        if (meshes != null)
        {
            for (String limb : meshes.keySet())
            {
                if (!model.limbs.containsKey(limb))
                {
                    model.addLimb(limb);
                }
            }
        }

        if (!model.model.isEmpty())
        {
            try
            {
                Class<? extends ModelCustom> clazz = (Class<? extends ModelCustom>) Class.forName(model.model);

                /* Parse custom custom model with a custom class */
                return ModelParser.parse(key, model, clazz, meshes);
            }
            catch (ClassNotFoundException e)
            {
                e.printStackTrace();
            }
        }

        return ModelParser.parse(key, model, meshes);
    }

    @SideOnly(Side.CLIENT)
    protected Map<String, IMeshes> getMeshes(String key, Model model) throws Exception
    {
        return null;
    }

    @Override
    public boolean copyFiles(File folder)
    {
        if (this.model instanceof FileEntry)
        {
            FileEntry file = (FileEntry) this.model;

            if (!file.file.getParentFile().equals(folder))
            {
                try
                {
                    FileUtils.copyDirectory(new File(file.file.getParentFile(), "skins"), new File(folder, "skins"));

                    return true;
                }
                catch (IOException e)
                {
                    return false;
                }
            }
        }

        return true;
    }
}


==================================================

--- Файл №60 ---
Путь: main\java\mchorse\blockbuster\api\loaders\lazy\ModelLazyLoaderOBJ.java
--------------------
package mchorse.blockbuster.api.loaders.lazy;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.api.formats.obj.MeshesOBJ;
import mchorse.blockbuster.api.formats.obj.OBJDataMesh;
import mchorse.blockbuster.api.formats.obj.OBJParser;
import mchorse.blockbuster.api.resource.FileEntry;
import mchorse.blockbuster.api.resource.IResourceEntry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class ModelLazyLoaderOBJ extends ModelLazyLoaderJSON
{
    public IResourceEntry obj;
    public IResourceEntry mtl;

    public List<IResourceEntry> shapes = new ArrayList<IResourceEntry>();

    private OBJParser parser;
    private long lastModified = -1;
    private File shapesFolder;

    public ModelLazyLoaderOBJ(IResourceEntry model, IResourceEntry obj, IResourceEntry mtl, List<IResourceEntry> shapes)
    {
        super(model);

        this.obj = obj;
        this.mtl = mtl;
        this.shapes.addAll(shapes);
    }

    public ModelLazyLoaderOBJ(IResourceEntry model, IResourceEntry obj, IResourceEntry mtl, File shapes)
    {
        super(model);

        this.obj = obj;
        this.mtl = mtl;

        this.setupShapes(shapes);
    }

    private void setupShapes(File shapes)
    {
        if (shapes == null)
        {
            return;
        }

        File[] files = shapes.listFiles();

        if (files == null)
        {
            return;
        }

        this.shapesFolder = shapes;

        for (File file : files)
        {
            if (file.isFile() && file.getName().endsWith(".obj"))
            {
                this.shapes.add(new FileEntry(file));
            }
        }
    }

    @Override
    public int count()
    {
        int count = super.count() + (this.obj.exists() ? 2 : 0) + (this.mtl.exists() ? 4 : 0);
        int bit = 3;

        for (IResourceEntry shape : this.shapes)
        {
            if (shape.exists())
            {
                count += shape.exists() ? 1 << bit : 0;
            }

            bit++;
        }

        return count;
    }

    @Override
    public boolean hasChanged()
    {
        boolean hasChanged = super.hasChanged() || this.obj.hasChanged() || this.mtl.hasChanged();

        for (IResourceEntry shape : this.shapes)
        {
            hasChanged = hasChanged || shape.hasChanged();
        }

        File[] files = this.shapesFolder == null ? null : this.shapesFolder.listFiles();

        if (files != null)
        {
            boolean haveShapesChanged = this.hasShapesFolderChanged(files);

            /* Update shapes */
            if (haveShapesChanged)
            {
                if (this.shapesFolder != null)
                {
                    this.setupShapes(this.shapesFolder);
                }

                this.lastModified = -1;
                this.parser = null;
            }

            hasChanged = hasChanged || haveShapesChanged;
        }

        return hasChanged;
    }

    private boolean hasShapesFolderChanged(File[] files)
    {
        int matching = 0;
        int total = 0;

        for (File file : files)
        {
            String name = file.getName();

            if (name.endsWith(".obj"))
            {
                total += 1;
            }

            for (IResourceEntry entry : this.shapes)
            {
                if (entry.getName().equals(name))
                {
                    matching += 1;

                    break;
                }
            }
        }

        return matching != total;
    }

    @Override
    public Model loadModel(String key) throws Exception
    {
        Model model = null;

        try
        {
            model = super.loadModel(key);
        }
        catch (Exception e) {}

        if (model == null)
        {
            model = this.generateOBJModel(key);
        }

        for (IResourceEntry entry : this.shapes)
        {
            if (!entry.exists())
            {
                continue;
            }

            String name = entry.getName();

            name = name.substring(0, name.lastIndexOf("."));
            model.shapes.add(name);
        }

        return model;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected Map<String, IMeshes> getMeshes(String key, Model model) throws Exception
    {
        try
        {
            OBJParser parser = this.getOBJParser(key, model);
            Map<String, IMeshes> meshes = parser.compile();

            for (IResourceEntry shape : this.shapes)
            {
                try
                {
                    OBJParser shapeParser = new OBJParser(shape.getStream(), model.providesMtl ? this.mtl.getStream() : null);

                    shapeParser.read();
                    this.mergeParsers(shape.getName(), meshes, shapeParser);
                }
                catch (Exception e)
                {}
            }

            this.parser = null;
            this.lastModified = -1;

            return meshes;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Merges data of shape parsers
     */
    private void mergeParsers(String name, Map<String, IMeshes> meshes, OBJParser shapeParser)
    {
        name = name.substring(0, name.lastIndexOf("."));

        Map<String, IMeshes> shapeMeshes = shapeParser.compile();

        for (Map.Entry<String, IMeshes> entry : meshes.entrySet())
        {
            IMeshes shapeMesh = shapeMeshes.get(entry.getKey());

            if (shapeMesh != null)
            {
                ((MeshesOBJ) entry.getValue()).mergeShape(name, (MeshesOBJ) shapeMesh);
            }
        }
    }

    /**
     * Create an OBJ parser
     */
    public OBJParser getOBJParser(String key, Model model)
    {
        if (!model.providesObj)
        {
            return null;
        }

        long lastModified = Math.max(this.model.lastModified(), Math.max(this.obj.lastModified(), this.mtl.lastModified()));

        if (this.lastModified < lastModified)
        {
            this.lastModified = lastModified;
        }
        else
        {
            return this.parser;
        }

        try
        {
            InputStream obj = this.obj.getStream();
            InputStream mtl = model.providesMtl ? this.mtl.getStream() : null;

            this.parser = new OBJParser(obj, mtl);
            this.parser.read();

            if (this.mtl instanceof FileEntry)
            {
                this.parser.setupTextures(key, ((FileEntry) this.mtl).file.getParentFile());
            }

            model.materials.putAll(this.parser.materials);
        }
        catch (Exception e)
        {
            e.printStackTrace();

            return null;
        }

        return this.parser;
    }

    /**
     * Generate custom model based on given OBJ
     */
    private Model generateOBJModel(String model)
    {
        /* Generate custom model for an OBJ model */
        Model data = new Model();
        ModelPose blocky = new ModelPose();

        blocky.setSize(1, 1, 1);
        data.poses.put("flying", blocky.copy());
        data.poses.put("standing", blocky.copy());
        data.poses.put("sneaking", blocky.copy());
        data.poses.put("sleeping", blocky.copy());
        data.poses.put("riding", blocky.copy());
        data.name = model;

        data.providesObj = true;
        data.providesMtl = this.mtl.exists();

        /* Generate limbs */
        OBJParser parser = this.getOBJParser(model, data);

        if (parser != null)
        {
            for (OBJDataMesh mesh : parser.objects)
            {
                data.addLimb(mesh.name);
            }
        }

        if (data.limbs.isEmpty())
        {
            data.addLimb("body");
        }

        data.legacyObj = false;

        return data;
    }

    @Override
    public boolean copyFiles(File folder)
    {
        boolean result = super.copyFiles(folder);

        result = this.obj.copyTo(new File(folder, this.obj.getName())) || result;
        result = this.mtl.copyTo(new File(folder, this.mtl.getName())) || result;

        for (IResourceEntry shape : this.shapes)
        {
            result = shape.copyTo(new File(folder, "shapes/" + shape.getName())) || result;
        }

        return result;
    }
}

==================================================

--- Файл №61 ---
Путь: main\java\mchorse\blockbuster\api\loaders\lazy\ModelLazyLoaderVOX.java
--------------------
package mchorse.blockbuster.api.loaders.lazy;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.api.formats.vox.MeshesVOX;
import mchorse.blockbuster.api.formats.vox.VoxDocument;
import mchorse.blockbuster.api.formats.vox.VoxReader;
import mchorse.blockbuster.api.resource.IResourceEntry;
import mchorse.blockbuster.client.model.ModelCustom;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class ModelLazyLoaderVOX extends ModelLazyLoaderJSON
{
    public IResourceEntry vox;

    private VoxDocument cachedDocument;

    public ModelLazyLoaderVOX(IResourceEntry model, IResourceEntry vox)
    {
        super(model);

        this.vox = vox;
    }

    @Override
    public int count()
    {
        return super.count() + (this.vox.exists() ? 2 : 0);
    }

    @Override
    public boolean hasChanged()
    {
        return super.hasChanged() || this.vox.hasChanged();
    }

    @Override
    public Model loadModel(String key) throws Exception
    {
        Model model = null;

        try
        {
            model = super.loadModel(key);
        }
        catch (Exception e) {}

        if (model == null)
        {
            model = this.generateVOXModel(key);
        }

        return model;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected Map<String, IMeshes> getMeshes(String key, Model model) throws Exception
    {
        Map<String, IMeshes> meshes = new HashMap<String, IMeshes>();
        VoxDocument document = this.getVox();

        for (VoxDocument.LimbNode node : document.generate())
        {
            meshes.put(node.name, new MeshesVOX(document, node));
        }

        return meshes;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public ModelCustom loadClientModel(String key, Model model) throws Exception
    {
        ModelCustom custom = super.loadClientModel(key, model);

        this.cachedDocument = null;

        return custom;
    }

    /**
     * Generate custom model based on given VOX
     */
    private Model generateVOXModel(String model) throws Exception
    {
        /* Generate custom model for a VOX model */
        Model data = new Model();
        ModelPose blocky = new ModelPose();

        /* Generate limbs */
        VoxDocument document = this.getVox();

        for (VoxDocument.LimbNode node : document.generate())
        {
            ModelLimb limb = data.addLimb(node.name);
            ModelTransform transform = new ModelTransform();

            limb.origin[0] = 0;
            limb.origin[1] = 0;
            limb.origin[2] = 0;

            transform.translate[0] = -node.translation.x;
            transform.translate[1] = node.translation.z;
            transform.translate[2] = -node.translation.y;

            blocky.limbs.put(limb.name, transform);
        }

        /* General model properties */
        data.providesObj = true;
        data.providesMtl = true;

        blocky.setSize(1, 1, 1);
        data.poses.put("flying", blocky.copy());
        data.poses.put("standing", blocky.copy());
        data.poses.put("sneaking", blocky.copy());
        data.poses.put("sleeping", blocky.copy());
        data.poses.put("riding", blocky.copy());
        data.name = model;

        return data;
    }

    private VoxDocument getVox() throws Exception
    {
        if (this.cachedDocument != null)
        {
            return this.cachedDocument;
        }

        return this.cachedDocument = new VoxReader().read(this.vox.getStream());
    }

    @Override
    public boolean copyFiles(File folder)
    {
        boolean skins = super.copyFiles(folder);
        boolean vox = this.vox.copyTo(new File(folder, this.vox.getName()));

        return skins || vox;
    }
}

==================================================

--- Файл №62 ---
Путь: main\java\mchorse\blockbuster\api\resource\FileEntry.java
--------------------
package mchorse.blockbuster.api.resource;

import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class FileEntry implements IResourceEntry
{
    public File file;
    public long lastModified;

    public FileEntry(File file)
    {
        this.file = file;
        this.lastModified = this.lastModified();
    }

    @Override
    public String getName()
    {
        return this.file == null ? "" : this.file.getName();
    }

    @Override
    public InputStream getStream() throws IOException
    {
        return this.file == null ? null : new FileInputStream(this.file);
    }

    @Override
    public boolean exists()
    {
        return this.file != null && this.file.exists();
    }

    @Override
    public boolean hasChanged()
    {
        long lastModified = this.lastModified();
        boolean result = lastModified > this.lastModified;

        this.lastModified = lastModified;

        return result;
    }

    @Override
    public long lastModified()
    {
        return this.file == null ? 0 : this.file.lastModified();
    }

    @Override
    public boolean copyTo(File file)
    {
        try
        {
            FileUtils.copyFile(this.file, file);

            return true;
        }
        catch (IOException e)
        {}

        return false;
    }
}


==================================================

--- Файл №63 ---
Путь: main\java\mchorse\blockbuster\api\resource\IResourceEntry.java
--------------------
package mchorse.blockbuster.api.resource;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

/**
 * Resource entry
 *
 * Used for the model system to allow both file based stream creation
 * and just stream creation via class loader/inside of jar
 */
public interface IResourceEntry
{
    public String getName();

    public static IResourceEntry createEntry(Object object)
    {
        if (object instanceof File)
        {
            return new FileEntry((File) object);
        }
        else if (object instanceof String)
        {
            return new StreamEntry((String) object, System.currentTimeMillis());
        }

        return new StreamEntry(null, 0);
    }

    public InputStream getStream() throws IOException;

    public boolean exists();

    public boolean hasChanged();

    public long lastModified();

    public boolean copyTo(File file);
}


==================================================

--- Файл №64 ---
Путь: main\java\mchorse\blockbuster\api\resource\StreamEntry.java
--------------------
package mchorse.blockbuster.api.resource;

import mchorse.blockbuster.Blockbuster;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;

public class StreamEntry implements IResourceEntry
{
    public String path;
    public long time;
    public ClassLoader loader = Blockbuster.class.getClassLoader();

    public StreamEntry(String path, long time)
    {
        this.path = path;
        this.time = time;
    }

    @Override
    public String getName()
    {
        return this.path == null ? "" : FilenameUtils.getName(this.path);
    }

    public StreamEntry(String path, long time, ClassLoader loader)
    {
        this(path, time);

        this.loader = loader;
    }

    @Override
    public InputStream getStream() throws IOException
    {
        return this.path == null ? null : this.loader.getResourceAsStream(this.path);
    }

    @Override
    public boolean exists()
    {
        return this.path != null && this.loader.getResource(this.path) != null;
    }

    @Override
    public boolean hasChanged()
    {
        return false;
    }

    @Override
    public long lastModified()
    {
        return this.time;
    }

    @Override
    public boolean copyTo(File file)
    {
        try
        {
            FileUtils.copyInputStreamToFile(this.getStream(), file);

            return true;
        }
        catch (IOException e)
        {}

        return false;
    }
}


==================================================

--- Файл №65 ---
Путь: main\java\mchorse\blockbuster\audio\AudioFile.java
--------------------
package mchorse.blockbuster.audio;

import mchorse.mclib.utils.wav.WavePlayer;
import mchorse.mclib.utils.wav.Waveform;
import org.lwjgl.openal.AL10;

import java.io.File;

public class AudioFile
{
    public String name;
    public File file;
    public WavePlayer player;
    public Waveform waveform;
    public long update;

    private boolean wasPaused;

    public AudioFile(String name, File file, WavePlayer player, Waveform waveform, long update)
    {
        this.name = name;
        this.file = file;
        this.player = player;
        this.waveform = waveform;
        this.update = update;
    }

    public boolean canBeUpdated()
    {
        return this.update < this.file.lastModified();
    }

    public boolean isEmpty()
    {
        return this.player == null || this.waveform == null;
    }

    public void delete()
    {
        if (this.player != null)
        {
            this.player.delete();
            this.player = null;
        }

        if (this.waveform != null)
        {
            this.waveform.delete();
            this.waveform = null;
        }
    }

    public void pause(boolean pause)
    {
        if (this.player == null) return;

        int state = this.player.getSourceState();

        if (!pause && this.wasPaused)
        {
            this.wasPaused = false;

            return;
        }

        this.wasPaused = pause && state == AL10.AL_PAUSED;

        if (pause && state == AL10.AL_PLAYING)
        {
            this.player.pause();
        }
        else if (!pause && state == AL10.AL_PAUSED)
        {
            this.player.play();
        }
    }
}

==================================================

--- Файл №66 ---
Путь: main\java\mchorse\blockbuster\audio\AudioHandler.java
--------------------
package mchorse.blockbuster.audio;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.audio.PacketAudio;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueString;
import mchorse.mclib.math.functions.limit.Min;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.mclib.network.INBTSerializable;
import mchorse.mclib.utils.ForgeUtils;
import mchorse.mclib.utils.ICopy;
import mchorse.mclib.utils.LatencyTimer;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagFloat;
import net.minecraft.server.management.PlayerList;
import net.minecraft.world.WorldServer;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;

/**
 * This class is responsible for handling an audio, for example, for the scene.
 */
public class AudioHandler implements ICopy<AudioHandler>, INBTSerializable, IByteBufSerializable
{
    /**
     * Cache of the current audio state. This does not need to be serialized
     */
    private AudioState audioState = AudioState.STOP;

    private final ValueInt audioShift = new ValueInt("audio_shift");
    private final ValueString audio = new ValueString("audio_name");
    /**
     * The global tick and not the tick relative to the audio timeline.
     * This is used to determine when to play if there is a negative {@link #audioShift}, which signifies a delay.
     */
    private int tick;

    public String getAudioName()
    {
        return this.audio.get();
    }

    public void setAudioName(String audio)
    {
        this.audio.set((audio == null) ? "" : audio);
    }

    public int getAudioShift()
    {
        return this.audioShift.get();
    }

    public void setAudioShift(int audioShift)
    {
        this.audioShift.set(audioShift);
    }

    public AudioState getAudioState()
    {
        return this.audioState;
    }

    public boolean hasAudio()
    {
        return this.audio.get() != null && !this.audio.get().isEmpty();
    }

    public boolean isPlaying()
    {
        switch (this.audioState)
        {
            case REWIND:
            case RESUME_SET:
            case RESUME:
            case SET:
                return true;
            case PAUSE:
            case STOP:
            case PAUSE_SET:
                return false;
        }

        return false;
    }

    public void pauseAudio()
    {
        this.setAudioStateTick(AudioState.PAUSE, this.tick);
    }

    /**
     * Pause the audio at a certain tick.
     * @param tick The global tick and not the tick relative to the audio timeline.
     *             This needs to be the global tick to determine whether the audio can play due to delayed audio shift.
     */
    public void pauseAudio(int tick)
    {
        this.setAudioStateTick(AudioState.PAUSE_SET, tick);
    }

    /**
     * Resume playing at a certain tick.
     * @param tick the tick to resume playing again at.
     *             The global tick and not the tick relative to the audio timeline.
     *             This needs to be the global tick to determine whether the audio can play due to delayed audio shift.
     */
    public void resume(int tick)
    {
        this.setAudioStateTick(AudioState.RESUME_SET, tick);
    }

    /**
     * Stops the audio.
     */
    public void stopAudio()
    {
        this.audioState = AudioState.STOP;

        this.sendAudioState(AudioState.STOP, Blockbuster.audioSync.get());
    }

    /**
     * Go to a tick. This can happen while in paused/stopped state or in playing state.
     * @param tick the global tick and not the tick relative to the audio timeline.
     *             This needs to be the global tick to determine whether the audio can play due to delayed audio shift.
     */
    public void goTo(int tick)
    {
        /*
         * It is important that the audio state SET is only used when setting the audio while it is playing.
         * AudioState.SET <=> playing
         */
        this.setAudioStateTick(this.isPlaying() ? AudioState.SET : AudioState.PAUSE_SET, tick);
    }

    /**
     *
     * @param tick the global tick and not the tick relative to the audio timeline.
     *             This needs to be the global tick to determine whether the audio can play due to delayed audio shift.
     */
    public void startAudio(int tick)
    {
        this.setAudioStateTick(AudioState.REWIND, tick);
    }

    /**
     * Sets the tick, audiostate and sends them to the players with {@link #sendAudioState(AudioState, boolean)}.
     * If the tick is smaller than the delay, when {@link #audioShift} is negative, it stops the audio.
     * If the tick is greater than the delay it will allow the state to be synchronised.
     * @param state
     * @param tick The global tick and not the tick relative to the audio timeline.
     *             This needs to be the global tick to determine whether the audio can play due to delayed audio shift.
     */
    private void setAudioStateTick(AudioState state, int tick)
    {
        this.tick = tick;

        if (this.audioShift.get() < 0 && tick < -this.audioShift.get())
        {
            this.stopAudio();

            return;
        }

        this.audioState = state;

        this.sendAudioState(state, Blockbuster.audioSync.get());
    }

    /**
     * This method must be called, preferably on the logical server side!
     * This updates the tick and starts the audio if there was a negative {@link #audioShift}.
     * A negative {@link #audioShift} signifies a delay. If the tick is greater than the delay the audio will be started.
     */
    public void update()
    {
        if (this.audioShift.get() < 0 && this.tick >= -this.audioShift.get() && !this.isPlaying())
        {
            this.startAudio(this.tick);
        }

        this.tick++;
    }

    /**
     * Sends the audio, if present, to all players on the server
     * and set {@link #audioState} to the provided state.
     * @param state
     * @param sync whether to try and sync the audio with server and client.
     */
    private void sendAudioState(AudioState state, boolean sync)
    {
        if (!this.hasAudio())
        {
            return;
        }

        for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
        {
            this.sendAudioStateToPlayer(state, (sync) ? new LatencyTimer() : null, player);
        }
    }

    /**
     * Send the current audio state to the player. This is useful when a player joins a server with audio already playing.
     * @param player
     */
    public void syncPlayer(EntityPlayerMP player)
    {
        AudioState state = this.audioState;

        /*
         * convert to SET equivalent states so a player who joins the server
         * gets the audio state and the correct tick set
         */
        switch (this.audioState)
        {
            case PAUSE:
                state = AudioState.PAUSE_SET;
                break;
            case RESUME:
                state = AudioState.RESUME_SET;
                break;
        }

        this.sendAudioStateToPlayer(state, (Blockbuster.audioSync.get()) ? new LatencyTimer() : null, player);
    }

    /**
     * Send the audio to the provided player
     * @param state
     * @param latencyTimer a timer to measure (approximately) the delay to sync the audio properly
     * @param player the entity player the audio should be sent to
     */
    private void sendAudioStateToPlayer(AudioState state, @Nullable LatencyTimer latencyTimer, EntityPlayerMP player)
    {
        if (!this.hasAudio())
        {
            return;
        }

        /**
         * Important: this expects that the calling methods already checked the tick and state
         * so that, for example, an audio with delay of 10 will not try to send a state
         * that will play the audio before tick 10 is reached. If this is violated,
         * the shift passed to {@link AudioLibrary} might become negative.
         */
        int shift = 0;

        switch (state)
        {
            case REWIND:
            case RESUME_SET:
            case PAUSE_SET:
            case SET:
                shift = this.tick;
                break;
            case PAUSE:
            case STOP:
                shift = -this.audioShift.get();
                break;
        }

        PacketAudio packet = new PacketAudio(this.audio.get(), state, shift + this.audioShift.get(), latencyTimer);

        if (player != null)
        {
            Dispatcher.sendTo(packet, player);
        }
    }

    @Override
    public AudioHandler copy()
    {
        AudioHandler clone = new AudioHandler();

        clone.copy(this);

        return clone;
    }

    @Override
    public void copy(AudioHandler origin)
    {
        this.audio.copy(origin.audio);
        this.audioState = origin.audioState;
        this.audioShift.copy(origin.audioShift);
        this.tick = origin.tick;
    }

    @Override
    public void fromNBT(NBTTagCompound compound)
    {
        this.audio.set(compound.hasKey("Audio") ? compound.getString("Audio") : "");

        if (compound.hasKey("AudioShift"))
        {
            if (compound.getTag("AudioShift") instanceof NBTTagFloat)
            {
                this.audioShift.set((int) (compound.getFloat("AudioShift") * 20));
            }
            else
            {
                this.audioShift.set(compound.getInteger("AudioShift"));
            }
        }
    }

    @Override
    public NBTTagCompound toNBT(NBTTagCompound compound)
    {
        if (this.audio.hasChanged())
        {
            compound.setTag("Audio", this.audio.valueToNBT());
        }

        if (this.audioShift.hasChanged())
        {
            compound.setTag("AudioShift", this.audioShift.valueToNBT());
        }

        return compound;
    }

    @Override
    public void fromBytes(ByteBuf byteBuf)
    {
        this.audio.fromBytes(byteBuf);
        this.audioShift.fromBytes(byteBuf);
    }

    @Override
    public void toBytes(ByteBuf byteBuf)
    {
        this.audio.toBytes(byteBuf);
        this.audioShift.toBytes(byteBuf);
    }
}


==================================================

--- Файл №67 ---
Путь: main\java\mchorse\blockbuster\audio\AudioLibrary.java
--------------------
package mchorse.blockbuster.audio;

import mchorse.blockbuster.Blockbuster;
import mchorse.mclib.utils.LatencyTimer;
import mchorse.mclib.utils.wav.Wave;
import mchorse.mclib.utils.wav.WavePlayer;
import mchorse.mclib.utils.wav.WaveReader;
import mchorse.mclib.utils.wav.Waveform;

import javax.annotation.Nullable;
import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AudioLibrary
{
    public File folder;
    public Map<String, AudioFile> files = new HashMap<String, AudioFile>();

    public AudioLibrary(File folder)
    {
        this.folder = folder;
        this.folder.mkdirs();
    }

    public List<File> getFiles()
    {
        File[] files = this.folder.listFiles();

        if (files == null)
        {
            return Collections.emptyList();
        }

        List<File> list = new ArrayList<File>();

        for (File file : files)
        {
            if (!file.getName().endsWith(".wav"))
            {
                continue;
            }

            list.add(file);
        }

        return list;
    }

    public List<String> getFileNames()
    {
        List<String> list = new ArrayList<String>();

        for (File file : this.getFiles())
        {
            String name = file.getName();

            list.add(name.substring(0, name.length() - 4));
        }

        return list;
    }

    private AudioFile load(String name, File file)
    {
        if (!file.isFile())
        {
            return null;
        }

        AudioFile audio;

        try
        {
            Wave wave = new WaveReader().read(new FileInputStream(file));

            if (wave.getBytesPerSample() > 2)
            {
                wave = wave.convertTo16();
            }

            WavePlayer player = new WavePlayer().initialize(wave);
            Waveform waveform = new Waveform();

            waveform.populate(wave, Blockbuster.audioWaveformDensity.get(), 40);

            audio = new AudioFile(name + ".wav", file, player, waveform, file.lastModified());
        }
        catch (Exception e)
        {
            e.printStackTrace();

            /* Empty */
            audio = new AudioFile(name + ".wav", file, null, null, file.lastModified());
        }

        this.files.put(name, audio);

        return audio;
    }

    /**
     *
     * @param audio name of the file (without .wav file ending)
     * @param state play, pause, resume etc. the audio
     * @param shift in ticks
     * @param delay for syncing purposes, if not used, pass null as value
     * @return false if the file is null or empty
     */
    public boolean handleAudio(String audio, AudioState state, int shift, @Nullable LatencyTimer delay)
    {
        AudioFile file = this.files.get(audio);

        if (file == null || file.canBeUpdated())
        {
            file = this.load(audio, new File(this.folder, audio + ".wav"));
        }

        if (file == null || file.isEmpty())
        {
            return false;
        }

        WavePlayer player = file.player;

        float seconds = shift / 20F;
        float elapsedDelay = (delay != null) ? delay.getElapsedTime() / 1000F : 0F;

        System.out.println("Received audio latency of: " + elapsedDelay + " seconds");

        this.handleAudioState(state, player, seconds, elapsedDelay);

        return true;
    }

    private void handleAudioState(AudioState state, WavePlayer player, float seconds, float elapsedDelay)
    {
        switch (state)
        {
            case REWIND:
                player.stop();
                player.play();
                player.setPlaybackPosition(seconds + elapsedDelay);

                break;
            case PAUSE:
                elapsedDelay = (player.isPlaying()) ? elapsedDelay : 0;

                player.pause();
                player.setPlaybackPosition(((seconds == 0) ? player.getPlaybackPosition() : seconds) - elapsedDelay);

                break;
            case PAUSE_SET:
                if (player.isStopped())
                {
                    player.play();
                }

                player.pause();
                player.setPlaybackPosition(seconds);

                break;
            case RESUME:
                player.play();
                player.setPlaybackPosition(player.getPlaybackPosition() + elapsedDelay);

                break;
            case RESUME_SET:
                player.play();
                player.setPlaybackPosition(seconds + elapsedDelay);

                break;
            case SET:
                elapsedDelay = (player.isPlaying()) ? elapsedDelay : 0;

                player.setPlaybackPosition(seconds + elapsedDelay);

                break;
            case STOP:
                player.stop();

                break;
        }
    }

    public void reset()
    {
        for (AudioFile file : this.files.values())
        {
            file.delete();
        }

        this.files.clear();
    }

    public void pause(boolean pause)
    {
        for (AudioFile file : this.files.values())
        {
            file.pause(pause);
        }
    }
}

==================================================

--- Файл №68 ---
Путь: main\java\mchorse\blockbuster\audio\AudioRenderer.java
--------------------
package mchorse.blockbuster.audio;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.wav.Waveform;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.lang3.StringUtils;

@SideOnly(Side.CLIENT)
public class AudioRenderer
{
    public static void renderAll(int x, int y, int w, int h, int sw, int sh)
    {
        if (!Blockbuster.audioWaveformVisible.get())
        {
            return;
        }

        /* Make the anchor at the bottom */
        y -= h;

        for (AudioFile file : ClientProxy.audio.files.values())
        {
            if (!file.isEmpty() && !file.player.isStopped())
            {
                AudioRenderer.renderWaveform(file, x, y, w, h, sw, sh);

                y -= h + 5;
            }
        }
    }

    public static void renderWaveform(AudioFile file, int x, int y, int w, int h, int sw, int sh)
    {
        if (file == null || file.isEmpty())
        {
            return;
        }

        final float brightness = 0.45F;
        int half = w / 2;

        /* Draw background */
        GuiDraw.drawVerticalGradientRect(x + 2, y + 2, x + w - 2, y + h, 0, ColorUtils.HALF_BLACK);
        Gui.drawRect(x + 1, y, x + 2, y + h, 0xaaffffff);
        Gui.drawRect(x + w - 2, y, x + w - 1, y + h, 0xaaffffff);
        Gui.drawRect(x, y + h - 1, x + w, y + h, 0xffffffff);

        GuiDraw.scissor(x + 2, y + 2, w - 4, h - 4, sw, sh);

        Waveform wave = file.waveform;

        if (!wave.isCreated())
        {
            wave.render();
        }

        float playback = file.player.getPlaybackPosition();
        int offset = (int) (playback * wave.getPixelsPerSecond());
        int waveW = file.waveform.getWidth();

        GlStateManager.color(1, 1, 1, 1);
        GlStateManager.enableTexture2D();
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();

        /* Draw the waveform */
        int runningOffset = waveW - offset;

        if (runningOffset > 0)
        {
            file.waveform.draw(x + half, y, offset, 0, Math.min(runningOffset, half), h, h);
        }

        /* Draw the passed waveform */
        if (offset > 0)
        {
            int xx = offset > half ? x : x + half - offset;
            int oo = offset > half ? offset - half : 0;
            int ww = offset > half ? half : offset;

            GlStateManager.color(brightness, brightness, brightness);
            file.waveform.draw(xx, y, oo, 0, ww, h, h);
            GlStateManager.color(1, 1, 1);
        }

        GuiDraw.unscissor(sw, sh);

        Gui.drawRect(x + half, y + 1, x + half + 1, y + h - 1, 0xff57f52a);

        FontRenderer fontRenderer = Minecraft.getMinecraft().fontRenderer;

        if (Blockbuster.audioWaveformFilename.get())
        {
            GuiDraw.drawTextBackground(fontRenderer, file.name, x + 8, y + h / 2 - 4, 0xffffff, 0x99000000);
        }

        if (Blockbuster.audioWaveformTime.get())
        {
            int tick = (int) Math.floor(playback * 20);
            int seconds = tick / 20;
            int milliseconds = (int) (tick % 20 == 0 ? 0 : tick % 20 * 5D);

            String tickLabel = tick + "t (" + seconds + "." + StringUtils.leftPad(String.valueOf(milliseconds), 2, "0") + "s)";

            GuiDraw.drawTextBackground(fontRenderer, tickLabel, x + w - 8 - fontRenderer.getStringWidth(tickLabel), y + h / 2 - 4, 0xffffff, 0x99000000);
        }
    }
}

==================================================

--- Файл №69 ---
Путь: main\java\mchorse\blockbuster\audio\AudioState.java
--------------------
package mchorse.blockbuster.audio;

public enum AudioState
{
    REWIND, PAUSE, PAUSE_SET, RESUME, RESUME_SET, SET, STOP
}

==================================================

--- Файл №70 ---
Путь: main\java\mchorse\blockbuster\capabilities\CapabilityHandler.java
--------------------
package mchorse.blockbuster.capabilities;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.capabilities.recording.IRecording;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.capabilities.recording.RecordingProvider;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.PacketSceneCast;
import mchorse.blockbuster.network.common.structure.PacketStructureList;
import mchorse.blockbuster.network.server.ServerHandlerStructureRequest;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.utils.LatencyTimer;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.event.AttachCapabilitiesEvent;
import net.minecraftforge.event.entity.player.PlayerEvent.StartTracking;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerLoggedInEvent;

import java.util.Map;

/**
 * Capability handler class
 *
 * This class is responsible for managing capabilities, i.e. attaching
 * capabilities and syncing values on the client.
 */
public class CapabilityHandler
{
    public static final ResourceLocation RECORDING_CAP = new ResourceLocation(Blockbuster.MOD_ID, "recording_capability");

    /**
     * Attach capabilities (well, only one, right now)
     */
    @SubscribeEvent
    @SuppressWarnings("deprecation")
    public void attachPlayerCapability(AttachCapabilitiesEvent<Entity> event)
    {
        if (!(event.getObject() instanceof EntityPlayer))
        {
            return;
        }

        event.addCapability(RECORDING_CAP, new RecordingProvider());
    }

    /**
     * When player logs in, sent him his server counter partner's values.
     */
    @SubscribeEvent
    public void playerLogsIn(PlayerLoggedInEvent event)
    {
        EntityPlayerMP player = (EntityPlayerMP) event.player;
        IRecording recording = Recording.get(player);

        Dispatcher.sendTo(new PacketStructureList(ServerHandlerStructureRequest.getAllStructures()), player);

        if (recording.getLastScene() != null)
        {
            Scene scene = CommonProxy.scenes.get(recording.getLastScene(), player.world);

            if (scene != null)
            {
                Dispatcher.sendTo(new PacketSceneCast(new SceneLocation(scene)).open(false), player);
            }
        }

        /* send playing audio to client */
        for(Map.Entry<String, Scene> entry : CommonProxy.scenes.getScenes().entrySet())
        {
            entry.getValue().syncAudio(player);
        }
    }

    /**
     * When player starts tracking an actor, server has to send actor's record
     * frames to the player
     */
    @SubscribeEvent
    public void playerStartsTracking(StartTracking event)
    {
        Entity target = event.getTarget();
        EntityPlayerMP player = (EntityPlayerMP) event.getEntityPlayer();

        if (target instanceof EntityLivingBase)
        {
            RecordPlayer playback = EntityUtils.getRecordPlayer((EntityLivingBase) target);

            if (playback != null)
            {
                RecordUtils.sendRequestedRecord(target.getEntityId(), playback.record.filename, player);
            }
        }
    }
}

==================================================

--- Файл №71 ---
Путь: main\java\mchorse\blockbuster\capabilities\recording\IRecording.java
--------------------
package mchorse.blockbuster.capabilities.recording;

import mchorse.blockbuster.recording.RecordPlayer;
import net.minecraft.util.math.BlockPos;

/**
 * Recording capability
 *
 * This capability is responsible for tracking client player's resources such
 * as loaded records and camera profile (and also some data related to tracking
 * the changes of these resources).
 *
 * I think it will be server-side only capability (no need to sync with client).
 */
public interface IRecording
{
    /**
     * Get last edited scene
     */
    public String getLastScene();

    /**
     * Set last edited scene
     */
    public void setLastScene(String scene);

    /**
     * Does player has loaded recording?
     */
    public boolean hasRecording(String filename);

    /**
     * What is the last time given recording was updated?
     */
    public long recordingTimestamp(String filename);

    /**
     * Add a recording
     */
    public void addRecording(String filename, long timestamp);

    /**
     * Remove a recording
     */
    public void removeRecording(String filename);

    /**
     * Remove all recordings
     */
    public void removeRecordings();

    /**
     * Update given recording's timestamp
     */
    public void updateRecordingTimestamp(String filename, long timestamp);

    /**
     * Set last teleported block position  
     */
    public void setLastTeleportedBlockPos(BlockPos pos);

    /**
     * Get last teleported block position 
     */
    public BlockPos getLastTeleportedBlockPos();

    /**
     * Set record player which will animate this player 
     */
    public void setRecordPlayer(RecordPlayer player);

    /**
     * Get the record player which animates this player 
     */
    public RecordPlayer getRecordPlayer();

    /**
     * Whether this player is fake
     */
    public boolean isFakePlayer();

    /**
     * Set fake player
     */
    public void setFakePlayer(boolean fakePlayer);
}

==================================================

--- Файл №72 ---
Путь: main\java\mchorse\blockbuster\capabilities\recording\Recording.java
--------------------
package mchorse.blockbuster.capabilities.recording;

import java.util.HashMap;
import java.util.Map;

import mchorse.blockbuster.recording.RecordPlayer;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.BlockPos;

/**
 * Default implementation of {@link IRecording}
 */
public class Recording implements IRecording
{
    public String lastScene = "";
    public Map<String, ItemInfo> recordings = new HashMap<String, ItemInfo>();
    public BlockPos teleportPos;
    public RecordPlayer player;
    public boolean fakePlayer;

    public static IRecording get(EntityPlayer player)
    {
        return player.getCapability(RecordingProvider.RECORDING, null);
    }

    @Override
    public String getLastScene()
    {
        return this.lastScene;
    }

    @Override
    public void setLastScene(String scene)
    {
        if (scene == null)
        {
            return;
        }

        this.lastScene = scene;
    }

    @Override
    public boolean hasRecording(String filename)
    {
        return this.recordings.containsKey(filename);
    }

    @Override
    public long recordingTimestamp(String filename)
    {
        return this.recordings.get(filename).timestamp;
    }

    @Override
    public void addRecording(String filename, long timestamp)
    {
        if (this.hasRecording(filename))
        {
            this.updateRecordingTimestamp(filename, timestamp);
        }
        else
        {
            this.recordings.put(filename, new ItemInfo(filename, timestamp));
        }
    }

    @Override
    public void removeRecording(String filename)
    {
        this.recordings.remove(filename);
    }

    @Override
    public void removeRecordings()
    {
        this.recordings.clear();
    }

    @Override
    public void updateRecordingTimestamp(String filename, long timestamp)
    {
        if (this.hasRecording(filename))
        {
            this.recordings.get(filename).timestamp = timestamp;
        }
    }

    @Override
    public void setLastTeleportedBlockPos(BlockPos pos)
    {
        this.teleportPos = pos;
    }

    @Override
    public BlockPos getLastTeleportedBlockPos()
    {
        return this.teleportPos;
    }

    @Override
    public void setRecordPlayer(RecordPlayer player)
    {
        this.player = player;
    }

    @Override
    public RecordPlayer getRecordPlayer()
    {
        return this.player;
    }

    @Override
    public boolean isFakePlayer()
    {
        return this.fakePlayer;
    }

    @Override
    public void setFakePlayer(boolean fakePlayer)
    {
        this.fakePlayer = fakePlayer;
    }

    /**
     * Item information class
     *
     * Instance of this class is responsible for storing information about a
     * file item like camera profile or recording with timestamp of when
     * it was changed.
     */
    public static class ItemInfo
    {
        public String filename;
        public long timestamp;

        public ItemInfo()
        {
            this("", -1);
        }

        public ItemInfo(String filename, long timestamp)
        {
            this.filename = filename;
            this.timestamp = timestamp;
        }
    }
}

==================================================

--- Файл №73 ---
Путь: main\java\mchorse\blockbuster\capabilities\recording\RecordingProvider.java
--------------------
package mchorse.blockbuster.capabilities.recording;

import mchorse.metamorph.capabilities.morphing.MorphingProvider;
import net.minecraft.nbt.NBTBase;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.CapabilityInject;
import net.minecraftforge.common.capabilities.ICapabilityProvider;
import net.minecraftforge.common.capabilities.ICapabilitySerializable;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Recording provider
 *
 * Basic version of a capability provider. Most of the code is taken from
 * {@link MorphingProvider}.
 */
public class RecordingProvider implements ICapabilitySerializable<NBTBase>
{
    @CapabilityInject(IRecording.class)
    public static final Capability<IRecording> RECORDING = null;

    private IRecording instance = RECORDING.getDefaultInstance();

    @Override
    public boolean hasCapability(Capability<?> capability, EnumFacing facing)
    {
        return capability == RECORDING;
    }

    @Override
    public <T> T getCapability(Capability<T> capability, EnumFacing facing)
    {
        return capability == RECORDING ? RECORDING.<T>cast(this.instance) : null;
    }

    @Override
    public NBTBase serializeNBT()
    {
        return RECORDING.getStorage().writeNBT(RECORDING, this.instance, null);
    }

    @Override
    public void deserializeNBT(NBTBase nbt)
    {
        RECORDING.getStorage().readNBT(RECORDING, this.instance, null, nbt);
    }
}

==================================================

--- Файл №74 ---
Путь: main\java\mchorse\blockbuster\capabilities\recording\RecordingStorage.java
--------------------
package mchorse.blockbuster.capabilities.recording;

import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.common.capabilities.Capability;
import net.minecraftforge.common.capabilities.Capability.IStorage;
import net.minecraftforge.common.util.Constants;

/**
 * Recording capability storage
 *
 * This storage saves only current camera profile's name, because the other
 * fields like the timestamp of camera profile or recording information does
 * needed only during runtime.
 *
 * Basically, when client joins, he doesn't have any of that information except
 * latest camera profile he had in previous session, so we just don't store it.
 */
public class RecordingStorage implements IStorage<IRecording>
{
    @Override
    public NBTBase writeNBT(Capability<IRecording> capability, IRecording instance, EnumFacing side)
    {
        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Scene", instance.getLastScene());

        return tag;
    }

    @Override
    public void readNBT(Capability<IRecording> capability, IRecording instance, EnumFacing side, NBTBase nbt)
    {
        if (nbt instanceof NBTTagCompound)
        {
            NBTTagCompound tag = (NBTTagCompound) nbt;

            if (tag.hasKey("Scene", Constants.NBT.TAG_STRING))
            {
                instance.setLastScene(tag.getString("Scene"));
            }
        }
    }
}

==================================================

--- Файл №75 ---
Путь: main\java\mchorse\blockbuster\client\ActorsPack.java
--------------------
package mchorse.blockbuster.client;

import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.imageio.ImageIO;

import com.google.common.collect.ImmutableSet;

import jdk.nashorn.internal.ir.Block;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.api.ModelPack;
import mchorse.blockbuster.client.textures.GifProcessThread;
import mchorse.blockbuster.client.textures.URLDownloadThread;
import mchorse.blockbuster.utils.mclib.GifFolder;
import mchorse.blockbuster.utils.mclib.GifFrameFile;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.IResourcePack;
import net.minecraft.client.resources.data.IMetadataSection;
import net.minecraft.client.resources.data.MetadataSerializer;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Actors pack
 *
 * This class allows players to customize their actors with custom models and
 * skins.
 *
 * This class is used both on server and on client. I just realized that you
 * can't use IResourcePack on server...
 */
@SideOnly(Side.CLIENT)
public class ActorsPack implements IResourcePack
{
    private static final Pattern GifFrameNSPattern = Pattern.compile("^(.*)\\.gif>\\/frame(\\d+)(_n|_s)\\.png$");
    /**
     * Cached last file from {@link #resourceExists(ResourceLocation)} 
     * method
     */
    private File lastFile;

    /* IResourcePack implementation */

    /**
     * Read a resource from model pack
     */
    @Override
    public InputStream getInputStream(ResourceLocation location) throws IOException
    {
        String domain = location.getResourceDomain();
        String path = location.getResourcePath();

        if ((domain.equals("http") || domain.equals("https")) && path.startsWith("//") && !path.endsWith(".mcmeta"))
        {
            return this.hanldeURLSkins(location);
        }

        File fileFile = this.lastFile;

        /* In case this pack was used without checking for resource 
         * in other method first, find the file */
        if (fileFile == null)
        {
            for (File file : Blockbuster.proxy.pack.folders)
            {
                File packFile = null;

                if (path.contains(".gif>/"))
                {
                    Matcher matcher = GifFrameNSPattern.matcher(path);

                    if (matcher.find())
                    {
                        String pathPart = matcher.group(1);
                        String index = matcher.group(2);
                        String type = matcher.group(3);

                        File gifNS = new File(file, pathPart + type + ".gif");

                        if (gifNS.exists())
                        {
                            packFile = new GifFrameFile(file, pathPart + type + ".gif>/frame" + index + ".png");
                        }
                        else
                        {
                            /* This is what Optifine will to do without this mod. */
                            packFile = new File(file, pathPart + ".gif" + type + ".png");
                        }
                    }
                    else
                    {
                        packFile = new GifFrameFile(file, path);
                    }
                }
                else
                {
                    packFile = new File(file, path);
                }

                if (packFile.exists())
                {
                    fileFile = packFile;
                    break;
                }
            }
        }

        if (fileFile != null)
        {
            this.lastFile = null;

            if (fileFile instanceof GifFrameFile)
            {
                GifFrameFile frame = (GifFrameFile) fileFile;
                GifFolder image = frame.parent;

                if (image.exists())
                {
                    String gifPath = location.getResourcePath();

                    gifPath = gifPath.substring(0, gifPath.lastIndexOf('>'));

                    this.handleGif(RLUtils.create(location.getResourceDomain(), gifPath), image);
                }

                return new FileInputStream(new File(image.getFilePath()));
            }
            else
            {
                if (path.toLowerCase().endsWith(".gif"))
                {
                    GifFolder gifFile = new GifFolder(fileFile.getPath());

                    if (gifFile.exists())
                    {
                        this.handleGif(location, gifFile);
                    }
                }

                return new FileInputStream(fileFile);
            }
        }

        throw new FileNotFoundException(location.toString());
    }

    /**
     * Handle creation of GIF texture 
     */
    private void handleGif(ResourceLocation location, GifFolder gif)
    {
        if (GifProcessThread.THREADS.containsKey(location))
        {
            return;
        }

        new Thread(() ->
        {
            Minecraft.getMinecraft().addScheduledTask(() -> GifProcessThread.create(location, gif));
        }).start();
    }

    /**
     * Handle URL skins 
     */
    private InputStream hanldeURLSkins(ResourceLocation location)
    {
        try
        {
            if (Blockbuster.syncedURLTextureDownload.get())
            {
                InputStream stream = URLDownloadThread.downloadImage(location);

                if (stream == null)
                {
                    throw new IOException("Couldn't download image...");
                }

                return stream;
            }
            else
            {
                new Thread(new URLDownloadThread(location)).start();
            }
        }
        catch (IOException e)
        {}

        /* Make it a black pixel in case it fails */
        return ActorsPack.class.getResourceAsStream("/assets/blockbuster/textures/blocks/black.png");
    }

    /**
     * Check if resource is available in the model pack. This method 
     * also supports old mapping method for model skins
     */
    @Override
    public boolean resourceExists(ResourceLocation location)
    {
        /* Handle skin URLs */
        String domain = location.getResourceDomain();
        String path = location.getResourcePath();

        /* Only actual HTTP URL can go here, also ignore mcmeta data */
        if ((domain.equals("http") || domain.equals("https")) && path.startsWith("//") && !path.endsWith(".mcmeta"))
        {
            return true;
        }

        /* Handle models path */
        for (File file : Blockbuster.proxy.pack.folders)
        {
            if (path.contains(".gif>/"))
            {
                Matcher matcher = GifFrameNSPattern.matcher(path);

                if (matcher.find())
                {
                    String pathPart = matcher.group(1);
                    String index = matcher.group(2);
                    String type = matcher.group(3);

                    File gifNS = new File(file, pathPart + type + ".gif");

                    if (gifNS.exists())
                    {
                        this.lastFile = new GifFrameFile(file, pathPart + type + ".gif>/frame" + index + ".png");
                    }
                    else
                    {
                        this.lastFile = new File(file, pathPart + ".gif" + type + ".png");
                    }
                }
                else
                {
                    this.lastFile = new GifFrameFile(file, path);
                }
            }
            else
            {
                this.lastFile = new File(file, path);
            }

            if (this.lastFile.exists())
            {
                return true;
            }
        }

        this.lastFile = null;

        return false;
    }

    /**
     * Get resource domains
     *
     * Having multiple domains seems like a nice idea for aliases. 
     * I'm totally using it for URL skins
     */
    @Override
    public Set<String> getResourceDomains()
    {
        return ImmutableSet.<String>of("b.a", "http", "https");
    }

    @Override
    public String getPackName()
    {
        return "Blockbuster's Actor Pack";
    }

    /**
     * Get pack metadata
     *
     * This method is returns null, because it isn't an actual resource pack, but
     * just a way to pass resources into minecraft core.
     *
     * Either Jabelar or TheGreyGhost mentioned that returning null in this
     * method, disable listing of this resource pack in the resource pack menu.
     * Seems legit to me.
     */
    @Override
    public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String metadataSectionName) throws IOException
    {
        return null;
    }

    /**
     * I don't think that my actor resources pack should have an icon. 
     * However that icon would look really badass/sexy.
     */
    @Override
    public BufferedImage getPackImage() throws IOException
    {
        return null;
    }
}

==================================================

--- Файл №76 ---
Путь: main\java\mchorse\blockbuster\client\KeyboardHandler.java
--------------------
package mchorse.blockbuster.client;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.GuiGun;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.client.registry.ClientRegistry;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.InputEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent.ClientDisconnectionFromServerEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

/**
 * Separate event handler for keyboard events
 */
@SideOnly(Side.CLIENT)
public class KeyboardHandler
{
    /* Misc. */
    private KeyBinding plause;
    private KeyBinding record;
    private KeyBinding pause;
    private KeyBinding openGun;
    public static KeyBinding zoom;
    public static KeyBinding gunReload;
    public static KeyBinding gunShoot;

    /**
     * Create and register key bindings for mod
     */
    public KeyboardHandler()
    {
        /* Key categories */
        String category = "key.blockbuster.category";

        /* Misc */
        this.plause = new KeyBinding("key.blockbuster.plause_director", Keyboard.KEY_RCONTROL, category);
        this.record = new KeyBinding("key.blockbuster.record_director", Keyboard.KEY_RMENU, category);
        this.pause = new KeyBinding("key.blockbuster.pause_director", Keyboard.KEY_RSHIFT, category);
        this.openGun = new KeyBinding("key.blockbuster.open_gun", Keyboard.KEY_END, category);
        this.zoom = new KeyBinding("key.blockbuster.zoom", 0, category);
        this.gunReload = new KeyBinding("key.blockbuster.gun_reload", 19, category);
        this.gunShoot = new KeyBinding("key.blockbuster.gun_shoot", -100, category);

        ClientRegistry.registerKeyBinding(this.plause);
        ClientRegistry.registerKeyBinding(this.record);
        ClientRegistry.registerKeyBinding(this.pause);
        ClientRegistry.registerKeyBinding(this.openGun);
        ClientRegistry.registerKeyBinding(this.zoom);
        ClientRegistry.registerKeyBinding(this.gunReload);
        ClientRegistry.registerKeyBinding(this.gunShoot);
    }

    @SubscribeEvent
    public void onUserLogOut(ClientDisconnectionFromServerEvent event)
    {
        ClientProxy.manager.reset();
        ClientProxy.recordingOverlay.setVisible(false);
        RenderingHandler.resetEmitters();

        Minecraft.getMinecraft().addScheduledTask(StructureMorph::cleanUp);
    }


    @SubscribeEvent
    public void onKey(InputEvent.KeyInputEvent event)
    {
        if (this.plause.isPressed())
        {
            if (ClientProxy.panels.scenePanel != null)
            {
                ClientProxy.panels.scenePanel.plause();
            }
        }

        if (this.record.isPressed())
        {
            if (ClientProxy.panels.scenePanel != null)
            {
                ClientProxy.panels.scenePanel.record();
            }
        }

        if (this.pause.isPressed())
        {
            if (ClientProxy.panels.scenePanel != null)
            {
                ClientProxy.panels.scenePanel.pause();
            }
        }

        Minecraft mc = Minecraft.getMinecraft();

        if (this.openGun.isPressed() && mc.player.capabilities.isCreativeMode && OpHelper.isPlayerOp())
        {
            ItemStack stack = mc.player.getHeldItemMainhand();

            if (stack.getItem() == Blockbuster.gunItem)
            {
                mc.displayGuiScreen(new GuiGun(stack));
            }
        }
    }
}

==================================================

--- Файл №77 ---
Путь: main\java\mchorse\blockbuster\client\RenderingHandler.java
--------------------
package mchorse.blockbuster.client;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.audio.AudioRenderer;
import mchorse.blockbuster.client.gui.GuiRecordingOverlay;
import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.render.IRenderLast;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelRenderer;
import mchorse.blockbuster.client.textures.GifTexture;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.OrientedBB;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.RecordRecorder;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.OptifineHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.AbstractClientPlayer;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.model.ModelPlayer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EntitySelectors;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.client.MinecraftForgeClient;
import net.minecraftforge.client.event.EntityViewRenderEvent;
import net.minecraftforge.client.event.RenderGameOverlayEvent;
import net.minecraftforge.client.event.RenderHandEvent;
import net.minecraftforge.client.event.RenderLivingEvent;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;
import org.objectweb.asm.tree.MethodNode;
import scala.Int;

import javax.vecmath.Vector3d;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Random;
import java.util.Set;

/**
 * Rendering handler
 *
 * This handler is another handler in this mod that responsible for rendering.
 * Currently this handler only renders recording overlay
 */
@SideOnly(Side.CLIENT)
public class RenderingHandler
{
    private static EntityLivingBase lastItemHolder;
    public static Set<Record> recordsToRender = new HashSet<Record>();
    public static Set<OrientedBB> obbsToRender = new HashSet<OrientedBB>();

    private static final List<EntityActor> renderedEntityActors = new ArrayList<>();
    private static final List<IRenderLast> renderLasts = new ArrayList<>();
    /** Runnables to be executed at the end of renderlast event */
    private static final List<Runnable> renderLastBus = new ArrayList<>();
    private static ListIterator<Runnable> renderLastBusIterator = renderLastBus.listIterator();

    /**
     * is true when renderLasts List is being iterated
     */
    private static boolean isRenderingLast;

    private boolean wasPaused;

    /**
     * Bedrock particle emitters
     */
    private static final List<BedrockEmitter> emitters = new ArrayList<BedrockEmitter>();
    private static final List<BedrockEmitter> emittersAdd = new ArrayList<BedrockEmitter>();
    private static boolean emitterIsIterating;

    private GuiRecordingOverlay overlay;

    /**
     *  The transformType of the item currently rendered like TransformType.GUI, TransformType.GROUND, TransformType.THIRD_PERSON_RIGHT_HAND etc.
     *  This variable is set by {@link #setTSRTTransform(ItemCameraTransforms.TransformType)} which is called by ASM.
     */
    public static ItemCameraTransforms.TransformType itemTransformType;

    /**
     * Add a renderLast object to the renderLast List. They will be rendered after entities.
     * This method only adds the given object if the renderLast List is not being iterated
     * @param renderLast
     * @return true if added to the list, false if not added, for example, when RenderingHandler is currently rendering last.
     */
    public static boolean addRenderLast(IRenderLast renderLast)
    {
        /* only add a render last object when the renderLasts List is not iterated */
        if (!isRenderingLast)
        {
            renderLasts.add(renderLast);

            return true;
        }

        return false;
    }

    /**
     * Called by ASM in RenderGlobal.renderEntities() {@link mchorse.blockbuster.core.transformers.RenderGlobalTransformer}
     * @param entity
     */
    public static void addRenderedEntity(Entity entity)
    {
        if (entity instanceof EntityActor)
        {
            renderedEntityActors.add((EntityActor) entity);
        }
    }

    /**
     * Add a runnable that will be executed at the end of {@link #onRenderLast(RenderWorldLastEvent)}
     */
    public static void registerRenderLastEvent(Runnable runnable)
    {
        renderLastBusIterator.add(runnable);
    }

    /**
     * Render green sky, this is getting invoked from the ASM patched 
     * code in {@link RenderGlobal}
     */
    public static void renderGreenSky()
    {
        int color = Blockbuster.chromaSkyColor.get();
        float skyR = (color >> 16 & 0xff) / 255F;
        float skyG = (color >> 8 & 0xff) / 255F;
        float skyB = (color & 0xff) / 255F;
        float skyA = (color >> 24 & 0xff) / 255F;

        GlStateManager.clearColor(skyR, skyG, skyB, skyA);
        GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT);
        GL11.glDisable(GL11.GL_FOG);
    }

    /**
     * Check whether it's time to render green sky, this is getting 
     * invoked from ASM patched code in {@link RenderGlobal}  
     */
    public static boolean isGreenSky()
    {
        return Blockbuster.chromaSky.get();
    }

    /**
     * Render lit particles (call by ASM, but not used for anything yet...
     * I might use it for morph based Snowstorm system)...
     */
    public static void renderLitParticles(float partialTicks)
    {}

    /**
     * Render BB gun рands
     */
    public static void changePlayerHand(AbstractClientPlayer player, ModelPlayer modelPlayer)
    {
        ItemStack itemstack = player.getHeldItemMainhand();
        ModelBiped.ArmPose armPose = ModelBiped.ArmPose.EMPTY;
        
        if (!itemstack.isEmpty() && itemstack.getItem() instanceof ItemGun)
        {
            GunProps props = NBTUtils.getGunProps(itemstack);

            if (props.alwaysArmsShootingPose)
            {
                armPose = ModelBiped.ArmPose.BOW_AND_ARROW;
            }
            else
            {
                if (props.enableArmsShootingPose)
                {
                    if (KeyboardHandler.gunShoot.isKeyDown())
                    {
                        armPose = ModelBiped.ArmPose.BOW_AND_ARROW;
                    }
                }
            }
        }

        if (player.getPrimaryHand() == EnumHandSide.RIGHT)
        {
            modelPlayer.rightArmPose = armPose;
        }
        else
        {
            modelPlayer.leftArmPose = armPose;
        }
        
    }
    /**
     * Render particle emitters (called by ASM)
     */
    public static void renderParticles(float partialTicks)
    {
        if (!emitters.isEmpty())
        {
            if (Blockbuster.snowstormDepthSorting.get())
            {
                emitters.sort((a, b) ->
                {
                    double ad = a.getDistanceSq();
                    double bd = b.getDistanceSq();

                    if (ad < bd)
                    {
                        return 1;
                    }
                    else if (ad > bd)
                    {
                        return -1;
                    }

                    return 0;
                });
            }

            emitterIsIterating = true;

            for (BedrockEmitter emitter : emitters)
            {
                emitter.render(partialTicks);
                emitter.running = emitter.sanityTicks < 2;
            }

            addEmitters();

            emitterIsIterating = false;
        }
    }

    public static void addEmitter(BedrockEmitter emitter, EntityLivingBase target)
    {
        if (!emitter.added)
        {
            if (emitterIsIterating)
            {
                emittersAdd.add(emitter);
            }
            else
            {
                emitters.add(emitter);
            }

            emitter.added = true;
            emitter.setTarget(target);
        }
    }

    private static void addEmitters()
    {
        if (!emittersAdd.isEmpty())
        {
            emitters.addAll(emittersAdd);
            emittersAdd.clear();
        }
    }

    public static void updateEmitters()
    {
        List<BedrockEmitter> emittersRemove = new ArrayList<>();

        emitterIsIterating = true;

        for(BedrockEmitter emitter : emitters)
        {
            emitter.update();

            if (emitter.isFinished())
            {
                emittersRemove.add(emitter);

                emitter.added = false;
            }
        }

        if (!emittersRemove.isEmpty())
        {
            emitters.removeAll(emittersRemove);
        }

        addEmitters();

        emitterIsIterating = false;
    }

    public static void resetEmitters()
    {
        emitters.clear();
    }

    /**
     * Called by ASM {@link mchorse.blockbuster.core.transformers.RenderGlobalTransformer}
     * to render the entities that should be depth sorted after tileentities and entities have been rendered
     */
    public static void renderLastEntities()
    {
        if (MinecraftForgeClient.getRenderPass() != 0)
        {
            renderLasts.clear();
            renderedEntityActors.clear();

            return;
        }

        Minecraft mc = Minecraft.getMinecraft();
        Entity camera = mc.getRenderViewEntity();

        /* render always actors that have not been rendered */
        if (Blockbuster.actorAlwaysRender.get())
        {
            List<EntityActor> actors = mc.world.getEntities(EntityActor.class, EntitySelectors.IS_ALIVE);

            actors.removeAll(renderedEntityActors);
            actors.removeAll(renderLasts);

            /*
             * Add them to renderLast
             * because renderLast entities that are out of range won't be added to renderLast
             */
            renderLasts.addAll(actors);
        }

        /* render entities and tileEntities last */
        renderLasts.sort((a, b) ->
        {
            Vector3d aPos = a.getRenderLastPos();
            Vector3d bPos = b.getRenderLastPos();

            double dist1 = camera.getDistanceSq(aPos.x, aPos.y, aPos.z);
            double dist2 = camera.getDistanceSq(bPos.x, bPos.y, bPos.z);

            return dist1 == dist2 ? 0 : (dist2 - dist1 > 0 ? 1 : -1);
        });

        isRenderingLast = true;

        for (IRenderLast renderLast : renderLasts)
        {
            if (renderLast instanceof EntityActor)
            {
                /*
                 * Optifine calls net.optifine.shaders.Shaders.nextEntity before entity is rendered
                 * Without this the lighting / shadows are weird on renderLast models
                 */
                OptifineHelper.nextEntity((EntityActor) renderLast);

                mc.getRenderManager().renderEntityStatic((EntityActor) renderLast, mc.getRenderPartialTicks(), false);
            }
            else if (renderLast instanceof TileEntityModel)
            {
                /*
                 * Optifine calls net.optifine.shaders.Shaders.nextBlockEntity before tileEntity is rendered
                 * Without this the lighting / shadows are weird on renderLast models
                 */
                OptifineHelper.nextBlockEntity((TileEntityModel) renderLast);

                TileEntityRendererDispatcher.instance.render((TileEntityModel) renderLast, mc.getRenderPartialTicks(), -1);
            }
        }

        isRenderingLast = false;

        renderLasts.clear();
        renderedEntityActors.clear();
    }

    /**
     * Called by ASM
     */
    public static void setLastItemHolder(EntityLivingBase entity)
    {
        if (lastItemHolder == null)
        {
            lastItemHolder = entity;
        }
    }

    /**
     * Called by ASM {@link mchorse.blockbuster.core.transformers.RenderItemTransformer}
     * and sets the transform type of the currently rendered item
     * Called in renderItem, renderItemModel and renderItemModelIntoGUI method of Minecraft.
     */
    public static void setTSRTTransform(ItemCameraTransforms.TransformType type)
    {
        itemTransformType = type;
    }

    /**
     * Called by ASM {@link mchorse.blockbuster.core.transformers.RenderItemTransformer}.
     * This method sets the entity that is holding the item which is currently rendered.
     * Called in renderItem method of RenderItem class.
     */
    public static void resetLastItemHolder(EntityLivingBase entity)
    {
        if (lastItemHolder == entity)
        {
            lastItemHolder = null;
        }
    }

    public static EntityLivingBase getLastItemHolder()
    {
        return lastItemHolder;
    }

    public RenderingHandler(GuiRecordingOverlay overlay)
    {
        this.overlay = overlay;
    }

    /**
     * Fixes lightmap for TEISR
     */
    @SubscribeEvent
    public void onHUDRender(RenderGameOverlayEvent.Pre event)
    {
        if (event.getType() == RenderGameOverlayEvent.ElementType.ALL)
        {
            Minecraft.getMinecraft().entityRenderer.enableLightmap();
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, 240);
            Minecraft.getMinecraft().entityRenderer.disableLightmap();
        }
    }

    /**
     * Renders recording overlay during HUD rendering
     */
    @SubscribeEvent
    public void onHUDRender(RenderGameOverlayEvent.Post event)
    {
        ScaledResolution resolution = event.getResolution();

        if (event.getType() == RenderGameOverlayEvent.ElementType.ALL)
        {
            int w = resolution.getScaledWidth();
            int h = resolution.getScaledHeight();

            this.overlay.draw(w, h);

            if (!CameraHandler.isCameraEditorOpen())
            {
                int width = (int) (w * Blockbuster.audioWaveformWidth.get());

                AudioRenderer.renderAll((w - width) / 2, h / 2 + h / 4, width, Blockbuster.audioWaveformHeight.get(), w, h);
            }
        }
    }

    /**
     * Add Blockbuster debug strings, such as length of client records and
     * recording information, to the debug overlay.
     */
    @SubscribeEvent
    public void onHUDRender(RenderGameOverlayEvent.Text event)
    {
        if (!Minecraft.getMinecraft().gameSettings.showDebugInfo)
        {
            return;
        }

        List<String> list = event.getLeft();

        list.add("");
        list.add(ClientProxy.manager.records.size() + " client records");

        RecordRecorder recorder = ClientProxy.manager.recorders.get(Minecraft.getMinecraft().player);

        if (recorder != null)
        {
            list.add("Recording frame " + recorder.tick);
        }
    }

    /**
     * On render last world event, this bad boy will tick all of the GIF 
     * textures which were registered, and will keep track of audio
     */
    @SubscribeEvent
    public void onRenderLast(RenderWorldLastEvent event)
    {
        ModelExtrudedLayer.tickCache();

        Minecraft mc = Minecraft.getMinecraft();
        boolean isPaused = mc.isGamePaused();

        if (this.wasPaused != isPaused)
        {
            ClientProxy.audio.pause(isPaused);

            this.wasPaused = isPaused;
        }

        /* render actor paths */
        if (mc.gameSettings.showDebugInfo && !recordsToRender.isEmpty() && Blockbuster.recordRenderDebugPaths.get())
        {
            renderPaths(event, recordsToRender);
        }

        recordsToRender.clear();

        /* TODO render OBB outlines (move this code to limb renderer or so, later)*/
        if (mc.gameSettings.showDebugInfo && !obbsToRender.isEmpty())
        {
            for (OrientedBB obb : this.obbsToRender)
            {
                obb.render(event);
            }
        }
        obbsToRender.clear();

        renderLastBusIterator = renderLastBus.listIterator();

        while (renderLastBusIterator.hasNext())
        {
            Runnable runnable = renderLastBusIterator.next();

            runnable.run();
        }

        renderLastBus.clear();
        renderLastBusIterator = renderLastBus.listIterator();
    }

    private void renderPaths(RenderWorldLastEvent event, Set<Record> recordsToRender)
    {
        int shader = GL11.glGetInteger(GL20.GL_CURRENT_PROGRAM);

        if (shader != 0)
        {
            OpenGlHelper.glUseProgram(0);
        }

        final int delta = 2;
        Color color = ColorUtils.COLOR;
        Entity player = Minecraft.getMinecraft().getRenderViewEntity();
        Random random = new Random();

        double playerX = player.prevPosX + (player.posX - player.prevPosX) * event.getPartialTicks();
        double playerY = player.prevPosY + (player.posY - player.prevPosY) * event.getPartialTicks();
        double playerZ = player.prevPosZ + (player.posZ - player.prevPosZ) * event.getPartialTicks();

        GlStateManager.glLineWidth(2F);
        GlStateManager.disableLighting();
        GlStateManager.disableTexture2D();

        for (Record record : recordsToRender)
        {
            int length = record.frames.size();

            if (length < delta + 1)
            {
                continue;
            }

            random.setSeed(record.filename.hashCode());
            random.setSeed(random.nextLong());

            int hex = MathHelper.hsvToRGB(random.nextFloat(), 1F, 1F);

            color.set(hex, false);

            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder builder = tessellator.getBuffer();

            builder.setTranslation(-playerX, -playerY, -playerZ);
            builder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

            for (int i = delta; i < length; i += delta)
            {
                Frame prev = record.frames.get(i - delta);
                Frame current = record.frames.get(i);

                builder.pos(prev.x, prev.y + 1F, prev.z).color(color.r, color.g, color.b, color.a).endVertex();
                builder.pos(current.x, current.y + 1F, current.z).color(color.r, color.g, color.b, color.a).endVertex();
            }

            builder.setTranslation(0, 0, 0);
            tessellator.draw();
        }

        GlStateManager.enableTexture2D();
        GlStateManager.enableLighting();
        GlStateManager.glLineWidth(1F);

        if (shader != 0)
        {
            OpenGlHelper.glUseProgram(shader);
        }
    }

    @SubscribeEvent
    public void onOrientCamera(EntityViewRenderEvent.CameraSetup event)
    {
        EntityPlayer thePlayer = Minecraft.getMinecraft().player;
        RecordPlayer player = EntityUtils.getRecordPlayer(thePlayer);

        if (player != null && player.record != null && !player.record.frames.isEmpty())
        {
            Frame frame = player.record.getFrameSafe(player.tick);
            Frame prev = player.record.getFrameSafe(player.tick - 1);
            float partial = (float) event.getRenderPartialTicks();

            event.setYaw(Interpolations.lerp(prev.yawHead, frame.yawHead, partial) - 180);
            event.setPitch(Interpolations.lerp(prev.pitch, frame.pitch, partial));
        }
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onRenderHand(RenderHandEvent event)
    {
        EntityPlayer thePlayer = Minecraft.getMinecraft().player;
        RecordPlayer player = EntityUtils.getRecordPlayer(thePlayer);

        if (player != null && player.record != null && !player.record.frames.isEmpty())
        {
            Frame frame = player.record.getFrameSafe(player.tick);
            Frame prev = player.record.getFrameSafe(player.tick - 1);

            float partial = event.getPartialTicks();
            float yaw = Interpolations.lerp(prev.yaw, frame.yaw, partial);
            float pitch = Interpolations.lerp(prev.pitch, frame.pitch, partial);

            thePlayer.rotationYaw = yaw;
            thePlayer.rotationPitch = pitch;
            thePlayer.prevRotationYaw = yaw;
            thePlayer.prevRotationPitch = pitch;
        }
    }

    @SubscribeEvent
    public void onPreRenderEntity(RenderLivingEvent.Pre event)
    {
        GifTexture.entityTick = event.getEntity().ticksExisted;
    }

    @SubscribeEvent
    public void onPostRenderEntity(RenderLivingEvent.Post event)
    {
        GifTexture.entityTick = -1;
    }
}

==================================================

--- Файл №78 ---
Путь: main\java\mchorse\blockbuster\client\SkinHandler.java
--------------------
package mchorse.blockbuster.client;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.CommonProxy;
import net.minecraft.client.Minecraft;
import org.apache.commons.io.FilenameUtils;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.util.Iterator;

public class SkinHandler
{
    /**
     * Check general skins folder, and move these files to appropriate
     * skins folders
     */
    public static void checkSkinsFolder()
    {
        if (!ClientProxy.skinsFolder.exists())
        {
            return;
        }

        File[] files = ClientProxy.skinsFolder.listFiles();

        if (files == null)
        {
            return;
        }

        for (File file : files)
        {
            if (file.isFile())
            {
                tryReadingMovingSkinFile(file);
            }
        }
    }

    private static void tryReadingMovingSkinFile(File file)
    {
        try
        {
            FileInputStream stream = new FileInputStream(file);

            try (ImageInputStream in = ImageIO.createImageInputStream(stream))
            {
                final Iterator<ImageReader> readers = ImageIO.getImageReaders(in);

                if (readers.hasNext())
                {
                    ImageReader reader = readers.next();

                    try
                    {
                        reader.setInput(in);
                        int w = reader.getWidth(0);
                        int h = reader.getHeight(0);
                        reader.dispose();
                        stream.close();

                        reader = null;
                        tryMovingSkin(file, w, h);
                    }
                    finally
                    {
                        if (reader != null)
                        {
                            reader.dispose();
                            stream.close();
                        }
                    }
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private static void tryMovingSkin(File file, int w, int h)
    {
        float aspect = w / (float) h;

        /* Must be 1 to 1 or 2 to 1 aspect ratio */
        if (!(aspect == 2F || aspect == 1F))
        {
            return;
        }

        int hf = aspect == 1F ? 64 : 32;

        if (!(w % 64 == 0 || h % hf == 0))
        {
            return;
        }

        moveToDestination(hf == 64 ? "fred" : "steve", file);
    }

    private static void moveToDestination(String folder, File input)
    {
        String name = input.getName();
        File file = new File(CommonProxy.configFile, "models/" + folder + "/skins/" + name);

        for (int i = 1; file.exists() && i < 1000; i++)
        {
            file = new File(CommonProxy.configFile, "models/" + folder + "/skins/" + FilenameUtils.getBaseName(name) + "_" + i + "." + FilenameUtils.getExtension(name));
        }

        if (!file.exists())
        {
            boolean moved = input.renameTo(file);

            if (moved)
            {
                Blockbuster.l10n.success(Minecraft.getMinecraft().player, "model.skin_moved", name, "blockbuster." + folder, file.getName());
            }
        }
    }
}

==================================================

--- Файл №79 ---
Путь: main\java\mchorse\blockbuster\client\gui\GuiActor.java
--------------------
package mchorse.blockbuster.client.gui;

import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyActor;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsMenu;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;

public class GuiActor extends GuiBase
{
    public GuiMorphRenderer renderer;
    public GuiButtonElement pick;
    public GuiCreativeMorphsMenu morphs;

    private EntityActor actor;

    public GuiActor(Minecraft mc, EntityActor actor)
    {
        this.actor = actor;

        this.renderer = new GuiMorphRenderer(mc);
        this.renderer.morph = actor.morph.get();
        this.renderer.flex().reset().relative(this.viewport).wh(1F, 1F);

        this.pick = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.pick"), (button) ->
        {
            this.morphs.resize();
            this.morphs.setSelected(this.renderer.morph);
            this.root.add(this.morphs);
        });
        this.pick.flex().relative(this.viewport).x(0.5F).y(1F, -10).w(100).anchor(0.5F, 1F);

        this.morphs = new GuiCreativeMorphsMenu(mc, (morph) -> this.renderer.morph = morph);
        this.morphs.flex().reset().relative(this.viewport).wh(1F, 1F);

        this.root.add(this.renderer, this.pick);
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return false;
    }

    @Override
    protected void closeScreen()
    {
        this.actor.morph.setDirect(this.renderer.morph);
        Dispatcher.sendToServer(new PacketModifyActor(this.actor));

        super.closeScreen();
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        this.drawDefaultBackground();
        this.drawCenteredString(this.context.font, I18n.format("blockbuster.gui.actor.title"), this.width / 2, 16, 0xffffff);

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

==================================================

--- Файл №80 ---
Путь: main\java\mchorse\blockbuster\client\gui\GuiGun.java
--------------------
package mchorse.blockbuster.client.gui;

import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiPoseTransformations;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketGunInfo;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.GuiPanelBase;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsMenu;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.JsonToNBT;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;

@SideOnly(Side.CLIENT)
public class GuiGun extends GuiBase
{
    public GunProps props;
    public int index;

    public GuiPanelBase<GuiElement> panel;

    /* Morphs configuration */
    public GuiCreativeMorphsMenu morphs;

    /* Gun options */
    public GuiElement gunOptions;
    public GuiNestedEdit pickDefault;
    public GuiNestedEdit pickFiring;
    public GuiTextElement fireCommand;
    public GuiTrackpadElement delay;
    public GuiTrackpadElement projectiles;
    public GuiTrackpadElement scatterX;
    public GuiTrackpadElement scatterY;
    public GuiToggleElement launch;
    public GuiToggleElement useTarget;
    public GuiSlotElement ammoStack;

    /* Projectile options */
    public GuiElement projectileOptions;
    public GuiNestedEdit pickProjectile;
    public GuiTextElement tickCommand;
    public GuiTrackpadElement ticking;
    public GuiTrackpadElement lifeSpan;
    public GuiToggleElement yaw;
    public GuiToggleElement pitch;
    public GuiToggleElement sequencer;
    public GuiToggleElement random;
    public GuiTrackpadElement hitboxX;
    public GuiTrackpadElement hitboxY;
    public GuiTrackpadElement speed;
    public GuiTrackpadElement friction;
    public GuiTrackpadElement gravity;
    public GuiTrackpadElement fadeIn;
    public GuiTrackpadElement fadeOut;

    /* Evanechecssss' options */
    public GuiElement aimOptions;
    public GuiToggleElement staticRecoil;
    public GuiTrackpadElement recoilXMin;
    public GuiTrackpadElement recoilXMax;
    public GuiTrackpadElement recoilYMin;
    public GuiTrackpadElement recoilYMax;

    public GuiToggleElement enableArmsShootingPose;
    public GuiToggleElement alwaysArmsShootingPose;

    public GuiTrackpadElement shootOffsetX;
    public GuiTrackpadElement shootOffsetY;
    public GuiTrackpadElement shootOffsetZ;

    public GuiNestedEdit pickCrosshairMorph;
    public GuiNestedEdit pickInventoryMorph;
    public GuiNestedEdit pickHandsMorph;
    public GuiNestedEdit pickReloadMorph;
    public GuiNestedEdit pickZoomOverlayMorph;

    public GuiToggleElement hideCrosshairOnZoom;
    public GuiToggleElement useInventoryMorph;
    public GuiToggleElement hideHandsOnZoom;
    public GuiToggleElement useZoomOverlayMorph;

    public GuiTrackpadElement zoomFactor;
    public GuiTrackpadElement ammo;
    public GuiToggleElement useReloading;
    public GuiTrackpadElement reloadingTime;
    public GuiToggleElement shootWhenHeld;
    public GuiTrackpadElement shotDelay;

    /* Evanechecssss's options (page 2) */
    public GuiElement aimOptionsSecond;
    public GuiTextElement destroyCommand;
    public GuiTextElement meleeCommand;
    public GuiTextElement reloadCommand;
    public GuiTextElement zoomOnCommand;
    public GuiTextElement zoomOffCommand;

    public GuiTrackpadElement meleeDamage;
    public GuiTrackpadElement mouseZoom;
    public GuiTrackpadElement durability;
    public GuiToggleElement preventLeftClick;
    public GuiToggleElement preventRightClick;
    public GuiToggleElement preventEntityAttack;

    /* Impact options */
    public GuiElement impactOptions;
    public GuiNestedEdit pickImpact;
    public GuiTextElement impactCommand;
    public GuiTextElement impactEntityCommand;
    public GuiTrackpadElement impactDelay;
    public GuiToggleElement vanish;
    public GuiToggleElement bounce;
    public GuiToggleElement sticks;
    public GuiTrackpadElement hits;
    public GuiTrackpadElement damage;
    public GuiTrackpadElement knockbackHorizontal;
    public GuiTrackpadElement knockbackVertical;
    public GuiTrackpadElement bounceFactor;
    public GuiTextElement vanishCommand;
    public GuiTrackpadElement vanishDelay;
    public GuiTrackpadElement penetration;
    public GuiToggleElement ignoreBlocks;
    public GuiToggleElement ignoreEntities;

    /* Transforms */
    public GuiElement transformOptions;
    public GuiPoseTransformations gun;
    public GuiPoseTransformations projectile;
    public GuiMorphRenderer arms;
    public GuiProjectileModelRenderer bullet;

    /* First person transform */
    public GuiElement transformFirstPersonOptions;
    public GuiPoseTransformations gunFirstPerson;

    public GuiGun(ItemStack stack)
    {
        TileEntityGunItemStackRenderer.GunEntry entry = TileEntityGunItemStackRenderer.models.get(stack);

        if (entry == null)
        {
            this.props = NBTUtils.getGunProps(stack);
        }
        else
        {
            this.props = entry.props;
        }

        Minecraft mc = Minecraft.getMinecraft();

        /* Initialization of GUI elements */
        this.gunOptions = new GuiElement(mc);
        this.projectileOptions = new GuiElement(mc);
        this.aimOptions = new GuiElement(mc);
        this.aimOptionsSecond = new GuiElement(mc);
        this.transformOptions = new GuiElement(mc);
        this.transformFirstPersonOptions = new GuiElement(mc);
        this.impactOptions = new GuiElement(mc);

        this.panel = new GuiGunPanels(mc);
        this.panel.setPanel(this.gunOptions);
        this.panel.registerPanel(this.gunOptions, IKey.lang("blockbuster.gui.gun.fire_props"), Icons.GEAR);
        this.panel.registerPanel(this.projectileOptions, IKey.lang("blockbuster.gui.gun.projectile_props"), BBIcons.BULLET);
        this.panel.registerPanel(this.aimOptions, IKey.lang("blockbuster.gui.gun.aim_options_second"), Icons.SOUND);
        this.panel.registerPanel(this.aimOptionsSecond, IKey.lang("blockbuster.gui.gun.aim_options"), Icons.CURSOR);
        this.panel.registerPanel(this.impactOptions, IKey.lang("blockbuster.gui.gun.impact_props"), Icons.DOWNLOAD);
        this.panel.registerPanel(this.transformOptions, IKey.lang("blockbuster.gui.gun.transforms"), Icons.POSE);
        this.panel.registerPanel(this.transformFirstPersonOptions, IKey.lang("blockbuster.gui.gun.transforms_first_person"), Icons.WRENCH);

        this.morphs = new GuiCreativeMorphsMenu(mc, this::setMorph);

        /* Gun options */
        Area area = this.gunOptions.area;

        this.pickDefault = new GuiNestedEdit(mc, (editing) -> this.openMorphs(1, editing));
        this.pickFiring = new GuiNestedEdit(mc, false, (editing) -> this.openMorphs(2, editing));
        this.fireCommand = new GuiTextElement(mc, 10000, (value) -> this.props.fireCommand = value);
        this.delay = new GuiTrackpadElement(mc, (value) -> this.props.delay = value.intValue());
        this.delay.limit(0, Integer.MAX_VALUE, true);
        this.projectiles = new GuiTrackpadElement(mc, (value) -> this.props.projectiles = value.intValue());
        this.projectiles.limit(0, Integer.MAX_VALUE, true);
        this.scatterX = new GuiTrackpadElement(mc, (value) -> this.props.scatterX = value.floatValue());
        this.scatterX.tooltip(IKey.lang("blockbuster.gui.gun.scatter_x"));
        this.scatterY = new GuiTrackpadElement(mc, (value) -> this.props.scatterY = value.floatValue());
        this.scatterY.tooltip(IKey.lang("blockbuster.gui.gun.scatter_y"));
        this.launch = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.launch"), false, (b) -> this.props.launch = b.isToggled());
        this.useTarget = new GuiToggleElement(mc, IKey.lang("metamorph.gui.body_parts.use_target"), false, (b) -> this.props.useTarget = b.isToggled());
        this.ammoStack = new GuiSlotElement(mc, 0, this::pickItem);
        this.ammoStack.tooltip(IKey.lang("blockbuster.gui.gun.ammo_stack"));
        int firingOffset = 40;

        GuiElement scatterBar = new GuiElement(mc);

        scatterBar.flex().relative(area).set(0, 0, 0, 20).x(0.5F).y(1, -75).w(0.5F, -60).anchorX(0.5F).row(5);
        scatterBar.add(this.scatterX, this.scatterY);

        this.fireCommand.flex().relative(area).set(10, 0, 0, 20).w(1, -20).y(1F, -30);
        this.delay.flex().relative(scatterBar.resizer()).set(0, 0, 100, 20).x(-10).anchorX(1F);
        this.projectiles.flex().relative(scatterBar.resizer()).set(0, 0, 100, 20).x(1F, 10);
        this.pickDefault.flex().relative(this.delay.resizer()).w(1F).y(-5 - firingOffset);
        this.pickFiring.flex().relative(this.projectiles.resizer()).w(1F).y(-5 - firingOffset);
        this.ammoStack.flex().relative(this.pickFiring.resizer()).x(1F, 5).y(-2);

        GuiElement launchBar = new GuiElement(mc);

        launchBar.flex().relative(scatterBar.resizer()).y(-5 - firingOffset).w(1F).h(11).row(10);
        this.launch.flex().h(20);
        this.useTarget.flex().h(20);
        launchBar.add(this.launch, this.useTarget);

        this.gunOptions.add(scatterBar, launchBar, this.delay, this.projectiles, this.pickDefault, this.pickFiring, this.fireCommand, this.ammoStack);

        /* Projectile options */
        area = this.projectileOptions.area;

        this.pickProjectile = new GuiNestedEdit(mc, (editing) -> this.openMorphs(3, editing));
        this.tickCommand = new GuiTextElement(mc, 10000, (value) -> this.props.tickCommand = value);
        this.ticking = new GuiTrackpadElement(mc, (value) -> this.props.ticking = value.intValue());
        this.ticking.tooltip(IKey.lang("blockbuster.gui.gun.ticking"));
        this.ticking.limit(0, Integer.MAX_VALUE, true);
        this.lifeSpan = new GuiTrackpadElement(mc, (value) -> this.props.lifeSpan = value.intValue());
        this.lifeSpan.tooltip(IKey.lang("blockbuster.gui.gun.life_span"));
        this.lifeSpan.limit(0, Integer.MAX_VALUE, true);
        this.yaw = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.yaw"), false, (b) -> this.props.yaw = b.isToggled());
        this.pitch = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.pitch"), false, (b) -> this.props.pitch = b.isToggled());
        this.sequencer = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.enabled"), false, (b) -> this.props.sequencer = b.isToggled());
        this.random = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.random"), false, (b) -> this.props.random = b.isToggled());
        this.hitboxX = new GuiTrackpadElement(mc, (value) -> this.props.hitboxX = value.floatValue());
        this.hitboxX.tooltip(IKey.lang("blockbuster.gui.gun.hitbox_x"));
        this.hitboxY = new GuiTrackpadElement(mc, (value) -> this.props.hitboxY = value.floatValue());
        this.hitboxY.tooltip(IKey.lang("blockbuster.gui.gun.hitbox_y"));
        this.speed = new GuiTrackpadElement(mc, (value) -> this.props.speed = value.floatValue());
        this.speed.tooltip(IKey.lang("blockbuster.gui.gun.speed"));
        this.friction = new GuiTrackpadElement(mc, (value) -> this.props.friction = value.floatValue());
        this.friction.tooltip(IKey.lang("blockbuster.gui.gun.friction"));
        this.gravity = new GuiTrackpadElement(mc, (value) -> this.props.gravity = value.floatValue());
        this.gravity.tooltip(IKey.lang("blockbuster.gui.gun.gravity"));
        this.fadeIn = new GuiTrackpadElement(mc, (value) -> this.props.fadeIn = value.intValue());
        this.fadeIn.tooltip(IKey.lang("blockbuster.gui.gun.fade_in"));
        this.fadeIn.limit(0, Integer.MAX_VALUE, true);
        this.fadeOut = new GuiTrackpadElement(mc, (value) -> this.props.fadeOut = value.intValue());
        this.fadeOut.tooltip(IKey.lang("blockbuster.gui.gun.fade_out"));
        this.fadeOut.limit(0, Integer.MAX_VALUE, true);

        this.pickProjectile.flex().relative(area).w(100).x(0.75F, -50).y(1, -60);
        this.tickCommand.flex().relative(area).set(10, 0, 0, 20).w(1, -20).y(1, -30);

        GuiElement projectileFields = new GuiElement(mc);

        projectileFields.flex().relative(area).w(1F).h(1F, -40).column(5).width(100).height(20).padding(10);
        projectileFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.category.motion")).background(), this.speed, this.friction, this.gravity);
        projectileFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.category.hitbox")).background().marginTop(12), this.hitboxX, this.hitboxY);
        projectileFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.category.timers")).background().marginTop(12), this.ticking, this.lifeSpan);
        projectileFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.category.rotation")).background().marginTop(12), this.yaw, this.pitch);
        projectileFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.category.transition")).background().marginTop(12), this.fadeIn, this.fadeOut);
        projectileFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.sequencer")).background().marginTop(12), this.sequencer, this.random);
        this.projectileOptions.add(this.pickProjectile, this.tickCommand, projectileFields);

        /* Aim options */
        area = this.aimOptionsSecond.area;

        this.staticRecoil = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.static_recoil"), false, (b) -> this.props.staticRecoil = b.isToggled());
        this.staticRecoil.tooltip(IKey.lang("blockbuster.gui.gun.static_recoil_tooltip"));
        this.recoilXMin = new GuiTrackpadElement(mc, (value) -> this.props.recoilXMin = value.floatValue());
        this.recoilXMin.limit(-200, 200).tooltip(IKey.lang("blockbuster.gui.gun.recoil_min"));
        this.recoilXMax = new GuiTrackpadElement(mc, (value) -> this.props.recoilXMax = value.floatValue());
        this.recoilXMax.limit(-200, 200).tooltip(IKey.lang("blockbuster.gui.gun.recoil_max"));
        this.recoilYMin = new GuiTrackpadElement(mc, (value) -> this.props.recoilYMin = value.floatValue());
        this.recoilYMin.limit(-200, 200).tooltip(IKey.lang("blockbuster.gui.gun.recoil_min"));
        this.recoilYMax = new GuiTrackpadElement(mc, (value) -> this.props.recoilYMax = value.floatValue());
        this.recoilYMax.limit(-200, 200).tooltip(IKey.lang("blockbuster.gui.gun.recoil_max"));

        this.enableArmsShootingPose = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.arm_shooting_pose"), false, (b) -> this.props.enableArmsShootingPose = b.isToggled());
        this.enableArmsShootingPose.tooltip(IKey.lang("blockbuster.gui.gun.arm_shooting_pose_tooltip"));
        this.alwaysArmsShootingPose = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.arm_shooting_pose_always"), false, (b) -> this.props.alwaysArmsShootingPose = b.isToggled());
        this.alwaysArmsShootingPose.tooltip(IKey.lang("blockbuster.gui.gun.arm_shooting_pose_always_tooltip"));

        this.shootOffsetX = new GuiTrackpadElement(mc, (value) -> this.props.shootingOffsetX = value.floatValue());
        this.shootOffsetX.limit(-10, 10);
        this.shootOffsetY = new GuiTrackpadElement(mc, (value) -> this.props.shootingOffsetY = value.floatValue());
        this.shootOffsetY.limit(-10, 10);
        this.shootOffsetZ = new GuiTrackpadElement(mc, (value) -> this.props.shootingOffsetZ = value.floatValue());
        this.shootOffsetZ.limit(-10, 10);

        this.pickCrosshairMorph = new GuiNestedEdit(mc, (editing) -> this.openMorphs(9, editing));
        this.pickInventoryMorph = new GuiNestedEdit(mc, (editing) -> this.openMorphs(7, editing));
        this.pickHandsMorph = new GuiNestedEdit(mc, (editing) -> this.openMorphs(5, editing));
        this.pickReloadMorph = new GuiNestedEdit(mc, (editing) -> this.openMorphs(8, editing));
        this.pickZoomOverlayMorph = new GuiNestedEdit(mc, (editing) -> this.openMorphs(6, editing));

        this.hideCrosshairOnZoom = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.hide_crosshair_on_zoom"), false, (b) -> this.props.hideCrosshairOnZoom = b.isToggled());
        this.useInventoryMorph = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.use_inventory_morph"), false, (b) -> this.props.useInventoryMorph = b.isToggled());
        this.hideHandsOnZoom = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.hide_hands_on_zoom"), false, (b) -> this.props.hideHandsOnZoom = b.isToggled());
        this.useZoomOverlayMorph = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.use_zoom_overlay_morph"), false, (b) -> this.props.useZoomOverlayMorph = b.isToggled());

        this.zoomFactor = new GuiTrackpadElement(mc, (value) -> this.props.zoomFactor = value.floatValue());
        this.zoomFactor.limit(0, 1).increment(0.1).values(0.05, 0.01, 0.1).tooltip(IKey.lang("blockbuster.gui.gun.zoom_factor_tooltip"));
        this.ammo = new GuiTrackpadElement(mc, (value) -> this.props.ammo = value.intValue());
        this.ammo.limit(1).integer().tooltip(IKey.lang("blockbuster.gui.gun.ammo_tooltip"));
        this.useReloading = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.use_reloading"), false, (b) -> this.props.useReloading = b.isToggled());
        this.reloadingTime = new GuiTrackpadElement(mc, (value) -> this.props.reloadingTime = value.intValue());
        this.reloadingTime.limit(0).integer().tooltip(IKey.lang("blockbuster.gui.gun.reloading_time_tooltip"));
        this.shootWhenHeld = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.shoot_when_held"), false, (b) -> this.props.shootWhenHeld = b.isToggled());
        this.shotDelay = new GuiTrackpadElement(mc, (value) -> this.props.shotDelay = value.intValue());
        this.shotDelay.limit(0).integer().tooltip(IKey.lang("blockbuster.gui.gun.shot_delay_tooltip"));

        GuiScrollElement aimFields = new GuiScrollElement(mc, ScrollDirection.HORIZONTAL);

        aimFields.flex().relative(area).wh(1F, 1F).column(5).scroll().width(160).height(20).padding(10);
        aimFields.add(Elements.label(IKey.str("Recoil")).background(), this.staticRecoil);
        aimFields.add(
            Elements.label(IKey.lang("blockbuster.gui.gun.recoil_x")).marginBottom(-2),
            Elements.row(mc, 5, this.recoilXMin, this.recoilXMax)
        );
        aimFields.add(
            Elements.label(IKey.lang("blockbuster.gui.gun.recoil_y")).marginBottom(-2),
            Elements.row(mc, 5, this.recoilYMin, this.recoilYMax)
        );
        aimFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.arm_pose")).background().marginTop(12), this.enableArmsShootingPose, this.alwaysArmsShootingPose);
        aimFields.add(
            Elements.label(IKey.lang("blockbuster.gui.gun.shooting_offset")).background().marginTop(12).tooltip(IKey.lang("blockbuster.gui.gun.shooting_offset_tooltip")),
            this.shootOffsetX, this.shootOffsetY, this.shootOffsetZ.marginBottom(100000)
        );

        aimFields.add(
            Elements.column(mc, 5,
                Elements.label(IKey.lang("blockbuster.gui.gun.crosshair_morph")).background(),
                this.hideCrosshairOnZoom, this.pickCrosshairMorph
            )
        );
        aimFields.add(
            Elements.column(mc, 5,
                Elements.label(IKey.lang("blockbuster.gui.gun.inventory_morph")).background(),
                this.useInventoryMorph, this.pickInventoryMorph
            ).marginTop(12)
        );
        aimFields.add(
            Elements.column(mc, 5,
                Elements.label(IKey.lang("blockbuster.gui.gun.hands_morph")).background(),
                this.hideHandsOnZoom, this.pickHandsMorph
            ).marginTop(12)
        );
        aimFields.add(
            Elements.column(mc, 5,
                Elements.label(IKey.lang("blockbuster.gui.gun.reload_morph")).background(),
                this.pickReloadMorph
            ).marginTop(12)
        );
        aimFields.add(
            Elements.column(mc, 5,
                Elements.label(IKey.lang("blockbuster.gui.gun.overlay_morph")).background(),
                this.useZoomOverlayMorph, this.pickZoomOverlayMorph
            ).marginTop(12).marginBottom(100000)
        );

        aimFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.zoom_factor")).background().marginTop(12), this.zoomFactor);
        aimFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.ammo")).background().marginTop(12), this.ammo);
        aimFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.reloading")).background().marginTop(12), this.useReloading, reloadingTime);
        aimFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.shooting")).background().marginTop(12), this.shootWhenHeld, this.shotDelay);

        this.aimOptionsSecond.add(aimFields);

        /* Aim options 2 */
        area = this.aimOptions.area;

        this.destroyCommand = new GuiTextElement(mc, 10000, (value) -> this.props.destroyCommand = value);
        this.meleeCommand = new GuiTextElement(mc, 10000, (value) -> this.props.meleeCommand = value);
        this.reloadCommand = new GuiTextElement(mc, 10000, (value) -> this.props.reloadCommand = value);
        this.zoomOnCommand = new GuiTextElement(mc, 10000, (value) -> this.props.zoomOnCommand = value);
        this.zoomOffCommand = new GuiTextElement(mc, 10000, (value) -> this.props.zoomOffCommand = value);

        this.meleeDamage = new GuiTrackpadElement(mc, (value) -> this.props.meleeDamage = value.floatValue());
        this.mouseZoom = new GuiTrackpadElement(mc, (value) -> this.props.mouseZoom = value.floatValue());
        this.mouseZoom.limit(0, 1.5F);
        this.durability = new GuiTrackpadElement(mc, (value) -> this.props.durability = value.intValue());
        this.durability.limit(0, Integer.MAX_VALUE, true);
        this.preventLeftClick = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.prevent_left_click"), false, (b) -> this.props.preventLeftClick = b.isToggled());
        this.preventRightClick = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.prevent_right_click"), false, (b) -> this.props.preventRightClick = b.isToggled());
        this.preventEntityAttack = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.prevent_entity_attack"), false, (b) -> this.props.preventEntityAttack = b.isToggled());

        GuiElement aimTwo = Elements.column(mc, 5, 10,
            Elements.label(IKey.lang("blockbuster.gui.gun.melee_damage")).marginTop(5), this.meleeDamage,
            Elements.label(IKey.lang("blockbuster.gui.gun.mouse_zoom")).marginTop(5), this.mouseZoom,
            Elements.label(IKey.lang("blockbuster.gui.gun.durability")).marginTop(5), this.durability,
            this.preventLeftClick,
            this.preventRightClick,
            this.preventEntityAttack
        );

        aimTwo.flex().relative(area).x(1F).y(1F).w(200).anchor(1F, 1F);

        GuiElement aimCommands = Elements.column(mc, 3, 10,
            Elements.label(IKey.lang("blockbuster.gui.gun.destroyed_command")), this.destroyCommand,
            Elements.label(IKey.lang("blockbuster.gui.gun.melee_command")).marginTop(5), this.meleeCommand,
            Elements.label(IKey.lang("blockbuster.gui.gun.reload_command")).marginTop(5), this.reloadCommand,
            Elements.label(IKey.lang("blockbuster.gui.gun.zoom_on_command")).marginTop(5), this.zoomOnCommand,
            Elements.label(IKey.lang("blockbuster.gui.gun.zoom_off_command")).marginTop(5), this.zoomOffCommand
        );

        aimCommands.flex().relative(area).y(1F).wTo(aimTwo.area, 10).anchorY(1F);

        this.aimOptions.add(aimTwo, aimCommands);

        /* Impact options */
        area = this.impactOptions.area;

        this.pickImpact = new GuiNestedEdit(mc, (editing) -> this.openMorphs(4, editing));
        this.impactDelay = new GuiTrackpadElement(mc, (value) -> this.props.impactDelay = value.intValue());
        this.impactDelay.limit(0, Integer.MAX_VALUE, true);
        this.impactCommand = new GuiTextElement(mc, 10000, (value) -> this.props.impactCommand = value);
        this.impactEntityCommand = new GuiTextElement(mc, 10000, (value) -> this.props.impactEntityCommand = value);
        this.vanish = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.enabled"), false, (b) -> this.props.vanish = b.isToggled());
        this.bounce = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.enabled"), false, (b) -> this.props.bounce = b.isToggled());
        this.sticks = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.enabled"), false, (b) -> this.props.sticks = b.isToggled());
        this.hits = new GuiTrackpadElement(mc, (value) -> this.props.hits = value.intValue());
        this.hits.tooltip(IKey.lang("blockbuster.gui.gun.hits"));
        this.hits.limit(0, Integer.MAX_VALUE, true);
        this.damage = new GuiTrackpadElement(mc, (value) -> this.props.damage = value.floatValue());
        this.knockbackHorizontal = new GuiTrackpadElement(mc, (value) -> this.props.knockbackHorizontal = value.floatValue());
        this.knockbackHorizontal.tooltip(IKey.lang("blockbuster.gui.gun.knockback_horizontal"));
        this.knockbackVertical = new GuiTrackpadElement(mc, (value) -> this.props.knockbackVertical = value.floatValue());
        this.knockbackVertical.tooltip(IKey.lang("blockbuster.gui.gun.knockback_vertical"));
        this.bounceFactor = new GuiTrackpadElement(mc, (value) -> this.props.bounceFactor = value.floatValue());
        this.bounceFactor.tooltip(IKey.lang("blockbuster.gui.gun.bounce_factor"));
        this.vanishCommand = new GuiTextElement(mc, 10000, (value) -> this.props.vanishCommand = value);
        this.vanishDelay = new GuiTrackpadElement(mc, (value) -> this.props.vanishDelay = value.intValue());
        this.vanishDelay.limit(0).integer().tooltip(IKey.lang("blockbuster.gui.gun.vanish_delay"));
        this.penetration = new GuiTrackpadElement(mc, (value) -> this.props.penetration = value.floatValue());
        this.penetration.block().tooltip(IKey.lang("blockbuster.gui.gun.penetration"));
        this.ignoreBlocks = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.ignore_blocks"), false, (b) -> this.props.ignoreBlocks = b.isToggled());
        this.ignoreBlocks.tooltip(IKey.lang("blockbuster.gui.gun.ignore_blocks_tooltip"));
        this.ignoreEntities = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.ignore_entities"), false, (b) -> this.props.ignoreEntities = b.isToggled());
        this.ignoreEntities.tooltip(IKey.lang("blockbuster.gui.gun.ignore_entities_tooltip"));

        this.pickImpact.flex().relative(area).w(100).x(0.75F, -40).y(1, -140);
        this.vanishCommand.flex().relative(area).set(10, 0, 0, 20).w(1, -20).y(1, -110);
        this.impactEntityCommand.flex().relative(this.vanishCommand).y(40).w(1F).h(20);
        this.impactCommand.flex().relative(this.impactEntityCommand).y(40).w(1F).h(20);

        GuiElement impactFields = new GuiElement(mc);

        impactFields.flex().relative(area).w(1F).h(1F, -120).column(5).width(100).height(20).padding(10);
        impactFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.impact_delay")).background(), this.impactDelay);
        impactFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.damage")).background().marginTop(12), this.damage, this.knockbackHorizontal, this.knockbackVertical);
        impactFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.bounce")).background().marginTop(12), this.bounce, this.hits, this.bounceFactor);
        impactFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.vanish")).background().marginTop(12), this.vanish, this.vanishDelay);
        impactFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.sticks")).background().marginTop(12), this.sticks, this.penetration);
        impactFields.add(Elements.label(IKey.lang("blockbuster.gui.gun.collision")).background().marginTop(12), this.ignoreBlocks, this.ignoreEntities);

        this.impactOptions.add(this.pickImpact, this.vanishCommand, this.impactEntityCommand, this.impactCommand, impactFields);

        /* Gun transforms */
        area = this.transformOptions.area;

        this.gun = new GuiPoseTransformations(mc);
        this.projectile = new GuiPoseTransformations(mc);

        this.arms = new GuiMorphRenderer(mc);
        this.arms.setRotation(61, -13);
        this.arms.setPosition(0.1048045F, 1.081198F, 0.22774392F);
        this.arms.setScale(1.5F);

        try
        {
            this.arms.morph = MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson("{Name:\"blockbuster.fred\"}"));
            this.arms.getEntity().setItemStackToSlot(EntityEquipmentSlot.MAINHAND, stack);
        }
        catch (Exception e)
        {}

        this.bullet = new GuiProjectileModelRenderer(mc);
        this.bullet.projectile.props = this.props;
        this.bullet.projectile.morph.setDirect(this.props.projectileMorph);

        this.bullet.setRotation(-64, 16);
        this.bullet.setPosition(-0.042806394F, 0.40452564F, -0.001203875F);
        this.bullet.setScale(2.5F);

        this.gun.flex().relative(area).x(0.25F, -95).y(1, -80).wh(190, 70);
        this.projectile.flex().relative(area).x(0.75F, -95).y(1, -80).wh(190, 70);
        this.arms.flex().relative(area).wTo(this.bullet.flex()).h(1F);
        this.bullet.flex().relative(area).x(0.5F).wh(0.5F, 1F);

        this.transformOptions.add(this.arms, this.bullet, this.gun, this.projectile);

        /* Gun transforms (first person) */
        area = this.transformFirstPersonOptions.area;

        this.gunFirstPerson = new GuiPoseTransformations(mc);
        this.gunFirstPerson.flex().relative(area).x(0.5F).y(1, -80).wh(190, 70).anchorX(0.5F);

        this.transformFirstPersonOptions.add(this.gunFirstPerson);

        /* Placement of the elements */
        this.morphs.flex().relative(this.viewport).wh(1F, 1F);
        this.panel.flex().relative(this.viewport).set(0, 35, 0, 0).w(1, 0).h(1, -35);

        /* Gun properties */
        this.pickDefault.setMorph(this.props.defaultMorph);
        this.pickHandsMorph.setMorph(this.props.handsMorph);
        this.pickInventoryMorph.setMorph(this.props.inventoryMorph);
        this.pickReloadMorph.setMorph(this.props.reloadMorph);
        this.pickZoomOverlayMorph.setMorph(this.props.zoomOverlayMorph);
        this.pickFiring.setMorph(this.props.firingMorph);
        this.pickCrosshairMorph.setMorph(this.props.crosshairMorph);
        this.fireCommand.setText(this.props.fireCommand);
        this.delay.setValue(this.props.delay);
        this.projectiles.setValue(this.props.projectiles);
        this.zoomFactor.setValue(this.props.zoomFactor);
        this.recoilXMin.setValue(this.props.recoilXMin);
        this.recoilXMax.setValue(this.props.recoilXMax);
        this.shootOffsetX.setValue(this.props.shootingOffsetX);
        this.shootOffsetY.setValue(this.props.shootingOffsetY);
        this.durability.setValue(this.props.durability);
        this.mouseZoom.setValue(this.props.mouseZoom);
        this.shootOffsetZ.setValue(this.props.shootingOffsetZ);
        this.recoilYMin.setValue(this.props.recoilYMin);
        this.meleeDamage.setValue(this.props.meleeDamage);
        this.ammo.setValue(this.props.ammo);
        this.reloadingTime.setValue(this.props.reloadingTime);
        this.recoilYMax.setValue(this.props.recoilYMax);
        this.shotDelay.setValue(this.props.shotDelay);
        this.staticRecoil.toggled(this.props.staticRecoil);
        this.scatterX.setValue(this.props.scatterX);
        this.scatterY.setValue(this.props.scatterY);
        this.launch.toggled(this.props.launch);
        this.useTarget.toggled(this.props.useTarget);
        this.ammoStack.setStack(this.props.ammoStack);
        this.reloadCommand.setText(this.props.reloadCommand);
        this.meleeCommand.setText(this.props.meleeCommand);
        this.destroyCommand.setText(this.props.destroyCommand);
        this.meleeCommand.setText(this.props.meleeCommand);
        this.destroyCommand.setText(this.props.destroyCommand);
        this.zoomOnCommand.setText(this.props.zoomOnCommand);
        this.zoomOffCommand.setText(this.props.zoomOffCommand);

        this.useZoomOverlayMorph.toggled(this.props.useZoomOverlayMorph);
        this.hideHandsOnZoom.toggled(this.props.hideHandsOnZoom);
        this.hideCrosshairOnZoom.toggled(this.props.hideCrosshairOnZoom);
        this.enableArmsShootingPose.toggled(this.props.enableArmsShootingPose);
        this.preventRightClick.toggled(this.props.preventRightClick);
        this.preventLeftClick.toggled(this.props.preventLeftClick);
        this.preventEntityAttack.toggled(this.props.preventEntityAttack);
        this.useInventoryMorph.toggled(this.props.useInventoryMorph);
        this.useReloading.toggled(this.props.useReloading);
        this.alwaysArmsShootingPose.toggled(this.props.alwaysArmsShootingPose);
        this.shootWhenHeld.toggled(this.props.shootWhenHeld);

        /* Projectile properties */
        this.pickProjectile.setMorph(this.props.projectileMorph);
        this.tickCommand.setText(this.props.tickCommand);
        this.ticking.setValue(this.props.ticking);
        this.lifeSpan.setValue(this.props.lifeSpan);
        this.yaw.toggled(this.props.yaw);
        this.pitch.toggled(this.props.pitch);
        this.sequencer.toggled(this.props.sequencer);
        this.random.toggled(this.props.random);
        this.hitboxX.setValue(this.props.hitboxX);
        this.hitboxY.setValue(this.props.hitboxY);
        this.speed.setValue(this.props.speed);
        this.friction.setValue(this.props.friction);
        this.gravity.setValue(this.props.gravity);
        this.fadeIn.setValue(this.props.fadeIn);
        this.fadeOut.setValue(this.props.fadeOut);

        /* Impact properties */
        this.pickImpact.setMorph(this.props.impactMorph);
        this.impactCommand.setText(this.props.impactCommand);
        this.impactEntityCommand.setText(this.props.impactEntityCommand);
        this.impactDelay.setValue(this.props.impactDelay);
        this.vanish.toggled(this.props.vanish);
        this.bounce.toggled(this.props.bounce);
        this.sticks.toggled(this.props.sticks);
        this.hits.setValue(this.props.hits);
        this.damage.setValue(this.props.damage);
        this.knockbackHorizontal.setValue(this.props.knockbackHorizontal);
        this.knockbackVertical.setValue(this.props.knockbackVertical);
        this.bounceFactor.setValue(this.props.bounceFactor);
        this.vanishCommand.setText(this.props.vanishCommand);
        this.vanishDelay.setValue(this.props.vanishDelay);
        this.penetration.setValue(this.props.penetration);
        this.ignoreBlocks.toggled(this.props.ignoreBlocks);
        this.ignoreEntities.toggled(this.props.ignoreEntities);

        /* Gun transforms */
        this.gun.set(this.props.gunTransform);
        this.gunFirstPerson.set(this.props.gunTransformFirstPerson);
        this.projectile.set(this.props.projectileTransform);

        this.root.add(this.panel);
        this.root.keys().register(IKey.lang("blockbuster.gui.gun.keys.cycle"), Keyboard.KEY_TAB, this::cycle);
    }


    private void pickItem(ItemStack stack)
    {
        this.props.ammoStack = stack;
    }

    protected void cycle()
    {
        int index = -1;

        for (int i = 0; i < this.panel.panels.size(); i++)
        {
            if (this.panel.view.delegate == this.panel.panels.get(i))
            {
                index = i;

                break;
            }
        }

        index += GuiScreen.isShiftKeyDown() ? 1 : -1;
        index = MathUtils.cycler(index, 0, this.panel.panels.size() - 1);

        this.panel.buttons.elements.get(index).clickItself(GuiBase.getCurrent());
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return false;
    }

    private void openMorphs(int i, boolean editing)
    {
        AbstractMorph morph = this.props.defaultMorph;

        if (i == 2)
        {
            morph = this.props.firingMorph;
        }
        else if (i == 3)
        {
            morph = this.props.projectileMorph;
        }
        else if (i == 4)
        {
            morph = this.props.impactMorph;
        }
        else if (i == 5)
        {
            morph = this.props.handsMorph;
        }
        else if (i == 6)
        {
            morph = this.props.zoomOverlayMorph;
        }
        else if (i == 7)
        {
            morph = this.props.inventoryMorph;
        }
        else if (i == 8)
        {
            morph = this.props.reloadMorph;
        }
        else if (i == 9)
        {
            morph = this.props.crosshairMorph;
        }

        if (this.morphs.hasParent())
        {
            if (i == this.index)
            {
                return;
            }
            else
            {
                this.morphs.finish();
                this.morphs.removeFromParent();
            }
        }

        this.index = i;
        this.morphs.resize();
        this.morphs.setSelected(morph);

        if (editing)
        {
            this.morphs.enterEditMorph();
        }

        this.root.add(this.morphs);
    }

    private void setMorph(AbstractMorph morph)
    {
        if (this.index == 1)
        {
            this.props.defaultMorph = morph;
            this.props.setCurrent(MorphUtils.copy(morph));
            this.pickDefault.setMorph(morph);
        }
        else if (this.index == 2)
        {
            this.props.firingMorph = morph;
            this.pickFiring.setMorph(morph);
        }
        else if (this.index == 3)
        {
            this.props.projectileMorph = morph;
            this.pickProjectile.setMorph(morph);
            this.bullet.projectile.morph.setDirect(this.props.projectileMorph);
        }
        else if (this.index == 4)
        {
            this.props.impactMorph = morph;

            this.pickImpact.setMorph(morph);
        }
        else if (this.index == 5)
        {
            this.props.handsMorph = morph;
            this.props.setHandsMorph(MorphUtils.copy(morph));
            this.pickHandsMorph.setMorph(morph);
        }
        else if (this.index == 6)
        {
            this.props.zoomOverlayMorph = morph;
            this.props.setCurrentZoomOverlay(MorphUtils.copy(morph));
            this.pickZoomOverlayMorph.setMorph(morph);
        }
        else if (this.index == 7)
        {
            this.props.inventoryMorph = morph;
            this.props.setInventoryMorph(MorphUtils.copy(morph));
            this.pickInventoryMorph.setMorph(morph);

        }
        else if (this.index == 8)
        {
            this.props.reloadMorph = morph;
            this.pickReloadMorph.setMorph(morph);

        }
        else if (this.index == 9)
        {
            this.props.crosshairMorph = morph;
            this.props.setCrosshairMorph(MorphUtils.copy(morph));
            this.pickCrosshairMorph.setMorph(morph);
        }
    }

    @Override
    protected void closeScreen()
    {
        super.closeScreen();

        this.props.storedDurability = (int) this.durability.value;

        Dispatcher.sendToServer(new PacketGunInfo(this.props.toNBT(), 0));
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        GuiDraw.drawCustomBackground(0, 0, this.width, this.height);

        Gui.drawRect(0, 0, this.width, 35, ColorUtils.HALF_BLACK);
        this.drawGradientRect(0, 35, this.width, 45, ColorUtils.HALF_BLACK, 0);
        this.fontRenderer.drawStringWithShadow(I18n.format("blockbuster.gui.gun.title"), 10, 15, 0xffffffff);

        EntityPlayer player = this.mc.player;
        int w = this.viewport.w / 4;

        if (this.panel.view.delegate == this.gunOptions)
        {
            if (this.props.defaultMorph != null)
            {
                this.props.defaultMorph.renderOnScreen(player, this.pickDefault.area.mx(), this.pickDefault.area.y - 20, w * 0.5F, 1);
            }
            if (this.props.firingMorph != null)
            {
                this.props.firingMorph.renderOnScreen(player, this.pickFiring.area.mx(), this.pickFiring.area.y - 20, w * 0.5F, 1);

                GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);
            }

            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.default_morph"), this.pickDefault.area.mx(), this.pickFiring.area.y - 12, 0xffffff);
            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.fire_morph"), this.pickFiring.area.mx(), this.pickFiring.area.y - 12, 0xffffff);
            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.delay"), this.delay.area.mx(), this.delay.area.y - 12, 0xffffff);
            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.scatter"), this.scatterX.area.ex() + 3, this.scatterX.area.y - 12, 0xffffff);
            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.projectiles"), this.projectiles.area.mx(), this.projectiles.area.y - 12, 0xffffff);

            this.fontRenderer.drawStringWithShadow(I18n.format("blockbuster.gui.gun.fire_command"), this.fireCommand.area.x, this.fireCommand.area.y - 12, 0xffffff);
        }
        else if (this.panel.view.delegate == this.projectileOptions)
        {
            if (this.props.projectileMorph != null)
            {
                this.props.projectileMorph.renderOnScreen(player, this.pickProjectile.area.mx(), this.pickProjectile.area.y - 20, w * 0.5F, 1);
            }

            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.projectile_morph"), this.pickProjectile.area.mx(), this.pickProjectile.area.y - 12, 0xffffff);

            this.fontRenderer.drawStringWithShadow(I18n.format("blockbuster.gui.gun.tick_command"), this.tickCommand.area.x, this.tickCommand.area.y - 12, 0xffffff);
        }
        else if (this.panel.view.delegate == this.impactOptions)
        {
            if (this.props.impactMorph != null)
            {
                this.props.impactMorph.renderOnScreen(player, this.pickImpact.area.mx(), this.pickImpact.area.y - 20, w * 0.5F, 1);
            }

            this.drawCenteredString(this.fontRenderer, I18n.format("blockbuster.gui.gun.impact_morph"), this.pickImpact.area.mx(), this.pickImpact.area.y - 12, 0xffffff);

            this.fontRenderer.drawStringWithShadow(I18n.format("blockbuster.gui.gun.impact_command"), this.impactCommand.area.x, this.impactCommand.area.y - 12, 0xffffff);
            this.fontRenderer.drawStringWithShadow(I18n.format("blockbuster.gui.gun.impact_entity_command"), this.impactEntityCommand.area.x, this.impactEntityCommand.area.y - 12, 0xffffff);
            this.fontRenderer.drawStringWithShadow(I18n.format("blockbuster.gui.gun.vanish_command"), this.vanishCommand.area.x, this.vanishCommand.area.y - 12, 0xffffff);
        }

        super.drawScreen(mouseX, mouseY, partialTicks);

        if (this.panel.view.delegate == this.transformOptions)
        {
            String gun = I18n.format("blockbuster.gui.gun.gun_transforms");
            String trans = I18n.format("blockbuster.gui.gun.projectile_transforms");

            GuiDraw.drawTextBackground(this.context.font, gun, this.gun.area.mx(this.context.font.getStringWidth(gun)), this.arms.area.y + 15, 0xffffff, ColorUtils.HALF_BLACK);
            GuiDraw.drawTextBackground(this.context.font, trans, this.projectile.area.mx(this.context.font.getStringWidth(trans)), this.arms.area.y + 15, 0xffffff, ColorUtils.HALF_BLACK);
        }
    }

    public static class GuiProjectileModelRenderer extends GuiModelRenderer
    {
        public EntityGunProjectile projectile;

        public GuiProjectileModelRenderer(Minecraft mc)
        {
            super(mc);

            this.projectile = new EntityGunProjectile(mc.world);
        }

        @Override
        protected void drawUserModel(GuiContext context)
        {
            this.projectile.ticksExisted = this.projectile.props.fadeIn;
            this.mc.getRenderManager().renderEntity(this.projectile, 0, 0.5F, 0, 0, context.partialTicks, false);

            GlStateManager.disableTexture2D();
            GlStateManager.disableLighting();
            GlStateManager.disableDepth();

            GlStateManager.pushMatrix();
            GlStateManager.translate(0, 0.5F, 0);

            GL11.glLineWidth(5);
            GL11.glBegin(GL11.GL_LINES);
            GL11.glColor3d(0, 0, 0);
            GL11.glVertex3d(0, 0, 0);
            GL11.glVertex3d(0, 0, 0.25);
            GL11.glEnd();

            GL11.glLineWidth(3);
            GL11.glBegin(GL11.GL_LINES);
            GL11.glColor3d(0, 1, 0);
            GL11.glVertex3d(0, 0, 0);
            GL11.glVertex3d(0, 0, 0.25);
            GL11.glEnd();
            GL11.glLineWidth(1);

            GL11.glPointSize(12);
            GL11.glBegin(GL11.GL_POINTS);
            GL11.glColor3d(0, 0, 0);
            GL11.glVertex3d(0, 0, 0);
            GL11.glEnd();

            GL11.glPointSize(10);
            GL11.glBegin(GL11.GL_POINTS);
            GL11.glColor3d(1, 1, 1);
            GL11.glVertex3d(0, 0, 0);
            GL11.glEnd();
            GL11.glPointSize(1);

            GlStateManager.popMatrix();

            GlStateManager.enableDepth();
            GlStateManager.enableLighting();
            GlStateManager.enableTexture2D();
        }
    }

    public static class GuiGunPanels extends GuiPanelBase<GuiElement>
    {
        public GuiGunPanels(Minecraft mc)
        {
            super(mc);
        }

        @Override
        protected void drawBackground(GuiContext context, int x, int y, int w, int h)
        {
            Gui.drawRect(x, y, x + w, y + h, 0xff080808);
        }
    }
}

==================================================

--- Файл №81 ---
Путь: main\java\mchorse\blockbuster\client\gui\GuiImmersiveEditor.java
--------------------
package mchorse.blockbuster.client.gui;

import java.util.List;
import java.util.function.Consumer;

import org.lwjgl.input.Keyboard;

import com.google.common.collect.ImmutableList;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IGuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.EntityUtils;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.world.GameType;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Immersive Editor
 * 
 * This editor allows you to edit morphs in the game world
 */
@SideOnly(Side.CLIENT)
public class GuiImmersiveEditor extends GuiBase
{
    public static final IKey CATEGORY = IKey.lang("blockbuster.gui.immersive_editor.keys.category");

    public GuiImmersiveMorphMenu morphs;
    public GuiOuterScreen outerPanel;

    public GuiScreen lastScreen;
    public int lastTPS;
    public GameType lastMode;

    public double lastPosX;
    public double lastPosY;
    public double lastPosZ;
    public float lastRotPitch;
    public float lastRotYaw;

    public Consumer<GuiImmersiveEditor> onClose;

    public GuiImmersiveEditor(Minecraft mc)
    {
        this.mc = mc;

        this.morphs = new GuiImmersiveMorphMenu(mc);
        this.morphs.flex().relative(this.viewport).xy(0F, 0F).wh(1F, 1F);

        this.outerPanel = new GuiOuterScreen(mc);
        this.outerPanel.flex().relative(this.viewport).xy(0F, 0F).wh(1F, 1F);

        this.root.add(morphs, this.outerPanel);

        this.root.keys().register(IKey.lang("blockbuster.gui.immersive_editor.keys.toggle_outer_panel"), Keyboard.KEY_F1, () -> this.outerPanel.toggleVisible())
            .category(CATEGORY).active(() -> !this.outerPanel.getChildren().isEmpty());
    }

    public void show()
    {
        this.lastScreen = this.mc.currentScreen;
        this.lastTPS = this.mc.gameSettings.thirdPersonView;
        this.lastMode = EntityUtils.getGameMode();

        this.lastPosX = this.mc.player.posX;
        this.lastPosY = this.mc.player.posY;
        this.lastPosZ = this.mc.player.posZ;
        this.lastRotPitch = this.mc.player.rotationPitch;
        this.lastRotYaw = this.mc.player.rotationYaw;

        this.mc.currentScreen = this;
        ScaledResolution scaledresolution = new ScaledResolution(this.mc);
        int i = scaledresolution.getScaledWidth();
        int j = scaledresolution.getScaledHeight();
        this.setWorldAndResolution(this.mc, i, j);

        this.morphs.reload();
        this.morphs.resize();
        this.morphs.setVisible(true);
        this.outerPanel.setVisible(false);

        this.mc.gameSettings.thirdPersonView = 0;
        this.mc.setRenderViewEntity(this.mc.player);

        if (this.lastMode != GameType.SPECTATOR)
        {
            this.mc.player.sendChatMessage("/gamemode 3");
        }

        MinecraftForge.EVENT_BUS.register(this.morphs);
    }

    @Override
    public void onGuiClosed()
    {
        this.closeScreen();

        this.lastScreen.onGuiClosed();
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return false;
    }

    @Override
    protected void closeScreen()
    {
        if (this.lastScreen == null)
        {
            return;
        }

        this.morphs.finish();

        this.mc.currentScreen = this.lastScreen;
        ScaledResolution scaledresolution = new ScaledResolution(this.mc);
        int i = scaledresolution.getScaledWidth();
        int j = scaledresolution.getScaledHeight();
        this.lastScreen.setWorldAndResolution(this.mc, i, j);

        this.mc.gameSettings.thirdPersonView = this.lastTPS;
        /* if the server connection is terminated unexpectedly,
         it seems to happen that player is null before screen is closed */
        if (this.mc.player != null) {
            this.mc.player.sendChatMessage("/gamemode " + this.lastMode.getID());
            this.mc.player.setPositionAndRotation(this.lastPosX, this.lastPosY, this.lastPosZ, this.lastRotYaw, this.lastRotPitch);
        }

        this.lastScreen = null;
        MinecraftForge.EVENT_BUS.unregister(this.morphs);

        if (this.onClose != null)
        {
            this.onClose.accept(this);
            this.onClose = null;
        }

        this.morphs.setVisible(false);
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        if (!this.morphs.isImmersionMode())
        {
            GuiDraw.drawCustomBackground(0, 0, this.width, this.height);
        }

        super.drawScreen(mouseX, mouseY, partialTicks);
    }

    public static class GuiOuterScreen extends GuiElement
    {
        public GuiOuterScreen(Minecraft mc)
        {
            super(mc);
        }

        @Override
        public boolean mouseClicked(GuiContext context)
        {
            List<IGuiElement> list = ImmutableList.copyOf(this.getChildren());

            for (int i = list.size() - 1; i >= 0; i--)
            {
                IGuiElement element = list.get(i);

                if (element.isEnabled() && element.mouseClicked(context))
                {
                    return true;
                }
            }

            return false;
        }

        @Override
        public boolean mouseScrolled(GuiContext context)
        {
            List<IGuiElement> list = ImmutableList.copyOf(this.getChildren());

            for (int i = list.size() - 1; i >= 0; i--)
            {
                IGuiElement element = list.get(i);

                if (element.isEnabled() && element.mouseScrolled(context))
                {
                    return true;
                }
            }

            return false;
        }

        @Override
        public void mouseReleased(GuiContext context)
        {
            List<IGuiElement> list = ImmutableList.copyOf(this.getChildren());

            for (int i = list.size() - 1; i >= 0; i--)
            {
                IGuiElement element = list.get(i);

                if (element.isEnabled())
                {
                    element.mouseReleased(context);
                }
            }
        }

        @Override
        public void draw(GuiContext context)
        {
            GuiDraw.drawCustomBackground(this.area.x, this.area.y, this.area.ex(), this.area.ey());

            super.draw(context);

            GuiDraw.drawTextBackground(this.font, IKey.lang("blockbuster.gui.immersive_editor.hide_outer_panel").get(), this.area.x + 5, this.area.y + 5, 0xFFFFFF, 0);
        }
    }
}


==================================================

--- Файл №82 ---
Путь: main\java\mchorse\blockbuster\client\gui\GuiImmersiveMorphMenu.java
--------------------
package mchorse.blockbuster.client.gui;

import java.util.Stack;
import java.util.function.Consumer;
import java.util.function.Function;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;

import org.lwjgl.input.Keyboard;

import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster_pack.client.gui.GuiSequencerMorph.GuiSequencerMorphRenderer;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.EntityUtils;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsMenu;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.client.event.EntityViewRenderEvent.FOVModifier;
import net.minecraftforge.client.event.EntityViewRenderEvent;
import net.minecraftforge.client.event.RenderGameOverlayEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.Phase;
import net.minecraftforge.fml.common.gameevent.TickEvent.RenderTickEvent;

/**
 * Immersive morph menu
 * 
 * It is the actual executor that synchronizes the model editing process to the game world
 */
public class GuiImmersiveMorphMenu extends GuiCreativeMorphsMenu
{
    public boolean immersionMode = true;
    public EntityLivingBase target;
    public Consumer<GuiImmersiveMorphMenu> updateCallback;
    public boolean hideGuiModel = true;

    public Function<Integer, Frame> frameProvider;

    public Consumer<GuiContext> beforeRender;
    public Consumer<GuiContext> afterRender;

    private PreviewMorph preview = new PreviewMorph();
    private AbstractMorph lastMorph;

    private Stack<Boolean> stack = new Stack<>();

    public GuiImmersiveMorphMenu(Minecraft mc)
    {
        super(mc, true, null);

        GuiButtonElement close = new GuiButtonElement(mc, IKey.str("X"), (b) -> this.exit());
        close.flex().w(20);

        this.bar.add(close);

        this.keys().register(IKey.lang("blockbuster.gui.morphs.keys.toggle_gui_model"), Keyboard.KEY_F3, () -> this.hideGuiModel = !this.hideGuiModel)
            .category(GuiImmersiveEditor.CATEGORY).active(() -> this.isImmersionMode());
    }

    @Override
    public void nestEdit(AbstractMorph selected, boolean editing, boolean keepViewport, Consumer<AbstractMorph> callback)
    {
        this.stack.add(this.immersionMode);
        this.immersionMode &= keepViewport;

        super.nestEdit(selected, editing, keepViewport, callback);
    }

    @Override
    public void restoreEdit()
    {
        super.restoreEdit();

        this.immersionMode = this.stack.pop();
    }

    @Override
    public void exit()
    {
        if (this.isEditMode() || this.isNested())
        {
            if (this.isEditMode())
            {
                this.editor.delegate.renderer.fov = 70F;
            }

            super.exit();
        }
        else
        {
            ((GuiImmersiveEditor) mc.currentScreen).closeThisScreen();
        }
    }

    @Override
    public void finish()
    {
        super.finish();

        this.frameProvider = null;
        this.beforeRender = null;
        this.afterRender = null;

        this.pickMorph(getSelected());
    }

    @Override
    public void draw(GuiContext context)
    {
        if (!this.isImmersionMode())
        {
            Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), 0x33000000);
        }

        if (this.isEditMode())
        {
            this.refreshImmersive();
        }

        super.draw(context);
    }

    @Override
    protected void beforeRenderModel(GuiContext context)
    {
        super.beforeRenderModel(context);

        if (this.isImmersionMode() && this.beforeRender != null)
        {
            this.beforeRender.accept(context);
        }
    }

    @Override
    protected void afterRenderModel(GuiContext context)
    {
        super.afterRenderModel(context);

        if (this.isImmersionMode() && this.afterRender != null)
        {
            this.afterRender.accept(context);
        }
    }

    public Frame getFrame(int tick)
    {
        if (this.frameProvider != null && !this.isNested())
        {
            return this.frameProvider.apply(tick);
        }
        else
        {
            return null;
        }
    }

    @SubscribeEvent
    public void onRenderTick(RenderTickEvent event)
    {
        if (this.isEditMode() && this.immersionMode && event.phase == Phase.START)
        {
            this.preview.renderComplete = false;

            if (this.updateCallback != null)
            {
                this.updateCallback.accept(this);
            }
        }

        if (this.isImmersionMode())
        {
            if (event.phase == Phase.START)
            {
                this.lastMorph = EntityUtils.getMorph(this.target);

                if (this.target instanceof EntityActor)
                {
                    ((EntityActor) this.target).morph.setDirect(this.preview);
                }
                else if (this.target instanceof EntityPlayer)
                {
                    MorphAPI.morph((EntityPlayer) this.target, this.preview, true);
                }

                GuiModelRenderer renderer = this.editor.delegate.renderer;

                Vector3f temp = new Vector3f(renderer.pos);
                Vector3f vec = new Vector3f();
                vec.set(0.0F, 0.0F, (renderer.flight ? 0F : -renderer.scale) - 0.05F);

                renderer.pitch = MathUtils.clamp(renderer.pitch, -90F, 90F);

                Matrix4f mat = new Matrix4f();
                mat.rotX(renderer.pitch / 180.0F * 3.1415927F);
                mat.transform(vec);
                mat.rotY((180.0F - renderer.yaw) / 180.0F * 3.1415927F);
                mat.transform(vec);

                temp.x += vec.x;
                temp.y += vec.y;
                temp.z += vec.z;

                mat.rotY(-target.rotationYaw / 180.0F * 3.1415927F);
                mat.transform(temp);

                temp.x += this.target.posX;
                temp.y += this.target.posY;
                temp.z += this.target.posZ;

                EntityPlayer camera = this.mc.player;
                camera.setPositionAndRotation(temp.x, Math.max(temp.y - camera.getEyeHeight(), -64.0), temp.z, renderer.yaw + target.rotationYaw + 180, renderer.pitch);
                camera.setLocationAndAngles(temp.x, Math.max(temp.y - camera.getEyeHeight(), -64.0), temp.z, renderer.yaw + target.rotationYaw + 180, renderer.pitch);
                camera.motionX = camera.motionY = camera.motionZ = 0;
            }
            else
            {
                if (this.target instanceof EntityActor)
                {
                    ((EntityActor) this.target).morph.setDirect(this.lastMorph);
                }
                else if (this.target instanceof EntityPlayer)
                {
                    MorphAPI.morph((EntityPlayer) this.target, this.lastMorph, true);
                }
            }
        }
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onFovModifierEvent(FOVModifier event)
    {
        if (this.isImmersionMode())
        {
            event.setFOV(this.editor.delegate.renderer.fov);
        }
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onCameraOrient(EntityViewRenderEvent.CameraSetup event)
    {
        if (this.isImmersionMode())
        {
            event.setRoll(0F);
        }
    }

    @SubscribeEvent
    public void onRenderGameOverlayEvent(RenderGameOverlayEvent event)
    {
        event.setCanceled(true);
    }

    public void refreshImmersive()
    {
        GuiModelRenderer renderer = this.editor.delegate.renderer;

        renderer.hideModel = this.isImmersionMode() && this.preview.renderComplete && this.hideGuiModel && (!this.doRenderOnionSkin || !this.haveOnionSkin());
        renderer.customEntity = this.isImmersionMode();
        renderer.fullScreen = this.isImmersionMode();

        if (renderer.customEntity)
        {
            renderer.entityPitch = this.target.rotationPitch;
            renderer.entityYawHead = this.target.rotationYawHead - this.target.rotationYaw;
            renderer.entityYawBody = this.target.renderYawOffset - this.target.rotationYaw;
            renderer.entityTicksExisted = this.target.ticksExisted;
        }
    }

    public boolean isImmersionMode()
    {
        return this.isEditMode() && this.immersionMode && this.target != null;
    }

    public class PreviewMorph extends AbstractMorph
    {
        public boolean renderComplete;

        @Override
        public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
        {}

        @Override
        public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
        {
            this.renderComplete = true;

            GuiImmersiveMorphMenu menu = GuiImmersiveMorphMenu.this;
            AbstractMorph morph = menu.editor.delegate.morph;
            GuiModelRenderer renderer = menu.editor.delegate.renderer;

            if (renderer instanceof GuiSequencerMorphRenderer)
            {
                GuiContext context = GuiBase.getCurrent();

                context.partialTicks = GuiImmersiveMorphMenu.this.mc.getRenderPartialTicks();
                ((GuiSequencerMorphRenderer) renderer).doRender(GuiBase.getCurrent(), entity, x, y, z);

                morph = null;
            }
            else if (renderer instanceof GuiMorphRenderer)
            {
                morph = ((GuiMorphRenderer) renderer).morph;
            }

            if (morph != null)
            {
                MorphUtils.render(morph, entity, x, y, z, entityYaw, partialTicks);
            }
        }

        @Override
        public AbstractMorph create()
        {
            return null;
        }

        @Override
        public float getWidth(EntityLivingBase target)
        {
            return 0;
        }

        @Override
        public float getHeight(EntityLivingBase target)
        {
            return 0;
        }
    }
}


==================================================

--- Файл №83 ---
Путь: main\java\mchorse\blockbuster\client\gui\GuiRecordingOverlay.java
--------------------
package mchorse.blockbuster.client.gui;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.recording.RecordRecorder;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Recording GUI overlay
 *
 * This class is responsible for rendering red circle (like the icon that
 * represents recording in progress) and name of the recording file.
 */
@SideOnly(Side.CLIENT)
public class GuiRecordingOverlay extends Gui
{
    public static final ResourceLocation TEXTURE = new ResourceLocation(Blockbuster.MOD_ID, "textures/gui/recording.png");

    protected Minecraft mc;
    protected String caption;
    protected boolean isVisible = false;
    protected boolean recording = false;

    public GuiRecordingOverlay(Minecraft mc)
    {
        this.mc = mc;
    }

    /* Public API */

    public void setCaption(String caption, boolean recording)
    {
        this.caption = recording ? I18n.format("blockbuster.recording", caption) : caption;
        this.recording = recording;
    }

    public void setVisible(boolean isVisible)
    {
        this.isVisible = isVisible;
    }

    /* Rendering code */

    /**
     * Draw recording overlay if the recording in the process in top-left corner
     * of the screen.
     *
     * Thanks to coolAlias and to his tutorial github repo for this rendering
     * code.
     */
    public void draw(int width, int height)
    {
        if (!this.isVisible)
        {
            return;
        }

        FontRenderer font = this.mc.fontRenderer;
        String caption = this.caption;

        if (this.recording)
        {
            RecordRecorder recorder = ClientProxy.manager.recorders.get(Minecraft.getMinecraft().player);

            if (recorder != null)
            {
                caption += "\u00A7r (\u00A7l" + (recorder.tick + recorder.offset) + "\u00A7r)";
            }
        }

        this.mc.renderEngine.bindTexture(TEXTURE);

        GlStateManager.pushAttrib();
        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);

        this.drawTexturedModalRect(4, 4, 0, 0, 16, 16);
        font.drawStringWithShadow(caption, 22, 8, 0xffffffff);

        GlStateManager.popAttrib();
    }
}

==================================================

--- Файл №84 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\GuiBlockbusterPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard;

import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.mclib.GuiDashboardPanel;
import net.minecraft.client.Minecraft;

public class GuiBlockbusterPanel extends GuiDashboardPanel<GuiDashboard>
{
    public GuiBlockbusterPanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);
    }

    @Override
    public void appear()
    {
        GuiFirstTime.addOverlay(this.dashboard);
    }
}

==================================================

--- Файл №85 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\GuiBlockbusterPanels.java
--------------------
package mchorse.blockbuster.client.gui.dashboard;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.GuiImmersiveEditor;
import mchorse.blockbuster.client.gui.GuiImmersiveMorphMenu;
import mchorse.blockbuster.client.gui.dashboard.panels.GuiTextureManagerPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.scene.GuiScenePanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_block.GuiModelBlockPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.GuiModelEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.events.MultiskinProcessedEvent;
import mchorse.mclib.events.RegisterDashboardPanels;
import mchorse.mclib.events.RemoveDashboardPanels;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsMenu;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.function.Consumer;

/**
 * Blockbuster's dashboard GUI entry
 */
@SideOnly(Side.CLIENT)
public class GuiBlockbusterPanels
{
    public GuiScenePanel scenePanel;
    public GuiModelBlockPanel modelPanel;
    public GuiModelEditorPanel modelEditorPanel;
    public GuiRecordingEditorPanel recordingEditorPanel;
    public GuiTextureManagerPanel texturePanel;
    public GuiSnowstorm particleEditor;

    public GuiCreativeMorphsMenu morphs;
    public GuiImmersiveEditor immersiveEditor;

    public void picker(Consumer<AbstractMorph> callback)
    {
        this.morphs.removeFromParent();
        this.morphs.callback = callback;
        this.immersiveEditor.morphs.callback = callback;
    }

    public void addMorphs(GuiElement parent, boolean editing, AbstractMorph morph)
    {
        if (this.morphs.hasParent())
        {
            return;
        }

        parent.add(this.morphs);

        this.morphs.reload();
        this.morphs.flex().reset().relative(parent).wh(1F, 1F);
        this.morphs.resize();
        this.morphs.setSelected(morph);

        if (editing)
        {
            this.morphs.enterEditMorph();
        }
    }

    public GuiImmersiveEditor showImmersiveEditor(boolean editing, AbstractMorph morph)
    {
        this.immersiveEditor.show();
        this.immersiveEditor.morphs.setSelected(morph);
        this.immersiveEditor.morphs.updateCallback = null;
        this.immersiveEditor.morphs.target = null;
        this.immersiveEditor.morphs.frameProvider = null;
        this.immersiveEditor.morphs.beforeRender = null;
        this.immersiveEditor.morphs.afterRender = null;

        if (editing)
        {
            this.immersiveEditor.morphs.enterEditMorph();
        }

        return this.immersiveEditor;
    }

    public void closeImmersiveEditor()
    {
        this.immersiveEditor.closeThisScreen();
    }

    @SubscribeEvent
    public void onRegister(RegisterDashboardPanels event)
    {
        if (!(event.dashboard instanceof GuiDashboard))
        {
            return;
        }

        Minecraft mc = Minecraft.getMinecraft();
        GuiDashboard dashboard = (GuiDashboard) event.dashboard;

        this.scenePanel = new GuiScenePanel(mc, dashboard);
        this.modelPanel = new GuiModelBlockPanel(mc, dashboard);
        this.modelEditorPanel = new GuiModelEditorPanel(mc, dashboard);
        this.recordingEditorPanel = new GuiRecordingEditorPanel(mc, dashboard);
        this.texturePanel = new GuiTextureManagerPanel(mc, dashboard);
        this.particleEditor = new GuiSnowstorm(mc, dashboard);

        this.morphs = new GuiCreativeMorphsMenu(mc, null);
        this.immersiveEditor = new GuiImmersiveEditor(mc);

        dashboard.panels.registerPanel(this.scenePanel, IKey.lang("blockbuster.gui.dashboard.director"), BBIcons.SCENE);
        dashboard.panels.registerPanel(this.modelPanel, IKey.lang("blockbuster.gui.dashboard.model"), Icons.BLOCK);
        dashboard.panels.registerPanel(this.modelEditorPanel, IKey.lang("blockbuster.gui.dashboard.model_editor"), Icons.POSE);
        dashboard.panels.registerPanel(this.recordingEditorPanel, IKey.lang("blockbuster.gui.dashboard.player_recording"), BBIcons.EDITOR);
        dashboard.panels.registerPanel(this.texturePanel, IKey.lang("blockbuster.gui.dashboard.texture"), Icons.MATERIAL);
        dashboard.panels.registerPanel(this.particleEditor, IKey.lang("blockbuster.gui.dashboard.particle"), BBIcons.PARTICLE);
    }

    @SubscribeEvent
    public void onUnregister(RemoveDashboardPanels event)
    {
        GuiModelBlockPanel.lastBlocks.clear();
        ClientProxy.audio.reset();

        this.scenePanel = null;
        this.modelPanel = null;
        this.recordingEditorPanel = null;

        this.morphs = null;
        this.immersiveEditor = null;
    }

    @SubscribeEvent
    public void onMultiskinLoad(MultiskinProcessedEvent event)
    {
        ModelExtrudedLayer.forceReload(event.location, event.image);
    }
}

==================================================

--- Файл №86 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\GuiFirstTime.java
--------------------
package mchorse.blockbuster.client.gui.dashboard;

import mchorse.blockbuster.Blockbuster;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IGuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.mclib.GuiAbstractDashboard;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;

import java.util.List;

/**
 * First time? https://i.redd.it/2dbksvvj34121.jpg
 */
public class GuiFirstTime extends GuiElement
{
    public GuiButtonElement close;
    public GuiButtonElement tutorial;
    public GuiButtonElement youtube;
    public GuiButtonElement channel;
    public GuiButtonElement discord;
    public GuiButtonElement twitter;

    private IKey title;
    private List<String> welcome;
    private List<String> social;

    private final Overlay overlay;

    public static boolean shouldOpen()
    {
        return Blockbuster.generalFirstTime.get();
    }

    public static void addOverlay(GuiAbstractDashboard dashboard)
    {
        if (!GuiFirstTime.shouldOpen())
        {
            return;
        }

        boolean alreadyHas = false;

        for (IGuiElement element : dashboard.root.getChildren())
        {
            if (element instanceof GuiFirstTime.Overlay)
            {
                alreadyHas = true;

                break;
            }
        }

        if (!alreadyHas)
        {
            GuiFirstTime.Overlay overlay = new GuiFirstTime.Overlay(Minecraft.getMinecraft());

            overlay.flex().relative(dashboard.viewport).w(1, 0).h(1, 0);
            overlay.resize();
            dashboard.root.add(overlay);
        }
    }

    public GuiFirstTime(Minecraft mc, Overlay overlay)
    {
        super(mc);

        this.overlay = overlay;

        this.close = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.done"), (button) -> this.close());
        this.tutorial = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.tutorial"), (button) -> GuiUtils.openWebLink(Blockbuster.TUTORIAL_URL()));
        this.discord = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.discord"), (button) -> GuiUtils.openWebLink(Blockbuster.DISCORD_URL()));
        this.youtube = new GuiButtonElement(mc, IKey.str("YouTube"), (button) -> GuiUtils.openWebLink("https://www.youtube.com/c/McHorsesMods"));
        this.channel = new GuiButtonElement(mc, IKey.str(Blockbuster.langOrDefault("blockbuster.gui.first_time.channel", "")), (button) -> GuiUtils.openWebLink(Blockbuster.CHANNEL_URL()));
        this.twitter = new GuiButtonElement(mc, IKey.str("Twitter"), (button) -> GuiUtils.openWebLink(Blockbuster.TWITTER_URL()));

        this.tutorial.flex().set(10, 0, 0, 20).relative(this.area).w(0.5F, -12);
        this.youtube.flex().set(0, 0, 0, 20).relative(this.area).x(0.5F, 2).w(0.5F, -12);
        this.discord.flex().set(10, 0, 0, 20).relative(this.area).w(0.5F, -12).y(1, -55);
        this.twitter.flex().set(0, 0, 0, 20).relative(this.area).x(0.5F, 2).w(0.5F, -12).y(1, -55);
        this.close.flex().set(10, 0, 0, 20).relative(this.area).w(1, -20).y(1, -30);

        this.add(this.tutorial, this.discord, this.youtube, this.twitter, this.close);

        if (!this.channel.label.get().isEmpty())
        {
            this.tutorial.flex().set(10, 0, 0, 20).relative(this.area).w(0.33F, -10);
            this.channel.flex().set(0, 0, 0, 20).relative(this.area).x(0.5F, -30).w(60);
            this.youtube.flex().set(0, 0, 0, 20).relative(this.area).x(0.67F, 0).w(0.33F, -10);

            this.add(this.channel);
        }

        this.title = IKey.lang("blockbuster.gui.first_time.title");
        this.welcome = this.font.listFormattedStringToWidth(I18n.format("blockbuster.gui.first_time.welcome"), 180);
        this.social = this.font.listFormattedStringToWidth(I18n.format("blockbuster.gui.first_time.social"), 180);
    }

    private void close()
    {
        this.overlay.removeFromParent();

        /* Don't show anymore this modal */
        Blockbuster.generalFirstTime.set(false);
    }

    @Override
    public void draw(GuiContext context)
    {
        final int lineHeight = 11;

        this.area.draw(0xff000000);

        /* Draw extra text */
        String title = this.title.get();

        GlStateManager.pushMatrix();
        GlStateManager.translate(this.area.mx() - this.font.getStringWidth(title), this.area.y + 10, 0);
        GlStateManager.scale(2, 2, 2);

        this.font.drawStringWithShadow(title, 0, 0, 0xffffff);
        GlStateManager.popMatrix();

        /* Draw welcome paragraph */
        int y = this.area.y + 35;

        for (String label : this.welcome)
        {
            this.font.drawStringWithShadow(label, this.area.x + 10, y, 0xaaaaaa);
            y += lineHeight;
        }

        y += 5;

        /* Readjust buttons */
        this.tutorial.flex().y(y - this.area.y);
        this.tutorial.resize();
        this.channel.flex().y(y - this.area.y);
        this.channel.resize();
        this.youtube.flex().y(y - this.area.y);
        this.youtube.resize();

        /* Draw social paragraph */
        y = this.discord.area.y - 5 - this.social.size() * lineHeight;

        for (String label : this.social)
        {
            this.font.drawStringWithShadow(label, this.area.x + 10, y, 0xaaaaaa);
            y += lineHeight;
        }

        super.draw(context);
    }

    public static class Overlay extends GuiElement
    {
        public Overlay(Minecraft mc)
        {
            super(mc);

            GuiFirstTime firstTime = new GuiFirstTime(mc, this);

            firstTime.flex().set(0, 0, 200, 250).relative(this.area).x(0.5F, -100).y(0.5F, -125);

            this.add(firstTime);
            this.hideTooltip();
        }

        @Override
        public boolean mouseClicked(GuiContext context)
        {
            return super.mouseClicked(context) || this.isEnabled();
        }

        @Override
        public void draw(GuiContext context)
        {
            this.area.draw(ColorUtils.HALF_BLACK);

            super.draw(context);
        }
    }
}


==================================================

--- Файл №87 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\GuiBlockList.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels;

import java.util.List;
import java.util.function.Consumer;

import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.util.math.BlockPos;

/**
 * GUI block list
 * 
 * This GUI module is responsible for rendering and selecting 
 */
public abstract class GuiBlockList<T> extends GuiListElement<T>
{
    /**
     * Title of this panel 
     */
    public IKey title;

    public GuiBlockList(Minecraft mc, IKey title, Consumer<List<T>> callback)
    {
        super(mc, callback);

        this.title = title;
        this.area = new Area();
        this.scroll = new ScrollArea(20);
    }

    public abstract boolean addBlock(BlockPos pos);

    @Override
    public void resize()
    {
        super.resize();

        this.scroll.copy(this.area);
        this.scroll.y += 30;
        this.scroll.h -= 30;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xff333333);

        Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.y + 30, 0x44000000);
        this.font.drawStringWithShadow(this.title.get(), this.area.x + 10, this.area.y + 11, 0xcccccc);

        super.draw(context);
    }
}

==================================================

--- Файл №88 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\GuiTextureManagerPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanel;
import mchorse.blockbuster.client.textures.MipmapTexture;
import mchorse.blockbuster.utils.TextureUtils;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiResourceLocationListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiSearchListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiMessageModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.util.ResourceLocation;
import org.apache.commons.io.FilenameUtils;
import org.lwjgl.opengl.GL11;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

/**
 * Texture manager panel
 * 
 * This is a GUI which allows viewing and managing textures loaded by
 * {@link TextureManager} class.
 * 
 * Besides viewing, it also allows changing filter (linear/nearest), 
 * generating mipmaps and removing (clearing) textures from the manager.
 */
public class GuiTextureManagerPanel extends GuiBlockbusterPanel
{
    public GuiSearchResourceLocationList textures;
    public GuiToggleElement linear;
    public GuiToggleElement mipmap;
    public GuiButtonElement remove;
    public GuiButtonElement replace;
    public GuiButtonElement export;
    public GuiIconElement copy;

    private ResourceLocation rl;
    private String title = I18n.format("blockbuster.gui.texture.title");
    private String subtitle = I18n.format("blockbuster.gui.texture.subtitle");

    public GuiTextureManagerPanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        this.textures = new GuiSearchResourceLocationList(mc, (rl) -> this.pickRL(rl.get(0)));
        this.textures.list.background();
        this.linear = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.texture.linear"), false, (b) -> this.setLinear(b.isToggled()));
        this.linear.tooltip(IKey.lang("blockbuster.gui.texture.linear_tooltip"), Direction.LEFT);
        this.mipmap = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.texture.mipmap"), false, (b) -> this.setMipmap(b.isToggled()));
        this.mipmap.tooltip(IKey.lang("blockbuster.gui.texture.mipmap_tooltip"), Direction.LEFT);
        this.remove = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.remove"), (b) -> this.remove());
        this.replace = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.texture.replace"), (b) -> this.replace());
        this.export = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.texture.export"), (b) -> this.export());
        this.copy = new GuiIconElement(mc, Icons.COPY, (b) -> this.copy());
        this.copy.tooltip(IKey.lang("blockbuster.gui.texture.copy"), Direction.TOP).flex().wh(20, 20);

        GuiElement element = new GuiElement(mc);

        element.flex().relative(this).xy(1F, 1F).w(148).anchor(1F, 1F).column(5).vertical().stretch().padding(10);
        this.textures.flex().relative(this.area).set(10, 50, 0, 0).w(1, -30 - 128).h(1, -60);

        element.add(Elements.row(mc, 5, 0, this.export, this.copy));
        element.add(this.replace, this.remove, this.linear, this.mipmap);
        this.add(this.textures, element);
    }

    @Override
    public boolean isClientSideOnly()
    {
        return true;
    }

    private void copy()
    {
        ResourceLocation location = this.textures.list.getCurrentFirst();

        if (location == null)
        {
            return;
        }

        GuiScreen.setClipboardString(location.toString());
    }

    private void export()
    {
        ResourceLocation location = this.textures.list.getCurrentFirst();

        if (location == null)
        {
            return;
        }

        String name = FilenameUtils.getBaseName(location.getResourcePath());
        File folder = new File(ClientProxy.configFile, "export");
        File file = TextureUtils.getFirstAvailableFile(folder, name);

        folder.mkdirs();
        this.mc.renderEngine.bindTexture(location);

        int w = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
        int h = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);
        ByteBuffer buffer = GLAllocation.createDirectByteBuffer(w * h * 4);

        GL11.glGetTexImage(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);

        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        int[] pixelData = new int[w * h];

        for (int i = 0, c = w * h; i < c; i++)
        {
            int r = buffer.get() & 0xff;
            int g = buffer.get() & 0xff;
            int b = buffer.get() & 0xff;
            int a = buffer.get() & 0xff;

            pixelData[i] = (a << 24) | (r << 16) | (g << 8) | b;
        }

        image.setRGB(0, 0, w, h, pixelData, 0, w);

        try
        {
            ImageIO.write(image, "png", file);
            GuiModal.addFullModal(this, () ->
            {
                GuiMessageModal modal = new GuiMessageModal(this.mc, IKey.format("blockbuster.gui.texture.export_modal", file.getName()));
                GuiButtonElement open = new GuiButtonElement(this.mc, IKey.lang("blockbuster.gui.texture.open_folder"), (b) ->
                {
                    modal.removeFromParent();
                    GuiUtils.openFolder(new File(ClientProxy.configFile, "export").getAbsolutePath());
                });

                modal.bar.add(open);

                return modal;
            });
        }
        catch (Exception e)
        {
            e.printStackTrace();
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.lang("blockbuster.gui.texture.export_error")));
        }
    }

    private void pickRL(ResourceLocation rl)
    {
        if (this.rl == null)
        {
            this.linear.toggled(false);
            this.mipmap.toggled(false);
            this.rl = rl;
        }
        else
        {
            try
            {
                this.mc.renderEngine.bindTexture(rl);

                int filter = GL11.glGetTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER);

                boolean mipmap = ReflectionUtils.getTextures(this.mc.renderEngine).get(rl) instanceof MipmapTexture;
                boolean linear = filter == GL11.GL_LINEAR || filter == GL11.GL_LINEAR_MIPMAP_LINEAR || filter == GL11.GL_LINEAR_MIPMAP_NEAREST;

                this.linear.toggled(linear);
                this.mipmap.toggled(mipmap);
                this.rl = rl;
            }
            catch (Exception e)
            {}
        }
    }

    private void setLinear(boolean linear)
    {
        if (this.rl == null) return;

        this.mc.renderEngine.bindTexture(this.rl);

        boolean mipmap = this.mipmap.isToggled();

        int mod = linear ? (mipmap ? GL11.GL_LINEAR_MIPMAP_LINEAR : GL11.GL_LINEAR) : (mipmap ? GL11.GL_NEAREST_MIPMAP_LINEAR : GL11.GL_NEAREST);
        int mag = linear ? GL11.GL_LINEAR : GL11.GL_NEAREST;

        GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, mod);
        GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, mag);
    }

    private void setMipmap(boolean mipmap)
    {
        if (this.rl == null) return;

        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(this.mc.renderEngine);
        ITextureObject tex = map.get(this.rl);

        boolean mipmapped = tex instanceof MipmapTexture;

        /* Add or remove mipmap */
        if (mipmap && !mipmapped)
        {
            GlStateManager.deleteTexture(map.remove(this.rl).getGlTextureId());

            try
            {
                /* Load texture manually */
                tex = new MipmapTexture(this.rl);
                tex.loadTexture(Minecraft.getMinecraft().getResourceManager());

                map.put(this.rl, tex);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
        else if (!mipmap && mipmapped)
        {
            GlStateManager.deleteTexture(map.remove(this.rl).getGlTextureId());
        }
    }

    private void remove()
    {
        if (this.rl == null)
        {
            return;
        }

        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(this.mc.renderEngine);
        GlStateManager.deleteTexture(map.remove(this.rl).getGlTextureId());

        this.textures.list.remove(this.rl);
        this.textures.list.setIndex(this.textures.list.getIndex() - 1);
        this.pickRL(this.textures.list.getCurrentFirst());
    }

    private void replace()
    {
        if (this.rl == null || GuiModal.hasModal(this))
        {
            return;
        }

        GuiModal.addModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.texture.replace_modal"), this::replace);

            modal.text.field.setMaxStringLength(2000);
            modal.setValue(this.rl.toString());
            modal.flex().relative(this.area).set(10, 50, 0, 0).w(1, -30 - 128).h(1, -60);

            return modal;
        });
    }

    private void replace(String string)
    {
        if (this.rl.toString().equals(string))
        {
            return;
        }

        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(this.mc.renderEngine);
        ITextureObject texture = map.get(RLUtils.create(string));

        if (texture != null)
        {
            map.put(this.rl, texture);
        }
    }

    @Override
    public void open()
    {
        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(this.mc.renderEngine);

        this.textures.list.clear();
        this.textures.list.getList().addAll(map.keySet());
        this.textures.list.sort();
        this.textures.list.update();

        this.pickRL(this.rl);
        this.textures.list.setCurrent(this.rl);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.font.drawString(this.title, this.area.x + 10, this.area.y + 10, 0xffffff);
        this.font.drawSplitString(this.subtitle, this.area.x + 10, this.area.y + 26, this.area.w - 158, 0xcccccc);

        /* Draw preview */
        if (this.rl != null)
        {
            this.mc.renderEngine.bindTexture(this.rl);

            int w = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
            int h = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);

            int x = this.area.ex();
            int y = this.area.y + 10;
            int fw = w;
            int fh = h;

            if (fw > 128 || fh > 128)
            {
                fw = fh = 128;

                if (w > h)
                {
                    fh = (int) ((h / (float) w) * fw);
                }
                else if (h > w)
                {
                    fw = (int) ((w / (float) h) * fh);
                }
            }

            x -= fw + 10;

            GlStateManager.color(1, 1, 1);
            Icons.CHECKBOARD.renderArea(x, y, fw, fh);

            GlStateManager.enableAlpha();
            this.mc.renderEngine.bindTexture(this.rl);
            GuiDraw.drawBillboard(x, y, 0, 0, fw, fh, fw, fh);
        }

        super.draw(context);
    }

    public static class GuiSearchResourceLocationList extends GuiSearchListElement<ResourceLocation>
    {
        public GuiSearchResourceLocationList(Minecraft mc, Consumer<List<ResourceLocation>> callback)
        {
            super(mc, callback);
        }

        @Override
        protected GuiListElement<ResourceLocation> createList(Minecraft mc, Consumer<List<ResourceLocation>> callback)
        {
            return new GuiResourceLocationListElement(mc, callback);
        }
    }
}

==================================================

--- Файл №89 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_block\GuiModelBlockList.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_block;

import mchorse.blockbuster.client.gui.dashboard.panels.GuiBlockList;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;

import java.util.List;
import java.util.function.Consumer;

/**
 * Model block list 
 */
public class GuiModelBlockList extends GuiBlockList<TileEntityModel>
{
    public GuiModelBlockList(Minecraft mc, IKey title, Consumer<List<TileEntityModel>> callback)
    {
        super(mc, title, callback);
    }

    @Override
    public boolean addBlock(BlockPos pos)
    {
        TileEntity tile = this.mc.world.getTileEntity(pos);

        if (tile instanceof TileEntityModel)
        {
            this.list.add((TileEntityModel) tile);

            this.scroll.setSize(this.list.size());
            this.scroll.clamp();

            return true;
        }

        return false;
    }

    @Override
    protected void drawElementPart(TileEntityModel element, int i, int x, int y, boolean hover, boolean selected)
    {
        GuiContext context = GuiBase.getCurrent();
        int h = this.scroll.scrollItemSize;

        if (!element.morph.isEmpty())
        {
            int mny = MathHelper.clamp(y, this.scroll.y, this.scroll.ey());
            int mxy = MathHelper.clamp(y + 20, this.scroll.y, this.scroll.ey());

            if (mxy - mny > 0)
            {
                GuiDraw.scissor(x, mny, this.scroll.w, mxy - mny, context);
                element.morph.get().renderOnScreen(this.mc.player, x + this.scroll.w - 16, y + 30, 20, 1);
                GuiDraw.unscissor(context);
            }
        }

        BlockPos pos = element.getPos();
        String label = String.format("(%s, %s, %s)", pos.getX(), pos.getY(), pos.getZ());

        this.font.drawStringWithShadow(label, x + 10, y + 6, hover ? 16777120 : 0xffffff);
        Gui.drawRect(x, y + h - 1, x + this.area.w, y + h, 0x88181818);
    }
}

==================================================

--- Файл №90 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_block\GuiModelBlockPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_block;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.GuiImmersiveEditor;
import mchorse.blockbuster.client.gui.GuiImmersiveMorphMenu;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanel;
import mchorse.blockbuster.common.BlockbusterPermissions;
import mchorse.blockbuster.common.block.BlockModel;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.permissions.PermissionCategory;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.MatrixUtils.RotationOrder;
import mchorse.mclib.utils.MatrixUtils.Transformation;
import mchorse.mclib.utils.OpHelper;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;

public class GuiModelBlockPanel extends GuiBlockbusterPanel
{
    public static final List<BlockPos> lastBlocks = new ArrayList<BlockPos>();

    private TileEntityModel model;

    private GuiTrackpadElement yaw;
    private GuiTrackpadElement pitch;
    private GuiTrackpadElement body;

    private GuiModelBlockTransformations trans;

    private GuiNestedEdit pickMorph;
    private GuiCirculateElement order;
    private GuiToggleElement shadow;
    private GuiToggleElement global;
    private GuiToggleElement enabled;
    private GuiToggleElement excludeResetPlayback;
    private GuiToggleElement renderLast;
    private GuiToggleElement renderAlways;
    private GuiToggleElement enableBlockHitbox;
    private GuiTrackpadElement lightLevel;

    private GuiModelBlockList list;
    private GuiElement subChildren;

    private GuiSlotElement[] slots = new GuiSlotElement[6];

    private Map<BlockPos, TileEntityModel> old = new HashMap<BlockPos, TileEntityModel>();

    private AbstractMorph morph;

    private boolean opened;

    /**
     * Try adding a block position, if it doesn't exist in list already 
     */
    public static void tryAddingBlock(BlockPos pos)
    {
        for (BlockPos stored : lastBlocks)
        {
            if (pos.equals(stored))
            {
                return;
            }
        }

        lastBlocks.add(pos);
    }

    public GuiModelBlockPanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        this.subChildren = new GuiElement(mc).noCulling();
        this.subChildren.setVisible(false);
        this.add(this.subChildren);

        /* Transformations */
        this.trans = new GuiModelBlockTransformations(mc);
        this.trans.flex().relative(this).x(0.5F, 42).y(1F, -10).wh(250, 70).anchor(0.5F, 1F);

        this.subChildren.add(this.trans);

        /* Entity angles */
        this.subChildren.add(this.yaw = new GuiTrackpadElement(mc, (value) -> this.model.getSettings().setRotateYawHead(value.floatValue())));
        this.yaw.tooltip(IKey.lang("blockbuster.gui.model_block.yaw"));
        this.subChildren.add(this.pitch = new GuiTrackpadElement(mc, (value) -> this.model.getSettings().setRotatePitch(value.floatValue())));
        this.pitch.tooltip(IKey.lang("blockbuster.gui.model_block.pitch"));
        this.subChildren.add(this.body = new GuiTrackpadElement(mc, (value) -> this.model.getSettings().setRotateBody(value.floatValue())));
        this.body.tooltip(IKey.lang("blockbuster.gui.model_block.body"));

        this.yaw.flex().set(-85, 0, 80, 20).relative(this.trans);
        this.pitch.flex().set(0, 25, 80, 20).relative(this.yaw.resizer());
        this.body.flex().set(0, 25, 80, 20).relative(this.pitch.resizer());

        this.subChildren.add(this.order = new GuiCirculateElement(mc, (b) ->
        {
            int index = 0;

            if (this.order.getValue() == 0)
            {
                index = 5;
            }

            this.model.getSettings().setOrder(RotationOrder.values()[index]);
        }));
        this.order.addLabel(IKey.str("ZYX"));
        this.order.addLabel(IKey.str("XYZ"));
        this.order.flex().relative(this.trans.rx).set(40, -22, 40, 20);

        /* Buttons */
        GuiElement column = new GuiElement(mc);

        column.flex().relative(this).w(120).column(5).vertical().stretch().height(20).padding(10);

        this.pickMorph = new GuiNestedEdit(mc, (editing) -> 
        {
            if (Blockbuster.immersiveModelBlock.get())
            {
                GuiImmersiveEditor editor = ClientProxy.panels.showImmersiveEditor(editing, this.model.morph.get());

                editor.morphs.updateCallback = this::updateMorphEditor;
                editor.morphs.beforeRender = this::beforeEditorRender;
                editor.morphs.afterRender = this::afterEditorRender;
                editor.onClose = this::afterEditorClose;

                /* Avoid update. */
                this.morph = this.model.morph.get();
                this.model.morph.setDirect(MorphUtils.copy(this.morph));
            }
            else
            {
                ClientProxy.panels.addMorphs(this, editing, this.model.morph.get());
            }
        });

        GuiButtonElement look = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.model_block.look"), (button) ->
        {
            this.model.getSettings().setRy(180 - this.mc.player.rotationYaw);
            this.fillData();
        });

        this.shadow = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.shadow"), false, (button) -> this.model.getSettings().setShadow(button.isToggled()));

        this.global = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.global"), false, (button) -> this.model.getSettings().setGlobal(button.isToggled()));
        this.global.tooltip(IKey.lang("blockbuster.gui.model_block.global_tooltip"), Direction.BOTTOM);

        this.enabled = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.enabled"), false, (button) -> this.model.getSettings().setEnabled(button.isToggled()));
        this.enabled.tooltip(IKey.lang("blockbuster.gui.model_block.enabled_tooltip"), Direction.BOTTOM);

        this.excludeResetPlayback = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.exlude_reset_playback"), false, (button) -> this.model.getSettings().setExcludeResetPlayback(button.isToggled()));
        this.excludeResetPlayback.tooltip(IKey.lang("blockbuster.gui.model_block.exlude_reset_playback_tooltip"), Direction.BOTTOM);

        this.renderLast = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.render_last"), false, (button) -> this.model.getSettings().setRenderLast(button.isToggled()));
        this.renderLast.tooltip(IKey.lang("blockbuster.gui.model_block.render_last_tooltip"), Direction.BOTTOM);

        this.renderAlways = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.render_always"), false, (button) -> this.model.getSettings().setRenderAlways(button.isToggled()));
        this.renderAlways.tooltip(IKey.lang("blockbuster.gui.model_block.render_always_tooltip"), Direction.BOTTOM);

        this.enableBlockHitbox = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.model_block.enable_hitbox"), false, (b) -> this.model.getSettings().setEnableBlockHitbox(b.isToggled()));
        this.enableBlockHitbox.tooltip(IKey.lang("blockbuster.gui.model_block.enable_hitbox_tooltip"), Direction.BOTTOM);

        this.lightLevel = new GuiTrackpadElement(mc, (value) ->
        {
            this.model.getSettings().setLightValue(value.intValue());

            this.model.getWorld().setBlockState(this.model.getPos(), this.model.getWorld().getBlockState(this.model.getPos()).withProperty(BlockModel.LIGHT, this.model.getSettings().getLightValue()) , 2);
        });
        this.lightLevel.integer().limit(0, 15);
        this.lightLevel.tooltip(IKey.lang("blockbuster.gui.model_block.light_level_tooltip"));

        column.add(this.pickMorph, look, this.shadow, this.global, this.enabled, this.excludeResetPlayback, this.renderLast, this.renderAlways, this.enableBlockHitbox, Elements.label(IKey.lang("blockbuster.gui.model_block.light_level")), this.lightLevel);
        this.subChildren.add(column);

        /* Model blocks */
        this.list = new GuiModelBlockList(mc, IKey.lang("blockbuster.gui.model_block.title"), (tile) -> this.setModelBlock(tile.get(0)));
        this.list.flex().relative(this.flex()).set(0, 0, 120, 0).h(1F).x(1F, -120);
        this.add(this.list);

        GuiIconElement toggle = new GuiIconElement(mc, Icons.BLOCK, (b) -> this.list.toggleVisible());
        toggle.flex().set(0, 2, 24, 24).relative(this).x(1F, -28);

        this.add(toggle);

        /* Inventory */
        for (int i = 0; i < this.slots.length; i++)
        {
            final int slot = i;

            this.slots[i] = new GuiSlotElement(mc, i, (stack) -> this.pickItem(stack, slot));
            this.slots[i].flex().relative(this.area).anchor(0.5F, 0.5F);
            this.subChildren.add(this.slots[i]);
        }

        this.slots[0].flex().x(0.5F - 0.125F).y(0.5F, -15);
        this.slots[1].flex().x(0.5F - 0.125F).y(0.5F, 15);
        this.slots[2].flex().x(0.5F + 0.125F).y(0.5F, 45);
        this.slots[3].flex().x(0.5F + 0.125F).y(0.5F, 15);
        this.slots[4].flex().x(0.5F + 0.125F).y(0.5F, -15);
        this.slots[5].flex().x(0.5F + 0.125F).y(0.5F, -45);
    }

    public boolean isOpened()
    {
        return this.opened;
    }

    /**
     * @param tileEntityModel
     * @return true if the provided tileEntityModel reference matches the reference of the selected model.
     */
    public boolean isSelected(TileEntityModel tileEntityModel)
    {
        return this.model == tileEntityModel;
    }

    @Override
    public PermissionCategory getRequiredPermission()
    {
        return BlockbusterPermissions.editModelBlock;
    }

    @Override
    public boolean needsBackground()
    {
        return false;
    }

    private void pickItem(ItemStack stack, int slot)
    {
        this.model.getSettings().setSlot(stack, slot);
        this.model.updateEntity();
    }

    private void setMorph(AbstractMorph morph)
    {
        if (this.model != null)
        {
            if (Blockbuster.immersiveModelBlock.get())
            {
                this.morph = morph;
            }
            else
            {
                this.model.morph.setDirect(morph);
            }
        }

        this.pickMorph.setMorph(morph);
    }

    private void updateMorphEditor(GuiImmersiveMorphMenu menu)
    {
        if (this.model == null)
        {
            return;
        }

        TileEntity te = this.model.getWorld().getTileEntity(this.model.getPos());

        if (te != this.model)
        {
            if (te instanceof TileEntityModel)
            {
                this.setModelBlock((TileEntityModel) te);
            }
        }

        menu.target = this.model.entity;
    }

    private void beforeEditorRender(GuiContext context)
    {
        GlStateManager.pushMatrix();

        ClientProxy.modelRenderer.transform(this.model);
    }

    private void afterEditorRender(GuiContext context)
    {
        GlStateManager.popMatrix();
    }

    private void afterEditorClose(GuiImmersiveEditor editor)
    {
        this.model.morph.setDirect(this.morph);
    }

    @Override
    public void appear()
    {
        super.appear();

        ClientProxy.panels.picker(this::setMorph);
    }

    @Override
    public void open()
    {
        opened = true;

        this.updateList();

        /* Resetting the current model block, if it was removed from the world */
        if (this.model != null && this.mc.world.getTileEntity(this.model.getPos()) == null)
        {
            this.setModelBlock(null);
        }
    }

    @Override
    public void close()
    {
        this.save(null);

        opened = false;
    }

    public void save(TileEntityModel model)
    {
        this.save(model, false);
    }

    public void save(TileEntityModel model, boolean force)
    {
        if (!OpHelper.isPlayerOp())
        {
            return;
        }

        if (!force)
        {
            if (this.model == null || this.model == model)
            {
                return;
            }

            if (model != null && this.model.getPos().equals(model.getPos()))
            {
                return;
            }
        }

        if (ClientProxy.panels.morphs.hasParent())
        {
            ClientProxy.panels.morphs.finish();
            ClientProxy.panels.morphs.removeFromParent();
        }

        Dispatcher.sendToServer(new PacketModifyModelBlock(this.model.getPos(), this.model));

        if (Blockbuster.modelBlockRestore.get())
        {
            this.old.put(this.model.getPos(), this.model);
        }
    }

    public GuiModelBlockPanel openModelBlock(TileEntityModel model)
    {
        if (model != null && Blockbuster.modelBlockRestore.get() && this.old.containsKey(model.getPos()))
        {
            TileEntityModel old = this.old.get(model.getPos());

            model.copyData(old, false);
        }

        tryAddingBlock(model.getPos());

        this.updateList();
        this.list.setVisible(false);

        return this.setModelBlock(model);
    }

    public GuiModelBlockPanel setModelBlock(TileEntityModel model)
    {
        this.save(model);
        this.list.setCurrent(model);
        this.subChildren.setVisible(model != null);
        this.model = model;
        this.fillData();

        return this;
    }

    private void updateList()
    {
        this.list.clear();

        for (BlockPos pos : lastBlocks)
        {
            this.list.addBlock(pos);
        }

        this.list.setCurrent(this.model);
    }

    private void fillData()
    {
        if (this.model != null)
        {
            this.yaw.setValue(this.model.getSettings().getRotateYawHead());
            this.pitch.setValue(this.model.getSettings().getRotatePitch());
            this.body.setValue(this.model.getSettings().getRotateBody());

            this.trans.set(this.model);

            this.pickMorph.setMorph(this.model.morph.get());

            int orderIndex = this.model.getSettings().getOrder().ordinal();

            if (orderIndex == 5)
            {
                this.order.setValue(0);
            }
            else if (orderIndex == 0)
            {
                this.order.setValue(1);
            }

            this.shadow.toggled(this.model.getSettings().isShadow());
            this.global.toggled(this.model.getSettings().isGlobal());
            this.enabled.toggled(this.model.getSettings().isEnabled());
            this.excludeResetPlayback.toggled(this.model.getSettings().isExcludeResetPlayback());
            this.renderLast.toggled(this.model.getSettings().isRenderLast());
            this.renderAlways.toggled(this.model.getSettings().isRenderAlways());
            this.enableBlockHitbox.toggled(this.model.getSettings().isBlockHitbox());
            this.lightLevel.setValue(this.model.getSettings().getLightValue());

            for (int i = 0; i < this.slots.length; i++)
            {
                this.slots[i].setStack(this.model.getSettings().getSlots()[i]);
            }
        }
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.model != null)
        {
            AbstractMorph morph = this.model.morph.get();

            if (morph != null)
            {
                int x = this.area.mx();
                int y = this.area.y + 30;

                int w = Math.max(this.font.getStringWidth(morph.name), this.font.getStringWidth(morph.getDisplayName()));

                Gui.drawRect(x - w / 2 - 3, y - 20, x + w / 2 + 3, y, ColorUtils.HALF_BLACK);

                this.drawCenteredString(this.font, morph.getDisplayName(), x, y - this.font.FONT_HEIGHT * 2, 0xffffff);
                this.drawCenteredString(this.font, morph.name, x, y - this.font.FONT_HEIGHT, 0xcccccc);
            }
        }

        if (this.subChildren.isVisible())
        {
            this.drawString(this.font, I18n.format("blockbuster.gui.model_block.entity"), this.yaw.area.x + 2, this.yaw.area.y - 12, 0xffffff);
        }
        else if (this.model == null)
        {
            this.drawCenteredString(this.font, I18n.format("blockbuster.gui.model_block.not_selected"), this.area.mx(), this.area.my() - 6, 0xffffff);
        }

        super.draw(context);
    }

    public static class GuiModelBlockTransformations extends GuiTransformations
    {
        public TileEntityModel model;

        public GuiModelBlockTransformations(Minecraft mc)
        {
            super(mc);

            this.one.callback = (toggle) ->
            {
                boolean one = toggle.isToggled();

                this.model.getSettings().setUniform(one);
                this.updateScaleFields();

                if (!one)
                {
                    this.sy.setValueAndNotify(this.sx.value);
                    this.sz.setValueAndNotify(this.sx.value);
                }
            };
        }

        public void set(TileEntityModel model)
        {
            this.model = model;

            if (model != null)
            {
                this.fillT(model.getSettings().getX(), model.getSettings().getY(), model.getSettings().getZ());
                this.fillS(model.getSettings().getSx(), model.getSettings().getSy(), model.getSettings().getSz());
                this.fillR(model.getSettings().getRx(), model.getSettings().getRy(), model.getSettings().getRz());
                this.one.toggled(model.getSettings().isUniform());
                this.updateScaleFields();
            }
        }

        @Override
        public void setT(double x, double y, double z)
        {
            this.model.getSettings().setX((float) x);
            this.model.getSettings().setY((float) y);
            this.model.getSettings().setZ((float) z);
        }

        @Override
        public void setS(double x, double y, double z)
        {
            this.model.getSettings().setSx((float) x);
            this.model.getSettings().setSy((float) y);
            this.model.getSettings().setSz((float) z);
        }

        @Override
        public void setR(double x, double y, double z)
        {
            this.model.getSettings().setRx((float) x);
            this.model.getSettings().setRy((float) y);
            this.model.getSettings().setRz((float) z);
        }

        @Override
        protected void localTranslate(double x, double y, double z)
        {
            this.model.getSettings().addTranslation(x, y, z, GuiStaticTransformOrientation.getOrientation());

            this.fillT(this.model.getSettings().getX(), this.model.getSettings().getY(), this.model.getSettings().getZ());
        }

        @Override
        protected void prepareRotation(Matrix4f mat)
        {
            RotationOrder order = RotationOrder.valueOf(this.model.getSettings().getOrder().toString());
            float[] rot = new float[] {(float) this.rx.value, (float) this.ry.value, (float) this.rz.value};
            Matrix4f trans = new Matrix4f();
            trans.setIdentity();
            trans.set(Transformation.getRotationMatrix(order.thirdIndex, rot[order.thirdIndex]));
            mat.mul(trans);
            trans.set(Transformation.getRotationMatrix(order.secondIndex, rot[order.secondIndex]));
            mat.mul(trans);
            trans.set(Transformation.getRotationMatrix(order.firstIndex, rot[order.firstIndex]));
            mat.mul(trans);
        }

        @Override
        protected void postRotation(Transformation transform)
        {
            Vector3f result = transform.getRotation(RotationOrder.valueOf(this.model.getSettings().getOrder().toString()), new Vector3f((float) this.rx.value, (float) this.ry.value, (float) this.rz.value));
            this.rx.setValueAndNotify(result.x);
            this.ry.setValueAndNotify(result.y);
            this.rz.setValueAndNotify(result.z);
        }
    }
}

==================================================

--- Файл №91 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\GuiModelEditorPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiModelLimbs;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiModelList;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiModelOptions;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiModelPoses;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiBBModelRenderer;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.ModelUtils;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiPoseTransformations;
import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;
import org.apache.commons.io.FileUtils;
import org.lwjgl.input.Keyboard;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.function.Consumer;

public class GuiModelEditorPanel extends GuiBlockbusterPanel
{
    /* GUI stuff */
    public GuiBBModelRenderer modelRenderer;

    private GuiElement icons;
    private GuiIconElement openModels;
    private GuiIconElement openOptions;
    private GuiIconElement openPoses;
    private GuiIconElement saveModel;
    private GuiIconElement swipe;
    private GuiIconElement running;
    private GuiIconElement items;
    private GuiIconElement hitbox;
    private GuiIconElement looking;
    private GuiIconElement skin;

    private GuiPoseTransformations poseEditor;
    private GuiModelLimbs limbs;
    private GuiModelPoses poses;
    private GuiModelList models;
    private GuiModelOptions options;

    private GuiTexturePicker picker;

    /* Current data */
    public String modelName;
    public Model model;
    public ModelPose pose;
    public ModelTransform transform;
    public ModelLimb limb;

    public IModelLazyLoader modelEntry;
    public ModelCustom renderModel;

    private boolean dirty;
    private boolean held;

    public GuiModelEditorPanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        this.modelRenderer = new GuiBBModelRenderer(mc);
        this.modelRenderer.picker(this::setLimb);
        this.modelRenderer.flex().relative(this).wh(1F, 1F);
        this.modelRenderer.origin = this.modelRenderer.items = true;

        this.picker = new GuiTexturePicker(mc, null);
        this.picker.flex().relative(this).wh(1F, 1F);

        this.poseEditor = new GuiModelPoseTransformations(mc, this);
        this.poseEditor.flex().relative(this).set(0, 0, 256, 70).x(0.5F, -128).y(1, -80);

        this.limbs = new GuiModelLimbs(mc, this);
        this.limbs.flex().relative(this).x(1F).w(200).h(1F).anchorX(1F);

        this.poses = new GuiModelPoses(mc, this);
        this.poses.flex().relative(this).y(20).w(140).h(1F, -20);
        this.poses.setVisible(false);

        this.models = new GuiModelList(mc, this);
        this.models.flex().relative(this).y(20).w(140).h(1F, -20);
        this.models.setVisible(false);

        this.options = new GuiModelOptions(mc, this);
        this.options.flex().relative(this).y(20).w(200).h(1F, -20);
        this.options.setVisible(false);

        /* Toolbar buttons */
        this.openModels = new GuiIconElement(mc, Icons.MORE, (b) -> this.toggle(this.models));
        this.openOptions = new GuiIconElement(mc, Icons.GEAR, (b) -> this.toggle(this.options));
        this.openPoses = new GuiIconElement(mc, Icons.POSE, (b) -> this.toggle(this.poses));

        this.saveModel = new GuiIconElement(mc, Icons.SAVED, (b) -> this.saveModel());
        this.saveModel.tooltip(IKey.lang("blockbuster.gui.me.tooltips.save"));

        this.swipe = new GuiIconElement(mc, BBIcons.ARM1, (b) -> this.modelRenderer.swipe());
        this.swipe.tooltip(IKey.lang("blockbuster.gui.me.tooltips.swipe"));
        this.swipe.hovered(BBIcons.ARM2);

        this.running = new GuiIconElement(mc, BBIcons.LEGS1, (b) -> this.modelRenderer.swinging = !this.modelRenderer.swinging);
        this.running.hovered(BBIcons.LEGS2).hoverColor(0xffffffff).tooltip(IKey.lang("blockbuster.gui.me.tooltips.running"));

        this.items = new GuiIconElement(mc, BBIcons.NO_ITEMS, (b) ->
        {
            this.held = !this.held;
            ((DummyEntity) this.modelRenderer.getEntity()).toggleItems(this.held);
        });
        this.items.hovered(BBIcons.HELD_ITEMS).tooltip(IKey.lang("blockbuster.gui.me.tooltips.held_items"));

        this.hitbox = new GuiIconElement(mc, BBIcons.HITBOX, (b) -> this.modelRenderer.aabb = !this.modelRenderer.aabb);
        this.hitbox.tooltip(IKey.lang("blockbuster.gui.me.tooltips.hitbox"));

        this.looking = new GuiIconElement(mc, BBIcons.LOOKING, (b) -> this.modelRenderer.looking = !this.modelRenderer.looking);
        this.looking.tooltip(IKey.lang("blockbuster.gui.me.tooltips.looking"));

        this.skin = new GuiIconElement(mc, Icons.MATERIAL, (b) -> this.pickTexture(this.modelRenderer.texture, (rl) -> this.modelRenderer.texture = rl));
        this.skin.tooltip(IKey.lang("blockbuster.gui.me.tooltips.skin"));

        this.icons = new GuiElement(mc);
        this.icons.flex().relative(this).h(20).row(0).resize().height(20);
        this.icons.add(this.openModels, this.openOptions, this.openPoses, this.saveModel);

        GuiElement icons = new GuiElement(mc);
        icons.flex().relative(this.icons).x(1F, 20).h(20).row(0).resize().height(20);
        icons.add(this.swipe, this.running, this.items, this.hitbox, this.looking, this.skin);

        this.add(this.modelRenderer, this.poses, this.poseEditor, this.limbs, this.models, this.options, this.icons, icons);

        this.keys()
                .register(IKey.lang("blockbuster.gui.me.keys.save"), Keyboard.KEY_S, () -> this.saveModel.clickItself(GuiBase.getCurrent()))
                .held(Keyboard.KEY_LCONTROL).category(IKey.lang("blockbuster.gui.me.keys.category"));

        this.setModel("steve");
    }

    private void toggle(GuiElement element)
    {
        boolean visible = element.isVisible();

        this.models.setVisible(false);
        this.poses.setVisible(false);
        this.options.setVisible(false);

        element.setVisible(!visible);
    }

    public void dirty()
    {
        this.dirty(true);
    }

    public void dirty(boolean dirty)
    {
        this.dirty = dirty;
        this.updateSaveButton();
    }

    private void updateSaveButton()
    {
        this.saveModel.both(this.dirty ? Icons.SAVE : Icons.SAVED);
    }

    @Override
    public void open()
    {
        this.models.updateModelList();
    }

    public void pickTexture(ResourceLocation location, Consumer<ResourceLocation> callback)
    {
        this.picker.fill(location);
        this.picker.callback = callback;

        this.picker.resize();
        this.add(this.picker);
    }

    public void setLimb(String str)
    {
        ModelLimb limb = this.model.limbs.get(str);

        if (limb != null)
        {
            this.limb = limb;

            if (this.pose != null)
            {
                this.transform = this.pose.limbs.get(str);
            }

            this.modelRenderer.limb = limb;
            this.poseEditor.set(this.transform);
            this.limbs.fillLimbData(limb);
            this.limbs.setCurrent(str);
        }
    }

    public void setPose(String str)
    {
        this.setPose(str, false);
    }

    public void setPose(String str, boolean scroll)
    {
        ModelPose pose = this.model.poses.get(str);

        if (pose != null)
        {
            this.pose = pose;
            this.modelRenderer.setPose(pose);
            this.renderModel.pose = pose;

            if (this.limb != null)
            {
                this.transform = pose.limbs.get(this.limb.name);
            }

            this.poses.setCurrent(str, scroll);
            this.poses.fillPoseData();
            this.poseEditor.set(this.transform);
        }
    }

    public void saveModel()
    {
        this.saveModel(this.modelName);
    }

    /**
     * Save model
     *
     * This method is responsible for saving model into users's config folder.
     */
    public boolean saveModel(String name)
    {
        if (name.isEmpty())
        {
            return false;
        }

        File folder = new File(CommonProxy.configFile, "models/" + name);
        File file = new File(folder, "model.json");
        String output = ModelUtils.toJson(this.model);

        folder.mkdirs();

        try
        {
            FileUtils.write(file, output, StandardCharsets.UTF_8);

            IModelLazyLoader previous = Blockbuster.proxy.pack.models.get(this.modelName);

            /* Copy OBJ files */
            if (previous != null)
            {
                previous.copyFiles(folder);
            }

            this.modelName = name;
            Blockbuster.proxy.loadModels(false);

            this.dirty(false);
        }
        catch (Exception e)
        {
            e.printStackTrace();

            return false;
        }

        return true;
    }

    /**
     * Build the model from data model
     */
    public void rebuildModel()
    {
        ModelPose oldPose = this.renderModel.pose;

        this.renderModel.delete();
        this.renderModel = this.buildModel();
        this.modelRenderer.model = this.renderModel;

        if (this.model != null)
        {
            this.renderModel.pose = oldPose;
            this.modelRenderer.setPose(oldPose);
            this.poseEditor.set(this.transform);
        }

        this.dirty();
    }

    /**
     * Build the model from data model
     * 
     * TODO: optimize by rebuilding only one limb
     */
    public ModelCustom buildModel()
    {
        try
        {
            ModelExtrudedLayer.clearByModel(this.renderModel);

            return this.modelEntry.loadClientModel(this.modelName, this.model);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Set a model from the repository
     */
    public void setModel(String name)
    {
        ModelCustom model = ModelCustom.MODELS.get(name);

        if (model != null)
        {
            this.setModel(name, model.model, Blockbuster.proxy.pack.models.get(name));
        }
    }

    public void setModel(String name, Model model, IModelLazyLoader loader)
    {
        this.dirty(false);

        this.modelName = name;
        this.model = model.copy();
        this.modelEntry = loader;

        this.renderModel = this.buildModel();
        this.modelRenderer.model = this.renderModel;
        this.modelRenderer.texture = this.getFirstResourceLocation();
        this.modelRenderer.limb = this.limb;
        this.modelRenderer.setPose(this.pose);

        this.limbs.fillData(model);
        this.poses.fillData(model);
        this.options.fillData(model);

        this.setPose("standing", true);
        this.setLimb(this.model.limbs.keySet().iterator().next());
    }

    /**
     * Get the first available resource location for this model
     */
    private ResourceLocation getFirstResourceLocation()
    {
        ResourceLocation rl = this.model.defaultTexture;

        if (rl != null && rl.getResourcePath().isEmpty())
        {
            rl = null;
        }

        if (rl == null)
        {
            FolderEntry folder = ClientProxy.tree.getByPath(this.modelName + "/skins", null);

            if (folder != null)
            {
                for (AbstractEntry file : folder.getEntries())
                {
                    if (file instanceof mchorse.mclib.utils.files.entries.FileEntry)
                    {
                        rl = ((mchorse.mclib.utils.files.entries.FileEntry) file).resource;
                    }
                }
            }
        }

        return rl == null ? RLUtils.create("blockbuster", "textures/entity/actor.png") : rl;
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.models.isVisible())
        {
            this.openModels.area.draw(0xaa000000);
        }
        else if (this.poses.isVisible())
        {
            this.openPoses.area.draw(0xaa000000);
        }
        else if (this.options.isVisible())
        {
            this.openOptions.area.draw(0xaa000000);
        }

        if (this.modelRenderer.swinging)
        {
            this.running.area.draw(0x66000000);
        }

        if (this.held)
        {
            this.items.area.draw(0x66000000);
        }

        if (this.modelRenderer.aabb)
        {
            this.hitbox.area.draw(0x66000000);
        }

        if (this.modelRenderer.looking)
        {
            this.looking.area.draw(0x66000000);
        }

        super.draw(context);
    }

    public static class GuiModelPoseTransformations extends GuiPoseTransformations
    {
        public GuiModelEditorPanel panel;

        public GuiModelPoseTransformations(Minecraft mc, GuiModelEditorPanel panel)
        {
            super(mc);

            this.panel = panel;
        }

        @Override
        public void setT(double x, double y, double z)
        {
            super.setT(x, y, z);
            this.panel.dirty();
        }

        @Override
        public void setS(double x, double y, double z)
        {
            super.setS(x, y, z);
            this.panel.dirty();
        }

        @Override
        public void setR(double x, double y, double z)
        {
            super.setR(x, y, z);
            this.panel.dirty();
        }
    }
}

==================================================

--- Файл №92 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\tabs\GuiAnchorModal.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs;

import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiThreeElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

import javax.vecmath.Vector3f;
import java.util.function.Consumer;

public class GuiAnchorModal extends GuiModal
{
    public Consumer<Vector3f> callback;

    public GuiThreeElement vector;
    public GuiButtonElement confirm;

    public GuiAnchorModal(Minecraft mc, IKey label, Consumer<Vector3f> callback)
    {
        super(mc, label);

        this.callback = callback;
        this.vector = new GuiThreeElement(mc, null);
        this.vector.setLimit(0, 1, false);
        this.vector.a.increment(0.1).values(0.05, 0.01, 0.1);
        this.vector.b.increment(0.1).values(0.05, 0.01, 0.1);
        this.vector.c.increment(0.1).values(0.05, 0.01, 0.1);
        this.vector.flex().relative(this).set(10, 0, 0, 20).y(1, -55).w(1, -20);

        this.confirm = new GuiButtonElement(mc, IKey.lang("mclib.gui.ok"), (b) -> this.send());

        this.bar.add(this.confirm);
        this.add(this.vector);
    }

    public void send()
    {
        this.removeFromParent();

        if (this.callback != null)
        {
            this.callback.accept(new Vector3f((float) this.vector.a.value, (float) this.vector.b.value, (float) this.vector.c.value));
        }
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (context.keyCode == Keyboard.KEY_RETURN)
        {
            this.confirm.clickItself(context);

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №93 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\tabs\GuiModelEditorTab.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs;

import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.GuiModelEditorPanel;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public abstract class GuiModelEditorTab extends GuiElement
{
    protected IKey title = IKey.EMPTY;
    protected GuiModelEditorPanel panel;

    public GuiModelEditorTab(Minecraft mc, GuiModelEditorPanel panel)
    {
        super(mc);

        this.panel = panel;
    }

    public GuiModelEditorPanel getPanel()
    {
        return this.panel;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.drawLabels();
        super.draw(context);
    }

    protected void drawLabels()
    {
        if (this.title != null)
        {
            this.font.drawStringWithShadow(this.title.get(), this.area.x + 4, this.area.y + 6, 0xeeeeee);
        }
    }
}

==================================================

--- Файл №94 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\tabs\GuiModelLimbs.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs;

import javax.vecmath.Matrix4d;
import javax.vecmath.Matrix4f;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelLimb.ArmorSlot;
import mchorse.blockbuster.api.ModelLimb.Holding;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.GuiModelEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiTextureCanvas;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiThreeElement;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.ModelOBJRenderer;
import mchorse.blockbuster.client.model.ModelVoxRenderer;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiListModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiMessageModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.Minecraft;

import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;

public class GuiModelLimbs extends GuiModelEditorTab
{
    private GuiIconElement addLimb;
    private GuiIconElement dupeLimb;
    private GuiIconElement removeLimb;
    private GuiIconElement renameLimb;
    private GuiIconElement parentLimb;

    private GuiStringListElement limbs;
    private GuiScrollElement scroll;

    /* First category */
    private GuiThreeElement size;
    private GuiTrackpadElement sizeOffset;
    private GuiTrackpadElement itemScale;
    private GuiButtonElement texture;
    private GuiThreeElement anchor;
    private GuiThreeElement origin;

    private GuiTextureCanvas textureEditor;

    /* Second category */
    private GuiToggleElement mirror;
    private GuiToggleElement lighting;
    private GuiToggleElement shading;
    private GuiToggleElement smooth;
    private GuiToggleElement is3D;

    private GuiElement colors;
    private GuiColorElement color;
    private GuiColorElement specular;

    private GuiCirculateElement holding;
    private GuiCirculateElement slot;
    private GuiToggleElement hold;
    private GuiToggleElement swiping;
    private GuiToggleElement lookX;
    private GuiToggleElement lookY;
    private GuiToggleElement swinging;
    private GuiToggleElement idle;
    private GuiToggleElement invert;
    private GuiToggleElement wheel;
    private GuiToggleElement wing;
    private GuiToggleElement roll;
    private GuiToggleElement cape;
    
    private GuiElement vanillaPanel;
    private GuiElement objPanel;
    
    private float lastAnchorX;
    private float lastAnchorY;
    private float lastAnchorZ;

    public GuiModelLimbs(Minecraft mc, GuiModelEditorPanel panel)
    {
        super(mc, panel);

        this.title = IKey.lang("blockbuster.gui.me.limbs.title");

        this.limbs = new GuiStringListElement(mc, (str) -> this.setLimb(str.get(0)));
        this.limbs.background().flex().relative(this).y(20).w(1F).h(100);

        this.scroll = new GuiScrollElement(mc);
        this.scroll.scroll.scrollSpeed = 15;
        this.scroll.flex().relative(this.limbs).y(1F).w(1F).hTo(this.area, 1F).column(5).vertical().stretch().scroll().height(20).padding(10);

        this.textureEditor = new GuiTextureCanvas(mc, this);
        this.textureEditor.flex().relative(this.limbs).y(1F).w(1F).hTo(this.area, 1F);

        /* First category */
        this.size = new GuiThreeElement(mc, (values) ->
        {
            this.panel.limb.size[0] = values[0].intValue();
            this.panel.limb.size[1] = values[1].intValue();
            this.panel.limb.size[2] = values[2].intValue();
            this.panel.rebuildModel();
        });
        this.size.setLimit(0, 8192, true);
        this.sizeOffset = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.limb.sizeOffset = value.floatValue();
            this.panel.rebuildModel();
        });
        this.itemScale = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.limb.itemScale = value.floatValue();
            this.panel.dirty();
        });
        this.texture = new GuiButtonElement(mc, IKey.comp(IKey.lang("blockbuster.gui.edit"), IKey.str("...")), (b) ->
        {
            this.textureEditor.toggleVisible();
            this.textureEditor.setSize(this.panel.model.texture[0], this.panel.model.texture[1]);
        });
        this.anchor = new GuiThreeElement(mc, (values) ->
        {
            if (this.is3D.isVisible())
            {
                this.fixLimbPosition(values[0].floatValue(), values[1].floatValue(), values[2].floatValue());
                this.lastAnchorX = this.panel.limb.anchor[0] = values[0].floatValue();
                this.lastAnchorY = this.panel.limb.anchor[1] = values[1].floatValue();
                this.lastAnchorZ = this.panel.limb.anchor[2] = values[2].floatValue();
            }
            else
            {
                this.panel.limb.anchor[0] = values[0].floatValue();
                this.panel.limb.anchor[1] = values[1].floatValue();
                this.panel.limb.anchor[2] = values[2].floatValue();
            }

            this.panel.rebuildModel();
        });
        this.origin = new GuiThreeElement(mc, (values) ->
        {
            this.fixLimbPosition(values[0].floatValue(), values[1].floatValue(), values[2].floatValue());
            this.lastAnchorX = this.panel.limb.origin[0] = values[0].floatValue();
            this.lastAnchorY = this.panel.limb.origin[1] = values[1].floatValue();
            this.lastAnchorZ = this.panel.limb.origin[2] = values[2].floatValue();
            this.panel.rebuildModel();
        });
        this.origin.context(() ->
        {
            ModelCustomRenderer renderer = this.panel.renderModel.get(this.panel.limb.name);

            if (renderer != null && renderer.min != null && renderer.max != null)
            {
                return new GuiSimpleContextMenu(this.mc)
                    .action(Icons.FULLSCREEN, IKey.lang("blockbuster.gui.me.limbs.context.anchor_setup"), () -> this.setupAnchorPoint(renderer, false))
                    .action(Icons.DOWNLOAD, IKey.lang("blockbuster.gui.me.limbs.context.anchor_move"), () -> this.setupAnchorPoint(renderer, true));
            }

            return null;
        });
        this.slot = new GuiCirculateElement(mc, (b) ->
        {
            this.panel.limb.slot = ArmorSlot.values()[this.slot.getValue()];
            this.panel.dirty();
        });
        this.slot.tooltip(IKey.lang("blockbuster.gui.me.limbs.slot"));
        this.hold = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.holding"), false, (b) ->
        {
            this.panel.limb.hold = b.isToggled();
            this.panel.dirty();
        });

        for (ArmorSlot slot : ArmorSlot.values())
        {
            this.slot.addLabel(IKey.lang("blockbuster.gui.me.limbs.slots." + slot.name));
        }

        /* Second category */
        this.color = new GuiColorElement(mc, (eh) ->
        {
            Color color = this.color.picker.color;

            this.panel.limb.color[0] = color.r;
            this.panel.limb.color[1] = color.g;
            this.panel.limb.color[2] = color.b;
            this.panel.limb.opacity = color.a;
            this.panel.dirty();
        });
        this.color.picker.editAlpha();
        this.color.tooltip(IKey.lang("blockbuster.gui.me.limbs.color"));
        this.specular = new GuiColorElement(mc, (eh) ->
        {
            Color color = this.specular.picker.color;

            this.panel.limb.specular = color.getRGBAColor();
            this.panel.dirty();
        });
        this.specular.picker.editAlpha();
        this.specular.tooltip(IKey.lang("blockbuster.gui.me.limbs.specular"));
        this.mirror = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.mirror"), false, (b) ->
        {
            this.panel.limb.mirror = b.isToggled();
            this.panel.rebuildModel();
        });
        this.mirror.flex().h(20);
        this.lighting = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.lighting"), false, (b) ->
        {
            this.panel.limb.lighting = b.isToggled();
            this.panel.dirty();
        });
        this.shading = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.shading"), false, (b) ->
        {
            this.panel.limb.shading = b.isToggled();
            this.panel.dirty();
        });
        this.smooth = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.smooth"), false, (b) ->
        {
            this.panel.limb.smooth = b.isToggled();
            this.panel.dirty();
        });
        this.is3D = new GuiToggleElement(mc, IKey.str("3D"), false, (b) ->
        {
            this.panel.limb.is3D = b.isToggled();
            this.panel.dirty();
        });

        this.holding = new GuiCirculateElement(mc, (b) ->
        {
            this.panel.limb.holding = Holding.values()[this.holding.getValue()];
            this.panel.rebuildModel();
        });
        this.holding.tooltip(IKey.lang("blockbuster.gui.me.limbs.hold"));
        this.holding.addLabel(IKey.lang("blockbuster.gui.me.limbs.none"));
        this.holding.addLabel(IKey.lang("blockbuster.gui.me.limbs.right"));
        this.holding.addLabel(IKey.lang("blockbuster.gui.me.limbs.left"));

        this.swiping = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.swiping"), false, (b) ->
        {
            this.panel.limb.swiping = b.isToggled();
            this.panel.dirty();
        });
        this.lookX = new GuiToggleElement(mc, IKey.comp(IKey.lang("blockbuster.gui.me.limbs.looking"), IKey.str(" X")), false, (b) ->
        {
            this.panel.limb.lookX = b.isToggled();
            this.panel.dirty();
        });
        this.lookY = new GuiToggleElement(mc, IKey.comp(IKey.lang("blockbuster.gui.me.limbs.looking"), IKey.str(" Y")), false, (b) ->
        {
            this.panel.limb.lookY = b.isToggled();
            this.panel.dirty();
        });
        this.swinging = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.swinging"), false, (b) ->
        {
            this.panel.limb.swinging = b.isToggled();
            this.panel.dirty();
        });
        this.idle = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.idle"), false, (b) ->
        {
            this.panel.limb.idle = b.isToggled();
            this.panel.dirty();
        });
        this.invert = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.invert"), false, (b) ->
        {
            this.panel.limb.invert = b.isToggled();
            this.panel.dirty();
        });
        this.wheel = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.wheel"), false, (b) ->
        {
            this.panel.limb.wheel = b.isToggled();
            this.panel.dirty();
        });
        this.wing = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.wing"), false, (b) ->
        {
            this.panel.limb.wing = b.isToggled();
            this.panel.dirty();
        });
        this.roll = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.roll"), false, (b) ->
        {
            this.panel.limb.roll = b.isToggled();
            this.panel.dirty();
        });
        this.cape = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.cape"), false, (b) ->
        {
            this.panel.limb.cape = b.isToggled();
            this.panel.dirty();
        });

        this.vanillaPanel = Elements.column(mc, 5);
        this.vanillaPanel.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.size")).background(), this.size);
        this.vanillaPanel.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.size_offset")).background(), this.sizeOffset);
        this.vanillaPanel.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.texture")).background().marginTop(12), Elements.row(mc, 5, 0, 20, this.texture, this.mirror));

        this.objPanel = Elements.column(mc, 5);
        this.objPanel.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.origin")).background(), this.origin);

        GuiElement appearance = new GuiElement(mc);

        appearance.flex().grid(5).items(2).resizes(true);
        appearance.add(this.lighting, this.shading);
        appearance.add(this.smooth, this.is3D);

        this.colors = new GuiElement(mc);

        this.colors.flex().grid(5).items(1).resizes(true);
        this.colors.add(this.color);

        GuiElement animation = new GuiElement(mc);

        animation.flex().grid(5).items(2).resizes(true);
        animation.add(this.lookX, this.lookY);
        animation.add(this.idle, this.swinging);
        animation.add(this.invert, this.swiping);
        animation.add(this.hold, this.wheel);
        animation.add(this.wing, this.roll);
        animation.add(this.cape);

        this.scroll.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.anchor")).background().marginTop(12), this.anchor);
        this.scroll.add(Elements.row(mc, 5, this.slot, this.holding));
        this.scroll.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.item_scale")).background(), this.itemScale);
        this.scroll.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.appearance")).background().marginTop(12), appearance, this.colors);
        this.scroll.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.animation")).background().marginTop(12), animation);

        /* Buttons */
        this.addLimb = new GuiIconElement(mc, Icons.ADD, (b) -> this.addLimb());
        this.dupeLimb = new GuiIconElement(mc, Icons.DUPE, (b) -> this.dupeLimb());
        this.removeLimb = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.removeLimb());
        this.renameLimb = new GuiIconElement(mc, Icons.EDIT, (b) -> this.renameLimb());
        this.parentLimb = new GuiIconElement(mc, Icons.LIMB, (b) -> this.parentLimb());

        GuiElement sidebar = Elements.row(mc, 0, 0, 20, this.addLimb, this.dupeLimb, this.parentLimb, this.renameLimb, this.removeLimb);

        sidebar.flex().relative(this).x(1F).h(20).anchorX(1F).row(0).resize();

        this.add(sidebar, this.limbs, this.scroll, this.textureEditor);
    }

    private void setupAnchorPoint(ModelCustomRenderer renderer, boolean move)
    {
        GuiAnchorModal modal = new GuiAnchorModal(this.mc, IKey.lang("blockbuster.gui.me.limbs.anchor_modal"), (anchor) -> this.doSetupAnchorPoint(renderer, anchor, move));

        this.panel.modelRenderer.anchorPreview = modal;
        GuiModal.addFullModal(this, () -> modal);
    }

    private void doSetupAnchorPoint(ModelCustomRenderer renderer, Vector3f anchor, boolean move)
    {
        renderer.limb.origin[0] = Interpolations.lerp(renderer.min.x, renderer.max.x, anchor.x);
        renderer.limb.origin[1] = Interpolations.lerp(renderer.min.y, renderer.max.y, anchor.y);
        renderer.limb.origin[2] = Interpolations.lerp(renderer.min.z, renderer.max.z, anchor.z);

        if (move)
        {
            float[] translate = this.panel.pose.limbs.get(renderer.limb.name).translate;

            translate[0] = -renderer.limb.origin[0] * 16;
            translate[1] = renderer.limb.origin[1] * 16;
            translate[2] = -renderer.limb.origin[2] * 16;
        }

        this.panel.modelRenderer.anchorPreview = null;
        this.panel.setLimb(renderer.limb.name);
        this.panel.rebuildModel();
    }

    private void addLimb()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.me.limbs.new_limb"), this::addLimb);

            return modal.setValue(this.panel.limb.name);
        });
    }

    private void addLimb(String text)
    {
        if (!this.panel.model.limbs.containsKey(text))
        {
            this.panel.model.addLimb(text);
            this.limbs.add(text);
            this.limbs.setCurrent(text);
            this.panel.rebuildModel();
            this.panel.setLimb(text);
        }
    }

    private void dupeLimb()
    {
        if (this.getLimbClass(this.panel.limb) != ModelCustomRenderer.class)
        {
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.lang("blockbuster.gui.me.limbs.obj_limb")));
            return;
        }
        
        ModelLimb limb = this.panel.limb.clone();

        /* It must be unique name */
        while (this.panel.model.limbs.containsKey(limb.name))
        {
            limb.name += "_copy";
        }

        this.panel.model.addLimb(limb);
        this.limbs.add(limb.name);
        this.limbs.setCurrent(limb.name);
        this.panel.rebuildModel();
        this.panel.setLimb(limb.name);
    }

    private void removeLimb()
    {
        int size = this.panel.model.limbs.size();

        if (this.getLimbClass(this.panel.limb) != ModelCustomRenderer.class)
        {
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.lang("blockbuster.gui.me.limbs.obj_limb")));
        }
        else if (size == this.panel.model.getLimbCount(this.panel.limb))
        {
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.lang("blockbuster.gui.me.limbs.last_limb")));
        }
        else
        {
            this.panel.model.removeLimb(this.panel.limb);

            String newLimb = this.panel.model.limbs.keySet().iterator().next();

            this.fillData(this.panel.model);
            this.panel.rebuildModel();
            this.panel.setLimb(newLimb);
        }
    }

    private void renameLimb()
    {
        if (this.getLimbClass(this.panel.limb) != ModelCustomRenderer.class)
        {
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.lang("blockbuster.gui.me.limbs.obj_limb")));
        }
        else
        {
            GuiModal.addFullModal(this, () -> new GuiPromptModal(mc, IKey.lang("blockbuster.gui.me.limbs.rename_limb"), this::renameLimb).setValue(this.panel.limb.name));
        }
    }

    private void renameLimb(String text)
    {
        if (this.panel.model.renameLimb(this.panel.limb, text))
        {
            this.limbs.replace(text);
            this.panel.rebuildModel();
        }
    }

    private void parentLimb()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiToggleElement button = new GuiToggleElement(this.mc, IKey.lang("blockbuster.gui.me.limbs.parent_limb_transform_correction"), true, null);
            button.tooltip(IKey.lang("blockbuster.gui.me.limbs.parent_limb_transform_correction_tooltip"));

            GuiListModal modal = new GuiListModal(mc, IKey.lang("blockbuster.gui.me.limbs.parent_limb"),
                    (text) -> this.parentLimb(text, button.isToggled()));

            button.flex().relative(modal.bar).x(10).w(1F, -20).y(-0.25F, -5);
            modal.add(button);

            return modal.addValues(this.panel.model.limbs.keySet()).setValue(this.panel.limb.parent);
        });
    }

    private void parentLimb(String text)
    {
        this.parentLimb(text, false);
    }

    private void correctTransformationParenting(String newParent)
    {
        ModelCustomRenderer currentLimbRenderer = null;
        ModelCustomRenderer newParentRenderer = null;

        for (ModelCustomRenderer limbRenderer : this.panel.renderModel.limbs) {
            if (limbRenderer.limb == this.panel.limb) {
                currentLimbRenderer = limbRenderer;
            } else if (limbRenderer.limb.name.equals(newParent)) {
                newParentRenderer = limbRenderer;
            }
        }

        if (currentLimbRenderer == null) return;

        Matrix4d diff = new Matrix4d();
        diff.setIdentity();

        if (newParentRenderer != null)
        {
            diff = newParentRenderer.getWorldTransformation();
            diff.invert();
            diff.mul(currentLimbRenderer.getWorldTransformation());
        }
        else
        {
            diff = this.panel.modelRenderer.getModelMatrix();
            diff.invert();
            diff.mul(currentLimbRenderer.getModelView());
            /**
             * see {@link ModelCustomRenderer#applyTransform(ModelTransform)}
             */
            diff.m13 -= 24 / 16F;
        }

        MatrixUtils.Transformation correction = MatrixUtils.getTransformation(diff);

        correction.rotation.transpose();

        Vector3f trans = correction.getTranslation3f();
        Vector3f rot = correction.getRotation(MatrixUtils.RotationOrder.XYZ);
        Vector3f scale = correction.getScale();

        /* everything is scaled with 1/16 so this is needed to convert normal coordinates into BB coordinates*/
        trans.scale(16);
        ModelTransform transform = currentLimbRenderer.model.pose.limbs.get(this.panel.limb.name);

        if (transform != null) {
            transform.translate = new float[]{trans.x, -trans.y, -trans.z};
            transform.rotate = new float[]{rot.x, -rot.y, -rot.z};
            transform.scale = new float[]{scale.x, scale.y, scale.z};
        }
    }

    private void parentLimb(String text, boolean correctTransformation)
    {
        if (!this.panel.limb.name.equals(text))
        {
            this.panel.limb.parent = text;

            if (correctTransformation) this.correctTransformationParenting(text);

            this.panel.rebuildModel();
        }
    }

    private void setLimb(String str)
    {
        this.panel.setLimb(str);
        this.fillLimbData(this.panel.limb);
    }

    public void setCurrent(String str)
    {
        this.limbs.setCurrent(str);
        this.fillLimbData(this.panel.limb);
    }

    public void fillData(Model model)
    {
        this.limbs.clear();
        this.limbs.add(model.limbs.keySet());
        this.limbs.sort();

        this.textureEditor.setVisible(false);
    }

    public void fillLimbData(ModelLimb limb)
    {
        this.textureEditor.x.setValue(this.panel.limb.texture[0]);
        this.textureEditor.y.setValue(this.panel.limb.texture[1]);

        this.size.setValues(limb.size[0], limb.size[1], limb.size[2]);
        this.sizeOffset.setValue(limb.sizeOffset);
        this.itemScale.setValue(limb.itemScale);
        this.anchor.setValues(limb.anchor[0], limb.anchor[1], limb.anchor[2]);
        this.origin.setValues(limb.origin[0], limb.origin[1], limb.origin[2]);
        this.color.picker.setColor(limb.color[0], limb.color[1], limb.color[2], limb.opacity);
        this.mirror.toggled(limb.mirror);
        this.lighting.toggled(limb.lighting);
        this.shading.toggled(limb.shading);
        this.smooth.toggled(limb.smooth);
        this.is3D.toggled(limb.is3D);

        this.holding.setValue(limb.holding.ordinal());
        this.slot.setValue(limb.slot.ordinal());
        this.hold.toggled(limb.hold);
        this.swiping.toggled(limb.swiping);
        this.lookX.toggled(limb.lookX);
        this.lookY.toggled(limb.lookY);
        this.swinging.toggled(limb.swinging);
        this.idle.toggled(limb.idle);
        this.invert.toggled(limb.invert);
        this.wheel.toggled(limb.wheel);
        this.wing.toggled(limb.wing);
        this.roll.toggled(limb.roll);
        this.cape.toggled(limb.cape);

        boolean isObj = this.getLimbClass(limb) != ModelCustomRenderer.class;
        boolean isVOX = this.getLimbClass(limb) == ModelVoxRenderer.class;
        this.vanillaPanel.removeFromParent();
        this.objPanel.removeFromParent();
        this.is3D.setVisible(!isObj);

        if (isObj)
        {
            this.lastAnchorX = limb.origin[0];
            this.lastAnchorY = limb.origin[1];
            this.lastAnchorZ = limb.origin[2];
            this.scroll.prepend(this.objPanel);
        }
        else
        {
            this.lastAnchorX = limb.anchor[0];
            this.lastAnchorY = limb.anchor[1];
            this.lastAnchorZ = limb.anchor[2];
            this.scroll.prepend(this.vanillaPanel);
        }

        if (isVOX)
        {
            if (!this.specular.hasParent())
            {
                this.colors.flex().grid(5).items(2).resizes(true);
                this.colors.add(this.specular);
            }

            this.specular.picker.setColor(limb.specular);
        }
        else
        {
            this.specular.removeFromParent();
            this.colors.flex().grid(5).items(1).resizes(true);
        }

        this.scroll.resize();
    }

    private void fixLimbPosition(float x, float y, float z)
    {
        Model model = this.panel.model;
        ModelLimb limb = this.panel.limb;
        ModelTransform transform = this.panel.transform;
        Class<? extends ModelCustomRenderer> clazz = this.getLimbClass(limb);
        
        Matrix4f mat = new Matrix4f();
        mat.setIdentity();
        mat.m03 = transform.translate[0];
        mat.m13 = transform.translate[1];
        mat.m23 = transform.translate[2];
        
        Matrix4f mat2 = new Matrix4f();
        mat2.rotZ((float) Math.toRadians(transform.rotate[2]));
        mat.mul(mat2);
        mat2.rotY((float) Math.toRadians(transform.rotate[1]));
        mat.mul(mat2);
        mat2.rotX((float) Math.toRadians(transform.rotate[0]));
        mat.mul(mat2);
        
        mat2.setIdentity();
        mat2.m00 = transform.scale[0];
        mat2.m11 = transform.scale[1];
        mat2.m22 = transform.scale[2];
        mat.mul(mat2);
        
        if (clazz != ModelCustomRenderer.class)
        {
            if (clazz == ModelOBJRenderer.class)
            {
                mat2.setIdentity();
                mat2.m00 = model.legacyObj || this.getLimbClass(this.panel.limb) == ModelVoxRenderer.class ? 16 : -16;
                mat2.m11 = 16;
                mat2.m22 = 16;
                mat.mul(mat2);
            }
            
            mat2.setIdentity();
            mat2.m03 = x - this.lastAnchorX;
            mat2.m13 = y - this.lastAnchorY;
            mat2.m23 = this.lastAnchorZ - z;
            mat.mul(mat2);
        }
        else
        {
            mat2.setIdentity();
            mat2.m00 = limb.size[0];
            mat2.m11 = limb.size[1];
            mat2.m22 = limb.size[2];
            mat.mul(mat2);
            
            mat2.setIdentity();
            mat2.m03 = this.lastAnchorX - x;
            mat2.m13 = this.lastAnchorY - y;
            mat2.m23 = this.lastAnchorZ - z;
            mat.mul(mat2);
        }

        transform.translate[0] = mat.m03;
        transform.translate[1] = mat.m13;
        transform.translate[2] = mat.m23;
    }
    
    private Class<? extends ModelCustomRenderer> getLimbClass(ModelLimb limb)
    {
        for (ModelCustomRenderer limbRenderer : this.panel.renderModel.limbs)
        {
            if (limbRenderer.limb.name.equals(limb.name))
            {
                return limbRenderer.getClass();
            }
        }
        return null;
    }
}

==================================================

--- Файл №95 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\tabs\GuiModelList.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderJSON;
import mchorse.blockbuster.api.resource.StreamEntry;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.GuiModelEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiThreeElement;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiTwoElement;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.parsing.ModelExporter;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringSearchListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiListModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiMessageModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Patterns;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.registry.EntityEntry;
import net.minecraftforge.fml.common.registry.ForgeRegistries;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map.Entry;
import java.util.regex.Pattern;

public class GuiModelList extends GuiModelEditorTab
{
    public static final Pattern FILENAME_SLASHES = Pattern.compile(Patterns.FILENAME.pattern().replace("]*$","/]*$"));

    public GuiStringSearchListElement models;
    private GuiIconElement dupe;
    private GuiIconElement export;
    private GuiIconElement folder;

    public GuiModelList(Minecraft mc, GuiModelEditorPanel panel)
    {
        super(mc, panel);

        this.title = IKey.lang("blockbuster.gui.me.models.title");

        this.models = new GuiStringSearchListElement(mc, (str) -> this.panel.setModel(str.get(0)));
        this.models.flex().relative(this.area).y(20).w(140).h(1, -20);
        this.models.list.scroll.scrollSpeed = 16;

        this.dupe = new GuiIconElement(mc, Icons.DUPE, (b) -> this.saveModel());
        this.export = new GuiIconElement(mc, Icons.UPLOAD, (b) -> this.exportModel());
        this.folder = new GuiIconElement(mc, Icons.FOLDER, (b) -> this.openFolder());

        GuiElement sidebar = Elements.row(mc, 0, 0, 20, this.dupe, this.export, this.folder);

        sidebar.flex().relative(this.models).x(1F).y(-20).h(20).anchorX(1F).row(0).resize();

        this.add(this.models, sidebar);
    }

    public void updateModelList()
    {
        String current = this.models.list.getCurrentFirst();

        this.models.list.clear();
        this.models.list.add(ModelCustom.MODELS.keySet());
        this.models.list.sort();

        if (current == null)
        {
            current = "steve";
        }

        this.models.list.setCurrentScroll(current);
    }

    private void saveModel()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(mc, IKey.lang("blockbuster.gui.me.models.name"), this::saveModel).setValue(this.panel.modelName);

            modal.text.validator((string) -> FILENAME_SLASHES.matcher(string).find());

            return modal;
        });
    }

    private void saveModel(String name)
    {
        boolean exists = ModelCustom.MODELS.containsKey(name);

        if (!exists)
        {
            if (!this.panel.saveModel(name))
            {
                return;
            }

            this.models.list.add(name);
            this.models.list.sort();
            this.models.list.setCurrent(name);
        }
    }

    private void exportModel()
    {
        List<String> mobs = new ArrayList<String>();

        for (Entry<ResourceLocation, EntityEntry> entry : ForgeRegistries.ENTITIES.getEntries())
        {
            Class<? extends Entity> clazz = entry.getValue().getEntityClass();

            while (clazz != null)
            {
                if (clazz == EntityLivingBase.class)
                {
                    mobs.add(entry.getKey().toString());
                    break;
                }
                else
                {
                    clazz = (Class<? extends Entity>) clazz.getSuperclass();
                }
            }
        }

        Collections.sort(mobs);

        GuiModal.addFullModal(this, () ->
        {
            GuiListModal modal = new GuiListModal(this.mc, IKey.lang("blockbuster.gui.me.models.pick"), this::exportModel);

            return modal.addValues(mobs);
        });
    }

    private void exportModel(String name)
    {
        if (name.isEmpty())
        {
            return;
        }

        try
        {
            Entity entity = EntityList.createEntityByIDFromName(new ResourceLocation(name), this.mc.world);
            Render render = Minecraft.getMinecraft().getRenderManager().getEntityRenderObject(entity);
            ModelExporter exporter = new ModelExporter((EntityLivingBase) entity, (RenderLivingBase) render);
            Model model = exporter.exportModel(name);

            name = name.replaceAll(":", "_");
            model.fillInMissing();
            this.panel.setModel(name, model, new ModelLazyLoaderJSON(new StreamEntry("", 0)));
        }
        catch (Exception e)
        {
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.str(I18n.format("blockbuster.gui.me.models.error", e.getMessage()))));

            e.printStackTrace();
        }
    }

    private void openFolder()
    {
        GuiUtils.openFolder(new File(ClientProxy.configFile, "models/" + this.panel.modelName).getAbsolutePath());
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xaa000000);

        super.draw(context);
    }
}

==================================================

--- Файл №96 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\tabs\GuiModelOptions.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.GuiModelEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiThreeElement;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiTwoElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;

public class GuiModelOptions extends GuiModelEditorTab
{
    /* Main properties */
    private GuiTextElement name;
    private GuiTwoElement texture;
    private GuiTrackpadElement extrudeMaxFactor;
    private GuiTrackpadElement extrudeInwards;
    private GuiThreeElement scale;
    private GuiTrackpadElement scaleGui;
    private GuiButtonElement defaultTexture;
    private GuiTextElement skins;
    private GuiToggleElement providesObj;
    private GuiToggleElement providesMtl;
    private GuiToggleElement legacyObj;

    public GuiModelOptions(Minecraft mc, GuiModelEditorPanel panel)
    {
        super(mc, panel);

        /* Main properties */
        GuiScrollElement element = new GuiScrollElement(mc);

        this.name = new GuiTextElement(mc, 120, (str) -> this.panel.model.name = str);
        this.texture = new GuiTwoElement(mc, (value) ->
        {
            this.panel.model.texture[0] = value[0].intValue();
            this.panel.model.texture[1] = value[1].intValue();
            this.panel.rebuildModel();
        });
        this.texture.setLimit(1, 8196, true);
        this.extrudeMaxFactor = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.model.extrudeMaxFactor = value.intValue();
            this.panel.rebuildModel();
        });
        this.extrudeMaxFactor.tooltip(IKey.lang("blockbuster.gui.me.options.extrude_max_factor"));
        this.extrudeMaxFactor.integer().limit(1);
        this.extrudeInwards = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.model.extrudeInwards = value.intValue();
            this.panel.rebuildModel();
        });
        this.extrudeInwards.tooltip(IKey.lang("blockbuster.gui.me.options.extrude_inwards"));
        this.extrudeInwards.integer().limit(1);
        this.scale = new GuiThreeElement(mc, (value) ->
        {
            this.panel.model.scale[0] = value[0].floatValue();
            this.panel.model.scale[1] = value[1].floatValue();
            this.panel.model.scale[2] = value[2].floatValue();
        });
        this.scaleGui = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.model.scaleGui = value.floatValue();
            this.panel.dirty();
        });
        this.scaleGui.tooltip(IKey.lang("blockbuster.gui.me.options.scale_gui"));
        this.defaultTexture = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.me.options.default_texture"), (b) ->
        {
            this.panel.pickTexture(this.panel.model.defaultTexture, (rl) ->
            {
                this.panel.model.defaultTexture = rl;
                this.panel.dirty();
            });
        });
        this.skins = new GuiTextElement(mc, 120, (str) ->
        {
            this.panel.model.skins = str;
            this.panel.dirty();
        });
        this.providesObj = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.options.provides_obj"), false, (b) ->
        {
            this.panel.model.providesObj = b.isToggled();
            this.panel.rebuildModel();
        });
        this.providesMtl = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.options.provides_mtl"), false, (b) ->
        {
            this.panel.model.providesMtl = b.isToggled();
            this.panel.rebuildModel();
        });
        this.legacyObj = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.options.legacy_obj"), false, (b) ->
        {
            this.panel.model.legacyObj = b.isToggled();
            this.panel.rebuildModel();
        });
        this.legacyObj.tooltip(IKey.lang("blockbuster.gui.me.options.legacy_obj_tooltip"), Direction.TOP);

        element.flex().relative(this).wh(1F, 1F).column(5).vertical().stretch().scroll().padding(10).height(20);
        element.add(Elements.label(IKey.lang("blockbuster.gui.me.options.name")), this.name);
        element.add(Elements.label(IKey.lang("blockbuster.gui.me.options.texture")), this.texture);
        element.add(Elements.label(IKey.lang("blockbuster.gui.me.options.extrusion")), this.extrudeMaxFactor, this.extrudeInwards);
        element.add(Elements.label(IKey.lang("blockbuster.gui.me.options.scale")), this.scale, this.scaleGui, this.defaultTexture);
        element.add(Elements.label(IKey.lang("blockbuster.gui.me.options.skins")), this.skins, this.providesObj, this.providesMtl, this.legacyObj);

        this.add(element);
    }

    public void fillData(Model model)
    {
        this.name.setText(model.name);
        this.texture.setValues(model.texture[0], model.texture[1]);
        this.extrudeMaxFactor.setValue(model.extrudeMaxFactor);
        this.extrudeInwards.setValue(model.extrudeInwards);
        this.scale.setValues(model.scale[0], model.scale[1], model.scale[2]);
        this.scaleGui.setValue(model.scaleGui);
        this.skins.setText(model.skins);
        this.providesObj.toggled(model.providesObj);
        this.providesMtl.toggled(model.providesMtl);
        this.legacyObj.toggled(model.legacyObj);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xaa000000);

        super.draw(context);
    }
}

==================================================

--- Файл №97 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\tabs\GuiModelPoses.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.GuiModelEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiTwoElement;
import mchorse.blockbuster.client.gui.utils.GuiShapeKeysEditor;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiListModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiMessageModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;

import java.util.List;
import java.util.function.Consumer;

public class GuiModelPoses extends GuiModelEditorTab
{
    private GuiIconElement addPose;
    private GuiIconElement removePose;
    private GuiIconElement copyPose;
    private GuiIconElement applyPose;

    private GuiStringListElement posesList;
    private GuiShapeKeysEditor shapeKeys;
    private GuiTwoElement hitbox;
    private GuiElement bottom;

    private String pose;

    public static GuiSimpleContextMenu createCopyPasteMenu(Runnable copy, Consumer<ModelPose> paste)
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        ModelPose pose = null;

        try
        {
            NBTTagCompound tag = JsonToNBT.getTagFromJson(GuiScreen.getClipboardString());
            ModelPose loaded = new ModelPose();

            loaded.fromNBT(tag);

            pose = loaded;
        }
        catch (Exception e)
        {}

        menu.action(Icons.COPY, IKey.lang("blockbuster.gui.me.poses.context.copy"), copy);

        if (pose != null)
        {
            final ModelPose innerPose = pose;

            menu.action(Icons.PASTE, IKey.lang("blockbuster.gui.me.poses.context.paste"), () -> paste.accept(innerPose));
        }

        return menu;
    }

    public GuiModelPoses(Minecraft mc, GuiModelEditorPanel panel)
    {
        super(mc, panel);

        this.title = IKey.lang("blockbuster.gui.me.poses.title");

        this.hitbox = new GuiTwoElement(mc, (values) ->
        {
            this.panel.pose.size[0] = values[0].floatValue();
            this.panel.pose.size[1] = values[1].floatValue();
            this.panel.dirty();
        });

        /* Buttons */
        this.addPose = new GuiIconElement(mc, Icons.ADD, (b) -> this.addPose());
        this.removePose = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.removePose());
        this.copyPose = new GuiIconElement(mc, Icons.COPY, (b) -> this.copyPose());
        this.copyPose.tooltip(IKey.lang("blockbuster.gui.me.poses.copy_pose_tooltip"));
        this.applyPose = new GuiIconElement(mc, Icons.PASTE, (b) -> this.applyPose());
        this.applyPose.tooltip(IKey.lang("blockbuster.gui.me.poses.apply_pose_tooltip"));

        GuiElement sidebar = Elements.row(mc, 0, 0, 20, this.addPose, this.removePose, this.copyPose, this.applyPose);
        this.bottom = new GuiElement(mc);

        sidebar.flex().relative(this).x(1F).h(20).anchorX(1F).row(0).resize();
        this.bottom.flex().relative(this).y(1F).w(1F).anchorY(1F).column(5).vertical().stretch().height(20).padding(10);

        this.posesList = new GuiStringListElement(mc, (str) -> this.setPose(str.get(0)));
        this.posesList.flex().relative(this).y(20).w(1F).hTo(bottom.area);
        this.posesList.context(() ->
        {
            GuiSimpleContextMenu menu = createCopyPasteMenu(this::copyCurrentPose, this::pastePose);

            menu.action(Icons.EDIT, IKey.lang("blockbuster.gui.me.poses.context.rename"), this::renamePose);

            return menu;
        });

        this.shapeKeys = new GuiShapeKeysEditor(mc, () -> this.panel.model);
        this.shapeKeys.flex().relative(this.posesList).y(1F, 10).x(10).w(1F, -20).hTo(this.hitbox.area, -27);

        this.bottom.add(Elements.label(IKey.lang("blockbuster.gui.me.poses.hitbox")), this.hitbox);
        this.add(sidebar, this.bottom, this.posesList);
    }

    private void copyCurrentPose()
    {
        GuiScreen.setClipboardString(this.panel.pose.toNBT(new NBTTagCompound()).toString());
    }

    private void pastePose(ModelPose pose)
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(mc, IKey.lang("blockbuster.gui.me.poses.paste_pose"), (text) ->
            {
                this.addPose(text, pose);
            });

            String base = "pasted_pose";
            String name = base;
            int index = 1;

            while (this.panel.model.poses.containsKey(name))
            {
                name = base + "_" + (index++);
            }

            return modal.setValue(name);
        });
    }

    private void renamePose()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(mc, IKey.lang("blockbuster.gui.me.poses.rename_pose"), this::renamePose);

            return modal.setValue(this.pose);
        });
    }

    private void renamePose(String name)
    {
        if (!this.panel.model.poses.containsKey(name))
        {
            this.panel.model.poses.put(name, this.panel.model.poses.remove(this.pose));
            this.posesList.remove(this.pose);
            this.posesList.add(name);
            this.posesList.sort();
            this.panel.setPose(name, true);
            this.panel.dirty();
        }
    }

    private void addPose()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(mc, IKey.lang("blockbuster.gui.me.poses.new_pose"), this::addPose);

            return modal.setValue(this.pose);
        });
    }

    private void addPose(String pose)
    {
        this.addPose(pose, this.panel.pose == null ? new ModelPose() : this.panel.pose.copy());
    }

    private void addPose(String name, ModelPose pose)
    {
        if (!this.panel.model.poses.containsKey(name))
        {
            this.panel.model.poses.put(name, pose);
            this.posesList.add(name);
            this.posesList.sort();
            this.panel.setPose(name, true);
            this.panel.dirty();
        }
    }

    private void removePose()
    {
        if (Model.REQUIRED_POSES.contains(this.pose))
        {
            GuiModal.addFullModal(this, () -> new GuiMessageModal(this.mc, IKey.lang("blockbuster.gui.me.poses.standard")));
        }
        else
        {
            this.panel.model.poses.remove(this.pose);

            String newPose = null;
            int index = this.posesList.getIndex();
            int size = this.posesList.getList().size();

            if (index > 0 && size > 1)
            {
                newPose = this.posesList.getList().get(this.posesList.getIndex() - 1);
            }
            else if (index == 0 && size > 1)
            {
                newPose = this.posesList.getList().get(1);
            }

            if (newPose == null)
            {
                newPose = this.panel.model.poses.keySet().iterator().next();
            }

            this.posesList.remove(this.pose);
            this.setPose(newPose);
            this.panel.dirty();
        }
    }

    private void copyPose()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiListModal modal = new GuiListModal(this.mc, IKey.lang("blockbuster.gui.me.poses.copy_pose"), this::copyPose);

            return modal.addValues(this.panel.model.poses.keySet());
        });
    }

    private void copyPose(String text)
    {
        ModelPose pose = this.panel.model.poses.get(text);

        if (pose == null)
        {
            return;
        }

        this.panel.transform.copy(pose.limbs.get(this.panel.limb.name));
        this.panel.dirty();
    }

    private void applyPose()
    {
        GuiModal.addFullModal(this, () ->
        {
            GuiListModal modal = new GuiListModal(this.mc, IKey.lang("blockbuster.gui.me.poses.apply_pose"), null).callback(this::copyPose);

            modal.list.getList().remove(0);
            modal.list.multi();

            modal.addValues(this.panel.model.poses.keySet());
            modal.list.selectAll();
            modal.list.toggleIndex(modal.list.getList().indexOf(this.pose));

            return modal;
        });
    }

    private void copyPose(List<String> poses)
    {
        ModelPose pose = this.panel.model.poses.get(this.pose);

        if (pose == null)
        {
            return;
        }

        ModelTransform current = pose.limbs.get(this.panel.limb.name);

        if (current == null || poses.isEmpty())
        {
            return;
        }

        for (String name : poses)
        {
            ModelPose target = this.panel.model.poses.get(name);

            if (target != null)
            {
                ModelTransform transform = target.limbs.get(this.panel.limb.name);

                if (transform != null)
                {
                    transform.copy(current);
                }
            }
        }

        this.panel.dirty();
    }

    public void setPose(String str)
    {
        this.pose = str;
        this.panel.setPose(str);
        this.fillPoseData();
    }

    public void setCurrent(String pose, boolean scroll)
    {
        this.pose = pose;

        if (scroll)
        {
            this.posesList.setCurrentScroll(pose);
        }
        else
        {
            this.posesList.setCurrent(pose);
        }

        this.fillPoseData();
    }

    public void fillData(Model model)
    {
        this.posesList.clear();
        this.posesList.add(model.poses.keySet());
        this.posesList.sort();
    }

    public void fillPoseData()
    {
        this.hitbox.setValues(this.panel.pose.size[0], this.panel.pose.size[1]);

        boolean isVisible = !this.panel.model.shapes.isEmpty();

        if (isVisible)
        {
            this.shapeKeys.fillData(this.panel.pose.shapes);

            if (!this.shapeKeys.hasParent())
            {
                this.add(this.shapeKeys);
                this.posesList.flex().h(0.4F);
            }
        }
        else
        {
            this.shapeKeys.removeFromParent();
            this.posesList.flex().hTo(this.bottom.area);
        }

        this.resize();
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xaa000000);

        super.draw(context);
    }
}

==================================================

--- Файл №98 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\utils\GuiBBModelRenderer.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils;

import java.util.List;
import java.util.Map;

import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.RenderingUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL13;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiAnchorModal;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.blockbuster.client.render.layer.LayerHeldItem;
import mchorse.mclib.client.Draw;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.RenderGlobal;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;

import javax.vecmath.Matrix4d;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;

/**
 * Model renderer which renders Blockbuster models 
 */
public class GuiBBModelRenderer extends GuiModelRenderer
{    
    public boolean swinging;
    private float swing;
    private float swingAmount;
    private int swipe;

    public boolean items;
    public boolean aabb;
    public boolean origin;
    public boolean looking = true;

    public Map<String, ResourceLocation> materials;
    public ResourceLocation texture;
    public ModelCustom model;
    public ModelLimb limb;
    public GuiAnchorModal anchorPreview;

    private ModelPose pose;
    private List<ShapeKey> shapes;
    private Matrix4d modelMatrix;

    public Matrix4d getModelMatrix()
    {
        return new Matrix4d(modelMatrix);
    }

    public static void renderItems(EntityLivingBase entity, ModelCustom model)
    {
        ItemStack main = entity.getHeldItemMainhand();
        ItemStack offhand = entity.getHeldItemOffhand();

        if (!offhand.isEmpty() || !main.isEmpty())
        {
            GlStateManager.pushMatrix();
            LayerHeldItem.renderHeldItem(entity, offhand, model, ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND, EnumHandSide.LEFT);
            LayerHeldItem.renderHeldItem(entity, main, model, ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND, EnumHandSide.RIGHT);
            GlStateManager.popMatrix();
        }
    }

    public GuiBBModelRenderer(Minecraft mc)
    {
        super(mc);
    }

    public void swipe()
    {
        this.swipe = 6;
    }

    public void toggleItems()
    {
        this.items = !this.items;
        ((DummyEntity) this.entity).toggleItems(this.items);
    }

    /**
     * Update logic
     */
    @Override
    protected void update()
    {
        super.update();

        if (this.swipe > -1)
        {
            this.swipe--;
        }

        if (this.swinging)
        {
            this.swing += 0.75F;
            this.swingAmount = 1.0F;
        }
        else
        {
            this.swing = 0.0F;
            this.swingAmount = 0.0F;
        }
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        boolean result = super.mouseClicked(context);

        if (this.dragging && GuiScreen.isCtrlKeyDown())
        {
            this.tryPicking = true;
            this.dragging = false;
        }

        return result;
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);
        this.tryPicking = false;
    }

    protected float getScale()
    {
        return 1;
    }

    @Override
    protected void drawUserModel(GuiContext context)
    {
        if (this.model == null)
        {
            return;
        }

        float partial = context.partialTicks;
        float headYaw = this.yaw - (this.customEntity ? this.entityYawBody : 0);
        float headPitch = -this.pitch;

        final float factor = 1 / 16F;
        float limbSwing = this.swinging ? this.swing + partial : 0;

        if (!this.looking)
        {
            headYaw = this.customEntity ? this.entityYawHead - this.entityYawBody : 0;
            headPitch = this.customEntity ? this.entityPitch : 0;
        }

        this.updateModel(limbSwing, headYaw, headPitch, factor, partial);

        float scale = this.getScale();

        GlStateManager.pushMatrix();
        GlStateManager.scale(model.model.scale[0], model.model.scale[1], model.model.scale[2]);
        GlStateManager.scale(-1.0F * scale, -1.0F * scale, 1.0F * scale);
        GlStateManager.translate(0.0F, -1.501F, 0.0F);
        GlStateManager.rotate(180 + (this.customEntity ? this.entityYawBody : 0), 0, 1, 0);
        this.modelMatrix = MatrixUtils.readModelViewDouble();

        if (this.texture != null)
        {
            RenderCustomModel.bindLastTexture(this.texture);
        }

        this.tryPicking(context);
        this.renderModel(this.entity, headYaw, headPitch, this.customEntity ? this.entityTicksExisted : this.timer, context.mouseX, context.mouseY, partial, factor);

        if (this.items)
        {
            renderItems(this.entity, this.model);
        }

        /* Render highlighting things on top */
        this.updateModel(limbSwing, headYaw, headPitch, factor, partial);

        GlStateManager.pushMatrix();
        GlStateManager.disableTexture2D();
        GlStateManager.disableDepth();
        GlStateManager.disableLighting();

        if (this.limb != null)
        {
            ModelCustomRenderer targetLimb = this.model.get(this.limb.name);

            if (targetLimb != null)
            {
                if (model.limbs.length > 1)
                {
                    if (targetLimb.getClass() != ModelCustomRenderer.class)
                    {
                        this.renderObjHighlight(targetLimb);
                    }
                    else
                    {
                        targetLimb.postRender(1F / 16F);
                        this.renderLimbHighlight(this.limb);
                    }
                }
                else
                {
                    if (this.origin)
                    {
                        targetLimb.postRender(1F / 16F);
                        this.drawAxis(targetLimb, 0.25F);
                    }
                }

                this.renderAnchorPreview(targetLimb);
            }
        }

        GlStateManager.enableLighting();
        GlStateManager.enableDepth();
        GlStateManager.enableTexture2D();
        GlStateManager.popMatrix();

        GlStateManager.popMatrix();

        if (this.aabb)
        {
            this.renderAABB();
        }
    }

    protected void drawAxis(ModelCustomRenderer target, float length)
    {
        GlStateManager.pushMatrix();

        if (GuiTransformations.GuiStaticTransformOrientation.getOrientation() == GuiTransformations.TransformOrientation.GLOBAL)
        {
            RenderingUtils.glRevertRotationScale(new Vector3d(target.rotateAngleX, target.rotateAngleY, target.rotateAngleZ),
                                                 new Vector3d(target.scaleX, target.scaleY, target.scaleZ),
                                                 MatrixUtils.RotationOrder.XYZ);
        }

        Draw.axis(length);
        GlStateManager.popMatrix();
    }

    protected void updateModel(float limbSwing, float headYaw, float headPitch, float factor, float partial)
    {
        this.model.materials = this.materials;
        this.model.shapes = this.shapes;
        this.model.pose = this.pose;
        this.model.swingProgress = this.swipe == -1 ? 0 : MathHelper.clamp(1.0F - (this.swipe - 1.0F * partial) / 6.0F, 0.0F, 1.0F);
        this.model.setLivingAnimations(this.entity, headYaw, headPitch, partial);
        this.model.setRotationAngles(limbSwing, this.swingAmount, this.customEntity ? this.entityTicksExisted : this.timer, headYaw, headPitch, factor, this.entity);
    }

    protected void renderModel(EntityLivingBase dummy, float headYaw, float headPitch, int timer, int yaw, int pitch, float partial, float factor)
    {
        this.model.render(dummy, headYaw, headPitch, timer, yaw, pitch, factor);
    }

    @Override
    protected void drawForStencil(GuiContext context)
    {
        if (this.model != null)
        {
            this.model.renderForStencil(this.entity, this.swing + context.partialTicks, this.swingAmount, this.customEntity ? this.entityTicksExisted : this.timer, this.yaw, this.pitch, 1 / 16F);
        }
    }

    @Override
    protected String getStencilValue(int value)
    {
        return this.model.limbs[value - 1].limb.name;
    }

    /**
     * Render limb highlight and the anchor and origin point of the limb 
     */
    protected void renderLimbHighlight(ModelLimb limb)
    {
        float f = 1F / 16F;
        float w = limb.size[0] * f;
        float h = limb.size[1] * f;
        float d = limb.size[2] * f;
        float o = limb.sizeOffset * f;

        float minX = 0;
        float minY = 0;
        float minZ = 0;
        float maxX = w;
        float maxY = h;
        float maxZ = d;
        float alpha = 0.2F;

        minX -= w * limb.anchor[0] + 0.1F * f;
        maxX -= w * limb.anchor[0] - 0.1F * f;
        minY -= h * limb.anchor[1] + 0.1F * f;
        maxY -= h * limb.anchor[1] - 0.1F * f;
        minZ -= d * limb.anchor[2] + 0.1F * f;
        maxZ -= d * limb.anchor[2] - 0.1F * f;

        minX *= -1;
        maxX *= -1;

        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();

        Draw.cube(minX + o, minY - o, minZ -o, maxX - o, maxY + o, maxZ + o, 0F, 0.5F, 1F, alpha);

        GlStateManager.disableAlpha();
        GlStateManager.disableBlend();

        if (this.origin)
        {
            this.drawAxis(this.model.get(limb.name), 0.25F);
        }
    }
    
    protected void renderObjHighlight(ModelCustomRenderer renderer)
    {
        float f = 1F / 16F;
        
        GlStateManager.pushMatrix();
        
        GL11.glClearStencil(0);
        GL11.glClear(GL11.GL_STENCIL_BUFFER_BIT);
        GL11.glEnable(GL11.GL_STENCIL_TEST);
        GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_REPLACE, GL11.GL_REPLACE);
        GL11.glColorMask(false, false, false, false);
        
        if (renderer.parent != null)
        {
            renderer.parent.postRender(f);
        }

        List<ModelRenderer> children = renderer.childModels;
        renderer.childModels = null;
        renderer.setupStencilRendering(1);
        renderer.render(f);
        renderer.childModels = children;

        GL11.glStencilMask(0);
        GL11.glStencilFunc(GL11.GL_EQUAL, 1, -1);
        GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_KEEP);
        GL11.glColorMask(true, true, true, true);
        
        GL11.glLoadIdentity();
        GlStateManager.matrixMode(GL11.GL_PROJECTION);
        GlStateManager.pushMatrix();
        GL11.glLoadIdentity();

        GlStateManager.enableBlend();
        GlStateManager.color(0F, 0.5F, 1F, 0.2F);
        
        GL11.glBegin(GL11.GL_TRIANGLE_STRIP);
        GL11.glVertex3f(-1.0F, -1.0F, 0.0F);
        GL11.glVertex3f(1.0F, -1.0F, 0.0F);
        GL11.glVertex3f(-1.0F, 1.0F, 0.0F);
        GL11.glVertex3f(1.0F, 1.0F, 0.0F);
        GL11.glEnd();
        GL11.glFlush();
        
        GlStateManager.color(1F, 1F, 1F, 1F);
        GlStateManager.disableBlend();
        
        GL11.glStencilMask(-1);
        GL11.glStencilFunc(GL11.GL_NEVER, 0, 0);
        GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_KEEP);
        GL11.glDisable(GL11.GL_STENCIL_TEST);
        
        GlStateManager.popMatrix();
        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
        GlStateManager.popMatrix();

        renderer.postRender(f);

        if (this.origin)
        {
            this.drawAxis(renderer, 0.25F);
        }
    }

    /**
     * Render model's hitbox
     */
    protected void renderAABB()
    {
        ModelPose current = this.pose;

        float minX = -current.size[0] / 2.0F;
        float maxX = current.size[0] / 2.0F;
        float minY = 0.0F;
        float maxY = current.size[1];
        float minZ = -current.size[0] / 2.0F;
        float maxZ = current.size[0] / 2.0F;

        GlStateManager.depthMask(false);
        GlStateManager.disableTexture2D();
        GlStateManager.disableLighting();
        GlStateManager.disableCull();
        GlStateManager.disableBlend();
        /* This is necessary to hid / lines which are used to reduce 
         * amount of drawing operations */
        GlStateManager.enableAlpha();

        RenderGlobal.drawBoundingBox(minX, minY, minZ, maxX, maxY, maxZ, 1.0F, 1.0F, 1.0F, 1.0F);

        GlStateManager.enableTexture2D();
        GlStateManager.enableLighting();
        GlStateManager.enableCull();
        GlStateManager.disableBlend();
        GlStateManager.depthMask(true);
    }

    protected void renderAnchorPreview(ModelCustomRenderer renderer)
    {
        if (this.anchorPreview != null && renderer.min != null && renderer.max != null)
        {
            float ax = (float) this.anchorPreview.vector.a.value;
            float ay = (float) this.anchorPreview.vector.b.value;
            float az = (float) this.anchorPreview.vector.c.value;

            float dx = renderer.max.x - renderer.min.x;
            float dy = renderer.max.y - renderer.min.y;
            float dz = renderer.max.z - renderer.min.z;

            float x = renderer.min.x + Interpolations.lerp(0, dx, ax) - this.limb.origin[0];
            float y = renderer.min.y + Interpolations.lerp(0, dy, ay) - this.limb.origin[1];
            float z = renderer.min.z + Interpolations.lerp(0, dz, az) - this.limb.origin[2];

            GlStateManager.disableLighting();
            GlStateManager.disableTexture2D();
            GlStateManager.disableDepth();

            GlStateManager.pushMatrix();
            GlStateManager.translate(-x, -y, z);

            Draw.point(0, 0, 0);

            GlStateManager.popMatrix();

            GlStateManager.enableDepth();
            GlStateManager.enableTexture2D();
            GlStateManager.enableLighting();
        }
    }

    public void setPose(ModelPose pose)
    {
        this.setPose(pose, pose == null ? null : pose.shapes);
    }

    public void setPose(ModelPose pose, List<ShapeKey> shapes)
    {
        this.pose = pose;
        this.shapes = shapes;
    }
}

==================================================

--- Файл №99 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\utils\GuiPoseTransformations.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils;

import mchorse.blockbuster.api.ModelTransform;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import net.minecraft.client.Minecraft;

public class GuiPoseTransformations extends GuiTransformations
{
    public ModelTransform trans;
    public ModelTransform oldTransform;

    public GuiPoseTransformations(Minecraft mc)
    {
        super(mc);
    }

    public void set(ModelTransform trans)
    {
        this.set(trans, null);
    }

    public void set(ModelTransform trans, ModelTransform oldTransform)
    {
        this.trans = trans;
        this.oldTransform = oldTransform;

        if (trans != null)
        {
            this.fillT(trans.translate[0], trans.translate[1], trans.translate[2]);
            this.fillS(trans.scale[0], trans.scale[1], trans.scale[2]);
            this.fillR(trans.rotate[0], trans.rotate[1], trans.rotate[2]);
        }
    }

    @Override
    public void localTranslate(double x, double y, double z)
    {
        this.trans.addTranslation(x, y, z, GuiStaticTransformOrientation.getOrientation());

        this.fillT(this.trans.translate[0], this.trans.translate[1], this.trans.translate[2]);
    }

    @Override
    public void setT(double x, double y, double z)
    {
        this.trans.translate[0] = (float) x;
        this.trans.translate[1] = (float) y;
        this.trans.translate[2] = (float) z;
    }

    @Override
    public void setS(double x, double y, double z)
    {
        this.trans.scale[0] = (float) x;
        this.trans.scale[1] = (float) y;
        this.trans.scale[2] = (float) z;
    }

    @Override
    public void setR(double x, double y, double z)
    {
        this.trans.rotate[0] = (float) x;
        this.trans.rotate[1] = (float) y;
        this.trans.rotate[2] = (float) z;
    }

    @Override
    protected void reset()
    {
        if (this.oldTransform == null)
        {
            super.reset();
        }
        else
        {
            this.fillSetT(this.oldTransform.translate[0], this.oldTransform.translate[1], this.oldTransform.translate[2]);
            this.fillSetS(this.oldTransform.scale[0], this.oldTransform.scale[1], this.oldTransform.scale[2]);
            this.fillSetR(this.oldTransform.rotate[0], this.oldTransform.rotate[1], this.oldTransform.rotate[2]);
        }
    }
}

==================================================

--- Файл №100 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\utils\GuiTextureCanvas.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiModelLimbs;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiCanvasEditor;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.util.ResourceLocation;

public class GuiTextureCanvas extends GuiCanvasEditor
{
    public GuiTrackpadElement x;
    public GuiTrackpadElement y;
    public GuiIconElement close;

    public GuiModelLimbs panel;

    public GuiTextureCanvas(Minecraft mc, GuiModelLimbs panel)
    {
        super(mc);

        this.panel = panel;

        this.close = new GuiIconElement(mc, Icons.CLOSE, (b) -> this.toggleVisible());
        this.close.flex().relative(this).x(1F, -25).y(5);

        this.x = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.getPanel().limb.texture[0] = value.intValue();
            this.panel.getPanel().rebuildModel();
        });
        this.x.limit(0, 8192, true);

        this.y = new GuiTrackpadElement(mc, (value) ->
        {
            this.panel.getPanel().limb.texture[1] = value.intValue();
            this.panel.getPanel().rebuildModel();
        });
        this.y.limit(0, 8192, true);

        this.editor.add(Elements.label(IKey.lang("blockbuster.gui.me.limbs.texture")).background(), this.x, this.y);
        this.add(this.editor, this.close);

        this.markContainer();
    }

    @Override
    protected boolean shouldDrawCanvas(GuiContext context)
    {
        return this.panel.getPanel().modelRenderer.texture != null;
    }

    @Override
    protected void drawCanvasFrame(GuiContext guiContext)
    {
        ResourceLocation location = this.panel.getPanel().modelRenderer.texture;
        Area area = this.calculate(-this.w / 2, -this.h / 2, this.w / 2, this.h / 2);

        this.mc.renderEngine.bindTexture(location);
        GuiDraw.drawBillboard(area.x, area.y, 0, 0, area.w, area.h, area.w, area.h);

        ModelLimb limb = this.panel.getPanel().limb;
        int lx = limb.texture[0];
        int ly = limb.texture[1];
        int lw = limb.size[0];
        int lh = limb.size[1];
        int ld = limb.size[2];

        /* Top and bottom */
        area = this.calculateRelative(lx + ld, ly, lx + ld + lw, ly + ld);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x5500ff00);

        area = this.calculateRelative(lx + ld + lw, ly, lx + ld + lw + lw, ly + ld);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x5500ffff);

        /* Front and back */
        area = this.calculateRelative(lx + ld, ly + ld, lx + ld + lw, ly + ld + lh);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x550000ff);

        area = this.calculateRelative(lx + ld * 2 + lw, ly + ld, lx + ld * 2 + lw * 2, ly + ld + lh);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x55ff00ff);

        /* Left and right */
        area = this.calculateRelative(lx, ly + ld, lx + ld, ly + ld + lh);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x55ff0000);

        area = this.calculateRelative(lx + ld + lw, ly + ld, lx + ld * 2 + lw, ly + ld + lh);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x55ffff00);

        /* Holes */
        area = this.calculateRelative(lx, ly, lx + ld, ly + ld);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0xdd000000);

        area = this.calculateRelative(lx + ld + lw * 2, ly, lx + ld * 2 + lw * 2, ly + ld);

        Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0xdd000000);

        /* Outline */
        area = this.calculateRelative(lx, ly, lx + ld * 2 + lw * 2, ly + ld + lh);

        GuiDraw.drawOutline(area.x, area.y, area.ex(), area.ey(), 0xffff0000);
    }
}

==================================================

--- Файл №101 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\utils\GuiThreeElement.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils;

import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.resizers.Flex;
import net.minecraft.client.Minecraft;

import java.util.function.Consumer;

public class GuiThreeElement extends GuiTwoElement
{
    public GuiTrackpadElement c;

    public GuiThreeElement(Minecraft mc, Consumer<Double[]> callback)
    {
        super(mc, callback);

        this.array = new Double[] {0D, 0D, 0D};
        this.c = new GuiTrackpadElement(mc, (value) ->
        {
            this.array[2] = value;

            if (callback != null)
            {
                callback.accept(this.array);
            }
        });
        this.add(this.c);
    }

    @Override
    public void setLimit(int min, int max)
    {
        super.setLimit(min, max);
        this.c.min = min;
        this.c.max = max;
    }

    @Override
    public void setLimit(int min, int max, boolean integer)
    {
        super.setLimit(min, max, integer);
        this.c.limit(min, max, integer);
    }

    public void setValues(double a, double b, double c)
    {
        this.setValues(a, b);
        this.c.setValue(c);

        this.array[2] = c;
    }
}

==================================================

--- Файл №102 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\utils\GuiTwoElement.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.resizers.Flex;
import net.minecraft.client.Minecraft;

import java.util.function.Consumer;

public class GuiTwoElement extends GuiElement
{
    public GuiTrackpadElement a;
    public GuiTrackpadElement b;
    public Double[] array;

    public GuiTwoElement(Minecraft mc, Consumer<Double[]> callback)
    {
        super(mc);

        this.array = new Double[] {0D, 0D};
        this.a = new GuiTrackpadElement(mc, (value) ->
        {
            this.array[0] = value;

            if (callback != null)
            {
                callback.accept(this.array);
            }
        });
        this.b = new GuiTrackpadElement(mc, (value) ->
        {
            this.array[1] = value;

            if (callback != null)
            {
                callback.accept(this.array);
            }
        });

        this.flex().h(20).row(5);
        this.add(this.a, this.b);
    }

    public void setLimit(int min, int max)
    {
        this.a.limit(min, max);
        this.b.limit(min, max);
    }

    public void setLimit(int min, int max, boolean integer)
    {
        this.a.limit(min, max, integer);
        this.b.limit(min, max, integer);
    }

    public void setValues(double a, double b)
    {
        this.a.setValue(a);
        this.b.setValue(b);

        this.array[0] = a;
        this.array[1] = b;
    }
}

==================================================

--- Файл №103 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\model_editor\utils\ModelUtils.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils;

import java.io.StringWriter;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.stream.JsonWriter;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.json.ModelAdapter;
import mchorse.blockbuster.api.json.ModelLimbAdapter;
import mchorse.blockbuster.api.json.ModelPoseAdapter;

/**
 * Model utilities
 *
 * This code might be transferred to Metamorph, since this code is actually
 * supposed to be in {@link Model} class.
 */
public class ModelUtils
{
    /**
     * Save model to JSON
     *
     * This method is responsible for making the JSON output pretty printed and
     * 4 spaces indented (fuck 2 space indentation).
     */
    public static String toJson(Model model)
    {
        GsonBuilder builder = new GsonBuilder().setPrettyPrinting();

        builder.registerTypeAdapter(Model.class, new ModelAdapter());
        builder.registerTypeAdapter(ModelLimb.class, new ModelLimbAdapter());
        builder.registerTypeAdapter(ModelPose.class, new ModelPoseAdapter());
        builder.excludeFieldsWithoutExposeAnnotation();

        Gson gson = builder.create();
        StringWriter writer = new StringWriter();
        JsonWriter jsonWriter = new JsonWriter(writer);

        jsonWriter.setIndent("    ");
        gson.toJson(model, Model.class, jsonWriter);

        String output = writer.toString();

        /* Prettify arrays */
        output = output.replaceAll("\\n\\s+(?=-?\\d|\\])", " ");

        return output;
    }
}

==================================================

--- Файл №104 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\GuiRecordingEditorPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions.*;
import mchorse.blockbuster.events.ActionPanelRegisterEvent;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestAction;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestActions;
import mchorse.blockbuster.network.common.scene.PacketSceneRecord;
import mchorse.blockbuster.network.common.scene.sync.PacketScenePlay;
import mchorse.blockbuster.network.server.recording.actions.ServerHandlerActionsChange;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.*;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiDelegateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiLabelSearchListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.MinecraftForge;
import org.lwjgl.input.Keyboard;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GuiRecordingEditorPanel extends GuiBlockbusterPanel
{
    /**
     * A map of action editing panels mapped to their classes  
     */
    public Map<Class<? extends Action>, GuiActionPanel<? extends Action>> panels = new HashMap<Class<? extends Action>, GuiActionPanel<? extends Action>>();

    public GuiRecordList records;
    public GuiRecordTimeline timeline;
    public GuiDelegateElement<GuiActionPanel<? extends Action>> actionEditor;

    public GuiIconElement add;
    public GuiIconElement dupe;
    public GuiIconElement remove;
    public GuiIconElement capture;

    public GuiIconElement cut;
    public GuiIconElement copy;
    public GuiIconElement paste;
    public GuiIconElement teleport;

    public GuiIconElement open;
    public GuiLabelSearchListElement<String> list;

    public Record record;
    public NBTTagCompound buffer;

    public GuiRecordingEditorPanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        this.timeline = new GuiRecordTimeline(mc, this);
        this.timeline.setVisible(false);
        this.records = new GuiRecordList(mc, this);
        this.actionEditor = new GuiDelegateElement<GuiActionPanel<? extends Action>>(mc, null);

        /* Add/remove */
        this.add = new GuiIconElement(mc, Icons.ADD, (b) -> this.list.toggleVisible());
        this.add.tooltip(IKey.lang("blockbuster.gui.add"), Direction.LEFT);
        this.dupe = new GuiIconElement(mc, Icons.DUPE, (b) -> this.timeline.dupeActions());
        this.dupe.tooltip(IKey.lang("blockbuster.gui.duplicate"), Direction.LEFT);
        this.remove = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.timeline.removeActions());
        this.remove.tooltip(IKey.lang("blockbuster.gui.remove"), Direction.LEFT);
        this.capture = new GuiIconElement(mc, Icons.SPHERE, (b) -> this.capture());
        this.capture.tooltip(IKey.lang("blockbuster.gui.record_editor.capture"), Direction.LEFT);

        this.cut = new GuiIconElement(mc, Icons.CUT, (icon) -> this.timeline.cutActions());
        this.cut.tooltip(IKey.lang("blockbuster.gui.record_editor.cut"), Direction.RIGHT);
        this.copy = new GuiIconElement(mc, Icons.COPY, (icon) -> this.timeline.copyActions());
        this.copy.tooltip(IKey.lang("blockbuster.gui.record_editor.copy"), Direction.RIGHT);
        this.paste = new GuiIconElement(mc, Icons.PASTE, (b) -> this.timeline.pasteActions());
        this.paste.tooltip(IKey.lang("blockbuster.gui.record_editor.paste"), Direction.RIGHT);
        this.teleport = new GuiIconElement(mc, Icons.MOVE_TO, (b) -> this.teleport());
        this.teleport.tooltip(IKey.lang("blockbuster.gui.record_editor.teleport"), Direction.RIGHT);

        this.list = new GuiLabelSearchListElement<String>(mc, (str) ->
        {
            this.timeline.createAction(str.get(0).value);
            this.list.setVisible(false);
        });
        this.list.label(IKey.lang("blockbuster.gui.search"));
        this.list.list.background();

        for (String key : ActionRegistry.NAME_TO_CLASS.keySet())
        {
            IKey title = IKey.lang("blockbuster.gui.record_editor.actions." + key + ".title");

            this.list.list.add(new Label<String>(title, key));
        }

        this.list.filter("", false);

        this.add.flex().relative(this.timeline).x(1F);
        this.dupe.flex().relative(this.add.resizer()).y(20);
        this.remove.flex().relative(this.dupe.resizer()).y(20);
        this.capture.flex().relative(this.remove.resizer()).y(20);
        this.cut.flex().relative(this.timeline).x(-20);
        this.copy.flex().relative(this.cut.resizer()).y(20);
        this.paste.flex().relative(this.copy.resizer()).y(20);
        this.teleport.flex().relative(this.paste.resizer()).y(20);
        this.list.flex().set(0, 0, 80, 80).relative(this.timeline.area).x(1, -80);

        this.open = new GuiIconElement(mc, Icons.MORE, (b) -> this.records.toggleVisible());
        this.open.flex().relative(this.area).set(0, 2, 24, 24).x(1, -28);

        this.add(this.open);
        this.timeline.add(this.add, this.dupe, this.remove, this.capture, this.cut, this.copy, this.paste, this.teleport, this.list);

        IKey category = IKey.lang("blockbuster.gui.aperture.keys.category");

        this.timeline.keys().register(IKey.lang("blockbuster.gui.record_editor.capture"), Keyboard.KEY_R, this::capture)
            .held(Keyboard.KEY_LCONTROL).category(category);
        this.timeline.keys().register(IKey.lang("blockbuster.gui.record_editor.teleport"), Keyboard.KEY_T, this::teleport)
            .held(Keyboard.KEY_LCONTROL).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.aperture.keys.toggle_list"), Keyboard.KEY_L, () -> this.open.clickItself(GuiBase.getCurrent()))
            .held(Keyboard.KEY_LCONTROL).category(category);
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public GuiActionPanel<? extends Action> getActionPanel(Action action)
    {
        if (action == null)
        {
            return null;
        }

        GuiActionPanel panel = this.panels.get(action.getClass());

        if (panel == null)
        {
            panel = this.panels.get(Action.class);
        }

        panel.fill(action);

        return panel;
    }

    private void capture()
    {
        if (this.record == null)
        {
            return;
        }

        int offset = this.getOffset();

        if (offset >= 0)
        {
            SceneLocation scene = CameraHandler.isCameraEditorOpen() ? CameraHandler.get() : null;

            CameraHandler.closeScreenOrCameraEditor();

            if (scene != null)
            {
                Dispatcher.sendToServer(new PacketScenePlay(scene, PacketScenePlay.STOP, 0));
            }

            Dispatcher.sendToServer(new PacketSceneRecord(scene, this.record.filename, offset));
        }
    }

    private void teleport()
    {
        if (this.record == null)
        {
            return;
        }

        int offset = this.getOffset();

        if (offset >= 0)
        {
            SceneLocation scene = CameraHandler.get();

            if (scene != null)
            {
                Dispatcher.sendToServer(new PacketScenePlay(scene, PacketScenePlay.STOP, 0));
            }

            GuiBase.getCurrent().screen.closeThisScreen();

            RecordUtils.applyFrameOnEntity(Minecraft.getMinecraft().player, this.record, offset - record.preDelay);
        }
    }

    private int getOffset()
    {
        return this.timeline.getCurrentTick();
    }

    @Override
    public void open()
    {
        this.records.clear();
        Dispatcher.sendToServer(new PacketRequestActions());

        this.timeline.removeFromParent();
        this.timeline.flex().reset().relative(this.area).x(20).y(1F, -80).h(80).w(1F, -40);
        this.actionEditor.removeFromParent();
        this.actionEditor.flex().reset().relative(this.area).w(1F).h(1, -80);
        this.records.removeFromParent();
        this.records.flex().reset().relative(this).w(120).x(1, -120).hTo(this.timeline.flex());

        this.prepend(this.records);
        this.add(this.actionEditor, this.timeline);

        this.updateEditorWidth();

        if (this.record != null && this.record != ClientProxy.manager.records.get(this.record.filename))
        {
            this.selectRecord(this.record.filename);
        }

        if (this.panels.isEmpty())
        {
            GuiEmptyActionPanel empty = new GuiEmptyActionPanel(this.mc, this);

            this.panels.put(Action.class, empty);
            this.panels.put(ChatAction.class, new GuiChatActionPanel(this.mc, this));
            this.panels.put(DropAction.class, new GuiDropActionPanel(this.mc, this));
            this.panels.put(EquipAction.class, new GuiEquipActionPanel(this.mc, this));
            this.panels.put(HotbarChangeAction.class, new GuiHotbarChangeActionPanel(this.mc, this));
            this.panels.put(ShootArrowAction.class, new GuiShootArrowActionPanel(this.mc, this));
            this.panels.put(PlaceBlockAction.class, new GuiPlaceBlockActionPanel(this.mc, this));
            this.panels.put(MountingAction.class, new GuiMountingActionPanel(this.mc, this));
            this.panels.put(InteractBlockAction.class, new GuiBlockActionPanel<InteractBlockAction>(this.mc, this));
            this.panels.put(BreakBlockAction.class, new GuiBreakBlockActionPanel(this.mc, this));
            this.panels.put(MorphAction.class, new GuiMorphActionPanel(this.mc, this));
            this.panels.put(AttackAction.class, new GuiDamageActionPanel(this.mc, this));
            this.panels.put(DamageAction.class, new GuiDamageActionPanel(this.mc, this));
            this.panels.put(CommandAction.class, new GuiCommandActionPanel(this.mc, this));
            this.panels.put(BreakBlockAnimation.class, new GuiBreakBlockAnimationPanel(this.mc, this));
            this.panels.put(ItemUseAction.class, new GuiItemUseActionPanel<ItemUseAction>(this.mc, this));
            this.panels.put(ItemUseBlockAction.class, new GuiItemUseBlockActionPanel(this.mc, this));
            this.panels.put(InteractEntityAction.class, new GuiInteractEntityActionPanel(this.mc, this));

            MinecraftForge.EVENT_BUS.post(new ActionPanelRegisterEvent(this));
        }
    }

    @Override
    public void appear()
    {
        super.appear();

        ClientProxy.panels.picker((morph) ->
        {
            if (this.actionEditor.delegate != null)
            {
                this.actionEditor.delegate.setMorph(morph);
            }
        });
    }

    @Override
    public void close()
    {
        this.saveAction();
    }

    public void saveAction()
    {
        if (this.actionEditor.delegate != null && this.record != null)
        {
            this.actionEditor.delegate.disappear();

            if (this.actionEditor.delegate.action != null)
            {
                /* so this method is independent from the current tick and index of GuiRecordTimeline */
                int[] found = this.record.findAction(this.actionEditor.delegate.action);

                if (found[0] != -1 && found[1] != -1)
                {
                    /* save the old action */
                    ServerHandlerActionsChange.editAction(this.actionEditor.delegate.action, this.record, found[0], found[1]);
                }
            }
            //TODO out of scope for this method to reset delegate GUI
            this.actionEditor.delegate = null;
        }
    }

    public void addRecords(List<String> records)
    {
        this.records.add(records);

        if (this.record != null)
        {
            this.records.records.list.setCurrent(this.record.filename);
        }
    }

    /**
     * Select the record by the filename - request actions from the server
     * @param str
     */
    public void selectRecord(String str)
    {
        //this.timeline.reset();
        this.saveAction();
        Dispatcher.sendToServer(new PacketRequestAction(str, true));
    }

    //TODO This needs refactoring... data flow is not clear and ClientHandlerActions receiver shouldn't control GUI...
    /**
     * When the server sends back actions after the request {@link #selectRecord(String)} - select the recording
     * @param record
     */
    public void selectRecord(Record record)
    {
        this.record = record;
        this.timeline.setVisible(record != null);
        this.timeline.reset();
        this.setDelegate(null);
        this.list.setVisible(false);
    }

    public void reselectRecord(Record record)
    {
        if (this.record != null && this.record.filename.equals(record.filename))
        {
            this.record.preDelay = record.preDelay;
            this.record.postDelay = record.postDelay;
        }
    }

    public void selectAction(Action action)
    {
        this.setDelegate(this.getActionPanel(action));
    }

    public void updateEditorWidth()
    {
        if (this.records.isVisible())
        {
            this.actionEditor.flex().wTo(this.records.area);
        }
        else
        {
            this.actionEditor.flex().w(1F);
        }

        this.actionEditor.resize();
    }

    public void setDelegate(GuiActionPanel<? extends Action> panel)
    {
        if (this.actionEditor.delegate != null)
        {
            this.actionEditor.delegate.disappear();
        }

        this.actionEditor.setDelegate(panel);
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.record == null)
        {
            this.drawCenteredString(this.font, I18n.format("blockbuster.gui.record_editor.not_selected"), this.area.mx(), this.area.my() - 6, 0xffffff);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №105 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\GuiRecordList.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringSearchListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.resources.I18n;

import java.util.List;

public class GuiRecordList extends GuiElement
{
    public GuiRecordingEditorPanel panel;
    public GuiStringSearchListElement records;
    public boolean director;

    public GuiRecordList(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc);

        this.panel = panel;
        this.records = new GuiStringSearchListElement(mc, (str) -> this.panel.selectRecord(str.get(0)));
        this.records.flex().relative(this.area).set(10, 35, 0, 0).h(1, -45).w(1, -20);
        this.records.label = IKey.lang("blockbuster.gui.search");

        this.add(this.records);
    }

    public void clear()
    {
        this.records.list.clear();
        this.records.filter("", true);
    }

    public void add(List<String> records)
    {
        List<Replay> replays = ClientProxy.panels.scenePanel.getReplays();
        boolean loadAll = replays == null || !CameraHandler.canSync() || !CameraHandler.isCameraEditorOpen();

        if (loadAll)
        {
            /* Display all replays */
            for (String record : records)
            {
                this.records.list.add(record);
            }
        }
        else
        {
            /* Display only current director block's replays */
            for (Replay replay : replays)
            {
                if (records.contains(replay.id) && !this.records.list.getList().contains(replay.id))
                {
                    this.records.list.getList().add(replay.id);
                }
            }
        }

        this.director = !loadAll;
        this.records.filter("", true);
        this.records.list.update();
    }

    @Override
    public void toggleVisible()
    {
        super.toggleVisible();

        this.panel.updateEditorWidth();
    }

    @Override
    public void setVisible(boolean visible)
    {
        super.setVisible(visible);

        this.panel.updateEditorWidth();
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xff222222);
        Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.y + 30, 0x44000000);

        this.font.drawStringWithShadow(I18n.format(this.director ? "blockbuster.gui.record_editor.directors" : "blockbuster.gui.record_editor.title"), this.area.x + 10, this.area.y + 11, 0xcccccc);

        super.draw(context);
    }
}

==================================================

--- Файл №106 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\GuiRecordTimeline.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor;

import mchorse.blockbuster.network.server.recording.actions.ServerHandlerActionsChange;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.actions.MorphAction;
import mchorse.blockbuster_pack.morphs.SequencerMorph;
import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.ICopy;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.BodyPartManager;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.math.MathHelper;
import org.lwjgl.input.Keyboard;

import java.util.*;

public class GuiRecordTimeline extends GuiElement
{
    public GuiRecordingEditorPanel panel;
    public ScrollArea scroll;
    public ScrollArea vertical;
    /**
     * Pointer to the current selected action.
     * Can be null
     */
    private Action current;
    /**
     * A frame in the list can be null if it does not contain any actions
     */
    private final List<List<Action>> selection = new ArrayList<>();
    /**
     * The tick where the selection begins
     */
    private int fromTick = -1;
    /**
     * The current selected tick. It should always be greater or equal to {@link #fromTick}
     */
    private Selection currentTick = new Selection(-1, -1);
    /**
     * What has been last left clicked
     */
    private Selection lastClicked = new Selection(-1, -1);

    public boolean lastDragging = false;
    public int lastX;
    public int lastY;
    /**
     * Last clicked x coordinate with mouse button 0
     */
    private int lastLeftX;
    /**
     * Last clicked y coordinate with mouse button 0
     */
    private int lastLeftY;
    public int lastH;
    public int lastV;
    /**
     * To render the actions at the mouse position correctly when dragging.
     * The default value is -1 when this has not been set
     */
    private int movingDx = -1;
    private int movingDy = -1;
    /**
     * The first scroll when drawing the selection area.
     * This is used to ensure continuity of the selection area when scrolling around.
     */
    private int areaScrollDx = -1;
    private int areaScrollDy = -1;

    /**
     * If this is true moving is possible
     */
    public boolean canMove;
    public boolean moving;
    /**
     * Whether the user is ready to select an area
     */
    private boolean canSelectArea;
    private boolean selectingArea;
    public int cursor = -1;
    private boolean preventMouseReleaseSelect = false;

    private int adaptiveMaxIndex;
    private final int itemHeight = 20;
    private final int morphActionHandleWidth = 4;
    /**
     * A list of morph actions where the time handles have been selected.
     * Important to draw the selection and for multi selection of time handles
     */
    private final Set<MorphAction> selectedTimeHandles = Collections.newSetFromMap(new IdentityHashMap<>()) ;
    private boolean movingMorphActionTimeHandle = false;
    /**
     * The tick that got clicked by {@link #mouseClicked(GuiContext)}
     * This is cleared after releasing mouse.
     * The key of the map is the mouse button.
     */
    private final Map<Integer, Integer> clickedTick = new HashMap<>();

    public GuiRecordTimeline(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc);

        this.scroll = new ScrollArea(34);
        this.scroll.direction = ScrollDirection.HORIZONTAL;
        this.scroll.scrollSpeed = 34 * 2;
        this.vertical = new ScrollArea(this.itemHeight);
        this.vertical.direction = ScrollDirection.VERTICAL;
        this.panel = panel;

        IKey category = IKey.lang("blockbuster.gui.aperture.keys.category");

        this.keys().register(IKey.lang("blockbuster.gui.aperture.keys.add_morph_action"), Keyboard.KEY_M, () -> this.createAction("morph"))
                .held(Keyboard.KEY_LCONTROL).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.record_editor.deselect"), Keyboard.KEY_ESCAPE, this::deselect)
                .category(category).active(() -> this.isActive());
        this.keys().register(IKey.lang("blockbuster.gui.record_editor.select_all"), Keyboard.KEY_A, this::selectAll)
                .held(Keyboard.KEY_LCONTROL).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.record_editor.copy"), Keyboard.KEY_C, this::copyActions)
                .held(Keyboard.KEY_LCONTROL).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.record_editor.paste"), Keyboard.KEY_V, this::pasteActions)
                .held(Keyboard.KEY_LCONTROL).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.record_editor.cut"), Keyboard.KEY_X, this::cutActions)
                .held(Keyboard.KEY_LCONTROL).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.duplicate"), Keyboard.KEY_D, this::dupeActions)
                .held(Keyboard.KEY_LSHIFT).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.remove"), Keyboard.KEY_DELETE, this::removeActions).category(category);
    }

    /**
     * @return the tick of the current selected action / frame
     */
    public int getCurrentTick()
    {
        return this.currentTick.tick;
    }

    public int getCurrentIndex()
    {
        return this.currentTick.index;
    }

    /**
     * This is used to determine whether you can escape out of the gui
     * @return true if this selection is not empty and if it does not contain only one empty frame.
     */
    public boolean isActive()
    {
        return !(this.selection.isEmpty() || (this.selection.size() == 1 && this.isFrameEmpty(this.selection.get(0))));
    }

    @Override
    public void resize()
    {
        super.resize();

        this.scroll.copy(this.area);
        this.vertical.copy(this.area);
    }

    /**
     * Update with a new recording
     */
    public void reset()
    {
        if (this.panel.record != null)
        {
            this.selection.clear();
            this.selectCurrent(MathUtils.clamp(this.fromTick, 0, this.panel.record.actions.size() - 1), -1);
            this.scroll.setSize(this.panel.record.actions.size());
            this.scroll.clamp();

            this.recalculateVertical();
        }
    }

    public void recalculateVertical()
    {
        int max = 0;

        if (this.panel.record != null)
        {
            for (List<Action> actions : this.panel.record.actions)
            {
                if (actions != null && actions.size() > max)
                {
                    max = actions.size();
                }
            }

            max += 1;
        }

        this.vertical.setSize(max);
        this.vertical.clamp();
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        this.lastX = context.mouseX;
        this.lastY = context.mouseY;

        //TODO getIndex returns -2 when beyond end but returns -1 when beyond max index, but also -1 when behind beginning...
        //this brings issues with interpreting!
        int tick = this.scroll.getIndex(context.mouseX, context.mouseY);
        int index = this.vertical.getIndex(context.mouseX, context.mouseY);

        this.clickedTick.put(context.mouseButton, tick);

        if (context.mouseButton == 0)
        {
            /* morph action time handle has the highest priority */
            boolean abort = false;
            if (this.clickMorphActionTimeHandle(context.mouseX, context.mouseY)) abort = true;

            this.lastClicked = new Selection(tick, index);
            this.lastLeftX = this.lastX;
            this.lastLeftY = this.lastY;

            if (abort) return true;
        }

        if (context.mouseButton == 1)
        {
            if (this.moving || this.selectingArea)
            {
                this.preventMouseReleaseSelect = true;
            }

            this.moving = false;
            this.canMove = false;
            this.selectingArea = false;
            this.movingMorphActionTimeHandle = false;
        }

        if (context.mouseButton == 2 && this.area.isInside(context))
        {
            this.lastDragging = true;
            this.lastH = this.scroll.scroll;
            this.lastV = this.vertical.scroll;

            return true;
        }

        if (super.mouseClicked(context) || this.scroll.mouseClicked(context) || this.vertical.mouseClicked(context))
        {
            this.preventMouseReleaseSelect = true;

            return true;
        }

        if (this.scroll.isInside(context) && !this.moving && context.mouseButton == 0)
        {
            if (tick >= 0 && tick < this.panel.record.actions.size())
            {
                this.selectMouseClicked(tick, index);
            }
        }

        return false;
    }

    /**
     * Searches if there is a morph action time handle at the given mouse coordinates and whether to select it.
     * @param mouseX
     * @param mouseY
     * @return {tick, index} or null if there was no morph action timeline handle
     */
    private List<int[]> getMorphActionHandles(int mouseX, int mouseY)
    {
        int tick = this.scroll.getIndex(mouseX, mouseY);
        int index = this.vertical.getIndex(mouseX, mouseY);

        List<int[]> tickHandles = new ArrayList<>();

        if (tick < 0 || index < 0)
        {
            return tickHandles;
        }

        for (int t = tick; t >= 0; t--)
        {
            List<Action> actions = this.panel.record.actions.get(t);

            if (actions != null && index < actions.size() && actions.get(index) instanceof MorphAction)
            {
                MorphAction morphAction = (MorphAction) actions.get(index);

                int ticks = this.getAnimationLength(this.getMaxAnimationLengthMorph(morphAction.morph));

                /* this should be the global screen coordinates of the end of the tick item cell*/
                int test = this.scroll.x - this.scroll.scroll + (tick + 1) * this.scroll.scrollItemSize;

                /* first check if mouse inside the tick of the length -> then check if mouse on pixels of the handle */
                if ((ticks > 1 && tick == t + ticks - 1) && mouseX >= (test - this.morphActionHandleWidth))
                {
                    tickHandles.add(new int[]{t, index});
                }
            }
        }

        return tickHandles;
    }

    private List<int[]> getMorphActionHandlesRange(int fromTick, int toTick, int fromIndex, int toIndex)
    {
        if (fromTick < 0 || toTick < 0 || fromIndex < 0 || toIndex < 0)
        {
            return new ArrayList<>();
        }

        int tick0 = Math.min(fromTick, toTick);
        int tick1 = Math.max(fromTick, toTick);
        int index0 = Math.min(fromIndex, toIndex);
        int index1 = Math.max(fromIndex, toIndex);
        List<int[]> tickHandles = new ArrayList<>();

        for (int t = tick1; t >= 0; t--)
        {
            List<Action> actions = this.panel.record.actions.get(t);

            if (actions == null || actions.isEmpty()) continue;

            for (int i = index0; i < actions.size() && i <= index1; i++)
            {
                if (!(actions.get(i) instanceof MorphAction)) continue;

                int ticks = this.getAnimationLength(this.getMaxAnimationLengthMorph(((MorphAction) actions.get(i)).morph));

                if (ticks <= 1) continue;
                int animationEndTick = t + ticks - 1;

                if (animationEndTick >= tick0 && animationEndTick <= tick1)
                {
                    tickHandles.add(new int[]{t, i});
                }
            }
        }

        return tickHandles;
    }


    private boolean clickMorphActionTimeHandle(int mouseX, int mouseY)
    {
        List<int[]> selections = this.getMorphActionHandles(mouseX, mouseY);

        if (selections.isEmpty())
        {
            this.selectedTimeHandles.clear();
            return false;
        }

        boolean cleared = false;

        List<int[]> lastClickedSelection = this.getMorphActionHandles(this.lastLeftX, this.lastLeftY);

        /* if user clicked on time handles before and now clicks on new time handles with shift -> select a range */
        if (GuiScreen.isShiftKeyDown() && !lastClickedSelection.isEmpty())
        {
            int tick = this.scroll.getIndex(mouseX, mouseY);
            int index = this.vertical.getIndex(mouseX, mouseY);

            selections = this.getMorphActionHandlesRange(tick, this.lastClicked.tick, index, this.lastClicked.index);
        }

        for (int[] selection : selections)
        {
            int tick = selection[0];
            int index = selection[1];
            MorphAction action = (MorphAction) this.panel.record.getAction(tick, index);

            if (GuiScreen.isShiftKeyDown())
            {
                this.selectedTimeHandles.add(action);
            }
            else if (GuiScreen.isCtrlKeyDown())
            {
                if (this.selectedTimeHandles.contains(action)) this.selectedTimeHandles.remove(action);
                else this.selectedTimeHandles.add(action);
            }
            else if (!this.selectedTimeHandles.contains(action))
            {
                /* clear only once so multiple overlapping time handles can be selected */
                if (!cleared)
                {
                    this.selectedTimeHandles.clear();
                    cleared = true;
                }

                this.selectedTimeHandles.add(action);
            }

            boolean actionFound = this.selection.stream().anyMatch((frame) ->
            {
                if (frame != null && !frame.isEmpty())
                {
                    return frame.stream().anyMatch((actionTest) -> actionTest == action);
                }

                return false;
            });

            this.deselect();

            /*
             * only select the action of the time handle if it was already selected
             * otherwise clicking on time handles will always open the action menu and might annoy the user
             */
            if (actionFound)
            {
                this.fromTick = tick;
                this.selectCurrentSaveOld(tick, index);
                this.preventMouseReleaseSelect = true;
            }
        }

        this.movingMorphActionTimeHandle = true;

        return true;
    }

    private void releaseMorphActionTimeHandle(GuiContext context)
    {
        List<int[]> selections = this.getMorphActionHandles(context.mouseX, context.mouseY);

        for (int[] selection : selections)
        {
            int tick = selection[0];
            int index = selection[1];
            MorphAction action = (MorphAction) this.panel.record.getAction(tick, index);

            /* releasing the mouse on a selected time handle means clear selection and select it as the current */
            if (!(GuiScreen.isShiftKeyDown() || GuiScreen.isCtrlKeyDown()) && this.selectedTimeHandles.contains(action))
            {
                this.selectedTimeHandles.clear();
                this.selectedTimeHandles.add(action);

                boolean actionFound = this.selection.stream().anyMatch((frame) ->
                {
                    if (frame != null && !frame.isEmpty())
                    {
                        return frame.stream().anyMatch((actionTest) -> actionTest == action);
                    }

                    return false;
                });

                this.deselect();

                if (actionFound)
                {
                    this.fromTick = tick;
                    this.selectCurrentSaveOld(tick, index);
                    this.preventMouseReleaseSelect = true;
                }
            }
        }

        if (this.movingMorphActionTimeHandle && this.clickedTick.containsKey(0))
        {
            int tick = this.scroll.getIndex(context.mouseX, context.mouseY);
            int diff = tick - this.clickedTick.get(0);

            if (diff != 0)
            {
                for (MorphAction action : this.selectedTimeHandles)
                {
                    if (action.morph == null) continue;

                    /* only change the animation length of the morph with maximum duration, as this is what renders slider */
                    if (GuiScreen.isAltKeyDown())
                    {
                        AbstractMorph morph = this.getMaxAnimationLengthMorph(action.morph);

                        if (morph instanceof IAnimationProvider)
                        {
                            Animation animation = ((IAnimationProvider) morph).getAnimation();

                            if (animation.animates)
                            {
                                animation.duration = Math.max(0, animation.duration + diff);
                            }
                        }
                    }
                    else
                    {
                        /* add the diff onto every morph, even bodyparts etc. */
                        this.addAnimationDuration(action.morph, diff);
                    }

                    int[] found = this.panel.record.findAction(action);
                    ServerHandlerActionsChange.editAction(action, this.panel.record, found[0], found[1]);
                }
            }
        }

        this.movingMorphActionTimeHandle = false;
    }

    private void addAnimationDuration(AbstractMorph morph, int delta)
    {
        if (morph instanceof IAnimationProvider)
        {
            Animation animation = ((IAnimationProvider) morph).getAnimation();

            if (animation.animates)
            {
                animation.duration = Math.max(0, animation.duration + delta);
            }
        }

        if (morph instanceof IBodyPartProvider)
        {
            BodyPartManager manager = ((IBodyPartProvider) morph).getBodyPart();

            for (BodyPart part : manager.parts)
            {
                if (!part.morph.isEmpty() && part.limb != null && !part.limb.isEmpty())
                {
                    this.addAnimationDuration(part.morph.get(), delta);
                }
            }
        }
    }

    private void selectMouseClicked(int tick, int index)
    {
        if (this.isInSelection(tick, index))
        {
            if (GuiScreen.isCtrlKeyDown())
            {
                this.removeFromSelection(tick, index);
            }
            else if (GuiScreen.isShiftKeyDown())
            {
                this.canSelectArea = true;
            }
            else
            {
                this.awaitMoving();
            }
        }
        else
        {
            if (GuiScreen.isShiftKeyDown())
            {
                if (this.currentTick.tick != -1 && this.currentTick.index != -1)
                {
                    /* select a range from current tick to clicked tick */
                    List<List<Action>> actionRange = this.panel.record.getActions(tick, this.currentTick.tick, index, this.currentTick.index);

                    this.addToSelection(Math.min(tick, this.currentTick.tick), actionRange);
                }

                this.selectCurrentSaveOld(tick, index);
            }
            else if (GuiBase.isCtrlKeyDown())
            {
                if (this.panel.record.getAction(tick, index) != null)
                {
                    this.selectCurrentSaveOld(tick, index);
                }
            }
            else if (this.panel.record.getAction(tick, index) != null)
            {
                this.selection.clear();
                this.fromTick = tick;

                this.selectCurrentSaveOld(tick, index);
                this.awaitMoving();
            }
            else
            {
                this.canSelectArea = true;
            }
        }
    }

    private void awaitMoving()
    {
        this.canMove = true;
        this.moving = false;
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);

        this.releaseMorphActionTimeHandle(context);

        this.clickedTick.remove(context.mouseButton);

        if (context.mouseButton == 0)
        {
            if (this.moving)
            {
                this.moveSelectionTo(this.scroll.getIndex(context.mouseX, context.mouseY), this.vertical.getIndex(context.mouseX, context.mouseY));
            }
            else if (this.selectingArea)
            {
                if (!GuiScreen.isShiftKeyDown())
                {
                    this.selection.clear();
                }

                int scrollIndex = this.scroll.getIndex(context.mouseX, context.mouseY);
                int verticalIndex = this.vertical.getIndex(context.mouseX, context.mouseY);

                scrollIndex = scrollIndex == -1 ? 0 : (scrollIndex == -2 ? this.panel.record.actions.size() - 1 : scrollIndex);

                int frameSize = this.panel.record.getActions(scrollIndex) == null ? 1 : this.panel.record.getActions(scrollIndex).size();
                verticalIndex = verticalIndex == -1 ? 0 : (verticalIndex == -2 ? frameSize - 1 : verticalIndex);

                int fromSt = Math.min(this.lastClicked.tick, scrollIndex);
                int toSt = Math.max(this.lastClicked.tick, scrollIndex);
                int fromSi = Math.min(this.lastClicked.index, verticalIndex);
                int toSi = Math.max(this.lastClicked.index, verticalIndex);

                List<List<Action>> actionRange = this.panel.record.getActions(fromSt, toSt, fromSi, toSi);

                int startShift = this.trimSelectionBeginning(actionRange);
                this.trimSelectionEnd(actionRange);

                this.addToSelection(fromSt + startShift, actionRange);
            }
            else if (!this.preventMouseReleaseSelect)
            {
                int tick = this.scroll.getIndex(context.mouseX, context.mouseY);
                int index = this.vertical.getIndex(context.mouseX, context.mouseY);

                if (index != -1 && 0 <= tick && tick < this.panel.record.actions.size())
                {
                    if (!GuiScreen.isShiftKeyDown() && !GuiScreen.isCtrlKeyDown()
                            && (this.isInSelection(tick, index) || this.panel.record.getAction(tick, index) == null))
                    {
                        this.selection.clear();
                        this.selectCurrentSaveOld(tick, index);
                    }
                }
            }

            this.preventMouseReleaseSelect = false;
            this.canSelectArea = false;
            this.selectingArea = false;
            this.canMove = false;
            this.moving = false;
        }

        this.lastDragging = false;
        this.scroll.mouseReleased(context);
        this.vertical.mouseReleased(context);
    }

    /**
     * Add the given actions to the selection starting at the specified tick.
     * Nothing will be added if the tick is outside the record.actions range or if the specified actions are empty.
     * @param tick
     * @param actions
     */
    private void addToSelection(int tick, List<List<Action>> actions)
    {
        if (actions.isEmpty() || this.panel.record.actions.size() <= tick || tick < 0)
        {
            return;
        }

        this.selectTick(tick);
        this.selectTick(tick + actions.size() - 1);

        int start = tick - this.fromTick;

        for (int i = start, c = 0; i < this.selection.size() && c < actions.size(); i++, c++)
        {
            if (this.selection.get(i) == null && actions.get(c) != null)
            {
                this.selection.set(i, new ArrayList<>(actions.get(c)));
            }
            else if (this.selection.get(i) != null && actions.get(c) != null)
            {
                this.selection.get(i).removeAll(actions.get(c));

                this.selection.get(i).addAll(actions.get(c));
            }
        }
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        if (super.mouseScrolled(context))
        {
            return true;
        }

        boolean shift = GuiScreen.isShiftKeyDown();
        boolean alt = GuiScreen.isAltKeyDown();

        if (shift && !alt)
        {
            return this.vertical.mouseScroll(context);
        }
        else if (alt && !shift)
        {
            int scale = this.scroll.scrollItemSize;

            this.scroll.scrollItemSize = MathUtils.clamp(this.scroll.scrollItemSize + (int) Math.copySign(2, context.mouseWheel), 6, 50);
            this.scroll.setSize(this.panel.record.actions.size());
            this.scroll.clamp();

            if (this.scroll.scrollItemSize != scale)
            {
                int value = this.scroll.scroll + (context.mouseX - this.area.x);

                this.scroll.scroll = (int) ((value - (value - this.scroll.scroll) * (scale / (float) this.scroll.scrollItemSize)) * (this.scroll.scrollItemSize / (float) scale));
            }

            return true;
        }

        return this.scroll.mouseScroll(context);
    }


    /**
     * @param tick
     * @param index
     * @return true if the action at the tick and index is selected.
     *         False if tick is outside of selection, if there is no action at the tick and index
     *         or if the action is not in the selection.
     */
    private boolean isInSelection(int tick, int index)
    {
        if (tick < this.fromTick || this.selection.isEmpty() || this.fromTick == -1)
        {
            return false;
        }

        Action action = this.panel.record.getAction(tick, index);
        int t = tick - this.fromTick;

        if (action == null || t >= this.selection.size())
        {
            return false;
        }

        return this.selection.get(t) != null ? this.selection.get(t).contains(action) : false;
    }

    /**
     * Remove the given tick and index from the selection
     * and update {@link #currentTick} and {@link #fromTick} if necessary.
     * @param tick
     * @param index
     */
    private void removeFromSelection(int tick, int index)
    {
        if (tick < this.fromTick)
        {
            return;
        }

        int t = tick - fromTick;

        Action remove = this.panel.record.getAction(tick, index);

        if (remove == null || t >= this.selection.size())
        {
            return;
        }

        if (this.selection.get(t) != null)
        {
            this.selection.get(t).remove(remove);
        }

        if (t == this.selection.size() - 1)
        {
            this.trimSelectionEnd(this.selection);
        }
        else if (t == 0)
        {
            this.fromTick += this.trimSelectionBeginning(this.selection);
        }
        else if (this.selection.get(t).isEmpty())
        {
            this.selection.set(t, null);
        }

        if (this.current == remove)
        {
            this.selectCurrentSaveOld(-1, -1);
        }
    }

    /**
     * Clear the selection, but keep current tick (without selecting a current action) and save the old action.
     */
    public void deselect()
    {
        this.selection.clear();
        this.selectCurrentSaveOld(this.currentTick.tick, -1);
    }

    public void selectAll()
    {
        this.selection.clear();
        this.addToSelection(0, this.panel.record.getActions(0, this.panel.record.actions.size() - 1));
        this.selectCurrentSaveOld(this.currentTick.tick, this.currentTick.index);
    }

    /**
     * Trims the selection so that the first start frame is not empty or null.
     * This method will remove entry from the given list, but it will not remove entries from the list entries.
     * @param selection
     * @return the shift from the beginning
     */
    private int trimSelectionBeginning(List<List<Action>> selection)
    {
        int shift = 0;

        for (int start = 0; start < selection.size(); start++)
        {
            if (this.isFrameEmpty(selection.get(start)))
            {
                selection.remove(start);

                start--;
                shift++;
            }
            else
            {
                break;
            }
        }

        return shift;
    }

    private boolean isFrameEmpty(List<Action> frame)
    {
        boolean empty = true;

        if (frame != null && !frame.isEmpty())
        {
            for (int a = 0; a < frame.size(); a++)
            {
                if (frame.get(a) != null)
                {
                    empty = false;
                }
            }
        }

        return empty;
    }

    /**
     * Trims the selection so that the first end frame that is not empty or null.
     * This method will remove entry from the given list, but it will not remove entries from the list entries.
     * @param selection
     * @return the shift from the end
     */
    private int trimSelectionEnd(List<List<Action>> selection)
    {
        int shift = 0;

        for (int end = selection.size() - 1; end >= 0; end--)
        {
            if (this.isFrameEmpty(selection.get(end)))
            {
                selection.remove(end);

                shift++;
            }
            else
            {
                break;
            }
        }

        return shift;
    }

    /**
     * Sets current action and {@link #currentTick} and updates the selection.
     * This method also updates the GUI action panel of the recording editor panel.
     * If the selection was empty or if {@link #fromTick} was -1 then {@link #fromTick} will be set to the provided tick
     * @param tick
     * @param index
     */
    public void selectCurrent(int tick, int index)
    {
        Action selected = this.panel.record.getAction(tick, index);

        if (selected != null)
        {
            if (this.fromTick == -1 || this.selection.isEmpty())
            {
                this.selection.clear();

                this.fromTick = tick;
                this.selection.add(null);
            }
            else
            {
                this.selectTick(tick);
            }

            int t = tick - this.fromTick;

            if (this.selection.get(t) != null)
            {
                if (!this.selection.get(t).contains(selected))
                {
                    this.selection.get(t).add(selected);
                }
            }
            else
            {
                this.selection.set(t, new ArrayList<>(Arrays.asList(selected)));
            }
        }
        else if (this.fromTick == -1 || this.selection.isEmpty())
        {
            this.selection.clear();

            this.fromTick = tick;
            this.selection.add(null);
        }

        this.current = selected;
        this.currentTick.tick = tick;
        this.currentTick.index = index;

        this.panel.selectAction(this.current);
    }

    /**
     * This method also saves the old action of the panel via {@link GuiRecordingEditorPanel#saveAction()}.
     * Sets current action and {@link #currentTick} and updates the selection.
     * This method also updates the GUI action panel of the recording editor panel.
     * If the selection was empty or if {@link #fromTick} was -1 then {@link #fromTick} will be set to the provided tick
     * @param tick
     * @param index
     */
    public void selectCurrentSaveOld(int tick, int index)
    {
        this.saveAction();

        this.selectCurrent(tick, index);
    }

    public void saveAction()
    {
        this.panel.saveAction();
    }

    /**
     * Add the given tick to the selection and close gaps to previous selection.
     * The provided tick will be greater or equal to {@link #fromTick} after this operation.
     * @param tick
     */
    private void selectTick(int tick)
    {
        int t = tick - this.fromTick;
        int start = (tick < this.fromTick) ? 0 : ((t >= this.selection.size()) ? this.selection.size() : 0);
        int end = (tick < this.fromTick) ? this.fromTick - tick : ((t >= this.selection.size()) ? t + 1: 0);

        for (int i = start; i < end; i++)
        {
            this.selection.add(i, null);
        }

        if (tick < this.fromTick)
        {
            this.fromTick = tick;
        }
    }

    /**
     * Sort the given actions to the original actions list from the recording.
     * This should be used for example when copying or moving so the order of selection doesn't
     * change the order of the actions when inserted.
     * @param actions
     */
    private void sortToOriginal(List<List<Action>> actions)
    {
        for (int tick = 0; tick < actions.size(); tick++)
        {
            if (actions.get(tick) != null && !actions.get(tick).isEmpty())
            {
                List<Action> frameList = new ArrayList<>();
                boolean added = false;

                for (int a = 0; a < actions.get(tick).size(); a++)
                {
                    int newIndex = this.panel.record.getActionIndex(this.fromTick + tick, actions.get(tick).get(a));

                    if (newIndex != -1)
                    {
                        if (newIndex >= frameList.size())
                        {
                            frameList.addAll(Arrays.asList(new Action[newIndex - frameList.size() + 1]));
                        }

                        frameList.set(newIndex, actions.get(tick).get(a));

                        if (!added)
                        {
                            added = actions.get(tick).get(a) != null;
                        }
                    }
                }

                if (added)
                {
                    this.removeNulls(frameList);
                    actions.set(tick, frameList);
                }
            }
        }
    }

    private void removeNulls(List<Action> frame)
    {
        for (int s = 0, e = frame.size() - 1; s < frame.size() && e >= 0; s++, e--)
        {
            if (frame.get(e) == null)
            {
                frame.remove(e);
                e--;
            }

            if (frame.get(s) == null)
            {
                frame.remove(s);
                s--;
                e--;
            }

            if (s >= e) break;
        }
    }

    private void moveSelectionTo(int tick, int index)
    {
        /* beyond start */
        if (tick == -1)
        {
            tick = 0;
        }
        /* beyond end */
        else if (tick == -2)
        {
            tick = this.panel.record.actions.size() - this.selection.size();
        }
        else
        {
            tick = tick + this.fromTick - this.lastClicked.tick;
        }

        if (index == -1)
        {
            index = 0;
        }
        else if (index == -2)
        {
            index = this.panel.record.actions.get(tick) == null ? 0 : this.panel.record.actions.get(tick).size() - 1;
        }

        List<List<Action>> selectionCopy = new ArrayList<>(this.selection);

        this.sortToOriginal(selectionCopy);

        int start = this.trimSelectionBeginning(selectionCopy);
        this.trimSelectionEnd(selectionCopy);

        if (selectionCopy.isEmpty())
        {
            return;
        }

        Action current = this.current;
        int dT = this.currentTick.tick - this.fromTick;
        this.removeActions();
        this.selection.clear();
        this.selection.addAll(selectionCopy);

        tick += start;

        /* move it back if outside of range */
        if (tick < 0)
        {
            tick = 0;
        }
        else if (tick + this.selection.size() - 1 >= this.panel.record.actions.size())
        {
            tick -= tick + this.selection.size() - 1 - this.panel.record.actions.size() + 1;
        }

        this.fromTick = tick;
        this.currentTick.tick = tick + dT - start;

        this.addActions(tick, index, selectionCopy);
        this.selectCurrent(this.currentTick.tick, this.panel.record.getActionIndex(this.currentTick.tick, current));
    }

    public void cutActions()
    {
        if (this.fromTick == -1 || this.selection.isEmpty())
        {
            return;
        }

        this.copyActions();
        this.removeActions();
    }

    public void copyActions()
    {
        if (this.fromTick == -1 || this.selection.isEmpty())
        {
            return;
        }

        List<List<Action>> selectionCopy = new ArrayList<>(this.selection);

        this.sortToOriginal(selectionCopy);

        this.trimSelectionBeginning(selectionCopy);
        this.trimSelectionEnd(selectionCopy);

        if (selectionCopy.isEmpty())
        {
            return;
        }

        NBTTagList list = new NBTTagList();

        for (List<Action> frame : selectionCopy)
        {
            NBTTagList frameNBT = new NBTTagList();

            if (frame != null)
            {
                for (Action action : frame)
                {
                    if (action == null) continue;

                    NBTTagCompound actionNBT = new NBTTagCompound();

                    actionNBT.setString("ActionType", ActionRegistry.NAME_TO_CLASS.inverse().get(action.getClass()));
                    action.toNBT(actionNBT);
                    frameNBT.appendTag(actionNBT);
                }
            }

            list.appendTag(frameNBT);
        }

        this.panel.buffer = new NBTTagCompound();
        this.panel.buffer.setTag("Actions", list);
    }

    public void pasteActions()
    {
        if (this.panel.buffer == null || !this.panel.buffer.hasKey("Actions") || this.currentTick.tick == -1)
        {
            return;
        }

        List<List<Action>> copied = new ArrayList<>();

        if (this.panel.buffer.getTag("Actions") instanceof NBTTagList)
        {
            NBTTagList nbtList = (NBTTagList) this.panel.buffer.getTag("Actions");

            for (int i = 0; i < nbtList.tagCount(); i++)
            {
                if (nbtList.get(i) == null || !(nbtList.get(i) instanceof NBTTagList))
                {
                    copied.add(null);

                    continue;
                }

                List<Action> frame = null;

                NBTTagList frameNBT = (NBTTagList) nbtList.get(i);

                //TODO externalise parsing of action data - checkout Record too
                for (int a = 0; a < frameNBT.tagCount(); a++)
                {
                    if (frameNBT.get(a) instanceof NBTTagCompound)
                    {
                        NBTTagCompound actionNBT = (NBTTagCompound) frameNBT.get(a);

                        if (actionNBT.hasKey("ActionType"))
                        {
                            try
                            {
                                Action action = ActionRegistry.fromName(actionNBT.getString("ActionType"));

                                action.fromNBT(actionNBT);

                                if (frame == null)
                                {
                                    frame = new ArrayList<>();
                                }

                                frame.add(action);
                            }
                            catch (Exception e)
                            { }
                        }
                    }
                }

                copied.add(frame);
            }
        }

        this.trimSelectionBeginning(copied);
        this.trimSelectionEnd(copied);

        if (copied.isEmpty())
        {
            return;
        }

        this.saveAction();

        if (this.currentTick.index < 0 || this.current == null)
        {
            this.addActions(this.currentTick.tick, -1, copied);
        }
        else
        {
            this.addActions(this.currentTick.tick, this.currentTick.index, copied);
        }

        this.selection.clear();
        this.selection.addAll(copied);
        this.selectCurrent(this.currentTick.tick, -1);
    }

    public void createAction(String str)
    {
        if (!ActionRegistry.NAME_TO_CLASS.containsKey(str)
            || this.currentTick.tick < 0 || this.currentTick.tick >= this.panel.record.actions.size())
        {
            return;
        }

        try
        {
            Action action = ActionRegistry.fromName(str);
            int tick = this.currentTick.tick;
            int index = this.currentTick.index;

            List<List<Action>> insert = new ArrayList<>();
            insert.add(new ArrayList<>(Arrays.asList(action)));

            this.addActions(tick, index, insert);
            this.selection.clear();
            this.selectCurrentSaveOld(tick, this.panel.record.getActionIndex(tick, action));
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public void dupeActions()
    {
        if (this.fromTick < 0 || this.selection.isEmpty())
        {
            return;
        }

        int tick = this.fromTick;
        int index = this.currentTick.index == -1 ? 0 : (this.currentTick.index == -2 ? -1 : this.currentTick.index);

        List<List<Action>> selectionCopy = new ArrayList<>(this.selection);

        if (selectionCopy.isEmpty())
        {
            return;
        }

        this.sortToOriginal(selectionCopy);
        int start = this.trimSelectionBeginning(selectionCopy);
        this.trimSelectionEnd(selectionCopy);

        Action newCurrent = null;

        for (int t = 0; t < selectionCopy.size(); t++)
        {
            if (selectionCopy.get(t) != null && !selectionCopy.get(t).isEmpty())
            {
                for (int a = 0; a < selectionCopy.get(t).size(); a++)
                {
                    if (selectionCopy.get(t).get(a) == null) continue;

                    try
                    {
                        //TODO implement copy interface for actions...
                        Action newAction = ActionRegistry.fromType(ActionRegistry.getType(selectionCopy.get(t).get(a)));
                        NBTTagCompound tag = new NBTTagCompound();

                        selectionCopy.get(t).get(a).toNBT(tag);
                        newAction.fromNBT(tag);

                        if (selectionCopy.get(t).get(a) == this.current)
                        {
                            newCurrent = newAction;
                        }

                        selectionCopy.get(t).set(a, newAction);
                    }
                    catch (Exception e)
                    {}
                }
            }
        }

        tick += start;

        this.addActions(tick, index, selectionCopy);

        this.selection.clear();
        this.addToSelection(tick, selectionCopy);
        this.selectCurrentSaveOld(this.currentTick.tick, this.panel.record.getActionIndex(this.currentTick.tick, newCurrent));
    }

    private void addActions(int tick, int index, List<List<Action>> actions)
    {
        if (index < 0)
        {
            ServerHandlerActionsChange.addActions(actions, this.panel.record, tick);
        }
        else
        {
            ServerHandlerActionsChange.addActions(actions, this.panel.record, tick, index);
        }

        this.recalculateVertical();
    }

    /**
     * Remove selected actions, send to server, clear selection and set current to none
     */
    public void removeActions()
    {
        if (this.fromTick == -1 || this.selection.isEmpty())
        {
            return;
        }

        List<List<Action>> selectionCopy = new ArrayList<>(this.selection);

        int startShift = this.trimSelectionBeginning(selectionCopy);
        this.trimSelectionEnd(selectionCopy);

        if (selectionCopy.isEmpty())
        {
            return;
        }

        int from = this.fromTick + startShift;

        List<List<Boolean>> deletionMask = this.panel.record.getActionsMask(from, selectionCopy);

        this.saveAction();
        ServerHandlerActionsChange.deleteActions(this.panel.record, from, deletionMask);

        /* deselect without saving previous action */
        this.selection.clear();
        this.selectCurrent(this.currentTick.tick, -1);

        this.recalculateVertical();
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.panel.record == null)
        {
            return;
        }

        int mouseX = context.mouseX;
        int mouseY = context.mouseY;
        int count = this.panel.record.actions.size();

        if (this.lastDragging)
        {
            this.scroll.scroll = this.lastH + (this.lastX - mouseX);
            this.scroll.clamp();
            this.vertical.scroll = this.lastV + (this.lastY - mouseY);
            this.vertical.clamp();
        }

        if (!this.moving && (Math.abs(mouseX - this.lastX) > 2 || Math.abs(mouseY - this.lastY) > 2))
        {
            if (this.canMove)
            {
                this.moving = true;
            }

            if (this.canSelectArea)
            {
                this.selectingArea = true;
            }
        }

        this.scroll.drag(mouseX, mouseY);
        this.vertical.drag(mouseX, mouseY);
        this.scroll.draw(ColorUtils.HALF_BLACK);

        Gui.drawRect(this.area.ex(), this.area.y, this.area.ex() + 20, this.area.ey(), 0xff222222);
        Gui.drawRect(this.area.x - 20, this.area.y, this.area.x, this.area.ey(), 0xff222222);
        GuiDraw.drawHorizontalGradientRect(this.area.ex() - 8, this.area.y, this.area.ex(), this.area.ey(), 0, ColorUtils.HALF_BLACK, 0);
        GuiDraw.drawHorizontalGradientRect(this.area.x, this.area.y, this.area.x + 8, this.area.ey(), ColorUtils.HALF_BLACK, 0, 0);

        int max = this.area.x + this.scroll.scrollItemSize * count;

        if (max < this.area.ex())
        {
            Gui.drawRect(max, this.area.y, this.area.ex(), this.area.ey(), 0xaa000000);
        }

        GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);

        int w = this.scroll.scrollItemSize;
        int index = this.scroll.scroll / w;
        int diff = index;

        index -= this.adaptiveMaxIndex;
        index = index < 0 ? 0 : index;
        diff = diff - index;

        this.adaptiveMaxIndex = 0;

        for (int i = index, c = i + this.area.w / w + 2 + diff; i < c; i++)
        {
            int x = this.scroll.x - this.scroll.scroll + i * w;

            if (i < count)
            {
                Gui.drawRect(x, this.scroll.y, x + 1, this.scroll.ey(), 0x22ffffff);
            }

            int toTick = this.selection.isEmpty() ? this.fromTick : this.fromTick + this.selection.size() - 1;

            if (this.fromTick <= i && i <= toTick)
            {
                Gui.drawRect(x, this.scroll.y, x + w + 1, this.scroll.ey(), 0x440088ff);
            }

            if (i >= 0 && i < count)
            {
                List<Action> actions = this.panel.record.actions.get(i);

                if (actions != null)
                {
                    int j = 0;

                    for (Action action : actions)
                    {
                        if (this.moving && this.isInSelection(i, j))
                        {
                            j++;

                            continue;
                        }

                        int y = this.scroll.y + j * this.itemHeight - this.vertical.scroll;

                        int scrollIndex = this.scroll.getIndex(mouseX, mouseY);
                        int verticalIndex = this.vertical.getIndex(mouseX, mouseY);

                        scrollIndex = scrollIndex == -1 ? 0 : (scrollIndex == -2 ? count - 1 : scrollIndex);
                        verticalIndex = verticalIndex == -1 ? 0 : (verticalIndex == -2 ? actions.size() - 1 : verticalIndex);

                        int fromSt = Math.min(this.lastClicked.tick, scrollIndex);
                        int toSt = Math.max(this.lastClicked.tick, scrollIndex);
                        int fromSi = Math.min(this.lastClicked.index, verticalIndex);
                        int toSi = Math.max(this.lastClicked.index, verticalIndex);

                        boolean selected;

                        if (this.selectingArea)
                        {
                            selected = fromSt <= i && i <= toSt && fromSi <= j && j <= toSi;

                            if (GuiScreen.isShiftKeyDown())
                            {
                                selected = selected || this.isInSelection(i, j);
                            }
                        }
                        else
                        {
                            selected = this.isInSelection(i, j);
                        }

                        this.drawAction(action, context, String.valueOf(j), x, y, selected);

                        j++;
                    }
                }
            }
        }

        for (int i = index, c = i + this.area.w / w + 2 + diff; i < c; i++)
        {
            if (i % 5 == 0 && i < count && i != this.cursor)
            {
                int x = this.scroll.x - this.scroll.scroll + i * w;
                int y = this.scroll.ey() - 12;

                String str = String.valueOf(i);

                this.drawGradientRect(x + 1, y - 6, x + w, y + 12, 0, ColorUtils.HALF_BLACK);
                this.font.drawStringWithShadow(str, x + (this.scroll.scrollItemSize - this.font.getStringWidth(str) + 2) / 2, y, 0xffffff);
            }
        }

        this.scroll.drawScrollbar();
        this.vertical.drawScrollbar();

        /* Draw cursor (tick indicator) */
        if (this.cursor >= 0 && this.cursor < this.panel.record.actions.size())
        {
            int x = this.scroll.x - this.scroll.scroll + this.cursor * w;
            int cursorX = x + 2;

            String label = this.cursor + "/" + this.panel.record.actions.size();
            int width = this.font.getStringWidth(label);
            int height = 2 + this.font.FONT_HEIGHT;
            int offsetY = this.scroll.ey() - height;

            if (cursorX + width + 4 > this.scroll.ex())
            {
                cursorX -= width + 4 + 2;
            }

            Gui.drawRect(x, this.scroll.y, x + 2, this.scroll.ey(), 0xff57f52a);
            Gui.drawRect(cursorX, offsetY, cursorX + width + 4, offsetY + height, 0xaa57f52a);

            this.font.drawStringWithShadow(label, cursorX + 2, offsetY + 2, 0xffffff);
        }

        String label = this.panel.record.filename;

        GuiDraw.drawTextBackground(this.font, label, this.area.ex() - this.font.getStringWidth(label) - 5, this.area.ey() - 13, 0xffffff, 0xaa000000 + McLib.primaryColor.get());

        GuiDraw.unscissor(context);

        if (this.moving)
        {
            int x = mouseX;
            int y = mouseY;

            int posX = w * (this.lastClicked.tick) + this.scroll.x - this.scroll.scroll;
            int posY = this.itemHeight * this.lastClicked.index + this.scroll.y - this.vertical.scroll;

            if (this.movingDx == -1)
            {
                this.movingDx = mouseX - posX;
            }

            if (this.movingDy == -1)
            {
                this.movingDy = mouseY - posY;
            }

            x -= this.movingDx - w * (this.fromTick - this.lastClicked.tick);
            y -= this.movingDy + this.itemHeight * this.lastClicked.index;

            int y0 = y;

            for (int tick = this.fromTick; tick < this.panel.record.actions.size(); tick++)
            {
                List<Action> frame = this.panel.record.actions.get(tick);

                if (frame != null)
                {
                    for (int i = 0; i < frame.size(); i++)
                    {
                        if (this.isInSelection(tick, i))
                        {
                            this.drawAction(frame.get(i), context, String.valueOf(i), x, y, true);
                        }

                        y += this.itemHeight;
                    }
                }

                y = y0;
                x += w;
            }
        }
        else
        {
            this.movingDx = -1;
            this.movingDy = -1;
        }

        if (this.selectingArea)
        {
            if (this.areaScrollDx == -1)
            {
                this.areaScrollDx = this.scroll.scroll;
            }

            if (this.areaScrollDy == -1)
            {
                this.areaScrollDy = this.vertical.scroll;
            }

            Gui.drawRect(this.lastLeftX - (this.scroll.scroll - this.areaScrollDx), this.lastLeftY - (this.vertical.scroll - this.areaScrollDy), mouseX, mouseY, 0x440088FF);
        }
        else
        {
            this.areaScrollDy = -1;
            this.areaScrollDx = -1;
        }

        super.draw(context);

        this.cursor = -1;
    }

    private void drawAction(Action action, GuiContext context, String label, int x, int y, boolean selected)
    {
        int w = this.scroll.scrollItemSize;
        float hue = ((ActionRegistry.getType(action) - 1) / ((float) ActionRegistry.getMaxID()));
        int color = MathHelper.hsvToRGB(hue, 1F, 1F);
        int offset = this.scroll.scrollItemSize < 18 ? (this.scroll.scrollItemSize - this.font.getStringWidth(label)) / 2 : 6;

        this.drawAnimationLength(action, context, x, y, color, selected);

        Gui.drawRect(x, y, x + w, y + this.itemHeight, color + ColorUtils.HALF_BLACK);
        this.font.drawStringWithShadow(label, x + offset, y + 6, 0xffffff);

        if (selected)
        {
            /* get complementary color, but ignore purple and blue colors - they don't pop enough */
            float hueSelected = MathUtils.clamp((hue - 0.5F) < 0 ? 0.5F + hue : hue - 0.5F, 0, 0.5F);
            int c = action == this.current ? (new Color(MathHelper.hsvToRGB(hueSelected, 0.5F, 1F), false)).getRGBAColor() : 0xffffffff;
            int border = action == this.current ? 2 : 1;
            GuiDraw.drawOutline(x, y, x + w, y + this.itemHeight, c, border);
        }
    }

    private void drawAnimationLength(Action action, GuiContext context, int x, int y, int color, boolean selected)
    {
        if (action instanceof MorphAction)
        {
            MorphAction morphAction = (MorphAction) action;
            int ticks = this.getAnimationLength(this.getMaxAnimationLengthMorph(morphAction.morph));

            if (this.movingMorphActionTimeHandle && this.selectedTimeHandles.contains(action) && this.clickedTick.containsKey(0))
            {
                ticks = Math.max(0, ticks + this.scroll.getIndex(context.mouseX, context.mouseY) - this.clickedTick.get(0));
            }

            if (ticks > 1)
            {
                ticks -= 1;

                int offset = x + this.scroll.scrollItemSize;
                boolean timeHandleSelected = this.selectedTimeHandles.contains(action);

                Gui.drawRect(offset, y + 8, offset + ticks * this.scroll.scrollItemSize, y + 12, selected ? 0xffffffff : color + 0x33000000);
                Gui.drawRect(offset + ticks * this.scroll.scrollItemSize - this.morphActionHandleWidth, y, offset + ticks * this.scroll.scrollItemSize, y + this.itemHeight,
                        timeHandleSelected ? 0xffffffff : 0xff000000 + color);
            }

            this.adaptiveMaxIndex = Math.max(ticks, this.adaptiveMaxIndex);
        }
    }

    private AbstractMorph getMaxAnimationLengthMorph(AbstractMorph morph)
    {
        int ticks = this.getAnimationLength(morph);

        if (morph instanceof IBodyPartProvider)
        {
            BodyPartManager manager = ((IBodyPartProvider) morph).getBodyPart();

            for (BodyPart part : manager.parts)
            {
                if (!part.morph.isEmpty() && part.limb != null && !part.limb.isEmpty())
                {
                    AbstractMorph morph0 = this.getMaxAnimationLengthMorph(part.morph.get());
                    int ticks0 = this.getAnimationLength(morph0);

                    if (ticks0 > ticks)
                    {
                        ticks = ticks0;
                        morph = morph0;
                    }
                }
            }
        }

        return morph;
    }

    private int getAnimationLength(AbstractMorph morph)
    {
        if (morph instanceof IAnimationProvider)
        {
            Animation animation = ((IAnimationProvider) morph).getAnimation();

            if (animation.animates)
            {
                return animation.duration;
            }
        }
        else if (morph instanceof SequencerMorph)
        {
            SequencerMorph sequencerMorph = (SequencerMorph) morph;

            return (int) sequencerMorph.getDuration();
        }

        return 0;
    }

    public static class Selection implements ICopy<Selection>
    {
        private int tick;
        private int index;

        public Selection(int tick, int index)
        {
            this.set(tick, index);
        }

        public void set(int tick, int index)
        {
            this.tick = tick;
            this.index = index;
        }

        public int getTick()
        {
            return this.tick;
        }

        public int getIndex()
        {
            return this.index;
        }

        @Override
        public Selection copy()
        {
            Selection copy = new Selection(this.tick, this.index);

            return copy;
        }
    }
}

==================================================

--- Файл №107 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;

import java.util.Map.Entry;

public abstract class GuiActionPanel<T extends Action> extends GuiElement
{
    public T action;
    public GuiRecordingEditorPanel panel;

    private IKey title = IKey.lang("");
    private IKey description = IKey.lang("");

    public GuiActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc);

        this.panel = panel;

        this.hideTooltip();
    }

    public void fill(T action)
    {
        this.action = action;

        String key = ActionRegistry.NAME_TO_CLASS.inverse().get(action.getClass());

        if (key != null)
        {
            this.setKey(key);
        }
    }

    public void disappear()
    {}

    public void setMorph(AbstractMorph morph)
    {}

    public void setKey(String key)
    {
        this.title.set("blockbuster.gui.record_editor.actions." + key + ".title");
        this.description.set("blockbuster.gui.record_editor.actions." + key + ".desc");
    }

    @Override
    public void draw(GuiContext context)
    {
        String title = this.title.get();

        if (!title.isEmpty())
        {
            this.font.drawStringWithShadow(title, this.area.x + 10, this.area.y + 10, 0xffffff);
            GuiDraw.drawMultiText(this.font, this.description.get(), this.area.x + 10, this.area.y + 30, 0xcccccc, this.area.w / 3);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №108 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiBlockActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.InteractBlockAction;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.util.math.BlockPos;

public class GuiBlockActionPanel<T extends InteractBlockAction> extends GuiActionPanel<T>
{
    public GuiTrackpadElement x;
    public GuiTrackpadElement y;
    public GuiTrackpadElement z;

    public GuiBlockActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.x = new GuiTrackpadElement(mc, (v) -> this.action.pos = new BlockPos(v.intValue(), this.action.pos.getY(), this.action.pos.getZ()));
        this.x.tooltip(IKey.lang("blockbuster.gui.model_block.x"));
        this.y = new GuiTrackpadElement(mc, (v) -> this.action.pos = new BlockPos(this.action.pos.getX(), v.intValue(), this.action.pos.getZ()));
        this.y.tooltip(IKey.lang("blockbuster.gui.model_block.y"));
        this.z = new GuiTrackpadElement(mc, (v) -> this.action.pos = new BlockPos(this.action.pos.getX(), this.action.pos.getY(), v.intValue()));
        this.z.tooltip(IKey.lang("blockbuster.gui.model_block.z"));

        this.x.integer = this.y.integer = this.z.integer = true;

        this.x.flex().set(10, 0, 80, 20).relative(this.area).y(1, -80);
        this.y.flex().set(0, 25, 80, 20).relative(this.x.resizer());
        this.z.flex().set(0, 25, 80, 20).relative(this.y.resizer());

        this.add(this.x, this.y, this.z);
    }

    @Override
    public void fill(T action)
    {
        super.fill(action);

        this.x.setValue(action.pos.getX());
        this.y.setValue(action.pos.getY());
        this.z.setValue(action.pos.getZ());
    }
}


==================================================

--- Файл №109 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiBreakBlockActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.BreakBlockAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiBreakBlockActionPanel extends GuiBlockActionPanel<BreakBlockAction>
{
    public GuiToggleElement drop;

    public GuiBreakBlockActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.drop = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.record_editor.drop"), false, (b) -> this.action.drop = b.isToggled());
        this.drop.flex().set(0, -16, 70, 11).relative(this.x.resizer());

        this.add(this.drop);
    }

    @Override
    public void fill(BreakBlockAction action)
    {
        super.fill(action);

        this.drop.toggled(action.drop);
    }
}

==================================================

--- Файл №110 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiBreakBlockAnimationPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.BreakBlockAnimation;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;

public class GuiBreakBlockAnimationPanel extends GuiBlockActionPanel<BreakBlockAnimation>
{
    public GuiTrackpadElement charge;

    public GuiBreakBlockAnimationPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.charge = new GuiTrackpadElement(mc, (charge) -> this.action.progress = charge.intValue());
        this.charge.tooltip(IKey.lang("blockbuster.gui.record_editor.progress"));
        this.charge.limit(0, 100, true);
        this.charge.flex().set(0, -25, 100, 20).relative(this.x.resizer());

        this.add(this.charge);
    }

    @Override
    public void fill(BreakBlockAnimation action)
    {
        super.fill(action);

        this.charge.setValue(action.progress);
    }
}


==================================================

--- Файл №111 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiChatActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.ChatAction;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;

public class GuiChatActionPanel extends GuiActionPanel<ChatAction>
{
    public GuiTextElement command;

    public GuiChatActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.command = new GuiTextElement(mc, 10000, (str) -> this.action.message = str);
        this.command.flex().relative(this.area).set(10, 0, 0, 20).y(1, -30).w(1, -20);

        this.add(this.command);
    }

    @Override
    public void fill(ChatAction action)
    {
        super.fill(action);

        this.command.setText(action.message);
    }

    @Override
    public void draw(GuiContext context)
    {
        String message = this.action.getMessage(null);

        if (!message.isEmpty())
        {
            GuiDraw.drawTextBackground(this.font, message, this.command.area.x + 3, this.command.area.y - this.font.FONT_HEIGHT - 3, 0xffffff, ColorUtils.HALF_BLACK);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №112 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiCommandActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.CommandAction;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import net.minecraft.client.Minecraft;

public class GuiCommandActionPanel extends GuiActionPanel<CommandAction>
{
    public GuiTextElement command;

    public GuiCommandActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.command = new GuiTextElement(mc, 10000, (str) -> this.action.command = str);
        this.command.flex().relative(this.area).set(10, 0, 0, 20).y(1, -30).w(1, -20);

        this.add(this.command);
    }

    @Override
    public void fill(CommandAction action)
    {
        super.fill(action);

        this.command.setText(action.command);
    }
}

==================================================

--- Файл №113 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiDamageActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.DamageAction;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiDamageActionPanel extends GuiActionPanel<DamageAction>
{
    public GuiTrackpadElement damage;

    public GuiDamageActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.damage = new GuiTrackpadElement(mc, (charge) -> this.action.damage = charge.intValue());
        this.damage.tooltip(IKey.lang("blockbuster.gui.record_editor.damage"));
        this.damage.min = 0;
        this.damage.flex().set(10, 0, 100, 20).relative(this.area).y(1, -30);

        this.add(this.damage);
    }

    @Override
    public void fill(DamageAction action)
    {
        super.fill(action);

        this.damage.setValue(action.damage);
    }
}

==================================================

--- Файл №114 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiDropActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.DropAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import net.minecraft.client.Minecraft;
import net.minecraft.item.ItemStack;

public class GuiDropActionPanel extends GuiActionPanel<DropAction>
{
    public GuiSlotElement slot;

    public GuiDropActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.slot = new GuiSlotElement(mc,0, this::pickItem);
        this.slot.flex().relative(this.area).xy(0.5F, 0.5F).anchor(0.5F, 0.5F);

        this.add(this.slot);
    }

    public void pickItem(ItemStack stack)
    {
        this.action.itemData = stack.isEmpty() ? null : stack.serializeNBT();
        this.slot.setStack(stack);
    }

    @Override
    public void fill(DropAction action)
    {
        super.fill(action);

        this.slot.setStack(action.itemData == null ? ItemStack.EMPTY : new ItemStack(action.itemData));
    }
}

==================================================

--- Файл №115 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiEmptyActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;

public class GuiEmptyActionPanel extends GuiActionPanel<Action>
{
    public GuiEmptyActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);
    }

    @Override
    public void draw(GuiContext context)
    {
        super.draw(context);

        this.drawCenteredString(this.font, I18n.format("blockbuster.gui.record_editor.no_fields"), this.area.mx(), this.area.my(), 0xffffff);
    }
}

==================================================

--- Файл №116 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiEquipActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.EquipAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

public class GuiEquipActionPanel extends GuiActionPanel<EquipAction>
{
    public GuiCirculateElement armor;
    public GuiSlotElement slot;

    public GuiEquipActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.armor = new GuiCirculateElement(mc, (b) -> this.action.armorSlot = (byte) b.getValue());
        this.armor.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.main_hand"));
        this.armor.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.feet"));
        this.armor.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.legs"));
        this.armor.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.chest"));
        this.armor.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.head"));
        this.armor.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.off_hand"));
        this.armor.flex().relative(this).w(80).x(10).y(1F, -30);

        this.slot = new GuiSlotElement(mc,0, this::pickItem);
        this.slot.flex().relative(this).xy(0.5F, 0.5F).anchor(0.5F, 0.5F);

        this.add(this.armor, this.slot);
    }

    public void pickItem(ItemStack stack)
    {
        this.action.itemData = stack.isEmpty() ? null : stack.writeToNBT(new NBTTagCompound());
        this.slot.setStack(stack);
    }

    @Override
    public void fill(EquipAction action)
    {
        super.fill(action);

        this.armor.setValue(action.armorSlot);
        this.slot.setStack(action.itemData == null ? ItemStack.EMPTY : new ItemStack(action.itemData));
    }
}

==================================================

--- Файл №117 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiHotbarChangeActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.HotbarChangeAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.item.ItemStack;

public class GuiHotbarChangeActionPanel extends GuiActionPanel<HotbarChangeAction>
{
    public GuiSlotElement item;
    public GuiTrackpadElement slot;
    public GuiTrackpadElement durability;

    public GuiHotbarChangeActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.slot = new GuiTrackpadElement(mc, (b) -> this.action.setSlot(b.intValue()));
        this.slot.integer().limit(0,8);
        this.slot.flex().relative(this).xy(0.5F, 0.65F).anchor(0.5F, 0.5F).w(75);
        this.slot.tooltip(IKey.lang("blockbuster.gui.record_editor.actions.hotbar_change.slot_tooltip"));

        this.durability = new GuiTrackpadElement(mc, (b) ->
        {
            if (this.item.getStack().getMaxDamage() != 0)
            {
                ItemStack newItemStack = this.item.getStack().copy();

                newItemStack.setItemDamage((int) ((1 - b.floatValue() / 100F) * this.item.getStack().getMaxDamage()));

                this.action.setItemStack(newItemStack);
                this.item.setStack(newItemStack);
            }
        });
        this.durability.limit(0,100);
        this.durability.flex().relative(this).xy(0.5F, 0.75F).anchor(0.5F, 0.5F).w(75);
        this.durability.tooltip(IKey.lang("blockbuster.gui.record_editor.actions.hotbar_change.durability_tooltip"));

        this.item = new GuiSlotElement(mc,0, this::pickItem);
        this.item.flex().relative(this).xy(0.5F, 0.5F).anchor(0.5F, 0.5F);

        this.add(this.item, this.slot);
    }

    public void pickItem(ItemStack stack)
    {
        this.action.setItemStack(stack);
        this.item.setStack(stack);

        this.updateFields();
    }

    protected void updateFields()
    {
        this.durability.removeFromParent();

        if (this.item.getStack().getMaxDamage() != 0)
        {
            this.add(this.durability);
        }

        double durability = (this.item.getStack().getMaxDamage() == 0) ? 1 : (1 - (double) this.item.getStack().getItemDamage() / (double) this.item.getStack().getMaxDamage());

        this.durability.setValue(durability * 100D);

        if (this.parent != null)
        {
            this.parent.resize();
        }
    }

    @Override
    public void fill(HotbarChangeAction action)
    {
        super.fill(action);

        this.slot.setValue(action.getSlot());
        this.item.setStack(action.getItemStack() == null ? ItemStack.EMPTY : action.getItemStack().copy());

        this.updateFields();
    }
}


==================================================

--- Файл №118 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiInteractEntityActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import net.minecraft.client.Minecraft;

public class GuiInteractEntityActionPanel extends GuiItemUseActionPanel
{
    public GuiInteractEntityActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);
    }
}

==================================================

--- Файл №119 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiItemUseActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.ItemUseAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.util.EnumHand;

public class GuiItemUseActionPanel<T extends ItemUseAction> extends GuiActionPanel<T>
{
    public GuiCirculateElement hand;

    public GuiItemUseActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.hand = new GuiCirculateElement(mc, (b) -> this.action.hand = EnumHand.values()[this.hand.getValue()]);
        this.hand.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.main_hand"));
        this.hand.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.equip.off_hand"));
        this.hand.flex().set(10, 0, 80, 20).relative(this.area).y(1, -30);

        this.add(this.hand);
    }

    @Override
    public void fill(T action)
    {
        super.fill(action);

        this.hand.setValue(action.hand.ordinal());
    }
}

==================================================

--- Файл №120 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiItemUseBlockActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiThreeElement;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.ItemUseBlockAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;

public class GuiItemUseBlockActionPanel extends GuiItemUseActionPanel<ItemUseBlockAction>
{
    public GuiCirculateElement facing;
    public GuiThreeElement block;
    public GuiThreeElement hit;

    public GuiItemUseBlockActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.facing = new GuiCirculateElement(mc, (b) -> this.action.facing = EnumFacing.values()[this.facing.getValue()]);
        this.facing.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.use_item_block.down"));
        this.facing.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.use_item_block.up"));
        this.facing.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.use_item_block.north"));
        this.facing.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.use_item_block.south"));
        this.facing.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.use_item_block.west"));
        this.facing.addLabel(IKey.lang("blockbuster.gui.record_editor.actions.use_item_block.east"));
        this.block = new GuiThreeElement(mc, (values) -> this.action.pos = new BlockPos(values[0], values[1], values[2]));
        this.block.a.integer = true;
        this.block.b.integer = true;
        this.block.c.integer = true;
        this.hit = new GuiThreeElement(mc, (values) ->
        {
            this.action.hitX = values[0].floatValue();
            this.action.hitY = values[1].floatValue();
            this.action.hitZ = values[2].floatValue();
        });

        this.hit.flex().set(0, -25, 200, 20).relative(this.hand.resizer());
        this.block.flex().set(0, -25, 200, 20).relative(this.hit.resizer());
        this.facing.flex().set(0, -25, 70, 20).relative(this.block.resizer());

        this.add(this.facing, this.block, this.hit);
    }

    @Override
    public void fill(ItemUseBlockAction action)
    {
        super.fill(action);

        this.facing.setValue(action.facing.ordinal());
        this.block.setValues(action.pos.getX(), action.pos.getY(), action.pos.getZ());
        this.hit.setValues(action.hitX, action.hitY, action.hitZ);
    }
}

==================================================

--- Файл №121 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiMorphActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import java.util.ArrayList;
import java.util.List;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.client.gui.GuiImmersiveEditor;
import mchorse.blockbuster.client.gui.GuiImmersiveMorphMenu;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.sync.PacketSceneGoto;
import mchorse.blockbuster.recording.actions.MorphAction;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.recording.data.Record.FoundAction;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.DummyEntity;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList.OnionSkin;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.Vec3d;

public class GuiMorphActionPanel extends GuiActionPanel<MorphAction>
{
    public GuiNestedEdit pickMorph;
    public GuiColorElement onionSkin;
    public GuiElement onionSkinPanel;

    private DummyEntity actor;
    private int lastTick;

    private OnionSkin skin;

    private boolean isImmersiveEditing;
    private boolean showRecordList;
    private int cursor;

    public GuiMorphActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.pickMorph = new GuiNestedEdit(mc, this::doNestEdit);
        this.pickMorph.flex().relative(this.area).set(0, 5, 100, 20).x(0.5F, -30);

        this.onionSkin = new GuiColorElement(mc, Blockbuster.morphActionOnionSkinColor);

        this.onionSkinPanel = Elements.column(mc, 10, 5, Elements.label(IKey.lang("blockbuster.config.onion_skin.title")), this.onionSkin);
        this.onionSkinPanel.flex().relative(this.area).x(0F, 10).y(1F, -20).w(150).anchorY(1F);

        this.add(this.pickMorph, this.onionSkinPanel);

        this.actor = new DummyEntity(this.mc.world);
    }

    @Override
    public void setMorph(AbstractMorph morph)
    {
        this.action.morph = morph;
        this.pickMorph.setMorph(action.morph);
    }

    @Override
    public void fill(MorphAction action)
    {
        super.fill(action);

        ClientProxy.panels.morphs.removeFromParent();
        this.pickMorph.setMorph(action.morph);

        this.onionSkinPanel.setVisible(CameraHandler.get() != null && CameraHandler.isCameraEditorOpen());
    }

    @Override
    public void disappear()
    {
        ClientProxy.panels.morphs.finish();
        ClientProxy.panels.morphs.removeFromParent();

        if (this.isImmersiveEditing)
        {
            ClientProxy.panels.closeImmersiveEditor();
        }

        this.action.morph = MorphUtils.copy(this.action.morph);

        super.disappear();
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.action.morph != null)
        {
            int x = this.area.mx();
            int y = this.area.y(0.8F);

            GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);
            this.action.morph.renderOnScreen(this.mc.player, x, y, this.area.h / 3F, 1.0F);
            GuiDraw.unscissor(context);
        }

        super.draw(context);
    }

    public void doNestEdit(boolean editing)
    {
        if (CameraHandler.get() != null && CameraHandler.isCameraEditorOpen())
        {
            this.lastTick = -1;

            if (Blockbuster.immersiveRecordEditor.get())
            {
                this.cursor = Math.max(0, CameraHandler.getOffset());

                CameraHandler.detachOutside();

                GuiImmersiveEditor editor = ClientProxy.panels.showImmersiveEditor(editing, this.action.morph);

                editor.morphs.updateCallback = this::updateMorphEditor;
                editor.morphs.frameProvider = this::getFrame;
                editor.onClose = this::onImmersiveEditorClose;

                this.panel.records.removeFromParent();
                this.panel.records.flex().relative(editor.outerPanel);
                this.panel.timeline.removeFromParent();
                this.panel.timeline.flex().relative(editor.outerPanel);

                editor.outerPanel.add(this.panel.records, this.panel.timeline);

                this.addOnionSkin(editor.morphs);

                this.isImmersiveEditing = true;
                this.showRecordList = this.panel.records.isVisible();
                this.panel.records.setVisible(true);
            }
            else
            {
                ClientProxy.panels.addMorphs(this, editing, this.action.morph);

                this.addOnionSkin(ClientProxy.panels.morphs);
            }
        }
        else
        {
            ClientProxy.panels.addMorphs(this, editing, this.action.morph);
        }
    }

    public void updateMorphEditor(GuiImmersiveMorphMenu menu)
    {
        Record record = ClientProxy.manager.records.get(this.panel.record.filename);
        int tick = this.panel.timeline.getCurrentTick();

        if (menu.isNested())
        {
            tick = this.lastTick;
        }
        else
        {
            tick += menu.editor.delegate.getCurrentTick();
        }

        if (tick != this.lastTick)
        {
            Dispatcher.sendToServer(new PacketSceneGoto(CameraHandler.get(), tick, CameraHandler.actions.get()));

            if (record != null && record.getFrameSafe(0) != null)
            {
                record.applyFrame(Math.max(tick - 1, 0), this.actor, true, true);

                Frame frame = record.getFrameSafe(tick - 1);

                if (frame.hasBodyYaw)
                {
                    this.actor.renderYawOffset = frame.bodyYaw;
                }
            }
            else
            {
                menu.target = null;
            }

            this.lastTick = tick;
        }

        boolean refreshTarget = true;

        if (menu.target != null && menu.target != this.actor && this.mc.world.getLoadedEntityList().contains(menu.target))
        {
            refreshTarget = false;
        }

        if (refreshTarget)
        {
            EntityLivingBase entity = null;

            for (EntityLivingBase actor : Minecraft.getMinecraft().world.getEntities(EntityLivingBase.class, actor ->
            {
                return actor.isEntityAlive() && EntityUtils.getRecordPlayer(actor) != null && EntityUtils.getRecordPlayer(actor).record != null && this.panel.record.filename.equals(EntityUtils.getRecordPlayer(actor).record.filename);
            }))
            {
                entity = actor;

                break;
            }

            if (entity == null)
            {
                entity = this.actor;
            }

            menu.target = entity;
        }

        if (menu.target instanceof EntityActor)
        {
            ((EntityActor) menu.target).morph.setDirect(null);
        }
        else if (menu.target instanceof EntityPlayer)
        {
            MorphAPI.morph((EntityPlayer) menu.target, null, true);
        }

        if (record != null && !record.frames.isEmpty() && this.skin != null && menu.target != null)
        {
            Frame last = record.getFrameSafe(this.panel.timeline.getCurrentTick() - 1);
            EntityLivingBase actor = menu.target;
            float yaw = actor.rotationYaw;

            Vec3d pos = new Vec3d(last.x - actor.posX, last.y - actor.posY, last.z - actor.posZ);
            pos = pos.rotateYaw((float) Math.toRadians(yaw));

            this.skin.offset(pos.x, pos.y, pos.z, last.pitch, last.yawHead - yaw, last.bodyYaw - yaw);
        }
    }

    public Frame getFrame(int tick)
    {
        Record record = ClientProxy.manager.records.get(this.panel.record.filename);

        if (record != null)
        {
            return record.getFrameSafe(this.panel.timeline.getCurrentTick() + tick - 1);
        }
        else
        {
            return null;
        }
    }

    public void addOnionSkin(GuiCreativeMorphsList morphs)
    {
        if (this.onionSkin.picker.color.a < 0.003921F)
        {
            return;
        }

        List<OnionSkin> skins = new ArrayList<OnionSkin>();
        Record record = this.panel.record;
        Color color = this.onionSkin.picker.color;

        if (record != null)
        {
            FoundAction found = record.seekMorphAction(this.panel.timeline.getCurrentTick(), this.action);
            AbstractMorph morph = null;
            int tick = 0;

            if (found != null)
            {
                morph = found.action.morph;
                tick = found.tick;
            }
            else
            {
                for (Replay replay : ClientProxy.panels.scenePanel.getReplays())
                {
                    if (replay.id.equals(this.panel.record.filename))
                    {
                        morph = replay.morph;
                        break;
                    }
                }
            }

            if (morph != null)
            {
                MorphUtils.pause(morph, null, Math.max(0, this.panel.timeline.getCurrentTick() - tick));

                this.skin = new OnionSkin().color(color.r, color.g, color.b, color.a).morph(morph);
                skins.add(this.skin);
            }
        }

        morphs.lastOnionSkins = skins;
    }

    public void onImmersiveEditorClose(GuiImmersiveEditor editor)
    {
        this.isImmersiveEditing = false;

        this.panel.records.setVisible(this.showRecordList);

        CameraHandler.updatePlayerPosition();
        CameraHandler.attachOutside();
        CameraHandler.moveRecordPanel(this.panel);

        Dispatcher.sendToServer(new PacketSceneGoto(CameraHandler.get(), this.cursor, CameraHandler.actions.get()));
    }
}


==================================================

--- Файл №122 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiMountingActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.MountingAction;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiMountingActionPanel extends GuiActionPanel<MountingAction>
{
    public GuiToggleElement mounting;

    public GuiMountingActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.mounting = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.record_editor.mounting"), false, (b) -> this.action.isMounting = b.isToggled());
        this.mounting.flex().set(10, 0, 60, 11).relative(this.area).y(1, -21);

        this.add(this.mounting);
    }

    @Override
    public void fill(MountingAction action)
    {
        super.fill(action);

        this.mounting.toggled(action.isMounting);
    }
}


==================================================

--- Файл №123 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiPlaceBlockActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.PlaceBlockAction;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiPlaceBlockActionPanel extends GuiBlockActionPanel<PlaceBlockAction>
{
    public GuiTextElement block;
    public GuiTrackpadElement meta;

    public GuiPlaceBlockActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.block = new GuiTextElement(mc, (str) -> this.action.block = str);
        this.meta = new GuiTrackpadElement(mc, (value) -> this.action.metadata = value.byteValue());
        this.meta.tooltip(IKey.lang("blockbuster.gui.record_editor.meta"));

        this.block.flex().set(0, -30, 100, 20).relative(this.meta.resizer());
        this.meta.flex().set(0, -30, 100, 20).relative(this.x.resizer());
        this.meta.limit(0, 15, true);

        this.add(this.block, this.meta);
    }

    @Override
    public void fill(PlaceBlockAction action)
    {
        super.fill(action);

        this.block.setText(action.block);
        this.meta.setValue(action.metadata);
    }
}

==================================================

--- Файл №124 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\recording_editor\actions\GuiShootArrowActionPanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.recording.actions.ShootArrowAction;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiShootArrowActionPanel extends GuiActionPanel<ShootArrowAction>
{
    public GuiTrackpadElement charge;

    public GuiShootArrowActionPanel(Minecraft mc, GuiRecordingEditorPanel panel)
    {
        super(mc, panel);

        this.charge = new GuiTrackpadElement(mc, (charge) -> this.action.charge = charge.intValue());
        this.charge.tooltip(IKey.lang("blockbuster.gui.record_editor.arrow_charge"));
        this.charge.limit(0, 100, true);
        this.charge.flex().set(10, 0, 100, 20).relative(this.area).y(1, -30);

        this.add(this.charge);
    }

    @Override
    public void fill(ShootArrowAction action)
    {
        super.fill(action);

        this.charge.setValue(action.charge);
    }
}

==================================================

--- Файл №125 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\scene\GuiReplaySelector.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.scene;

import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;

import java.util.List;
import java.util.function.Consumer;

/**
 * This GUI is responsible for drawing replays available in the 
 * director thing
 */
public class GuiReplaySelector extends GuiListElement<Replay>
{
    private String hovered;
    private int hoverX;
    private int hoverY;

    public GuiReplaySelector(Minecraft mc, Consumer<List<Replay>> callback)
    {
        super(mc, callback);

        this.horizontal().sorting();
        this.scroll.scrollItemSize = 40;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.hovered = null;

        super.draw(context);

        if (this.hovered != null)
        {
            int w = this.font.getStringWidth(hovered);
            int x = this.hoverX - w / 2;

            Gui.drawRect(x - 2, this.hoverY - 1, x + w + 2, this.hoverY + 9, ColorUtils.HALF_BLACK);
            this.font.drawStringWithShadow(this.hovered, x, this.hoverY, 0xffffff);
        }
        else if (this.getList().isEmpty())
        {
            this.drawCenteredString(this.font, I18n.format("blockbuster.gui.director.no_replays"), this.area.mx(), this.area.my() - 6, 0xffffff);
        }
    }

    @Override
    public void drawListElement(Replay replay, int i, int x, int y, boolean hover, boolean selected)
    {
        int w = this.scroll.scrollItemSize;
        int h = this.scroll.h;
        boolean isDragging = this.isDragging() && this.getDraggingIndex() == i;

        if (isDragging)
        {
            y -= 20;
        }
        else
        {
            x += w / 2;
        }

        if (selected && !isDragging)
        {
            Gui.drawRect(x - w / 2, y, x + w / 2, y + h, 0xaa000000 + McLib.primaryColor.get());
            GuiDraw.scissor(x - w / 2, y, w, h, GuiBase.getCurrent());
        }

        if (replay.morph != null)
        {
            replay.morph.renderOnScreen(this.mc.player, x, y + (int) (this.scroll.h * 0.8F), 24, 1);
        }
        else
        {
            GlStateManager.color(1, 1, 1);
            BBIcons.CHICKEN.render(x - 8, y + this.scroll.h / 2 - 8);
        }

        if (selected && !isDragging)
        {
            GuiDraw.drawOutline(x - w / 2, y, x + w / 2, y + h, 0xff000000 + McLib.primaryColor.get(), 2);
            GuiDraw.unscissor(GuiBase.getCurrent());
        }

        if (hover && !replay.id.isEmpty() && this.hovered == null)
        {
            this.hovered = replay.id;
            this.hoverX = x;
            this.hoverY = y + this.scroll.h / 2;
        }
    }
}

==================================================

--- Файл №126 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\scene\GuiSceneManager.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.PacketRequestScenes;
import mchorse.blockbuster.network.common.scene.PacketSceneManage;
import mchorse.blockbuster.network.common.scene.PacketSceneRequestCast;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.blockbuster.recording.scene.SceneManager;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiConfirmModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.resources.I18n;

import java.io.IOException;
import java.util.List;

/**
 * Scene manager GUI
 */
public class GuiSceneManager extends GuiElement
{
    public GuiScenePanel parent;
    public GuiStringListElement sceneList;

    /* Elements for scene manager */
    public GuiIconElement add;
    public GuiIconElement dupe;
    public GuiIconElement rename;
    public GuiIconElement remove;

    public GuiSceneManager(Minecraft mc, GuiScenePanel parent)
    {
        super(mc);

        this.parent = parent;

        /* Scene manager elements */
        this.sceneList = new GuiStringListElement(mc, (scene) -> this.switchScene(scene.get(0)));
        this.add = new GuiIconElement(mc, Icons.ADD, (b) -> this.addScene());
        this.add.tooltip(IKey.lang("blockbuster.gui.scenes.add_scene"));
        this.dupe = new GuiIconElement(mc, Icons.DUPE, (b) -> this.dupeScene());
        this.dupe.tooltip(IKey.lang("blockbuster.gui.scenes.dupe_scene"));
        this.rename = new GuiIconElement(mc, Icons.EDIT, (b) -> this.renameScene());
        this.rename.tooltip(IKey.lang("blockbuster.gui.scenes.rename_scene"));
        this.remove = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.removeScene());
        this.remove.tooltip(IKey.lang("blockbuster.gui.scenes.remove_scene"));

        this.sceneList.flex().relative(this.area).set(0, 20, 0, 0).w(1, 0).h(1, -20);
        this.add.flex().relative(this.area).set(0, 2, 16, 16).x(1, -78);
        this.dupe.flex().relative(this.add.resizer()).set(20, 0, 16, 16);
        this.rename.flex().relative(this.dupe.resizer()).set(20, 0, 16, 16);
        this.remove.flex().relative(this.rename.resizer()).set(20, 0, 16, 16);

        /* Add children */
        this.add(this.sceneList, this.add, this.dupe, this.rename, this.remove);
        this.hideTooltip();
    }

    /* Popup callbacks */

    private void switchScene(String scene)
    {
        this.parent.close();
        Dispatcher.sendToServer(new PacketSceneRequestCast(new SceneLocation(scene)));
    }

    private void addScene()
    {
        GuiModal.addFullModal(this, () -> new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.scenes.add_modal"), (name) ->
        {
            if (this.sceneList.getList().contains(name) || !SceneManager.isValidFilename(name)) return;

            Scene scene = new Scene();

            scene.setId(name);
            this.sceneList.add(name);
            this.sceneList.sort();
            this.sceneList.setCurrent(name);

            this.parent.setScene(new SceneLocation(scene));
        }).filename());
    }

    private void dupeScene()
    {
        if (!this.parent.getLocation().isScene())
        {
            return;
        }

        GuiModal.addFullModal(this, () ->
        {

            GuiToggleElement dupeRecordings = new GuiToggleElement(this.mc, IKey.lang("blockbuster.gui.scenes.dupe_recordings"), null);

            GuiPromptModal modal = new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.scenes.dupe_modal"), (name) ->
            {
                if (this.sceneList.getList().contains(name) || !SceneManager.isValidFilename(name)) return;

                Scene scene = new Scene();

                scene.copy(this.parent.getLocation().getScene());
                scene.setId(name);
                scene.setupIds();
                scene.renamePrefix(this.parent.getLocation().getScene().getId(), scene.getId(), (id) -> id + "_copy");

                //copy recordings
                if (dupeRecordings.isToggled())
                {
                    Dispatcher.sendToServer(new PacketSceneManage(this.parent.getLocation().getScene().getId(), name, PacketSceneManage.DUPE));
                }

                this.sceneList.add(name);
                this.sceneList.sort();
                this.sceneList.setCurrent(name);

                this.parent.setScene(new SceneLocation(scene));
                this.parent.close();
            });

            dupeRecordings.tooltip(IKey.lang("blockbuster.gui.scenes.dupe_recordings_tooltip"));
            dupeRecordings.flex().relative(modal.bar).y(-50).x(10).w(1F, -20);
            modal.add(dupeRecordings);

            return modal.filename().setValue(this.parent.getLocation().getFilename());
        });
    }

    private void renameScene()
    {
        if (!this.parent.getLocation().isScene())
        {
            return;
        }

        GuiModal.addFullModal(this, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(mc, IKey.lang("blockbuster.gui.scenes.rename_modal"), (name) ->
            {
                if (this.sceneList.getList().contains(name) || !SceneManager.isValidFilename(name)) return;

                String old = this.parent.getLocation().getFilename();

                this.sceneList.remove(old);
                this.parent.getLocation().getScene().setId(name);
                this.sceneList.add(name);
                this.sceneList.sort();
                this.sceneList.setCurrent(name);
                this.parent.setScene(new SceneLocation(this.parent.getLocation().getScene()));

                Dispatcher.sendToServer(new PacketSceneManage(old, name, PacketSceneManage.RENAME));
            });

            return modal.filename().setValue(this.parent.getLocation().getFilename());
        });
    }

    private void removeScene()
    {
        if (!this.parent.getLocation().isScene())
        {
            return;
        }

        GuiModal.addFullModal(this, () -> new GuiConfirmModal(this.mc, IKey.lang("blockbuster.gui.scenes.remove_modal"), (value) ->
        {
            if (!value) return;

            String name = this.parent.getLocation().getFilename();

            this.sceneList.remove(name);
            this.sceneList.update();
            this.sceneList.setCurrent((String) null);
            this.parent.setScene(new SceneLocation());

            Dispatcher.sendToServer(new PacketSceneManage(name, "", PacketSceneManage.REMOVE));
        }));
    }

    /* Scene manager methods */

    public void setScene(Scene scene)
    {
        this.sceneList.setCurrent(scene == null ? "" : scene.getId());
    }

    public void updateSceneList()
    {
        Dispatcher.sendToServer(new PacketRequestScenes());
    }

    public void add(List<String> scenes)
    {
        String current = this.sceneList.getCurrentFirst();

        this.sceneList.clear();
        this.sceneList.add(scenes);
        this.sceneList.sort();
        this.sceneList.setCurrent(current);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xaa000000);
        Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.y + 20, ColorUtils.HALF_BLACK);
        this.font.drawStringWithShadow(I18n.format("blockbuster.gui.scenes.title"), this.area.x + 6, this.area.y + 7, 0xffffff);

        super.draw(context);
    }
}

==================================================

--- Файл №127 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\scene\GuiScenePanel.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.scene;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanel;
import mchorse.blockbuster.common.BlockbusterPermissions;
import mchorse.blockbuster.common.item.ItemPlayback;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketPlaybackButton;
import mchorse.blockbuster.network.common.recording.PacketUpdatePlayerData;
import mchorse.blockbuster.network.common.scene.PacketSceneCast;
import mchorse.blockbuster.network.common.scene.PacketScenePause;
import mchorse.blockbuster.network.common.scene.PacketScenePlayback;
import mchorse.blockbuster.network.common.scene.PacketSceneRecord;
import mchorse.blockbuster.network.server.recording.ServerHandlerFramesOverwrite;
import mchorse.blockbuster.network.server.recording.ServerHandlerRequestRecording;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiCollapseSection;
import mchorse.mclib.client.gui.framework.elements.GuiDelegateElement;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPopUpModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.permissions.PermissionCategory;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.OpHelper;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.util.text.event.ClickEvent;
import net.minecraft.util.text.event.HoverEvent;
import org.lwjgl.input.Keyboard;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class GuiScenePanel extends GuiBlockbusterPanel
{
    private GuiElement subChildren;
    private GuiDelegateElement<GuiElement> mainView;
    private GuiElement replays;
    private GuiElement replayEditor;
    private GuiElement configOptions;
    private GuiReplaySelector selector;

    /* Config fields */
    public GuiTextElement title;
    public GuiTextElement startCommand;
    public GuiTextElement stopCommand;
    public GuiToggleElement loops;

    public GuiStringListElement audio;
    public GuiTrackpadElement audioShift;
    public GuiIconElement openAudioFolder;

    /* Replay fields */
    public GuiTextElement id;
    public GuiTextElement name;
    public GuiTextElement target;
    public GuiToggleElement playbackXPFood;
    public GuiToggleElement invincible;
    public GuiToggleElement invisible;
    public GuiToggleElement enableBurning;
    public GuiToggleElement enabled;
    public GuiToggleElement fake;
    public GuiToggleElement teleportBack;
    public GuiToggleElement renderLast;
    public GuiTrackpadElement health;
    public GuiTrackpadElement foodLevel;
    public GuiTrackpadElement totalExperience;

    public GuiButtonElement record;
    public GuiButtonElement rename;
    public GuiButtonElement attach;
    public GuiButtonElement camera;
    public GuiButtonElement teleport;
    public GuiCollapseSection eulerFilter;
    public GuiCirculateElement eulerFilterChannel;
    public GuiTrackpadElement eulerFilterFrom;
    public GuiTrackpadElement eulerFilterTo;
    public GuiButtonElement eulerFilterExecute;

    public GuiLabel recordingId;
    public GuiNestedEdit pickMorph;

    public GuiSceneManager scenes;

    private SceneLocation location = new SceneLocation();
    private Replay replay;

    private IKey noneAudioTrack = IKey.lang("blockbuster.gui.director.none");

    public GuiScenePanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        this.selector = new GuiReplaySelector(mc, (replay) -> this.setReplay(replay.get(0)));
        this.selector.flex().set(0, 0, 0, 60).relative(this).w(1, -20).y(1, -60);

        GuiElement left = new GuiElement(mc);
        GuiElement right = new GuiElement(mc);

        left.flex().relative(this).w(120).y(20).hTo(this.selector.flex()).column(5).width(100).height(20).padding(10);
        right.flex().relative(this).x(1F).y(20).w(120).hTo(this.selector.flex()).anchorX(1F).column(5).flip().width(100).height(20).padding(10);

        this.subChildren = new GuiElement(mc).noCulling();
        this.subChildren.setVisible(false);
        this.replays = new GuiElement(mc).noCulling();
        this.replayEditor = new GuiElement(mc).noCulling();
        this.replayEditor.setVisible(false);
        this.replayEditor.add(left, right);
        this.configOptions = new GuiElement(mc).noCulling();
        this.mainView = new GuiDelegateElement<GuiElement>(mc, this.replays);
        this.mainView.noCulling();

        this.add(this.subChildren);
        this.subChildren.add(this.mainView);

        /* Config options */
        this.title = new GuiTextElement(mc, 80, (str) -> this.location.getScene().title = str);
        this.startCommand = new GuiTextElement(mc, 10000, (str) -> this.location.getScene().startCommand = str);
        this.stopCommand = new GuiTextElement(mc, 10000, (str) -> this.location.getScene().stopCommand = str);
        this.loops = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.loops"), false, (b) -> this.location.getScene().loops = b.isToggled());

        this.audio = new GuiStringListElement(mc, (value) -> this.location.getScene().setAudio(value.get(0).equals(this.noneAudioTrack.get()) ? "" : value.get(0)));
        this.audio.background().tooltip(IKey.lang("blockbuster.gui.director.audio_tooltip"), Direction.RIGHT);
        this.audioShift = new GuiTrackpadElement(mc, (value) -> this.location.getScene().setAudioShift(value.intValue()));
        this.audioShift.integer().tooltip(IKey.lang("blockbuster.gui.director.audio_shift_tooltip"));
        this.openAudioFolder = new GuiIconElement(mc, Icons.FOLDER, (b) -> GuiUtils.openFolder(ClientProxy.audio.folder.getAbsolutePath()));
        this.openAudioFolder.tooltip(IKey.lang("blockbuster.gui.director.open_audio_folder"));

        this.title.flex().set(120, 50, 0, 20).relative(this.area).w(1, -130);
        this.startCommand.flex().set(120, 90, 0, 20).relative(this.area).w(1, -130);
        this.stopCommand.flex().set(120, 130, 0, 20).relative(this.area).w(1, -130);

        this.audio.flex().relative(this).xy(10, 50).w(100).hTo(this.stopCommand.area, 1F);
        this.audioShift.flex().relative(this.audio).y(1F, 5).w(1F);
        this.openAudioFolder.flex().relative(this.audio).x(1F, -16).y(-16).wh(16, 16);

        GuiElement row = Elements.row(mc, 5, 0, 20, this.loops);

        row.flex().relative(this.stopCommand).y(25).w(1F);
        this.loops.flex().h(20);

        this.configOptions.add(this.title, this.startCommand, this.stopCommand, row, this.audio, this.audioShift, this.openAudioFolder);

        /* Replay options */
        this.id = new GuiTextElement(mc, 120, (str) ->
        {
            this.replay.id = str;

            this.updateLabel(true);
        }).filename();
        this.name = new GuiTextElement(mc, 80, (str) -> this.replay.name = str);
        this.name.tooltip(IKey.lang("blockbuster.gui.director.name_tooltip"), Direction.RIGHT);
        this.target = new GuiTextElement(mc, 80, (str) -> this.replay.target = str);
        this.target.tooltip(IKey.lang("blockbuster.gui.director.target_tooltip"), Direction.LEFT);
        this.playbackXPFood = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.playback_xp_food_level_enabled"), (b) -> this.replay.playBackXPFood = b.isToggled());
        this.playbackXPFood.tooltip(IKey.lang("blockbuster.gui.director.playback_xp_food_level_tooltip"), Direction.LEFT);
        this.invincible = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.invincible"), false, (b) -> this.replay.invincible = b.isToggled());
        this.invisible = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.invisible"), false, (b) -> this.replay.invisible = b.isToggled());
        this.enableBurning = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.enable_burning"), true, (b) -> this.replay.enableBurning = b.isToggled());
        this.enabled = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.enabled"), false, (b) -> this.replay.enabled = b.isToggled());
        this.fake = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.fake_player"), false, (b) -> this.replay.fake = b.isToggled());
        this.teleportBack = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.tp_back"), false, (b) -> this.replay.teleportBack = b.isToggled());
        this.teleportBack.tooltip(IKey.lang("blockbuster.gui.director.tp_back_tooltip"), Direction.RIGHT);
        this.renderLast = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.render_last"), false, (b) -> this.replay.renderLast = b.isToggled());
        this.renderLast.tooltip(IKey.lang("blockbuster.gui.director.render_last_tooltip"), Direction.RIGHT);
        this.health = new GuiTrackpadElement(mc, (value) -> this.replay.health = value.floatValue());
        this.health.limit(0);
        this.foodLevel = new GuiTrackpadElement(mc, (value) -> this.replay.foodLevel = value.intValue());
        this.foodLevel.limit(0).integer();
        this.totalExperience = new GuiTrackpadElement(mc, (value) -> this.replay.totalExperience = value.intValue());
        this.totalExperience.limit(0).integer();
        this.recordingId = Elements.label(IKey.lang("blockbuster.gui.director.id")).color(0xcccccc);

        left.add(this.recordingId, this.id);
        left.add(Elements.label(IKey.lang("blockbuster.gui.director.name")).color(0xcccccc), this.name);
        left.add(Elements.label(IKey.lang("blockbuster.gui.director.health")).color(0xcccccc), this.health,
                 Elements.label(IKey.lang("blockbuster.gui.director.food_level")).color(0xcccccc), this.foodLevel,
                 Elements.label(IKey.lang("blockbuster.gui.director.total_experience")).color(0xcccccc), this.totalExperience,
                 this.invincible, this.invisible, this.enableBurning, this.enabled, this.fake, this.teleportBack, this.renderLast);
        this.replays.add(this.selector, this.replayEditor);

        /* Toggle view button */
        GuiIconElement toggle = new GuiIconElement(mc, Icons.GEAR, (b) ->
        {
            this.mainView.setDelegate(this.mainView.delegate == this.configOptions ? this.replays : this.configOptions);
        });

        GuiIconElement toggleScenes = new GuiIconElement(mc, Icons.MORE, (b) -> this.scenes.toggleVisible());
        toggleScenes.flex().y(4).relative(this.area).x(1, -24);

        toggle.tooltip(IKey.lang("blockbuster.gui.director.config"), Direction.LEFT);
        toggle.flex().y(4).relative(this.area).x(1, -44);

        this.add(toggleScenes);
        this.subChildren.add(toggle);

        /* Add, duplicate and remove replay buttons */
        GuiIconElement add = new GuiIconElement(mc, Icons.ADD, (b) -> this.addReplay());
        GuiIconElement dupe = new GuiIconElement(mc, Icons.DUPE, (b) -> this.dupeReplay());
        GuiIconElement remove = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.removeReplay());

        add.tooltip(IKey.lang("blockbuster.gui.director.add_replay"), Direction.LEFT);
        dupe.tooltip(IKey.lang("blockbuster.gui.director.dupe_replay"), Direction.LEFT);
        remove.tooltip(IKey.lang("blockbuster.gui.director.remove_replay"), Direction.LEFT);

        add.flex().set(0, 0, 20, 20).relative(this.selector.resizer()).x(1F);
        dupe.flex().set(0, 20, 20, 20).relative(this.selector.resizer()).x(1F);
        remove.flex().set(0, 40, 20, 20).relative(this.selector.resizer()).x(1F);

        this.replays.add(add, dupe, remove);

        /* Additional utility buttons */
        IKey category = IKey.lang("blockbuster.gui.director.keys.category");
        Supplier<Boolean> active = () -> this.replay != null;

        this.pickMorph = new GuiNestedEdit(mc, (editing) -> ClientProxy.panels.addMorphs(this, editing, this.replay.morph));
        this.record = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.record"), (b) -> this.sendRecordMessage());
        GuiButtonElement edit = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.edit_record"), (b) -> this.openRecordEditor());
        GuiButtonElement update = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.update_data"), (b) -> this.updatePlayerData());
        this.rename = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.rename_prefix"), (b) -> this.renamePrefix());
        this.attach = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.attach"), (b) -> this.attach());
        this.teleport = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.tp"), (b) -> this.teleport());
        this.teleport.keys().register(this.teleport.label, Keyboard.KEY_T, () -> this.teleport.clickItself(GuiBase.getCurrent())).category(category).active(active);

        this.eulerFilter = new GuiCollapseSection(mc, IKey.lang("blockbuster.gui.director.rotation_filter.title"));
        this.eulerFilter.setCollapsed(true);

        this.eulerFilterFrom = new GuiTrackpadElement(mc, (Consumer<Double>) null);
        this.eulerFilterFrom.limit(0).integer();
        this.eulerFilterFrom.tooltip(IKey.lang("blockbuster.gui.director.rotation_filter.from_tooltip"));

        this.eulerFilterTo = new GuiTrackpadElement(mc, (Consumer<Double>) null);
        this.eulerFilterTo.limit(0).integer();
        this.eulerFilterTo.tooltip(IKey.lang("blockbuster.gui.director.rotation_filter.to_tooltip"));

        this.eulerFilterChannel = new GuiCirculateElement(mc, null);
        this.eulerFilterChannel.addLabel(IKey.lang("blockbuster.gui.director.rotation_filter.head_yaw"));
        this.eulerFilterChannel.addLabel(IKey.lang("blockbuster.gui.director.rotation_filter.head_pitch"));
        this.eulerFilterChannel.addLabel(IKey.lang("blockbuster.gui.director.rotation_filter.body_yaw"));
        this.eulerFilterChannel.tooltip(IKey.lang("blockbuster.gui.director.rotation_filter.channel_tooltip"));

        this.eulerFilterExecute = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.rotation_filter.execute"), (b) ->
        {
            this.rotationFilter();
        });

        this.eulerFilter.addFields(this.eulerFilterChannel, this.eulerFilterFrom, this.eulerFilterTo, this.eulerFilterExecute);

        this.pickMorph.flex().relative(this.selector).x(0.5F).y(-10).w(100).anchor(0.5F, 1F);

        update.tooltip(IKey.lang("blockbuster.gui.director.update_data_tooltip"), Direction.LEFT);
        this.rename.tooltip(IKey.lang("blockbuster.gui.director.rename_prefix_tooltip"), Direction.LEFT);
        this.attach.tooltip(IKey.lang("blockbuster.gui.director.attach_tooltip"), Direction.LEFT);
        this.teleport.tooltip(IKey.lang("blockbuster.gui.director.tp_tooltip"), Direction.LEFT);

        right.add(this.attach, this.record, update, this.rename, edit);

        if (CameraHandler.isApertureLoaded())
        {
            this.camera = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.director.camera"), (b) ->
            {
                CameraHandler.location = this.location;
                CameraHandler.openCameraEditor();
            });
            this.camera.keys().register(this.camera.label, Keyboard.KEY_C, () -> this.camera.clickItself(GuiBase.getCurrent())).category(category).active(active);

            right.add(this.camera);
        }

        right.add(this.teleport, this.eulerFilter);
        right.add(Elements.label(IKey.lang("blockbuster.gui.director.target")).color(0xcccccc).marginTop(12), this.target, Elements.label(IKey.lang("blockbuster.gui.director.playback_xp_food_level")), this.playbackXPFood);
        this.replayEditor.add(this.pickMorph);

        /* Scene manager */
        this.add(this.scenes = new GuiSceneManager(mc, this));
        this.scenes.flex().relative(toggleScenes).xy(1F, 1F).w(160).hTo(this.selector.flex()).anchorX(1F);
        this.scenes.setVisible(false);

        this.keys().register(IKey.lang("blockbuster.gui.director.keys.toggle_list"), Keyboard.KEY_N, () -> toggleScenes.clickItself(GuiBase.getCurrent())).category(category);
        this.keys().register(IKey.lang("blockbuster.gui.director.keys.toggle_options"), Keyboard.KEY_O, () -> toggle.clickItself(GuiBase.getCurrent())).category(category);
    }

    @Override
    public PermissionCategory getRequiredPermission()
    {
        return BlockbusterPermissions.openScene;
    }

    public SceneLocation getLocation()
    {
        return this.location;
    }

    public Replay getReplay()
    {
        return this.replay;
    }

    public List<Replay> getReplays()
    {
        if (this.location.isEmpty())
        {
            return null;
        }

        return this.getLocation().getScene().replays;
    }

    public GuiScenePanel openScene(SceneLocation location)
    {
        this.scenes.setVisible(false);

        return this.setScene(location);
    }

    public GuiScenePanel setScene(SceneLocation location)
    {
        this.location = location == null ? new SceneLocation() : location;

        this.subChildren.setVisible(!location.isEmpty());
        this.replayEditor.setVisible(!location.isEmpty());
        this.scenes.setScene(location.getScene());

        if (location.isEmpty())
        {
            this.setReplay(null);

            return this;
        }

        this.selector.setList(location.getScene().replays);

        if (!this.location.getScene().replays.isEmpty())
        {
            int current = this.location.getScene().replays.indexOf(this.replay);

            this.setReplay(this.location.getScene().replays.get(current == -1 ? 0 : current));
        }
        else
        {
            this.setReplay(null);
        }

        this.fillData();

        return this;
    }

    public GuiScenePanel set(SceneLocation location)
    {
        this.location = location;
        this.scenes.setScene(location.getScene());

        return this;
    }

    protected void rotationFilter()
    {
        int fromTest = Math.min((int) this.eulerFilterFrom.value, (int) this.eulerFilterTo.value);
        int toTest = Math.max((int) this.eulerFilterFrom.value, (int) this.eulerFilterTo.value);

        if (toTest - fromTest + 1 < 2)
        {
            this.addPopUpModal(IKey.lang("blockbuster.gui.director.rotation_filter.not_enough_frames"));

            return;
        }

        /* wait for the requested recording to return from server */
        ServerHandlerRequestRecording.requestRecording(this.replay.id, (record) ->
        {
            Frame.RotationChannel channel = Frame.RotationChannel.values()[this.eulerFilterChannel.getValue()];

            if (record == null)
            {
                this.addPopUpModal(IKey.lang("blockbuster.gui.director.rotation_filter.record_not_loaded"));

                return;
            }

            int from = MathUtils.clamp(Math.min((int) this.eulerFilterFrom.value, (int) this.eulerFilterTo.value), 0, record.frames.size() - 1);
            int to = MathUtils.clamp(Math.max((int) this.eulerFilterFrom.value, (int) this.eulerFilterTo.value), 0, record.frames.size() - 1);

            List<Frame> frames = RecordUtils.discontinuityEulerFilter(record.frames, from, to, channel);

            if (frames.isEmpty())
            {
                this.addPopUpModal(IKey.lang("blockbuster.gui.director.rotation_filter.empty_filtered_frames"));

                return;
            }

            ServerHandlerFramesOverwrite.sendFramesToServer(record.filename, frames, from, to, (obj) ->
            {
                this.addPopUpModal(obj.getKey());
            });
        });
    }

    private void addPopUpModal(IKey lang)
    {
        GuiPopUpModal modal = new GuiPopUpModal(this.mc, lang);
        modal.flex().relative(this.parent).wh(200, 50);
        modal.setFadeDuration(0);
        modal.resize();

        this.add(modal);
    }

    @Override
    public void appear()
    {
        super.appear();

        ClientProxy.panels.picker(this::setMorph);

        if (!this.location.isEmpty())
        {
            this.setScene(this.location);
        }
    }

    @Override
    public void open()
    {
        ClientProxy.panels.morphs.reload();

        this.setScene(this.location);
        this.scenes.setScene(this.location.getScene());
        this.scenes.updateSceneList();
    }

    @Override
    public void close()
    {
        if (!OpHelper.isPlayerOp())
        {
            return;
        }

        if (this.location.isScene())
        {
            if (ClientProxy.panels.morphs.hasParent())
            {
                ClientProxy.panels.morphs.finish();
            }

            Dispatcher.sendToServer(new PacketSceneCast(this.location));
        }
    }

    private void setReplay(Replay replay)
    {
        if (this.replay != null)
        {
            this.replay.morph = MorphUtils.copy(this.replay.morph);
        }

        this.replay = replay;
        this.replayEditor.setVisible(this.replay != null);
        this.mainView.setDelegate(this.replays);
        this.selector.setCurrent(replay);
        this.fillReplayData();
    }

    private void fillData()
    {
        this.title.setText(this.location.getScene().title);
        this.startCommand.setText(this.location.getScene().startCommand);
        this.stopCommand.setText(this.location.getScene().stopCommand);
        this.loops.toggled(this.location.getScene().loops);
        this.attach.setEnabled(false);

        this.audio.clear();
        this.audio.add(this.noneAudioTrack.get());
        this.audio.add(ClientProxy.audio.getFileNames());
        this.audio.sort();

        String audio = this.location.getScene().getAudio();

        this.audio.setCurrentScroll(audio == null || audio.isEmpty() ? this.noneAudioTrack.get() : audio);

        this.audioShift.setValue(this.location.getScene().getAudioShift());

        if (this.mc != null && this.mc.player != null)
        {
            ItemStack stack = this.mc.player.getHeldItemMainhand();

            this.attach.setEnabled(!this.location.isEmpty() && stack.getItem() instanceof ItemPlayback);
        }
    }

    private void fillReplayData()
    {
        if (this.replay == null)
        {
            return;
        }

        this.id.setText(this.replay.id);
        this.name.setText(this.replay.name);
        this.target.setText(this.replay.target);
        this.playbackXPFood.toggled(this.replay.playBackXPFood);
        this.invincible.toggled(this.replay.invincible);
        this.invisible.toggled(this.replay.invisible);
        this.enableBurning.toggled(this.replay.enableBurning);
        this.enabled.toggled(this.replay.enabled);
        this.fake.toggled(this.replay.fake);
        this.teleportBack.toggled(this.replay.teleportBack);
        this.renderLast.toggled(this.replay.renderLast);
        this.health.setValue(this.replay.health);
        this.foodLevel.setValue(this.replay.foodLevel);
        this.totalExperience.setValue(this.replay.totalExperience);
        this.pickMorph.setMorph(this.replay.morph);

        this.selector.setCurrent(this.replay);
        this.updateLabel(false);
    }

    /**
     * Add an empty replay 
     */
    private void addReplay()
    {
        Replay replay = new Replay("");

        if (this.location.isScene())
        {
            replay.id = this.location.getScene().getNextBaseSuffix(this.location.getScene().getId());
        }

        this.location.getScene().replays.add(replay);
        this.setReplay(replay);
        this.selector.update();
    }

    /**
     * Duplicate a replay 
     */
    private void dupeReplay()
    {
        if (this.selector.isDeselected())
        {
            return;
        }

        Scene scene = this.location.getScene();

        if (scene.dupe(scene.replays.indexOf(this.replay)))
        {
            this.selector.update();
            this.selector.scroll.scrollTo(this.selector.getIndex() * this.selector.scroll.scrollItemSize);
            this.setReplay(scene.replays.get(scene.replays.size() - 1));
        }
    }

    /**
     * Remove replay 
     */
    private void removeReplay()
    {
        if (this.selector.isDeselected())
        {
            return;
        }

        Scene scene = this.location.getScene();
        int index = this.selector.getIndex();

        scene.replays.remove(this.replay);

        int size = scene.replays.size();
        index = MathHelper.clamp(index, 0, size - 1);

        this.setReplay(size == 0 ? null : scene.replays.get(index));
        this.selector.update();
    }

    private void setMorph(AbstractMorph morph)
    {
        if (this.replay != null)
        {
            this.replay.morph = morph;
        }

        this.pickMorph.setMorph(morph);
    }

    /**
     * update the labels
     * @param gui true when this is called by a callback from a GuiElement
     */
    private void updateLabel(boolean gui)
    {
        boolean error = this.replay != null && this.replay.id.isEmpty();

        this.recordingId.color(error ? 0xff3355 : 0xcccccc);

        if (this.replay != null && !this.replay.id.isEmpty() && gui)
        {
            boolean isDuplicate = false;

            for (Replay element : this.scenes.parent.getLocation().getScene().replays)
            {
                if (element.id.equals(this.replay.id) && this.replay != element)
                {
                    isDuplicate = true;

                    break;
                }
            }

            if (isDuplicate)
            {
                GuiModal.addModal(this, () ->
                {
                    GuiPopUpModal modal = new GuiPopUpModal(this.mc, IKey.lang("blockbuster.gui.director.rename_replay_dupe_modal"));
                    modal.flex().relative(this.parent).wh(220, 50);

                    return modal;
                });
            }
        }
    }

    /**
     * Send record message to the player
     */
    private void sendRecordMessage()
    {
        EntityPlayer player = this.mc.player;

        if (this.replay.id.isEmpty())
        {
            Blockbuster.l10n.error(player, "recording.fill_filename");

            return;
        }

        String command = "/action record " + this.replay.id + " " + this.location.getFilename();
        ITextComponent component = new TextComponentString(I18n.format("blockbuster.info.recording.clickhere"));

        component.getStyle().setClickEvent(new ClickEvent(ClickEvent.Action.RUN_COMMAND, command));
        component.getStyle().setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new TextComponentString(command)));
        component.getStyle().setColor(TextFormatting.GRAY).setUnderlined(true);

        Blockbuster.l10n.info(player, "recording.message", this.replay.id, component);

        /* Add the command to the history */
        List<String> messages = this.mc.ingameGUI.getChatGUI().getSentMessages();

        boolean empty = messages.isEmpty();
        boolean lastMessageIsntCommand = !empty && !messages.get(messages.size() - 1).equals(command);

        if (lastMessageIsntCommand || empty)
        {
            messages.add(command);
        }
    }

    private void attach()
    {
        if (CameraHandler.isApertureLoaded())
        {
            CameraHandler.attach(this.location, this.scenes.sceneList.getList());
        }
        else
        {
            Dispatcher.sendToServer(new PacketPlaybackButton(this.location, 0, ""));

            this.mc.displayGuiScreen(null);
        }
    }

    private void openRecordEditor()
    {
        if (this.replay != null && !this.replay.id.isEmpty())
        {
            this.dashboard.panels.setPanel(ClientProxy.panels.recordingEditorPanel);
            ClientProxy.panels.recordingEditorPanel.selectRecord(this.replay.id);
            ClientProxy.panels.recordingEditorPanel.records.setVisible(false);
        }
    }

    private void updatePlayerData()
    {
        Dispatcher.sendToServer(new PacketUpdatePlayerData(this.replay.id));
    }

    private void teleport()
    {
        if (this.replay == null)
        {
            return;
        }

        this.mc.displayGuiScreen(null);

        try
        {
            RecordUtils.applyFrameOnEntity(Minecraft.getMinecraft().player, ClientProxy.manager.get(this.replay.id), 0); //TODO requires client to request recording from server
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private void renamePrefix()
    {
        GuiModal.addModal(this.replayEditor, () ->
        {
            GuiPromptModal modal = new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.director.rename_prefix_popup"), this::renamePrefix);

            modal.markIgnored().flex().relative(this.rename).y(1F).w(1F).h(120);

            return modal;
        });
    }

    private void renamePrefix(String newPrefix)
    {
        this.location.getScene().renamePrefix(newPrefix);
        this.fillReplayData();
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.scenes.isVisible())
        {
            int x = this.scenes.area.ex() - 20;
            int y = this.scenes.area.y - 20;

            Gui.drawRect(x, y, x + 20, y + 20, ColorUtils.HALF_BLACK);
        }

        /* Draw additional stuff */
        if (this.mainView.delegate == this.replays)
        {
            Gui.drawRect(this.selector.area.x, this.selector.area.y, this.selector.area.ex() + 20, this.selector.area.ey(), ColorUtils.HALF_BLACK);
            this.drawGradientRect(this.selector.area.x, this.selector.area.y - 16, this.selector.area.ex() + 20, this.selector.area.y, 0, ColorUtils.HALF_BLACK);

            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.scenes.title"), this.area.x + 10, this.area.y + 10, 0xffffff);

            if (this.replay != null)
            {
                AbstractMorph morph = this.replay.morph;

                if (morph != null)
                {
                    int x = this.area.mx();
                    int y = this.area.y(0.55F);

                    GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);
                    morph.renderOnScreen(this.mc.player, x, y, this.area.h / 3.5F, 1.0F);
                    GuiDraw.unscissor(context);
                }
            }
        }
        else
        {
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.director.config"), this.area.x + 10, this.area.y + 10, 0xffffff);

            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.director.audio"), this.audio.area.x, this.audio.area.y - 12, 0xcccccc);
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.director.start_command"), this.startCommand.area.x, this.startCommand.area.y - 12, 0xcccccc);
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.director.stop_command"), this.stopCommand.area.x, this.stopCommand.area.y - 12, 0xcccccc);
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.director.display_title"), this.title.area.x, this.title.area.y - 12, 0xcccccc);
        }

        if (this.location.isEmpty())
        {
            String no = I18n.format("blockbuster.gui.director.not_selected");

            this.drawCenteredString(this.font, no, this.area.mx(), this.area.my() - 6, 0xffffff);
        }

        super.draw(context);
    }

    public void plause()
    {
        if (!OpHelper.isPlayerOp())
        {
            return;
        }

        if (this.location.isScene())
        {
            Dispatcher.sendToServer(new PacketScenePlayback(this.location));
        }
    }

    public void record()
    {
        if (!OpHelper.isPlayerOp())
        {
            return;
        }

        Replay replay = this.replay;

        if (replay != null && !replay.id.isEmpty() && this.location.isScene())
        {
            Dispatcher.sendToServer(new PacketSceneRecord(this.location, replay.id));
        }
    }

    public void pause()
    {
        if (!OpHelper.isPlayerOp())
        {
            return;
        }

        if (this.location.isScene())
        {
            Dispatcher.sendToServer(new PacketScenePause(this.location));
        }
    }
}

==================================================

--- Файл №128 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\GuiSectionManager.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm;

import java.util.HashMap;
import java.util.Map;

public class GuiSectionManager
{
    private static final Map<String, Boolean> STATES = new HashMap<String, Boolean>();

    public static boolean isCollapsed(String id)
    {
        Boolean state = STATES.get(id);
        
        if (state == null)
        {
            state = true; // default value
            STATES.put(id, state);
        }
        
        return state;
    }

    public static void setCollapsed(String id, boolean collapsed)
    {
        STATES.put(id, collapsed);
    }
    
    /**
     * This method only adds a state to the Map if the id isn't present
     * @param id
     * @param collapsed
     */
    public static void setDefaultState(String id, boolean collapsed)
    {
        if (!STATES.containsKey(id))
        {
            STATES.put(id, collapsed);
        }
    }
}


==================================================

--- Файл №129 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\GuiSnowstorm.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormAppearanceSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormCollisionAppearanceSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormCollisionLightingSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormCollisionSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormExpirationSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormGeneralSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormInitializationSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormLifetimeSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormLightingSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormMotionSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormParticleMorphSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormRateSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormShapeSection;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormSpaceSection;
import mchorse.blockbuster.client.particles.BedrockLibrary;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringSearchListElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiConfirmModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiPromptModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDrawable;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;

public class GuiSnowstorm extends GuiBlockbusterPanel
{
    public static final String DEFAULT_PARTICLE = "default_snow";

    public GuiSnowstormRenderer renderer;
    public GuiScrollElement editor;

    public GuiIconElement open;
    public GuiIconElement save;

    public GuiElement modal;
    public GuiIconElement add;
    public GuiIconElement dupe;
    public GuiIconElement remove;
    public GuiIconElement folder;
    public GuiStringSearchListElement particles;

    public List<GuiSnowstormSection> sections = new ArrayList<GuiSnowstormSection>();
    private GuiSnowstormParticleMorphSection particleMorphSection;

    private BedrockLibrary library;

    private String filename;
    private BedrockScheme scheme;
    private boolean dirty;

    public GuiSnowstorm(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        /* TODO: Add link to snowstorm web editor */
        this.library = Blockbuster.proxy.particles;

        this.renderer = new GuiSnowstormRenderer(mc);
        this.renderer.flex().relative(this).wh(1F, 1F);

        this.editor = new GuiScrollElement(mc);
        this.editor.flex().relative(this).x(1F).w(200).h(1F).anchorX(1F).column(20).vertical().stretch().scroll().padding(10);

        this.open = new GuiIconElement(mc, Icons.MORE, (b) -> this.modal.toggleVisible());
        this.open.tooltip(IKey.lang("blockbuster.gui.snowstorm.open_tooltip"));
        this.open.flex().relative(this);
        this.save = new GuiIconElement(mc, Icons.SAVE, (b) -> this.save());
        this.save.tooltip(IKey.lang("blockbuster.gui.snowstorm.save_tooltip"));
        this.save.flex().relative(this.open).x(20);

        /* Modal */
        this.modal = new GuiElement(mc);
        this.modal.flex().relative(this).y(20).w(160).hTo(this.area, 1F, -16);

        GuiLabel label = Elements.label(IKey.lang("blockbuster.gui.snowstorm.title"), 20)
            .anchor(0, 0.5F);
        label.flex().relative(this.modal).xy(10, 10).w(1F, -20);

        this.add = new GuiIconElement(mc, Icons.ADD, (b) -> this.addEffect());
        this.add.tooltip(IKey.lang("blockbuster.gui.snowstorm.add_tooltip"));
        this.dupe = new GuiIconElement(mc, Icons.DUPE, (b) -> this.dupeEffect());
        this.dupe.tooltip(IKey.lang("blockbuster.gui.snowstorm.dupe_tooltip"));
        this.remove = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.removeEffect());
        this.folder = new GuiIconElement(mc, Icons.FOLDER, (b) -> GuiUtils.openFolder(this.library.folder.getAbsolutePath()));
        this.folder.tooltip(IKey.lang("blockbuster.gui.snowstorm.folder_tooltip"));

        this.particles = new GuiStringSearchListElement(mc, (list) -> this.setScheme(list.get(0)));
        this.particles.flex().relative(this.modal).xy(10, 35).w(1F, -20).h(1F, -45);

        this.particleMorphSection = new GuiSnowstormParticleMorphSection(mc, this);

        GuiElement icons = new GuiElement(mc);
        icons.flex().relative(this.modal).x(1F, -10).y(10).h(20).anchorX(1F).row(0).resize().width(20).height(20);
        icons.add(this.add, this.dupe, this.remove, this.folder);

        this.modal.add(label, icons, this.particles);
        this.modal.setVisible(false);
        this.add(this.renderer, new GuiDrawable(this::drawOverlay), this.editor, this.modal, this.open, this.save);

        this.addSection(new GuiSnowstormGeneralSection(mc, this));
        //this.addSection(this.particleMorphSection);
        this.addSection(new GuiSnowstormSpaceSection(mc, this));
        this.addSection(new GuiSnowstormInitializationSection(mc, this));
        this.addSection(new GuiSnowstormRateSection(mc, this));
        this.addSection(new GuiSnowstormLifetimeSection(mc, this));
        this.addSection(new GuiSnowstormShapeSection(mc, this));
        this.addSection(new GuiSnowstormMotionSection(mc, this));
        this.addSection(new GuiSnowstormExpirationSection(mc, this));
        this.addSection(new GuiSnowstormAppearanceSection(mc, this));
        this.addSection(new GuiSnowstormLightingSection(mc, this));
        this.addSection(new GuiSnowstormCollisionSection(mc, this));
        this.addSection(new GuiSnowstormCollisionAppearanceSection(mc, this));
        this.addSection(new GuiSnowstormCollisionLightingSection(mc, this));
        
        this.keys()
            .register(IKey.lang("blockbuster.gui.snowstorm.keys.save"), Keyboard.KEY_S, () -> this.save.clickItself(GuiBase.getCurrent()))
            .held(Keyboard.KEY_LCONTROL).category(IKey.lang("blockbuster.gui.snowstorm.keys.category"));
    }

    private void addEffect()
    {
        GuiModal.addFullModal(this.modal, () -> new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.snowstorm.add_modal"), (name) ->
        {
            if (this.library.hasEffect(name) || name.isEmpty())
            {
                return;
            }

            BedrockScheme scheme = this.library.load(DEFAULT_PARTICLE);

            scheme.identifier = name;
            this.setScheme(name, scheme);
            this.dirty();

            this.particles.list.setCurrent("");
        }));
    }

    private void dupeEffect()
    {
        GuiModal.addFullModal(this.modal, () -> new GuiPromptModal(this.mc, IKey.lang("blockbuster.gui.snowstorm.dupe_modal"), (name) ->
        {
            if (this.library.hasEffect(name) || name.isEmpty())
            {
                return;
            }

            if (!this.scheme.isFactory())
            {
                this.particles.list.setCurrent("");
            }

            BedrockScheme scheme = BedrockScheme.dupe(this.scheme);

            scheme.factory(this.library.factory.containsKey(name));
            scheme.identifier = name;
            this.setScheme(name, scheme);
            this.save();
        }).setValue(this.filename));
    }

    private void removeEffect()
    {
        if (this.scheme.isFactory())
        {
            return;
        }

        GuiModal.addFullModal(this.modal, () -> new GuiConfirmModal(this.mc, IKey.lang("blockbuster.gui.snowstorm.remove_modal"), (confirm) ->
        {
            if (!confirm || !this.library.hasEffect(this.filename))
            {
                return;
            }

            int index = this.particles.list.getIndex();

            if (this.library.file(this.filename).delete())
            {
                if (!this.library.factory.containsKey(this.filename))
                {
                    this.particles.list.remove(this.filename);
                }

                index = MathUtils.clamp(index, 0, this.particles.list.getList().size() - 1);

                this.particles.list.setIndex(index);
                this.setScheme(this.particles.list.getCurrentFirst());
            }
        }));
    }

    public void dirty()
    {
        this.dirty = true;
        this.updateSaveButton();

        this.renderer.emitter.setupVariables();
    }

    private void updateSaveButton()
    {
        this.save.both(this.dirty ? Icons.SAVE : Icons.SAVED);
    }

    private void updateRemoveButton()
    {
        this.remove.setEnabled(!this.scheme.isFactory());

        if (this.remove.isEnabled())
        {
            this.remove.tooltip(IKey.lang("blockbuster.gui.snowstorm.remove_tooltip"));
        }
        else
        {
            this.remove.tooltip(IKey.lang("blockbuster.gui.snowstorm.remove_factory_tooltip"));
        }
    }

    private void save()
    {
        for (GuiSnowstormSection section : this.sections)
        {
            section.beforeSave(this.scheme);
        }

        this.library.save(this.filename, this.scheme);

        if (!this.particles.list.getList().contains(this.filename))
        {
            this.particles.list.add(this.filename);
            this.particles.list.sort();
            this.particles.list.setCurrent(this.filename);
        }

        this.dirty = false;
        this.scheme.factory(false);
        this.updateSaveButton();
        this.updateRemoveButton();
    }

    private void addSection(GuiSnowstormSection section)
    {
        this.sections.add(section);
        this.editor.add(section);
    }

    private void setScheme(String scheme)
    {
        this.setScheme(scheme, this.library.load(scheme));
    }

    private void setScheme(String name, BedrockScheme scheme)
    {
        if (scheme == null)
        {
            this.particles.list.remove(name);
            this.particles.list.setIndex(-1);

            return;
        }

        this.filename = name;
        this.scheme = scheme;
        this.renderer.setScheme(this.scheme);

        this.dirty = false;
        this.updateSaveButton();
        this.updateRemoveButton();

        for (GuiSnowstormSection section : this.sections)
        {
            section.setScheme(this.scheme);
        }

        this.editor.resize();
    }

    @Override
    public void appear()
    {
        super.appear();

        String current = this.particles.list.getCurrentFirst();

        this.particles.filter("", true);

        this.particles.list.clear();
        this.particles.list.add(this.library.presets.keySet());
        this.particles.list.sort();

        if (this.scheme == null)
        {
            this.setScheme(DEFAULT_PARTICLE);
            this.particles.list.setCurrent(DEFAULT_PARTICLE);
        }
        else
        {
            this.particles.list.setCurrent(current);
        }

        ClientProxy.panels.picker(this.particleMorphSection::setMorph);
    }

    @Override
    public void close()
    {
        if (this.renderer.emitter != null)
        {
            this.renderer.emitter.particles.clear();
        }
    }

    private void drawOverlay(GuiContext context)
    {
        /* Draw debug info */
        BedrockEmitter emitter = this.renderer.emitter;
        String label = emitter.particles.size() + "P - " + emitter.age + "A";

        this.font.drawStringWithShadow(label, this.area.x + 4, this.area.ey() - 12, 0xffffff);

        if (this.modal.isVisible())
        {
            this.open.area.draw(ColorUtils.HALF_BLACK);
            this.modal.area.draw(ColorUtils.HALF_BLACK);
        }
    }
}

==================================================

--- Файл №130 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\GuiSnowstormRenderer.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm;

import mchorse.blockbuster.api.formats.obj.Vector3f;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentKillPlane;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.client.Draw;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import org.lwjgl.opengl.GL11;

public class GuiSnowstormRenderer extends GuiModelRenderer
{
    public BedrockEmitter emitter;

    public boolean playing = true;

    private Vector3f vector = new Vector3f(0, 0, 0);

    public GuiSnowstormRenderer(Minecraft mc)
    {
        super(mc);

        this.emitter = new BedrockEmitter();
    }

    public void setScheme(BedrockScheme scheme)
    {
        this.emitter = new BedrockEmitter();
        this.emitter.setScheme(scheme);
        this.playing = true;
    }

    @Override
    protected void update()
    {
        super.update();

        if (this.playing && this.emitter != null)
        {
            this.emitter.rotation.setIdentity();
            this.emitter.update();
        }
    }

    @Override
    protected void drawUserModel(GuiContext context)
    {
        if (this.emitter == null || this.emitter.scheme == null)
        {
            return;
        }

        this.emitter.cYaw = this.yaw;
        this.emitter.cPitch = this.pitch;
        this.emitter.cX = this.temp.x;
        this.emitter.cY = this.temp.y;
        this.emitter.cZ = this.temp.z;
        this.emitter.perspective = 100;
        this.emitter.rotation.setIdentity();

        GlStateManager.disableLighting();

        GlStateManager.disableDepth();
        GlStateManager.glLineWidth(3);
        GlStateManager.disableTexture2D();
        Draw.axis(1F);
        GlStateManager.enableTexture2D();
        GlStateManager.glLineWidth(1);
        GlStateManager.enableDepth();

        this.emitter.render(this.playing ? context.partialTicks : 1);

        BedrockComponentKillPlane plane = this.emitter.scheme.get(BedrockComponentKillPlane.class);

        if (plane.a != 0 || plane.b != 0 || plane.c != 0)
        {
            this.drawKillPlane(plane.a, plane.b, plane.c, plane.d);
        }

        GlStateManager.enableLighting();
    }

    private void drawKillPlane(float a, float b, float c, float d)
    {
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        // GL11.glLineWidth(2F);
        GL11.glPointSize(4F);
        GlStateManager.disableTexture2D();
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();

        GlStateManager.color(1F, 1F, 1F);
        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

        this.calculate(0, 0, a, b, c, d);
        buffer.pos(this.vector.x, this.vector.y, this.vector.z).color(0, 1, 0, 0.5F).endVertex();
        this.calculate(1, 0, a, b, c, d);
        buffer.pos(this.vector.x, this.vector.y, this.vector.z).color(0, 1, 0, 0.5F).endVertex();
        this.calculate(1, 1, a, b, c, d);
        buffer.pos(this.vector.x, this.vector.y, this.vector.z).color(0, 1, 0, 0.5F).endVertex();
        this.calculate(0, 1, a, b, c, d);
        buffer.pos(this.vector.x, this.vector.y, this.vector.z).color(0, 1, 0, 0.5F).endVertex();

        tessellator.draw();

        GlStateManager.enableTexture2D();
    }

    private void calculate(float i, float j, float a, float b, float c, float d)
    {
        final float radius = 5;

        if (b != 0)
        {
            this.vector.x = -radius + radius * 2 * i;
            this.vector.z = -radius + radius * 2 * j;
            this.vector.y = (a * this.vector.x + c * this.vector.z + d) / -b;
        }
        else if (a != 0)
        {
            this.vector.y = -radius + radius * 2 * i;
            this.vector.z = -radius + radius * 2 * j;
            this.vector.x = (b * this.vector.y + c * this.vector.z + d) / -a;
        }
        else if (c != 0)
        {
            this.vector.x = -radius + radius * 2 * i;
            this.vector.y = -radius + radius * 2 * j;
            this.vector.z = (b * this.vector.y + a * this.vector.x + d) / -c;
        }
    }
}

==================================================

--- Файл №131 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormAppearanceSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSectionManager;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceBillboard;
import mchorse.blockbuster.client.particles.components.appearance.CameraFacing;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import org.apache.commons.lang3.ArrayUtils;

public class GuiSnowstormAppearanceSection extends GuiSnowstormComponentSection<BedrockComponentAppearanceBillboard>
{
    public static final CameraFacing[] SORTED_FACING_MODES = {CameraFacing.DIRECTION_X, CameraFacing.DIRECTION_Y, CameraFacing.DIRECTION_Z, CameraFacing.LOOKAT_XYZ, CameraFacing.LOOKAT_Y, CameraFacing.LOOKAT_DIRECTION, CameraFacing.ROTATE_XYZ, CameraFacing.ROTATE_Y, CameraFacing.EMITTER_XY, CameraFacing.EMITTER_XZ, CameraFacing.EMITTER_YZ};

    public GuiCirculateElement mode;
    public GuiLabel modeLabel;
    
    public GuiCirculateElement facingMode;
    public GuiLabel facingModeLabel;
    public GuiTextElement sizeW;
    public GuiTextElement sizeH;
    public GuiTextElement uvX;
    public GuiTextElement uvY;
    public GuiTextElement uvW;
    public GuiTextElement uvH;
    public GuiElement modeRow;
    public GuiElement directionContainer;
    public GuiCirculateElement directionMode;
    public GuiTrackpadElement speedThreshold;
    public GuiTextElement directionX;
    public GuiTextElement directionY;
    public GuiTextElement directionZ;

    public GuiElement flipbook;
    public GuiTrackpadElement stepX;
    public GuiTrackpadElement stepY;
    public GuiTrackpadElement fps;
    public GuiTextElement max;
    public GuiToggleElement stretch;
    public GuiToggleElement loop;
    
    public GuiSnowstormAppearanceSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.mode = new GuiCirculateElement(mc, (b) ->
        {
            this.component.flipbook = this.mode.getValue() == 1;
            this.updateElements();
            this.parent.dirty();
        });
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.regular"));
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.animated"));
        this.modeLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.mode"), 20).anchor(0, 0.5F);
        
        this.facingMode = new GuiCirculateElement(mc, (b) ->
        {
            this.component.facing = SORTED_FACING_MODES[this.facingMode.getValue()];
            this.updateElements();
            this.parent.dirty();
        });
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_x"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_y"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_z"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_xyz"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_y"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_direction"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.rotate_xyz"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.rotate_y"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.emitter_xy"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.emitter_xz"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.emitter_yz"));
        this.facingModeLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.label"), 20).anchor(0, 0.5F);

        this.directionContainer = new GuiElement(mc);
        this.directionContainer.flex().column(5).vertical().stretch();
        this.directionMode = new GuiCirculateElement(mc, (b) -> {
            this.component.customDirection = b.getValue() == 1;
            this.updateElements();
            this.parent.dirty();
        });
        this.directionMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_mode.motion"));
        this.directionMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_mode.custom"));

        this.directionX = new GuiTextElement(mc, 10000, (str) -> {
            this.component.directionX = this.parse(str, this.directionX, this.component.directionX);
        });
        this.directionX.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_mode.direction_x_tooltip"));

        this.directionY = new GuiTextElement(mc, 10000, (str) -> {
            this.component.directionY = this.parse(str, this.directionY, this.component.directionY);
        });
        this.directionX.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_mode.direction_y_tooltip"));

        this.directionZ = new GuiTextElement(mc, 10000, (str) -> {
            this.component.directionZ = this.parse(str, this.directionZ, this.component.directionZ);
        });
        this.directionX.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_mode.direction_z_tooltip"));
        this.speedThreshold = new GuiTrackpadElement(mc, (value) -> {
            this.component.directionSpeedThreshhold = value.floatValue();
            this.parent.dirty();
        });
        this.speedThreshold.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_mode.speed_threshold_tooltip"));

        this.directionContainer.add(this.directionMode, this.speedThreshold);
        
        this.sizeW = new GuiTextElement(mc, 10000, (str) -> this.component.sizeW = this.parse(str, this.sizeW, this.component.sizeW));
        this.sizeW.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.width"));
        this.sizeH = new GuiTextElement(mc, 10000, (str) -> this.component.sizeH = this.parse(str, this.sizeH, this.component.sizeH));
        this.sizeH.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.height"));

        this.uvX = new GuiTextElement(mc, 10000, (str) -> this.component.uvX = this.parse(str, this.uvX, this.component.uvX));
        this.uvX.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.uv_x"));
        this.uvY = new GuiTextElement(mc, 10000, (str) -> this.component.uvY = this.parse(str, this.uvY, this.component.uvY));
        this.uvY.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.uv_y"));
        this.uvW = new GuiTextElement(mc, 10000, (str) -> this.component.uvW = this.parse(str, this.uvW, this.component.uvW));
        this.uvW.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.uv_w"));
        this.uvH = new GuiTextElement(mc, 10000, (str) -> this.component.uvH = this.parse(str, this.uvH, this.component.uvH));
        this.uvH.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.uv_h"));

        this.stepX = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.stepX = value.floatValue();
            this.parent.dirty();
        });
        this.stepX.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.step_x"));
        this.stepY = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.stepY = value.floatValue();
            this.parent.dirty();
        });
        this.stepY.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.step_y"));
        this.fps = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.fps = value.floatValue();
            this.parent.dirty();
        });
        this.fps.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.fps"));
        this.max = new GuiTextElement(mc, 10000, (str) -> this.component.maxFrame = this.parse(str, this.max, this.component.maxFrame));
        this.max.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.max"));

        this.stretch = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.appearance.stretch"), (b) ->
        {
            this.component.stretchFPS = b.isToggled();
            this.parent.dirty();
        });
        this.stretch.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.stretch_tooltip"));
        this.loop = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.appearance.loop"), (b) ->
        {
            this.component.loop = b.isToggled();
            this.parent.dirty();
        });
        this.loop.tooltip(IKey.lang("blockbuster.gui.snowstorm.appearance.loop_tooltip"));

        this.modeRow = Elements.row(mc, 5, 0, 20, this.facingModeLabel, this.facingMode);

        this.flipbook = new GuiElement(mc);
        this.flipbook.flex().column(5).vertical().stretch();
        this.flipbook.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.appearance.animated")).marginTop(12));
        this.flipbook.add(Elements.row(mc, 5, 0, 20, this.stepX, this.stepY));
        this.flipbook.add(Elements.row(mc, 5, 0, 20, this.fps, this.max));
        this.flipbook.add(Elements.row(mc, 5, 0, 20, this.stretch, this.loop));

        this.fields.add(Elements.row(mc, 5, 0, 20, this.modeLabel, this.mode));
        this.fields.add(this.modeRow);
        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.appearance.size")).marginTop(12));
        this.fields.add(this.sizeW, this.sizeH);
        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.appearance.mapping")).marginTop(12));
        this.fields.add(this.uvX, this.uvY, this.uvW, this.uvH);
    }
    
    @Override
    protected void collapseState()
    {
        GuiSectionManager.setDefaultState(this.getClass().getSimpleName(), false);
        
        super.collapseState();
    }

    private void updateElements()
    {
        this.directionContainer.removeFromParent();

        if (this.component.facing.isDirection)
        {
            this.fields.addAfter(this.modeRow, this.directionContainer);
            this.speedThreshold.removeFromParent();
            this.directionX.removeFromParent();
            this.directionY.removeFromParent();
            this.directionZ.removeFromParent();

            if (this.component.customDirection)
            {
                this.directionContainer.add(this.directionX, this.directionY, this.directionZ);
            }
            else
            {
                this.directionContainer.add(this.speedThreshold);
            }
        }
        else
        {
            this.directionContainer.removeFromParent();
        }

        this.flipbook.removeFromParent();

        if (this.component.flipbook)
        {
            this.fields.add(this.flipbook);
        }

        this.resizeParent();
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.appearance.title";
    }

    @Override
    protected BedrockComponentAppearanceBillboard getComponent(BedrockScheme scheme)
    {
        return scheme.getOrCreateExact(BedrockComponentAppearanceBillboard.class);
    }

    @Override
    protected void fillData()
    {
        super.fillData();

        this.mode.setValue(this.component.flipbook ? 1 : 0);
        this.facingMode.setValue(ArrayUtils.indexOf(SORTED_FACING_MODES, this.component.facing));
        this.set(this.sizeW, this.component.sizeW);
        this.set(this.sizeH, this.component.sizeH);
        this.set(this.uvX, this.component.uvX);
        this.set(this.uvY, this.component.uvY);
        this.set(this.uvW, this.component.uvW);
        this.set(this.uvH, this.component.uvH);
        this.set(this.directionX, this.component.directionX);
        this.set(this.directionY, this.component.directionY);
        this.set(this.directionZ, this.component.directionZ);
        this.speedThreshold.setValue(this.component.directionSpeedThreshhold);
        this.directionMode.setValue(this.component.customDirection ? 1 : 0);

        this.stepX.setValue(this.component.stepX);
        this.stepY.setValue(this.component.stepY);
        this.fps.setValue(this.component.fps);
        this.set(this.max, this.component.maxFrame);

        this.stretch.toggled(this.component.stretchFPS);
        this.loop.toggled(this.component.loop);

        this.updateElements();
    }
}


==================================================

--- Файл №132 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormCollisionAppearanceSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockMaterial;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionAppearance;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;
import org.apache.commons.lang3.ArrayUtils;
import org.lwjgl.opengl.GL11;

public class GuiSnowstormCollisionAppearanceSection extends GuiSnowstormComponentSection<BedrockComponentCollisionAppearance>
{
    /* inheriting this throughout the structure would make things less copy and paste */
    public static final String GUI_PATH = "blockbuster.gui.snowstorm.appearance";
    
    public GuiToggleElement enabled;
    public GuiButtonElement pick;
    public GuiCirculateElement material;
    public GuiTexturePicker texture;
    
    public GuiCirculateElement mode;
    public GuiLabel modeLabel;

    public GuiCirculateElement facingMode;
    public GuiLabel facingModeLabel;
    public GuiTextElement sizeW;
    public GuiTextElement sizeH;
    public GuiTextElement uvX;
    public GuiTextElement uvY;
    public GuiTextElement uvW;
    public GuiTextElement uvH;

    public GuiElement flipbook;
    public GuiTrackpadElement stepX;
    public GuiTrackpadElement stepY;
    public GuiTrackpadElement fps;
    public GuiTextElement max;
    public GuiToggleElement stretch;
    public GuiToggleElement loop;
    
    public GuiSnowstormCollisionAppearanceSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.enabled = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.enabled"), (b) -> this.parent.dirty());
        
        this.pick = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.snowstorm.general.pick"), (b) ->
        {
            GuiElement container = this.getParentContainer();

            this.texture.fill(this.component.texture);
            this.texture.flex().relative(container).wh(1F, 1F);
            this.texture.resize();
            container.add(this.texture);
        });

        this.material = new GuiCirculateElement(mc, (b) ->
        {
            this.component.material = BedrockMaterial.values()[this.material.getValue()];
            this.parent.dirty();
        });
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_opaque"));
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_alpha"));
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_blend"));
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_additive"));

        this.texture = new GuiTexturePicker(mc, (rl) ->
        {
            if (rl == null)
            {
                rl = BedrockScheme.DEFAULT_TEXTURE;
            }

            this.setTextureSize(rl);
            this.component.texture = rl;
            this.parent.dirty();
        });

        
        this.mode = new GuiCirculateElement(mc, (b) ->
        {
            this.component.flipbook = this.mode.getValue() == 1;
            this.updateElements();
            this.parent.dirty();
        });
        this.mode.addLabel(IKey.lang(GUI_PATH +".regular"));
        this.mode.addLabel(IKey.lang(GUI_PATH +".animated"));
        this.modeLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.mode"), 20).anchor(0, 0.5F);

        this.facingMode = new GuiCirculateElement(mc, (b) ->
        {
            this.component.facing = GuiSnowstormAppearanceSection.SORTED_FACING_MODES[this.facingMode.getValue()];
            this.parent.dirty();
        });
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_x"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_y"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.direction_z"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_xyz"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_y"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.rotate_xyz"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.rotate_y"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.emitter_xy"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.emitter_xz"));
        this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.emitter_yz"));
        this.facingModeLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.label"), 20).anchor(0, 0.5F);
        
        this.sizeW = new GuiTextElement(mc, 10000, (str) -> this.component.sizeW = this.parse(str, this.sizeW, this.component.sizeW));
        this.sizeW.tooltip(IKey.lang(GUI_PATH +".width"));
        this.sizeH = new GuiTextElement(mc, 10000, (str) -> this.component.sizeH = this.parse(str, this.sizeH, this.component.sizeH));
        this.sizeH.tooltip(IKey.lang(GUI_PATH +".height"));

        this.uvX = new GuiTextElement(mc, 10000, (str) -> this.component.uvX = this.parse(str, this.uvX, this.component.uvX));
        this.uvX.tooltip(IKey.lang(GUI_PATH +".uv_x"));
        this.uvY = new GuiTextElement(mc, 10000, (str) -> this.component.uvY = this.parse(str, this.uvY, this.component.uvY));
        this.uvY.tooltip(IKey.lang(GUI_PATH +".uv_y"));
        this.uvW = new GuiTextElement(mc, 10000, (str) -> this.component.uvW = this.parse(str, this.uvW, this.component.uvW));
        this.uvW.tooltip(IKey.lang(GUI_PATH +".uv_w"));
        this.uvH = new GuiTextElement(mc, 10000, (str) -> this.component.uvH = this.parse(str, this.uvH, this.component.uvH));
        this.uvH.tooltip(IKey.lang(GUI_PATH +".uv_h"));

        this.stepX = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.stepX = value.floatValue();
            this.parent.dirty();
        });
        this.stepX.tooltip(IKey.lang(GUI_PATH +".step_x"));
        this.stepY = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.stepY = value.floatValue();
            this.parent.dirty();
        });
        this.stepY.tooltip(IKey.lang(GUI_PATH +".step_y"));
        this.fps = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.fps = value.floatValue();
            this.parent.dirty();
        });
        this.fps.tooltip(IKey.lang(GUI_PATH +".fps"));
        this.max = new GuiTextElement(mc, 10000, (str) -> this.component.maxFrame = this.parse(str, this.max, this.component.maxFrame));
        this.max.tooltip(IKey.lang(GUI_PATH +".max"));

        this.stretch = new GuiToggleElement(mc, IKey.lang(GUI_PATH +".stretch"), (b) ->
        {
            this.component.stretchFPS = b.isToggled();
            this.parent.dirty();
        });
        this.stretch.tooltip(IKey.lang(GUI_PATH +".stretch_tooltip"));
        this.loop = new GuiToggleElement(mc, IKey.lang(GUI_PATH +".loop"), (b) ->
        {
            this.component.loop = b.isToggled();
            this.parent.dirty();
        });
        this.loop.tooltip(IKey.lang(GUI_PATH +".loop_tooltip"));

        this.flipbook = new GuiElement(mc);
        this.flipbook.flex().column(5).vertical().stretch();
        this.flipbook.add(Elements.label(IKey.lang(GUI_PATH +".animated")).marginTop(12));
        this.flipbook.add(Elements.row(mc, 5, 0, 20, this.stepX, this.stepY));
        this.flipbook.add(Elements.row(mc, 5, 0, 20, this.fps, this.max));
        this.flipbook.add(Elements.row(mc, 5, 0, 20, this.stretch, this.loop));

        this.fields.add(this.enabled);
        this.fields.add(Elements.row(mc, 5, 0, 20, this.pick, this.material));
        this.fields.add(Elements.row(mc, 5, 0, 20, this.modeLabel, this.mode));
        this.fields.add(Elements.row(mc, 5, 0, 20, this.facingModeLabel, this.facingMode));
        this.fields.add(Elements.label(IKey.lang(GUI_PATH +".size")).marginTop(12));
        this.fields.add(this.sizeW, this.sizeH);
        this.fields.add(Elements.label(IKey.lang(GUI_PATH +".mapping")).marginTop(12));
        this.fields.add(this.uvX, this.uvY, this.uvW, this.uvH);
    }

    private void setTextureSize(ResourceLocation rl)
    {
        BedrockComponentCollisionAppearance component = this.scheme.get(BedrockComponentCollisionAppearance.class);

        if (component == null)
        {
            return;
        }

        this.mc.renderEngine.bindTexture(rl);

        component.textureWidth = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
        component.textureHeight = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.collision.appearance.title";
    }

    @Override
    public void setScheme(BedrockScheme scheme)
    {
        super.setScheme(scheme);

        this.material.setValue(this.component.material.ordinal());
    }
    
    @Override
    public void beforeSave(BedrockScheme scheme)
    {
        this.component.enabled = this.enabled.isToggled() ? MolangParser.ONE : MolangParser.ZERO;
    }

    @Override
    protected BedrockComponentCollisionAppearance getComponent(BedrockScheme scheme) {
        return scheme.getOrCreate(BedrockComponentCollisionAppearance.class);
    }
    
    private void updateElements()
    {
        this.flipbook.removeFromParent();

        if (this.component.flipbook)
        {
            this.fields.add(this.flipbook);
        }

        this.resizeParent();
    }
    
    @Override
    protected void fillData()
    {
        super.fillData();

        this.enabled.toggled(MolangExpression.isOne(component.enabled));
        this.mode.setValue(this.component.flipbook ? 1 : 0);
        this.facingMode.setValue(ArrayUtils.indexOf(GuiSnowstormAppearanceSection.SORTED_FACING_MODES, this.component.facing));
        this.set(this.sizeW, this.component.sizeW);
        this.set(this.sizeH, this.component.sizeH);
        this.set(this.uvX, this.component.uvX);
        this.set(this.uvY, this.component.uvY);
        this.set(this.uvW, this.component.uvW);
        this.set(this.uvH, this.component.uvH);

        this.stepX.setValue(this.component.stepX);
        this.stepY.setValue(this.component.stepY);
        this.fps.setValue(this.component.fps);
        this.set(this.max, this.component.maxFrame);

        this.stretch.toggled(this.component.stretchFPS);
        this.loop.toggled(this.component.loop);

        this.updateElements();
    }
}


==================================================

--- Файл №133 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormCollisionLightingSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionAppearance;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionTinting;
import mchorse.blockbuster.client.particles.components.appearance.Tint;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;
import mchorse.mclib.utils.Color;
import net.minecraft.client.Minecraft;

public class GuiSnowstormCollisionLightingSection extends GuiSnowstormLightingSection
{
    public GuiToggleElement enabled;

    private BedrockComponentCollisionAppearance appearanceComponent;

    public GuiSnowstormCollisionLightingSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.enabled = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.enabled"), (b) -> this.parent.dirty());

        this.lighting.callback = (b) ->
        {
            this.appearanceComponent.lit = !b.isToggled();
            this.parent.dirty();
        };

        this.fields.addBefore(this.lighting, this.enabled);
    }

    private BedrockComponentCollisionTinting getComponent()
    {
        return (BedrockComponentCollisionTinting) this.component;
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.collision.lighting.title";
    }

    @Override
    public void beforeSave(BedrockScheme scheme)
    {
        this.getComponent().enabled = this.enabled.isToggled() ? MolangParser.ONE : MolangParser.ZERO;
    }

    @Override
    public void setScheme(BedrockScheme scheme)
    {
        this.scheme = scheme; //cant call super as it would set the wrong component

        this.component = scheme.getOrCreate(BedrockComponentCollisionTinting.class);
        this.appearanceComponent = scheme.getOrCreate(BedrockComponentCollisionAppearance.class);
        this.lighting.toggled(!this.appearanceComponent.lit);
        this.enabled.toggled(MolangExpression.isOne(this.getComponent().enabled));

        this.setTintsCache();
        this.fillData();
    }
}


==================================================

--- Файл №134 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormCollisionSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotionCollision;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangParser;
import net.minecraft.client.Minecraft;

public class GuiSnowstormCollisionSection extends GuiSnowstormComponentSection<BedrockComponentMotionCollision>
{
    public GuiTextElement condition;
    public GuiToggleElement realisticCollision;
    public GuiToggleElement entityCollision;
    public GuiToggleElement momentum;
    public GuiToggleElement realisticCollisionDrag;
    public GuiTrackpadElement collisionRotationDrag;
    public GuiTrackpadElement drag;
    public GuiTrackpadElement bounciness;
    public GuiTrackpadElement randomBounciness; //randomize the direction vector
    public GuiToggleElement preserveEnergy;
    public GuiTrackpadElement randomDamp;
    public GuiTrackpadElement damp;
    public GuiTrackpadElement splitParticle; //split particle into n particles on collision
    public GuiTrackpadElement splitParticleSpeedThreshold;
    public GuiTrackpadElement radius;
    public GuiToggleElement expire;
    public GuiTextElement expirationDelay;
    
    public GuiElement controlToggleElements;
    public GuiElement randomBouncinessRow;

    private boolean wasPresent;
    private boolean updateButtons;

    public GuiSnowstormCollisionSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.condition = new GuiTextElement(mc, 10000, (str) ->
        {
            this.component.enabled = str.isEmpty() ? MolangParser.ONE : this.parse(str, this.condition, this.component.enabled);
            this.parent.dirty();
        });
        this.condition.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.condition_tooltip"));
        
        this.realisticCollision = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.realistic_collision"), (b) ->
        {
            this.component.realisticCollision = b.isToggled();
            this.parent.dirty();
        });
        
        this.entityCollision = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.entity_collision"), (b) ->
        {
            this.component.entityCollision = b.isToggled();
            this.parent.dirty();

            this.updateButtons();
        });
        
        this.momentum = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.momentum"), (b) ->
        {
            this.component.momentum = b.isToggled();
            this.parent.dirty();
        });

        this.realisticCollisionDrag = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.realistic_collision_drag"), (b) ->
        {
            this.component.realisticCollisionDrag = b.isToggled();
            this.parent.dirty();
        });
        this.realisticCollisionDrag.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.realistic_collision_drag_tooltip"));
        
        this.drag = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.collisionDrag = value.floatValue();
            this.parent.dirty();
        });
        this.drag.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.drag"));

        this.collisionRotationDrag = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.rotationCollisionDrag = value.floatValue();
            this.parent.dirty();
        });
        this.collisionRotationDrag.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.rotation_drag"));
        
        this.bounciness = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.bounciness = value.floatValue();
            this.parent.dirty();

            this.updateButtons = true;
        });
        this.bounciness.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.bounciness"));
        
        this.randomBounciness = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.randomBounciness = (float) Math.abs(value);
            this.parent.dirty();

            this.updateButtons = true;
        });
        this.randomBounciness.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.random_direction"));
        
        this.preserveEnergy = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.collision.preserve_energy"), (b) -> this.parent.dirty());
        this.preserveEnergy.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.preserve_energy_tooltip"));
        
        this.damp = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.damp = value.floatValue();
            this.parent.dirty();
        });
        this.damp.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.damping.strength"));
        this.damp.limit(0, 1);
        
        this.randomDamp = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.randomDamp = (float) Math.abs(value);
            this.parent.dirty();
        });
        this.randomDamp.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.damping.randomness"));
        this.randomDamp.limit(0, 1);
        
        this.splitParticleSpeedThreshold = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.splitParticleSpeedThreshold = value.floatValue();
            this.parent.dirty();
        });
        this.splitParticleSpeedThreshold.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.split_particle.speed_threshold"));
        
        this.splitParticle = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.splitParticleCount = (int)Math.abs(value);
            this.parent.dirty();
        });
        this.splitParticle.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.split_particle.count"));
        this.splitParticle.limit(0, 99).integer();
        
        this.radius = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.radius = value.floatValue();
            this.parent.dirty();
        });
        this.radius.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.radius"));
        
        this.expire = new GuiToggleElement(mc,  IKey.lang("blockbuster.gui.snowstorm.collision.expire"), (b) ->
        {
            this.component.expireOnImpact = b.isToggled();
            this.parent.dirty();
        });
        
        this.expirationDelay = new GuiTextElement(mc, 10000, (value) ->
        {
            this.component.expirationDelay = this.parse(value, this.expirationDelay, this.component.expirationDelay);
            this.parent.dirty();
        });
        this.expirationDelay.tooltip(IKey.lang("blockbuster.gui.snowstorm.collision.expiration_delay"));
        
        this.controlToggleElements = new GuiElement(mc);
        this.controlToggleElements.flex().column(4).stretch().vertical().height(4);
        
        this.controlToggleElements.add(this.condition, this.realisticCollision, this.entityCollision);
        
        this.randomBouncinessRow = new GuiElement(mc);
        this.randomBouncinessRow.flex().column(2).stretch().vertical().height(2);

        this.randomBouncinessRow.add(this.randomBounciness);
        
        this.fields.add(this.controlToggleElements, this.realisticCollisionDrag, this.drag, this.collisionRotationDrag, this.bounciness, this.randomBouncinessRow , this.radius, this.expire, this.expirationDelay);
        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.collision.damping.title")).marginTop(12), this.damp, this.randomDamp);
        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.collision.split_particle.title")).marginTop(12), this.splitParticle,  this.splitParticleSpeedThreshold);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.collision.title";
    }

    @Override
    public void beforeSave(BedrockScheme scheme)
    {
        this.component.preserveEnergy = this.preserveEnergy.isToggled();
    }

    @Override
    protected BedrockComponentMotionCollision getComponent(BedrockScheme scheme)
    {
        this.wasPresent = this.scheme.get(BedrockComponentMotionCollision.class) != null;

        return scheme.getOrCreate(BedrockComponentMotionCollision.class);
    }

    @Override
    protected void fillData()
    {
        this.set(this.condition, this.component.enabled);
        this.realisticCollision.toggled(this.component.realisticCollision);
        this.entityCollision.toggled(this.component.entityCollision);
        this.momentum.toggled(this.component.momentum);
        this.realisticCollisionDrag.toggled(this.component.realisticCollisionDrag);
        this.drag.setValue(this.component.collisionDrag);
        this.bounciness.setValue(this.component.bounciness);
        this.randomBounciness.setValue(this.component.randomBounciness);
        this.preserveEnergy.toggled(this.component.preserveEnergy);
        this.damp.setValue(this.component.damp);
        this.randomDamp.setValue(this.component.randomDamp);
        this.splitParticle.setValue(this.component.splitParticleCount);
        this.splitParticleSpeedThreshold.setValue(this.component.splitParticleSpeedThreshold);
        this.radius.setValue(this.component.radius);
        this.expire.toggled(this.component.expireOnImpact);
        this.collisionRotationDrag.setValue(this.component.rotationCollisionDrag);
        this.set(this.expirationDelay, this.component.expirationDelay);
        
        this.updateButtons();
    }

    private void updateButtons()
    {
        this.preserveEnergy.removeFromParent();
        this.momentum.removeFromParent();

        if (this.entityCollision.isToggled())
        {
            this.controlToggleElements.add(this.momentum);
        }

        if (!Operation.equals(this.randomBounciness.value, 0) && Operation.equals(this.bounciness.value, 0))
        {
            this.randomBouncinessRow.add(this.preserveEnergy);
        }

        this.resizeParent();
    }

    @Override
    public void draw(GuiContext context)
    {
        super.draw(context);

        if (this.updateButtons)
        {
            this.updateButtons();
            this.updateButtons = false;
        }
    }
}


==================================================

--- Файл №135 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormComponentSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import net.minecraft.client.Minecraft;

public abstract class GuiSnowstormComponentSection <T extends BedrockComponentBase> extends GuiSnowstormSection
{
    protected T component;

    public GuiSnowstormComponentSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);
    }

    @Override
    public void setScheme(BedrockScheme scheme)
    {
        super.setScheme(scheme);

        this.component = this.getComponent(scheme);
        this.fillData();
    }

    protected abstract T getComponent(BedrockScheme scheme);

    protected void fillData()
    {}
}

==================================================

--- Файл №136 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormExpirationSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentExpireBlocks;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentExpireInBlocks;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentExpireNotInBlocks;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentKillPlane;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentParticleLifetime;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IGuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.framework.tooltips.LabelTooltip;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.block.Block;
import net.minecraft.client.Minecraft;
import net.minecraft.init.Blocks;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemStack;

public class GuiSnowstormExpirationSection extends GuiSnowstormSection
{
    public GuiCirculateElement mode;
    public GuiTextElement expression;

    public GuiTrackpadElement a;
    public GuiTrackpadElement b;
    public GuiTrackpadElement c;
    public GuiTrackpadElement d;

    public GuiBlocksSection inBlocksSection;
    public GuiBlocksSection notInBlocksSection;

    private BedrockComponentParticleLifetime lifetime;
    private BedrockComponentKillPlane plane;
    private BedrockComponentExpireInBlocks inBlocks;
    private BedrockComponentExpireNotInBlocks notInBlocks;

    public GuiSnowstormExpirationSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.mode = new GuiCirculateElement(mc, (b) ->
        {
            this.lifetime.max = this.mode.getValue() == 1;
            this.updateTooltip();
            this.parent.dirty();
        });
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.expiration.expression"));
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.expiration.max"));

        this.expression = new GuiTextElement(mc, 10000, (str) -> this.lifetime.expression = this.parse(str, this.expression, this.lifetime.expression));
        this.expression.tooltip(IKey.lang(""));

        this.a = new GuiTrackpadElement(mc, (value) ->
        {
            this.plane.a = value.floatValue();
            this.parent.dirty();
        });
        this.a.tooltip(IKey.str("Ax"));
        this.b = new GuiTrackpadElement(mc, (value) ->
        {
            this.plane.b = value.floatValue();
            this.parent.dirty();
        });
        this.b.tooltip(IKey.str("By"));
        this.c = new GuiTrackpadElement(mc, (value) ->
        {
            this.plane.c = value.floatValue();
            this.parent.dirty();
        });
        this.c.tooltip(IKey.str("Cz"));
        this.d = new GuiTrackpadElement(mc, (value) ->
        {
            this.plane.d = value.floatValue();
            this.parent.dirty();
        });
        this.d.tooltip(IKey.str("D"));

        this.inBlocksSection = new GuiBlocksSection(mc, IKey.lang("blockbuster.gui.snowstorm.expiration.in_blocks"), this);
        this.notInBlocksSection = new GuiBlocksSection(mc, IKey.lang("blockbuster.gui.snowstorm.expiration.not_in_blocks"), this);

        this.fields.add(Elements.row(mc, 5, 0, 20, Elements.label(IKey.lang("blockbuster.gui.snowstorm.mode"), 20).anchor(0, 0.5F), this.mode));
        this.fields.add(this.expression);
        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.expiration.kill_plane")).marginTop(12)
            .tooltip(IKey.lang("blockbuster.gui.snowstorm.expiration.kill_plane_tooltip")));
        this.fields.add(Elements.row(mc, 5, 0, 20, this.a, this.b));
        this.fields.add(Elements.row(mc, 5, 0, 20, this.c, this.d));
        this.fields.add(this.inBlocksSection, this.notInBlocksSection);
    }

    private void updateTooltip()
    {
        ((LabelTooltip) this.expression.tooltip).label.set(this.lifetime.max ? "blockbuster.gui.snowstorm.expiration.max_tooltip" : "blockbuster.gui.snowstorm.expiration.expression_tooltip");
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.expiration.title";
    }

    @Override
    public void setScheme(BedrockScheme scheme)
    {
        super.setScheme(scheme);

        this.lifetime = scheme.getOrCreate(BedrockComponentParticleLifetime.class);
        this.plane = scheme.getOrCreate(BedrockComponentKillPlane.class);
        this.inBlocks = scheme.getOrCreate(BedrockComponentExpireInBlocks.class);
        this.notInBlocks = scheme.getOrCreate(BedrockComponentExpireNotInBlocks.class);

        this.mode.setValue(this.lifetime.max ? 1 : 0);
        this.set(this.expression, this.lifetime.expression);
        this.updateTooltip();

        this.a.setValue(this.plane.a);
        this.b.setValue(this.plane.b);
        this.c.setValue(this.plane.c);
        this.d.setValue(this.plane.d);

        this.inBlocksSection.setComponent(this.inBlocks);
        this.notInBlocksSection.setComponent(this.notInBlocks);
    }

    @Override
    public void beforeSave(BedrockScheme scheme)
    {
        this.compileBlocks(this.inBlocks, this.inBlocksSection);
        this.compileBlocks(this.notInBlocks, this.notInBlocksSection);
    }

    private void compileBlocks(BedrockComponentExpireBlocks component, GuiBlocksSection section)
    {
        component.blocks.clear();

        for (IGuiElement child : section.blocks.getChildren())
        {
            if (child instanceof GuiSlotElement)
            {
                GuiSlotElement slot = (GuiSlotElement) child;

                if (slot.getStack().getItem() instanceof ItemBlock)
                {
                    component.blocks.add(((ItemBlock) slot.getStack().getItem()).getBlock());
                }
                else if (slot.getStack().isEmpty())
                {
                    component.blocks.add(Blocks.AIR);
                }
            }
        }
    }

    /**
     * Blocks module
     */
    public static class GuiBlocksSection extends GuiElement
    {
        public GuiElement blocks;

        private GuiSnowstormExpirationSection parent;
        private BedrockComponentExpireBlocks component;

        public GuiBlocksSection(Minecraft mc, IKey title, GuiSnowstormExpirationSection parent)
        {
            super(mc);

            this.parent = parent;

            GuiIconElement add = new GuiIconElement(mc, Icons.ADD, (b) ->
            {
                this.addBlock(Blocks.AIR);
                this.parent.resizeParent();
            });
            GuiLabel label = Elements.label(title).anchor(0, 0.5F);
            GuiElement row = Elements.row(mc, 5, 0, 20, label, add);
            this.blocks = new GuiElement(mc);

            add.flex().wh(10, 16);
            label.flex().h(0);
            row.flex().row(5).preferred(0);
            this.blocks.flex().grid(7).items(6).resizes(true);

            this.flex().column(5).vertical().stretch();
            this.add(row, this.blocks);
        }

        public void setComponent(BedrockComponentExpireBlocks component)
        {
            this.component = component;

            this.blocks.removeAll();

            for (Block block : this.component.blocks)
            {
                this.addBlock(block);
            }
        }

        public void addBlock(Block block)
        {
            GuiSlotElement slotElement = new GuiSlotElement(this.mc, 0, null);

            slotElement.callback = (stack) ->
            {
                if (!(stack.getItem() instanceof ItemBlock))
                {
                    slotElement.setStack(ItemStack.EMPTY);
                }
            };
            slotElement.setStack(new ItemStack(block, 1));
            slotElement.context(() -> new GuiSimpleContextMenu(this.mc).action(Icons.REMOVE, IKey.lang("Remove block"), () ->
            {
                slotElement.removeFromParent();
                this.parent.resizeParent();
            }));

            this.blocks.add(slotElement);
        }
    }
}

==================================================

--- Файл №137 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormGeneralSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSectionManager;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockMaterial;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceBillboard;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.opengl.GL11;

public class GuiSnowstormGeneralSection extends GuiSnowstormSection
{
    public GuiTextElement identifier;
    public GuiButtonElement pick;
    public GuiCirculateElement material;
    public GuiCirculateElement play;
    public GuiTexturePicker texture;

    public GuiSnowstormGeneralSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.identifier = new GuiTextElement(mc, 100, (str) ->
        {
            this.scheme.identifier = str;
            this.parent.dirty();
        });
        this.identifier.tooltip(IKey.lang("blockbuster.gui.snowstorm.general.identifier"));

        this.pick = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.snowstorm.general.pick"), (b) ->
        {
            GuiElement container = this.getParentContainer();

            this.texture.fill(this.scheme.texture);
            this.texture.flex().relative(container).wh(1F, 1F);
            this.texture.resize();
            container.add(this.texture);
        });

        this.material = new GuiCirculateElement(mc, (b) ->
        {
            this.scheme.material = BedrockMaterial.values()[this.material.getValue()];
            this.parent.dirty();
        });
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_opaque"));
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_alpha"));
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_blend"));
        this.material.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.particles_additive"));

        this.texture = new GuiTexturePicker(mc, (rl) ->
        {
            if (rl == null)
            {
                rl = BedrockScheme.DEFAULT_TEXTURE;
            }

            this.setTextureSize(rl);
            this.scheme.texture = rl;
            this.parent.dirty();
        });

        this.play = new GuiCirculateElement(mc, (b) ->
        {
            this.parent.renderer.playing = this.play.getValue() == 0;
        });
        this.play.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.play_playing"));
        this.play.addLabel(IKey.lang("blockbuster.gui.snowstorm.general.play_paused"));

        this.fields.add(this.identifier, Elements.row(mc, 5, 0, 20, this.pick, this.material), this.play);
    }
    
    @Override
    protected void collapseState()
    {
        GuiSectionManager.setDefaultState(this.getClass().getSimpleName(), false);
        
        super.collapseState();
    }

    private void setTextureSize(ResourceLocation rl)
    {
        BedrockComponentAppearanceBillboard component = this.scheme.get(BedrockComponentAppearanceBillboard.class);

        if (component == null)
        {
            return;
        }

        this.mc.renderEngine.bindTexture(rl);

        component.textureWidth = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
        component.textureHeight = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.general.title";
    }

    @Override
    public void setScheme(BedrockScheme scheme)
    {
        super.setScheme(scheme);

        this.identifier.setText(scheme.identifier);
        this.material.setValue(scheme.material.ordinal());
        this.play.setValue(0);
    }
}


==================================================

--- Файл №138 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormInitializationSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.meta.BedrockComponentInitialization;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiSnowstormInitializationSection extends GuiSnowstormComponentSection<BedrockComponentInitialization>
{
    public GuiTextElement create;
    public GuiTextElement update;
    public GuiTextElement updateParticle;

    public GuiSnowstormInitializationSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.create = new GuiTextElement(mc, 10000, (str) -> this.component.creation = this.parse(str, this.create, this.component.creation));
        this.create.tooltip(IKey.lang("blockbuster.gui.snowstorm.initialization.create"));

        this.update = new GuiTextElement(mc, 10000, (str) -> this.component.update = this.parse(str, this.update, this.component.update));
        this.update.tooltip(IKey.lang("blockbuster.gui.snowstorm.initialization.update"));

        this.updateParticle = new GuiTextElement(mc, 10000, (str) -> this.component.particleUpdate = this.parse(str, this.updateParticle, this.component.particleUpdate));
        this.updateParticle.tooltip(IKey.lang("blockbuster.gui.snowstorm.initialization.particle_update_expression"));

        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.initialization.emitter_expression_title")).marginTop(12), this.create, this.update);
        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.initialization.particle_expression_title")).marginTop(12), this.updateParticle);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.initialization.title";
    }

    @Override
    protected BedrockComponentInitialization getComponent(BedrockScheme scheme)
    {
        return this.scheme.getOrCreate(BedrockComponentInitialization.class);
    }

    @Override
    protected void fillData()
    {
        this.set(this.create, this.component.creation);
        this.set(this.update, this.component.update);
        this.set(this.updateParticle, this.component.particleUpdate);
    }
}

==================================================

--- Файл №139 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormLifetimeSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetime;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetimeExpression;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetimeLooping;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetimeOnce;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.tooltips.LabelTooltip;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiSnowstormLifetimeSection extends GuiSnowstormModeSection<BedrockComponentLifetime>
{
    public GuiTextElement active;
    public GuiTextElement expiration;

    public GuiSnowstormLifetimeSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.active = new GuiTextElement(mc, 10000, (str) -> this.component.activeTime = this.parse(str, this.active, this.component.activeTime));
        this.active.tooltip(IKey.lang(""));
        this.expiration = new GuiTextElement(mc, 10000, (str) ->
        {
            if (this.component instanceof BedrockComponentLifetimeLooping)
            {
                BedrockComponentLifetimeLooping component = (BedrockComponentLifetimeLooping) this.component;

                component.sleepTime = this.parse(str, this.expiration, component.sleepTime);
            }
            else
            {
                BedrockComponentLifetimeExpression component = (BedrockComponentLifetimeExpression) this.component;

                component.expiration = this.parse(str, this.expiration, component.expiration);
            }

            this.parent.dirty();
        });
        this.expiration.tooltip(IKey.lang(""));

        this.fields.add(this.active);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.lifetime.title";
    }

    @Override
    protected void fillModes(GuiCirculateElement button)
    {
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.lifetime.expression"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.lifetime.looping"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.lifetime.once"));
    }

    @Override
    protected void restoreInfo(BedrockComponentLifetime component, BedrockComponentLifetime old)
    {
        component.activeTime = old.activeTime;
    }

    @Override
    protected Class<BedrockComponentLifetime> getBaseClass()
    {
        return BedrockComponentLifetime.class;
    }

    @Override
    protected Class getDefaultClass()
    {
        return BedrockComponentLifetimeLooping.class;
    }

    @Override
    protected Class getModeClass(int value)
    {
        if (value == 0)
        {
            return BedrockComponentLifetimeExpression.class;
        }
        else if (value == 1)
        {
            return BedrockComponentLifetimeLooping.class;
        }

        return BedrockComponentLifetimeOnce.class;
    }

    @Override
    protected void fillData()
    {
        super.fillData();

        boolean once = this.component instanceof BedrockComponentLifetimeOnce;

        this.expiration.setVisible(!once);

        if (this.component instanceof BedrockComponentLifetimeExpression)
        {
            this.set(this.expiration, ((BedrockComponentLifetimeExpression) this.component).expiration);
            ((LabelTooltip) this.expiration.tooltip).label.set("blockbuster.gui.snowstorm.lifetime.expiration_expression");

            ((LabelTooltip) this.active.tooltip).label.set("blockbuster.gui.snowstorm.lifetime.active_expression");
        }
        else if (this.component instanceof BedrockComponentLifetimeLooping)
        {
            this.set(this.expiration, ((BedrockComponentLifetimeLooping) this.component).sleepTime);
            ((LabelTooltip) this.expiration.tooltip).label.set("blockbuster.gui.snowstorm.lifetime.sleep_time");

            ((LabelTooltip) this.active.tooltip).label.set("blockbuster.gui.snowstorm.lifetime.active_looping");
        }
        else
        {
            ((LabelTooltip) this.active.tooltip).label.set("blockbuster.gui.snowstorm.lifetime.active_once");
        }

        this.set(this.active, this.component.activeTime);
        this.expiration.removeFromParent();

        if (!once)
        {
            this.fields.add(this.expiration);
        }

        this.resizeParent();
    }
}

==================================================

--- Файл №140 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormLightingSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.utils.GuiGradientEditor;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceLighting;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceTinting;
import mchorse.blockbuster.client.particles.components.appearance.Tint;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;
import mchorse.mclib.utils.Color;
import net.minecraft.client.Minecraft;

public class GuiSnowstormLightingSection extends GuiSnowstormSection
{
    public GuiCirculateElement mode;
    public GuiColorElement color;
    public GuiTextElement r;
    public GuiTextElement g;
    public GuiTextElement b;
    public GuiTextElement a;
    public GuiTextElement interpolant;
    public GuiTrackpadElement range;
    public GuiToggleElement lighting;
    public GuiGradientEditor gradientEditor;
    public GuiColorElement gradientColor;

    public GuiElement gradientElements;
    public GuiElement first;
    public GuiElement second;

    /** Solid, Expression, Gradient */
    protected final Tint[] tints = new Tint[3];

    protected BedrockComponentAppearanceTinting component;

    public GuiSnowstormLightingSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.mode = new GuiCirculateElement(mc, (b) ->
        {
            this.component.color = this.tints[b.getValue()];

            this.updateElements();
            this.parent.dirty();
        });
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.lighting.solid"));
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.lighting.expression"));
        this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.lighting.gradient"));

        this.color = new GuiColorElement(mc, (color) ->
        {
            Tint.Solid solid = this.getSolid();
            Color original = this.color.picker.color;

            solid.r = this.set(solid.r, original.r);
            solid.g = this.set(solid.g, original.g);
            solid.b = this.set(solid.b, original.b);
            solid.a = this.set(solid.a, original.a);
            this.parent.dirty();
        });
        this.color.picker.editAlpha();

        this.r = new GuiTextElement(mc, 10000, (str) ->
        {
            Tint.Solid solid = this.getSolid();

            solid.r = this.parse(str, this.r, solid.r);
        });
        this.r.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.red"));

        this.g = new GuiTextElement(mc, 10000, (str) ->
        {
            Tint.Solid solid = this.getSolid();

            solid.g = this.parse(str, this.r, solid.g);
        });
        this.g.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.green"));

        this.b = new GuiTextElement(mc, 10000, (str) ->
        {
            Tint.Solid solid = this.getSolid();

            solid.b = this.parse(str, this.r, solid.b);
        });
        this.b.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.blue"));

        this.a = new GuiTextElement(mc, 10000, (str) ->
        {
            Tint.Solid solid = this.getSolid();

            solid.a = this.parse(str, this.r, solid.a);
        });
        this.a.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.alpha"));

        this.lighting = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.lighting.lighting"), (b) -> this.parent.dirty());
        this.lighting.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.lighting_tooltip"));

        GuiLabel label = Elements.label(IKey.lang("blockbuster.gui.snowstorm.mode"), 20).anchor(0, 0.5F);

        this.interpolant = new GuiTextElement(mc, 10000, (str) ->
        {
            Tint.Gradient gradient = this.getGradient();
            gradient.interpolant = this.parse(str, this.interpolant, gradient.interpolant);

            this.parent.dirty();
        });
        this.interpolant.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.interpolant_tooltip"));

        this.range = new GuiTrackpadElement(mc, (value) ->
        {
            double threshold = 0.0000000001;
            Tint.Gradient gradient = this.getGradient();
            gradient.range = (value.floatValue() >= -threshold && value.floatValue() <= threshold) ? 1 : value.floatValue();

            this.parent.dirty();
        });
        this.range.tooltip(IKey.lang("blockbuster.gui.snowstorm.lighting.range_tooltip"));
        this.gradientColor = new GuiColorElement(mc, this::setGradientColor);
        this.gradientColor.picker.editAlpha();
        this.gradientEditor = new GuiGradientEditor(mc, this, this.gradientColor);

        this.gradientElements = new GuiElement(mc);
        this.gradientElements.flex().column(4).stretch().vertical().height(4);

        this.gradientElements.add(this.gradientEditor, this.gradientColor, this.interpolant, this.range);

        this.first = Elements.row(mc, 5, 0, 20, this.r, this.g);
        this.second = Elements.row(mc, 5, 0, 20, this.b, this.a);

        this.fields.add(this.lighting);
        this.fields.add(Elements.row(mc, 5, 0, 20, label, this.mode));
    }

    protected void setGradientColor(int color)
    {
        this.gradientEditor.setColor(color);
    }

    protected MolangExpression set(MolangExpression expression, float value)
    {
        if (expression == MolangParser.ZERO || expression == MolangParser.ONE)
        {
            return new MolangValue(null, new Constant(value));
        }

        if (!(expression instanceof MolangValue))
        {
            expression = new MolangValue(null, new Constant(0));
        }

        if (expression instanceof MolangValue)
        {
            MolangValue v = (MolangValue) expression;

            if (!(v.value instanceof Constant))
            {
                v.value = new Constant(0);
            }

            if (v.value instanceof Constant)
            {
                ((Constant) v.value).set(value);
            }
        }

        return expression;
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.lighting.title";
    }

    protected Tint.Solid getSolid()
    {
        return (Tint.Solid) this.component.color;
    }

    protected Tint.Gradient getGradient()
    {
        return (Tint.Gradient) this.component.color;
    }

    @Override
    public void beforeSave(BedrockScheme scheme)
    {
        if (this.lighting.isToggled())
        {
            scheme.getOrCreate(BedrockComponentAppearanceLighting.class);
        }
        else
        {
            scheme.remove(BedrockComponentAppearanceLighting.class);
        }
    }

    @Override
    public void setScheme(BedrockScheme scheme)
    {
        super.setScheme(scheme);

        this.component = scheme.getOrCreateExact(BedrockComponentAppearanceTinting.class);

        this.lighting.toggled(scheme.get(BedrockComponentAppearanceLighting.class) != null);

        this.setTintsCache();
        this.fillData();
    }

    protected void setTintsCache()
    {
        this.tints[0] = new Tint.Solid();
        this.tints[1] = new Tint.Solid();
        this.tints[2] = new Tint.Gradient();
    }

    protected void fillData()
    {
        if (this.component.color instanceof Tint.Solid)
        {
            Tint.Solid solid = this.getSolid();

            if (solid.isConstant())
            {
                this.tints[0] = solid;

                this.color.picker.color.set((float) solid.r.get(), (float) solid.g.get(), (float) solid.b.get(), (float) solid.a.get());
                this.mode.setValue(0);
            }
            else
            {
                this.tints[1] = solid;

                this.set(this.r, solid.r);
                this.set(this.g, solid.g);
                this.set(this.b, solid.b);
                this.set(this.a, solid.a);
                this.mode.setValue(1);
            }
        }
        else if (this.component.color instanceof Tint.Gradient)
        {
            Tint.Gradient gradient = this.getGradient();
            this.tints[2] = gradient;

            this.set(this.interpolant, gradient.interpolant);
            this.range.setValue(gradient.range);
            this.gradientEditor.setGradient(gradient);
            this.mode.setValue(2);
        }

        this.updateElements();
    }

    public void updateElements()
    {
        this.gradientElements.removeFromParent();
        this.color.removeFromParent();
        this.color.picker.removeFromParent();
        this.first.removeFromParent();
        this.second.removeFromParent();

        if (this.mode.getValue() == 0)
        {
            Tint.Solid solid = this.getSolid();

            this.color.picker.color.set((float) solid.r.get(), (float) solid.g.get(), (float) solid.b.get(), (float) solid.a.get());

            this.fields.add(this.color);
        }
        else if (this.mode.getValue() == 1)
        {
            Tint.Solid solid = this.getSolid();

            this.set(this.r, solid.r);
            this.set(this.g, solid.g);
            this.set(this.b, solid.b);
            this.set(this.a, solid.a);

            this.fields.add(this.first);
            this.fields.add(this.second);
        }
        else if (this.mode.getValue() == 2)
        {
            Tint.Gradient gradient = this.getGradient();

            this.set(this.interpolant, gradient.interpolant);
            this.range.setValue(gradient.range);
            this.gradientEditor.setGradient(gradient);
            this.fields.add(this.gradientElements);
        }

        this.resizeParent();
    }
}

==================================================

--- Файл №141 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormModeSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public abstract class GuiSnowstormModeSection <T extends BedrockComponentBase> extends GuiSnowstormComponentSection<T>
{
    public GuiCirculateElement mode;
    public GuiLabel modeLabel;

    public GuiSnowstormModeSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.mode = new GuiCirculateElement(mc, (b) -> this.updateMode(this.mode.getValue()));
        this.fillModes(this.mode);
        this.modeLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.mode"), 20).anchor(0, 0.5F);

        this.fields.add(Elements.row(mc, 5, 0, 20, this.modeLabel, this.mode));
    }

    @Override
    protected T getComponent(BedrockScheme scheme)
    {
        return scheme.getOrCreate(this.getBaseClass(), this.getDefaultClass());
    }

    @Override
    protected void fillData()
    {
        super.fillData();

        for (int i = 0, c = this.mode.getLabels().size(); i < c; i ++)
        {
            if (this.getModeClass(i) == this.component.getClass())
            {
                this.mode.setValue(i);

                break;
            }
        }
    }

    protected abstract void fillModes(GuiCirculateElement button);

    protected void updateMode(int value)
    {
        T old = this.component;

        this.component = this.scheme.replace(this.getBaseClass(), this.getModeClass(this.mode.getValue()));
        this.restoreInfo(this.component, old);
        this.parent.dirty();

        this.fillData();
    }

    protected void restoreInfo(T component, T old)
    {}

    protected abstract Class<T> getBaseClass();

    protected abstract Class getDefaultClass();

    protected abstract Class getModeClass(int value);
}

==================================================

--- Файл №142 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormMotionSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentInitialSpeed;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentInitialSpin;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotion;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotionDynamic;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotionParametric;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiSnowstormMotionSection extends GuiSnowstormModeSection<BedrockComponentMotion>
{
    public GuiElement position;
    public GuiElement positionElements;
    public GuiTextElement positionSpeed;
    public GuiTextElement positionX;
    public GuiTextElement positionY;
    public GuiTextElement positionZ;
    public GuiTextElement positionDrag;
    public GuiElement positionDragRow;
    public GuiElement positionTitle = Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_title")).marginTop(12);

    public GuiElement rotation;
    public GuiTextElement rotationAngle;
    public GuiTextElement rotationRate;
    public GuiTextElement rotationAcceleration;
    public GuiElement rotationDragRow;
    public GuiTextElement rotationDrag;

    private BedrockComponentInitialSpeed speed;
    private BedrockComponentInitialSpin spin;

    public GuiSnowstormMotionSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.positionSpeed = new GuiTextElement(mc, 10000, (str) -> this.speed.speed = this.parse(str, this.positionSpeed, this.speed.speed));
        this.positionSpeed.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.position_speed"));
        this.positionX = new GuiTextElement(mc, 10000, (str) -> this.updatePosition(str, this.positionX, 0));
        this.positionX.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_x"));
        this.positionY = new GuiTextElement(mc, 10000, (str) -> this.updatePosition(str, this.positionY, 1));
        this.positionY.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_y"));
        this.positionZ = new GuiTextElement(mc, 10000, (str) -> this.updatePosition(str, this.positionZ, 2));
        this.positionZ.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_z"));
        this.positionDrag = new GuiTextElement(mc, 10000, (str) ->
        {
            BedrockComponentMotionDynamic component = (BedrockComponentMotionDynamic) this.component;

            component.motionDrag = this.parse(str, this.positionDrag, component.motionDrag);
        });
        this.positionDrag.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.position_drag"));

        this.rotationAngle = new GuiTextElement(mc, 10000, (str) -> this.spin.rotation = this.parse(str, this.rotationAngle, this.spin.rotation));
        this.rotationAngle.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.rotation_angle"));
        this.rotationRate = new GuiTextElement(mc, 10000, (str) -> this.spin.rate = this.parse(str, this.rotationRate, this.spin.rate));
        this.rotationRate.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.rotation_speed"));
        this.rotationAcceleration = new GuiTextElement(mc, 10000, (str) ->
        {
            if (this.component instanceof BedrockComponentMotionDynamic)
            {
                BedrockComponentMotionDynamic component = (BedrockComponentMotionDynamic) this.component;

                component.rotationAcceleration = this.parse(str, this.rotationAcceleration, component.rotationAcceleration);
            }
            else
            {
                BedrockComponentMotionParametric component = (BedrockComponentMotionParametric) this.component;

                component.rotation = this.parse(str, this.rotationAcceleration, component.rotation);
            }
        });
        this.rotationAcceleration.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.rotation_acceleration"));
        this.rotationDrag = new GuiTextElement(mc, 10000, (str) ->
        {
            BedrockComponentMotionDynamic component = (BedrockComponentMotionDynamic) this.component;

            component.rotationDrag = this.parse(str, this.rotationDrag, component.rotationDrag);
        });
        this.rotationDrag.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.rotation_drag"));

        this.position = new GuiElement(mc);

        this.position.flex().column(5).vertical().stretch();
        this.position.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.speed")).marginTop(12), this.positionSpeed);

        this.positionElements = new GuiElement(mc);

        this.positionElements.flex().column(5).vertical().stretch();
        this.positionElements.add(this.positionX, this.positionY, this.positionZ);
        this.positionElements.addBefore(this.positionX, this.positionTitle);
        this.position.add(this.positionElements);

        this.positionDragRow = new GuiElement(mc);
        this.rotationDragRow = new GuiElement(mc);

        this.rotationDragRow.flex().column(5).vertical().stretch();
        this.rotationDragRow.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.rotation_drag")), this.rotationDrag);

        this.positionDragRow.flex().column(5).vertical().stretch();
        this.positionDragRow.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.position_drag_title")), this.positionDrag);


        this.rotation = new GuiElement(mc);
        this.rotation.flex().column(5).vertical().stretch();
        this.rotation.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.rotation")).marginTop(12), this.rotationAngle, this.rotationRate);
        this.rotation.add(this.rotationAcceleration);

        this.fields.add(this.position, this.rotation);
    }

    private void updatePosition(String str, GuiTextElement element, int index)
    {
        if (this.component instanceof BedrockComponentMotionDynamic)
        {
            BedrockComponentMotionDynamic component = (BedrockComponentMotionDynamic) this.component;

            component.motionAcceleration[index] = this.parse(str, element, component.motionAcceleration[index]);
        }
        else
        {
            BedrockComponentMotionParametric component = (BedrockComponentMotionParametric) this.component;

            component.position[index] = this.parse(str, element, component.position[index]);
        }
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.motion.title";
    }

    @Override
    protected void fillModes(GuiCirculateElement button)
    {
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.motion.dynamic"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.motion.parametric"));
    }

    @Override
    protected Class<BedrockComponentMotion> getBaseClass()
    {
        return BedrockComponentMotion.class;
    }

    @Override
    protected Class getDefaultClass()
    {
        return BedrockComponentMotionDynamic.class;
    }

    @Override
    protected Class getModeClass(int value)
    {
        if (value == 1)
        {
            return BedrockComponentMotionParametric.class;
        }

        return BedrockComponentMotionDynamic.class;
    }

    @Override
    protected void fillData()
    {
        super.fillData();

        this.speed = this.scheme.getOrCreate(BedrockComponentInitialSpeed.class);
        this.spin = this.scheme.getOrCreate(BedrockComponentInitialSpin.class);

        this.set(this.positionSpeed, this.speed.speed);
        this.set(this.rotationAngle, this.spin.rotation);
        this.set(this.rotationRate, this.spin.rate);

        this.positionDragRow.removeFromParent();
        this.rotationDragRow.removeFromParent();

        if (this.component instanceof BedrockComponentMotionDynamic)
        {
            BedrockComponentMotionDynamic component = (BedrockComponentMotionDynamic) this.component;

            this.positionElements.remove(this.positionTitle);

            this.positionTitle = Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_title")).marginTop(12);

            this.positionElements.addBefore(this.positionX, this.positionTitle);

            this.positionX.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_x"));
            this.positionY.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_y"));
            this.positionZ.tooltip(IKey.lang("blockbuster.gui.snowstorm.motion.acceleration_z"));

            this.set(this.positionX, component.motionAcceleration[0]);
            this.set(this.positionY, component.motionAcceleration[1]);
            this.set(this.positionZ, component.motionAcceleration[2]);
            this.set(this.rotationAcceleration, component.rotationAcceleration);

            this.set(this.positionDrag, component.motionDrag);
            this.set(this.rotationDrag, component.rotationDrag);

            this.position.add(this.positionDragRow);
            this.rotation.add(this.rotationDragRow);
        }
        else
        {
            BedrockComponentMotionParametric component = (BedrockComponentMotionParametric) this.component;

            this.positionElements.remove(this.positionTitle);

            this.positionTitle = Elements.label(IKey.lang("blockbuster.gui.snowstorm.motion.position"));
            this.positionTitle.marginTop(12);

            this.positionElements.addBefore(this.positionX, this.positionTitle);

            this.positionX.tooltip(IKey.lang("blockbuster.gui.model_block.x"));
            this.positionY.tooltip(IKey.lang("blockbuster.gui.model_block.y"));
            this.positionZ.tooltip(IKey.lang("blockbuster.gui.model_block.z"));

            this.set(this.positionX, component.position[0]);
            this.set(this.positionY, component.position[1]);
            this.set(this.positionZ, component.position[2]);
            this.set(this.rotationAcceleration, component.rotation);
        }

        this.resizeParent();
    }
}

==================================================

--- Файл №143 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormParticleMorphSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentParticleMorph;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import net.minecraft.client.Minecraft;

public class GuiSnowstormParticleMorphSection extends GuiSnowstormComponentSection<BedrockComponentParticleMorph>
{
    public GuiToggleElement enabled;
    public GuiToggleElement renderTexture;
    public GuiNestedEdit pickMorph;

    public GuiSnowstormParticleMorphSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.enabled = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.particle_morph.enabled"), (b) ->
        {
            this.component.enabled = b.isToggled();

            this.parent.dirty();
        });

        this.renderTexture = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.particle_morph.render_texture"), (b) ->
        {
            this.component.renderTexture = b.isToggled();

            this.parent.dirty();
        });

        this.pickMorph = new GuiNestedEdit(mc, (editing) ->
        {
            ClientProxy.panels.addMorphs(this.parent, editing, this.component.morph.get());
            this.parent.dirty();
        });
        this.pickMorph.marginTop(80);

        this.fields.add(this.enabled, this.pickMorph, this.renderTexture);
    }

    public void setMorph(AbstractMorph morph)
    {
        this.component.morph.set(morph);

        this.pickMorph.setMorph(morph);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.particle_morph.title";
    }

    @Override
    public void draw(GuiContext context)
    {
        if (!this.component.morph.isEmpty())
        {
            AbstractMorph morph = this.component.morph.get();
            int x = this.area.mx();
            int y = this.enabled.area.y(1F) + 50;

            GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);
            morph.renderOnScreen(this.mc.player, x, y, this.area.h / 3.5F, 1.0F);
            GuiDraw.unscissor(context);
        }

        super.draw(context);
    }

    @Override
    protected BedrockComponentParticleMorph getComponent(BedrockScheme scheme)
    {
        return this.scheme.getOrCreate(BedrockComponentParticleMorph.class);
    }

    @Override
    protected void fillData()
    {
        this.enabled.toggled(this.component.enabled);
        this.renderTexture.toggled(this.component.renderTexture);
        this.pickMorph.setMorph(this.component.morph.get());
    }
}


==================================================

--- Файл №144 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormRateSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSectionManager;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.components.rate.BedrockComponentRate;
import mchorse.blockbuster.client.particles.components.rate.BedrockComponentRateInstant;
import mchorse.blockbuster.client.particles.components.rate.BedrockComponentRateSteady;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.tooltips.LabelTooltip;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiSnowstormRateSection extends GuiSnowstormModeSection<BedrockComponentRate>
{
    public GuiTextElement rate;
    public GuiTextElement particles;

    public GuiSnowstormRateSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.rate = new GuiTextElement(mc, 10000, (str) ->
        {
            BedrockComponentRateSteady comp = (BedrockComponentRateSteady) this.component;

            comp.spawnRate = this.parse(str, this.rate, comp.spawnRate);
        });
        this.rate.tooltip(IKey.lang("blockbuster.gui.snowstorm.rate.spawn_rate"));
        this.particles = new GuiTextElement(mc, 10000, (str) -> this.component.particles = this.parse(str, this.particles, this.component.particles));
        this.particles.tooltip(IKey.lang(""));

        this.fields.add(this.particles);
    }
    
    @Override
    protected void collapseState()
    {
        GuiSectionManager.setDefaultState(this.getClass().getSimpleName(), false);
        
        super.collapseState();
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.rate.title";
    }

    @Override
    protected void fillModes(GuiCirculateElement button)
    {
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.rate.instant"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.rate.steady"));
    }

    @Override
    protected void restoreInfo(BedrockComponentRate component, BedrockComponentRate old)
    {
        component.particles = old.particles;
    }

    @Override
    protected Class<BedrockComponentRate> getBaseClass()
    {
        return BedrockComponentRate.class;
    }

    @Override
    protected Class getDefaultClass()
    {
        return BedrockComponentRateInstant.class;
    }

    @Override
    protected Class getModeClass(int value)
    {
        return value == 0 ? BedrockComponentRateInstant.class : BedrockComponentRateSteady.class;
    }

    @Override
    protected void fillData()
    {
        super.fillData();

        this.updateVisibility();
        this.set(this.particles, this.component.particles);
        ((LabelTooltip) this.particles.tooltip).label.set(this.isInstant() ? "blockbuster.gui.snowstorm.rate.particles" : "blockbuster.gui.snowstorm.rate.max_particles");

        if (this.component instanceof BedrockComponentRateSteady)
        {
            this.set(this.rate, ((BedrockComponentRateSteady) this.component).spawnRate );
        }
    }

    private void updateVisibility()
    {
        if (this.isInstant())
        {
            this.rate.removeFromParent();
        }
        else if (!this.rate.hasParent())
        {
            this.fields.add(this.rate);
        }

        this.resizeParent();
    }

    private boolean isInstant()
    {
        return this.component instanceof BedrockComponentRateInstant;
    }
}


==================================================

--- Файл №145 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSectionManager;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;

public abstract class GuiSnowstormSection extends GuiElement
{
    public GuiLabel title;
    public GuiElement fields;

    protected BedrockScheme scheme;
    protected GuiSnowstorm parent;

    public GuiSnowstormSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc);
        
        this.parent = parent;
        this.title = Elements.label(IKey.lang(this.getTitle())).background(() -> ColorUtils.HALF_BLACK + McLib.primaryColor.get());
        this.fields = new GuiElement(mc);
        this.fields.flex().column(5).stretch().vertical().height(20);

        this.flex().column(5).stretch().vertical();
        this.add(this.title);
        
        this.collapseState();
    }
    
    protected void collapseState()
    {
        if (!GuiSectionManager.isCollapsed(this.getClass().getSimpleName()))
        {
            this.add(this.fields);
        }
    }

    protected void resizeParent()
    {
        this.getParent().resize();
    }

    public void dirty()
    {
        this.parent.dirty();
    }

    public abstract String getTitle();

    public MolangExpression parse(String string, GuiTextElement element, MolangExpression old)
    {
        if (string.isEmpty())
        {
            return MolangParser.ZERO;
        }

        try
        {
            MolangExpression expression = this.scheme.parser.parseExpression(string);

            element.field.setTextColor(0xffffff);
            this.parent.dirty();

            return expression;
        }
        catch (Exception e)
        {}

        element.field.setTextColor(0xff2244);

        return old;
    }

    public void set(GuiTextElement element, MolangExpression expression)
    {
        element.field.setTextColor(0xffffff);
        element.setText(expression.toString());
    }

    public void setScheme(BedrockScheme scheme)
    {
        this.scheme = scheme;
    }

    public void beforeSave(BedrockScheme scheme)
    {}

    /**
     * Toggle visibility of the field section
     */
    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.title.area.isInside(context))
        {
            if (this.fields.hasParent())
            {
                this.fields.removeFromParent();
                GuiSectionManager.setCollapsed(this.getClass().getSimpleName(), true);
            }
            else
            {
                this.add(this.fields);
                GuiSectionManager.setCollapsed(this.getClass().getSimpleName(), false);
            }

            this.resizeParent();

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №146 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormShapeSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSectionManager;
import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeBase;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeBox;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeDisc;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeEntityAABB;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapePoint;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeSphere;
import mchorse.blockbuster.client.particles.components.shape.ShapeDirection;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.molang.MolangParser;
import net.minecraft.client.Minecraft;

public class GuiSnowstormShapeSection extends GuiSnowstormModeSection<BedrockComponentShapeBase>
{
    public GuiTextElement offsetX;
    public GuiTextElement offsetY;
    public GuiTextElement offsetZ;
    public GuiDirectionSection direction;
    public GuiToggleElement surface;

    public GuiLabel radiusLabel;
    public GuiTextElement radius;

    public GuiLabel label;
    public GuiTextElement x;
    public GuiTextElement y;
    public GuiTextElement z;

    public GuiSnowstormShapeSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.offsetX = new GuiTextElement(mc, 10000, (str) -> this.component.offset[0] = this.parse(str, this.offsetX, this.component.offset[0]));
        this.offsetX.tooltip(IKey.lang("blockbuster.gui.model_block.x"));
        this.offsetY = new GuiTextElement(mc, 10000, (str) -> this.component.offset[1] = this.parse(str, this.offsetY, this.component.offset[1]));
        this.offsetY.tooltip(IKey.lang("blockbuster.gui.model_block.y"));
        this.offsetZ = new GuiTextElement(mc, 10000, (str) -> this.component.offset[2] = this.parse(str, this.offsetZ, this.component.offset[2]));
        this.offsetZ.tooltip(IKey.lang("blockbuster.gui.model_block.z"));
        this.direction = new GuiDirectionSection(mc, this);
        this.surface = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.shape.surface"), (b) ->
        {
            this.component.surface = b.isToggled();
            this.parent.dirty();
        });
        this.surface.tooltip(IKey.lang("blockbuster.gui.snowstorm.shape.surface_tooltip"));

        this.radiusLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.shape.radius"));
        this.radiusLabel.marginTop(12);
        this.radius = new GuiTextElement(mc, 10000, (str) ->
        {
            BedrockComponentShapeSphere sphere = (BedrockComponentShapeSphere) this.component;

            sphere.radius = this.parse(str, this.radius, sphere.radius);
        });

        this.label = Elements.label(IKey.lang(""));
        this.label.marginTop(12);
        this.x = new GuiTextElement(mc, 10000, (str) -> this.updateNormalDimension(str, this.x, 0));
        this.x.tooltip(IKey.lang("blockbuster.gui.model_block.x"));
        this.y = new GuiTextElement(mc, 10000, (str) -> this.updateNormalDimension(str, this.y, 1));
        this.y.tooltip(IKey.lang("blockbuster.gui.model_block.y"));
        this.z = new GuiTextElement(mc, 10000, (str) -> this.updateNormalDimension(str, this.z, 2));
        this.z.tooltip(IKey.lang("blockbuster.gui.model_block.z"));

        this.modeLabel.label.set("blockbuster.gui.snowstorm.shape.shape");

        this.fields.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.shape.offset")).marginTop(12), this.offsetX, this.offsetY, this.offsetZ, this.direction, this.surface);
    }
    
    @Override
    protected void collapseState()
    {
        GuiSectionManager.setDefaultState(this.getClass().getSimpleName(), false);
        
        super.collapseState();
    }

    private void updateNormalDimension(String str, GuiTextElement element, int index)
    {
        if (this.component instanceof BedrockComponentShapeBox)
        {
            BedrockComponentShapeBox box = (BedrockComponentShapeBox) this.component;

            box.halfDimensions[index] = this.parse(str, element, box.halfDimensions[index]);
        }
        else if (this.component instanceof BedrockComponentShapeDisc)
        {
            BedrockComponentShapeDisc disc = (BedrockComponentShapeDisc) this.component;

            disc.normal[index] = this.parse(str, element, disc.normal[index]);
        }
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.shape.title";
    }

    @Override
    protected void fillModes(GuiCirculateElement button)
    {
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.point"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.box"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.sphere"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.disc"));
        button.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.aabb"));
    }

    @Override
    protected void restoreInfo(BedrockComponentShapeBase component, BedrockComponentShapeBase old)
    {
        component.offset = old.offset;
        component.direction = old.direction;
        component.surface = old.surface;

        if (component instanceof BedrockComponentShapeSphere && old instanceof BedrockComponentShapeSphere)
        {
            ((BedrockComponentShapeSphere) component).radius = ((BedrockComponentShapeSphere) old).radius;
        }
    }

    @Override
    protected Class<BedrockComponentShapeBase> getBaseClass()
    {
        return BedrockComponentShapeBase.class;
    }

    @Override
    protected Class getDefaultClass()
    {
        return BedrockComponentShapePoint.class;
    }

    @Override
    protected Class getModeClass(int value)
    {
        if (value == 1)
        {
            return BedrockComponentShapeBox.class;
        }
        else if (value == 2)
        {
            return BedrockComponentShapeSphere.class;
        }
        else if (value == 3)
        {
            return BedrockComponentShapeDisc.class;
        }
        else if (value == 4)
        {
            return BedrockComponentShapeEntityAABB.class;
        }

        return BedrockComponentShapePoint.class;
    }

    @Override
    protected void fillData()
    {
        super.fillData();

        this.set(this.offsetX, this.component.offset[0]);
        this.set(this.offsetY, this.component.offset[1]);
        this.set(this.offsetZ, this.component.offset[2]);
        this.direction.fillData();
        this.surface.toggled(this.component.surface);

        if (this.component instanceof BedrockComponentShapeSphere)
        {
            this.set(this.radius, ((BedrockComponentShapeSphere) this.component).radius);
        }

        this.setNormalDimension(this.x, 0);
        this.setNormalDimension(this.y, 1);
        this.setNormalDimension(this.z, 2);

        this.radiusLabel.removeFromParent();;
        this.radius.removeFromParent();
        this.label.removeFromParent();
        this.x.removeFromParent();
        this.y.removeFromParent();
        this.z.removeFromParent();
        this.surface.removeFromParent();

        if (this.component instanceof BedrockComponentShapeSphere)
        {
            this.fields.add(this.radiusLabel, this.radius);
        }

        if (this.component instanceof BedrockComponentShapeBox || this.component instanceof BedrockComponentShapeDisc)
        {
            this.label.label.set("blockbuster.gui.snowstorm.shape." + (this.component instanceof BedrockComponentShapeBox ? "box_size" : "normal"));

            this.fields.add(this.label);
            this.fields.add(this.x);
            this.fields.add(this.y);
            this.fields.add(this.z);
        }

        this.fields.add(this.surface);

        this.resizeParent();
    }

    private void setNormalDimension(GuiTextElement text, int index)
    {
        if (this.component instanceof BedrockComponentShapeBox)
        {
            this.set(text, ((BedrockComponentShapeBox) this.component).halfDimensions[index]);
        }
        else if (this.component instanceof BedrockComponentShapeDisc)
        {
            this.set(text, ((BedrockComponentShapeDisc) this.component).normal[index]);
        }
    }

    public static class GuiDirectionSection extends GuiElement
    {
        public GuiSnowstormShapeSection parent;

        public GuiCirculateElement mode;
        public GuiTextElement x;
        public GuiTextElement y;
        public GuiTextElement z;

        public GuiDirectionSection(Minecraft mc, GuiSnowstormShapeSection parent)
        {
            super(mc);

            this.parent = parent;
            this.mode = new GuiCirculateElement(mc, (b) ->
            {
                int value = this.mode.getValue();

                if (value == 0)
                {
                    this.parent.component.direction = ShapeDirection.OUTWARDS;
                }
                else if (value == 1)
                {
                    this.parent.component.direction = ShapeDirection.INWARDS;
                }
                else
                {
                    this.parent.component.direction = new ShapeDirection.Vector(MolangParser.ZERO, MolangParser.ZERO, MolangParser.ZERO);
                }

                this.parent.parent.dirty();
                this.fillData();
            });
            this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.direction_outwards"));
            this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.direction_inwards"));
            this.mode.addLabel(IKey.lang("blockbuster.gui.snowstorm.shape.direction_vector"));

            this.x = new GuiTextElement(mc, 10000, (str) -> this.getVector().x = this.parent.parse(str, this.x, this.getVector().x));
            this.x.tooltip(IKey.lang("blockbuster.gui.model_block.x"));
            this.y = new GuiTextElement(mc, 10000, (str) -> this.getVector().y = this.parent.parse(str, this.y, this.getVector().y));
            this.y.tooltip(IKey.lang("blockbuster.gui.model_block.y"));
            this.z = new GuiTextElement(mc, 10000, (str) -> this.getVector().z = this.parent.parse(str, this.z, this.getVector().z));
            this.z.tooltip(IKey.lang("blockbuster.gui.model_block.z"));

            this.flex().column(5).vertical().stretch().height(20);
            this.add(Elements.row(mc, 5, 0, 20, Elements.label(IKey.lang("blockbuster.gui.snowstorm.shape.direction"), 20).anchor(0, 0.5F), this.mode));
        }

        private ShapeDirection.Vector getVector()
        {
            return (ShapeDirection.Vector) this.parent.component.direction;
        }

        public void fillData()
        {
            boolean isVector = this.parent.component.direction instanceof ShapeDirection.Vector;
            int value = 0;

            if (this.parent.component.direction == ShapeDirection.INWARDS)
            {
                value = 1;
            }
            else if (isVector)
            {
                value = 2;
            }

            this.mode.setValue(value);

            this.x.removeFromParent();
            this.y.removeFromParent();
            this.z.removeFromParent();

            if (isVector)
            {
                ShapeDirection.Vector vector = (ShapeDirection.Vector) this.parent.component.direction;

                this.parent.set(this.x, vector.x);
                this.parent.set(this.y, vector.y);
                this.parent.set(this.z, vector.z);

                this.add(this.x, this.y, this.z);
            }

            this.parent.resizeParent();
        }
    }
}


==================================================

--- Файл №147 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\sections\GuiSnowstormSpaceSection.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.GuiSnowstorm;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.meta.BedrockComponentLocalSpace;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.Operation;
import net.minecraft.client.Minecraft;

public class GuiSnowstormSpaceSection extends GuiSnowstormComponentSection<BedrockComponentLocalSpace>
{
    public GuiToggleElement position;
    public GuiToggleElement rotation;
    public GuiToggleElement scale;
    public GuiToggleElement scaleBillboard;
    public GuiElement scaleColumns;
    public GuiToggleElement direction; //local direction for physical accurate systems
    public GuiToggleElement acceleration;
    public GuiToggleElement gravity;
    public GuiTrackpadElement linearVelocity;
    public GuiTrackpadElement angularVelocity;

    public GuiElement objectVelocity;

    public GuiSnowstormSpaceSection(Minecraft mc, GuiSnowstorm parent)
    {
        super(mc, parent);

        this.position = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.position"), (b) ->
        {
            this.component.position = b.isToggled();
            this.parent.dirty();
        });
        this.position.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.position_tooltip"));

        this.rotation = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.rotation"), (b) ->
        {
            this.component.rotation = b.isToggled();
            this.parent.dirty();
        });
        this.rotation.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.rotation_tooltip"));

        this.scale = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.scale"), (b) ->
        {
            this.component.scale = b.isToggled();
            this.parent.dirty();

            updateButtons();
        });
        this.scale.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.scale_tooltip"));

        this.scaleBillboard = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.scale_billboard"), (b) ->
        {
            this.component.scaleBillboard = b.isToggled();
            this.parent.dirty();
        });
        this.scaleBillboard.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.scale_billboard_tooltip"));

        this.direction = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.direction"), (b) ->
        {
            this.component.direction = b.isToggled();
            this.parent.dirty();
        });
        this.direction.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.direction_tooltip"));

        this.acceleration = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.acceleration"), (b) ->
        {
            this.component.acceleration = b.isToggled();
            this.parent.dirty();
        });
        this.acceleration.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.acceleration_tooltip"));

        this.gravity = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.snowstorm.space.gravity"), (b) ->
        {
            this.component.gravity = b.isToggled();
            this.parent.dirty();
        });

        this.objectVelocity = new GuiElement(mc);
        this.scaleColumns = new GuiElement(mc);

        this.scaleColumns.flex().column(4).stretch().vertical().height(2);
        this.objectVelocity.flex().column(4).stretch().vertical().height(4);

        this.linearVelocity = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.linearVelocity = value.floatValue();
            this.parent.dirty();
        });
        this.linearVelocity.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.linear_velocity_tooltip"));
        this.objectVelocity.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.space.object_velocity_title")).marginTop(12), Elements.label(IKey.lang("blockbuster.gui.snowstorm.space.linear_velocity")).marginTop(12), this.linearVelocity);

        this.angularVelocity = new GuiTrackpadElement(mc, (value) ->
        {
            this.component.angularVelocity = value.floatValue();
            this.parent.dirty();
        });
        this.angularVelocity.tooltip(IKey.lang("blockbuster.gui.snowstorm.space.angular_velocity_tooltip"));
        this.objectVelocity.add(Elements.label(IKey.lang("blockbuster.gui.snowstorm.space.angular_velocity")).marginTop(12), this.angularVelocity);

        this.scaleColumns.add(this.scale);
        this.scaleColumns.add(this.scaleBillboard);

        this.fields.add(this.position, this.rotation, this.scaleColumns, this.direction, this.acceleration, this.gravity, this.objectVelocity);
    }

    @Override
    public String getTitle()
    {
        return "blockbuster.gui.snowstorm.space.title";
    }

    @Override
    protected BedrockComponentLocalSpace getComponent(BedrockScheme scheme)
    {
        return scheme.getOrCreate(BedrockComponentLocalSpace.class);
    }

    @Override
    protected void fillData()
    {
        this.position.toggled(this.component.position);
        this.rotation.toggled(this.component.rotation);
        this.scale.toggled(this.component.scale);
        this.scaleBillboard.toggled(this.component.scaleBillboard);
        this.direction.toggled(this.component.direction);
        this.acceleration.toggled(this.component.acceleration);
        this.gravity.toggled(this.component.gravity);
        this.linearVelocity.setValue(this.component.linearVelocity);
        this.angularVelocity.setValue(this.component.angularVelocity);

        updateButtons();
    }

    private void updateButtons()
    {
        /*this.scaleBillboard.removeFromParent();

        if (this.scale.isToggled())
        {
            this.scaleColumns.add(this.scaleBillboard);
        }

        this.resizeParent();*/
    }
}

==================================================

--- Файл №148 ---
Путь: main\java\mchorse\blockbuster\client\gui\dashboard\panels\snowstorm\utils\GuiGradientEditor.java
--------------------
package mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.utils;

import mchorse.blockbuster.client.gui.dashboard.panels.snowstorm.sections.GuiSnowstormSection;
import mchorse.blockbuster.client.particles.components.appearance.Tint;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.molang.expressions.MolangValue;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;

public class GuiGradientEditor extends GuiElement
{
    private GuiSnowstormSection section;
    private GuiColorElement color;

    private Tint.Gradient gradient;

    private Tint.Gradient.ColorStop current;
    private int dragging = -1;
    private int lastX;

    private Area a = new Area();
    private Area b = new Area();
    private Color c = new Color();

    public GuiGradientEditor(Minecraft mc, GuiSnowstormSection section, GuiColorElement color)
    {
        super(mc);

        this.section = section;
        this.color = color;

        this.flex().h(20);
    }

    private Color fillColor(Tint.Solid solid)
    {
        this.c.r = (float) solid.r.get();
        this.c.g = (float) solid.g.get();
        this.c.b = (float) solid.b.get();
        this.c.a = (float) solid.a.get();

        return this.c;
    }

    private Area fillBound(Tint.Gradient.ColorStop stop)
    {
        int x = this.a.x(stop.stop);

        this.b.set(x - 3, this.a.ey() - 7, 6, 10);

        return this.b;
    }

    private void fillStop(Tint.Gradient.ColorStop stop)
    {
        this.current = stop;
        this.color.picker.setColor(this.fillColor(stop.color).getRGBAColor());
    }

    public void setColor(int color)
    {
        this.c.set(color, true);

        ((MolangValue) this.current.color.r).value.set(this.c.r);
        ((MolangValue) this.current.color.g).value.set(this.c.g);
        ((MolangValue) this.current.color.b).value.set(this.c.b);
        ((MolangValue) this.current.color.a).value.set(this.c.a);

        this.section.dirty();
    }

    public void setGradient(Tint.Gradient gradient)
    {
        this.gradient = gradient;

        if (this.gradient.stops.isEmpty())
        {
            this.gradient.stops.add(new Tint.Gradient.ColorStop(0, new Tint.Solid()));
        }

        this.fillStop(this.gradient.stops.get(0));
        this.color.picker.setColor(this.fillColor(this.current.color).getRGBAColor());
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(context.mc);

        menu.action(Icons.ADD, IKey.lang("blockbuster.gui.snowstorm.lighting.context.add_stop"), () -> this.addColorStop(context.mouseX));

        if (this.gradient.stops.size() > 1)
        {
            menu.action(Icons.REMOVE, IKey.lang("blockbuster.gui.snowstorm.lighting.context.remove_stop"), this::removeColorStop);
        }

        return menu;
    }

    private void addColorStop(int mouseX)
    {
        float x = (mouseX - this.area.x) / (float) this.area.w;

        Tint.Solid color = new Tint.Solid();
        Tint.Gradient.ColorStop stop = new Tint.Gradient.ColorStop(x, color);

        color.r = new MolangValue(null, new Constant(1F));
        color.g = new MolangValue(null, new Constant(1F));
        color.b = new MolangValue(null, new Constant(1F));
        color.a = new MolangValue(null, new Constant(1F));

        this.gradient.stops.add(stop);
        this.gradient.sort();

        this.section.dirty();

        this.fillStop(stop);
    }

    private void removeColorStop()
    {
        if (this.gradient.stops.size() > 2)
        {
            int index = this.gradient.stops.indexOf(this.current);

            this.gradient.stops.remove(index);

            index = MathUtils.clamp(index, 0, this.gradient.stops.size() - 1);

            this.section.dirty();

            this.fillStop(this.gradient.stops.get(index));
        }
    }

    @Override
    public void resize()
    {
        super.resize();

        this.a.copy(this.area);
        this.a.offset(-1);
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.area.isInside(context))
        {
            for (Tint.Gradient.ColorStop stop : this.gradient.stops)
            {
                Area area = this.fillBound(stop);

                if (area.isInside(context))
                {
                    this.dragging = 0;
                    this.lastX = context.mouseX;
                    this.fillStop(stop);

                    return true;
                }
            }

            return true;
        }

        return false;
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);

        if (this.dragging != -1)
        {
            this.section.dirty();
        }

        this.dragging = -1;
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.dragging == 0 && Math.abs(context.mouseX - this.lastX) > 3)
        {
            this.dragging = 1;
        }
        else if (this.dragging == 1)
        {
            float x = (context.mouseX - this.area.x) / (float) this.area.w;

            this.current.stop = MathUtils.clamp(x, 0, 1);
            this.gradient.sort();
        }

        this.area.draw(0xff000000);

        int size = this.gradient.stops.size();

        GlStateManager.color(1, 1, 1, 1);
        Icons.CHECKBOARD.renderArea(this.a.x, this.a.y, this.a.w, this.a.h);

        Tint.Gradient.ColorStop first = this.gradient.stops.get(0);

        if (first.stop > 0)
        {
            int x1 = this.a.x(first.stop);
            int rgba1 = this.fillColor(first.color).getRGBAColor();

            Gui.drawRect(this.a.x, this.a.y, x1, this.a.ey(), rgba1);
        }

        for (int i = 0; i < size; i++)
        {
            Tint.Gradient.ColorStop stop = this.gradient.stops.get(i);
            Tint.Gradient.ColorStop next = i + 1 < size ? this.gradient.stops.get(i + 1) : stop;

            int x1 = this.a.x(stop.stop);
            int x2 = this.a.x((next == stop ? 1 : next.stop));

            int rgba1 = this.fillColor(stop.color).getRGBAColor();
            int rgba2 = this.fillColor(next.color).getRGBAColor();

            GuiDraw.drawHorizontalGradientRect(x1, this.a.y, x2, this.a.ey(), rgba1, rgba2);
        }

        for (int i = 0; i < size; i++)
        {
            Tint.Gradient.ColorStop stop = this.gradient.stops.get(i);
            Area area = this.fillBound(stop);

            int x = this.a.x(stop.stop);

            Gui.drawRect(area.x, area.y, area.ex(), area.ey(), this.current == stop ? 0xffffffff : 0xff000000);
            Gui.drawRect(area.x + 1, area.y + 1, area.ex() - 1, area.ey() - 1, this.fillColor(stop.color).getRGBAColor());
        }

        super.draw(context);
    }
}

==================================================

--- Файл №149 ---
Путь: main\java\mchorse\blockbuster\client\gui\utils\GuiShapeKeysEditor.java
--------------------
package mchorse.blockbuster.client.gui.utils;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.blockbuster_pack.client.gui.GuiCustomMorph;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;

import java.util.List;
import java.util.function.Supplier;

public class GuiShapeKeysEditor extends GuiElement
{
    public GuiListElement<ShapeKey> shapes;
    public GuiTrackpadElement factor;
    public GuiToggleElement relative;

    private Supplier<Model> supplier;

    public GuiShapeKeysEditor(Minecraft mc, Supplier<Model> supplier)
    {
        super(mc);

        this.supplier = supplier;

        this.shapes = new GuiCustomMorph.GuiShapeKeyListElement(mc, (str) -> this.setFactor(str.get(0)));
        this.shapes.sorting().background();
        this.shapes.context(() ->
        {
            GuiSimpleContextMenu menu = new GuiSimpleContextMenu(mc);

            menu.action(Icons.ADD, IKey.lang("blockbuster.gui.builder.context.add"), () ->
            {
                Model model = this.supplier == null ? null : this.supplier.get();

                if (model == null)
                {
                    return;
                }

                GuiSimpleContextMenu nested = new GuiSimpleContextMenu(mc);

                for (String key : model.shapes)
                {
                    nested.action(Icons.ADD, IKey.format("blockbuster.gui.builder.context.add_to", key), () ->
                    {
                        ShapeKey shapeKey = new ShapeKey(key, 0);

                        this.shapes.getList().add(shapeKey);
                        this.shapes.update();
                        this.shapes.setCurrent(shapeKey);
                        this.setFactor(shapeKey);
                    });
                }

                GuiBase.getCurrent().replaceContextMenu(nested);
            });

            if (this.shapes.getIndex() != -1)
            {
                menu.action(Icons.REMOVE, IKey.lang("blockbuster.gui.builder.context.remove"), () ->
                {
                    int index = this.shapes.getIndex();

                    this.shapes.getList().remove(index);
                    index = MathUtils.clamp(index, 0, this.shapes.getList().size() - 1);

                    this.shapes.setIndex(index);
                    this.setFactor(this.shapes.getCurrentFirst());
                });
            }

            return menu;
        });
        this.factor = new GuiTrackpadElement(mc, (value) -> this.setFactor(value.floatValue()));
        this.factor.tooltip(IKey.lang("blockbuster.gui.builder.shape_keys_factor_tooltip"), Direction.TOP);

        this.relative = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.builder.relative"), (b) -> this.shapes.getCurrentFirst().relative = b.isToggled());
        this.relative.tooltip(IKey.lang("blockbuster.gui.builder.relative_tooltip"), Direction.TOP);

        this.shapes.flex().relative(this).y(12).w(1F).hTo(this.factor.flex(), -17);
        this.factor.flex().relative(this.relative.flex()).y(-25).w(1F).h(20);
        this.relative.flex().relative(this).y(1F).w(1F).anchorY(1F);

        this.add(this.relative, this.factor, this.shapes);
    }

    private void setFactor(ShapeKey key)
    {
        this.factor.setEnabled(key != null);
        this.relative.setEnabled(key != null);

        if (key != null)
        {
            this.factor.setValue(key.value);
            this.relative.toggled(key.relative);
        }
    }

    private void setFactor(float value)
    {
        this.shapes.getCurrentFirst().value = value;
    }

    public void fillData(List<ShapeKey> shapeKeys)
    {
        this.shapes.setList(shapeKeys);

        if (!shapeKeys.isEmpty())
        {
            this.shapes.setIndex(0);
            this.setFactor(this.shapes.getCurrentFirst());
        }
        else
        {
            this.setFactor(null);
        }
    }

    @Override
    public void draw(GuiContext context)
    {
        super.draw(context);

        if (this.shapes.isVisible())
        {
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.builder.shape_keys"), this.shapes.area.x, this.shapes.area.y - 12, 0xffffff);
        }

        if (this.factor.isVisible())
        {
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.builder.shape_keys_factor"), this.factor.area.x, this.factor.area.y - 12, 0xffffff);
        }
    }
}


==================================================

--- Файл №150 ---
Путь: main\java\mchorse\blockbuster\client\model\ModelCustom.java
--------------------
package mchorse.blockbuster.client.model;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb.Holding;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.blockbuster.client.KeyboardHandler;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.OrientedBB;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.blockbuster_pack.morphs.CustomMorph.LimbProperties;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.EnumAction;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL14;

/**
 * Custom Model class
 * <p>
 * This class is responsible for managing available custom models that have
 * been loaded from config folder or from server and also render a custom model
 * itself.
 */
@SideOnly(Side.CLIENT)
public class ModelCustom extends ModelBiped
{
    /**
     * Repository of custom models that are available for usage
     */
    public static final Map<String, ModelCustom> MODELS = new HashMap<String, ModelCustom>();

    /**
     * Model data
     */
    public Model model;

    /**
     * Current pose
     */
    public ModelPose pose;

    public CustomMorph current;

    /**
     * Array of all limbs that has been parsed from JSON model
     */
    public ModelCustomRenderer[] limbs;

    /**
     * Array of limbs that has to be rendered (child limbs doesn't have to
     * be rendered, because they're getting render call from parent).
     */
    public ModelCustomRenderer[] renderable;

    public ModelCustomRenderer[] left;
    public ModelCustomRenderer[] right;
    public ModelCustomRenderer[] armor;

    public Map<String, ResourceLocation> materials;
    public List<ShapeKey> shapes;

    /**
     * Initiate the model with the size of the texture
     */
    public ModelCustom(Model model)
    {
        this.model = model;
        this.textureWidth = model.texture[0];
        this.textureHeight = model.texture[1];
    }

    /**
     * Get the {@link ModelCustomRenderer} for the provided limb name
     * @param name
     * @return the {@link ModelCustomRenderer} instance that has the limb with the same name as the provided String
     */
    public ModelCustomRenderer get(String name)
    {
        for (ModelCustomRenderer renderer : this.limbs)
        {
            if (renderer.limb.name.equals(name))
            {
                return renderer;
            }
        }

        return null;
    }

    @Override
    public void render(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        boolean keying = this.current != null && this.current.keying;

        GlStateManager.enableBlend();

        if (keying)
        {
            GlStateManager.glBlendEquation(GL14.GL_FUNC_REVERSE_SUBTRACT);
            GlStateManager.blendFunc(GL11.GL_ZERO, GL11.GL_ZERO);
        }
        else
        {
            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
        }

        if (this.current != null)
        {
            for (List<OrientedBB> obbs : this.current.orientedBBlimbs.values())
            {
                for (OrientedBB obb : obbs)
                {
                    obb.center.set(entityIn.prevPosX + (entityIn.posX - entityIn.prevPosX) * Minecraft.getMinecraft().getRenderPartialTicks(),
                            entityIn.prevPosY + (entityIn.posY - entityIn.prevPosY) * Minecraft.getMinecraft().getRenderPartialTicks(),
                            entityIn.prevPosZ + (entityIn.posZ - entityIn.prevPosZ) * Minecraft.getMinecraft().getRenderPartialTicks());
                }
            }
        }

        for (ModelRenderer limb : this.renderable)
        {
            limb.render(scale);
        }

        if (keying)
        {
            GlStateManager.glBlendEquation(GL14.GL_FUNC_ADD);
            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
        }

        GlStateManager.disableBlend();

        this.current = null;
    }

    public void renderForStencil(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        GlStateManager.enableBlend();
        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        for (int i = 0; i < this.limbs.length; i++)
        {
            this.limbs[i].setupStencilRendering(i + 1);
        }

        for (ModelRenderer limb : this.renderable)
        {
            limb.render(scale);
        }

        GlStateManager.disableBlend();
    }

    /**
     * Set hands postures
     */
    public void setHands(EntityLivingBase entity)
    {
        ItemStack rightItem = entity.getHeldItemMainhand();
        ItemStack leftItem = entity.getHeldItemOffhand();

        ModelBiped.ArmPose right = ModelBiped.ArmPose.EMPTY;
        ModelBiped.ArmPose left = ModelBiped.ArmPose.EMPTY;

        if (!rightItem.isEmpty())
        {
            right = ModelBiped.ArmPose.ITEM;

            if (entity.getItemInUseCount() > 0)
            {
                EnumAction enumaction = rightItem.getItemUseAction();

                if (enumaction == EnumAction.BLOCK)
                {
                    right = ModelBiped.ArmPose.BLOCK;
                }
                else if (enumaction == EnumAction.BOW)
                {
                    right = ModelBiped.ArmPose.BOW_AND_ARROW;
                }
            }
            if (rightItem.getItem() instanceof ItemGun)
            {
                GunProps props = NBTUtils.getGunProps(rightItem);

                if (props.alwaysArmsShootingPose)
                {
                    right = ModelBiped.ArmPose.BOW_AND_ARROW;
                }
                else if (props.enableArmsShootingPose && KeyboardHandler.gunShoot.isKeyDown())
                {
                    right = ModelBiped.ArmPose.BOW_AND_ARROW;
                }
            }
        }

        if (!leftItem.isEmpty())
        {
            left = ModelBiped.ArmPose.ITEM;

            if (entity.getItemInUseCount() > 0)
            {
                EnumAction action = leftItem.getItemUseAction();

                if (action == EnumAction.BLOCK)
                {
                    left = ModelBiped.ArmPose.BLOCK;
                }
            }
        }

        this.rightArmPose = right;
        this.leftArmPose = left;
    }

    /**
     * This method is responsible for setting gameplay wise features like head
     * looking, idle rotating (like arm swinging), swinging and swiping
     */
    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        if (entityIn instanceof EntityLivingBase)
        {
            this.setHands((EntityLivingBase) entityIn);
        }
        else
        {
            this.leftArmPose = ArmPose.EMPTY;
            this.rightArmPose = ArmPose.EMPTY;
        }

        for (ModelCustomRenderer limb : this.limbs)
        {
            boolean mirror = limb.limb.mirror;
            boolean invert = limb.limb.invert;

            if (limb instanceof ModelOBJRenderer)
            {
                ModelOBJRenderer obj = (ModelOBJRenderer) limb;

                obj.materials = this.materials;
                obj.shapes = this.shapes;
            }

            float factor = mirror ^ invert ? -1 : 1;
            float PI = (float) Math.PI;

            /* Reseting the angles */
            float anim = this.applyLimbPose(limb);
            float rotateX = limb.rotateAngleX;
            float rotateY = limb.rotateAngleY;
            float rotateZ = limb.rotateAngleZ;

            if (limb.limb.cape && entityIn instanceof EntityLivingBase && this.current != null)
            {
                float partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();
                EntityLivingBase living = (EntityLivingBase) entityIn;

                double dX = this.current.prevCapeX + (this.current.capeX - this.current.prevCapeX) * partialTicks - (living.prevPosX + (living.posX - living.prevPosX) * partialTicks);
                double dY = this.current.prevCapeY + (this.current.capeY - this.current.prevCapeY) * partialTicks - (living.prevPosY + (living.posY - living.prevPosY) * partialTicks);
                double dZ = this.current.prevCapeZ + (this.current.capeZ - this.current.prevCapeZ) * partialTicks - (living.prevPosZ + (living.posZ - living.prevPosZ) * partialTicks);
                float bodyYaw = living.prevRenderYawOffset + (living.renderYawOffset - living.prevRenderYawOffset) * partialTicks;
                double sin = MathHelper.sin(bodyYaw / 180 * PI);
                double cos = -MathHelper.cos(bodyYaw / 180 * PI);
                float h = (float) MathHelper.clamp(dY * 10.0F, -6.0F, 32.0F);
                float pitch = (float) (dX * sin + dZ * cos) * 100.0F;
                float yaw = (float) (dX * cos - dZ * sin) * 100.0F;

                if (pitch > 0.0F)
                {
                    pitch = -pitch;
                }

                float cameraYaw = 0;

                if (living instanceof EntityPlayer)
                {
                    EntityPlayer player = (EntityPlayer) living;

                    cameraYaw = player.prevCameraYaw + (player.cameraYaw - player.prevCameraYaw) * partialTicks;
                }

                h += MathHelper.sin((living.prevDistanceWalkedModified + (living.distanceWalkedModified - living.prevDistanceWalkedModified) * partialTicks) * 6.0F) * 32.0F * cameraYaw;

                limb.rotateAngleX += (6.0F + pitch / 2.0F + h) / 180 * PI;
                limb.rotateAngleY += (yaw / 2.0F * 0) / 180 * PI;
            }

            if ((limb.limb.lookX || limb.limb.lookY) && !limb.limb.wheel)
            {
                if (limb.limb.lookX)
                {
                    limb.rotateAngleX += headPitch * 0.017453292F;
                }

                if (limb.limb.lookY)
                {
                    if (invert)
                    {
                        limb.rotateAngleZ += netHeadYaw * 0.017453292F;
                    }
                    else
                    {
                        limb.rotateAngleY += netHeadYaw * 0.017453292F;
                    }
                }
            }

            if (limb.limb.swinging)
            {
                boolean flag = entityIn instanceof EntityLivingBase && ((EntityLivingBase) entityIn).getTicksElytraFlying() > 4;
                float f = 1.0F;

                if (flag)
                {
                    f = (float) (entityIn.motionX * entityIn.motionX + entityIn.motionY * entityIn.motionY + entityIn.motionZ * entityIn.motionZ);
                    f = f / 0.2F;
                    f = f * f * f;
                }

                if (f < 1.0F)
                {
                    f = 1.0F;
                }

                float f2 = mirror ^ invert ? 1 : 0;
                float f3 = limb.limb.holding == Holding.NONE ? 1.4F : 1.0F;

                limb.rotateAngleX += MathHelper.cos(limbSwing * 0.6662F + PI * f2) * f3 * limbSwingAmount / f;
            }

            if (limb.limb.idle)
            {
                limb.rotateAngleZ += (MathHelper.cos(ageInTicks * 0.09F) * 0.05F + 0.05F) * factor;
                limb.rotateAngleX += (MathHelper.sin(ageInTicks * 0.067F) * 0.05F) * factor;
            }

            if (limb.limb.swiping && !limb.limb.wing && this.swingProgress > 0.0F)
            {
                float swing = this.swingProgress;
                float bodyY = MathHelper.sin(MathHelper.sqrt(swing) * PI * 2F) * 0.2F;

                swing = 1.0F - swing;
                swing = swing * swing * swing;
                swing = 1.0F - swing;

                float sinSwing = MathHelper.sin(swing * PI);
                float sinSwing2 = MathHelper.sin(this.swingProgress * PI) * -(0.0F - 0.7F) * 0.75F;

                limb.rotateAngleX = limb.rotateAngleX - (sinSwing * 1.2F + sinSwing2);
                limb.rotateAngleY += bodyY * 2.0F * factor;
                limb.rotateAngleZ += MathHelper.sin(this.swingProgress * PI) * -0.4F * factor;
            }

            if (limb.limb.holding != Holding.NONE)
            {
                boolean right = limb.limb.holding == Holding.RIGHT;
                ModelBiped.ArmPose pose = right ? this.rightArmPose : this.leftArmPose;
                ModelBiped.ArmPose opposite = right ? this.leftArmPose : this.rightArmPose;

                switch (pose)
                {
                    case BLOCK:
                        limb.rotateAngleX = limb.rotateAngleX * 0.5F - 0.9424779F;
                        limb.rotateAngleY = 0.5235988F * (right ? -1 : 1);
                        break;

                    case ITEM:
                        if (limb.limb.hold)
                        {
                            limb.rotateAngleX = limb.rotateAngleX * 0.5F - PI / 10F;
                        }
                        break;
                }

                float rotateAngleX = headPitch * 0.017453292F;
                float rotateAngleY = netHeadYaw * 0.017453292F;

                if (right && pose == ModelBiped.ArmPose.BOW_AND_ARROW)
                {
                    limb.rotateAngleY = -0.1F + rotateAngleY - 0.4F;
                    limb.rotateAngleY = 0.1F + rotateAngleY;
                    limb.rotateAngleX = -((float) Math.PI / 2F) + rotateAngleX;
                    limb.rotateAngleX = -((float) Math.PI / 2F) + rotateAngleX;
                }
                else if (!right && opposite == ModelBiped.ArmPose.BOW_AND_ARROW)
                {
                    limb.rotateAngleY = -0.1F + rotateAngleY;
                    limb.rotateAngleY = 0.1F + rotateAngleY + 0.4F;
                    limb.rotateAngleX = -((float) Math.PI / 2F) + rotateAngleX;
                    limb.rotateAngleX = -((float) Math.PI / 2F) + rotateAngleX;
                }
            }

            if (limb.limb.wheel)
            {
                limb.rotateAngleX += limbSwing * factor;

                if (limb.limb.lookY)
                {
                    limb.rotateAngleY = netHeadYaw / 180 * (float) Math.PI;
                }
            }

            if (limb.limb.wing)
            {
                float wingFactor = MathHelper.cos(ageInTicks * 1.3F) * (float) Math.PI * 0.25F * (0.5F + limbSwingAmount) * factor;

                if (limb.limb.swiping)
                {
                    limb.rotateAngleZ = wingFactor;
                }
                else
                {
                    limb.rotateAngleY = wingFactor;
                }
            }

            if (limb.limb.roll)
            {
                limb.rotateAngleZ += -EntityUtils.getRoll(entityIn, ageInTicks % 1) / 180F * PI;
            }

            limb.rotateAngleX = (limb.rotateAngleX - rotateX) * anim + rotateX;
            limb.rotateAngleY = (limb.rotateAngleY - rotateY) * anim + rotateY;
            limb.rotateAngleZ = (limb.rotateAngleZ - rotateZ) * anim + rotateZ;
        }
    }

    /**
     * Apply transform from current pose on given limb
     */
    public float applyLimbPose(ModelCustomRenderer limb)
    {
        ModelTransform trans = this.pose.limbs.get(limb.limb.name);

        limb.applyTransform(trans == null ? ModelTransform.DEFAULT : trans);

        if (trans instanceof LimbProperties)
        {
            return 1F - ((LimbProperties) trans).fixed;
        }

        return 1F;
    }

    /**
     * Get renderer for an arm
     */
    public ModelCustomRenderer[] getRenderForArm(EnumHandSide side)
    {
        if (side == EnumHandSide.LEFT)
        {
            return this.left;
        }
        else if (side == EnumHandSide.RIGHT)
        {
            return this.right;
        }

        return null;
    }

    /**
     * Clean up resources used by this model
     */
    public void delete()
    {
        for (ModelCustomRenderer renderer : this.limbs)
        {
            renderer.delete();
        }
    }
}

==================================================

--- Файл №151 ---
Путь: main\java\mchorse\blockbuster\client\model\ModelCustomRenderer.java
--------------------
package mchorse.blockbuster.client.model;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.blockbuster.common.OrientedBB;
import mchorse.blockbuster_pack.morphs.CustomMorph.LimbProperties;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.metamorph.bodypart.BodyPart;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import javax.vecmath.*;

/**
 * Custom model renderer class
 *
 * This class extended only for purpose of storing more
 */
@SideOnly(Side.CLIENT)
public class ModelCustomRenderer extends ModelRenderer
{
    private static float lastBrightnessX;
    private static float lastBrightnessY;

    public ModelLimb limb;
    public ModelTransform trasnform;
    public ModelCustomRenderer parent;
    public ModelCustom model;

    public Vector3f cachedTranslation = new Vector3f();

    /**
     * At the moment no use -> would be useful to have realistic physics
     * for every limb, see robotics https://www.tu-chemnitz.de/informatik/KI/edu/robotik/ws2017/vel.kin.pdf
     */
    public Vector3f angularVelocity = new Vector3f();

    public float scaleX = 1;
    public float scaleY = 1;
    public float scaleZ = 1;

    /* Compied code from the ModelRenderer */
    protected boolean compiled;
    protected int displayList = -1;

    /* Stencil magic */
    public int stencilIndex = -1;
    public boolean stencilRendering = false;

    public Vector3f min;
    public Vector3f max;
    private Matrix4d worldTransformation = new Matrix4d();
    private Matrix4d modelView = new Matrix4d();

    public ModelCustomRenderer(ModelCustom model, int texOffX, int texOffY)
    {
        super(model, texOffX, texOffY);

        this.model = model;
    }

    /**
     * Initiate with limb and transform instances
     */
    public ModelCustomRenderer(ModelCustom model, ModelLimb limb, ModelTransform transform)
    {
        this(model, limb.texture[0], limb.texture[1]);

        this.limb = limb;
        this.trasnform = transform;
    }

    public Matrix4d getWorldTransformation()
    {
        return new Matrix4d(this.worldTransformation);
    }

    public Matrix4d getModelView()
    {
        return new Matrix4d(this.modelView);
    }

    public void setupStencilRendering(int stencilIndex)
    {
        this.stencilIndex = stencilIndex;
        this.stencilRendering = true;
    }

    /**
     * Apply transformations on this model renderer
     */
    public void applyTransform(ModelTransform transform)
    {
        this.trasnform = transform;

        float x = transform.translate[0];
        float y = transform.translate[1];
        float z = transform.translate[2];

        this.rotationPointX = x;
        this.rotationPointY = this.limb.parent.isEmpty() ? (-y + 24) : -y;
        this.rotationPointZ = -z;

        this.rotateAngleX = transform.rotate[0] * (float) Math.PI / 180;
        this.rotateAngleY = -transform.rotate[1] * (float) Math.PI / 180;
        this.rotateAngleZ = -transform.rotate[2] * (float) Math.PI / 180;

        this.scaleX = transform.scale[0];
        this.scaleY = transform.scale[1];
        this.scaleZ = transform.scale[2];
    }

    @Override
    public void addChild(ModelRenderer renderer)
    {
        if (renderer instanceof ModelCustomRenderer)
        {
            ((ModelCustomRenderer) renderer).parent = this;
        }

        super.addChild(renderer);
    }

    /**
     * Setup state for current limb 
     */
    protected void setup()
    {
        GlStateManager.color(this.limb.color[0], this.limb.color[1], this.limb.color[2], this.limb.opacity);

        lastBrightnessX = OpenGlHelper.lastBrightnessX;
        lastBrightnessY = OpenGlHelper.lastBrightnessY;

        if (!this.limb.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, lastBrightnessY);
        }

        if (this.trasnform instanceof LimbProperties)
        {
            LimbProperties limb = (LimbProperties) this.trasnform;
            GlStateManager.color(limb.color.r, limb.color.g, limb.color.b, limb.color.a);
            limb.applyGlow(lastBrightnessX, lastBrightnessY);
        }

        if (!this.limb.shading)
        {
            RenderHelper.disableStandardItemLighting();
        }

        if (this.limb.smooth)
        {
            GL11.glShadeModel(GL11.GL_SMOOTH);
        }
    }

    /**
     * Roll back the state to the way it was 
     */
    protected void disable()
    {
        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastBrightnessX, lastBrightnessY);
        
        if (!this.limb.shading)
        {
            GlStateManager.enableLighting();
            GlStateManager.enableLight(0);
            GlStateManager.enableLight(1);
            GlStateManager.enableColorMaterial();
        }

        if (this.limb.smooth)
        {
            GL11.glShadeModel(GL11.GL_FLAT);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(float scale)
    {
        if (!this.isHidden)
        {
            if (this.showModel)
            {
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0);

                if (!this.compiled)
                {
                    this.compileDisplayList(scale);
                }

                MatrixUtils.Transformation modelView = new MatrixUtils.Transformation();

                if (MatrixUtils.matrix != null)
                {
                    modelView = MatrixUtils.extractTransformations(MatrixUtils.matrix, MatrixUtils.readModelView(BodyPart.modelViewMatrix));
                }

                this.cachedTranslation.set(this.rotationPointX/16,(this.limb.parent.isEmpty() ? this.rotationPointY -24 : this.rotationPointY)/16,this.rotationPointZ/16);

                Matrix3f transformation = new Matrix3f(modelView.getRotation3f());

                transformation.mul(modelView.getScale3f());
                transformation.transform(this.cachedTranslation);

                if (this.parent!=null)
                {
                    this.cachedTranslation.add(this.parent.cachedTranslation);
                }

                if (this.model.current != null)
                {
                    this.cachedTranslation.add(this.model.current.cachedTranslation);
                    this.model.current.cachedTranslation.scale(0);
                }

                //currently deactivated, only use bodypart's translation as radius for angular stuff
                //BodyPart.cachedTranslation.set(this.cachedTranslation);

                GlStateManager.pushMatrix();
                GlStateManager.translate(this.offsetX, this.offsetY, this.offsetZ);

                if (this.rotateAngleX == 0.0F && this.rotateAngleY == 0.0F && this.rotateAngleZ == 0.0F)
                {
                    if (this.rotationPointX == 0.0F && this.rotationPointY == 0.0F && this.rotationPointZ == 0.0F)
                    {
                        GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
                        this.renderRenderer();

                        if (this.childModels != null)
                        {
                            for (int k = 0; k < this.childModels.size(); ++k)
                            {
                                this.childModels.get(k).render(scale);
                            }
                        }

                        updateObbs();
                    }
                    else
                    {
                        GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
                        GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
                        this.renderRenderer();

                        if (this.childModels != null)
                        {
                            for (int j = 0; j < this.childModels.size(); ++j)
                            {
                                this.childModels.get(j).render(scale);
                            }
                        }
                        
                        updateObbs();
                        GlStateManager.translate(-this.rotationPointX * scale, -this.rotationPointY * scale, -this.rotationPointZ * scale);
                    }
                }
                else
                {
                    GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);

                    if (this.rotateAngleZ != 0.0F)
                    {
                        GlStateManager.rotate(this.rotateAngleZ * (180F / (float) Math.PI), 0.0F, 0.0F, 1.0F);
                    }

                    if (this.rotateAngleY != 0.0F)
                    {
                        GlStateManager.rotate(this.rotateAngleY * (180F / (float) Math.PI), 0.0F, 1.0F, 0.0F);
                    }

                    if (this.rotateAngleX != 0.0F)
                    {
                        GlStateManager.rotate(this.rotateAngleX * (180F / (float) Math.PI), 1.0F, 0.0F, 0.0F);
                    }

                    GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
                    this.renderRenderer();

                    if (this.childModels != null)
                    {
                        for (int i = 0; i < this.childModels.size(); ++i)
                        {
                            this.childModels.get(i).render(scale);
                        }
                    }
                    
                    updateObbs();
                }
                
                GlStateManager.translate(-this.offsetX, -this.offsetY, -this.offsetZ);
                
                GlStateManager.popMatrix();
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
            }
        }
    }

    private void cacheMatrix(Matrix4d target)
    {
        try
        {
            Matrix4d parent = MatrixUtils.getCameraMatrix();
            parent.invert();
            parent.mul(parent, MatrixUtils.readModelViewDouble());
            target.set(parent);
        } catch (SingularMatrixException var9) {
        }
    }
    
    public void updateObbs()
    {
        if(this.model != null && this.model.current != null && this.model.current.orientedBBlimbs != null )
        {
            if(this.model.current.orientedBBlimbs.get(this.limb) != null)
            {
                for(OrientedBB obb : this.model.current.orientedBBlimbs.get(this.limb))
                {
                    if (MatrixUtils.matrix != null)
                    {
                        MatrixUtils.Transformation modelView = MatrixUtils.extractTransformations(MatrixUtils.matrix, MatrixUtils.readModelView(OrientedBB.modelView));

                        obb.rotation.set(modelView.getRotation3f());
                        obb.offset.set(modelView.getTranslation3f());
                        obb.scale.set(modelView.getScale3f());
                    }

                    obb.buildCorners();
                }
            }
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderWithRotation(float scale)
    {
        if (!this.isHidden)
        {
            if (this.showModel)
            {
                if (!this.compiled)
                {
                    this.compileDisplayList(scale);
                }

                GlStateManager.pushMatrix();
                GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);

                if (this.rotateAngleY != 0.0F)
                {
                    GlStateManager.rotate(this.rotateAngleY * (180F / (float) Math.PI), 0.0F, 1.0F, 0.0F);
                }

                if (this.rotateAngleX != 0.0F)
                {
                    GlStateManager.rotate(this.rotateAngleX * (180F / (float) Math.PI), 1.0F, 0.0F, 0.0F);
                }

                if (this.rotateAngleZ != 0.0F)
                {
                    GlStateManager.rotate(this.rotateAngleZ * (180F / (float) Math.PI), 0.0F, 0.0F, 1.0F);
                }

                GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
                this.renderRenderer();
                GlStateManager.popMatrix();
            }
        }
        
    }

    /**
     * Allows the changing of Angles after a box has been rendered
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void postRender(float scale)
    {
        if (this.parent != null)
        {
            this.parent.postRender(scale);
        }

        if (!this.isHidden)
        {
            if (this.showModel)
            {
                if (!this.compiled)
                {
                    this.compileDisplayList(scale);
                }

                if (this.rotateAngleX == 0.0F && this.rotateAngleY == 0.0F && this.rotateAngleZ == 0.0F)
                {
                    if (this.rotationPointX != 0.0F || this.rotationPointY != 0.0F || this.rotationPointZ != 0.0F)
                    {
                        GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);
                    }
                }
                else
                {
                    GlStateManager.translate(this.rotationPointX * scale, this.rotationPointY * scale, this.rotationPointZ * scale);

                    if (this.rotateAngleZ != 0.0F)
                    {
                        GlStateManager.rotate(this.rotateAngleZ * (180F / (float) Math.PI), 0.0F, 0.0F, 1.0F);
                    }

                    if (this.rotateAngleY != 0.0F)
                    {
                        GlStateManager.rotate(this.rotateAngleY * (180F / (float) Math.PI), 0.0F, 1.0F, 0.0F);
                    }

                    if (this.rotateAngleX != 0.0F)
                    {
                        GlStateManager.rotate(this.rotateAngleX * (180F / (float) Math.PI), 1.0F, 0.0F, 0.0F);
                    }
                }

                GlStateManager.scale(this.scaleX, this.scaleY, this.scaleZ);
            }
        }
    }

    /**
     * Compiles a GL display list for this model
     */
    protected void compileDisplayList(float scale)
    {
        this.displayList = GLAllocation.generateDisplayLists(1);
        GlStateManager.glNewList(this.displayList, 4864);
        BufferBuilder vertexbuffer = Tessellator.getInstance().getBuffer();

        for (int i = 0; i < this.cubeList.size(); ++i)
        {
            this.cubeList.get(i).render(vertexbuffer, scale);
        }

        GlStateManager.glEndList();
        this.compiled = true;
    }

    protected void renderRenderer()
    {
        this.cacheMatrix(this.worldTransformation);
        this.modelView = MatrixUtils.readModelViewDouble();

        if (this.limb.opacity <= 0 || this.trasnform instanceof LimbProperties && ((LimbProperties) this.trasnform).color.a <= 0)
        {
            return;
        }

        if (this.stencilRendering)
        {
            GL11.glStencilFunc(GL11.GL_ALWAYS, this.stencilIndex, -1);
            this.stencilRendering = false;
        }

        this.setup();
        this.renderDisplayList();
        this.disable();
    }

    /**
     * Render display list 
     */
    protected void renderDisplayList()
    {
        if (this.limb.is3D)
        {
            ModelExtrudedLayer.render3DLayer(this, RenderCustomModel.lastTexture);
        }
        else
        {
            GL11.glCallList(this.displayList);
        }
    }

    /**
     * DELET DIS 
     */
    public void delete()
    {
        if (this.displayList != -1)
        {
            GL11.glDeleteLists(this.displayList, 1);
        }
    }
}

==================================================

--- Файл №152 ---
Путь: main\java\mchorse\blockbuster\client\model\ModelOBJRenderer.java
--------------------
package mchorse.blockbuster.client.model;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.obj.MeshOBJ;
import mchorse.blockbuster.api.formats.obj.MeshesOBJ;
import mchorse.blockbuster.api.formats.obj.OBJMaterial;
import mchorse.blockbuster.api.formats.obj.OBJParser;
import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.blockbuster.client.textures.MipmapTexture;
import mchorse.mclib.client.render.VertexBuilder;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.ReflectionUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.opengl.GL11;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.Map;

/**
 * Like {@link ModelCustomRenderer}, this model renders 
 */
public class ModelOBJRenderer extends ModelCustomRenderer
{
    /**
     * Mesh containing the data about the model
     */
    public MeshesOBJ mesh;

    /**
     * Display lists 
     */
    public OBJDisplayList[] displayLists;

    /**
     * Custom materials texture 
     */
    public Map<String, ResourceLocation> materials;

    /**
     * Shape configurations
     */
    public List<ShapeKey> shapes;

    /**
     * Solid colored texture ID 
     */
    protected int solidColorTex = -1;

    public ModelOBJRenderer(ModelCustom model, ModelLimb limb, ModelTransform transform, MeshesOBJ mesh)
    {
        super(model, limb, transform);

        this.mesh = mesh;
        this.min = mesh.getMin();
        this.max = mesh.getMax();
    }

    /**
     * Instead of generating plain cube, this model renderer will 
     * generate mesh which was read by the {@link OBJParser}.
     */
    @Override
    protected void compileDisplayList(float scale)
    {
        if (this.mesh != null)
        {
            this.displayLists = new OBJDisplayList[this.mesh.meshes.size()];
            int index = 0;
            int texture = 0;
            int count = 0;

            /* Generate a texture based on solid colored materials */
            for (MeshOBJ mesh : this.mesh.meshes)
            {
                count += mesh.material != null && !mesh.material.useTexture ? 1 : 0;
            }

            if (count > 0)
            {
                ByteBuffer buffer = GLAllocation.createDirectByteBuffer(count * 4);
                texture = GL11.glGenTextures();

                for (MeshOBJ mesh : this.mesh.meshes)
                {
                    if (mesh.material != null && !mesh.material.useTexture)
                    {
                        buffer.put((byte) (mesh.material.r * 255));
                        buffer.put((byte) (mesh.material.g * 255));
                        buffer.put((byte) (mesh.material.b * 255));
                        buffer.put((byte) 255);
                    }
                }

                buffer.flip();

                /* For some reason, if there is no glTexParameter calls
                 * the texture becomes pure white */
                GlStateManager.bindTexture(texture);
                GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
                GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);

                GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, count, 1, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);
            }

            /* Generate display lists */
            int j = 0;
            int k = 0;

            for (MeshOBJ mesh : this.mesh.meshes)
            {
                OBJMaterial material = mesh.material;

                if (material != null && material.useTexture && material.texture != null)
                {
                    this.setupTexture(material);
                }

                int id = GLAllocation.generateDisplayLists(1);
                boolean hasColor = material != null && !mesh.material.useTexture;
                BufferBuilder renderer = Tessellator.getInstance().getBuffer();

                GlStateManager.glNewList(id, GL11.GL_COMPILE);
                renderer.begin(GL11.GL_TRIANGLES, VertexBuilder.getFormat(false, true, false, true));
                float texF = (j + 0.5F) / count;

                for (int i = 0, c = mesh.triangles; i < c; i++)
                {
                    float x = mesh.posData[i * 3] - this.limb.origin[0];
                    float y = -mesh.posData[i * 3 + 1] + this.limb.origin[1];
                    float z = mesh.posData[i * 3 + 2] - this.limb.origin[2];

                    float u = mesh.texData[i * 2];
                    float v = mesh.texData[i * 2 + 1];

                    float nx = mesh.normData[i * 3];
                    float ny = -mesh.normData[i * 3 + 1];
                    float nz = mesh.normData[i * 3 + 2];

                    if (!this.model.model.legacyObj)
                    {
                        x = -mesh.posData[i * 3] + this.limb.origin[0];
                        nx *= -1;
                    }

                    if (hasColor)
                    {
                        renderer.pos(x, y, z).tex(texF, 0.5F).normal(nx, ny, nz).endVertex();
                    }
                    else
                    {
                        renderer.pos(x, y, z).tex(u, v).normal(nx, ny, nz).endVertex();
                    }

                    if (i % 3 == 2)
                    {
                        VertexBuilder.calcTangent(renderer, false);
                    }
                }

                Tessellator.getInstance().draw();
                GlStateManager.glEndList();

                this.displayLists[index++] = new OBJDisplayList(k, id, texture, mesh, this.mesh.shapes == null);
                j += hasColor ? 1 : 0;
                k += 1;
            }

            this.compiled = true;
            this.solidColorTex = texture;

            /* Discard the mesh ONLY if there are no shapes */
            if (this.mesh.shapes == null)
            {
                this.mesh = null;
            }
        }
        else
        {
            super.compileDisplayList(scale);
        }
    }

    /**
     * Manually replace/setup a mipmapped texture 
     */
    private void setupTexture(OBJMaterial material)
    {
        TextureManager manager = Minecraft.getMinecraft().renderEngine;
        ITextureObject texture = manager.getTexture(material.texture);
        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(manager);

        if (texture != null && !(texture instanceof MipmapTexture))
        {
            GlStateManager.deleteTexture(map.remove(material.texture).getGlTextureId());
            texture = null;
        }

        if (texture == null)
        {
            try
            {
                /* Load texture manually */
                texture = new MipmapTexture(material.texture);
                texture.loadTexture(Minecraft.getMinecraft().getResourceManager());

                map.put(material.texture, texture);
            }
            catch (Exception e)
            {
                System.err.println("An error occurred during loading manually a mipmap'd texture '" + material.texture + "'");
                e.printStackTrace();
            }
        }

        boolean loaded = texture instanceof MipmapTexture;
        manager.bindTexture(material.texture);

        int mod = material.linear ? (loaded ? GL11.GL_LINEAR_MIPMAP_LINEAR : GL11.GL_LINEAR) : (loaded ? GL11.GL_NEAREST_MIPMAP_LINEAR : GL11.GL_NEAREST);
        int mag = material.linear ? GL11.GL_LINEAR : GL11.GL_NEAREST;

        GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, mod);
        GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, mag);
    }

    /**
     * Instead of rendering one default display list, this method 
     * renders the meshes  
     */
    @Override
    protected void renderDisplayList()
    {
        for (OBJDisplayList list : this.displayLists)
        {
            boolean hasColor = list.material != null && !list.material.useTexture;
            boolean hasTexture = list.material != null && list.material.useTexture;

            if (hasColor)
            {
                GlStateManager.bindTexture(list.texId);
            }

            if (hasTexture && list.material.texture != null)
            {
                ResourceLocation texture = list.material.texture;

                if (this.materials != null && this.materials.containsKey(list.material.name))
                {
                    texture = this.materials.get(list.material.name);
                }

                Minecraft.getMinecraft().renderEngine.bindTexture(texture);
            }

            list.render(this);

            if (hasColor || (hasTexture && list.material.texture != null))
            {
                RenderCustomModel.bindLastTexture();
            }
        }
    }

    @Override
    public void delete()
    {
        super.delete();

        if (this.displayLists != null)
        {
            for (OBJDisplayList list : this.displayLists)
            {
                if (list.id != -1)
                {
                    GL11.glDeleteLists(list.id, 1);
                }
            }
        }

        if (this.solidColorTex != -1)
        {
            GL11.glDeleteTextures(this.solidColorTex);
        }
    }

    public static class OBJDisplayList
    {
        public int index;
        public int id;
        public int texId;
        public OBJMaterial material;

        private MeshOBJ mesh;
        private MeshOBJ temporary;

        public OBJDisplayList(int index, int id, int texId, MeshOBJ mesh, boolean discard)
        {
            this.index = index;
            this.id = id;
            this.texId = texId;
            this.material = mesh.material;

            if (!discard)
            {
                this.mesh = mesh;
                this.temporary = new MeshOBJ(new float[mesh.posData.length], new float[mesh.texData.length], new float[mesh.normData.length]);
            }
        }

        public void render(ModelOBJRenderer renderer)
        {
            if (renderer.shapes != null && !renderer.shapes.isEmpty() && this.mesh != null)
            {
                BufferBuilder builder = Tessellator.getInstance().getBuffer();

                builder.begin(GL11.GL_TRIANGLES, VertexBuilder.getFormat(false, true, false, true));
                // float texF = (j + 0.5F) / count;

                for (int i = 0, c = this.mesh.triangles; i < c; i++)
                {
                    this.temporary.posData[i * 3] = this.mesh.posData[i * 3];
                    this.temporary.posData[i * 3 + 1] = this.mesh.posData[i * 3 + 1];
                    this.temporary.posData[i * 3 + 2] = this.mesh.posData[i * 3 + 2];
                    this.temporary.texData[i * 2] = this.mesh.texData[i * 2];
                    this.temporary.texData[i * 2 + 1] = this.mesh.texData[i * 2 + 1];
                    this.temporary.normData[i * 3] = this.mesh.normData[i * 3];
                    this.temporary.normData[i * 3 + 1] = this.mesh.normData[i * 3 + 1];
                    this.temporary.normData[i * 3 + 2] = this.mesh.normData[i * 3 + 2];
                }

                for (ShapeKey key : renderer.shapes)
                {
                    List<MeshOBJ> list = renderer.mesh.shapes.get(key.name);

                    if (list == null)
                    {
                        continue;
                    }

                    MeshOBJ mesh = list.get(this.index);
                    float factor = key.value;

                    if (mesh == null || this.temporary.triangles != mesh.triangles)
                    {
                        continue;
                    }

                    for (int i = 0, c = this.temporary.triangles; i < c; i++)
                    {
                        float x;
                        float y;
                        float z;
                        float u;
                        float v;
                        float nx = this.temporary.normData[i * 3];
                        float ny = this.temporary.normData[i * 3 + 1];
                        float nz = this.temporary.normData[i * 3 + 2];

                        if (key.relative)
                        {
                            /* final = temporary + lerp(initial, current, x) - initial */
                            x = this.temporary.posData[i * 3] + Interpolations.lerp(this.mesh.posData[i * 3], mesh.posData[i * 3], factor) - this.mesh.posData[i * 3];
                            y = this.temporary.posData[i * 3 + 1] + Interpolations.lerp(this.mesh.posData[i * 3 + 1], mesh.posData[i * 3 + 1], factor) - this.mesh.posData[i * 3 + 1];
                            z = this.temporary.posData[i * 3 + 2] + Interpolations.lerp(this.mesh.posData[i * 3 + 2], mesh.posData[i * 3 + 2], factor) - this.mesh.posData[i * 3 + 2];
                            u = this.temporary.texData[i * 2] + Interpolations.lerp(this.mesh.texData[i * 2], mesh.texData[i * 2], factor) - this.mesh.texData[i * 2];
                            v = this.temporary.texData[i * 2 + 1] + Interpolations.lerp(this.mesh.texData[i * 2 + 1], mesh.texData[i * 2 + 1], factor) - this.mesh.texData[i * 2 + 1];
                        }
                        else
                        {
                            x = Interpolations.lerp(this.temporary.posData[i * 3], mesh.posData[i * 3], factor);
                            y = Interpolations.lerp(this.temporary.posData[i * 3 + 1], mesh.posData[i * 3 + 1], factor);
                            z = Interpolations.lerp(this.temporary.posData[i * 3 + 2], mesh.posData[i * 3 + 2], factor);
                            u = Interpolations.lerp(this.temporary.texData[i * 2], mesh.texData[i * 2], factor);
                            v = Interpolations.lerp(this.temporary.texData[i * 2 + 1], mesh.texData[i * 2 + 1], factor);
                        }

                        if (
                            nx == mesh.normData[i * 3] &&
                            ny == mesh.normData[i * 3 + 1] &&
                            nz == mesh.normData[i * 3 + 2]
                        ) {
                            nx = Interpolations.lerp(nx, mesh.normData[i * 3], factor);
                            ny = Interpolations.lerp(ny, mesh.normData[i * 3 + 1], factor);
                            nz = Interpolations.lerp(nz, mesh.normData[i * 3 + 2], factor);
                        }

                        this.temporary.posData[i * 3] = x;
                        this.temporary.posData[i * 3 + 1] = y;
                        this.temporary.posData[i * 3 + 2] = z;
                        this.temporary.texData[i * 2] = u;
                        this.temporary.texData[i * 2 + 1] = v;
                        this.temporary.normData[i * 3] = nx;
                        this.temporary.normData[i * 3 + 1] = ny;
                        this.temporary.normData[i * 3 + 2] = nz;
                    }
                }

                for (int i = 0, c = this.temporary.triangles; i < c; i++)
                {
                    float x = this.temporary.posData[i * 3] - renderer.limb.origin[0];
                    float y = -this.temporary.posData[i * 3 + 1] + renderer.limb.origin[1];
                    float z = this.temporary.posData[i * 3 + 2] - renderer.limb.origin[2];

                    float u = this.temporary.texData[i * 2];
                    float v = this.temporary.texData[i * 2 + 1];

                    float nx = this.temporary.normData[i * 3];
                    float ny = -this.temporary.normData[i * 3 + 1];
                    float nz = this.temporary.normData[i * 3 + 2];

                    if (!renderer.model.model.legacyObj)
                    {
                        x = -this.temporary.posData[i * 3] + renderer.limb.origin[0];
                        nx *= -1;
                    }

                    if (false)
                    {
                        // renderer.pos(x, y, z).tex(texF, 0.5F).normal(nx, ny, nz).endVertex();
                    }
                    else
                    {
                        builder.pos(x, y, z).tex(u, v).normal(nx, ny, nz).endVertex();
                    }

                    if (i % 3 == 2)
                    {
                        VertexBuilder.calcTangent(builder, false);
                    }
                }

                Tessellator.getInstance().draw();
            }
            else
            {
                GL11.glCallList(this.id);
            }
        }
    }
}

==================================================

--- Файл №153 ---
Путь: main\java\mchorse\blockbuster\client\model\ModelVoxRenderer.java
--------------------
package mchorse.blockbuster.client.model;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.Mesh;
import mchorse.blockbuster.api.formats.obj.OBJParser;
import mchorse.blockbuster.api.formats.vox.MeshesVOX;
import mchorse.blockbuster.api.formats.vox.data.VoxTexture;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.mclib.client.render.VertexBuilder;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

/**
 * Like {@link ModelCustomRenderer}, this model renders 
 */
@SideOnly(Side.CLIENT)
public class ModelVoxRenderer extends ModelCustomRenderer
{
    public static final ResourceLocation VOXTEX = new ResourceLocation("blockbuster", "textures/dynamic_vox");

    /**
     * Mesh containing the data about the model
     */
    public MeshesVOX mesh;

    /**
     * Vox palette texture
     */
    public VoxTexture texture;

    public ModelVoxRenderer(ModelCustom model, ModelLimb limb, ModelTransform transform, MeshesVOX mesh)
    {
        super(model, limb, transform);

        this.mesh = mesh;
        this.min = mesh.getMin();
        this.max = mesh.getMax();
    }

    /**
     * Instead of generating plain cube, this model renderer will 
     * generate mesh which was read by the {@link OBJParser}.
     */
    @Override
    protected void compileDisplayList(float scale)
    {
        if (this.mesh != null)
        {
            BufferBuilder renderer = Tessellator.getInstance().getBuffer();

            /* Generate display list */
            Mesh mesh = this.mesh.mesh;
            {
                int id = GLAllocation.generateDisplayLists(1);

                GlStateManager.glNewList(id, GL11.GL_COMPILE);
                renderer.begin(GL11.GL_TRIANGLES, VertexBuilder.getFormat(false, true, false, true));

                for (int i = 0, c = mesh.triangles; i < c; i++)
                {
                    float x = (mesh.posData[i * 3] - this.limb.origin[0]) / 16F;
                    float y = -(mesh.posData[i * 3 + 1] - this.limb.origin[1]) / 16F;
                    float z = (mesh.posData[i * 3 + 2] - this.limb.origin[2]) / 16F;

                    float u = mesh.texData[i * 2];
                    float v = mesh.texData[i * 2 + 1];

                    float nx = mesh.normData[i * 3];
                    float ny = -mesh.normData[i * 3 + 1];
                    float nz = mesh.normData[i * 3 + 2];

                    renderer.pos(x, y, z).tex(u, v).normal(nx, ny, nz).endVertex();

                    if (i % 3 == 2)
                    {
                        VertexBuilder.calcTangent(renderer, false);
                    }
                }

                Tessellator.getInstance().draw();
                GlStateManager.glEndList();

                this.displayList = id;
            }

            this.texture = new VoxTexture(this.mesh.document.palette, this.limb.specular);

            this.compiled = true;
            this.mesh = null;
        }
        else
        {
            super.compileDisplayList(scale);
        }
    }

    /**
     * Instead of rendering one default display list, this method 
     * renders the meshes  
     */
    @Override
    protected void renderDisplayList()
    {
        if (this.texture != null)
        {
            TextureManager mgr = Minecraft.getMinecraft().getTextureManager();

            mgr.loadTexture(VOXTEX, this.texture);
            mgr.bindTexture(VOXTEX);
            GL11.glCallList(this.displayList);
            RenderCustomModel.bindLastTexture();
        }
    }

    @Override
    public void delete()
    {
        super.delete();

        if (this.texture != null)
        {
            this.texture.deleteGlTexture();
            this.texture = null;
        }
    }
}

==================================================

--- Файл №154 ---
Путь: main\java\mchorse\blockbuster\client\model\parsing\IModelCustom.java
--------------------
package mchorse.blockbuster.client.model.parsing;

import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;

/**
 * Custom model interface
 * 
 * This interface is used as a trait for models that extend from 
 * {@link ModelCustom} for {@link ModelParser} to inject the 
 * {@link ModelCustomRenderer}s in the public fields of the instance.
 */
public interface IModelCustom
{
    /**
     * Gets called when the {@link ModelParser} has finished generating its 
     * limbs.
     */
    public void onGenerated();
}

==================================================

--- Файл №155 ---
Путь: main\java\mchorse\blockbuster\client\model\parsing\ModelExporter.java
--------------------
package mchorse.blockbuster.client.model.parsing;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.ModelUtils;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.model.ModelBox;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.model.PositionTextureVertex;
import net.minecraft.client.model.TextureOffset;
import net.minecraft.client.model.TexturedQuad;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.passive.EntityTameable;
import net.minecraft.util.ResourceLocation;

/**
 * Model exporter
 *
 * Model exporter class is responsible for exporting Minecraft in-game models
 * based on the values of ModelBase ModelRenderer's ModelBoxes and given entity.
 */
public class ModelExporter
{
    private EntityLivingBase entity;
    private RenderLivingBase<EntityLivingBase> render;
    private int limbId;

    public ModelExporter(EntityLivingBase entity, RenderLivingBase<EntityLivingBase> render)
    {
        this.entity = entity;
        this.render = render;
    }

    private ModelBase getModel()
    {
        return this.render.getMainModel();
    }

    /**
     * Main method of this class.
     *
     * This method is responsible for exporting a JSON model based on the values
     * of given renderer's model and entity state.
     *
     * See private methods for more information about this export process.
     */
    public Model exportModel(String name)
    {
        Model data = new Model();

        this.limbId = 0;
        this.render.doRender(this.entity, 0, -420, 0, 0, 0);
        ModelBase model = this.getModel();

        this.setupProperties(data, model, name);
        Map<String, ModelRenderer> limbs = this.generateLimbs(data, model);

        /* Save standing, sleeping and flying poses */
        this.render.doRender(this.entity, 0, -420, 0, 0, 0);
        this.savePose("standing", data, limbs);
        this.savePose("sleeping", data, limbs);
        this.savePose("flying", data, limbs);

        /* Save sneaking pose */
        this.setSneaking(this.entity);

        if (this.render.getMainModel() instanceof ModelBiped)
        {
            ModelBiped biped = ((ModelBiped) this.render.getMainModel());
            boolean old = biped.isSneak;

            biped.isSneak = true;
            this.render.doRender(this.entity, 0, -420, 0, 0, 0);
            biped.isSneak = old;
        }
        else
        {
            this.render.doRender(this.entity, 0, -420, 0, 0, 0);
        }

        this.savePose("sneaking", data, limbs);

        this.setDefaultTexture(data);

        return data;
    }

    public String exportJSON(String name)
    {
        return ModelUtils.toJson(this.exportModel(name));
    }

    /**
     * Tries to set default texture
     */
    @SuppressWarnings({"rawtypes", "unchecked"})
    private void setDefaultTexture(Model data)
    {
        Class<?> clazz = Render.class;

        for (Method method : clazz.getDeclaredMethods())
        {
            Class[] args = method.getParameterTypes();

            boolean hasEntityArg = args.length == 1 && args[0].isAssignableFrom(Entity.class);
            boolean returnsRL = method.getReturnType().isAssignableFrom(ResourceLocation.class);

            if (hasEntityArg && returnsRL)
            {
                try
                {
                    method.setAccessible(true);
                    data.defaultTexture = (ResourceLocation) method.invoke(this.render, this.entity);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }

                break;
            }
        }
    }

    /**
     * Set entity sneaking
     */
    private void setSneaking(EntityLivingBase entity)
    {
        if (entity instanceof EntityTameable)
        {
            ((EntityTameable) entity).setSitting(true);
        }
        else
        {
            entity.setSneaking(true);
        }
    }

    /**
     * Save pose transformations for every limb
     */
    private void savePose(String poseName, Model data, Map<String, ModelRenderer> limbs)
    {
        ModelPose pose = new ModelPose();

        /* Set size */
        float width = this.entity.width;
        float height = this.entity.height;

        pose.size = new float[] {width, height, width};

        /* Allocate transforms */
        for (Map.Entry<String, ModelRenderer> entry : limbs.entrySet())
        {
            String key = entry.getKey();
            ModelRenderer renderer = entry.getValue();
            ModelTransform transform = new ModelTransform();

            float PI = (float) Math.PI;

            float rx = renderer.rotateAngleX * 180 / PI;
            float ry = renderer.rotateAngleY * 180 / PI;
            float rz = renderer.rotateAngleZ * 180 / PI;

            float x = renderer.rotationPointX;
            float y = renderer.rotationPointY;
            float z = renderer.rotationPointZ;

            if (data.limbs.get(key).parent.isEmpty())
            {
                x *= -1;
                y = -(y - 24);
                z *= -1;
            }
            else
            {
                x *= -1;
                y *= -1;
                z *= -1;
            }

            transform.rotate = new float[] {rx, ry, rz};
            transform.translate = new float[] {x, y, z};

            pose.limbs.put(key, transform);
        }

        data.poses.put(poseName, pose);
    }

    /**
     * Setup main properties for given model
     */
    private void setupProperties(Model data, ModelBase model, String name)
    {
        data.name = name;
        data.texture = new int[] {model.textureWidth, model.textureHeight};
    }

    /**
     * Generate limbs from the given model
     */
    private Map<String, ModelRenderer> generateLimbs(Model data, ModelBase model)
    {
        Map<String, ModelRenderer> limbs = new HashMap<String, ModelRenderer>();

        int width = 0;
        int height = 0;

        for (ModelRenderer renderer : this.getModelRenderers(model))
        {
            this.generateLimbs(limbs, renderer, data, model, "");

            width = Math.max(width, (int) renderer.textureWidth);
            height = Math.max(height, (int) renderer.textureHeight);
        }

        /* Some bastard decided that it was a smart idea to define two variables
         * in Model's constructor and inject those values directly into the
         * ModelRenderer via setTextureSize() instead of setting model's
         * properties textureWidth and textureHeight. Therefore ModelBase
         * properties has misleading result.
         *
         * This is a workaround to inject the right texture size for exporting
         * JSON model. Basically, if the texture size from JSON model doesn't
         * correspond with values that has been set from ModelRenderers,
         * it uses the greater value that was got from ModelRenderers.
         *
         * Zero check for width and height is just in case.
         *
         * See ModelIronGolem for more information. I hope it wasn't jeb.
         */
        if (data.texture[0] != width || data.texture[1] != height && width != 0 && height != 0)
        {
            data.texture = new int[] {width, height};
        }

        return limbs;
    }

    /**
     * Recursive method for generating limbs 
     */
    private void generateLimbs(Map<String, ModelRenderer> limbs, ModelRenderer renderer, Model data, ModelBase model, String parentName)
    {
        int j = 0;
        String firstName = "";

        for (ModelBox box : renderer.cubeList)
        {
            ModelLimb limb = new ModelLimb();
            String boxName = box.boxName != null ? box.boxName : "";
            String name = boxName.isEmpty() ? "limb_" + this.limbId : boxName;

            if (j == 0)
            {
                limb.mirror = renderer.mirror;
                limb.parent = parentName;
                firstName = name;
                limbs.put(name, renderer);
            }
            else
            {
                limb.parent = firstName;
            }

            limb.size = this.getModelSize(box);
            limb.texture = this.getModelOffset(box, renderer, model);
            limb.anchor = this.getAnchor(box, limb.size);

            data.limbs.put(name, limb);

            this.limbId++;
            j++;
        }

        if (renderer.childModels == null)
        {
            return;
        }

        for (ModelRenderer child : renderer.childModels)
        {
            this.generateLimbs(limbs, child, data, model, firstName);
        }
    }

    /**
     * Compute model size based on the box in the model renderer
     */
    private int[] getModelSize(ModelBox box)
    {
        int w = (int) (box.posX2 - box.posX1);
        int h = (int) (box.posY2 - box.posY1);
        int d = (int) (box.posZ2 - box.posZ1);

        return new int[] {w, h, d};
    }

    /**
     * Get texture offset of the model based on its box
     */
    private int[] getModelOffset(ModelBox box, ModelRenderer renderer, ModelBase model)
    {
        TextureOffset offset = model.getTextureOffset(box.boxName);

        if (offset != null)
        {
            return new int[] {offset.textureOffsetX, offset.textureOffsetY};
        }

        int[] zero = new int[] {0, 0};

        Field field = this.getFieldByType(TexturedQuad[].class, ModelBox.class);
        TexturedQuad[] quads;

        field.setAccessible(true);

        try
        {
            quads = (TexturedQuad[]) field.get(box);
        }
        catch (Exception e)
        {
            e.printStackTrace();

            return zero;
        }

        /* Getting the minimum */
        float minX = 1.0F;
        float minY = 1.0F;

        for (TexturedQuad quad : quads)
        {
            for (PositionTextureVertex vertex : quad.vertexPositions)
            {
                minX = Math.min(vertex.texturePositionX, minX);
                minY = Math.min(vertex.texturePositionY, minY);
            }
        }

        minX *= renderer.textureWidth;
        minY *= renderer.textureHeight;

        return new int[] {(int) minX, (int) minY};
    }

    /**
     * Compute anchor based on the renderer
     */
    private float[] getAnchor(ModelBox box, int[] size)
    {
        float w = size[0] != 0 ? -box.posX1 / size[0] : 0;
        float h = size[1] != 0 ? -box.posY1 / size[1] : 0;
        float d = size[2] != 0 ? -box.posZ1 / size[2] : 0;

        return new float[] {w, h, d};
    }

    /**
     * Get all model renderers that given model has (even if that is an array
     * of ModelRenderers)
     */
    private List<ModelRenderer> getModelRenderers(ModelBase model)
    {
        List<ModelRenderer> renderers = new ArrayList<ModelRenderer>();

        Class<?> rClass = ModelRenderer.class;
        Class<?> aRClass = ModelRenderer[].class;

        for (Field field : getInheritedFields(model.getClass()))
        {
            Class<?> type = field.getType();

            if (!type.isAssignableFrom(rClass) && !type.isAssignableFrom(aRClass)) continue;
            if (!field.isAccessible()) field.setAccessible(true);

            try
            {
                if (type.isAssignableFrom(rClass))
                {
                    ModelRenderer renderer = (ModelRenderer) field.get(model);

                    if (renderer != null && renderers.indexOf(renderer) == -1)
                    {
                        renderers.add(renderer);
                    }
                }
                else if (type.isAssignableFrom(aRClass))
                {
                    ModelRenderer[] moreRenderers = (ModelRenderer[]) field.get(model);

                    for (ModelRenderer renderer : moreRenderers)
                    {
                        if (renderer != null && renderers.indexOf(renderer) == -1)
                        {
                            renderers.add(renderer);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();

                continue;
            }
        }

        /* Eliminate any children model renderers */
        List<ModelRenderer> roots = new ArrayList<ModelRenderer>();

        for (ModelRenderer child : renderers)
        {
            boolean isChild = false;

            for (ModelRenderer parent : renderers)
            {
                if (parent.childModels != null && parent.childModels.contains(child))
                {
                    isChild = true;

                    break;
                }
            }

            if (!isChild)
            {
                roots.add(child);
            }
        }

        return roots;
    }

    /**
     * Get first field that corresponds to given class type in given class
     * subject
     */
    private Field getFieldByType(Class<?> type, Class<?> subject)
    {
        for (Field field : subject.getDeclaredFields())
        {
            if (field.getType().equals(type)) return field;
        }

        return null;
    }

    /**
     * From StackOverflow
     */
    public static List<Field> getInheritedFields(Class<?> type)
    {
        List<Field> fields = new ArrayList<Field>();

        for (Class<?> c = type; c != null; c = c.getSuperclass())
        {
            fields.addAll(Arrays.asList(c.getDeclaredFields()));
        }

        return fields;
    }
}

==================================================

--- Файл №156 ---
Путь: main\java\mchorse\blockbuster\client\model\parsing\ModelExporterOBJ.java
--------------------
package mchorse.blockbuster.client.model.parsing;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.vecmath.Matrix3f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelBox;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.model.PositionTextureVertex;
import net.minecraft.client.model.TexturedQuad;
import net.minecraft.util.math.Vec3d;

/**
 * Model exporter OBJ class
 * 
 * <i>slaps roof of ModelExporterOBJ</i> this bad boy can convert so much 
 * OBJ models from Blockbuster JSON models.
 */
public class ModelExporterOBJ
{
    private Model data;
    private ModelPose pose;

    public ModelExporterOBJ(Model data, ModelPose pose)
    {
        this.data = data;
        this.pose = pose;
    }

    /**
     * Export given model into OBJ string 
     */
    public String export(String modelName)
    {
        String obj = "# OBJ generated by Blockbuster (version " + Blockbuster.VERSION + ")\n\nmtllib " + modelName + ".mtl\nusemtl default\n";

        Map<ModelLimb, Mesh> meshes = new HashMap<>();
        this.generateMeshes(meshes);

        return obj + this.generateBody(meshes);
    }

    /**
     * Find texture quads field in {@link ModelBox} class.
     */
    private Field findField()
    {
        Field field = null;

        for (Field f : ModelBox.class.getDeclaredFields())
        {
            if (f.getType().equals(TexturedQuad[].class))
            {
                field = f;
                field.setAccessible(true);

                return field;
            }
        }

        return null;
    }

    /**
     * Prepare and generate meshes. This method is responsible for 
     * turning model's limbs into boxes and also preparing 
     * transformation matrices for actual generation of OBJ geometry.
     */
    private void generateMeshes(Map<ModelLimb, Mesh> meshes)
    {
        ModelBase base = new ModelBase()
        {};

        base.textureWidth = this.data.texture[0];
        base.textureHeight = this.data.texture[1];

        for (ModelLimb limb : this.data.limbs.values())
        {
            ModelTransform transform = this.pose.limbs.get(limb.name);

            if (transform == null)
            {
                transform = ModelTransform.DEFAULT;
            }

            Matrix4f mat = new Matrix4f();
            mat.setIdentity();
            Matrix3f rotScale = new Matrix3f();
            rotScale.setIdentity();
            mat.setTranslation(new Vector3f(transform.translate));
            mat.m23 = -mat.m23;
            mat.m13 = -mat.m13;

            Matrix3f x = new Matrix3f();
            rotScale.m00 = transform.scale[0];
            rotScale.m11 = transform.scale[1];
            rotScale.m22 = transform.scale[2];

            Matrix3f rot = new Matrix3f();
            rot.setIdentity();
            x.setIdentity();
            x.rotZ((float) Math.toRadians(-transform.rotate[2]));
            rot.mul(x);
            x.setIdentity();
            x.rotY((float) Math.toRadians(-transform.rotate[1]));
            rot.mul(x);
            x.setIdentity();
            x.rotX((float) Math.toRadians(transform.rotate[0]));
            rot.mul(x);

            rotScale.mul(rot);
            mat.setRotationScale(rotScale);

            int w = limb.size[0];
            int h = limb.size[1];
            int d = limb.size[2];

            float ox = 1 - limb.anchor[0];
            float oy = limb.anchor[1];
            float oz = limb.anchor[2];

            ModelBox box = new ModelBox(new ModelRenderer(base), limb.texture[0], limb.texture[1], -w * ox, -h * oy, -d * oz, w, h, d, limb.sizeOffset, limb.mirror);

            meshes.put(limb, new Mesh(box, mat, rot));
        }
    }

    /**
     * Generate body of the OBJ file based on given prepared meshes
     */
    private String generateBody(Map<ModelLimb, Mesh> meshes)
    {
        String output = "";
        Field field = this.findField();
        /* Count of vertices, normals and UVs indices */
        int v = 1;
        int u = 1;
        int n = 1;

        Matrix4f scale = new Matrix4f();
        scale.setIdentity();
        scale.rotZ((float) Math.PI);
        scale.setScale(1 / 16F);

        for (Map.Entry<ModelLimb, Mesh> entry : meshes.entrySet())
        {
            TexturedQuad[] quads = null;
            ModelLimb limb = entry.getKey();
            Mesh mesh = entry.getValue();

            try
            {
                quads = (TexturedQuad[]) field.get(mesh.box);
            }
            catch (Exception e)
            {}

            /* Technically shouldn't ever happen, but just in case */
            if (quads == null) continue;

            Matrix4f mat = new Matrix4f(mesh.mat);
            Matrix3f rot = new Matrix3f(mesh.rot);

            if (!limb.parent.isEmpty())
            {
                ModelLimb parent = this.data.limbs.get(limb.parent);

                while (parent != null)
                {
                    Mesh parentMesh = meshes.get(parent);
                    Matrix4f mat2 = new Matrix4f(parentMesh.mat);
                    Matrix3f rot2 = new Matrix3f(parentMesh.rot);

                    mat2.mul(mat);
                    rot2.mul(rot);

                    mat = mat2;
                    rot = rot2;

                    parent = this.data.limbs.get(parent.parent);
                }
            }

            /* Downscale geometry and flip vertically */
            Matrix4f m = new Matrix4f(scale);
            m.mul(mat);
            mat = m;

            /* Flip vertically normals */
            Matrix3f r = new Matrix3f();
            r.setIdentity();
            r.m11 = -1;
            r.mul(rot);
            rot = r;

            output += "o " + limb.name.replaceAll("\\s", "_") + "\n";

            String vertices = "";
            String normals = "";
            String uvs = "";
            String faces = "";

            /* List of already added vectors, so we could make connected
             * vertices, instead of separate faces (i.e. to simplify the work 
             * on the modeler to do the remove doubles on every limb) */
            List<Vector4f> vecs = new ArrayList<Vector4f>();

            for (TexturedQuad quad : quads)
            {
                /* Calculating normal as done in TexturedQuad */
                Vec3d v1 = quad.vertexPositions[1].vector3D.subtractReverse(quad.vertexPositions[0].vector3D);
                Vec3d v2 = quad.vertexPositions[1].vector3D.subtractReverse(quad.vertexPositions[2].vector3D);
                Vec3d v3 = v2.crossProduct(v1).normalize();
                Vector3f normal = new Vector3f((float) v3.x, (float) v3.y, (float) v3.z);
                String face = "f ";

                rot.transform(normal);
                normal.normalize();
                normals += String.format("vn %.4f %.4f %.4f\n", normal.x, normal.y, normal.z);

                /* We're iterating backward, because it's important for 
                 * normal generation. */
                for (int i = 0; i < quad.nVertices; i++)
                {
                    PositionTextureVertex vx = quad.vertexPositions[i];
                    Vector4f vec = new Vector4f((float) vx.vector3D.x, (float) vx.vector3D.y, (float) vx.vector3D.z, 1);

                    mat.transform(vec);

                    /* Find vector index */
                    int vi = vecs.indexOf(vec);

                    if (vi == -1)
                    {
                        /* If vector index is not found, add it and write it */
                        vertices += String.format("v %.4f %.4f %.4f\n", vec.x, vec.y, vec.z);
                        vi = vecs.size();
                        vecs.add(vec);
                    }

                    uvs += String.format("vt %f %f\n", vx.texturePositionX, 1 - vx.texturePositionY);
                    face += (v + vi) + "/" + u + "/" + n + " ";

                    u++;
                }

                faces += face.trim() + "\n";
                n++;
            }

            v += vecs.size();

            output += vertices + normals + uvs + faces;
        }

        return output;
    }

    /**
     * Temporary mesh structure which is used internally within this 
     * class for generating an OBJ
     */
    public static class Mesh
    {
        public ModelBox box;
        public Matrix4f mat;
        public Matrix3f rot;

        public Mesh(ModelBox box, Matrix4f mat, Matrix3f rot)
        {
            this.box = box;
            this.mat = mat;
            this.rot = rot;
        }
    }
}

==================================================

--- Файл №157 ---
Путь: main\java\mchorse\blockbuster\client\model\parsing\ModelExtrudedLayer.java
--------------------
package mchorse.blockbuster.client.model.parsing;

import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.mclib.McLib;
import mchorse.mclib.client.render.VertexBuilder;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.resources.MultiResourceLocation;
import mchorse.mclib.utils.resources.MultiskinThread;
import mchorse.mclib.utils.resources.TextureProcessor;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.renderer.vertex.VertexFormat;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.opengl.GL11;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Model extruded layer class
 * 
 * This baby is responsible for making wonders. Basically, it allows 
 * to render extruded layers based on the texture. 
 *
 * TODO: Clean up and make sure the code isn't confusing (axes and coordinates)
 */
public class ModelExtrudedLayer
{
    public static final byte TOP_BIT = 0b1;
    public static final byte BOTTOM_BIT = 0b10;
    public static final byte FRONT_BIT = 0b100;
    public static final byte BACK_BIT = 0b1000;
    public static final byte LEFT_BIT = 0b10000;
    public static final byte RIGHT_BIT = 0b100000;

    /**
     * Storage for extruded layers 
     */
    protected static Map<ModelCustomRenderer, Map<ResourceLocation, Integer>> layers = new HashMap<>();

    /**
     * Cached textures 
     */
    protected static Map<ResourceLocation, CachedImage> images = new HashMap<>();

    public static void forceReload(ResourceLocation location, BufferedImage image)
    {
        CachedImage cached = new CachedImage(image);

        cached.timer = Integer.MAX_VALUE;
        images.put(location, cached);
    }

    /**
     * Render the extruded 3D layer. If extruded layer wasn't generated 
     * before, it will generate it.
     */
    public static void render3DLayer(ModelCustomRenderer renderer, ResourceLocation texture)
    {
        Map<ResourceLocation, Integer> map = layers.get(renderer);
        int id = -1;

        if (map == null)
        {
            map = new HashMap<>();
            layers.put(renderer, map);
        }

        if (!map.containsKey(texture))
        {
            generateLayer(renderer, texture, map);
        }

        Integer callId = map.get(texture);

        if (callId != null)
        {
            id = callId;
        }

        if (id != -1)
        {
            // GlStateManager.disableTexture2D();
            // GL11.glPolygonMode(GL11.GL_FRONT_AND_BACK, GL11.GL_LINE);
            GL11.glCallList(id);
            // GL11.glPolygonMode(GL11.GL_FRONT_AND_BACK, GL11.GL_FILL);
            // GlStateManager.enableTexture2D();
        }
    }

    /**
     * Tick the cache to clean up the data
     */
    public static void tickCache()
    {
        /* Clean up cache */
        if (!images.isEmpty())
        {
            Iterator<CachedImage> it = images.values().iterator();

            while (it.hasNext())
            {
                CachedImage image = it.next();

                if (image.timer <= 0)
                {
                    image.image.flush();
                    it.remove();
                }

                image.timer -= 1;
            }
        }
    }

    /**
     * Generate extruded layer call list for given limb renderer and 
     * texture location
     */
    private static void generateLayer(ModelCustomRenderer renderer, ResourceLocation texture, Map<ResourceLocation, Integer> map)
    {
        int id = -1;

        try
        {
            CachedImage image = images.get(texture);

            if (image == null)
            {
                /* Multi-threaded multi-skins freak out when gerResource(ResourceLocation) gets called */
                if (texture instanceof MultiResourceLocation && McLib.multiskinMultiThreaded.get())
                {
                    MultiskinThread.add((MultiResourceLocation) texture);

                    return;
                }

                image = new CachedImage(ImageIO.read(Minecraft.getMinecraft().getResourceManager().getResource(texture).getInputStream()));
                images.put(texture, image);
            }

            if (image.timer > 20)
            {
                image.timer = 20;
            }

            Chunk chunk = fillChunk(image.image, renderer);

            if (chunk.stats > 0)
            {
                id = generateDisplayList(chunk, renderer);
            }
        }
        catch (Exception e)
        {
            System.err.println("An error occurred during construction of extruded 3D layer for texture " + texture + " and limb " + renderer.limb.name);
            e.printStackTrace();
        }

        map.put(texture, id);
    }

    /**
     * Fill chunk based on given texture
     * 
     * Basically, this method is responsible for filling the chunk data
     * with outer voxels. The voxels are getting filled based on the 
     * limb's offset and Minecraft's cube mapping.
     * 
     * There is a lot of copy-paste code since I'm not sure 
     */
    private static Chunk fillChunk(BufferedImage image, ModelCustomRenderer renderer)
    {
        final int threshold = 0x80;

        /* Extrude factor */
        int ef = renderer.model.model.extrudeMaxFactor;
        int stepX = (int) (image.getWidth() / renderer.textureWidth);
        int stepY = (int) (image.getHeight() / renderer.textureHeight);
        int oStepX = stepX;
        int oStepY = stepY;

        if (ef > 1)
        {
            ef = Math.min(ef, Math.min(stepX, stepY));

            if (stepX > 1) stepX = (int) (image.getWidth() / (renderer.textureWidth * ef));
            if (stepY > 1) stepY = (int) (image.getHeight() / (renderer.textureHeight * ef));
        }

        /* Extrude Factor Inwards */
        int efi = MathUtils.clamp(renderer.model.model.extrudeInwards, 1, ef);
        int w = renderer.limb.size[0];
        int h = renderer.limb.size[1];
        int d = renderer.limb.size[2];

        Chunk chunk = new Chunk(w, h, d, ef);

        int offsetX = renderer.limb.texture[0];
        int offsetY = renderer.limb.texture[1];

        /* Top & bottom */
        int x = (offsetX + d) * oStepX;
        int y = offsetY * oStepY;

        for (int i = 0; i < chunk.w; i++)
        {
            for (int j = 0; j < chunk.d; j++)
            {
                int alpha = image.getRGB(x + i * stepX, y + j * stepY) >> 24 & 0xff;

                if (alpha >= threshold)
                {
                    for (int k = 0; k < efi; k ++)
                    {
                        chunk.setBlockBit(i, chunk.h - 1 - k, j, TOP_BIT);
                    }
                }
            }
        }

        x = (offsetX + d + w) * oStepX;
        y = offsetY * oStepY;

        for (int i = 0; i < chunk.w; i++)
        {
            for (int j = 0; j < chunk.h; j++)
            {
                int alpha = image.getRGB(x + i * stepX, y + j * stepY) >> 24 & 0xff;

                if (alpha >= threshold)
                {
                    for (int k = 0; k < efi; k ++)
                    {
                        chunk.setBlockBit(i, k, j, BOTTOM_BIT);
                    }
                }
            }
        }

        /* Front & back */
        x = (offsetX + d) * oStepX;
        y = (offsetY + d) * oStepY;

        for (int i = 0; i < chunk.w; i++)
        {
            for (int j = 0; j < chunk.h; j++)
            {
                int alpha = image.getRGB(x + i * stepX, y + j * stepY) >> 24 & 0xff;

                if (alpha >= threshold)
                {
                    for (int k = 0; k < efi; k ++)
                    {
                        chunk.setBlockBit(i, chunk.h - j - 1, chunk.d - 1 - k, FRONT_BIT);
                    }
                }
            }
        }

        x = (offsetX + d * 2 + w) * oStepX;
        y = (offsetY + d) * oStepY;

        for (int i = 0; i < chunk.w; i++)
        {
            for (int j = 0; j < chunk.h; j++)
            {
                int alpha = image.getRGB(x + i * stepX, y + j * stepY) >> 24 & 0xff;

                if (alpha >= threshold)
                {
                    for (int k = 0; k < efi; k ++)
                    {
                        chunk.setBlockBit(chunk.w - i - 1, chunk.h - j - 1, k, BACK_BIT);
                    }
                }
            }
        }

        /* Left & right */
        x = offsetX * oStepX;
        y = (offsetY + d) * oStepY;

        for (int i = 0; i < chunk.d; i++)
        {
            for (int j = 0; j < chunk.h; j++)
            {
                int alpha = image.getRGB(x + i * stepX, y + j * stepY) >> 24 & 0xff;

                if (alpha >= threshold)
                {
                    for (int k = 0; k < efi; k ++)
                    {
                        chunk.setBlockBit(k, chunk.h - j - 1, i, LEFT_BIT);
                    }
                }
            }
        }

        x = (offsetX + d + w) * oStepX;
        y = (offsetY + d) * oStepY;

        for (int i = 0; i < chunk.d; i++)
        {
            for (int j = 0; j < chunk.h; j++)
            {
                int xx = x + i * stepX;
                int yy = y + j * stepY;

                int color = image.getRGB(xx, yy);
                int alpha = color >> 24 & 0xff;

                if (alpha >= threshold)
                {
                    for (int k = 0; k < efi; k ++)
                    {
                        chunk.setBlockBit(chunk.w - 1 - k, chunk.h - j - 1, chunk.d - i - 1, RIGHT_BIT);
                    }
                }
            }
        }

        return chunk;
    }

    /**
     * Generate display list out of chunk 
     */
    private static int generateDisplayList(Chunk chunk, ModelCustomRenderer renderer)
    {
        int id = GLAllocation.generateDisplayLists(1);
        GlStateManager.glNewList(id, 4864);
        generateGeometry(chunk, renderer);
        GlStateManager.glEndList();

        return id;
    }

    /**
     * Generate geometry based on given chunk. This method is basically 
     * using stupid (instead of greedy) voxel meshing in order to 
     * compile the geometry.
     *
     * TODO: Fix UV mapping on non primary sides to match the edges (for high-res textures, primarily)
     */
    private static void generateGeometry(Chunk chunk, ModelCustomRenderer renderer)
    {
        BufferBuilder buffer = Tessellator.getInstance().getBuffer();

        int ef = chunk.ef;
        int w = renderer.limb.size[0] * ef;
        int h = renderer.limb.size[1] * ef;
        int d = renderer.limb.size[2] * ef;
        float f = 1F / 16F / ef;
        float so = renderer.limb.sizeOffset * ef;

        float tw = renderer.textureWidth * ef;
        float th = renderer.textureHeight * ef;
        int offsetX = renderer.limb.texture[0] * ef;
        int offsetY = renderer.limb.texture[1] * ef;
        boolean mirror = renderer.limb.mirror;
        Offset off = new Offset(0, 0);
        Offset offmax = new Offset(0, 0);

        buffer.begin(GL11.GL_QUADS, VertexBuilder.getFormat(false, true, false, true));

        for (int x = 0; x < chunk.w; x++)
        {
            for (int y = 0; y < chunk.h; y++)
            {
                for (int z = 0; z < chunk.d; z++)
                {
                    int blockX = mirror ? w - x - 1 : x;
                    byte block = chunk.getBlock(blockX, y, z);

                    if (block == 0)
                    {
                        continue;
                    }

                    float sw = w + so * 2;
                    float sh = h + so * 2;
                    float sd = d + so * 2;

                    float aX = -renderer.limb.anchor[0] * sw + sw;
                    float aY = -renderer.limb.anchor[1] * sh + sh;
                    float aZ = -renderer.limb.anchor[2] * sd + sd;

                    /* Minimum and maximum */
                    float mnx = ((x + (mirror ? 1 : 0)) * (sw / (float) w) - aX) * f;
                    float mmx = ((x + (mirror ? 0 : 1)) * (sw / (float) w) - aX) * f;
                    float mny = -(y * (sh / (float) h) - aY) * f;
                    float mmy = -((y + 1) * (sh / (float) h) - aY) * f;
                    float mnz = -(z * (sd / (float) d) - aZ) * f;
                    float mmz = -((z + 1) * (sd / (float) d) - aZ) * f;

                    /* Top & Bottom */
                    if (!chunk.hasBlock(blockX, y + 1, z))
                    {
                        if (!calculateOffset(off, offmax, (byte) (block & TOP_BIT), offsetX, offsetY, w, h, d, blockX, y, z, tw, th))
                        {
                            calculateOffset(off, offmax, block, offsetX, offsetY, w, h, d, blockX, y, z, tw, th);
                        }

                        buffer.pos(mnx, mmy, mnz).tex(off.x, off.y).normal(0, -1, 0).endVertex();
                        buffer.pos(mnx, mmy, mmz).tex(off.x, offmax.y).normal(0, -1, 0).endVertex();
                        buffer.pos(mmx, mmy, mmz).tex(offmax.x, offmax.y).normal(0, -1, 0).endVertex();
                        buffer.pos(mmx, mmy, mnz).tex(offmax.x, off.y).normal(0, -1, 0).endVertex();
                    }

                    if (!chunk.hasBlock(blockX, y - 1, z))
                    {
                        if (!calculateOffset(off, offmax, (byte) (block & BOTTOM_BIT), offsetX, offsetY, w, h, d, blockX, y, z, tw, th))
                        {
                            calculateOffset(off, offmax, block, offsetX, offsetY, w, h, d, blockX, y, z, tw, th);
                        }

                        buffer.pos(mnx, mny, mnz).tex(off.x, off.y).normal(0, 1, 0).endVertex();
                        buffer.pos(mmx, mny, mnz).tex(offmax.x, off.y).normal(0, 1, 0).endVertex();
                        buffer.pos(mmx, mny, mmz).tex(offmax.x, offmax.y).normal(0, 1, 0).endVertex();
                        buffer.pos(mnx, mny, mmz).tex(off.x, offmax.y).normal(0, 1, 0).endVertex();
                    }

                    /* Front & back */
                    if (!chunk.hasBlock(blockX, y, z + 1))
                    {
                        if (!calculateOffset(off, offmax, (byte) (block & FRONT_BIT), offsetX, offsetY, w, h, d, blockX, y, z, tw, th))
                        {
                            calculateOffset(off, offmax, block, offsetX, offsetY, w, h, d, blockX, y, z, tw, th);
                        }

                        buffer.pos(mnx, mmy, mmz).tex(off.x, off.y).normal(0, 0, -1).endVertex();
                        buffer.pos(mnx, mny, mmz).tex(off.x, offmax.y).normal(0, 0, -1).endVertex();
                        buffer.pos(mmx, mny, mmz).tex(offmax.x, offmax.y).normal(0, 0, -1).endVertex();
                        buffer.pos(mmx, mmy, mmz).tex(offmax.x, off.y).normal(0, 0, -1).endVertex();
                    }

                    if (!chunk.hasBlock(blockX, y, z - 1))
                    {
                        if (!calculateOffset(off, offmax, (byte) (block & BACK_BIT), offsetX, offsetY, w, h, d, blockX, y, z, tw, th))
                        {
                            calculateOffset(off, offmax, block, offsetX, offsetY, w, h, d, blockX, y, z, tw, th);
                        }

                        buffer.pos(mnx, mmy, mnz).tex(offmax.x, off.y).normal(0, 0, 1).endVertex();
                        buffer.pos(mmx, mmy, mnz).tex(off.x, off.y).normal(0, 0, 1).endVertex();
                        buffer.pos(mmx, mny, mnz).tex(off.x, offmax.y).normal(0, 0, 1).endVertex();
                        buffer.pos(mnx, mny, mnz).tex(offmax.x, offmax.y).normal(0, 0, 1).endVertex();
                    }

                    /* Left & Right */
                    if (!chunk.hasBlock(blockX + 1, y, z))
                    {
                        if (!calculateOffset(off, offmax, (byte) (block & RIGHT_BIT), offsetX, offsetY, w, h, d, blockX, y, z, tw, th))
                        {
                            calculateOffset(off, offmax, block, offsetX, offsetY, w, h, d, blockX, y, z, tw, th);
                        }

                        buffer.pos(mmx, mmy, mnz).tex(offmax.x, off.y).normal(1, 0, 0).endVertex();
                        buffer.pos(mmx, mmy, mmz).tex(off.x, off.y).normal(1, 0, 0).endVertex();
                        buffer.pos(mmx, mny, mmz).tex(off.x, offmax.y).normal(1, 0, 0).endVertex();
                        buffer.pos(mmx, mny, mnz).tex(offmax.x, offmax.y).normal(1, 0, 0).endVertex();
                    }

                    if (!chunk.hasBlock(blockX - 1, y, z))
                    {
                        if (!calculateOffset(off, offmax, (byte) (block & LEFT_BIT), offsetX, offsetY, w, h, d, blockX, y, z, tw, th))
                        {
                            calculateOffset(off, offmax, block, offsetX, offsetY, w, h, d, blockX, y, z, tw, th);
                        }

                        buffer.pos(mnx, mmy, mnz).tex(off.x, off.y).normal(-1, 0, 0).endVertex();
                        buffer.pos(mnx, mny, mnz).tex(off.x, offmax.y).normal(-1, 0, 0).endVertex();
                        buffer.pos(mnx, mny, mmz).tex(offmax.x, offmax.y).normal(-1, 0, 0).endVertex();
                        buffer.pos(mnx, mmy, mmz).tex(offmax.x, off.y).normal(-1, 0, 0).endVertex();
                    }
                }
            }
        }

        Tessellator.getInstance().draw();
    }

    private static boolean calculateOffset(Offset offset, Offset max, byte block, int offsetX, int offsetY, int w, int h, int d, int x, int y, int z, float tw, float th)
    {
        /* Right */
        float offX = -1;
        float offY = -1;

        /* Top */
        if ((block & TOP_BIT) != 0)
        {
            offX = offsetX + d + x;
            offY = offsetY + z;
        }
        /* Bottom */
        else if ((block & BOTTOM_BIT) != 0)
        {
            offX = offsetX + d + w + x;
            offY = offsetY + z;
        }
        /* Front */
        else if ((block & FRONT_BIT) != 0)
        {
            offX = offsetX + d + x;
            offY = offsetY + d + h - y - 1;
        }
        /* Back */
        else if ((block & BACK_BIT) != 0)
        {
            offX = offsetX + d * 2 + w * 2 - x - 1;
            offY = offsetY + d + h - y - 1;
        }
        /* Left */
        else if ((block & LEFT_BIT) != 0)
        {
            offX = offsetX + z;
            offY = offsetY + d + h - y - 1;
        }
        else if ((block & RIGHT_BIT) != 0)
        {
            offX = offsetX + d + w + d - z - 1;
            offY = offsetY + d + h - y - 1;
        }

        if (offX == -1 && offY == -1)
        {
            return false;
        }

        float offMX = (offX + 1) / tw;
        float offMY = (offY + 1) / th;
        offX /= tw;
        offY /= th;

        offset.set(offX, offY);
        max.set(offMX, offMY);

        return true;
    }

    /**
     * Clean everything
     */
    public static void clear()
    {
        for (Map<ResourceLocation, Integer> map : layers.values())
        {
            for (Integer i : map.values())
            {
                if (i != -1)
                {
                    GL11.glDeleteLists(i, 1);
                }
            }
        }

        layers.clear();
    }

    /**
     * Clean up layers by texture
     */
    public static void clearByTexture(ResourceLocation texture)
    {
        for (Map<ResourceLocation, Integer> map : layers.values())
        {
            if (map.containsKey(texture))
            {
                int i = map.remove(texture);

                if (i != -1)
                {
                    GL11.glDeleteLists(i, 1);
                }
            }
        }
    }

    /**
     * Clean up layers by model
     */
    public static void clearByModel(ModelCustom model)
    {
        if (model == null)
        {
            return;
        }

        for (ModelCustomRenderer renderer : model.limbs)
        {
            if (!renderer.limb.is3D)
            {
                continue;
            }

            Map<ResourceLocation, Integer> map = layers.remove(renderer);

            if (map == null)
            {
                continue;
            }

            for (Integer i : map.values())
            {
                GL11.glDeleteLists(i.intValue(), 1);
            }
        }
    }

    /**
     * Cached image class
     */
    public static class CachedImage
    {
        public BufferedImage image;
        public int timer = 10;

        public CachedImage(BufferedImage image)
        {
            this.image = image;
        }
    }

    /**
     * Chunk class
     * 
     * Another class I extracted from my unfinished voxel video game. 
     * This class represents a voxel chunk.
     */
    public static class Chunk
    {
        /**
         * Array of block data 
         */
        protected byte[] data;

        public final int w;
        public final int h;
        public final int d;

        public int stats;
        public int ef;

        /**
         * Initialize empty chunk data 
         */
        public Chunk(int w, int h, int d, int ef)
        {
            w *= ef;
            h *= ef;
            d *= ef;

            this.w = w;
            this.h = h;
            this.d = d;
            this.ef = ef;

            this.data = new byte[w * h * d];
        }

        /**
         * Set block at given coordinates
         */
        public void setBlock(int x, int y, int z, byte block)
        {
            if (x < 0 || y < 0 || z < 0 || x >= this.w || y >= this.h || z >= this.d)
            {
                return;
            }

            byte old = this.data[x + y * this.w + z * this.w * this.h];

            this.data[x + y * this.w + z * this.w * this.h] = block;

            if (block != old)
            {
                this.stats += (block == 0) ? -1 : 1;
            }
        }

        /**
         * Set block at given coordinates
         */
        public void setBlockBit(int x, int y, int z, byte bit)
        {
            if (x < 0 || y < 0 || z < 0 || x >= this.w || y >= this.h || z >= this.d)
            {
                return;
            }

            byte old = this.data[x + y * this.w + z * this.w * this.h];
            byte block = (byte) (old | bit);

            this.data[x + y * this.w + z * this.w * this.h] = block;

            if (block != old)
            {
                this.stats += (block == 0) ? -1 : 1;
            }
        }

        /**
         * Is this chunk has a block at given coordinates  
         */
        public boolean hasBlock(int x, int y, int z)
        {
            return this.getBlock(x, y, z) != 0;
        }

        /**
         * Get block at given coordinate 
         */
        public byte getBlock(int x, int y, int z)
        {
            if (x < 0 || y < 0 || z < 0 || x >= this.w || y >= this.h || z >= this.d)
            {
                return 0;
            }

            return this.data[x + y * this.w + z * this.w * this.h];
        }
    }

    public static class Offset
    {
        public float x;
        public float y;

        public Offset(float x, float y)
        {
            this.set(x, y);
        }

        public void set(float x, float y)
        {
            this.x = x;
            this.y = y;
        }
    }
}

==================================================

--- Файл №158 ---
Путь: main\java\mchorse\blockbuster\client\model\parsing\ModelParser.java
--------------------
package mchorse.blockbuster.client.model.parsing;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelLimb.ArmorSlot;
import mchorse.blockbuster.api.ModelLimb.Holding;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.IMeshes;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.metamorph.Metamorph;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Model parser
 *
 * This class is responsible for converting models into in-game renderable
 * models (ModelCustom)
 */
@SideOnly(Side.CLIENT)
public class ModelParser
{
    public String key;
    public Map<String, IMeshes> meshes;

    /**
     * Parse with default class 
     */
    public static ModelCustom parse(String key, Model data)
    {
        return parse(key, data, ModelCustom.class, null);
    }

    /**
     * Parse with default class 
     */
    public static ModelCustom parse(String key, Model data, Map<String, IMeshes> meshes)
    {
        return parse(key, data, ModelCustom.class, meshes);
    }

    /**
     * Parse given input stream as JSON model, and then save this model in
     * the custom model repository
     */
    public static ModelCustom parse(String key, Model data, Class<? extends ModelCustom> clazz, Map<String, IMeshes> meshes)
    {
        try
        {
            return new ModelParser(key, meshes).parseModel(data, clazz);
        }
        catch (Exception e)
        {
            System.out.println("Model for key '" + key + "' couldn't converted to ModelCustom!");
            e.printStackTrace();
        }

        return null;
    }

    public ModelParser(String key, Map<String, IMeshes> meshes)
    {
        if (meshes == null)
        {
            meshes = new HashMap<String, IMeshes>();
        }

        this.key = key;
        this.meshes = meshes;
    }

    /**
     * Parse and build model out of given JSON string. Throws exception in case
     * if parsed model doesn't have at least one required pose.
     */
    public ModelCustom parseModel(Model data, Class<? extends ModelCustom> clazz) throws Exception
    {
        ModelCustom model = clazz.getConstructor(Model.class).newInstance(data);
        this.generateLimbs(data, model);

        if (model instanceof IModelCustom)
        {
            ((IModelCustom) model).onGenerated();
        }

        return model;
    }

    /**
     * Generate limbs for a custom model renderer based on a passed model data
     * which was parsed from JSON.
     */
    protected void generateLimbs(Model data, ModelCustom model)
    {
        /* Define lists for different purposes */
        Map<String, ModelCustomRenderer> limbs = new HashMap<String, ModelCustomRenderer>();
        List<ModelRenderer> renderable = new ArrayList<ModelRenderer>();

        List<ModelRenderer> left = new ArrayList<ModelRenderer>();
        List<ModelRenderer> right = new ArrayList<ModelRenderer>();
        List<ModelRenderer> armor = new ArrayList<ModelRenderer>();

        ModelPose standing = data.poses.get("standing");

        /* First, iterate to create every limb */
        for (Map.Entry<String, ModelLimb> entry : data.limbs.entrySet())
        {
            ModelLimb limb = entry.getValue();
            ModelTransform transform = standing.limbs.get(entry.getKey());

            ModelCustomRenderer renderer = this.createRenderer(model, data, limb, transform);

            if (limb.holding == Holding.LEFT) left.add(renderer);
            if (limb.holding == Holding.RIGHT) right.add(renderer);
            if (limb.slot != ArmorSlot.NONE) armor.add(renderer);

            limbs.put(entry.getKey(), renderer);
        }

        /* Then, iterate to attach child to their parents */
        for (Map.Entry<String, ModelCustomRenderer> entry : limbs.entrySet())
        {
            ModelLimb limb = data.limbs.get(entry.getKey());

            if (!limb.parent.isEmpty())
            {
                limbs.get(limb.parent).addChild(entry.getValue());
            }
            else
            {
                renderable.add(entry.getValue());
            }

            /* Inject ModelCustomRenderers into the model's fields */
            if (model instanceof IModelCustom)
            {
                try
                {
                    Field field = model.getClass().getField(entry.getKey());

                    if (field != null)
                    {
                        field.set(model, entry.getValue());
                    }
                }
                catch (Exception e)
                {
                    Metamorph.log("Field '" + entry.getKey() + "' was not found or is not accessible for " + model.getClass().getSimpleName());
                }
            }
        }

        /* Assign values */
        model.left = left.toArray(new ModelCustomRenderer[left.size()]);
        model.right = right.toArray(new ModelCustomRenderer[right.size()]);
        model.armor = armor.toArray(new ModelCustomRenderer[armor.size()]);

        model.limbs = limbs.values().toArray(new ModelCustomRenderer[limbs.size()]);
        model.renderable = renderable.toArray(new ModelCustomRenderer[renderable.size()]);
    }

    /**
     * Create limb renderer for the model
     */
    protected ModelCustomRenderer createRenderer(ModelCustom model, Model data, ModelLimb limb, ModelTransform transform)
    {
        ModelCustomRenderer renderer = null;

        float w = limb.size[0];
        float h = limb.size[1];
        float d = limb.size[2];

        float ax = 1 - limb.anchor[0];
        float ay = limb.anchor[1];
        float az = limb.anchor[2];

        IMeshes meshes = this.meshes.get(limb.name);

        if (meshes != null)
        {
            renderer = meshes.createRenderer(data, model, limb, transform);
        }

        if (renderer == null)
        {
            renderer = new ModelCustomRenderer(model, limb, transform);
            renderer.mirror = limb.mirror;
            renderer.addBox(-ax * w, -ay * h, -az * d, (int) w, (int) h, (int) d, limb.sizeOffset);
        }

        renderer.applyTransform(transform);

        return renderer;
    }
}

==================================================

--- Файл №159 ---
Путь: main\java\mchorse\blockbuster\client\particles\BedrockCurve.java
--------------------
package mchorse.blockbuster.client.particles;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;

public class BedrockCurve
{
    public BedrockCurveType type = BedrockCurveType.LINEAR;
    public MolangExpression[] nodes = {MolangParser.ZERO, MolangParser.ONE, MolangParser.ZERO};
    public MolangExpression input;
    public MolangExpression range;
    public Variable variable;

    public double compute()
    {
        return this.computeCurve(this.input.get() / this.range.get());
    }

    private double computeCurve(double factor)
    {
        int length = this.nodes.length;

        if (length == 0)
        {
            return 0;
        }
        else if (length == 1)
        {
            return this.nodes[0].get();
        }

        if (factor < 0)
        {
            factor = -(1 + factor);
        }

        factor = MathUtils.clamp(factor, 0, 1);

        if (this.type == BedrockCurveType.HERMITE)
        {
            if (length <= 3)
            {
                return this.nodes[length - 2].get();
            }

            factor *= (length - 3);
            int index = (int) factor + 1;

            MolangExpression beforeFirst = this.getNode(index - 1);
            MolangExpression first = this.getNode(index);
            MolangExpression next = this.getNode(index + 1);
            MolangExpression afterNext = this.getNode(index + 2);

            return Interpolations.cubicHermite(beforeFirst.get(), first.get(), next.get(), afterNext.get(), factor % 1);
        }

        factor *= length - 1;
        int index = (int) factor;

        MolangExpression first = this.getNode(index);
        MolangExpression next = this.getNode(index + 1);

        return Interpolations.lerp(first.get(), next.get(), factor % 1);
    }

    private MolangExpression getNode(int index)
    {
        if (index < 0)
        {
            return this.nodes[0];
        }
        else if (index >= this.nodes.length)
        {
            return this.nodes[this.nodes.length - 1];
        }

        return this.nodes[index];
    }

    public void fromJson(JsonObject object, MolangParser parser) throws MolangException
    {
        if (object.has("type"))
        {
            this.type = BedrockCurveType.fromString(object.get("type").getAsString());
        }

        if (object.has("input"))
        {
            this.input = parser.parseJson(object.get("input"));
        }

        if (object.has("horizontal_range"))
        {
            this.range = parser.parseJson(object.get("horizontal_range"));
        }

        if (object.has("nodes"))
        {
            JsonArray nodes = object.getAsJsonArray("nodes");
            MolangExpression[] result = new MolangExpression[nodes.size()];

            for (int i = 0, c = result.length; i < c; i ++)
            {
                result[i] = parser.parseJson(nodes.get(i));
            }

            this.nodes = result;
        }
    }

    public JsonElement toJson()
    {
        JsonObject curve = new JsonObject();
        JsonArray nodes = new JsonArray();

        curve.addProperty("type", this.type.id);
        curve.add("nodes", nodes);
        curve.add("input", this.input.toJson());
        curve.add("horizontal_range", this.range.toJson());

        for (MolangExpression expression : this.nodes)
        {
            nodes.add(expression.toJson());
        }

        return curve;
    }
}

==================================================

--- Файл №160 ---
Путь: main\java\mchorse\blockbuster\client\particles\BedrockCurveType.java
--------------------
package mchorse.blockbuster.client.particles;

public enum BedrockCurveType
{
    LINEAR("linear"), HERMITE("catmull_rom");

    public final String id;

    public static BedrockCurveType fromString(String type)
    {
        for (BedrockCurveType t : values())
        {
            if (t.id.equals(type))
            {
                return t;
            }
        }

        return LINEAR;
    }

    private BedrockCurveType(String id)
    {
        this.id = id;
    }
}

==================================================

--- Файл №161 ---
Путь: main\java\mchorse\blockbuster\client\particles\BedrockLibrary.java
--------------------
package mchorse.blockbuster.client.particles;

import mchorse.mclib.utils.JsonUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

public class BedrockLibrary
{
    public static long lastUpdate;

    public Map<String, BedrockScheme> presets = new HashMap<String, BedrockScheme>();
    public Map<String, BedrockScheme> factory = new HashMap<String, BedrockScheme>();
    public File folder;

    public BedrockLibrary(File folder)
    {
        this.folder = folder;
        this.folder.mkdirs();

        /* Load factory (default) presets */
        this.storeFactory("default_fire");
        this.storeFactory("default_magic");
        this.storeFactory("default_rain");
        this.storeFactory("default_snow");
    }

    public File file(String name)
    {
        return new File(this.folder, name + ".json");
    }

    public boolean hasEffect(String name)
    {
        return this.file(name).isFile();
    }

    public void reload()
    {
        this.presets.clear();
        this.presets.putAll(this.factory);

        for (File file : this.folder.listFiles())
        {
            if (file.isFile() && file.getName().endsWith(".json"))
            {
                this.storeScheme(file);
            }
        }
    }

    public BedrockScheme load(String name)
    {
        BedrockScheme scheme = this.loadScheme(this.file(name));

        if (scheme != null)
        {
            return scheme;
        }

        return this.loadFactory(name);
    }

    private void storeScheme(File file)
    {
        BedrockScheme scheme = this.loadScheme(file);

        if (scheme != null)
        {
            String name = file.getName();

            this.presets.put(name.substring(0, name.indexOf(".json")), scheme);
        }
    }

    /**
     * Load a scheme from a file
     */
    public BedrockScheme loadScheme(File file)
    {
        if (!file.exists())
        {
            return null;
        }

        try
        {
            return BedrockScheme.parse(FileUtils.readFileToString(file, StandardCharsets.UTF_8));
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    private void storeFactory(String name)
    {
        BedrockScheme scheme = this.loadFactory(name);

        if (scheme != null)
        {
            this.factory.put(name, scheme);
        }
    }

    /**
     * Load a scheme from Blockbuster's zip
     */
    public BedrockScheme loadFactory(String name)
    {
        try
        {
            return BedrockScheme.parse(IOUtils.toString(this.getClass().getClassLoader().getResourceAsStream("assets/blockbuster/particles/" + name + ".json"), StandardCharsets.UTF_8)).factory(true);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    public void save(String filename, BedrockScheme scheme)
    {
        String json = JsonUtils.jsonToPretty(BedrockScheme.toJson(scheme));
        File file = this.file(filename);

        try
        {
            FileUtils.writeStringToFile(file, json, StandardCharsets.UTF_8);
        }
        catch (Exception e)
        {}

        this.storeScheme(file);

        lastUpdate = System.currentTimeMillis();
    }
}

==================================================

--- Файл №162 ---
Путь: main\java\mchorse\blockbuster\client\particles\BedrockMaterial.java
--------------------
package mchorse.blockbuster.client.particles;

import net.minecraft.client.renderer.GlStateManager;
import org.lwjgl.opengl.GL11;

public enum  BedrockMaterial
{
    OPAQUE("particles_opaque"), ALPHA("particles_alpha"), BLEND("particles_blend"), ADDITIVE("particles_add");

    public final String id;

    public static BedrockMaterial fromString(String material)
    {
        for (BedrockMaterial mat : values())
        {
            if (mat.id.equals(material))
            {
                return mat;
            }
        }

        return OPAQUE;
    }

    private BedrockMaterial(String id)
    {
        this.id = id;
    }

    public void beginGL()
    {
        switch (this)
        {
            case OPAQUE:
                GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0F);
                GlStateManager.disableBlend();
                GlStateManager.enableAlpha();
                break;
            case ALPHA:
                GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
                GlStateManager.disableBlend();
                GlStateManager.enableAlpha();
                break;
            case BLEND:
                GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0.0F);
                GlStateManager.enableBlend();
                GlStateManager.enableAlpha();
                break;
            case ADDITIVE:
                GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE);
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0.0F);
                GlStateManager.enableBlend();
                GlStateManager.enableAlpha();
                break;
        }
    }

    public void endGL()
    {
        switch (this)
        {
            case OPAQUE:
            case ALPHA:
            case BLEND:
            case ADDITIVE:
                GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
                GlStateManager.disableBlend();
                GlStateManager.enableAlpha();
                GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
                break;
        }
    }

}

==================================================

--- Файл №163 ---
Путь: main\java\mchorse\blockbuster\client\particles\BedrockScheme.java
--------------------
package mchorse.blockbuster.client.particles;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentEmitterInitialize;
import mchorse.blockbuster.client.particles.components.IComponentEmitterUpdate;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.components.IComponentParticleMorphRender;
import mchorse.blockbuster.client.particles.components.IComponentParticleRender;
import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentInitialSpeed;
import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangParser;
import net.minecraft.util.ResourceLocation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class BedrockScheme
{
    public static final ResourceLocation DEFAULT_TEXTURE = new ResourceLocation(Blockbuster.MOD_ID, "textures/default_particles.png");
    public static final Gson JSON_PARSER = new GsonBuilder()
        .registerTypeAdapter(BedrockScheme.class, new BedrockSchemeJsonAdapter())
        .create();

    /* Particles identifier */
    public String identifier = "";

    /* Particle description */
    public BedrockMaterial material = BedrockMaterial.OPAQUE;
    public ResourceLocation texture = DEFAULT_TEXTURE;

    /* Particle's curves */
    public Map<String, BedrockCurve> curves = new HashMap<String, BedrockCurve>();

    /* Particle's components */
    public List<BedrockComponentBase> components = new ArrayList<BedrockComponentBase>();
    public List<IComponentEmitterInitialize> emitterInitializes;
    public List<IComponentEmitterUpdate> emitterUpdates;
    public List<IComponentParticleInitialize> particleInitializes;
    public List<IComponentParticleUpdate> particleUpdates;
    public List<IComponentParticleRender> particleRender;
    public List<IComponentParticleMorphRender> particleMorphRender;

    private boolean factory;

    /* MoLang integration */
    public MolangParser parser;

    public static BedrockScheme parse(String json)
    {
        return JSON_PARSER.fromJson(json, BedrockScheme.class);
    }

    public static BedrockScheme parse(JsonElement json)
    {
        return JSON_PARSER.fromJson(json, BedrockScheme.class);
    }

    public static JsonElement toJson(BedrockScheme scheme)
    {
        return JSON_PARSER.toJsonTree(scheme);
    }

    /**
     * Probably it's very expensive, but it's much easier than implementing copy methods
     * to every component in the particle system...
     */
    public static BedrockScheme dupe(BedrockScheme scheme)
    {
        return parse(toJson(scheme));
    }

    public BedrockScheme()
    {
        this.parser = new MolangParser();

        /* Default variables */
        this.parser.register(new Variable("variable.particle_age", 0));
        this.parser.register(new Variable("variable.particle_lifetime", 0));
        this.parser.register(new Variable("variable.particle_random_1", 0));
        this.parser.register(new Variable("variable.particle_random_2", 0));
        this.parser.register(new Variable("variable.particle_random_3", 0));
        this.parser.register(new Variable("variable.particle_random_4", 0));

        this.parser.register(new Variable("variable.particle_speed.length", 0));
        this.parser.register(new Variable("variable.particle_speed.x", 0));
        this.parser.register(new Variable("variable.particle_speed.y", 0));
        this.parser.register(new Variable("variable.particle_speed.z", 0));
        this.parser.register(new Variable("variable.particle_pos.x", 0));
        this.parser.register(new Variable("variable.particle_pos.y", 0));
        this.parser.register(new Variable("variable.particle_pos.z", 0));
        this.parser.register(new Variable("variable.particle_pos.distance", 0));
        this.parser.register(new Variable("variable.particle_bounces", 0));

        this.parser.register(new Variable("variable.emitter_age", 0));
        this.parser.register(new Variable("variable.emitter_lifetime", 0));
        this.parser.register(new Variable("variable.emitter_random_1", 0));
        this.parser.register(new Variable("variable.emitter_random_2", 0));
        this.parser.register(new Variable("variable.emitter_random_3", 0));
        this.parser.register(new Variable("variable.emitter_random_4", 0));
    }

    public BedrockScheme factory(boolean factory)
    {
        this.factory = factory;

        return this;
    }

    public boolean isFactory()
    {
        return this.factory;
    }

    public void setup()
    {
        this.getOrCreate(BedrockComponentInitialSpeed.class);

        this.emitterInitializes = this.getComponents(IComponentEmitterInitialize.class);
        this.emitterUpdates = this.getComponents(IComponentEmitterUpdate.class);
        this.particleInitializes = this.getComponents(IComponentParticleInitialize.class);
        this.particleUpdates = this.getComponents(IComponentParticleUpdate.class);
        this.particleRender = this.getComponents(IComponentParticleRender.class);
        this.particleMorphRender = this.getComponents(IComponentParticleMorphRender.class);

        /* Link variables with curves */
        for (Map.Entry<String, BedrockCurve> entry : this.curves.entrySet())
        {
            entry.getValue().variable = this.parser.variables.get(entry.getKey());
        }
    }

    public <T extends IComponentBase> List<T> getComponents(Class<T> clazz)
    {
        List<T> list = new ArrayList<T>();

        for (BedrockComponentBase component : this.components)
        {
            if (clazz.isAssignableFrom(component.getClass()))
            {
                list.add((T) component);
            }
        }

        if (list.size() > 1)
        {
            Collections.sort(list, Comparator.comparingInt(IComponentBase::getSortingIndex));
        }

        return list;
    }

    public <T extends BedrockComponentBase> T get(Class<T> clazz)
    {
        for (BedrockComponentBase component : this.components)
        {
            if (clazz.isAssignableFrom(component.getClass()))
            {
                return (T) component;
            }
        }

        return null;
    }

    public <T extends BedrockComponentBase> T getExact(Class<T> clazz)
    {
        for (BedrockComponentBase component : this.components)
        {
            if (clazz.equals(component.getClass()))
            {
                return (T) component;
            }
        }

        return null;
    }

    public <T extends BedrockComponentBase> T add(Class<T> clazz)
    {
        T result = null;

        try
        {
            result = clazz.getConstructor().newInstance();

            this.components.add(result);
            this.setup();
        }
        catch (Exception e)
        {}

        return result;
    }

    /**
     * This method gets the component using isAssignableFrom() method. It can also get sub-classes
     * @param clazz target class
     * @param <T>
     * @return the component object
     */
    public <T extends BedrockComponentBase> T getOrCreate(Class<T> clazz)
    {
        return this.getOrCreate(clazz, clazz);
    }

    /**
     * This method gets the component by its exact class and no sub-classes.
     * @param clazz target class
     * @param <T>
     * @return the component object
     */
    public <T extends BedrockComponentBase> T getOrCreateExact(Class<T> clazz)
    {
        return this.getOrCreateExact(clazz, clazz);
    }

    /**
     * This method gets the component using isAssignableFrom() method. It can also get sub-classes. If clazz hasn't been found it will add the subclass parameter.
     * @param clazz target class
     * @param clazz alternative class too add in case target class doesnt exist
     * @param <T>
     * @return the component object
     */
    public <T extends BedrockComponentBase> T getOrCreate(Class<T> clazz, Class subclass)
    {
        T result = this.get(clazz);

        if (result == null)
        {
            result = (T) this.add(subclass);
        }

        return result;
    }

    public <T extends BedrockComponentBase> T getOrCreateExact(Class<T> clazz, Class subclass)
    {
        T result = this.getExact(clazz);

        if (result == null)
        {
            result = (T) this.add(subclass);
        }

        return result;
    }

    public <T extends BedrockComponentBase> T remove(Class<T> clazz)
    {
        Iterator<BedrockComponentBase> it = this.components.iterator();

        while (it.hasNext())
        {
            BedrockComponentBase component = it.next();

            if (clazz.isAssignableFrom(component.getClass()))
            {
                it.remove();

                return (T) component;
            }
        }

        return null;
    }

    public <T extends BedrockComponentBase> T replace(Class<T> clazz, Class subclass)
    {
        this.remove(clazz);

        return (T) this.add(subclass);
    }

    /**
     * Update curve values
     */
    public void updateCurves()
    {
        for (BedrockCurve curve : this.curves.values())
        {
            if (curve.variable != null)
            {
                curve.variable.set(curve.compute());
            }
        }
    }
}

==================================================

--- Файл №164 ---
Путь: main\java\mchorse\blockbuster\client\particles\BedrockSchemeJsonAdapter.java
--------------------
package mchorse.blockbuster.client.particles;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceBillboard;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceLighting;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceTinting;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionAppearance;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionTinting;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentParticleMorph;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentExpireInBlocks;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentExpireNotInBlocks;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentKillPlane;
import mchorse.blockbuster.client.particles.components.expiration.BedrockComponentParticleLifetime;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetimeExpression;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetimeLooping;
import mchorse.blockbuster.client.particles.components.lifetime.BedrockComponentLifetimeOnce;
import mchorse.blockbuster.client.particles.components.meta.BedrockComponentInitialization;
import mchorse.blockbuster.client.particles.components.meta.BedrockComponentLocalSpace;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentInitialSpeed;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentInitialSpin;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotionCollision;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotionDynamic;
import mchorse.blockbuster.client.particles.components.motion.BedrockComponentMotionParametric;
import mchorse.blockbuster.client.particles.components.rate.BedrockComponentRateInstant;
import mchorse.blockbuster.client.particles.components.rate.BedrockComponentRateSteady;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeBox;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeDisc;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeEntityAABB;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapePoint;
import mchorse.blockbuster.client.particles.components.shape.BedrockComponentShapeSphere;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.utils.resources.RLUtils;

import java.lang.reflect.Type;
import java.util.Map;

public class BedrockSchemeJsonAdapter implements JsonDeserializer<BedrockScheme>, JsonSerializer<BedrockScheme>
{
    public BiMap<String, Class<? extends BedrockComponentBase>> components = HashBiMap.create();

    public static boolean isEmpty(JsonElement element)
    {
        if (element.isJsonArray())
        {
            return element.getAsJsonArray().size() == 0;
        }
        else if (element.isJsonObject())
        {
            return element.getAsJsonObject().size() == 0;
        }
        else if (element.isJsonPrimitive())
        {
            JsonPrimitive primitive = element.getAsJsonPrimitive();

            if (primitive.isString())
            {
                return primitive.getAsString().isEmpty();
            }
            else if (primitive.isNumber())
            {
                return Operation.equals(primitive.getAsDouble(), 0);
            }
        }

        return element.isJsonNull();
    }

    public BedrockSchemeJsonAdapter()
    {
        /* Meta components */
        this.components.put("minecraft:emitter_local_space", BedrockComponentLocalSpace.class);
        this.components.put("minecraft:emitter_initialization", BedrockComponentInitialization.class);

        /* Rate */
        this.components.put("minecraft:emitter_rate_instant", BedrockComponentRateInstant.class);
        this.components.put("minecraft:emitter_rate_steady", BedrockComponentRateSteady.class);

        /* Lifetime emitter */
        this.components.put("minecraft:emitter_lifetime_looping", BedrockComponentLifetimeLooping.class);
        this.components.put("minecraft:emitter_lifetime_once", BedrockComponentLifetimeOnce.class);
        this.components.put("minecraft:emitter_lifetime_expression", BedrockComponentLifetimeExpression.class);

        /* Shapes */
        this.components.put("minecraft:emitter_shape_disc", BedrockComponentShapeDisc.class);
        this.components.put("minecraft:emitter_shape_box", BedrockComponentShapeBox.class);
        this.components.put("minecraft:emitter_shape_entity_aabb", BedrockComponentShapeEntityAABB.class);
        this.components.put("minecraft:emitter_shape_point", BedrockComponentShapePoint.class);
        this.components.put("minecraft:emitter_shape_sphere", BedrockComponentShapeSphere.class);

        /* Lifetime particle */
        this.components.put("minecraft:particle_lifetime_expression", BedrockComponentParticleLifetime.class);
        this.components.put("minecraft:particle_expire_if_in_blocks", BedrockComponentExpireInBlocks.class);
        this.components.put("minecraft:particle_expire_if_not_in_blocks", BedrockComponentExpireNotInBlocks.class);
        this.components.put("minecraft:particle_kill_plane", BedrockComponentKillPlane.class);

        /* Appearance */
        this.components.put("minecraft:particle_appearance_billboard", BedrockComponentAppearanceBillboard.class);
        this.components.put("minecraft:particle_appearance_lighting", BedrockComponentAppearanceLighting.class);
        this.components.put("minecraft:particle_appearance_tinting", BedrockComponentAppearanceTinting.class);
        this.components.put("blockbuster:particle_collision_appearance", BedrockComponentCollisionAppearance.class);
        this.components.put("blockbuster:particle_collision_tinting", BedrockComponentCollisionTinting.class);
        this.components.put("blockbuster:particle_morph", BedrockComponentParticleMorph.class);
        
        /* Motion & Rotation */
        this.components.put("minecraft:particle_initial_speed", BedrockComponentInitialSpeed.class);
        this.components.put("minecraft:particle_initial_spin", BedrockComponentInitialSpin.class);
        this.components.put("minecraft:particle_motion_collision", BedrockComponentMotionCollision.class);
        this.components.put("minecraft:particle_motion_dynamic", BedrockComponentMotionDynamic.class);
        this.components.put("minecraft:particle_motion_parametric", BedrockComponentMotionParametric.class);
    }

    @Override
    public BedrockScheme deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
    {
        BedrockScheme scheme = new BedrockScheme();

        if (!json.isJsonObject())
        {
            throw new JsonParseException("The root element of Bedrock particle should be an object!");
        }

        /* Skip format_version check to avoid breaking semi-compatible particles */
        JsonObject root = json.getAsJsonObject();

        try
        {
            this.parseEffect(scheme, this.getObject(root, "particle_effect", "No particle_effect was found..."));
        }
        catch (MolangException e)
        {
            throw new JsonParseException("Couldn't parse some MoLang expression!", e);
        }

        scheme.setup();

        return scheme;
    }

    private void parseEffect(BedrockScheme scheme, JsonObject effect) throws JsonParseException, MolangException
    {
        this.parseDescription(scheme, this.getObject(effect, "description", "No particle_effect.description was found..."));

        if (effect.has("curves"))
        {
            JsonElement curves = effect.get("curves");

            if (curves.isJsonObject())
            {
                this.parseCurves(scheme, curves.getAsJsonObject());
            }
        }

        this.parseComponents(scheme, this.getObject(effect, "components", "No particle_effect.components was found..."));
    }

    /**
     * Parse description object (which contains ID of the particle, material type and texture)
     */
    private void parseDescription(BedrockScheme scheme, JsonObject description) throws JsonParseException
    {
        if (description.has("identifier"))
        {
            scheme.identifier = description.get("identifier").getAsString();
        }

        JsonObject parameters = this.getObject(description, "basic_render_parameters", "No particle_effect.basic_render_parameters was found...");

        if (parameters.has("material"))
        {
            scheme.material = BedrockMaterial.fromString(parameters.get("material").getAsString());
        }

        if (parameters.has("texture"))
        {
            String texture = parameters.get("texture").getAsString();

            if (!texture.equals("textures/particle/particles"))
            {
                scheme.texture = RLUtils.create(texture);
            }
        }
    }

    /**
     * Parse curves object
     */
    private void parseCurves(BedrockScheme scheme, JsonObject curves) throws MolangException
    {
        for (Map.Entry<String, JsonElement> entry : curves.entrySet())
        {
            JsonElement element = entry.getValue();

            if (element.isJsonObject())
            {
                BedrockCurve curve = new BedrockCurve();

                curve.fromJson(element.getAsJsonObject(), scheme.parser);
                scheme.curves.put(entry.getKey(), curve);
            }
        }
    }

    private void parseComponents(BedrockScheme scheme, JsonObject components) throws MolangException
    {
        for (Map.Entry<String, JsonElement> entry : components.entrySet())
        {
            String key = entry.getKey();

            if (this.components.containsKey(key))
            {
                BedrockComponentBase component = null;

                try
                {
                    component = this.components.get(key).getConstructor().newInstance();
                }
                catch (Exception e)
                {}

                if (component != null)
                {
                    component.fromJson(entry.getValue(), scheme.parser);
                    scheme.components.add(component);
                }
                else
                {
                    System.out.println("Failed to parse given component " + key + " in " + scheme.identifier + "!");
                }
            }
        }
    }

    private JsonObject getObject(JsonObject object, String key, String message) throws JsonParseException
    {
        /* Skip format_version check to avoid breaking semi-compatible particles */
        if (!object.has(key) && !object.get(key).isJsonObject())
        {
            throw new JsonParseException(message);
        }

        return object.get(key).getAsJsonObject();
    }

    /**
     * Turn given bedrock scheme into JSON
     */
    @Override
    public JsonElement serialize(BedrockScheme src, Type typeOfSrc, JsonSerializationContext context)
    {
        JsonObject object = new JsonObject();
        JsonObject effect = new JsonObject();

        object.addProperty("format_version", "1.10.0");
        object.add("particle_effect", effect);

        this.addDescription(effect, src);
        this.addCurves(effect, src);
        this.addComponents(effect, src);

        return object;
    }

    private void addDescription(JsonObject effect, BedrockScheme scheme)
    {
        JsonObject desc = new JsonObject();
        JsonObject render = new JsonObject();

        effect.add("description", desc);

        desc.addProperty("identifier", scheme.identifier);
        desc.add("basic_render_parameters", render);

        render.addProperty("material", scheme.material.id);
        render.addProperty("texture", "textures/particle/particles");

        if (scheme.texture != null && !scheme.texture.equals(BedrockScheme.DEFAULT_TEXTURE))
        {
            render.addProperty("texture", scheme.texture.toString());
        }
    }

    private void addCurves(JsonObject effect, BedrockScheme scheme)
    {
        JsonObject curves = new JsonObject();

        effect.add("curves", curves);

        for (Map.Entry<String, BedrockCurve> entry : scheme.curves.entrySet())
        {
            curves.add(entry.getKey(), entry.getValue().toJson());
        }
    }

    private void addComponents(JsonObject effect, BedrockScheme scheme)
    {
        JsonObject components = new JsonObject();

        effect.add("components", components);

        for (BedrockComponentBase component : scheme.components)
        {
            JsonElement element = component.toJson();

            if (this.isEmpty(element) && !component.canBeEmpty())
            {
                continue;
            }

            components.add(this.components.inverse().get(component.getClass()), element);
        }
    }
}

==================================================

--- Файл №165 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\BedrockComponentBase.java
--------------------
package mchorse.blockbuster.client.particles.components;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;

public abstract class BedrockComponentBase
{
    public BedrockComponentBase fromJson(JsonElement element, MolangParser parser) throws MolangException
    {
        return this;
    }

    public JsonElement toJson()
    {
        return new JsonObject();
    }

    public boolean canBeEmpty()
    {
        return false;
    }
}

==================================================

--- Файл №166 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentBase.java
--------------------
package mchorse.blockbuster.client.particles.components;

public interface IComponentBase
{
    public default int getSortingIndex()
    {
        return 0;
    }
}

==================================================

--- Файл №167 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentEmitterInitialize.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;

public interface IComponentEmitterInitialize extends IComponentBase
{
    public void apply(BedrockEmitter emitter);
}

==================================================

--- Файл №168 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentEmitterUpdate.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;

public interface IComponentEmitterUpdate extends IComponentBase
{
    public void update(BedrockEmitter emitter);
}

==================================================

--- Файл №169 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentParticleInitialize.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;

public interface IComponentParticleInitialize extends IComponentBase
{
    public void apply(BedrockEmitter emitter, BedrockParticle particle);
}

==================================================

--- Файл №170 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentParticleMorphRender.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import net.minecraft.client.renderer.BufferBuilder;

public interface IComponentParticleMorphRender extends IComponentRenderBase
{ }


==================================================

--- Файл №171 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentParticleRender.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import net.minecraft.client.renderer.BufferBuilder;

public interface IComponentParticleRender extends IComponentRenderBase
{
}

==================================================

--- Файл №172 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentParticleUpdate.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;

public interface IComponentParticleUpdate extends IComponentBase
{
    public void update(BedrockEmitter emitter, BedrockParticle particle);
}

==================================================

--- Файл №173 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\IComponentRenderBase.java
--------------------
package mchorse.blockbuster.client.particles.components;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import net.minecraft.client.renderer.BufferBuilder;

public interface IComponentRenderBase extends IComponentBase
{
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks);

    public void renderOnScreen(BedrockParticle particle, int x, int y, float scale, float partialTicks);

    public void preRender(BedrockEmitter emitter, float partialTicks);

    public void postRender(BedrockEmitter emitter, float partialTicks);
}


==================================================

--- Файл №174 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\BedrockComponentAppearanceBillboard.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleRender;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.util.math.MathHelper;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix3d;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

public class BedrockComponentAppearanceBillboard extends BedrockComponentBase implements IComponentParticleRender
{
    /* Options */
    public MolangExpression sizeW = MolangParser.ZERO;
    public MolangExpression sizeH = MolangParser.ZERO;
    public CameraFacing facing = CameraFacing.LOOKAT_XYZ;
    public boolean customDirection = false;
    public float directionSpeedThreshhold = 0.01F;
    public MolangExpression directionX = MolangParser.ZERO;
    public MolangExpression directionY = MolangParser.ZERO;
    public MolangExpression directionZ = MolangParser.ZERO;
    public int textureWidth = 128;
    public int textureHeight = 128;
    public MolangExpression uvX = MolangParser.ZERO;
    public MolangExpression uvY = MolangParser.ZERO;
    public MolangExpression uvW = MolangParser.ZERO;
    public MolangExpression uvH = MolangParser.ZERO;

    public boolean flipbook = false;
    public float stepX;
    public float stepY;
    public float fps;
    public MolangExpression maxFrame = MolangParser.ZERO;
    public boolean stretchFPS = false;
    public boolean loop = false;

    /* Runtime properties */
    protected float w;
    protected float h;

    protected float u1;
    protected float v1;
    protected float u2;
    protected float v2;

    protected Matrix4f transform = new Matrix4f();
    protected Matrix4f rotation = new Matrix4f();
    protected Vector4f[] vertices = new Vector4f[] {
        new Vector4f(0, 0, 0, 1),
        new Vector4f(0, 0, 0, 1),
        new Vector4f(0, 0, 0, 1),
        new Vector4f(0, 0, 0, 1)
    };
    protected Vector3f vector = new Vector3f();
    protected Vector3f direction = new Vector3f();

    public BedrockComponentAppearanceBillboard()
    {}

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("size") && element.get("size").isJsonArray())
        {
            JsonArray size = element.getAsJsonArray("size");

            if (size.size() >= 2)
            {
                this.sizeW = parser.parseJson(size.get(0));
                this.sizeH = parser.parseJson(size.get(1));
            }
        }

        if (element.has("facing_camera_mode"))
        {
            this.facing = CameraFacing.fromString(element.get("facing_camera_mode").getAsString());
        }

        if (this.facing.isDirection && element.has("direction"))
        {
            this.parseDirection(element.get("direction").getAsJsonObject(), parser);
        }

        if (element.has("uv") && element.get("uv").isJsonObject())
        {
            this.parseUv(element.get("uv").getAsJsonObject(), parser);
        }

        return super.fromJson(element, parser);
    }

    protected void parseDirection(JsonObject object, MolangParser parser) throws MolangException
    {
        this.customDirection = object.has("mode") && object.get("mode").getAsString().equals("custom");

        if (this.customDirection && object.has("custom_direction"))
        {
            JsonArray directionArray = object.getAsJsonArray("custom_direction");
            this.directionX = parser.parseJson(directionArray.get(0));
            this.directionY = parser.parseJson(directionArray.get(1));
            this.directionZ = parser.parseJson(directionArray.get(2));
        }
        else if (!this.customDirection && object.has("min_speed_threshold"))
        {
            this.directionSpeedThreshhold = object.get("min_speed_threshold").getAsFloat();
        }
    }

    protected void parseUv(JsonObject object, MolangParser parser) throws MolangException
    {
        if (object.has("texture_width")) this.textureWidth = object.get("texture_width").getAsInt();
        if (object.has("texture_height")) this.textureHeight = object.get("texture_height").getAsInt();

        if (object.has("uv") && object.get("uv").isJsonArray())
        {
            JsonArray uv = object.getAsJsonArray("uv");

            if (uv.size() >= 2)
            {
                this.uvX = parser.parseJson(uv.get(0));
                this.uvY = parser.parseJson(uv.get(1));
            }
        }

        if (object.has("uv_size") && object.get("uv_size").isJsonArray())
        {
            JsonArray uv = object.getAsJsonArray("uv_size");

            if (uv.size() >= 2)
            {
                this.uvW = parser.parseJson(uv.get(0));
                this.uvH = parser.parseJson(uv.get(1));
            }
        }

        if (object.has("flipbook") && object.get("flipbook").isJsonObject())
        {
            this.flipbook = true;
            this.parseFlipbook(object.get("flipbook").getAsJsonObject(), parser);
        }
    }

    protected void parseFlipbook(JsonObject flipbook, MolangParser parser) throws MolangException
    {
        if (flipbook.has("base_UV") && flipbook.get("base_UV").isJsonArray())
        {
            JsonArray uv = flipbook.getAsJsonArray("base_UV");

            if (uv.size() >= 2)
            {
                this.uvX = parser.parseJson(uv.get(0));
                this.uvY = parser.parseJson(uv.get(1));
            }
        }

        if (flipbook.has("size_UV") && flipbook.get("size_UV").isJsonArray())
        {
            JsonArray uv = flipbook.getAsJsonArray("size_UV");

            if (uv.size() >= 2)
            {
                this.uvW = parser.parseJson(uv.get(0));
                this.uvH = parser.parseJson(uv.get(1));
            }
        }

        if (flipbook.has("step_UV") && flipbook.get("step_UV").isJsonArray())
        {
            JsonArray uv = flipbook.getAsJsonArray("step_UV");

            if (uv.size() >= 2)
            {
                this.stepX = uv.get(0).getAsFloat();
                this.stepY = uv.get(1).getAsFloat();
            }
        }

        if (flipbook.has("frames_per_second")) this.fps = flipbook.get("frames_per_second").getAsFloat();
        if (flipbook.has("max_frame")) this.maxFrame = parser.parseJson(flipbook.get("max_frame"));
        if (flipbook.has("stretch_to_lifetime")) this.stretchFPS = flipbook.get("stretch_to_lifetime").getAsBoolean();
        if (flipbook.has("loop")) this.loop = flipbook.get("loop").getAsBoolean();
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        JsonArray size = new JsonArray();
        JsonObject uv = new JsonObject();

        size.add(this.sizeW.toJson());
        size.add(this.sizeH.toJson());

        /* Adding "uv" properties */
        uv.addProperty("texture_width", this.textureWidth);
        uv.addProperty("texture_height", this.textureHeight);

        if (!this.flipbook && !MolangExpression.isZero(this.uvX) || !MolangExpression.isZero(this.uvY))
        {
            JsonArray uvs = new JsonArray();
            uvs.add(this.uvX.toJson());
            uvs.add(this.uvY.toJson());

            uv.add("uv", uvs);
        }

        if (!this.flipbook && !MolangExpression.isZero(this.uvW) || !MolangExpression.isZero(this.uvH))
        {
            JsonArray uvs = new JsonArray();
            uvs.add(this.uvW.toJson());
            uvs.add(this.uvH.toJson());

            uv.add("uv_size", uvs);
        }

        /* Adding "flipbook" properties to "uv" */
        if (this.flipbook)
        {
            JsonObject flipbook = new JsonObject();

            if (!MolangExpression.isZero(this.uvX) || !MolangExpression.isZero(this.uvY))
            {
                JsonArray base = new JsonArray();
                base.add(this.uvX.toJson());
                base.add(this.uvY.toJson());

                flipbook.add("base_UV", base);
            }

            if (!MolangExpression.isZero(this.uvW) || !MolangExpression.isZero(this.uvH))
            {
                JsonArray uvSize = new JsonArray();
                uvSize.add(this.uvW.toJson());
                uvSize.add(this.uvH.toJson());

                flipbook.add("size_UV", uvSize);
            }

            if (this.stepX != 0 || this.stepY != 0)
            {
                JsonArray step = new JsonArray();
                step.add(this.stepX);
                step.add(this.stepY);

                flipbook.add("step_UV", step);
            }

            if (this.fps != 0) flipbook.addProperty("frames_per_second", this.fps);
            if (!MolangExpression.isZero(this.maxFrame)) flipbook.add("max_frame", this.maxFrame.toJson());
            if (this.stretchFPS) flipbook.addProperty("stretch_to_lifetime", true);
            if (this.loop) flipbook.addProperty("loop", true);

            uv.add("flipbook", flipbook);
        }

        if (this.facing.isDirection)
        {
            JsonObject directionObj = new JsonObject();

            if (this.customDirection)
            {
                directionObj.addProperty("mode", "custom");

                if (this.directionX != MolangParser.ZERO || this.directionY != MolangParser.ZERO || this.directionZ != MolangParser.ZERO)
                {
                    JsonArray directionArray = new JsonArray();
                    directionArray.add(this.directionX.toJson());
                    directionArray.add(this.directionY.toJson());
                    directionArray.add(this.directionZ.toJson());

                    directionObj.add("custom_direction", directionArray);
                }

                object.add("direction", directionObj);
            }
            else if (this.directionSpeedThreshhold != 0.01f)
            {
                directionObj.addProperty("mode", "derive_from_velocity");
                directionObj.addProperty("min_speed_threshold", this.directionSpeedThreshhold);

                object.add("direction", directionObj);
            }
        }

        /* Add main properties */
        object.add("size", size);
        object.addProperty("facing_camera_mode", this.facing.id);
        object.add("uv", uv);

        return object;
    }

    @Override
    public void preRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks)
    {
        this.calculateUVs(particle, partialTicks);

        /* Render the particle */
        double px = Interpolations.lerp(particle.prevPosition.x, particle.position.x, partialTicks);
        double py = Interpolations.lerp(particle.prevPosition.y, particle.position.y, partialTicks);
        double pz = Interpolations.lerp(particle.prevPosition.z, particle.position.z, partialTicks);
        float angle = Interpolations.lerp(particle.prevRotation, particle.rotation, partialTicks);

        Vector3d pos = this.calculatePosition(emitter, particle, px, py, pz);
        px = pos.x;
        py = pos.y;
        pz = pos.z;

        /* Calculate the geometry for billboards using cool matrix math */
        int light = emitter.getBrightnessForRender(partialTicks, px, py, pz);
        int lightX = light >> 16 & 65535;
        int lightY = light & 65535;

        this.calculateFacing(emitter, particle, px, py, pz);

        this.rotation.rotZ(angle / 180 * (float) Math.PI);
        this.transform.mul(this.rotation);
        this.transform.setTranslation(new Vector3f((float) px, (float) py, (float) pz));

        for (Vector4f vertex : this.vertices)
        {
            this.transform.transform(vertex);
        }

        float u1 = this.u1 / (float) this.textureWidth;
        float u2 = this.u2 / (float) this.textureWidth;
        float v1 = this.v1 / (float) this.textureHeight;
        float v2 = this.v2 / (float) this.textureHeight;

        builder.pos(this.vertices[0].x, this.vertices[0].y, this.vertices[0].z).tex(u1, v1).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[1].x, this.vertices[1].y, this.vertices[1].z).tex(u2, v1).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[2].x, this.vertices[2].y, this.vertices[2].z).tex(u2, v2).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[3].x, this.vertices[3].y, this.vertices[3].z).tex(u1, v2).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
    }

    protected void calculateFacing(BedrockEmitter emitter, BedrockParticle particle, double px, double py, double pz)
    {
        /* Calculate yaw and pitch based on the facing mode */
        float cameraYaw = emitter.cYaw;
        float cameraPitch = emitter.cPitch;
        double cameraX = emitter.cX;
        double cameraY = emitter.cY;
        double cameraZ = emitter.cZ;

        /* Flip width when frontal perspective mode */
        if (emitter.perspective == 2)
        {
            this.w = -this.w;
        }
        /* In GUI renderer */
        else if (emitter.perspective == 100 && !this.facing.isLookAt)
        {
            cameraYaw = 180 - cameraYaw;

            this.w = -this.w;
            this.h = -this.h;
        }

        if (this.facing.isLookAt && !this.facing.isDirection)
        {
            double dX = cameraX - px;
            double dY = cameraY - py;
            double dZ = cameraZ - pz;

            double horizontalDistance = MathHelper.sqrt(dX * dX + dZ * dZ);

            cameraYaw = 180 - (float) (MathHelper.atan2(dZ, dX) * (180D / Math.PI)) - 90.0F;
            cameraPitch = (float) (-(MathHelper.atan2(dY, horizontalDistance) * (180D / Math.PI))) + 180;
        }

        if (this.facing.isDirection)
        {
            if (this.customDirection)
            {
                /* evaluate custom direction molang */
                this.direction.x = (float) this.directionX.get();
                this.direction.y = (float) this.directionY.get();
                this.direction.z = (float) this.directionZ.get();
            }
            else if (particle.speed.lengthSquared() > this.directionSpeedThreshhold * this.directionSpeedThreshhold)
            {
                this.direction.set(particle.speed);
                this.direction.normalize();
            }
            else
            {
                this.direction.set(1, 0, 0);
            }

            double lengthSq = this.direction.lengthSquared();
            if (lengthSq < 0.0001)
            {
                this.direction.set(1, 0, 0);
            }
            else if (Math.abs(lengthSq - 1) > 0.0001)
            {
                this.direction.normalize();
            }
        }

        this.calculateVertices(emitter, particle);

        switch (this.facing)
        {
            case ROTATE_XYZ:
            case LOOKAT_XYZ:
                this.rotation.rotY((float) Math.toRadians(cameraYaw));
                this.transform.mul(this.rotation);
                this.rotation.rotX((float) Math.toRadians(cameraPitch));
                this.transform.mul(this.rotation);
                break;
            case ROTATE_Y:
            case LOOKAT_Y:
                this.rotation.rotY((float) Math.toRadians(cameraYaw));
                this.transform.mul(this.rotation);
                break;
            case EMITTER_YZ:
                if (!GuiModelRenderer.isRendering())
                {
                    this.rotation.rotZ((float) Math.toRadians(180));
                    this.transform.mul(this.rotation);
                    this.rotation.rotY((float) Math.toRadians(90));
                    this.transform.mul(this.rotation);
                }
                else
                {
                    this.rotation.rotY((float) Math.toRadians(-90));
                    this.transform.mul(this.rotation);
                }
                break;
            case EMITTER_XZ:
                if (!GuiModelRenderer.isRendering())
                {
                    this.rotation.rotX((float) Math.toRadians(90));
                    this.transform.mul(this.rotation);
                }
                else
                {
                    this.rotation.rotZ((float) Math.toRadians(180));
                    this.transform.mul(this.rotation);
                    this.rotation.rotX((float) Math.toRadians(-90));
                    this.transform.mul(this.rotation);
                }
                break;
            case EMITTER_XY:
                if (!GuiModelRenderer.isRendering())
                {
                    this.rotation.rotX((float) Math.toRadians(180));
                    this.transform.mul(this.rotation);
                }
                else
                {
                    this.rotation.rotY((float) Math.toRadians(180));
                    this.transform.mul(this.rotation);
                }
                break;
            case DIRECTION_X:
                this.rotation.rotY((float) Math.toRadians(this.getYaw()));
                this.transform.mul(this.rotation);
                this.rotation.rotX((float) Math.toRadians(this.getPitch()));
                this.transform.mul(this.rotation);
                this.rotation.rotY((float) Math.toRadians(90));
                this.transform.mul(this.rotation);
                break;
            case DIRECTION_Y:
                this.rotation.rotY((float) Math.toRadians(this.getYaw()));
                this.transform.mul(this.rotation);
                this.rotation.rotX((float) Math.toRadians(this.getPitch() + 90));
                this.transform.mul(this.rotation);
                break;
            case DIRECTION_Z:
                this.rotation.rotY((float) Math.toRadians(this.getYaw()));
                this.transform.mul(this.rotation);
                this.rotation.rotX((float) Math.toRadians(this.getPitch()));
                this.transform.mul(this.rotation);
                break;
            case LOOKAT_DIRECTION:
                this.rotation.setIdentity();
                this.rotation.rotY((float) Math.toRadians(this.getYaw()));
                this.transform.mul(this.rotation);
                this.rotation.rotX((float) Math.toRadians(this.getPitch() + 90));
                this.transform.mul(this.rotation);

                Vector3f cameraDir = new Vector3f(
                        (float) (cameraX - px),
                        (float) (cameraY - py),
                        (float) (cameraZ - pz));

                Vector3f rotatedNormal = new Vector3f(0,0,1);

                this.transform.transform(rotatedNormal);

                /*
                 * The direction vector is the normal of the plane used for calculating the rotation around local y Axis.
                 * Project the cameraDir onto that plane to find out the axis angle (direction vector is the y axis).
                 */
                Vector3f projectDir = new Vector3f(this.direction);
                projectDir.scale(cameraDir.dot(this.direction));
                cameraDir.sub(projectDir);

                if (cameraDir.lengthSquared() < 1.0e-30) break;

                cameraDir.normalize();

                /*
                 * The angle between two vectors is only between 0 and 180 degrees.
                 * RotationDirection will be parallel to direction but pointing in different directions depending
                 * on the rotation of cameraDir. Use this to find out the sign of the angle
                 * between cameraDir and the rotatedNormal.
                 */
                Vector3f rotationDirection = new Vector3f();
                rotationDirection.cross(cameraDir, rotatedNormal);

                this.rotation.rotY(-Math.copySign(cameraDir.angle(rotatedNormal), rotationDirection.dot(this.direction)));
                this.transform.mul(this.rotation);
                break;
            default:
                // Unknown facing mode
                break;
        }
    }

    /**
     * @return the yaw angle in degrees of this {@link #direction}
     */
    private float getYaw()
    {
        double yaw = Math.atan2(-this.direction.x, this.direction.z);
        yaw = Math.toDegrees(yaw);
        if (yaw < -180) {
            yaw += 360;
        } else if (yaw > 180) {
            yaw -= 360;
        }
        return (float) -yaw;
    }

    /**
     * @return the pitch angle in degrees of this {@link #direction}
     */
    private float getPitch()
    {
        double pitch = Math.atan2(this.direction.y, Math.sqrt(this.direction.x * this.direction.x + this.direction.z * this.direction.z));
        return (float) -Math.toDegrees(pitch);
    }

    protected void calculateVertices(BedrockEmitter emitter, BedrockParticle particle)
    {
        this.transform.setIdentity();

        float hw = this.w * 0.5f;
        float hh = this.h * 0.5f;

        if (particle.relativeScaleBillboard)
        {
            hw *= emitter.scale[0];
            hh *= emitter.scale[1];
        }

        this.vertices[0].set(-hw, -hh, 0, 1);
        this.vertices[1].set( hw, -hh, 0, 1);
        this.vertices[2].set( hw,  hh, 0, 1);
        this.vertices[3].set(-hw,  hh, 0, 1);
    }

    protected Vector3d calculatePosition(BedrockEmitter emitter, BedrockParticle particle, double px, double py, double pz)
    {
        if (particle.relativePosition && particle.relativeRotation)
        {
            this.vector.set((float) px, (float) py, (float) pz);

            if (particle.relativeScale)
            {
                Vector3d pos = new Vector3d(px, py, pz);

                Matrix3d scale = new Matrix3d(emitter.scale[0], 0, 0,
                        0, emitter.scale[1], 0,
                        0, 0, emitter.scale[2]);

                scale.transform(pos);

                this.vector.x = (float) pos.x;
                this.vector.y = (float) pos.y;
                this.vector.z = (float) pos.z;
            }

            emitter.rotation.transform(this.vector);

            px = this.vector.x;
            py = this.vector.y;
            pz = this.vector.z;

            px += emitter.lastGlobal.x;
            py += emitter.lastGlobal.y;
            pz += emitter.lastGlobal.z;
        }
        else if (particle.relativeScale)
        {
            Vector3d pos = new Vector3d(px, py, pz);

            Matrix3d scale = new Matrix3d(emitter.scale[0], 0, 0,
                                    0, emitter.scale[1], 0,
                                    0, 0, emitter.scale[2]);

            pos.sub(emitter.lastGlobal); //transform back to local
            scale.transform(pos);
            pos.add(emitter.lastGlobal); //transform back to global

            px = pos.x;
            py = pos.y;
            pz = pos.z;
        }

        return new Vector3d(px, py, pz);
    }

    @Override
    public void renderOnScreen(BedrockParticle particle, int x, int y, float scale, float partialTicks)
    {
        this.calculateUVs(particle, partialTicks);

        this.w = this.h = 0.5F;
        float angle = Interpolations.lerp(particle.prevRotation, particle.rotation, partialTicks);

        /* Calculate the geometry for billboards using cool matrix math */
        float hw = this.w * 0.5f;
        float hh = this.h * 0.5f;
        this.vertices[0].set(-hw, -hh, 0, 1);
        this.vertices[1].set( hw, -hh, 0, 1);
        this.vertices[2].set( hw,  hh, 0, 1);
        this.vertices[3].set(-hw,  hh, 0, 1);

        this.transform.setIdentity();
        this.transform.setScale(scale * 2.75F);
        this.transform.setTranslation(new Vector3f(x, y - scale / 2, 0));

        this.rotation.rotZ(angle / 180 * (float) Math.PI);
        this.transform.mul(this.rotation);

        for (Vector4f vertex : this.vertices)
        {
            this.transform.transform(vertex);
        }

        float u1 = this.u1 / (float) this.textureWidth;
        float u2 = this.u2 / (float) this.textureWidth;
        float v1 = this.v1 / (float) this.textureHeight;
        float v2 = this.v2 / (float) this.textureHeight;

        BufferBuilder builder = Tessellator.getInstance().getBuffer();

        builder.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_COLOR);
        builder.pos(this.vertices[0].x, this.vertices[0].y, this.vertices[0].z).tex(u1, v1).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[1].x, this.vertices[1].y, this.vertices[1].z).tex(u2, v1).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[2].x, this.vertices[2].y, this.vertices[2].z).tex(u2, v2).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[3].x, this.vertices[3].y, this.vertices[3].z).tex(u1, v2).color(particle.r, particle.g, particle.b, particle.a).endVertex();

        Tessellator.getInstance().draw();
    }

    public void calculateUVs(BedrockParticle particle, float partialTicks)
    {
        /* Update particle's UVs and size */
        this.w = (float) this.sizeW.get() * 2.25F;
        this.h = (float) this.sizeH.get() * 2.25F;

        float u = (float) this.uvX.get();
        float v = (float) this.uvY.get();
        float w = (float) this.uvW.get();
        float h = (float) this.uvH.get();

        if (this.flipbook)
        {
            int index = (int) (particle.getAge(partialTicks) * this.fps);
            int max = (int) this.maxFrame.get();

            if (this.stretchFPS)
            {
                float lifetime = (particle.lifetime <= 0) ? 0 : (particle.age + partialTicks) / (particle.lifetime);

                //for particles with expiration - stretch differently since lifetime changed
                if (particle.getExpireAge() != -1)
                {
                    lifetime = (particle.lifetime <= 0) ? 0 : (particle.age + partialTicks) / (particle.getExpirationDelay());
                }

                index = (int) (lifetime * max);
            }

            if (this.loop && max != 0)
            {
                index = index % max;
            }

            if (index > max)
            {
                index = max;
            }

            u += this.stepX * index;
            v += this.stepY * index;
        }

        this.u1 = u;
        this.v1 = v;
        this.u2 = u + w;
        this.v2 = v + h;
    }

    @Override
    public void postRender(BedrockEmitter emitter, float partialTicks)
    {}
}

==================================================

--- Файл №175 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\BedrockComponentAppearanceLighting.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentEmitterInitialize;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;

public class BedrockComponentAppearanceLighting extends BedrockComponentBase implements IComponentEmitterInitialize
{
    @Override
    public void apply(BedrockEmitter emitter)
    {
        emitter.lit = false;
    }

    @Override
    public boolean canBeEmpty()
    {
        return true;
    }
}

==================================================

--- Файл №176 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\BedrockComponentAppearanceTinting.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.BedrockSchemeJsonAdapter;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleRender;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import net.minecraft.client.renderer.BufferBuilder;

public class BedrockComponentAppearanceTinting extends BedrockComponentBase implements IComponentParticleRender
{
    public Tint color = new Tint.Solid();

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("color"))
        {
            JsonElement color = element.get("color");

            if (color.isJsonArray() || color.isJsonPrimitive())
            {
                this.color = Tint.parseColor(color, parser);
            }
            else if (color.isJsonObject())
            {
                this.color = Tint.parseGradient(color.getAsJsonObject(), parser);
            }
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        JsonElement element = this.color.toJson();

        if (!BedrockSchemeJsonAdapter.isEmpty(element))
        {
            object.add("color", element);
        }

        return object;
    }

    /* Interface implementations */

    @Override
    public void preRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks)
    {
        this.renderOnScreen(particle, 0, 0, 0, 0);
    }

    @Override
    public void renderOnScreen(BedrockParticle particle, int x, int y, float scale, float partialTicks)
    {
        if (this.color != null)
        {
            this.color.compute(particle);
        }
        else
        {
            particle.r = particle.g = particle.b = particle.a = 1;
        }
    }

    @Override
    public void postRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public int getSortingIndex()
    {
        return -10;
    }
}

==================================================

--- Файл №177 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\BedrockComponentCollisionAppearance.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.BedrockMaterial;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleRender;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;

import java.util.Map;
import java.util.Set;

import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

public class BedrockComponentCollisionAppearance extends BedrockComponentAppearanceBillboard implements IComponentParticleRender
{
    /* Options */
    public BedrockMaterial material = BedrockMaterial.OPAQUE;
    public ResourceLocation texture = BedrockScheme.DEFAULT_TEXTURE;
    
    public MolangExpression enabled = MolangParser.ZERO;

    public boolean lit; //gets set from GuiCollisionLighting

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("enabled")) this.enabled = parser.parseJson(element.get("enabled"));
        if (element.has("lit"))
        {
            this.lit = element.get("lit").getAsBoolean();
        }
        
        if (element.has("material"))
        {
            this.material = BedrockMaterial.fromString(element.get("material").getAsString());
        }
        
        if (element.has("texture"))
        {
            String texture = element.get("texture").getAsString();

            if (!texture.equals("textures/particle/particles"))
            {
                this.texture = RLUtils.create(texture);
            }
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        
        object.add("enabled", this.enabled.toJson());
        object.addProperty("lit", this.lit);
        object.addProperty("material", this.material.id);
        
        if (this.texture != null && !this.texture.equals(BedrockScheme.DEFAULT_TEXTURE))
        {
            object.addProperty("texture", this.texture.toString());
        }

        /* add the default stuff from super */
        JsonObject superJson = (JsonObject) super.toJson();
        Set<Map.Entry<String, JsonElement>> entries = superJson.entrySet();

        for(Map.Entry<String, JsonElement> entry : entries)
        {
            object.add(entry.getKey(), entry.getValue());
        }

        return object;
    }

    @Override
    public void preRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks)
    {
        boolean tmpLit = false;

        if (!particle.isCollisionTexture(emitter))
        {
            if (particle.isCollisionTinting(emitter))
            {
                tmpLit = emitter.lit;
                emitter.lit = this.lit;
                emitter.scheme.get(BedrockComponentAppearanceBillboard.class).render(emitter, particle, builder, partialTicks);
                emitter.lit = tmpLit;
            }

            return; //when texture and tinting is false - this render method should not be used
        }
        else if (!particle.isCollisionTinting(emitter))
        {
            //tinting false doesn't necessarily mean that lit was not passed - emitter.lit should be used
            tmpLit = this.lit;
            this.lit = emitter.lit;
        }
        
        this.calculateUVs(particle, partialTicks);

        /* Render the particle */
        double px = Interpolations.lerp(particle.prevPosition.x, particle.position.x, partialTicks);
        double py = Interpolations.lerp(particle.prevPosition.y, particle.position.y, partialTicks);
        double pz = Interpolations.lerp(particle.prevPosition.z, particle.position.z, partialTicks);
        float angle = Interpolations.lerp(particle.prevRotation, particle.rotation, partialTicks);

        Vector3d pos = this.calculatePosition(emitter, particle, px, py, pz);
        px = pos.x;
        py = pos.y;
        pz = pos.z;

        /* Calculate the geometry for billboards using cool matrix math */
        int light = this.lit ? 15728880 : emitter.getBrightnessForRender(partialTicks, px, py, pz);
        int lightX = light >> 16 & 65535;
        int lightY = light & 65535;

        this.calculateFacing(emitter, particle, px, py, pz);

        this.rotation.rotZ(angle / 180 * (float) Math.PI);
        this.transform.mul(this.rotation);
        this.transform.setTranslation(new Vector3f((float) px, (float) py, (float) pz));

        for (Vector4f vertex : this.vertices)
        {
            this.transform.transform(vertex);
        }

        float u1 = this.u1 / (float) this.textureWidth;
        float u2 = this.u2 / (float) this.textureWidth;
        float v1 = this.v1 / (float) this.textureHeight;
        float v2 = this.v2 / (float) this.textureHeight;

        builder.pos(this.vertices[0].x, this.vertices[0].y, this.vertices[0].z).tex(u1, v1).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[1].x, this.vertices[1].y, this.vertices[1].z).tex(u2, v1).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[2].x, this.vertices[2].y, this.vertices[2].z).tex(u2, v2).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();
        builder.pos(this.vertices[3].x, this.vertices[3].y, this.vertices[3].z).tex(u1, v2).lightmap(lightX, lightY).color(particle.r, particle.g, particle.b, particle.a).endVertex();

        if (!particle.isCollisionTinting(emitter))
        {
            this.lit = tmpLit;
        }
    }

    @Override //not really important because it seems to be used for guiParticles - there is no collision
    public void renderOnScreen(BedrockParticle particle, int x, int y, float scale, float partialTicks)
    { }

    @Override
    public void calculateUVs(BedrockParticle particle, float partialTicks)
    {
        /* Update particle's UVs and size */
        this.w = (float) this.sizeW.get() * 2.25F;
        this.h = (float) this.sizeH.get() * 2.25F;

        float u = (float) this.uvX.get();
        float v = (float) this.uvY.get();
        float w = (float) this.uvW.get();
        float h = (float) this.uvH.get();

        if (this.flipbook)
        {
            int index = (int) (particle.getAge(partialTicks) * this.fps);
            int max = (int) this.maxFrame.get();

            if (this.stretchFPS)
            {
                float lifetime = (particle.lifetime <= 0) ? 0 : (particle.age + partialTicks) / (particle.lifetime - particle.firstIntersection);

                //for collided particles with expiration - stretch differently since lifetime changed
                if (particle.getExpireAge() != -1)
                {
                    lifetime = (particle.lifetime <= 0) ? 0 : (particle.age + partialTicks) / (particle.getExpirationDelay());
                }

                index = (int) (lifetime * max);
            }

            if (this.loop && max != 0)
            {
                index = index % max;
            }

            if (index > max)
            {
                index = max;
            }

            u += this.stepX * index;
            v += this.stepY * index;
        }

        this.u1 = u;
        this.v1 = v;
        this.u2 = u + w;
        this.v2 = v + h;
    }

    @Override
    public void postRender(BedrockEmitter emitter, float partialTicks)
    {}
    
    @Override
    public int getSortingIndex()
    {
        return 200;
    }
}

==================================================

--- Файл №178 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\BedrockComponentCollisionTinting.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.BedrockSchemeJsonAdapter;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleRender;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import net.minecraft.client.renderer.BufferBuilder;

import java.util.Map;
import java.util.Set;

public class BedrockComponentCollisionTinting extends BedrockComponentAppearanceTinting implements IComponentParticleRender
{
    public MolangExpression enabled = MolangParser.ZERO;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("enabled")) this.enabled = parser.parseJson(element.get("enabled"));

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        
        object.add("enabled", this.enabled.toJson());

        /* add the default stuff from super */
        JsonObject superJson = (JsonObject) super.toJson();
        Set<Map.Entry<String, JsonElement>> entries = superJson.entrySet();

        for(Map.Entry<String, JsonElement> entry : entries)
        {
            object.add(entry.getKey(), entry.getValue());
        }

        return object;
    }

    @Override
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks)
    {
        if (particle.isCollisionTinting(emitter))
        {
            this.renderOnScreen(particle, 0, 0, 0, 0);
        }
    }

    @Override
    public int getSortingIndex()
    {
        return -5;
    }
}

==================================================

--- Файл №179 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\BedrockComponentParticleMorph.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.components.IComponentParticleMorphRender;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.utils.Interpolations;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTException;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Matrix3d;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;

public class BedrockComponentParticleMorph extends BedrockComponentBase implements IComponentParticleMorphRender, IComponentParticleInitialize
{
    public boolean enabled;
    public boolean renderTexture;
    public Morph morph = new Morph();

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("enabled")) this.enabled = element.get("enabled").getAsBoolean();
        if (element.has("render_texture")) this.renderTexture = element.get("render_texture").getAsBoolean();

        if (element.has("nbt"))
        {
            try
            {
                this.morph.setDirect(MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson(element.get("nbt").getAsString())));
            }
            catch(NBTException e) { }
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        object.addProperty("enabled", this.enabled);
        object.addProperty("render_texture", this.renderTexture);
        if (!this.morph.isEmpty()) object.addProperty("nbt", this.morph.toNBT().toString());

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (this.enabled && !this.morph.isEmpty())
        {
            particle.morph.set(MorphUtils.copy(this.morph.get()));
        }
    }

    @SideOnly(Side.CLIENT)
    @Override
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks)
    {
        Entity camera = Minecraft.getMinecraft().getRenderViewEntity();

        if (camera == null || this.morph.isEmpty() || !this.enabled)
        {
            return;
        }

        EntityLivingBase dummy = particle.getDummy(emitter);

        double x = Interpolations.lerp(particle.prevPosition.x, particle.position.x, partialTicks);
        double y = Interpolations.lerp(particle.prevPosition.y, particle.position.y, partialTicks);
        double z = Interpolations.lerp(particle.prevPosition.z, particle.position.z, partialTicks);

        Vector3d position = this.calculatePosition(emitter, particle, x, y, z);
        x = position.x;
        y = position.y;
        z = position.z;

        if (!GuiModelRenderer.isRendering())
        {
            x -= Interpolations.lerp(camera.prevPosX, camera.posX, partialTicks);
            y -= Interpolations.lerp(camera.prevPosY, camera.posY, partialTicks);
            z -= Interpolations.lerp(camera.prevPosZ, camera.posZ, partialTicks);
        }

        int combinedBrightness  = dummy.getBrightnessForRender();
        int brightnessX = combinedBrightness % 65536;
        int brightnessY = combinedBrightness / 65536;

        GlStateManager.color(1, 1, 1, 1);
        RenderHelper.enableStandardItemLighting();
        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, brightnessX, brightnessY);

        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, z);

        if (particle.relativeScaleBillboard)
        {
            GlStateManager.scale(emitter.scale[0], emitter.scale[1], emitter.scale[2]);
        }

        MorphUtils.render(this.morph.get(), dummy, 0, 0, 0, 0, partialTicks);

        RenderHelper.disableStandardItemLighting();
        GlStateManager.popMatrix();
    }

    protected Vector3d calculatePosition(BedrockEmitter emitter, BedrockParticle particle, double px, double py, double pz)
    {
        if (particle.relativePosition && particle.relativeRotation)
        {
            Vector3f vector = new Vector3f((float) px, (float) py, (float) pz);
            emitter.rotation.transform(vector);

            px = vector.x;
            py = vector.y;
            pz = vector.z;

            if (particle.relativeScale)
            {
                Vector3d pos = new Vector3d(px, py, pz);

                Matrix3d scale = new Matrix3d(emitter.scale[0], 0, 0,
                        0, emitter.scale[1], 0,
                        0, 0, emitter.scale[2]);

                scale.transform(pos);

                px = pos.x;
                py = pos.y;
                pz = pos.z;
            }

            px += emitter.lastGlobal.x;
            py += emitter.lastGlobal.y;
            pz += emitter.lastGlobal.z;
        }
        else if (particle.relativeScale)
        {
            Vector3d pos = new Vector3d(px, py, pz);

            Matrix3d scale = new Matrix3d(emitter.scale[0], 0, 0,
                    0, emitter.scale[1], 0,
                    0, 0, emitter.scale[2]);

            pos.sub(emitter.lastGlobal); //transform back to local
            scale.transform(pos);
            pos.add(emitter.lastGlobal); //transform back to global

            px = pos.x;
            py = pos.y;
            pz = pos.z;
        }

        return new Vector3d(px, py, pz);
    }

    @SideOnly(Side.CLIENT)
    @Override
    public void renderOnScreen(BedrockParticle particle, int x, int y, float scale, float partialTicks)
    {
        if (this.enabled && !particle.morph.isEmpty() && particle.morph.get() != null)
        {
            particle.morph.get().renderOnScreen(Minecraft.getMinecraft().player, x, y, scale, 1F);
        }
    }

    @Override
    public void preRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public void postRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public int getSortingIndex()
    {
        return 99;
    }
}


==================================================

--- Файл №180 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\CameraFacing.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

/**
 * Camera facing mode
 */
public enum CameraFacing
{
    ROTATE_XYZ("rotate_xyz"), ROTATE_Y("rotate_y"),
    LOOKAT_XYZ("lookat_xyz", true, false), LOOKAT_Y("lookat_y", true, false), LOOKAT_DIRECTION("lookat_direction", true, true),
    DIRECTION_X("direction_x", false, true), DIRECTION_Y("direction_y", false, true), DIRECTION_Z("direction_z", false, true),
    EMITTER_XY("emitter_transform_xy"), EMITTER_XZ("emitter_transform_xz"), EMITTER_YZ("emitter_transform_yz");

    public final String id;
    public final boolean isLookAt;
    public final boolean isDirection;

    public static CameraFacing fromString(String string)
    {
        for (CameraFacing facing : values())
        {
            if (facing.id.equals(string))
            {
                return facing;
            }
        }

        return ROTATE_XYZ;
    }

    private CameraFacing(String id, boolean isLookAt, boolean isDirection)
    {
        this.id = id;
        this.isLookAt = isLookAt;
        this.isDirection = isDirection;
    }

    private CameraFacing(String id)
    {
        this(id, false, false);
    }

}


==================================================

--- Файл №181 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\appearance\Tint.java
--------------------
package mchorse.blockbuster.client.particles.components.appearance;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import mchorse.blockbuster.client.particles.BedrockSchemeJsonAdapter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.functions.rounding.Round;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;
import org.apache.commons.lang3.StringUtils;

import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

public abstract class Tint
{
    /**
     * Parse a single color either in hex string format or JSON array
     * (this should parse both RGB and RGBA expressions)
     */
    public static Tint.Solid parseColor(JsonElement element, MolangParser parser) throws MolangException
    {
        MolangExpression r = MolangParser.ONE;
        MolangExpression g = MolangParser.ONE;
        MolangExpression b = MolangParser.ONE;
        MolangExpression a = MolangParser.ONE;

        if (element.isJsonPrimitive())
        {
            String hex = element.getAsString();

            if (hex.startsWith("#") && (hex.length() == 7 || hex.length() == 9))
            {
                boolean hasAlpha = hex.length() == 9;

                try
                {
                    /* Apparently, Integer.parseInt() can't parse hex
                     * numbers that are longer than 6 hexadecimals... */
                    int color = Integer.parseInt(hex.substring(hasAlpha ? 3 : 1), 16);
                    float hr = (color >> 16 & 0xff) / 255F;
                    float hg = (color >> 8 & 0xff) / 255F;
                    float hb = (color & 0xff) / 255F;
                    float ha = hasAlpha ? Integer.parseInt(hex.substring(1, 3), 16) / 255F : 1;

                    r = new MolangValue(parser, new Constant(hr));
                    g = new MolangValue(parser, new Constant(hg));
                    b = new MolangValue(parser, new Constant(hb));
                    a = new MolangValue(parser, new Constant(ha));
                }
                catch (Exception e)
                {}
            }
        }
        else if (element.isJsonArray())
        {
            JsonArray array = element.getAsJsonArray();

            if (array.size() == 3 || array.size() == 4)
            {
                r = parser.parseJson(array.get(0));
                g = parser.parseJson(array.get(1));
                b = parser.parseJson(array.get(2));

                if (array.size() == 4)
                {
                    a = parser.parseJson(array.get(3));
                }
            }
        }

        return new Tint.Solid(r, g, b, a);
    }

    /**
     * Parse a gradient
     */
    public static Tint parseGradient(JsonObject color, MolangParser parser) throws MolangException
    {
        JsonElement gradient = color.get("gradient");

        MolangExpression expression = MolangParser.ZERO;
        List<Tint.Gradient.ColorStop> colorStops = new ArrayList<Gradient.ColorStop>();
        boolean equal = true;

        if (gradient.isJsonObject())
        {
            for (Map.Entry<String, JsonElement> entry : gradient.getAsJsonObject().entrySet())
            {
                Tint.Solid stopColor = parseColor(entry.getValue(), parser);

                colorStops.add(new Tint.Gradient.ColorStop(Float.parseFloat(entry.getKey()), stopColor));
            }

            colorStops.sort((a, b) -> Float.compare(a.stop, b.stop));
            equal = false;
        }
        else if (gradient.isJsonArray())
        {
            JsonArray colors = gradient.getAsJsonArray();

            int i = 0;

            for (JsonElement stop : colors)
            {
                colorStops.add(new Tint.Gradient.ColorStop(i / (float) (colors.size() - 1), parseColor(stop, parser)));

                i ++;
            }
        }

        float range = colorStops.get(colorStops.size() - 1).stop;

        for (Gradient.ColorStop stop : colorStops)
        {
            stop.stop /= range;
        }

        if (color.has("interpolant"))
        {
            expression = parser.parseJson(color.get("interpolant"));
        }

        return new Tint.Gradient(colorStops, range, expression, equal);
    }

    public abstract void compute(BedrockParticle particle);

    public abstract JsonElement toJson();

    /**
     * Solid color (not necessarily static)
     */
    public static class Solid extends Tint
    {
        public MolangExpression r;
        public MolangExpression g;
        public MolangExpression b;
        public MolangExpression a;

        public Solid(MolangExpression r, MolangExpression g, MolangExpression b, MolangExpression a)
        {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }

        public Solid()
        {
            this.r = MolangParser.ONE;
            this.g = MolangParser.ONE;
            this.b = MolangParser.ONE;
            this.a = MolangParser.ONE;
        }

        public boolean isConstant()
        {
            return MolangExpression.isExpressionConstant(this.r) && MolangExpression.isExpressionConstant(this.g)
                && MolangExpression.isExpressionConstant(this.b) && MolangExpression.isExpressionConstant(this.a);
        }

        @Override
        public void compute(BedrockParticle particle)
        {
            particle.r = (float) this.r.get();
            particle.g = (float) this.g.get();
            particle.b = (float) this.b.get();
            particle.a = (float) this.a.get();
        }

        @Override
        public JsonElement toJson()
        {
            JsonArray array = new JsonArray();

            if (MolangExpression.isOne(this.r) && MolangExpression.isOne(this.g) && MolangExpression.isOne(this.b) && MolangExpression.isOne(this.a))
            {
                return array;
            }

            array.add(this.r.toJson());
            array.add(this.g.toJson());
            array.add(this.b.toJson());
            array.add(this.a.toJson());

            return array;
        }

        public JsonElement toHexJson()
        {
            int r = (int) (this.r.get() * 255) & 0xff;
            int g = (int) (this.g.get() * 255) & 0xff;
            int b = (int) (this.b.get() * 255) & 0xff;
            int a = (int) (this.a.get() * 255) & 0xff;

            String hex = "#";

            if (a < 255)
            {
                hex += StringUtils.leftPad(Integer.toHexString(a), 2, "0").toUpperCase();
            }

            hex += StringUtils.leftPad(Integer.toHexString(r), 2, "0").toUpperCase();
            hex += StringUtils.leftPad(Integer.toHexString(g), 2, "0").toUpperCase();
            hex += StringUtils.leftPad(Integer.toHexString(b), 2, "0").toUpperCase();

            return new JsonPrimitive(hex);
        }

        public void lerp(BedrockParticle particle, float factor)
        {
            particle.r = Interpolations.lerp(particle.r, (float) this.r.get(), factor);
            particle.g = Interpolations.lerp(particle.g, (float) this.g.get(), factor);
            particle.b = Interpolations.lerp(particle.b, (float) this.b.get(), factor);
            particle.a = Interpolations.lerp(particle.a, (float) this.a.get(), factor);
        }
    }

    /**
     * Gradient color, instead of using formulas, you can just specify a couple of colors
     * and an expression at which color it would stop
     */
    public static class Gradient extends Tint
    {
        public List<ColorStop> stops;
        public MolangExpression interpolant;
        public float range = 1;
        public boolean equal;

        public Gradient(List<ColorStop> stops, float range, MolangExpression interpolant, boolean equal)
        {
            this.stops = stops;
            this.range = range;
            this.interpolant = interpolant;
            this.equal = equal;
        }

        public Gradient()
        {
            this.stops = new ArrayList<>();
            this.stops.add(new ColorStop(0, new Tint.Solid(new MolangValue(null, new Constant(1F)), new MolangValue(null, new Constant(1F)), new MolangValue(null, new Constant(1F)), new MolangValue(null, new Constant(1F)))));
            this.stops.add(new ColorStop(1, new Tint.Solid(new MolangValue(null, new Constant(0F)), new MolangValue(null, new Constant(0F)), new MolangValue(null, new Constant(0F)), new MolangValue(null, new Constant(1F)))));
            this.interpolant = MolangParser.ZERO;
            this.equal = false;
        }

        public void sort()
        {
            this.stops.sort((a, b) -> Float.compare(a.stop, b.stop));
        }

        @Override
        public void compute(BedrockParticle particle)
        {
            int length = this.stops.size();

            if (length == 0)
            {
                particle.r = particle.g = particle.b = particle.a = 1;

                return;
            }
            else if (length == 1)
            {
                this.stops.get(0).color.compute(particle);

                return;
            }

            double factor = this.interpolant.get();

            factor = MathUtils.clamp(factor, 0, 1);

            ColorStop prev = this.stops.get(0);

            if (factor < prev.getStop(this.range))
            {
                prev.color.compute(particle);

                return;
            }

            for (int i = 1; i < length; i ++)
            {
                ColorStop stop = this.stops.get(i);

                if (stop.getStop(this.range) > factor)
                {
                    prev.color.compute(particle);
                    stop.color.lerp(particle, (float) (factor - prev.getStop(this.range)) / (stop.getStop(this.range) - prev.getStop(this.range)));

                    return;
                }

                prev = stop;
            }

            prev.color.compute(particle);
        }

        @Override
        public JsonElement toJson()
        {
            JsonObject object = new JsonObject();
            JsonElement color;

            if (this.equal)
            {
                JsonArray gradient = new JsonArray();

                for (ColorStop stop : this.stops)
                {
                    gradient.add(stop.color.toHexJson());
                }

                color = gradient;
            }
            else
            {
                JsonObject gradient = new JsonObject();

                for (ColorStop stop : this.stops)
                {
                    gradient.add(String.valueOf(stop.getStop(this.range)), stop.color.toHexJson());
                }

                color = gradient;
            }

            if (!BedrockSchemeJsonAdapter.isEmpty(color))
            {
                object.add("gradient", color);
            }

            if (!MolangExpression.isZero(this.interpolant))
            {
                object.add("interpolant", this.interpolant.toJson());
            }

            return object;
        }

        public static class ColorStop
        {
            public float stop;
            public Tint.Solid color;

            public ColorStop(float stop, Tint.Solid color)
            {
                this.stop = stop;
                this.color = color;
            }

            public float getStop(float range)
            {
                return this.stop * range;
            }
        }
    }
}

==================================================

--- Файл №182 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\expiration\BedrockComponentExpireBlocks.java
--------------------
package mchorse.blockbuster.client.particles.components.expiration;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.registry.ForgeRegistries;

import javax.vecmath.Vector3d;
import java.util.ArrayList;
import java.util.List;

public abstract class BedrockComponentExpireBlocks extends BedrockComponentBase
{
    public List<Block> blocks = new ArrayList<Block>();

    private BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();

    @Override
    public BedrockComponentBase fromJson(JsonElement element, MolangParser parser) throws MolangException
    {
        if (element.isJsonArray())
        {
            for (JsonElement value : element.getAsJsonArray())
            {
                ResourceLocation location = new ResourceLocation(value.getAsString());
                Block block = ForgeRegistries.BLOCKS.getValue(location);

                if (block != null)
                {
                    this.blocks.add(block);
                }
            }
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonArray array = new JsonArray();

        for (Block block : this.blocks)
        {
            ResourceLocation rl = ForgeRegistries.BLOCKS.getKey(block);

            if (rl != null)
            {
                array.add(rl.toString());
            }
        }

        return array;
    }

    public Block getBlock(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (emitter.world == null)
        {
            return Blocks.AIR;
        }

        Vector3d position = particle.getGlobalPosition(emitter);

        this.pos.setPos(position.getX(), position.getY(), position.getZ());

        return emitter.world.getBlockState(this.pos).getBlock();
    }
}

==================================================

--- Файл №183 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\expiration\BedrockComponentExpireInBlocks.java
--------------------
package mchorse.blockbuster.client.particles.components.expiration;

import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import net.minecraft.block.Block;

public class BedrockComponentExpireInBlocks extends BedrockComponentExpireBlocks implements IComponentParticleUpdate
{
    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (particle.dead || emitter.world == null)
        {
            return;
        }

        Block current = this.getBlock(emitter, particle);

        for (Block block : this.blocks)
        {
            if (block == current)
            {
                particle.dead = true;

                return;
            }
        }
    }
}

==================================================

--- Файл №184 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\expiration\BedrockComponentExpireNotInBlocks.java
--------------------
package mchorse.blockbuster.client.particles.components.expiration;

import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import net.minecraft.block.Block;

public class BedrockComponentExpireNotInBlocks extends BedrockComponentExpireBlocks implements IComponentParticleUpdate
{
    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (particle.dead || emitter.world == null)
        {
            return;
        }

        Block current = this.getBlock(emitter, particle);

        for (Block block : this.blocks)
        {
            if (block == current)
            {
                return;
            }
        }

        particle.dead = true;
    }
}

==================================================

--- Файл №185 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\expiration\BedrockComponentKillPlane.java
--------------------
package mchorse.blockbuster.client.particles.components.expiration;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;

import javax.vecmath.Vector3d;

public class BedrockComponentKillPlane extends BedrockComponentBase implements IComponentParticleUpdate
{
    public float a;
    public float b;
    public float c;
    public float d;

    @Override
    public BedrockComponentBase fromJson(JsonElement element, MolangParser parser) throws MolangException
    {
        if (!element.isJsonArray())
        {
            return super.fromJson(element, parser);
        }

        JsonArray array = element.getAsJsonArray();

        if (array.size() >= 4)
        {
            this.a = array.get(0).getAsFloat();
            this.b = array.get(1).getAsFloat();
            this.c = array.get(2).getAsFloat();
            this.d = array.get(3).getAsFloat();
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonArray array = new JsonArray();

        if (Operation.equals(this.a, 0) && Operation.equals(this.b, 0) && Operation.equals(this.c, 0) && Operation.equals(this.d, 0))
        {
            return array;
        }

        array.add(this.a);
        array.add(this.b);
        array.add(this.c);
        array.add(this.d);

        return array;
    }

    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (particle.dead)
        {
            return;
        }

        Vector3d prevLocal = new Vector3d(particle.prevPosition);
        Vector3d local = new Vector3d(particle.position);

        if (!particle.relativePosition)
        {
            local.sub(emitter.lastGlobal);
            prevLocal.sub(emitter.lastGlobal);
        }

        double prev = this.a * prevLocal.x + this.b * prevLocal.y + this.c * prevLocal.z + this.d;
        double now = this.a * local.x + this.b * local.y + this.c * local.z + this.d;

        if ((prev > 0 && now < 0) || (prev < 0 && now > 0))
        {
            particle.dead = true;
        }
    }

    @Override
    public int getSortingIndex()
    {
        return 100;
    }
}

==================================================

--- Файл №186 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\expiration\BedrockComponentParticleLifetime.java
--------------------
package mchorse.blockbuster.client.particles.components.expiration;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentParticleLifetime extends BedrockComponentBase implements IComponentParticleInitialize, IComponentParticleUpdate
{
    public MolangExpression expression = MolangParser.ZERO;
    public boolean max;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();
        JsonElement expression = null;

        if (element.has("expiration_expression"))
        {
            expression = element.get("expiration_expression");
            this.max = false;
        }
        else if (element.has("max_lifetime"))
        {
            expression = element.get("max_lifetime");
            this.max = true;
        }
        else
        {
            throw new JsonParseException("No expiration_expression or max_lifetime was found in minecraft:particle_lifetime_expression component");
        }

        this.expression = parser.parseJson(expression);

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        object.add(this.max ? "max_lifetime" : "expiration_expression", this.expression.toJson());

        return object;
    }

    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (!this.max && this.expression.get() != 0)
        {
            particle.dead = true;
        }
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (this.max)
        {
            particle.lifetime = (int) (this.expression.get() * 20);
        }
        else
        {
            particle.lifetime = -1;
        }
    }
}

==================================================

--- Файл №187 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\lifetime\BedrockComponentLifetime.java
--------------------
package mchorse.blockbuster.client.particles.components.lifetime;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentEmitterUpdate;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;

public abstract class BedrockComponentLifetime extends BedrockComponentBase implements IComponentEmitterUpdate
{
    public static final MolangExpression DEFAULT_ACTIVE = new MolangValue(null, new Constant(10));

    public MolangExpression activeTime = DEFAULT_ACTIVE;

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject())
        {
            return super.fromJson(elem, parser);
        }

        JsonObject element = elem.getAsJsonObject();

        if (element.has(this.getPropertyName()))
        {
            this.activeTime = parser.parseJson(element.get(this.getPropertyName()));
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (!MolangExpression.isConstant(this.activeTime, 10))
        {
            object.add(this.getPropertyName(), this.activeTime.toJson());
        }

        return object;
    }

    protected String getPropertyName()
    {
        return "active_time";
    }

    @Override
    public int getSortingIndex()
    {
        return -10;
    }
}

==================================================

--- Файл №188 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\lifetime\BedrockComponentLifetimeExpression.java
--------------------
package mchorse.blockbuster.client.particles.components.lifetime;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentLifetimeExpression extends BedrockComponentLifetime
{
    public MolangExpression expiration = MolangParser.ZERO;

    @Override
    protected String getPropertyName()
    {
        return "activation_expression";
    }

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject())
        {
            return super.fromJson(elem, parser);
        }

        JsonObject element = elem.getAsJsonObject();

        if (element.has("expiration_expression"))
        {
            this.expiration = parser.parseJson(element.get("expiration_expression"));
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = (JsonObject) super.toJson();

        if (!MolangExpression.isZero(this.expiration))
        {
            object.add("expiration_expression", this.expiration.toJson());
        }

        return object;
    }

    @Override
    public void update(BedrockEmitter emitter)
    {
        if (!Operation.equals(this.activeTime.get(), 0))
        {
            emitter.start();
        }

        if (!Operation.equals(this.expiration.get(), 0))
        {
            emitter.stop();
        }
    }
}

==================================================

--- Файл №189 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\lifetime\BedrockComponentLifetimeLooping.java
--------------------
package mchorse.blockbuster.client.particles.components.lifetime;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentLifetimeLooping extends BedrockComponentLifetime
{
    public MolangExpression sleepTime = MolangParser.ZERO;

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject())
        {
            return super.fromJson(elem, parser);
        }

        JsonObject element = elem.getAsJsonObject();

        if (element.has("sleep_time"))
        {
            this.sleepTime = parser.parseJson(element.get("sleep_time"));
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = (JsonObject) super.toJson();

        if (!MolangExpression.isZero(this.sleepTime))
        {
            object.add("sleep_time", this.sleepTime.toJson());
        }

        return object;
    }

    @Override
    public void update(BedrockEmitter emitter)
    {
        double active = this.activeTime.get();
        double sleep = this.sleepTime.get();
        double age = emitter.getAge();

        emitter.lifetime = (int) (active * 20);

        if (age >= active && emitter.playing)
        {
            emitter.stop();
        }

        if (age >= sleep && !emitter.playing)
        {
            emitter.start();
        }
    }
}

==================================================

--- Файл №190 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\lifetime\BedrockComponentLifetimeOnce.java
--------------------
package mchorse.blockbuster.client.particles.components.lifetime;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;

public class BedrockComponentLifetimeOnce extends BedrockComponentLifetime
{
    @Override
    public void update(BedrockEmitter emitter)
    {
        double time = this.activeTime.get();

        emitter.lifetime = (int) (time * 20);

        if (emitter.getAge() >= time)
        {
            emitter.stop();
        }
    }
}

==================================================

--- Файл №191 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\meta\BedrockComponentInitialization.java
--------------------
package mchorse.blockbuster.client.particles.components.meta;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentEmitterInitialize;
import mchorse.blockbuster.client.particles.components.IComponentEmitterUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangAssignment;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangMultiStatement;

import java.util.Map;

public class BedrockComponentInitialization extends BedrockComponentBase implements IComponentEmitterInitialize, IComponentEmitterUpdate
{
    /* Standard BedrockEdition variables - global inside an emitter */
    public MolangExpression creation = MolangParser.ZERO;
    public MolangExpression update = MolangParser.ZERO;

    /* Blockbuster specific expression - local inside a particle (added by Chryfi) */
    public MolangExpression particleUpdate = MolangParser.ZERO;

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("creation_expression")) this.creation = parser.parseGlobalJson(element.get("creation_expression"));
        if (element.has("per_update_expression")) this.update = parser.parseGlobalJson(element.get("per_update_expression"));
        if (element.has("particle_update_expression")) this.particleUpdate = parser.parseGlobalJson(element.get("particle_update_expression"));

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (!MolangExpression.isZero(this.creation)) object.add("creation_expression", this.creation.toJson());
        if (!MolangExpression.isZero(this.update)) object.add("per_update_expression", this.update.toJson());
        if (!MolangExpression.isZero(this.particleUpdate)) object.add("particle_update_expression", this.particleUpdate.toJson());

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter)
    {
        emitter.initialValues.clear();

        this.creation.get();
        this.cacheInitialValues(this.creation, emitter);

        if (emitter.variables != null)
        {
            for (Map.Entry<String, IValue> entry : emitter.variables.entrySet())
            {
                emitter.initialValues.put(entry.getKey(), entry.getValue().get().doubleValue());
            }
        }
    }

    @Override
    public void update(BedrockEmitter emitter)
    {
        this.update.get();
        this.cacheInitialValues(this.update, emitter);

        emitter.replaceVariables();
    }

    private void cacheInitialValues(MolangExpression e, BedrockEmitter emitter)
    {
        if (e instanceof MolangMultiStatement)
        {
            MolangMultiStatement statement = (MolangMultiStatement) e;

            for (MolangExpression expression : statement.expressions)
            {
                if (expression instanceof MolangAssignment)
                {
                    this.cacheInitialValue((MolangAssignment) expression, emitter);
                }
            }
        }
        else if (e instanceof MolangAssignment)
        {
            this.cacheInitialValue((MolangAssignment) e, emitter);
        }
    }

    private void cacheInitialValue(MolangAssignment assignment, BedrockEmitter emitter)
    {
        emitter.initialValues.put(assignment.variable.getName(), assignment.variable.get().doubleValue());
    }
}

==================================================

--- Файл №192 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\meta\BedrockComponentLocalSpace.java
--------------------
package mchorse.blockbuster.client.particles.components.meta;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;

public class BedrockComponentLocalSpace extends BedrockComponentBase implements IComponentParticleInitialize
{
    public boolean position;
    public boolean rotation;
    public boolean scale;
    public boolean scaleBillboard;
    public boolean direction;
    public boolean acceleration;
    public boolean gravity;
    public float linearVelocity;
    public float angularVelocity;
    
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("position")) this.position = element.get("position").getAsBoolean();
        if (element.has("rotation")) this.rotation = element.get("rotation").getAsBoolean();
        if (element.has("scale")) this.scale = element.get("scale").getAsBoolean();
        if (element.has("scale_billboard")) this.scaleBillboard = element.get("scale_billboard").getAsBoolean();
        if (element.has("direction")) this.direction = element.get("direction").getAsBoolean();
        if (element.has("acceleration")) this.acceleration = element.get("acceleration").getAsBoolean();
        if (element.has("gravity")) this.gravity = element.get("gravity").getAsBoolean();
        if (element.has("linear_velocity")) this.linearVelocity = element.get("linear_velocity").getAsFloat();
        if (element.has("angular_velocity")) this.angularVelocity = element.get("angular_velocity").getAsFloat();

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (this.position) object.addProperty("position", true);
        if (this.rotation) object.addProperty("rotation", true);
        if (this.scale) object.addProperty("scale", true);
        if (this.scaleBillboard) object.addProperty("scale_billboard", true);
        if (this.direction) object.addProperty("direction", true);
        if (this.acceleration) object.addProperty("acceleration", true);
        if (this.gravity) object.addProperty("gravity", true);
        if (this.linearVelocity!=0) object.addProperty("linear_velocity", this.linearVelocity);
        if (this.angularVelocity!=0) object.addProperty("angular_velocity", this.angularVelocity);

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        particle.relativePosition = this.position;
        particle.relativeRotation = this.rotation;
        particle.relativeScale = this.scale;
        particle.relativeScaleBillboard = this.scaleBillboard;
        particle.relativeDirection = this.direction;
        particle.relativeAcceleration = this.acceleration;
        particle.gravity = this.gravity;
        particle.linearVelocity = this.linearVelocity;
        particle.angularVelocity = this.angularVelocity;

        particle.setupMatrix(emitter);
    }

    @Override
    public int getSortingIndex()
    {
        return 6;
    }
}


==================================================

--- Файл №193 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\motion\BedrockComponentInitialSpeed.java
--------------------
package mchorse.blockbuster.client.particles.components.motion;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentInitialSpeed extends BedrockComponentBase implements IComponentParticleInitialize
{
    public MolangExpression speed = MolangParser.ONE;
    public MolangExpression[] direction;

    @Override
    public BedrockComponentBase fromJson(JsonElement element, MolangParser parser) throws MolangException
    {
        if (element.isJsonArray())
        {
            JsonArray array = element.getAsJsonArray();

            if (array.size() >= 3)
            {
                this.direction = new MolangExpression[] {parser.parseJson(array.get(0)), parser.parseJson(array.get(1)), parser.parseJson(array.get(2))};
            }
        }
        else if (element.isJsonPrimitive())
        {
            this.speed = parser.parseJson(element);
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        if (this.direction != null)
        {
            JsonArray array = new JsonArray();

            for (MolangExpression expression : this.direction)
            {
                array.add(expression.toJson());
            }

            return array;
        }

        return this.speed.toJson();
    }

    @Override
    public boolean canBeEmpty()
    {
        return true;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        if (this.direction != null)
        {
            particle.speed.set(
                (float) this.direction[0].get(),
                (float) this.direction[1].get(),
                (float) this.direction[2].get()
            );
        }
        else
        {
            float speed = (float) this.speed.get();

            particle.speed.scale(speed);
        }
    }

    @Override
    public int getSortingIndex()
    {
        return 5;
    }
}

==================================================

--- Файл №194 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\motion\BedrockComponentInitialSpin.java
--------------------
package mchorse.blockbuster.client.particles.components.motion;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentInitialSpin extends BedrockComponentBase implements IComponentParticleInitialize
{
    public MolangExpression rotation = MolangParser.ZERO;
    public MolangExpression rate = MolangParser.ZERO;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("rotation")) this.rotation = parser.parseJson(element.get("rotation"));
        if (element.has("rotation_rate")) this.rate = parser.parseJson(element.get("rotation_rate"));

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (!MolangExpression.isZero(this.rotation)) object.add("rotation", this.rotation.toJson());
        if (!MolangExpression.isZero(this.rate)) object.add("rotation_rate", this.rate.toJson());

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        particle.initialRotation = (float) this.rotation.get();
        particle.rotationVelocity = (float) this.rate.get() / 20;
    }
}

==================================================

--- Файл №195 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\motion\BedrockComponentMotion.java
--------------------
package mchorse.blockbuster.client.particles.components.motion;

import mchorse.blockbuster.client.particles.components.BedrockComponentBase;

public abstract class BedrockComponentMotion extends BedrockComponentBase
{}

==================================================

--- Файл №196 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\motion\BedrockComponentMotionCollision.java
--------------------
package mchorse.blockbuster.client.particles.components.motion;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.blockbuster.utils.EntityTransformationUtils;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.MorphUtils;
import net.minecraft.entity.Entity;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;

import javax.annotation.Nullable;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import java.util.HashMap;
import java.util.List;

public class BedrockComponentMotionCollision extends BedrockComponentBase implements IComponentParticleUpdate
{
    public MolangExpression enabled = MolangParser.ONE;
    public boolean preserveEnergy = false;
    public boolean entityCollision;
    public boolean momentum;
    public float collisionDrag = 0;
    public float bounciness = 1;
    public float randomBounciness = 0;
    public float randomDamp = 0;
    public float damp = 0; // should be like in Blender
    public int splitParticleCount;
    public float splitParticleSpeedThreshold; // threshold to activate the split
    public float radius = 0.01F;
    public boolean expireOnImpact;
    public MolangExpression expirationDelay = MolangParser.ZERO;
    public boolean realisticCollision;
    public boolean realisticCollisionDrag;
    public float rotationCollisionDrag;

    /* Runtime options */
    private Vector3d previous = new Vector3d();
    private Vector3d current = new Vector3d();
    private BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos();

    public static float getComponent(Vector3f vector, EnumFacing.Axis component)
    {
        if (component == EnumFacing.Axis.X)
        {
            return vector.x;
        }
        else if (component == EnumFacing.Axis.Y)
        {
            return vector.y;
        }

        return vector.z;
    }

    public static void setComponent(Vector3f vector, EnumFacing.Axis component, float value)
    {
        if (component == EnumFacing.Axis.X)
        {
            vector.x = value;
        }
        else if (component == EnumFacing.Axis.Y)
        {
            vector.y = value;
        }
        else
        {
            vector.z = value;
        }
    }
    
    public static void negateComponent(Vector3f vector, EnumFacing.Axis component) 
    {
        setComponent(vector, component, -getComponent(vector, component));
    }

    public static double getComponent(Vector3d vector, EnumFacing.Axis component)
    {
        if (component == EnumFacing.Axis.X)
        {
            return vector.x;
        }
        else if (component == EnumFacing.Axis.Y)
        {
            return vector.y;
        }

        return vector.z;
    }

    public static void setComponent(Vector3d vector, EnumFacing.Axis component, double value)
    {
        if (component == EnumFacing.Axis.X)
        {
            vector.x = value;
        }
        else if (component == EnumFacing.Axis.Y)
        {
            vector.y = value;
        }
        else
        {
            vector.z = value;
        }
    }
    
    public static void negateComponent(Vector3d vector, EnumFacing.Axis component) 
    {
        setComponent(vector, component, -getComponent(vector, component));
    }

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("enabled")) this.enabled = parser.parseJson(element.get("enabled"));
        if (element.has("entityCollision")) this.entityCollision = element.get("entityCollision").getAsBoolean();
        if (element.has("momentum")) this.momentum = element.get("momentum").getAsBoolean();
        if (element.has("realistic_collision_drag")) this.realisticCollisionDrag = element.get("realistic_collision_drag").getAsBoolean();
        if (element.has("collision_drag")) this.collisionDrag = element.get("collision_drag").getAsFloat();
        if (element.has("coefficient_of_restitution")) this.bounciness = element.get("coefficient_of_restitution").getAsFloat();
        if (element.has("bounciness_randomness")) this.randomBounciness = element.get("bounciness_randomness").getAsFloat();
        if (element.has("collision_rotation_drag")) this.rotationCollisionDrag = element.get("collision_rotation_drag").getAsFloat();
        if (element.has("preserveEnergy") && element.get("preserveEnergy").isJsonPrimitive())
        {
            JsonPrimitive energy = element.get("preserveEnergy").getAsJsonPrimitive();

            if (energy.isBoolean())
            {
                this.preserveEnergy = energy.getAsBoolean();
            }
            else
            {
                this.preserveEnergy = MolangExpression.isOne(parser.parseJson(energy));
            }
        }
        if (element.has("damp")) this.damp = element.get("damp").getAsFloat();
        if (element.has("random_damp")) this.randomDamp = element.get("random_damp").getAsFloat();
        if (element.has("split_particle_count")) this.splitParticleCount = element.get("split_particle_count").getAsInt();
        if (element.has("split_particle_speedThreshold")) this.splitParticleSpeedThreshold = element.get("split_particle_speedThreshold").getAsFloat();
        if (element.has("collision_radius")) this.radius = element.get("collision_radius").getAsFloat();
        if (element.has("expire_on_contact")) this.expireOnImpact = element.get("expire_on_contact").getAsBoolean();
        if (element.has("expirationDelay")) this.expirationDelay = parser.parseJson(element.get("expirationDelay"));
        if (element.has("realisticCollision")) this.realisticCollision = element.get("realisticCollision").getAsBoolean();

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (!MolangExpression.isOne(this.enabled)) object.add("enabled", this.enabled.toJson());
        if (this.realisticCollision) object.addProperty("realisticCollision", true);
        if (this.entityCollision) object.addProperty("entityCollision", true);
        if (this.momentum) object.addProperty("momentum", true);
        if (this.realisticCollisionDrag) object.addProperty("realistic_collision_drag", true);
        if (this.collisionDrag != 0) object.addProperty("collision_drag", this.collisionDrag);
        if (this.bounciness != 1) object.addProperty("coefficient_of_restitution", this.bounciness);
        if (this.rotationCollisionDrag != 0) object.addProperty("collision_rotation_drag", this.rotationCollisionDrag);
        if (this.randomBounciness != 0) object.addProperty("bounciness_randomness", this.randomBounciness);
        if (this.preserveEnergy) object.addProperty("preserveEnergy", this.preserveEnergy);
        if (this.damp != 0) object.addProperty("damp", this.damp);
        if (this.randomDamp != 0) object.addProperty("random_damp", this.randomDamp);
        if (this.splitParticleCount != 0) object.addProperty("split_particle_count", this.splitParticleCount);
        if (this.splitParticleSpeedThreshold != 0) object.addProperty("split_particle_speedThreshold", this.splitParticleSpeedThreshold);
        if (this.radius != 0.01F) object.addProperty("collision_radius", this.radius);
        if (this.expireOnImpact) object.addProperty("expire_on_contact", true);
        if (!MolangExpression.isZero(this.expirationDelay)) object.add("expirationDelay", this.expirationDelay.toJson());

        return object;
    }

    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        particle.realisticCollisionDrag = this.realisticCollisionDrag;

        if (emitter.world == null)
        {
            return;
        }

        float r = this.radius;

        this.previous.set(particle.getGlobalPosition(emitter, particle.prevPosition));
        this.current.set(particle.getGlobalPosition(emitter));

        Vector3d prev = this.previous;
        Vector3d now = this.current;

        double x = now.x - prev.x;
        double y = now.y - prev.y;
        double z = now.z - prev.z;
        boolean veryBig = Math.abs(x) > 10 || Math.abs(y) > 10 || Math.abs(z) > 10;

        this.pos.setPos(now.x, now.y, now.z);

        if (veryBig || !emitter.world.isBlockLoaded(this.pos))
        {
            return;
        }

        AxisAlignedBB aabb = new AxisAlignedBB(prev.x - r, prev.y - r, prev.z - r, prev.x + r, prev.y + r, prev.z + r);

        double d0 = y;
        double origX = x;
        double origZ = z;

        List<Entity> entities = emitter.world.getEntitiesWithinAABB(Entity.class, aabb.expand(x, y, z));
        HashMap<Entity, AxisAlignedBB> entityAABBs = new HashMap<Entity, AxisAlignedBB>();
        HashMap<Entity, CollisionOffset> staticEntityAABBs = new HashMap<>(); //for newtons first law
        /* for own hitbox implementation: check for hitbox expanded for the previous position - prevent fast moving tunneling */
        List<AxisAlignedBB> list = emitter.world.getCollisionBoxes(null, aabb.expand(x, y, z));

        if ((!list.isEmpty() || (!entities.isEmpty() && this.entityCollision)) && !particle.intersected)
        {
            particle.firstIntersection = particle.age;
            particle.intersected = true;
        }

        if (!particle.manual && !Operation.equals(this.enabled.get(), 0))
        {
            if (this.entityCollision)
            {
                for (Entity entity : entities)
                {
                    AxisAlignedBB aabb2 = new AxisAlignedBB(prev.x - r, prev.y - r, prev.z - r, prev.x + r, prev.y + r, prev.z + r);
                    AxisAlignedBB entityAABB = entity.getEntityBoundingBox();

                    double y2 = y, x2 = x, z2 = z;

                    y2 = entityAABB.calculateYOffset(aabb2, y2);
                    aabb2 = aabb2.offset(0.0D, y2, 0.0D);

                    x2 = entityAABB.calculateXOffset(aabb2, x2);
                    aabb2 = aabb2.offset(x2, 0.0D, 0.0D);

                    z2 = entityAABB.calculateZOffset(aabb2, z2);
                    aabb2 = aabb2.offset(0.0D, 0.0D, z2);

                    if (d0 == y2 && origX == x2 && origZ == z2)
                    {
                        entityAABBs.put(entity, entityAABB); //Note to myself: maybe start already here with collision response?
                    }
                    else
                    {
                        list.add(entityAABB);
                        staticEntityAABBs.put(entity, new CollisionOffset(entityAABB, x2, y2, z2));

                        if (this.momentum && d0 == y2)
                        {
                            momentum(particle,entity);
                        }
                    }
                }
            }

            CollisionOffset offsetData = calculateOffsets(aabb, list, x, y, z);
            aabb = offsetData.aabb;
            x = offsetData.x;
            y = offsetData.y;
            z = offsetData.z;

            if (d0 != y || origX != x || origZ != z)
            {
                this.collision(particle, emitter, prev);

                now.set(aabb.minX + r, aabb.minY + r, aabb.minZ + r);

                if (d0 != y)
                {
                    if (d0 < y) now.y = aabb.minY;
                    else now.y = aabb.maxY;

                    now.y += d0 < y ? r : -r;

                    this.collisionHandler(particle, emitter, EnumFacing.Axis.Y, now, prev);

                    /* here comes inertia */
                    /* remove unecessary elements from collisionTime*/
                    particle.entityCollisionTime.keySet().retainAll(staticEntityAABBs.keySet());

                    for (HashMap.Entry<Entity, CollisionOffset> entry : staticEntityAABBs.entrySet())
                    {
                        CollisionOffset offsetData2 = entry.getValue();
                        AxisAlignedBB entityAABB = offsetData2.aabb;
                        Entity collidingEntity = entry.getKey();

                        if (d0 != offsetData2.y && origX == offsetData2.x && origZ == offsetData2.z)
                        {
                            inertia(particle, collidingEntity, now);
                        }

                        if (particle.entityCollisionTime.containsKey(collidingEntity))
                        {
                            particle.entityCollisionTime.get(collidingEntity).y = particle.age;
                        }
                        else
                        {
                            particle.entityCollisionTime.put(entry.getKey(), new Vector3f(-1F, particle.age, -1F));
                        }
                    }
                }

                if (origX != x)
                {
                    if (origX < x) now.x = aabb.minX;
                    else now.x = aabb.maxX;

                    now.x += origX < x ? r : -r;

                    collisionHandler(particle, emitter, EnumFacing.Axis.X, now, prev);
                }

                if (origZ != z)
                {
                    if (origZ < z) now.z = aabb.minZ;
                    else now.z = aabb.maxZ;

                    now.z += origZ < z ? r : -r;

                    collisionHandler(particle, emitter, EnumFacing.Axis.Z, now, prev);
                }

                particle.position.set(now);

                drag(particle);
            }
            else if (entityAABBs.isEmpty() && this.realisticCollisionDrag) //no collision - reset collision drag
            {
                particle.dragFactor = 0;
            }
            else
            {
                particle.rotationCollisionDrag = 0;
            }


            for (HashMap.Entry<Entity, AxisAlignedBB> entry : entityAABBs.entrySet())
            {
                AxisAlignedBB entityAABB = entry.getValue();
                Entity entity = entry.getKey();

                Vector3f speedEntity = new Vector3f((float) (entity.posX - entity.prevPosX), (float) (entity.posY - entity.prevPosY), (float) (entity.posZ - entity.prevPosZ));
                Vector3f ray;

                if (speedEntity.x != 0 || speedEntity.y != 0 || speedEntity.z != 0)
                {
                    ray = speedEntity;
                }
                else
                {
                    /* fixes the issue of particles falling through the entity
                     * when they lie on the surface while the hitbox changes
                     * downside: the position is not always accurate depending on the movement*/

                    /*Vector3f particleMotion = new Vector3f();
                    particleMotion.x = (float) (particle.prevPosition.x - particle.position.x);
                    particleMotion.y = (float) (particle.prevPosition.y - particle.position.y);
                    particleMotion.z = (float) (particle.prevPosition.z - particle.position.z);
                    ray = particleMotion;*/
                    continue;
                }

                Vector3d frac = intersect(ray, particle.getGlobalPosition(emitter), entityAABB);

                if (frac != null)
                {
                    particle.position.add(frac);

                    AxisAlignedBB aabb2 = new AxisAlignedBB(particle.position.x - r, particle.position.y - r, particle.position.z - r, particle.position.x + r, particle.position.y + r, particle.position.z + r);

                    collision(particle, emitter, prev);

                    if ((aabb2.minX < entityAABB.maxX && aabb2.maxX > entityAABB.maxX) || (aabb2.maxX > entityAABB.minX && aabb2.minX < entityAABB.minX))
                    {
                        entityCollision(particle, emitter, entity, EnumFacing.Axis.X, prev);
                    }

                    if ((aabb2.minY < entityAABB.maxY && aabb2.maxY > entityAABB.maxY) || (aabb2.maxY > entityAABB.minY && aabb2.minY < entityAABB.minY))
                    {
                        entityCollision(particle, emitter, entity, EnumFacing.Axis.Y, prev);
                    }

                    if ((aabb2.minZ < entityAABB.maxZ && aabb2.maxZ > entityAABB.maxZ) || (aabb2.maxZ > entityAABB.minZ && aabb2.minZ < entityAABB.minZ))
                    {
                        entityCollision(particle, emitter, entity, EnumFacing.Axis.Z, prev);
                    }
                }
            }

            if (!entityAABBs.isEmpty())
            {
                this.drag(particle);
            }
        }
    }

    public void collision(BedrockParticle particle, BedrockEmitter emitter, Vector3d prev)
    {
        if (this.expireOnImpact)
        {
            double expirationDelay = this.expirationDelay.get();

            if (expirationDelay != 0 && !particle.collided)
            {
                particle.setExpirationDelay(expirationDelay);
            }
            else if (expirationDelay == 0 && !particle.collided)
            {
                particle.dead = true;

                return;
            }
        }

        if (particle.relativePosition)
        {
            particle.relativePosition = false;
            particle.prevPosition.set(prev);
        }

        particle.rotationCollisionDrag = this.rotationCollisionDrag;
        particle.collided = true;
    }
    
    public void entityCollision(BedrockParticle particle, BedrockEmitter emitter, Entity entity, EnumFacing.Axis component, Vector3d prev) 
    {
        Vector3f entitySpeed = new Vector3f((float) (entity.posX - entity.prevPosX), (float) (entity.posY - entity.prevPosY), (float) (entity.posZ - entity.prevPosZ));
        Vector3d entityPosition = new Vector3d(entity.posX, entity.posY,entity.posZ);

        if (this.momentum)
        {
            momentum(particle,entity);
        }

        /* collisionTime should be not changed - otherwise the particles will stop when moving against moving entites */
        float tmpTime = getComponent(particle.collisionTime, component);
        double delta = getComponent(particle.position, component) - getComponent(entityPosition, component);

        setComponent(particle.position, component, getComponent(particle.position, component) + (delta > 0 ? this.radius : -this.radius));
        
        collisionHandler(particle, emitter, component, particle.position, prev);

        /* collisionTime should not change or otherwise particles will lose their speed although they should be reflected */
        setComponent(particle.collisionTime, component, tmpTime);

        if (delta > 0 && component == EnumFacing.Axis.Y) //particle is above
        {
            inertia(particle, entity, null);
        }

        /* particle speed is always switched (realistcCollision==true), as it always collides with the entity, but it should only have one correct direction */
        if (getComponent(particle.speed, component) > 0)
        {
            if (getComponent(entitySpeed, component) < 0) negateComponent(particle.speed, component);
        }
        else if (getComponent(particle.speed, component) < 0)
        {
            if (getComponent(entitySpeed, component) > 0) negateComponent(particle.speed, component);
        }

        /* otherwise particles would stick on the body and get reflected when entity stops */
        /* note to myself: when particle lies on top and you fly up it floats weirdly - need to redo this system a little bit*/
        setComponent(particle.position, component, getComponent(particle.position, component) + getComponent(particle.speed, component) / 20F);
    }

    public void collisionHandler(BedrockParticle particle, BedrockEmitter emitter, EnumFacing.Axis component, Vector3d now, Vector3d prev)
    {
        float collisionTime = getComponent(particle.collisionTime, component);
        float speed = getComponent(particle.speed, component);
        float accelerationFactor = getComponent(particle.accelerationFactor, component);

        /* realistic collision */
        if (this.realisticCollision)
        {
            if (collisionTime != (particle.age - 1))
            {
                if (this.bounciness != 0)
                {
                    setComponent(particle.speed, component, -speed * this.bounciness);
                }
            }
            else if (collisionTime == (particle.age - 1))
            {
                setComponent(particle.speed, component, 0); //particle laid on that surface since last tick
            }
        }
        else
        {
            setComponent(particle.accelerationFactor, component, accelerationFactor * -this.bounciness);
        }

        if (collisionTime != (particle.age - 1))
        {
            /* random bounciness */
            if (this.randomBounciness != 0 /* && Math.round(particle.speed.x) != 0 */)
            {
                particle.speed = this.randomBounciness(particle.speed, component, this.randomBounciness);
            }

            /* split particles */
            if (this.splitParticleCount != 0)
            {
                this.splitParticle(particle, emitter, component, now, prev);
            }

            /* damping */
            if (damp != 0)
            {
                particle.speed = this.damping(particle.speed);
            }
        }

        if (collisionTime != particle.age - 1)
        {
            particle.bounces++;
        }

        setComponent(particle.collisionTime, component, particle.age);
    }

    public void inertia(BedrockParticle particle, Entity entity, @Nullable Vector3d now)
    {
        if (this.collisionDrag==0)
        {
            return;
        }

        Vector3d entitySpeed = new Vector3d((entity.posX - entity.prevPosX), (entity.posY - entity.prevPosY), (entity.posZ - entity.prevPosZ));

        double prevPrevPosX = EntityTransformationUtils.getPrevPrevPosX(entity);
        double prevPrevPosY = EntityTransformationUtils.getPrevPrevPosY(entity);
        double prevPrevPosZ = EntityTransformationUtils.getPrevPrevPosZ(entity);

        Vector3d prevEntitySpeed = new Vector3d(entity.prevPosX-prevPrevPosX, entity.prevPosY-prevPrevPosY, entity.prevPosZ-prevPrevPosZ);

        /*if (Math.round((prevEntitySpeed.x-entitySpeed.x)*1000D) != 0 || Math.round((prevEntitySpeed.y-entitySpeed.y)*1000D) != 0 || Math.round((prevEntitySpeed.z-entitySpeed.z)*1000D) != 0)
        {
            particle.dragFactor = 0;
        }*/

        /* for first collision from the inertial system of the particle it is acceleration from zero to current velocity */
        if (!particle.entityCollisionTime.containsKey(entity))
        {
            prevEntitySpeed.scale(0);
        }
        else
        {
            /* stick the particle on top of the entity */
            particle.offset.x = entitySpeed.x;
            particle.offset.z = entitySpeed.z;

            if (now==null)
            {
                particle.position.x += entitySpeed.x;
                particle.position.z += entitySpeed.z;
            }
            else
            {
                now.x += entitySpeed.x;
                now.z += entitySpeed.z;
            }
        }

        particle.speed.x += Math.round((prevEntitySpeed.x-entitySpeed.x)*1000D)/250D; //scale it up so it gets more noticable
        particle.speed.y += Math.round((prevEntitySpeed.y-entitySpeed.y)*1000D)/250D;
        particle.speed.z += Math.round((prevEntitySpeed.z-entitySpeed.z)*1000D)/250D;
    }

    public void momentum(BedrockParticle particle, Entity entity)
    {
        particle.speed.x += 2 * (entity.posX - entity.prevPosX);
        particle.speed.y += 2 * (entity.posY - entity.prevPosY);
        particle.speed.z += 2 * (entity.posZ - entity.prevPosZ);
    }

    public void drag(BedrockParticle particle)
    {
        /* only apply drag when speed is almost not zero and randombounciness and realisticCollision are off
         * prevent particles from accelerating away when randomBounciness is active */
        if (!((this.randomBounciness != 0 || this.realisticCollision) && Math.round(particle.speed.x*10000) == 0 && Math.round(particle.speed.y*10000) == 0 && Math.round(particle.speed.z*10000) == 0))
        {
            particle.dragFactor = this.collisionDrag;
            /*if (this.realisticCollisionDrag)
            {
                //TODO WTF IS THIS
                particle.dragFactor = 3*this.collisionDrag;
            }
            else
            {
                //why is it adding it on top of the old drag?
                particle.dragFactor += this.collisionDrag;
            }*/
        }
    }

    public Vector3f damping(Vector3f vector)
    {
        float random = (float) (this.randomDamp * (Math.random() * 2 - 1));
        float clampedValue = MathUtils.clamp((1 - this.damp) + random, 0, 1);

        vector.scale(clampedValue);

        return vector;
    }

    public void splitParticle(BedrockParticle particle, BedrockEmitter emitter, EnumFacing.Axis component, Vector3d now, Vector3d prev)
    {
        float speed = getComponent(particle.speed, component);

        if (!(Math.abs(speed) > Math.abs(this.splitParticleSpeedThreshold)))
        {
            return;
        }

        for (int i = 0; i < this.splitParticleCount; i++)
        {
            BedrockParticle splitParticle = emitter.createParticle(false);

            particle.softCopy(splitParticle);

            splitParticle.position.set(now);
            splitParticle.prevPosition.set(prev);
            splitParticle.morph.setDirect(MorphUtils.copy(particle.morph.get()));

            splitParticle.bounces = 1;

            double splitPosition = getComponent(splitParticle.position, component);

            setComponent(splitParticle.collisionTime, component, particle.age);
            setComponent(splitParticle.position, component, splitPosition/* + ((orig < offset) ? this.radius : -this.radius)*/);

            Vector3f randomSpeed = this.randomBounciness(particle.speed, component, (this.randomBounciness != 0) ? this.randomBounciness : 10);

            randomSpeed.scale(1.0f / this.splitParticleCount);
            splitParticle.speed.set(randomSpeed);

            if (this.damp != 0)
            {
                splitParticle.speed = this.damping(splitParticle.speed);
            }

            emitter.splitParticles.add(splitParticle);
        }

        particle.dead = true;
    }

    public Vector3f randomBounciness(Vector3f vector0, EnumFacing.Axis component, float randomness)
    {
        if (randomness != 0)
        {
            /* don't change the vector0 - pointer behaviour not wanted here */
            Vector3f vector = new Vector3f(vector0);
            /* scale down the vector components not involved in the collision reflection */
            float randomfactor = 0.25F;
            float prevLength = vector.length();
            randomness *= 0.1F;
            float random1 = (float) Math.random() * randomness;
            float random2 = (float) (randomness * randomfactor * (Math.random() * 2 - 1));
            float random3 = (float) (randomness * randomfactor * (Math.random() * 2 - 1));

            float vectorValue = getComponent(vector, component);

            if (component == EnumFacing.Axis.X)
            {
                vector.y += random2;
                vector.z += random3;
            }
            else if (component == EnumFacing.Axis.Y)
            {
                vector.x += random2;
                vector.z += random3;
            }
            else
            {
                vector.y += random2;
                vector.x += random3;
            }

            if (this.bounciness != 0)
            {
                setComponent(vector, component, vectorValue + ((vectorValue < 0) ? -random1 : random1));
                vector.scale(prevLength / vector.length()); //scale back to original length
            }
            else if (vector.x != 0 || vector.y != 0 || vector.z != 0)
            {
                /* if bounciness=0 then the speed of a specific component wont't affect the particles movement
                 * so the particles speed needs to be scaled back without taking that component into account
                 * when bounciness=0 the energy of that component gets absorbed by the collision block and therefore is lost for the particle
                 */
                if (this.preserveEnergy)
                {
                    setComponent(vector, component, 0);
                }

                /* if the vector is now zero... don't execute 1/vector.length() -> 1/0 not possible */
                if (vector.x != 0 || vector.y != 0 || vector.z != 0)
                {
                    vector.scale(prevLength / vector.length());
                }

                setComponent(vector, component, vectorValue);
            }
            else /* bounciness == 0 and vector is zero (rare case, but not impossible) */
            {
                /* if you don't want particles to stop, while others randomly slide away,
                 * when bounciness==0, then return vector0 */
                return vector0;
            }

            return vector;
        }

        return vector0;
    }

    public Vector3d intersect(Vector3f ray, Vector3d orig, AxisAlignedBB aabb)
    {
        double tmin = (aabb.minX - orig.x) / ray.x;
        double tmax = (aabb.maxX - orig.x) / ray.x;

        if (tmin > tmax)
        {
            double tminTmp = tmin;
            tmin = tmax;
            tmax = tminTmp;
        }

        double tymin = (aabb.minY - orig.y) / ray.y;
        double tymax = (aabb.maxY - orig.y) / ray.y;

        if (tymin > tymax)
        {
            double tyminTmp = tymin;
            tymin = tymax;
            tymax = tyminTmp;
        }

        if (tmin > tymax || tymin > tmax)
            return null;

        if (tymin > tmin)
            tmin = tymin;

        if (tymax < tmax)
            tmax = tymax;

        double tzmin = (aabb.minZ - orig.z) / ray.z;
        double tzmax = (aabb.maxZ - orig.z) / ray.z;

        if (tzmin > tzmax)
        {
            double tzminTmp = tzmin;
            tzmin = tzmax;
            tzmax = tzminTmp;
        }

        if (tmin > tzmax || tzmin > tmax)
            return null;

        if (tzmax < tmax)
            tmax = tzmax;

        Vector3d ray1 = new Vector3d(ray);

        ray1.scale(tmax);

        return ray1;
    }

    /**
     * @param aabb AxisAlignedBoundingBox of the main aabb
     * @param list List of AxisAlignedBoundingBoxs of the targets
     * @param x origin
     * @param y origin
     * @param z origin
     * @return CollisionOffset which includes aabb, x, y, z
     */
    public CollisionOffset calculateOffsets(AxisAlignedBB aabb, List<AxisAlignedBB> list, double x, double y, double z)
    {
        for (AxisAlignedBB axisalignedbb : list)
        {
            y = axisalignedbb.calculateYOffset(aabb, y);
        }

        aabb = aabb.offset(0.0D, y, 0.0D);

        for (AxisAlignedBB axisalignedbb1 : list)
        {
            x = axisalignedbb1.calculateXOffset(aabb, x);
        }

        aabb = aabb.offset(x, 0.0D, 0.0D);

        for (AxisAlignedBB axisalignedbb2 : list)
        {
            z = axisalignedbb2.calculateZOffset(aabb, z);
        }

        aabb = aabb.offset(0.0D, 0.0D, z);

        return new CollisionOffset(aabb, x, y, z);
    }

    @Override
    public int getSortingIndex()
    {
        return 50;
    }

    public class CollisionOffset
    {
        public AxisAlignedBB aabb;
        public double x;
        public double y;
        public double z;

        public CollisionOffset(AxisAlignedBB aabb, double x, double y, double z)
        {
            this.aabb = aabb;
            this.x = x;
            this.y = y;
            this.z = z;
        }
    }
}


==================================================

--- Файл №197 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\motion\BedrockComponentMotionDynamic.java
--------------------
package mchorse.blockbuster.client.particles.components.motion;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentMotionDynamic extends BedrockComponentMotion implements IComponentParticleUpdate
{
    public MolangExpression[] motionAcceleration = {MolangParser.ZERO, MolangParser.ZERO, MolangParser.ZERO};
    public MolangExpression motionDrag = MolangParser.ZERO;
    public MolangExpression rotationAcceleration = MolangParser.ZERO;
    public MolangExpression rotationDrag = MolangParser.ZERO;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("linear_acceleration"))
        {
            JsonArray array = element.getAsJsonArray("linear_acceleration");

            if (array.size() >= 3)
            {
                this.motionAcceleration[0] = parser.parseJson(array.get(0));
                this.motionAcceleration[1] = parser.parseJson(array.get(1));
                this.motionAcceleration[2] = parser.parseJson(array.get(2));
            }
        }

        if (element.has("linear_drag_coefficient")) this.motionDrag = parser.parseJson(element.get("linear_drag_coefficient"));
        if (element.has("rotation_acceleration")) this.rotationAcceleration = parser.parseJson(element.get("rotation_acceleration"));
        if (element.has("rotation_drag_coefficient")) this.rotationDrag = parser.parseJson(element.get("rotation_drag_coefficient"));

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        JsonArray acceleration = new JsonArray();

        for (MolangExpression expression : this.motionAcceleration)
        {
            acceleration.add(expression.toJson());
        }

        object.add("linear_acceleration", acceleration);

        if (!MolangExpression.isZero(this.motionDrag)) object.add("linear_drag_coefficient", this.motionDrag.toJson());
        if (!MolangExpression.isZero(this.rotationAcceleration)) object.add("rotation_acceleration", this.rotationAcceleration.toJson());
        if (!MolangExpression.isZero(this.rotationDrag)) object.add("rotation_drag_coefficient", this.rotationDrag.toJson());

        return object;
    }

    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        particle.acceleration.x += (float) this.motionAcceleration[0].get();
        particle.acceleration.y += (float) this.motionAcceleration[1].get();
        particle.acceleration.z += (float) this.motionAcceleration[2].get();
        particle.drag = (float) this.motionDrag.get();

        particle.rotationAcceleration += (float) this.rotationAcceleration.get() / 20F;
        particle.rotationDrag = (float) this.rotationDrag.get();
    }
}

==================================================

--- Файл №198 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\motion\BedrockComponentMotionParametric.java
--------------------
package mchorse.blockbuster.client.particles.components.motion;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.blockbuster.client.particles.components.IComponentParticleUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

import javax.vecmath.Vector3f;

public class BedrockComponentMotionParametric extends BedrockComponentMotion implements IComponentParticleInitialize, IComponentParticleUpdate
{
    public MolangExpression[] position = {MolangParser.ZERO, MolangParser.ZERO, MolangParser.ZERO};
    public MolangExpression rotation = MolangParser.ZERO;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("relative_position") && element.get("relative_position").isJsonArray())
        {
            JsonArray array = element.get("relative_position").getAsJsonArray();

            this.position[0] = parser.parseJson(array.get(0));
            this.position[1] = parser.parseJson(array.get(1));
            this.position[2] = parser.parseJson(array.get(2));
        }

        if (element.has("rotation"))
        {
            this.rotation = parser.parseJson(element.get("rotation"));
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        JsonArray position = new JsonArray();

        for (MolangExpression expression : this.position)
        {
            position.add(expression.toJson());
        }

        object.add("relative_position", position);

        if (!MolangExpression.isZero(this.rotation)) object.add("rotation", this.rotation.toJson());

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        Vector3f position = new Vector3f((float) this.position[0].get(), (float) this.position[1].get(), (float) this.position[2].get());

        particle.manual = true;
        particle.initialPosition.set(particle.position);

        particle.matrix.transform(position);
        particle.position.x = particle.initialPosition.x + position.x;
        particle.position.y = particle.initialPosition.y + position.y;
        particle.position.z = particle.initialPosition.z + position.z;
        particle.rotation = (float) this.rotation.get();
    }

    @Override
    public void update(BedrockEmitter emitter, BedrockParticle particle)
    {
        Vector3f position = new Vector3f((float) this.position[0].get(), (float) this.position[1].get(), (float) this.position[2].get());

        particle.matrix.transform(position);
        particle.position.x = particle.initialPosition.x + position.x;
        particle.position.y = particle.initialPosition.y + position.y;
        particle.position.z = particle.initialPosition.z + position.z;
        particle.rotation = (float) this.rotation.get();
    }

    @Override
    public int getSortingIndex()
    {
        return 10;
    }
}

==================================================

--- Файл №199 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\rate\BedrockComponentRate.java
--------------------
package mchorse.blockbuster.client.particles.components.rate;

import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public abstract class BedrockComponentRate extends BedrockComponentBase
{
    public MolangExpression particles;
}

==================================================

--- Файл №200 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\rate\BedrockComponentRateInstant.java
--------------------
package mchorse.blockbuster.client.particles.components.rate;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentEmitterUpdate;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;

public class BedrockComponentRateInstant extends BedrockComponentRate implements IComponentEmitterUpdate
{
    public static final MolangExpression DEFAULT_PARTICLES = new MolangValue(null, new Constant(10));

    public BedrockComponentRateInstant()
    {
        this.particles = DEFAULT_PARTICLES;
    }

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("num_particles"))
        {
            this.particles = parser.parseJson(element.get("num_particles"));
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (!MolangExpression.isConstant(this.particles, 10))
        {
            object.add("num_particles", this.particles.toJson());
        }

        return object;
    }

    @Override
    public void update(BedrockEmitter emitter)
    {
        double age = emitter.getAge();

        if (emitter.playing && Operation.equals(age, 0))
        {
            emitter.setEmitterVariables(0);

            for (int i = 0, c = (int) this.particles.get(); i < c; i ++)
            {
                emitter.spawnParticle();
            }
        }
    }
}

==================================================

--- Файл №201 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\rate\BedrockComponentRateSteady.java
--------------------
package mchorse.blockbuster.client.particles.components.rate;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleMorphRender;
import mchorse.blockbuster.client.particles.components.IComponentParticleRender;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;
import net.minecraft.client.renderer.BufferBuilder;

public class BedrockComponentRateSteady extends BedrockComponentRate implements IComponentParticleRender, IComponentParticleMorphRender
{
    public static final MolangExpression DEFAULT_PARTICLES = new MolangValue(null, new Constant(50));

    public MolangExpression spawnRate = MolangParser.ONE;

    public BedrockComponentRateSteady()
    {
        this.particles = DEFAULT_PARTICLES;
    }

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("spawn_rate")) this.spawnRate = parser.parseJson(element.get("spawn_rate"));
        if (element.has("max_particles")) this.particles = parser.parseJson(element.get("max_particles"));

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();

        if (!MolangExpression.isOne(this.spawnRate)) object.add("spawn_rate", this.spawnRate.toJson());
        if (!MolangExpression.isConstant(this.particles, 50)) object.add("max_particles", this.particles.toJson());

        return object;
    }

    @Override
    public void preRender(BedrockEmitter emitter, float partialTicks)
    {}

    @Override
    public void render(BedrockEmitter emitter, BedrockParticle particle, BufferBuilder builder, float partialTicks)
    {}

    @Override
    public void renderOnScreen(BedrockParticle particle, int x, int y, float scale, float partialTicks)
    {}

    @Override
    public void postRender(BedrockEmitter emitter, float partialTicks)
    {
        if (emitter.playing)
        {
            double particles = emitter.getAge(partialTicks) * this.spawnRate.get();
            double diff = particles - emitter.spawnedParticles;
            double spawn = Math.round(diff);

            if (spawn > 0)
            {
                emitter.setEmitterVariables(partialTicks);

                double track = spawn;

                for (int i = 0; i < spawn; i++)
                {
                    if (emitter.particles.size() < this.particles.get())
                    {
                        emitter.spawnParticle();
                    }
                    else
                    {
                        track -= 1;
                    }
                }

                emitter.spawnedParticles += track;
            }
        }
    }

    @Override
    public int getSortingIndex()
    {
        return 10;
    }
}

==================================================

--- Файл №202 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\BedrockComponentShapeBase.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.components.IComponentParticleInitialize;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public abstract class BedrockComponentShapeBase extends BedrockComponentBase implements IComponentParticleInitialize
{
    public MolangExpression[] offset = {MolangParser.ZERO, MolangParser.ZERO, MolangParser.ZERO};
    public ShapeDirection direction = ShapeDirection.OUTWARDS;
    public boolean surface = false;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("offset"))
        {
            JsonArray array = element.getAsJsonArray("offset");

            if (array.size() >= 3)
            {
                this.offset[0] = parser.parseJson(array.get(0));
                this.offset[1] = parser.parseJson(array.get(1));
                this.offset[2] = parser.parseJson(array.get(2));
            }
        }

        if (element.has("direction"))
        {
            JsonElement direction = element.get("direction");

            if (direction.isJsonPrimitive())
            {
                String name = direction.getAsString();

                if (name.equals("inwards")) this.direction = ShapeDirection.INWARDS;
                else this.direction = ShapeDirection.OUTWARDS;
            }
            else if (direction.isJsonArray())
            {
                JsonArray array = direction.getAsJsonArray();

                if (array.size() >= 3)
                {
                    this.direction = new ShapeDirection.Vector(
                        parser.parseJson(array.get(0)),
                        parser.parseJson(array.get(1)),
                        parser.parseJson(array.get(2))
                    );
                }
            }
        }

        if (element.has("surface_only"))
        {
            this.surface = element.get("surface_only").getAsBoolean();
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = new JsonObject();
        JsonArray offset = new JsonArray();

        for (MolangExpression expression : this.offset)
        {
            offset.add(expression.toJson());
        }

        object.add("offset", offset);

        if (this.direction != ShapeDirection.OUTWARDS)
        {
            object.add("direction", this.direction.toJson());
        }

        if (this.surface)
        {
            object.addProperty("surface_only", true);
        }

        return object;
    }
}

==================================================

--- Файл №203 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\BedrockComponentShapeBox.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

public class BedrockComponentShapeBox extends BedrockComponentShapeBase
{
    public MolangExpression[] halfDimensions = {MolangParser.ZERO, MolangParser.ZERO, MolangParser.ZERO};

    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("half_dimensions"))
        {
            JsonArray array = element.getAsJsonArray("half_dimensions");

            if (array.size() >= 3)
            {
                this.halfDimensions[0] = parser.parseJson(array.get(0));
                this.halfDimensions[1] = parser.parseJson(array.get(1));
                this.halfDimensions[2] = parser.parseJson(array.get(2));
            }
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = (JsonObject) super.toJson();
        JsonArray array = new JsonArray();

        for (MolangExpression expression : this.halfDimensions)
        {
            array.add(expression.toJson());
        }

        object.add("half_dimensions", array);

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        float centerX = (float) this.offset[0].get();
        float centerY = (float) this.offset[1].get();
        float centerZ = (float) this.offset[2].get();

        float w = (float) this.halfDimensions[0].get();
        float h = (float) this.halfDimensions[1].get();
        float d = (float) this.halfDimensions[2].get();

        particle.position.x = centerX + ((float) Math.random() * 2 - 1F) * w;
        particle.position.y = centerY + ((float) Math.random() * 2 - 1F) * h;
        particle.position.z = centerZ + ((float) Math.random() * 2 - 1F) * d;

        if (this.surface)
        {
            int roll = (int) (Math.random() * 6 * 100) % 6;

            if (roll == 0) particle.position.x = centerX + w;
            else if (roll == 1) particle.position.x = centerX - w;
            else if (roll == 2) particle.position.y = centerY + h;
            else if (roll == 3) particle.position.y = centerY - h;
            else if (roll == 4) particle.position.z = centerZ + d;
            else if (roll == 5) particle.position.z = centerZ - d;
        }

        this.direction.applyDirection(particle, centerX, centerY, centerZ);
    }
}

==================================================

--- Файл №204 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\BedrockComponentShapeDisc.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

import javax.vecmath.Matrix4f;
import javax.vecmath.Quat4f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

public class BedrockComponentShapeDisc extends BedrockComponentShapeSphere
{
    public MolangExpression[] normal = {MolangParser.ZERO, MolangParser.ONE, MolangParser.ZERO};

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("plane_normal"))
        {
            JsonElement normal = element.get("plane_normal");

            if (normal.isJsonPrimitive())
            {
                String axis = normal.getAsString().toLowerCase();

                if (axis.equals("x"))
                {
                    this.normal[0] = MolangParser.ONE;
                    this.normal[1] = MolangParser.ZERO;
                }
                else if (axis.equals("z"))
                {
                    this.normal[1] = MolangParser.ZERO;
                    this.normal[2] = MolangParser.ONE;
                }
            }
            else
            {
                JsonArray array = element.getAsJsonArray("plane_normal");

                if (array.size() >= 3)
                {
                    this.normal[0] = parser.parseJson(array.get(0));
                    this.normal[1] = parser.parseJson(array.get(1));
                    this.normal[2] = parser.parseJson(array.get(2));
                }
            }
        }

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = (JsonObject) super.toJson();
        JsonArray array = new JsonArray();

        for (MolangExpression expression : this.normal)
        {
            array.add(expression.toJson());
        }

        object.add("plane_normal", array);

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        float centerX = (float) this.offset[0].get();
        float centerY = (float) this.offset[1].get();
        float centerZ = (float) this.offset[2].get();

        Vector3f normal = new Vector3f((float) this.normal[0].get(), (float) this.normal[1].get(), (float) this.normal[2].get());

        normal.normalize();

        Quat4f quaternion = new Quat4f(normal.x, normal.y, normal.z, 1);
        Matrix4f rotation = new Matrix4f();
        rotation.set(quaternion);

        Vector4f position = new Vector4f((float) Math.random() - 0.5F, 0, (float) Math.random() - 0.5F, 0);
        position.normalize();
        rotation.transform(position);

        position.scale((float) (this.radius.get() * (this.surface ? 1 : Math.random())));
        position.add(new Vector4f(centerX, centerY, centerZ, 0));

        particle.position.x += position.x;
        particle.position.y += position.y;
        particle.position.z += position.z;

        this.direction.applyDirection(particle, centerX, centerY, centerZ);
    }
}

==================================================

--- Файл №205 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\BedrockComponentShapeEntityAABB.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;

public class BedrockComponentShapeEntityAABB extends BedrockComponentShapeBase
{
    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        float centerX = (float) this.offset[0].get();
        float centerY = (float) this.offset[1].get();
        float centerZ = (float) this.offset[2].get();

        float w = 0;
        float h = 0;
        float d = 0;

        if (emitter.target != null)
        {
            w = emitter.target.width;
            h = emitter.target.height;
            d = emitter.target.width;
        }

        particle.position.x = centerX + ((float) Math.random() - 0.5F) * w;
        particle.position.y = centerY + ((float) Math.random() - 0.5F) * h;
        particle.position.z = centerZ + ((float) Math.random() - 0.5F) * d;

        if (this.surface)
        {
            int roll = (int) (Math.random() * 6 * 100) % 6;

            if (roll == 0) particle.position.x = centerX + w / 2F;
            else if (roll == 1) particle.position.x = centerX - w / 2F;
            else if (roll == 2) particle.position.y = centerY + h / 2F;
            else if (roll == 3) particle.position.y = centerY - h / 2F;
            else if (roll == 4) particle.position.z = centerZ + d / 2F;
            else if (roll == 5) particle.position.z = centerZ - d / 2F;
        }

        this.direction.applyDirection(particle, centerX, centerY, centerZ);
    }
}


==================================================

--- Файл №206 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\BedrockComponentShapePoint.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;

public class BedrockComponentShapePoint extends BedrockComponentShapeBase
{
    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        particle.position.x = (float) this.offset[0].get();
        particle.position.y = (float) this.offset[1].get();
        particle.position.z = (float) this.offset[2].get();

        if (this.direction instanceof ShapeDirection.Vector)
        {
            this.direction.applyDirection(particle, particle.position.x, particle.position.y, particle.position.z);
        }
    }
}

==================================================

--- Файл №207 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\BedrockComponentShapeSphere.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.blockbuster.client.particles.components.BedrockComponentBase;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.MolangException;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;

import javax.vecmath.Vector3f;

public class BedrockComponentShapeSphere extends BedrockComponentShapeBase
{
    public MolangExpression radius = MolangParser.ZERO;

    @Override
    public BedrockComponentBase fromJson(JsonElement elem, MolangParser parser) throws MolangException
    {
        if (!elem.isJsonObject()) return super.fromJson(elem, parser);

        JsonObject element = elem.getAsJsonObject();

        if (element.has("radius")) this.radius = parser.parseJson(element.get("radius"));

        return super.fromJson(element, parser);
    }

    @Override
    public JsonElement toJson()
    {
        JsonObject object = (JsonObject) super.toJson();

        if (!MolangExpression.isZero(this.radius)) object.add("radius", this.radius.toJson());

        return object;
    }

    @Override
    public void apply(BedrockEmitter emitter, BedrockParticle particle)
    {
        float centerX = (float) this.offset[0].get();
        float centerY = (float) this.offset[1].get();
        float centerZ = (float) this.offset[2].get();
        float radius = (float) this.radius.get();

        Vector3f direction = new Vector3f((float) Math.random() * 2 - 1, (float) Math.random() * 2 - 1, (float) Math.random() * 2 - 1);
        direction.normalize();

        if (!this.surface)
        {
            radius *= Math.random();
        }

        direction.scale(radius);

        particle.position.x = centerX + direction.x;
        particle.position.y = centerY + direction.y;
        particle.position.z = centerZ + direction.z;

        this.direction.applyDirection(particle, centerX, centerY, centerZ);
    }
}

==================================================

--- Файл №208 ---
Путь: main\java\mchorse\blockbuster\client\particles\components\shape\ShapeDirection.java
--------------------
package mchorse.blockbuster.client.particles.components.shape;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import mchorse.blockbuster.client.particles.emitter.BedrockParticle;
import mchorse.mclib.math.molang.expressions.MolangExpression;

import javax.vecmath.Vector3d;

public abstract class ShapeDirection
{
    public static final ShapeDirection INWARDS = new Inwards(-1);
    public static final ShapeDirection OUTWARDS = new Inwards(1);

    public abstract void applyDirection(BedrockParticle particle, double x, double y, double z);

    public abstract JsonElement toJson();

    private static class Inwards extends ShapeDirection
    {
        private float factor;

        public Inwards(float factor)
        {
            this.factor = factor;
        }

        @Override
        public void applyDirection(BedrockParticle particle, double x, double y, double z)
        {
            Vector3d vector = new Vector3d(particle.position);

            vector.sub(new Vector3d(x, y, z));

            if (vector.length() <= 0)
            {
                vector.set(0, 0, 0);
            }
            else
            {
                vector.normalize();
                vector.scale(this.factor);
            }

            particle.speed.set(vector);
        }

        @Override
        public JsonElement toJson()
        {
            return new JsonPrimitive(this.factor < 0 ? "inwards" : "outwards");
        }
    }

    public static class Vector extends ShapeDirection
    {
        public MolangExpression x;
        public MolangExpression y;
        public MolangExpression z;

        public Vector(MolangExpression x, MolangExpression y, MolangExpression z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        @Override
        public void applyDirection(BedrockParticle particle, double x, double y, double z)
        {
            particle.speed.set((float) this.x.get(), (float) this.y.get(), (float) this.z.get());

            if (particle.speed.length() <= 0)
            {
                particle.speed.set(0, 0, 0);
            }
            else
            {
                particle.speed.normalize();
            }
        }

        @Override
        public JsonElement toJson()
        {
            JsonArray array = new JsonArray();

            array.add(this.x.toJson());
            array.add(this.y.toJson());
            array.add(this.z.toJson());

            return array;
        }
    }
}


==================================================

--- Файл №209 ---
Путь: main\java\mchorse\blockbuster\client\particles\emitter\BedrockEmitter.java
--------------------
package mchorse.blockbuster.client.particles.emitter;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.components.*;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentAppearanceBillboard;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionAppearance;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionTinting;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentParticleMorph;
import mchorse.blockbuster.client.particles.components.meta.BedrockComponentInitialization;
import mchorse.blockbuster.client.particles.components.rate.BedrockComponentRateSteady;
import mchorse.blockbuster.client.textures.GifTexture;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix3f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import java.util.*;

public class BedrockEmitter
{
    public BedrockScheme scheme;
    public List<BedrockParticle> particles = new ArrayList<BedrockParticle>();
    public List<BedrockParticle> splitParticles = new ArrayList<BedrockParticle>();
    public Map<String, IValue> variables;
    public Map<String, Double> initialValues = new HashMap<String, Double>();

    public EntityLivingBase target;
    public World world;
    public boolean lit;

    public boolean added;
    public int sanityTicks;
    public boolean running = true;
    private BedrockParticle guiParticle;

    /* Intermediate values */
    public Vector3d lastGlobal = new Vector3d();
    public Vector3d prevGlobal = new Vector3d();
    public Matrix3f rotation = new Matrix3f(1,0,0,0,1,0,0,0,1);
    public Matrix3f prevRotation = new Matrix3f(1,0,0,0,1,0,0,0,1);
    public Vector3f angularVelocity = new Vector3f();
    /**
     * Translation of immediate bodypart
     */
    public Vector3d translation = new Vector3d();

    /* Runtime properties */
    public int age;
    public int lifetime;
    public double spawnedParticles;
    public boolean playing = true;

    public float random1 = (float) Math.random();
    public float random2 = (float) Math.random();
    public float random3 = (float) Math.random();
    public float random4 = (float) Math.random();

    private BlockPos.MutableBlockPos blockPos = new BlockPos.MutableBlockPos();

    public double[] scale = {1,1,1};

    /* Camera properties */
    public int perspective;
    public float cYaw;
    public float cPitch;

    public double cX;
    public double cY;
    public double cZ;

    /* Cached variable references to avoid hash look ups */
    private Variable varAge;
    private Variable varLifetime;
    private Variable varRandom1;
    private Variable varRandom2;
    private Variable varRandom3;
    private Variable varRandom4;

    /* Exclusive Blockbuster variables */
    private Variable varSpeedABS;
    private Variable varSpeedX;
    private Variable varSpeedY;
    private Variable varSpeedZ;
    private Variable varPosX;
    private Variable varPosY;
    private Variable varPosZ;
    private Variable varPosDistance;
    private Variable varBounces;

    private Variable varEmitterAge;
    private Variable varEmitterLifetime;
    private Variable varEmitterRandom1;
    private Variable varEmitterRandom2;
    private Variable varEmitterRandom3;
    private Variable varEmitterRandom4;

    public boolean isFinished()
    {
        return !this.running && this.particles.isEmpty();
    }

    public double getDistanceSq()
    {
        this.setupCameraProperties(0F);

        double dx = this.cX -  this.lastGlobal.x;
        double dy = this.cY -  this.lastGlobal.y;
        double dz = this.cZ -  this.lastGlobal.z;

        return dx * dx + dy * dy + dz * dz;
    }

    public double getAge()
    {
        return this.getAge(0);
    }

    public double getAge(float partialTicks)
    {
        return (this.age + partialTicks) / 20.0;
    }

    public boolean isMorphParticle()
    {
        BedrockComponentParticleMorph morphComponent = this.scheme.getOrCreate(BedrockComponentParticleMorph.class);

        return morphComponent.enabled;
    }

    public void setTarget(EntityLivingBase target)
    {
        this.target = target;
        this.world = target == null ? null : target.world;
    }

    public void setScheme(BedrockScheme scheme)
    {
        this.setScheme(scheme, null);
    }

    public void setScheme(BedrockScheme scheme, Map<String, String> variables)
    {
        this.scheme = scheme;

        if (this.scheme == null)
        {
            return;
        }

        if (variables != null)
        {
            this.parseVariables(variables);
        }

        this.lit = true;
        this.stop();
        this.start();

        this.setupVariables();
        this.setEmitterVariables(0);
    }

    /* Variable related code */

    public void setupVariables()
    {
        this.varAge = this.scheme.parser.variables.get("variable.particle_age");
        this.varLifetime = this.scheme.parser.variables.get("variable.particle_lifetime");
        this.varRandom1 = this.scheme.parser.variables.get("variable.particle_random_1");
        this.varRandom2 = this.scheme.parser.variables.get("variable.particle_random_2");
        this.varRandom3 = this.scheme.parser.variables.get("variable.particle_random_3");
        this.varRandom4 = this.scheme.parser.variables.get("variable.particle_random_4");

        this.varSpeedABS = this.scheme.parser.variables.get("variable.particle_speed.length");
        this.varSpeedX = this.scheme.parser.variables.get("variable.particle_speed.x");
        this.varSpeedY = this.scheme.parser.variables.get("variable.particle_speed.y");
        this.varSpeedZ = this.scheme.parser.variables.get("variable.particle_speed.z");
        this.varPosX = this.scheme.parser.variables.get("variable.particle_pos.x");
        this.varPosY = this.scheme.parser.variables.get("variable.particle_pos.y");
        this.varPosZ = this.scheme.parser.variables.get("variable.particle_pos.z");
        this.varPosDistance = this.scheme.parser.variables.get("variable.particle_pos.distance");
        this.varBounces = this.scheme.parser.variables.get("variable.particle_bounces");

        this.varEmitterAge = this.scheme.parser.variables.get("variable.emitter_age");
        this.varEmitterLifetime = this.scheme.parser.variables.get("variable.emitter_lifetime");
        this.varEmitterRandom1 = this.scheme.parser.variables.get("variable.emitter_random_1");
        this.varEmitterRandom2 = this.scheme.parser.variables.get("variable.emitter_random_2");
        this.varEmitterRandom3 = this.scheme.parser.variables.get("variable.emitter_random_3");
        this.varEmitterRandom4 = this.scheme.parser.variables.get("variable.emitter_random_4");
    }

    public void setParticleVariables(BedrockParticle particle, float partialTicks)
    {
        if (this.varAge != null) this.varAge.set(particle.getAge(partialTicks));
        if (this.varLifetime != null) this.varLifetime.set(particle.lifetime / 20.0);
        if (this.varRandom1 != null) this.varRandom1.set(particle.random1);
        if (this.varRandom2 != null) this.varRandom2.set(particle.random2);
        if (this.varRandom3 != null) this.varRandom3.set(particle.random3);
        if (this.varRandom4 != null) this.varRandom4.set(particle.random4);

        Vector3d relativePos = new Vector3d(particle.getGlobalPosition(this));
        relativePos.sub(this.lastGlobal);

        if (this.varPosDistance != null) this.varPosDistance.set(relativePos.length());
        if (this.varPosX != null) this.varPosX.set(relativePos.x);
        if (this.varPosY != null) this.varPosY.set(relativePos.y);
        if (this.varPosZ != null) this.varPosZ.set(relativePos.z);
        if (this.varSpeedABS != null) this.varSpeedABS.set(particle.speed.length());
        if (this.varSpeedX != null) this.varSpeedX.set(particle.speed.x);
        if (this.varSpeedY != null) this.varSpeedY.set(particle.speed.y);
        if (this.varSpeedZ != null) this.varSpeedZ.set(particle.speed.z);
        if (this.varBounces != null) this.varBounces.set(particle.bounces);

        this.scheme.updateCurves();

        BedrockComponentInitialization component = this.scheme.get(BedrockComponentInitialization.class);

        if (component != null)
        {
            component.particleUpdate.get();
        }
    }

    public void setEmitterVariables(float partialTicks)
    {
        for (Map.Entry<String, Double> entry : this.initialValues.entrySet())
        {
            Variable var = this.scheme.parser.variables.get(entry.getKey());

            if (var != null)
            {
                var.set(entry.getValue());
            }
        }

        if (this.varEmitterAge != null) this.varEmitterAge.set(this.getAge(partialTicks));
        if (this.varEmitterLifetime != null) this.varEmitterLifetime.set(this.lifetime / 20.0);
        if (this.varEmitterRandom1 != null) this.varEmitterRandom1.set(this.random1);
        if (this.varEmitterRandom2 != null) this.varEmitterRandom2.set(this.random2);
        if (this.varEmitterRandom3 != null) this.varEmitterRandom3.set(this.random3);
        if (this.varEmitterRandom4 != null) this.varEmitterRandom4.set(this.random4);

        this.scheme.updateCurves();
    }

    public void parseVariables(Map<String, String> variables)
    {
        this.variables = new HashMap<String, IValue>();

        for (Map.Entry<String, String> entry : variables.entrySet())
        {
            this.parseVariable(entry.getKey(), entry.getValue());
        }
    }

    public void parseVariable(String name, String expression)
    {
        try
        {
            this.variables.put(name, this.scheme.parser.parse(expression));
        }
        catch (Exception e)
        {}
    }

    public void replaceVariables()
    {
        if (this.variables == null)
        {
            return;
        }

        for (Map.Entry<String, IValue> entry : this.variables.entrySet())
        {
            Variable var = this.scheme.parser.variables.get(entry.getKey());

            if (var != null)
            {
                var.set(entry.getValue().get().doubleValue());
            }
        }
    }

    public void start()
    {
        if (this.playing)
        {
            return;
        }

        this.age = 0;
        this.spawnedParticles = 0;
        this.playing = true;

        for (IComponentEmitterInitialize component : this.scheme.emitterInitializes)
        {
            component.apply(this);
        }
    }

    public void stop()
    {
        if (!this.playing)
        {
            return;
        }

        this.spawnedParticles = 0;
        this.playing = false;

        this.random1 = (float) Math.random();
        this.random2 = (float) Math.random();
        this.random3 = (float) Math.random();
        this.random4 = (float) Math.random();
    }

    /**
     * Update this current emitter
     */
    public void update()
    {
        if (this.scheme == null)
        {
            return;
        }

        this.setEmitterVariables(0);

        for (IComponentEmitterUpdate component : this.scheme.emitterUpdates)
        {
            component.update(this);
        }

        this.setEmitterVariables(0);
        this.updateParticles();

        this.age += 1;
        this.sanityTicks += 1;
    }

    /**
     * Update all particles
     */
    private void updateParticles()
    {
        Iterator<BedrockParticle> it = this.particles.iterator();

        while (it.hasNext())
        {
            BedrockParticle particle = it.next();

            this.updateParticle(particle);

            if (particle.dead)
            {
                it.remove();
            }
        }

        if (!this.splitParticles.isEmpty())
        {
            this.particles.addAll(this.splitParticles);
            this.splitParticles.clear();
        }
    }

    /**
     * Update a single particle
     */
    private void updateParticle(BedrockParticle particle)
    {
        particle.update(this);

        this.setParticleVariables(particle, 0);

        for (IComponentParticleUpdate component : this.scheme.particleUpdates)
        {
            component.update(this, particle);
        }
    }

    /**
     * Spawn a particle
     */
    public void spawnParticle()
    {
        if (!this.running)
        {
            return;
        }

        this.particles.add(this.createParticle(false));
    }

    /**
     * Create a new particle
     */
    public BedrockParticle createParticle(boolean forceRelative)
    {
        BedrockParticle particle = new BedrockParticle();

        this.setParticleVariables(particle, 0);
        particle.setupMatrix(this);

        for (IComponentParticleInitialize component : this.scheme.particleInitializes)
        {
            component.apply(this, particle);
        }

        if (particle.relativePosition && !particle.relativeRotation)
        {
            Vector3f vec = new Vector3f(particle.position);

            particle.matrix.transform(vec);

            particle.position.x = vec.x;
            particle.position.y = vec.y;
            particle.position.z = vec.z;
        }

        if (!(particle.relativePosition && particle.relativeRotation))
        {
            particle.position.add(this.lastGlobal);
            particle.initialPosition.add(this.lastGlobal);
        }

        particle.prevPosition.set(particle.position);
        particle.rotation = particle.initialRotation;
        particle.prevRotation = particle.rotation;

        return particle;
    }

    /**
     * Render the particle on screen
     */
    public void renderOnScreen(int x, int y, float scale)
    {
        if (this.scheme == null)
        {
            return;
        }

        BedrockComponentParticleMorph particleMorphComponent = this.scheme.getOrCreate(BedrockComponentParticleMorph.class);
        float partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();

        List<IComponentParticleRender> listParticle = this.scheme.getComponents(IComponentParticleRender.class);
        List<IComponentParticleMorphRender> listMorph = this.scheme.getComponents(IComponentParticleMorphRender.class);

        Matrix3f rotation = this.rotation;

        this.rotation = new Matrix3f();

        if (!listParticle.isEmpty() && (!this.isMorphParticle() || particleMorphComponent.renderTexture))
        {
            Minecraft.getMinecraft().renderEngine.bindTexture(this.scheme.texture);

            this.scheme.material.beginGL();
            GlStateManager.disableCull();

            if (this.guiParticle == null || this.guiParticle.dead)
            {
                this.guiParticle = this.createParticle(true);
            }

            this.rotation.setIdentity();
            this.guiParticle.update(this);
            this.setEmitterVariables(partialTicks);
            this.setParticleVariables(this.guiParticle, partialTicks);

            for (IComponentParticleRender render : listParticle)
            {
                render.renderOnScreen(this.guiParticle, x, y, scale, partialTicks);
            }

            this.scheme.material.endGL();
            GlStateManager.enableCull();
        }

        if (!listMorph.isEmpty() && this.isMorphParticle())
        {
            if (this.guiParticle == null || this.guiParticle.dead)
            {
                this.guiParticle = this.createParticle(true);
            }

            this.rotation.setIdentity();
            this.guiParticle.update(this);
            this.setEmitterVariables(partialTicks);
            this.setParticleVariables(this.guiParticle, partialTicks);

            for (IComponentParticleMorphRender render : listMorph)
            {
                render.renderOnScreen(this.guiParticle, x, y, scale, partialTicks);
            }
        }

        this.rotation = rotation;
    }

    /**
     * Render all the particles in this particle emitter
     */
    public void render(float partialTicks)
    {
        if (this.scheme == null)
        {
            return;
        }

        this.setupCameraProperties(partialTicks);

        BedrockComponentParticleMorph particleMorphComponent = this.scheme.getOrCreate(BedrockComponentParticleMorph.class);
        List<IComponentParticleRender> renders = this.scheme.particleRender;
        List<IComponentParticleMorphRender> morphRenders = this.scheme.particleMorphRender;

        boolean morphRendering = this.isMorphParticle();
        boolean particleRendering = !morphRendering || particleMorphComponent.renderTexture;

        /* particle rendering */
        if (particleRendering)
        {
            this.setupOpenGL(partialTicks);

            for (IComponentParticleRender component : renders)
            {
                component.preRender(this, partialTicks);
            }

            if (!this.particles.isEmpty())
            {
                this.depthSorting();

                this.renderParticles(this.scheme.texture, renders, false, partialTicks);

                BedrockComponentCollisionAppearance collisionAppearance = this.scheme.getOrCreate(BedrockComponentCollisionAppearance.class);

                /* rendering the collided particles with an extra component */
                if (collisionAppearance != null && collisionAppearance.texture != null)
                {
                    this.renderParticles(collisionAppearance.texture, renders, true, partialTicks);
                }
            }

            for (IComponentParticleRender component : renders)
            {
                component.postRender(this, partialTicks);
            }

            this.endOpenGL();
        }

        /* Morph rendering */
        if (morphRendering)
        {
            for (IComponentParticleMorphRender component : morphRenders)
            {
                component.preRender(this, partialTicks);
            }

            if (!this.particles.isEmpty())
            {
                //only depth sort either in particle rendering or morph rendering
                if (!particleRendering)
                {
                    this.depthSorting();
                }

                this.renderParticles(morphRenders, false, partialTicks);

                /*BedrockComponentCollisionParticleMorph collisionComponent = this.scheme.getOrCreate(BedrockComponentCollisionParticleMorph.class);

                if (collisionComponent != null && collisionComponent.morph != null)
                {
                    this.renderParticles(morphRenders, true, partialTicks);
                }*/
            }

            for (IComponentParticleMorphRender component : morphRenders)
            {
                if (component.getClass() == BedrockComponentRateSteady.class)
                {
                    if (!particleRendering)
                    {
                        //only spawn particles either in particles or in morph rendering
                        component.postRender(this, partialTicks);
                    }
                }
                else
                {
                    component.postRender(this, partialTicks);
                }
            }
        }
    }

    /**
     * This method renders the particles using morphs
     * @param renderComponents
     * @param collided
     * @param partialTicks
     */
    private void renderParticles(List<? extends IComponentParticleMorphRender> renderComponents, boolean collided, float partialTicks)
    {
        BufferBuilder builder = Tessellator.getInstance().getBuffer();

        for (BedrockParticle particle : this.particles)
        {
            this.setEmitterVariables(partialTicks);
            this.setParticleVariables(particle, partialTicks);

            for (IComponentRenderBase component : renderComponents)
            {
                component.render(this, particle, builder, partialTicks);
            }
        }
    }

    /**
     * This method renders the particles using the default bedrock billboards
     * @param texture Ressource location of the texture to render
     * @param renderComponents
     * @param collided
     * @param partialTicks
     */
    private void renderParticles(ResourceLocation texture, List<? extends IComponentParticleRender> renderComponents, boolean collided, float partialTicks)
    {
        BufferBuilder builder = Tessellator.getInstance().getBuffer();

        GifTexture.bindTexture(texture, this.age, partialTicks);

        builder.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_LMAP_COLOR);

        for (BedrockParticle particle : this.particles)
        {
            boolean collisionStuff = particle.isCollisionTexture(this) || particle.isCollisionTinting(this);

            if (collisionStuff != collided)
            {
                continue;
            }

            this.setEmitterVariables(partialTicks);
            this.setParticleVariables(particle, partialTicks);

            for (IComponentRenderBase component : renderComponents)
            {
                /* if collisionTexture or collisionTinting is true - means that those options are enabled
                 * therefore the old Billboardappearance should not be called
                 * because collisionAppearance.class is rendering
                 */
                if (!(collisionStuff && component.getClass() == BedrockComponentAppearanceBillboard.class))
                {
                    component.render(this, particle, builder, partialTicks);
                }
            }
        }

        Tessellator.getInstance().draw();
    }

    private void setupOpenGL(float partialTicks)
    {
        this.scheme.material.beginGL();

        if (!GuiModelRenderer.isRendering())
        {
            Entity camera = Minecraft.getMinecraft().getRenderViewEntity();
            double playerX = camera.prevPosX + (camera.posX - camera.prevPosX) * (double) partialTicks;
            double playerY = camera.prevPosY + (camera.posY - camera.prevPosY) * (double) partialTicks;
            double playerZ = camera.prevPosZ + (camera.posZ - camera.prevPosZ) * (double) partialTicks;

            BufferBuilder builder = Tessellator.getInstance().getBuffer();

            builder.setTranslation(-playerX, -playerY, -playerZ);

            GlStateManager.disableCull();
            GlStateManager.enableTexture2D();
        }
    }

    private void endOpenGL()
    {
        if (!GuiModelRenderer.isRendering())
        {
            Tessellator.getInstance().getBuffer().setTranslation(0, 0, 0);
        }

        this.scheme.material.endGL();
    }


    private void depthSorting()
    {
        if (Blockbuster.snowstormDepthSorting.get())
        {
            this.particles.sort((a, b) ->
            {
                double ad = a.getDistanceSq(this);
                double bd = b.getDistanceSq(this);

                if (ad < bd)
                {
                    return 1;
                }
                else if (ad > bd)
                {
                    return -1;
                }

                return 0;
            });
        }
    }

    public void setupCameraProperties(float partialTicks)
    {
        if (this.world != null)
        {
            Entity camera = Minecraft.getMinecraft().getRenderViewEntity();

            this.perspective = Minecraft.getMinecraft().gameSettings.thirdPersonView;
            this.cYaw = 180 - Interpolations.lerp(camera.prevRotationYaw, camera.rotationYaw, partialTicks);
            this.cPitch = 180 - Interpolations.lerp(camera.prevRotationPitch, camera.rotationPitch, partialTicks);
            this.cX = Interpolations.lerp(camera.prevPosX, camera.posX, partialTicks);
            this.cY = Interpolations.lerp(camera.prevPosY, camera.posY, partialTicks) + camera.getEyeHeight();
            this.cZ = Interpolations.lerp(camera.prevPosZ, camera.posZ, partialTicks);
        }
    }

    /**
     * Get brightness for the block
     */
    public int getBrightnessForRender(float partialTicks, double x, double y, double z)
    {
        if (this.lit || this.world == null)
        {
            return 15728880;
        }

        this.blockPos.setPos(x, y, z);

        return this.world.isBlockLoaded(this.blockPos) ? this.world.getCombinedLight(this.blockPos, 0) : 0;
    }
}

==================================================

--- Файл №210 ---
Путь: main\java\mchorse\blockbuster\client\particles\emitter\BedrockParticle.java
--------------------
package mchorse.blockbuster.client.particles.emitter;

import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionAppearance;
import mchorse.blockbuster.client.particles.components.appearance.BedrockComponentCollisionTinting;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.metamorph.api.Morph;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.*;
import java.util.HashMap;
import java.util.Map;

public class BedrockParticle
{
    /* Randoms */
    public float random1 = (float) Math.random();
    public float random2 = (float) Math.random();
    public float random3 = (float) Math.random();
    public float random4 = (float) Math.random();

    public Morph morph = new Morph();
    private DummyEntity dummy;

    /* States */
    public int age;
    public int lifetime;
    public boolean dead;
    public boolean relativePosition;
    public boolean relativeRotation;
    public boolean relativeDirection;
    public boolean relativeScale;
    public boolean relativeScaleBillboard;
    public boolean relativeAcceleration;
    public boolean realisticCollisionDrag;
    public float linearVelocity;
    public float angularVelocity;
    public boolean gravity;
    public boolean manual;

    /* Age when the particle should expire */
    private int expireAge = -1;
    /* Used to determine lifetime when expirationDelay is on */
    private int expirationDelay = -1;
    
    /**
     * This is used to estimate whether an object is only bouncing or lying on a surface
     *
     * CollisionTime won't work when e.g. the particle bounces of the surface and directly in the next
     * update cycle hits the same surface side, like from top of the block to bottom of the block...
     * I think this probably never happens in practice
     */
    public Vector3f collisionTime = new Vector3f(-2f, -2f,-2f);
    public HashMap<Entity, Vector3f> entityCollisionTime = new HashMap<>();
    public boolean collided;
    public int bounces;
    /**
     * Is set by collision component when there is a collision an drag should happen.
     */
    public float rotationCollisionDrag = 0;

    /**
     * For collision Appearance needed for animation
     */
    public int firstIntersection = -1;
    public boolean intersected;
    
    /* Rotation */
    public float rotation;
    public float initialRotation;
    public float prevRotation;

    public float rotationVelocity;
    public float rotationAcceleration;
    public float rotationDrag;

    /* for transforming into intertial systems (currently just used for inertia)*/
    public Vector3d offset = new Vector3d();
    /* Position */
    public Vector3d position = new Vector3d();
    public Vector3d initialPosition = new Vector3d();
    public Vector3d prevPosition = new Vector3d();
    public Matrix3f matrix = new Matrix3f();
    private boolean matrixSet;

    public Vector3f speed = new Vector3f();
    public Vector3f acceleration = new Vector3f();
    public Vector3f accelerationFactor = new Vector3f(1, 1, 1);
    public float drag = 0;
    /**
     * Is set by collision component when there is a collision an drag should happen.
     */
    public float dragFactor = 0;

    /* Color */
    public float r = 1;
    public float g = 1;
    public float b = 1;
    public float a = 1;

    private Vector3d global = new Vector3d();

    public BedrockParticle()
    {
        this.speed.set((float) Math.random() - 0.5F, (float) Math.random() - 0.5F, (float) Math.random() - 0.5F);
        this.speed.normalize();
        this.matrix.setIdentity();
    }

    public boolean isCollisionTexture(BedrockEmitter emitter)
    {
        return MolangExpression.isOne(emitter.scheme.getOrCreate(BedrockComponentCollisionAppearance.class).enabled) && this.intersected;
    }

    public boolean isCollisionTinting(BedrockEmitter emitter)
    {
        return MolangExpression.isOne(emitter.scheme.getOrCreate(BedrockComponentCollisionTinting.class).enabled) && this.intersected;
    }

    public int getExpireAge()
    {
        return this.expireAge;
    }

    public int getExpirationDelay()
    {
        return this.expirationDelay;
    }

    /**
     * Copy this particle to the given particle (it does not copy fields that are initialized by components)
     * @param to destiny to copy values to
     * @return copied particle
     */
    public BedrockParticle softCopy(BedrockParticle to)
    {
        to.age = this.age;
        to.expireAge = this.expireAge;
        to.expirationDelay = this.expirationDelay;
        to.realisticCollisionDrag = this.realisticCollisionDrag;
        to.collisionTime = (Vector3f) this.collisionTime.clone();
        to.entityCollisionTime = new HashMap<>();

        for(Map.Entry<Entity, Vector3f> entry : this.entityCollisionTime.entrySet())
        {
            to.entityCollisionTime.put(entry.getKey(), (Vector3f) entry.getValue().clone());
        }

        to.bounces = this.bounces;
        to.firstIntersection = this.firstIntersection;
        to.offset = (Vector3d) this.offset.clone();
        to.position = (Vector3d) this.position.clone();
        to.initialPosition = (Vector3d) this.initialPosition.clone();
        to.prevPosition = (Vector3d) this.prevPosition.clone();
        to.matrix = (Matrix3f) this.matrix.clone();
        to.matrixSet = this.matrixSet;
        to.speed = (Vector3f) this.speed.clone();
        to.acceleration = (Vector3f) this.acceleration.clone();
        to.accelerationFactor = (Vector3f) this.accelerationFactor.clone();
        to.dragFactor = this.dragFactor;
        to.global = (Vector3d) this.global.clone();

        return to;
    }

    public double getDistanceSq(BedrockEmitter emitter)
    {
        Vector3d pos = this.getGlobalPosition(emitter);

        double dx = emitter.cX - pos.x;
        double dy = emitter.cY - pos.y;
        double dz = emitter.cZ - pos.z;

        return dx * dx + dy * dy + dz * dz;
    }

    public double getAge(float partialTick)
    {
        return (this.age + partialTick) / 20.0;
    }

    public Vector3d getGlobalPosition(BedrockEmitter emitter)
    {
        return this.getGlobalPosition(emitter, this.position);
    }

    public Vector3d getGlobalPosition(BedrockEmitter emitter, Vector3d vector)
    {
        double px = vector.x;
        double py = vector.y;
        double pz = vector.z;

        if (this.relativePosition && this.relativeRotation)
        {
            Vector3f v = new Vector3f((float) px, (float) py, (float) pz);
            emitter.rotation.transform(v);

            px = v.x;
            py = v.y;
            pz = v.z;

            px += emitter.lastGlobal.x;
            py += emitter.lastGlobal.y;
            pz += emitter.lastGlobal.z;
        }

        this.global.set(px, py, pz);

        return this.global;
    }

    public void update(BedrockEmitter emitter)
    {
        this.prevRotation = this.rotation;
        this.prevPosition.set(this.position);

        this.setupMatrix(emitter);

        if (!this.manual)
        {
            //this.position.add(this.offset);

            /*if (this.realisticCollisionDrag && Math.round(this.speed.x*10000) == 0 && Math.round(this.speed.y*10000) == 0 && Math.round(this.speed.z*10000) == 0)
            {
                this.dragFactor = 0;
                this.speed.scale(0);
            }*/

            /* lazy fix for transforming from moving intertial system back to global space */
            if (this.entityCollisionTime.isEmpty())
            {
                transformOffsetToGlobal();
            }
            else
            {
                for (HashMap.Entry<Entity, Vector3f> entry : this.entityCollisionTime.entrySet())
                {
                    if (entry.getValue().y != this.age)
                    {
                        transformOffsetToGlobal();
                    }
                }
            }

            //TODO drag force usually takes velocity^2 -> this cuts off higher velocities much quicker but takes longer with slower velocities. maybe two separate options?
            float rotationDrag = (this.rotationDrag + this.rotationCollisionDrag) * this.rotationVelocity;
            float rotationAcceleration = this.rotationAcceleration / 20F;
            /* clamp drag so it doesn't make rotation velocity explode*/
            this.rotationVelocity = MathUtils.clamp(this.rotationVelocity - rotationDrag / 20F,
                    Math.min(this.rotationVelocity, 0), Math.max(this.rotationVelocity, 0));
            this.rotationVelocity += rotationAcceleration / 20F;
            this.rotation += this.rotationVelocity;

            /* Position */
            if (this.age == 0)
            {
                if (this.relativeDirection)
                {
                    emitter.rotation.transform(this.speed);
                }

                if (this.linearVelocity != 0)
                {
                    Vector3f v = new Vector3f(emitter.lastGlobal);
                    v.x -= emitter.prevGlobal.x;
                    v.y -= emitter.prevGlobal.y;
                    v.z -= emitter.prevGlobal.z;

                    this.speed.x += v.x * this.linearVelocity;
                    this.speed.y += v.y * this.linearVelocity;
                    this.speed.z += v.z * this.linearVelocity;
                }

                if (this.angularVelocity != 0)
                {
                    Matrix3f rotation1 = new Matrix3f(emitter.rotation);
                    Matrix3f identity = new Matrix3f();

                    identity.setIdentity();

                    try
                    {
                        Matrix3f rotation0 = new Matrix3f(emitter.prevRotation);

                        rotation0.invert();
                        rotation1.mul(rotation0);

                        Vector3f angularV = MatrixUtils.getAngularVelocity(rotation1);

                        Vector3f radius = new Vector3f(emitter.translation);
                        radius.x += this.position.x - emitter.lastGlobal.x;
                        radius.y += this.position.y - emitter.lastGlobal.y;
                        radius.z += this.position.z - emitter.lastGlobal.z;

                        Vector3f v = new Vector3f();

                        v.cross(angularV, radius);

                        this.speed.x += v.x * this.angularVelocity;
                        this.speed.y += v.y * this.angularVelocity;
                        this.speed.z += v.z * this.angularVelocity;
                    }
                    catch (SingularMatrixException e) {} //maybe check if determinant is zero
                }
            }

            if (this.relativeAcceleration)
            {
                emitter.rotation.transform(this.acceleration);
            }

            if (this.gravity)
            {
                this.acceleration.y -= 9.81;
            }

            Vector3f drag = new Vector3f(this.speed);
            drag.scale(-(this.drag + this.dragFactor));
            /* apply drag separately so we can clamp it - high drag values shouldn't accelerate particles again */
            drag.scale(1 / 20F);
            if (this.speed.length() - drag.length() <= 0) {
                this.speed.scale(0);
            } else {
                this.speed.add(drag);
            }

            this.acceleration.scale(1 / 20F);
            this.speed.add(this.acceleration);

            Vector3f speed0 = new Vector3f(this.speed);
            speed0.x *= this.accelerationFactor.x;
            speed0.y *= this.accelerationFactor.y;
            speed0.z *= this.accelerationFactor.z;

            if (this.relativePosition || this.relativeRotation)
            {
                this.matrix.transform(speed0);
            }

            this.position.x += speed0.x / 20F;
            this.position.y += speed0.y / 20F;
            this.position.z += speed0.z / 20F;

            if (!this.morph.isEmpty())
            {
                EntityLivingBase dummy = this.getDummy(emitter);

                this.morph.get().update(dummy);

                dummy.ticksExisted += 1;
            }
        }

        if (this.lifetime >= 0 &&
            (this.age >= this.lifetime || (this.age >= this.expireAge && this.expireAge != -1)) )
        {
            this.dead = true;
        }

        this.age ++;
        this.acceleration.set(0,0,0);
    }

    /**
     * Sets the expirationDelay and expireAge - the smallest expire age wins. Negative expiration delays always overwrite/win.
     */
    public void setExpirationDelay(double delay)
    {
        int expirationDelay = (int) delay;

        if (this.age + expirationDelay < this.expireAge || this.expireAge == -1)
        {
            this.expirationDelay = Math.abs(expirationDelay);
            this.expireAge = this.age + this.expirationDelay;
        }
    }

    public void setupMatrix(BedrockEmitter emitter)
    {
        if (this.relativePosition)
        {
            if (this.relativeRotation)
            {
                this.matrix.setIdentity();
            }
            else if (!this.matrixSet)
            {
                this.matrix.set(emitter.rotation);
                this.matrixSet = true;
            }
        }
        else if (this.relativeRotation)
        {
            this.matrix.set(emitter.rotation);
        }
    }

    /**
     * This method adds the offset to the speed to transform from a moving inertial system to the global space
     * (especially for inertia)
     */
    public void transformOffsetToGlobal()
    {
        this.offset.scale(6); //scale it up so it gets more noticeable (artistic choice)

        this.speed.x += this.offset.x;
        this.speed.y += this.offset.y;
        this.speed.z += this.offset.z;

        this.offset.scale(0);
    }

    @SideOnly(Side.CLIENT)
    public EntityLivingBase getDummy(BedrockEmitter emitter)
    {
        if (this.dummy == null)
        {
            this.dummy = new DummyEntity(Minecraft.getMinecraft().world);
        }

        Vector3d pos = this.getGlobalPosition(emitter);

        this.dummy.setPosition(pos.x, pos.y, pos.z);
        this.dummy.prevPosX = this.dummy.posX;
        this.dummy.prevPosY = this.dummy.posY;
        this.dummy.prevPosZ = this.dummy.posZ;
        this.dummy.lastTickPosX = this.dummy.posX;
        this.dummy.lastTickPosY = this.dummy.posY;
        this.dummy.lastTickPosZ = this.dummy.posZ;
        this.dummy.rotationYaw = this.dummy.prevRotationYaw = 0;
        this.dummy.rotationPitch = this.dummy.prevRotationPitch = 0;
        this.dummy.rotationYawHead = this.dummy.prevRotationYawHead = 0;
        this.dummy.renderYawOffset = this.dummy.prevRenderYawOffset = 0;

        return this.dummy;
    }
}


==================================================

--- Файл №211 ---
Путь: main\java\mchorse\blockbuster\client\render\GunMiscRender.java
--------------------
package mchorse.blockbuster.client.render;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.KeyboardHandler;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketZoomCommand;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHand;
import net.minecraftforge.client.event.RenderGameOverlayEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.util.vector.Vector3f;

/**
 * \* User: Evanechecssss
 * \* https://bio.link/evanechecssss
 * \* Data: 17.11.2021
 * \* Description:
 * \
 */
@SideOnly(Side.CLIENT)
public class GunMiscRender
{
    public static float ZOOM_TIME;
    public static float UN_ZOOM_TIME;
    public static boolean onZoom = true;
    private boolean hasChangedSensitivity = false;
    private boolean hasChangedFov = false;
    private float lastMouseSensitivity;
    private float lastFov;

    public Vector3f translate = new Vector3f();
    public Vector3f scale = new Vector3f(1F, 1F, 1F);
    public Vector3f rotate = new Vector3f();
    
    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public void onTick(TickEvent.RenderTickEvent event)
    {
        if (Minecraft.getMinecraft().player != null && event.phase.equals(TickEvent.Phase.END))
        {
            EntityPlayer player = Minecraft.getMinecraft().player;
            ItemStack heldItem = player.getHeldItem(EnumHand.MAIN_HAND);
            GunProps props = NBTUtils.getGunProps(heldItem);
            
            if (heldItem.getItem().equals(Blockbuster.gunItem))
            {
                this.handleZoom(event.renderTickTime);
            }

            if (ZOOM_TIME == 0)
            {
                if (hasChangedFov)
                {
                    hasChangedFov = false;
                    Minecraft.getMinecraft().gameSettings.fovSetting = lastFov;
                }
                else
                {
                    lastFov = Minecraft.getMinecraft().gameSettings.fovSetting;
                }
                
                Minecraft.getMinecraft().renderGlobal.setDisplayListEntitiesDirty();
    
                if (hasChangedSensitivity)
                {
                    hasChangedSensitivity = false;
                    Minecraft.getMinecraft().gameSettings.mouseSensitivity = lastMouseSensitivity;
                }
                else
                {
                    lastMouseSensitivity = Minecraft.getMinecraft().gameSettings.mouseSensitivity;
                }
            }
            else if (ZOOM_TIME != 0)
            {
                if (heldItem.getItem().equals(Blockbuster.gunItem) && KeyboardHandler.zoom.isKeyDown())
                {
                    hasChangedSensitivity = true;
                    hasChangedFov = true;
                    
                    if (props != null)
                    {
                        Minecraft.getMinecraft().gameSettings.mouseSensitivity = lastMouseSensitivity * props.mouseZoom - 0.3f;
                        Minecraft.getMinecraft().gameSettings.fovSetting = lastFov - lastFov * ZOOM_TIME * props.zoomFactor;
                        Minecraft.getMinecraft().renderGlobal.setDisplayListEntitiesDirty();
    
                    }
                }
                else
                {
                    hasChangedSensitivity = true;
                    hasChangedFov = true;
                    Minecraft.getMinecraft().gameSettings.mouseSensitivity = lastMouseSensitivity;
                    Minecraft.getMinecraft().gameSettings.fovSetting = lastFov;
                }
            }

        }
    }
    
    private void handleZoom(float partialTick)
    {
        boolean zoomed = onZoom;
        
        if (KeyboardHandler.zoom.isKeyDown())
        {
            onZoom = true;
            ZOOM_TIME = Math.min(ZOOM_TIME + partialTick * 0.1F, 1);
            UN_ZOOM_TIME = Math.max(UN_ZOOM_TIME - partialTick * 0.2F, 0);
            
            if (!zoomed)
            {
                Dispatcher.sendToServer(new PacketZoomCommand(Minecraft.getMinecraft().player.getEntityId(), true));
            }
        }
        else
        {
            onZoom = false;
            ZOOM_TIME = Math.max(ZOOM_TIME - partialTick * 0.1F, 0);
            UN_ZOOM_TIME = Math.min(UN_ZOOM_TIME + partialTick * 0.2F, 1);
            
            if (zoomed)
            {
                Dispatcher.sendToServer(new PacketZoomCommand(Minecraft.getMinecraft().player.getEntityId(), false));
            }
        }
    }
    
    @SideOnly(Side.CLIENT)
    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void renderGameOverlay(RenderGameOverlayEvent event)
    {
        if (event.getType() == RenderGameOverlayEvent.ElementType.CROSSHAIRS)
        {
            Minecraft mc = Minecraft.getMinecraft();
            ItemStack gun = mc.player.getHeldItemMainhand();

            if (gun.getItem() instanceof ItemGun)
            {
                GunProps props = NBTUtils.getGunProps(gun);

                if (props == null)
                {
                    return;
                }
                if ((props.hideCrosshairOnZoom && KeyboardHandler.zoom.isKeyDown()) || !props.currentCrosshair.isEmpty())
                {
                    event.setCanceled(true);
                }
            }
        }
    }
    
    @SideOnly(Side.CLIENT)
    @SubscribeEvent
    public void onHUDRender(RenderGameOverlayEvent.Post event)
    {
        ScaledResolution resolution = event.getResolution();

        if (event.getType() == RenderGameOverlayEvent.ElementType.ALL)
        {
            EntityPlayer player = Minecraft.getMinecraft().player;

            if (player.getHeldItemMainhand().getItem() instanceof ItemGun)
            {
                GunProps props = NBTUtils.getGunProps(player.getHeldItemMainhand());

                if (props != null && props.crosshairMorph != null && !(KeyboardHandler.zoom.isKeyDown() && props.hideCrosshairOnZoom))
                {
                    render(props.currentCrosshair.get(), resolution.getScaledWidth(), resolution.getScaledHeight());
                }
            }
        }
    }
    
    public void render(AbstractMorph morph, int width, int height)
    {
        if (morph == null)
        {
            return;
        }

        Minecraft mc = Minecraft.getMinecraft();

        GlStateManager.pushMatrix();
        GlStateManager.translate(0.5F, 0, 0.5F);
        enableGLStates();

        morph.renderOnScreen(mc.player, (width / 2) + (int) morph.cachedTranslation.x, (height / 2) + (int) morph.cachedTranslation.y, 15, 1f);

        GlStateManager.popMatrix();
    }
    
    private void enableGLStates()
    {
        RenderHelper.enableStandardItemLighting();
        GlStateManager.enableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableRescaleNormal();
        GlStateManager.enableDepth();
        GlStateManager.disableCull();
        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
    }
}

==================================================

--- Файл №212 ---
Путь: main\java\mchorse\blockbuster\client\render\IRenderLast.java
--------------------
package mchorse.blockbuster.client.render;

import javax.vecmath.Vector3d;

public interface IRenderLast
{
    /**
     * @return the position used to depth sort
     */
    public Vector3d getRenderLastPos();
}


==================================================

--- Файл №213 ---
Путь: main\java\mchorse\blockbuster\client\render\RenderActor.java
--------------------
package mchorse.blockbuster.client.render;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.culling.ICamera;
import net.minecraft.client.renderer.entity.RenderLiving;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.client.registry.IRenderFactory;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;

/**
 * Render actor class
 *
 * Render actor entities with custom swaggalicious models ?8|
 */
public class RenderActor extends RenderLiving<EntityActor>
{
    /**
     * Default texture of the renderer
     */
    private static final ResourceLocation defaultTexture = new ResourceLocation(Blockbuster.MOD_ID, "textures/entity/actor.png");

    /**
     * Initiate render actor
     */
    public RenderActor(RenderManager manager, float shadow)
    {
        super(manager, null, shadow);
    }

    /**
     * Use skin from resource pack or default one (if skin is empty or just
     * wasn't found by actor pack)
     */
    @Override
    protected ResourceLocation getEntityTexture(EntityActor entity)
    {
        return defaultTexture;
    }

    @Override
    public boolean shouldRender(EntityActor livingEntity, ICamera camera, double camX, double camY, double camZ)
    {
        if (livingEntity.renderLast && RenderingHandler.addRenderLast(livingEntity))
        {
            return false;
        }

        if (Blockbuster.actorAlwaysRender.get())
        {
            return true;
        }

        return super.shouldRender(livingEntity, camera, camX, camY, camZ);
    }

    @Override
    public void doRender(EntityActor entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        this.shadowOpaque = 0;

        if (entity.invisible)
        {
            this.renderPlayerRecordingName(entity, x, y, z);

            return;
        }

        AbstractMorph morph = entity.getMorph();

        if (morph != null)
        {
            this.shadowOpaque = 1.0F;

            float shadow = 0.5F;

            if (morph instanceof CustomMorph)
            {
                CustomMorph custom = (CustomMorph) morph;

                if (custom.model != null)
                {
                    shadow = custom.getWidth(entity) * custom.model.scale[0];
                }
            }

            this.shadowSize = shadow;

            morph.render(entity, x, y, z, entityYaw, partialTicks);
        }

        this.renderLeash(entity, x, y, z, entityYaw, partialTicks);
        this.renderPlayerRecordingName(entity, x, y, z);

        if (entity.playback != null && entity.playback.record != null)
        {
            RenderingHandler.recordsToRender.add(entity.playback.record);
        }
    }

    /**
     * Renders player recording name
     */
    private void renderPlayerRecordingName(EntityActor entity, double x, double y, double z)
    {
        if (!Minecraft.getMinecraft().gameSettings.showDebugInfo)
        {
            return;
        }

        final double maxDistance = 64;
        double d0 = entity.getDistanceSq(this.renderManager.renderViewEntity);

        if (d0 <= (maxDistance * maxDistance) && entity.playback != null && entity.playback.record != null)
        {
            float viewerYaw = this.renderManager.playerViewY;
            float viewerPitch = this.renderManager.playerViewX;
            boolean isThirdPersonFrontal = this.renderManager.options.thirdPersonView == 2;
            float f2 = entity.height / 2;
            String str = entity.playback.record.filename;
            FontRenderer fontRendererIn = this.getFontRendererFromRenderManager();
            int verticalShift = -fontRendererIn.FONT_HEIGHT / 2;

            y += f2;

            int shader = GL11.glGetInteger(GL20.GL_CURRENT_PROGRAM);

            if (shader != 0)
            {
                OpenGlHelper.glUseProgram(0);
            }

            GlStateManager.pushMatrix();
            GlStateManager.translate(x, y, z);
            GlStateManager.glNormal3f(0.0F, 1.0F, 0.0F);
            GlStateManager.rotate(-viewerYaw, 0.0F, 1.0F, 0.0F);
            GlStateManager.rotate((float)(isThirdPersonFrontal ? -1 : 1) * viewerPitch, 1.0F, 0.0F, 0.0F);
            GlStateManager.scale(-0.025F, -0.025F, 0.025F);
            GlStateManager.disableLighting();
            GlStateManager.disableDepth();

            GlStateManager.enableBlend();
            GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
            int i = fontRendererIn.getStringWidth(str) / 2;
            GlStateManager.disableTexture2D();
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder vertexbuffer = tessellator.getBuffer();
            vertexbuffer.begin(7, DefaultVertexFormats.POSITION_COLOR);
            vertexbuffer.pos((double)(-i - 1), (double)(-1 + verticalShift), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
            vertexbuffer.pos((double)(-i - 1), (double)(8 + verticalShift), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
            vertexbuffer.pos((double)(i + 1), (double)(8 + verticalShift), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
            vertexbuffer.pos((double)(i + 1), (double)(-1 + verticalShift), 0.0D).color(0.0F, 0.0F, 0.0F, 0.25F).endVertex();
            tessellator.draw();
            GlStateManager.enableTexture2D();

            fontRendererIn.drawString(str, -fontRendererIn.getStringWidth(str) / 2, verticalShift, -1);

            GlStateManager.enableDepth();
            GlStateManager.enableLighting();
            GlStateManager.disableBlend();
            GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
            GlStateManager.popMatrix();

            if (shader != 0)
            {
                OpenGlHelper.glUseProgram(shader);
            }
        }
    }

    /**
     * Renderer factory
     *
     * Some interface provided by Minecraft Forge that will pass a RenderManager
     * instance into the method for easier Renders initiation.
     */
    public static class FactoryActor implements IRenderFactory<EntityActor>
    {
        @Override
        public RenderActor createRenderFor(RenderManager manager)
        {
            return new RenderActor(manager, 0.5F);
        }
    }
}

==================================================

--- Файл №214 ---
Путь: main\java\mchorse\blockbuster\client\render\RenderCustomModel.java
--------------------
package mchorse.blockbuster.client.render;

import java.util.List;
import java.util.Map;

import javax.vecmath.Matrix4d;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector4f;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.common.OrientedBB;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.blockbuster_pack.morphs.SnowstormMorph;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class RenderCustomModel extends RenderLivingBase<EntityLivingBase>
{
    /**
     * Last bind texture
     */
    public static ResourceLocation lastTexture;

    /**
     * Currently used morph 
     */
    public CustomMorph current;

    private int captured;
    private boolean capturedByMe;

    public static void bindLastTexture(ResourceLocation location)
    {
        lastTexture = location;
        bindLastTexture();
    }

    public static void bindLastTexture()
    {
        if (lastTexture != null)
        {
            Minecraft.getMinecraft().renderEngine.bindTexture(lastTexture);
        }
    }

    public RenderCustomModel(RenderManager renderManagerIn, ModelBase modelBaseIn, float shadowSizeIn)
    {
        super(renderManagerIn, null, shadowSizeIn);
    }

    /**
     * Get default texture for entity 
     */
    @Override
    protected ResourceLocation getEntityTexture(EntityLivingBase entity)
    {
        return this.mainModel == null ? null : ((ModelCustom) this.mainModel).model.defaultTexture;
    }

    protected boolean bindEntityTexture(EntityLivingBase entity)
    {
        if (this.mainModel != null && ((ModelCustom) this.mainModel).model.providesMtl)
        {
            ResourceLocation texture = this.getEntityTexture(entity);

            if (texture == null)
            {
                return true;
            }
        }

        return super.bindEntityTexture(entity);
    }

    /**
     * Override method in order to save the last texture. Used by OBJ 
     * renderer with materials to bind texture back 
     */
    @Override
    public void bindTexture(ResourceLocation location)
    {
        lastTexture = location;

        super.bindTexture(location);
    }

    /**
     * Render morph's name only if the player is pointed at the entity
     */
    @Override
    protected boolean canRenderName(EntityLivingBase entity)
    {
        return super.canRenderName(entity) && entity.hasCustomName() && entity == this.renderManager.pointedEntity;
    }

    @Override
    public void doRender(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        this.setupModel(entity, partialTicks);

        if (this.mainModel != null)
        {
            super.doRender(entity, x, y, z, entityYaw, partialTicks);
        }

        if (this.captured > 0)
        {
            this.captured --;

            if (this.captured == 0 && this.capturedByMe)
            {
                MatrixUtils.releaseMatrix();

                this.capturedByMe = false;
            }
        }
    }

    @Override
    protected void renderLivingAt(EntityLivingBase entityLivingBaseIn, double x, double y, double z)
    {
        super.renderLivingAt(entityLivingBaseIn, x, y, z);

        if (this.captured == 0)
        {
            this.capturedByMe = MatrixUtils.captureMatrix();
        }

        this.captured ++;
    }

    /**
     * Setup the model for player instance.
     *
     * This method is responsible for picking the right model and pose based
     * on player properties.
     */
    public void setupModel(EntityLivingBase entity, float partialTicks)
    {
        Map<String, ModelCustom> models = ModelCustom.MODELS;
        ModelCustom model = null;
        ModelPose pose = null;

        if (this.current != null)
        {
            model = models.get(this.current.getKey());
            pose = this.current.getPose(entity, partialTicks);
        }

        if (model != null)
        {
            if (pose == null)
            {
                pose = model.model.getPose("standing");
            }

            model.materials = this.current.materials;
            model.shapes = this.current.getShapesForRendering(partialTicks);
            model.pose = pose;
            model.current = this.current;
            this.mainModel = model;
        }
    }

    /**
     * Make player a little bit smaller (so he looked like steve, and not like an 
     * overgrown rodent).
     */
    @Override
    protected void preRenderCallback(EntityLivingBase entity, float partialTickTime)
    {
        Model model = ((ModelCustom) this.mainModel).model;
        float scale = this.current == null ? 1.0F : this.current.scale;

        GlStateManager.scale(model.scale[0] * scale, model.scale[1] * scale, model.scale[2] * scale);
    }

    /**
     * Taken from RenderPlayer
     *
     * This code is primarily changes the angle of the player while it's flying
     * an elytra. You know?
     */
    @Override
    protected void applyRotations(EntityLivingBase entity, float pitch, float yaw, float partialTicks)
    {
        if (entity.isEntityAlive() && entity.isPlayerSleeping())
        {
            /* Nap time! */
            GlStateManager.rotate(((EntityPlayer) entity).getBedOrientationInDegrees(), 0.0F, 1.0F, 0.0F);
            GlStateManager.rotate(this.getDeathMaxRotation(entity), 0.0F, 0.0F, 1.0F);
            GlStateManager.rotate(270.0F, 0.0F, 1.0F, 0.0F);
        }
        else if (entity.isElytraFlying())
        {
            /* Elytra rotation */
            super.applyRotations(entity, pitch, yaw, partialTicks);

            float f = entity.getTicksElytraFlying() + partialTicks;
            float f1 = MathHelper.clamp(f * f / 100.0F, 0.0F, 1.0F);

            Vec3d vec3d = entity.getLook(partialTicks);

            double d0 = entity.motionX * entity.motionX + entity.motionZ * entity.motionZ;
            double d1 = vec3d.x * vec3d.x + vec3d.z * vec3d.z;

            GlStateManager.rotate(f1 * (-90.0F - entity.rotationPitch), 1.0F, 0.0F, 0.0F);

            if (d0 > 0.0D && d1 > 0.0D)
            {
                double d2 = (entity.motionX * vec3d.x + entity.motionZ * vec3d.z) / (Math.sqrt(d0) * Math.sqrt(d1));
                double d3 = entity.motionX * vec3d.z - entity.motionZ * vec3d.x;

                GlStateManager.rotate((float) (Math.signum(d3) * Math.acos(d2)) * 180.0F / (float) Math.PI, 0.0F, 1.0F, 0.0F);
            }
        }
        else
        {
            super.applyRotations(entity, pitch, yaw, partialTicks);
        }
    }

    /**
     * Render right hand 
     */
    public void renderRightArm(EntityPlayer player)
    {
        ResourceLocation texture = this.getEntityTexture(player);

        if (texture != null)
        {
            this.bindTexture(texture);
        }

        this.mainModel.swingProgress = 0.0F;
        this.mainModel.setRotationAngles(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0625F, player);

        GlStateManager.color(1.0F, 1.0F, 1.0F);
        GlStateManager.enableBlend();

        for (ModelCustomRenderer arm : ((ModelCustom) this.mainModel).right)
        {
            arm.rotateAngleX = 0;
            arm.rotationPointX = -6;
            arm.rotationPointY = 13.8F - (arm.limb.size[1] > 8 ? arm.limb.size[1] : arm.limb.size[1] + 2);
            arm.rotationPointZ = 0;
            arm.render(0.0625F);
        }

        GlStateManager.disableBlend();
    }

    /**
     * Render left hand 
     */
    public void renderLeftArm(EntityPlayer player)
    {
        ResourceLocation texture = this.getEntityTexture(player);

        if (texture != null)
        {
            this.bindTexture(texture);
        }

        this.mainModel.swingProgress = 0.0F;
        this.mainModel.setRotationAngles(0.0F, 0.0F, 0.0F, 0.0F, 0.0F, 0.0625F, player);

        GlStateManager.color(1.0F, 1.0F, 1.0F);
        GlStateManager.enableBlend();

        for (ModelCustomRenderer arm : ((ModelCustom) this.mainModel).left)
        {
            arm.rotateAngleX = 0;
            arm.rotationPointX = 6;
            arm.rotationPointY = 13.8F - (arm.limb.size[1] > 8 ? arm.limb.size[1] : arm.limb.size[1] + 2F);
            arm.rotationPointZ = 0;
            arm.render(0.0625F);
        }

        GlStateManager.disableBlend();
    }
}

==================================================

--- Файл №215 ---
Путь: main\java\mchorse\blockbuster\client\render\RenderExpirableDummy.java
--------------------
package mchorse.blockbuster.client.render;

import mchorse.blockbuster.common.entity.ExpirableDummyEntity;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.culling.ICamera;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.Entity;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.client.registry.IRenderFactory;

import javax.annotation.Nullable;

public class RenderExpirableDummy extends RenderLivingBase<ExpirableDummyEntity> {
    public RenderExpirableDummy(RenderManager renderManagerIn, ModelBase modelBaseIn, float shadowSizeIn) {
        super(renderManagerIn, modelBaseIn, shadowSizeIn);
    }

    @Override
    public void doRenderShadowAndFire(Entity entityIn, double x, double y, double z, float yaw, float partialTicks) {}

    @Override
    public boolean shouldRender(ExpirableDummyEntity livingEntity, ICamera camera, double camX, double camY, double camZ)
    {
        return false;
    }

    @Override
    public void doRender(ExpirableDummyEntity entity, double x, double y, double z, float entityYaw, float partialTicks) { }

    @Nullable
    @Override
    protected ResourceLocation getEntityTexture(ExpirableDummyEntity entity) {
        return null;
    }

    public static class FactoryExpirableDummy implements IRenderFactory<ExpirableDummyEntity>
    {
        @Override
        public RenderExpirableDummy createRenderFor(RenderManager manager)
        {
            return new RenderExpirableDummy(manager, null, 0);
        }
    }
}


==================================================

--- Файл №216 ---
Путь: main\java\mchorse\blockbuster\client\render\RenderGunProjectile.java
--------------------
package mchorse.blockbuster.client.render;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.culling.ICamera;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.client.registry.IRenderFactory;

/**
 * Gun projectile renderer
 * 
 * This bad boy is responsible for rendering the projectile shot from 
 * the gun.
 */
public class RenderGunProjectile extends Render<EntityGunProjectile>
{
    protected RenderGunProjectile(RenderManager renderManager)
    {
        super(renderManager);
    }

    @Override
    public boolean shouldRender(EntityGunProjectile livingEntity, ICamera camera, double camX, double camY, double camZ)
    {
        if (Blockbuster.actorAlwaysRender.get())
        {
            return true;
        }

        return super.shouldRender(livingEntity, camera, camX, camY, camZ);
    }

    @Override
    protected ResourceLocation getEntityTexture(EntityGunProjectile entity)
    {
        return null;
    }

    @Override
    public void doRender(EntityGunProjectile entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        AbstractMorph morph = entity.morph.get();

        if (entity.props != null && morph != null)
        {
            int length = entity.props.lifeSpan;
            float timer = entity.ticksExisted + partialTicks;
            float scale = Interpolations.envelope(timer > length ? length : timer, 0, entity.props.fadeIn, length - entity.props.fadeOut, length);

            if (entity.vanish && entity.props.vanishDelay > 0)
            {
                scale = Interpolations.envelope(entity.vanishDelay - partialTicks, 0, entity.props.fadeOut, entity.props.vanishDelay, entity.props.vanishDelay);
            }

            /* A small scale factor to avoid Z fighting */
            scale += (entity.getEntityId() % 100) / 10000F;

            GlStateManager.pushMatrix();
            GlStateManager.translate(x, y, z);

            boolean captured = MatrixUtils.captureMatrix();

            GlStateManager.scale(scale, scale, scale);

            if (entity.props.yaw) GlStateManager.rotate(entity.prevRotationYaw + (entity.rotationYaw - entity.prevRotationYaw) * partialTicks, 0.0F, 1.0F, 0.0F);
            if (entity.props.pitch) GlStateManager.rotate(-(entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks) + 90, 1.0F, 0.0F, 0.0F);

            entity.props.projectileTransform.transform();
            entity.props.createEntity();
            morph.render(entity.props.getEntity(entity), 0, 0, 0, 0, partialTicks);

            if (captured)
            {
                MatrixUtils.releaseMatrix();
            }

            GlStateManager.popMatrix();
        }
    }

    public static class FactoryGunProjectile implements IRenderFactory<EntityGunProjectile>
    {
        @Override
        public Render<? super EntityGunProjectile> createRenderFor(RenderManager manager)
        {
            return new RenderGunProjectile(manager);
        }
    }
}

==================================================

--- Файл №217 ---
Путь: main\java\mchorse\blockbuster\client\render\layer\LayerHeldItem.java
--------------------
package mchorse.blockbuster.client.render.layer;

import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.layers.LayerRenderer;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHandSide;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * This is patched LayerHeldItem layer class. This class is responsible for
 * rendering items in designated limbs in custom actor model. Lots of fun
 * stuff going on here.
 */
@SideOnly(Side.CLIENT)
public class LayerHeldItem implements LayerRenderer<EntityLivingBase>
{
    protected final RenderLivingBase<?> livingEntityRenderer;

    public LayerHeldItem(RenderLivingBase<?> livingEntityRendererIn)
    {
        this.livingEntityRenderer = livingEntityRendererIn;
    }

    @Override
    public void doRenderLayer(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        ItemStack itemstack1 = entity.getHeldItemMainhand();
        ItemStack itemstack = entity.getHeldItemOffhand();

        if (!itemstack.isEmpty() || !itemstack1.isEmpty())
        {
            HeldModel model = new HeldModel(((ModelCustom) this.livingEntityRenderer.getMainModel()));

            model.limbSwing = limbSwing;
            model.limbSwingAmount = limbSwingAmount;
            model.ageInTicks = ageInTicks;
            model.netHeadYaw = netHeadYaw;
            model.headPitch = headPitch;
            model.scale = scale;

            renderHeldItem(entity, itemstack1, model, ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND, EnumHandSide.RIGHT);
            renderHeldItem(entity, itemstack, model, ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND, EnumHandSide.LEFT);

            model.model.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, entity);
        }
    }

    /**
     * Render item in every arm.
     *
     * <p>Items could be rendered to several limbs.</p>
     */
    public static void renderHeldItem(EntityLivingBase entity, ItemStack item, HeldModel model, ItemCameraTransforms.TransformType transform, EnumHandSide handSide)
    {
        if (!item.isEmpty())
        {
            for (ModelCustomRenderer arm : model.model.getRenderForArm(handSide))
            {
                boolean flag = handSide == EnumHandSide.LEFT;

                model.setup(entity);
                GlStateManager.pushMatrix();
                applyTransform(arm);

                Minecraft.getMinecraft().getItemRenderer().renderItemSide(entity, item, transform, flag);
                GlStateManager.popMatrix();
            }
        }
    }

    /**
     * Render item in every arm.
     * <p>
     * Items could be rendered to several limbs.
     */
    public static void renderHeldItem(EntityLivingBase entity, ItemStack item, ModelCustom model, ItemCameraTransforms.TransformType transform, EnumHandSide handSide)
    {
        if (item != null)
        {
            for (ModelCustomRenderer arm : model.getRenderForArm(handSide))
            {
                boolean flag = handSide == EnumHandSide.LEFT;

                GlStateManager.pushMatrix();
                applyTransform(arm);

                Minecraft.getMinecraft().getItemRenderer().renderItemSide(entity, item, transform, flag);
                GlStateManager.popMatrix();
            }
        }
    }

    private static void applyTransform(ModelCustomRenderer arm)
    {
        float x = (arm.limb.size[0] * (0.5F - arm.limb.anchor[0])) * 0.0625F;
        float y = arm.limb.size[1] * (arm.limb.size[1] * (1 - arm.limb.anchor[1]) / arm.limb.size[1]) * -0.0625F;
        float z = (arm.limb.size[2] * (arm.limb.anchor[2])) * 0.0625F;

        if (arm.limb.size[0] > arm.limb.size[1])
        {
            x = arm.limb.size[0] * (10.0F / 12.0F) * 0.0625F;
        }

        arm.postRender(0.0625F);

        GlStateManager.rotate(-90.0F, 1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
        GlStateManager.translate(x, z, y);

        if (arm.limb.size[0] > arm.limb.size[1])
        {
            GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
        }

        GlStateManager.scale(arm.limb.itemScale, arm.limb.itemScale, arm.limb.itemScale);
    }

    /**
     * Don't really understand how this method is going to affect the rendering
     * of this layer.
     */
    @Override
    public boolean shouldCombineTextures()
    {
        return false;
    }

    /**
     * Held model class
     * <p>
     * This class is responsible for storing the data related to rendering of
     * some stuff in the layer class. This is needed to store the rotation and
     * angles during that stage, because recursive model block item stack
     * rendering messing up the angles, this class used to restore the original
     * state.
     */
    public static class HeldModel
    {
        public float limbSwing;
        public float limbSwingAmount;
        public float ageInTicks;
        public float netHeadYaw;
        public float headPitch;
        public float scale;

        public ModelCustom model;
        public ModelPose pose;

        public HeldModel(ModelCustom model)
        {
            this.model = model;
            this.pose = model.pose;
        }

        public void setup(EntityLivingBase entity)
        {
            this.model.pose = this.pose;
            this.model.setRotationAngles(this.limbSwing, this.limbSwingAmount, this.ageInTicks, this.netHeadYaw, this.headPitch, this.scale, entity);
        }
    }
}

==================================================

--- Файл №218 ---
Путь: main\java\mchorse\blockbuster\client\render\tileentity\TileEntityDirectorRenderer.java
--------------------
package mchorse.blockbuster.client.render.tileentity;

import mchorse.blockbuster.common.tileentity.TileEntityDirector;
import mchorse.mclib.client.Draw;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;

public class TileEntityDirectorRenderer extends TileEntitySpecialRenderer<TileEntityDirector>
{
    @Override
    public void render(TileEntityDirector te, double x, double y, double z, float partialTicks, int destroyStage, float alpha)
    {
        Minecraft mc = Minecraft.getMinecraft();

        /* Debug render (so people could find the block, lmao) */
        if (mc.gameSettings.showDebugInfo && !mc.gameSettings.hideGUI)
        {
            int shader = GL11.glGetInteger(GL20.GL_CURRENT_PROGRAM);

            if (shader != 0)
            {
                OpenGlHelper.glUseProgram(0);
            }

            GlStateManager.disableDepth();
            GlStateManager.disableLighting();
            GlStateManager.disableTexture2D();
            GlStateManager.enableBlend();

            Draw.cube(x + 0.25F, y + 0.25F, z + 0.25F, x + 0.75F, y + 0.75F, z + 0.75F, 1, 0, 0, 0.5F);

            GlStateManager.disableBlend();
            GlStateManager.enableTexture2D();
            GlStateManager.enableLighting();
            GlStateManager.enableDepth();

            if (shader != 0)
            {
                OpenGlHelper.glUseProgram(shader);
            }
        }
    }
}

==================================================

--- Файл №219 ---
Путь: main\java\mchorse\blockbuster\client\render\tileentity\TileEntityGunItemStackRenderer.java
--------------------
package mchorse.blockbuster.client.render.tileentity;

import mchorse.blockbuster.client.KeyboardHandler;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.utils.NBTUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Gun items's TEISR
 *
 * <p>This class is responsible for rendering gun items</p>
 */
@SideOnly(Side.CLIENT)
public class TileEntityGunItemStackRenderer extends TileEntityItemStackRenderer
{
    /**
     * A cache of model TEs
     */
    public static final Map<ItemStack, GunEntry> models = new HashMap<ItemStack, GunEntry>();
    private static boolean isRendering;

    public static boolean isRendering()
    {
        return isRendering;
    }

    @Override
    public void renderByItem(ItemStack stack, float partialTicks)
    {
        isRendering = true;

        /* Thank you Mojang, very cool! */
        partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();

        GunEntry model = models.get(stack);

        if (model == null)
        {
            GunProps props = NBTUtils.getGunProps(stack);

            if (props != null)
            {
                model = new GunEntry(props);
                models.put(stack, model);
            }
        }

        if (model != null)
        {
            /*
             * timer in ticks when to remove items that are not rendered anymore
             * 5 should be enough to ensure that even with very low fps the model doesn't get removed unnecessarily
             */
            model.timer = 5;

            boolean firstPerson = RenderingHandler.itemTransformType == ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND
                || RenderingHandler.itemTransformType == ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND;

            if (
                RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.GUI &&
                RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND &&
                RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND &&
                RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.FIXED &&
                RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.GROUND
            ) {
                if (!(KeyboardHandler.zoom.isKeyDown() && model.props.hideHandsOnZoom))
                {
                    model.props.renderHands(RenderingHandler.getLastItemHolder(), partialTicks, firstPerson);
                }

                if (model.props.useZoomOverlayMorph && KeyboardHandler.zoom.isKeyDown())
                {
                    model.props.renderZoomOverlay(RenderingHandler.getLastItemHolder(), partialTicks);
                }
            }
            
            if (RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.GUI)
            {
                if (KeyboardHandler.zoom.isKeyDown() && model.props.hideHandsOnZoom)
                {
                    if (
                        RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND &&
                        RenderingHandler.itemTransformType != ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND
                    ) {
                        model.props.render(RenderingHandler.getLastItemHolder(), partialTicks, firstPerson);
                    }
                }
                else
                {
                    model.props.render(RenderingHandler.getLastItemHolder(), partialTicks, firstPerson);
                }
            }
            
            if (RenderingHandler.itemTransformType == ItemCameraTransforms.TransformType.GUI)
            {
                if (model.props.useInventoryMorph && model.props.inventoryMorph != null)
                {
                    model.props.renderInventoryMorph(RenderingHandler.getLastItemHolder(), partialTicks);
                }
                else
                {
                    model.props.render(RenderingHandler.getLastItemHolder(), partialTicks, firstPerson);
                }
            }

            this.reset();
        }
        isRendering = false;
    }

    public void reset()
    {
        Minecraft mc = Minecraft.getMinecraft();
        TextureManager manager = mc.getTextureManager();

        manager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
        mc.getTextureMapBlocks().setBlurMipmapDirect(false, true);
        mc.getTextureMapBlocks().setBlurMipmap(false, false);
    }

    public static class GunEntry
    {
        public int timer = 20;
        public GunProps props;

        public GunEntry(GunProps props)
        {
            this.props = props;
        }
    }
}

==================================================

--- Файл №220 ---
Путь: main\java\mchorse\blockbuster\client\render\tileentity\TileEntityModelItemStackRenderer.java
--------------------
package mchorse.blockbuster.client.render.tileentity;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.tileentity.TileEntityItemStackRenderer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Matrix4f;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * Model block's TEISR
 * 
 * This class is responsible for rendering model blocks in inventory
 */
@SideOnly(Side.CLIENT)
public class TileEntityModelItemStackRenderer extends TileEntityItemStackRenderer
{
    /**
     * Default tile entity model
     */
    public TileEntityModel def;

    /**
     * A cache of model TEs
     */
    public static final Map<NBTTagCompound, TEModel> models = new HashMap<NBTTagCompound, TEModel>();

    private static boolean isRendering;

    public static boolean isRendering()
    {
        return isRendering;
    }

    @Override
    public void renderByItem(ItemStack stack, float partialTicks)
    {
        /* Thank you Mojang, very cool! */
        partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();

        if (this.def == null)
        {
            this.def = new TileEntityModel();
        }

        NBTTagCompound tag = stack.getTagCompound();

        if (tag != null)
        {
            TEModel model = models.get(tag);

            if (model == null)
            {
                TileEntityModel te = new TileEntityModel();
                te.readFromNBT(tag.getCompoundTag("BlockEntityTag"));

                model = new TEModel(te);
                models.put(tag, model);
            }
            
            /*
             * timer in ticks when to remove items that are not rendered anymore
             * 5 should be enough to ensure that even with very low fps the model doesn't get removed unnecessarily
             */
            model.timer = 5;
            this.renderModel(model.model, partialTicks);

            return;
        }

        this.renderModel(this.def, partialTicks);
    }

    public void renderModel(TileEntityModel model, float partialTicks)
    {
        isRendering = true;

        ClientProxy.modelRenderer.render(model, 0, 0, 0, partialTicks, 0, 0);

        Minecraft mc = Minecraft.getMinecraft();
        TextureManager manager = mc.getTextureManager();

        manager.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);
        mc.getTextureMapBlocks().setBlurMipmapDirect(false, true);
        mc.getTextureMapBlocks().setBlurMipmap(false, false);

        isRendering = false;
    }

    /**
     * {@link TileEntityModel} wrapper class
     * 
     * This class allows to hold timer for unloading purpose (so objects 
     * won't get stuck in the map forever, which might cause memory 
     * leak) 
     */
    public static class TEModel
    {
        public int timer = 20;
        public TileEntityModel model;

        public TEModel(TileEntityModel model)
        {
            this.model = model;
        }
    }
}

==================================================

--- Файл №221 ---
Путь: main\java\mchorse\blockbuster\client\render\tileentity\TileEntityModelRenderer.java
--------------------
package mchorse.blockbuster.client.render.tileentity;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.gui.dashboard.panels.model_block.GuiModelBlockPanel;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.utils.MatrixUtils.RotationOrder;
import mchorse.blockbuster.common.tileentity.TileEntityModelSettings;
import mchorse.mclib.client.Draw;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.RenderingUtils;
import mchorse.metamorph.api.EntityUtils;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.bodypart.GuiBodyPartEditor;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.EntityRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;

import javax.vecmath.Vector3d;
import java.util.List;

/**
 * Model tile entity renderer
 * 
 * This class is responsible for rendering a model based on given tile 
 * entity data.
 */
public class TileEntityModelRenderer extends TileEntitySpecialRenderer<TileEntityModel>
{
    /**
     * Entity shadow rendering  
     */
    public RenderShadow renderer;

    @Override
    public void render(TileEntityModel te, double x, double y, double z, float partialTicks, int destroyStage, float alpha)
    {
        Minecraft mc = Minecraft.getMinecraft();
        TileEntityModelSettings teSettings = te.getSettings();

        if (!te.morph.isEmpty() && (!Blockbuster.modelBlockDisableRendering.get() || teSettings.isRenderAlways()) && teSettings.isEnabled())
        {
            AbstractMorph morph = te.morph.get();

            if (this.renderer == null)
            {
                this.renderer = new RenderShadow(mc.getRenderManager());
            }

            if (te.entity == null)
            {
                te.createEntity(mc.world);
            }

            if (te.entity == null)
            {
                return;
            }

            EntityLivingBase entity = te.entity;

            if (EntityUtils.getMorph(entity) != null)
            {
                morph = EntityUtils.getMorph(entity);
            }

            /* Apply entity rotations */
            BlockPos pos = te.getPos();

            entity.setPositionAndRotation(pos.getX() + 0.5F + teSettings.getX(), pos.getY() + teSettings.getY(), pos.getZ() + 0.5F + teSettings.getZ(), 0, 0);
            entity.setLocationAndAngles(pos.getX() + 0.5F + teSettings.getX(), pos.getY() + teSettings.getY(), pos.getZ() + 0.5F + teSettings.getZ(), 0, 0);
            entity.rotationYawHead = entity.prevRotationYawHead = teSettings.getRotateYawHead();
            entity.rotationYaw = entity.prevRotationYaw = 0;
            entity.rotationPitch = entity.prevRotationPitch = teSettings.getRotatePitch();
            entity.renderYawOffset = entity.prevRenderYawOffset = teSettings.getRotateBody();
            entity.setVelocity(0, 0, 0);

            float xx = (float) x + 0.5F + teSettings.getX();
            float yy = (float) y + teSettings.getY();
            float zz = (float) z + 0.5F + teSettings.getZ();

            /* Apply transformations */
            GlStateManager.pushMatrix();
            GlStateManager.translate(xx, yy, zz);

            boolean wasSet = MatrixUtils.captureMatrix();

            this.transform(te);

            MorphUtils.render(morph, entity, 0, 0, 0, 0, partialTicks);

            this.drawAxis(te);

            GlStateManager.popMatrix();

            if (teSettings.isShadow())
            {
                this.renderer.setShadowSize(morph.getWidth(entity) * 0.8F);
                this.renderer.doRenderShadowAndFire(te.entity, xx, yy, zz, 0, partialTicks);
            }

            if (wasSet) MatrixUtils.releaseMatrix();
        }

        /* Debug render (so people could find the block, lmao) */
        if (mc.gameSettings.showDebugInfo && (!mc.gameSettings.hideGUI || Blockbuster.modelBlockRenderDebuginf1.get()))
        {
            int shader = GL11.glGetInteger(GL20.GL_CURRENT_PROGRAM);

            if (shader != 0)
            {
                OpenGlHelper.glUseProgram(0);
            }

            GlStateManager.disableTexture2D();
            GlStateManager.disableDepth();
            GlStateManager.disableLighting();
            GlStateManager.enableBlend();

            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder buffer = tessellator.getBuffer();

            buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

            float r = teSettings.isEnabled() ? 0 : 1;
            float g = teSettings.isEnabled() ? 0.5F : 0.85F;
            float b = teSettings.isEnabled() ? 1 : 0;

            if (!te.morph.isEmpty() && te.morph.get().errorRendering)
            {
                r = 1;
                g = b = 0;
            }

            Draw.cube(buffer, x + 0.25F, y + 0.25F, z + 0.25F, x + 0.75F, y + 0.75F, z + 0.75F, r, g, b, 0.35F);
            Draw.cube(buffer, x + 0.45F + teSettings.getX(), y + teSettings.getY(), z + 0.45F + teSettings.getZ(), x + 0.55F + teSettings.getX(), y + 0.1F + teSettings.getY(), z + 0.55F + teSettings.getZ(), 1, 1, 1, 0.85F);

            double distance = MathHelper.sqrt(Vec3d.ZERO.squareDistanceTo(teSettings.getX(), teSettings.getY(), teSettings.getZ()));

            if (distance > 0.1)
            {
                Draw.cube(buffer, x + 0.45F, y, z + 0.45F, x + 0.55F, y + 0.1F, z + 0.55F, 1, 1, 1, 0.85F);

                tessellator.draw();

                double horizontalDistance = MathHelper.sqrt(teSettings.getX() * teSettings.getX() + teSettings.getZ() * teSettings.getZ());
                double yaw = 180 - MathHelper.atan2(teSettings.getZ(), teSettings.getX()) * 180 / Math.PI + 90;
                double pitch = MathHelper.atan2(teSettings.getY(), horizontalDistance) * 180 / Math.PI;

                GL11.glPushMatrix();
                GL11.glTranslated(x + 0.5, y + 0.05F, z + 0.5);
                GL11.glRotated(yaw, 0.0F, 1.0F, 0.0F);
                GL11.glRotated(pitch, 1.0F, 0.0F, 0.0F);

                Draw.cube(-0.025F, -0.025F, 0, 0.025F, 0.025F, -distance, 0, 0, 0, 0.5F);

                GL11.glPopMatrix();
            }
            else
            {
                tessellator.draw();
            }

            if (teSettings.getLightValue() != 0)
            {
                FontRenderer font = Minecraft.getMinecraft().fontRenderer;
                String text = I18n.format("blockbuster.light", teSettings.getLightValue());
                RenderManager manager = mc.getRenderManager();

                boolean isInventory = false;

                float yaw = (isInventory) ? 180F : manager.playerViewY;
                float pitch = (isInventory) ? 0F : manager.playerViewX;


                EntityRenderer.drawNameplate(this.getFontRenderer(), text, (float) (x + 0.5F), (float) (y + 0.5F) + font.FONT_HEIGHT / 48.0F + 0.05F, (float) (z + 0.5F), 0, yaw, pitch, mc.gameSettings.thirdPersonView == 2, false);
            }

            GlStateManager.disableBlend();
            GlStateManager.enableLighting();
            GlStateManager.enableDepth();
            GlStateManager.enableTexture2D();

            if (shader != 0)
            {
                OpenGlHelper.glUseProgram(shader);
            }
        }
    }

    private void drawAxis(TileEntityModel te)
    {
        List<GuiModelBlockPanel> childList = GuiBase.getCurrentChildren(GuiModelBlockPanel.class);

        if (childList == null) return;

        GuiModelBlockPanel modelBlockPanel = childList.get(0);

        if (modelBlockPanel != null && modelBlockPanel.isOpened() && modelBlockPanel.isSelected(te))
        {
            GlStateManager.pushMatrix();
            GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
            GlStateManager.disableTexture2D();
            GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
            GlStateManager.disableTexture2D();

            GlStateManager.disableDepth();
            GlStateManager.disableLighting();

            Draw.point(0, 0, 0);

            if (GuiTransformations.GuiStaticTransformOrientation.getOrientation() == GuiTransformations.TransformOrientation.GLOBAL)
            {
                TileEntityModelSettings teSettings = te.getSettings();
                Vector3d rotation = new Vector3d(Math.toRadians(teSettings.getRx()), Math.toRadians(teSettings.getRy()), Math.toRadians(teSettings.getRz()));
                Vector3d scale = new Vector3d(teSettings.getSx(), teSettings.getSy(), teSettings.getSz());

                RenderingUtils.glRevertRotationScale(rotation, scale, teSettings.getOrder());
            }

            Draw.axis(0.25F);

            GlStateManager.enableLighting();
            GlStateManager.enableDepth();

            GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
            GlStateManager.enableTexture2D();
            GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
            GlStateManager.enableTexture2D();
            GlStateManager.popMatrix();
        }
    }

    @Override
    public boolean isGlobalRenderer(TileEntityModel te)
    {
        return te.getSettings().isGlobal();
    }

    public void transform(TileEntityModel te)
    {
        TileEntityModelSettings teSettings = te.getSettings();

        if (teSettings.getOrder() == RotationOrder.ZYX)
        {
            GlStateManager.rotate(teSettings.getRx(), 1, 0, 0);
            GlStateManager.rotate(teSettings.getRy(), 0, 1, 0);
            GlStateManager.rotate(teSettings.getRz(), 0, 0, 1);
        }
        else
        {
            GlStateManager.rotate(teSettings.getRz(), 0, 0, 1);
            GlStateManager.rotate(teSettings.getRy(), 0, 1, 0);
            GlStateManager.rotate(teSettings.getRx(), 1, 0, 0);
        }

        /* the uniform rendering is needed for backwards compatibility
        * with model blocks that have only sx set */
        if (teSettings.isUniform())
        {
            GlStateManager.scale(teSettings.getSx(), teSettings.getSx(), teSettings.getSx());
        }
        else
        {
            GlStateManager.scale(teSettings.getSx(), teSettings.getSy(), teSettings.getSz());
        }
    }

    /**
     * Used for rendering entity shadow 
     */
    public static class RenderShadow extends Render<Entity>
    {
        protected RenderShadow(RenderManager renderManager)
        {
            super(renderManager);
        }

        @Override
        protected ResourceLocation getEntityTexture(Entity entity)
        {
            return null;
        }

        public void setShadowSize(float size)
        {
            this.shadowSize = size;
            this.shadowOpaque = 0.8F;
        }
    }
}

==================================================

--- Файл №222 ---
Путь: main\java\mchorse\blockbuster\client\textures\GifFrameTexture.java
--------------------
package mchorse.blockbuster.client.textures;

import java.awt.image.BufferedImage;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Arrays;

import mchorse.blockbuster.utils.mclib.GifFolder;
import net.minecraft.client.renderer.texture.AbstractTexture;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraft.client.resources.IResourceManager;

public class GifFrameTexture extends AbstractTexture
{
    public GifFolder file;
    public int index;

    public GifFrameTexture(GifFolder file, int index)
    {
        this.file = file;
        this.index = index;
    }

    @Override
    public void loadTexture(IResourceManager resourceManager) throws IOException
    {
        this.deleteGlTexture();

        if (!this.file.exists())
        {
            throw new FileNotFoundException(this.file.getFilePath());
        }

        if (!tryLoadMultiTex())
        {
            TextureUtil.uploadTextureImage(this.getGlTextureId(), this.file.gif.getFrame(this.index));
        }
    }

    private boolean tryLoadMultiTex()
    {
        try
        {
            Class<?> config = Class.forName("Config");
            Method isShaders = config.getMethod("isShaders");

            if (!Boolean.TRUE.equals(isShaders.invoke(null)))
            {
                return false;
            }
        }
        catch (ClassNotFoundException | NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e)
        {
            return false;
        }

        BufferedImage frame = this.file.gif.getFrame(this.index);
        int width = frame.getWidth();
        int height = frame.getHeight();
        int[] aint = new int[width * height * 3];

        frame.getRGB(0, 0, width, height, aint, 0, width);

        String path = this.file.getFilePath();

        path = path.substring(0, path.length() - 4);

        GifFolder normal = new GifFolder(path + "_n.gif");
        GifFolder specular = new GifFolder(path + "_s.gif");

        if (normal.exists())
        {
            frame = normal.gif.getFrame(this.index);
            frame.getRGB(0, 0, width, height, aint, width * height, width);
        }
        else
        {
            Arrays.fill(aint, width * height, width * height * 2, 0xFF7F7FFF);
        }

        if (specular.exists())
        {
            frame = specular.gif.getFrame(this.index);
            frame.getRGB(0, 0, width, height, aint, width * height * 2, width);
        }
        else
        {
            Arrays.fill(aint, width * height * 2, width * height * 3, 0);
        }

        try
        {
            Class<?> shadersTex = Class.forName("net.optifine.shaders.ShadersTex");

            Method getMultiTexID = null;
            Method setupTexture = null;

            for (Method method : shadersTex.getMethods())
            {
                if ("getMultiTexID".equals(method.getName()))
                {
                    getMultiTexID = method;
                }
                else if ("setupTexture".equals(method.getName()))
                {
                    setupTexture = method;
                }
            }

            if (getMultiTexID == null || setupTexture == null)
            {
                return false;
            }

            Object multiTex = getMultiTexID.invoke(null, this);

            setupTexture.invoke(null, multiTex, aint, width, height, false, false);
        }
        catch (ClassNotFoundException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e)
        {
            return false;
        }

        return true;
    }
}


==================================================

--- Файл №223 ---
Путь: main\java\mchorse\blockbuster\client\textures\GifProcessThread.java
--------------------
package mchorse.blockbuster.client.textures;

import java.util.HashMap;
import java.util.Map;

import at.dhyan.open_imaging.GifDecoder.GifImage;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.utils.mclib.GifFolder;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.resources.MultiResourceLocation;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.AbstractTexture;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * GIF process thread
 * 
 * This bad boy is responsible for creating an animated GIF texture
 */
@SideOnly(Side.CLIENT)
public class GifProcessThread implements Runnable
{
    public static final Map<ResourceLocation, GifProcessThread> THREADS = new HashMap<ResourceLocation, GifProcessThread>();

    public ResourceLocation texture;
    public GifFolder gifFile;

    public GifProcessThread(ResourceLocation texture, GifFolder gif)
    {
        this.texture = texture;
        this.gifFile = gif;
    }

    @Override
    public void run()
    {
        if (this.texture instanceof MultiResourceLocation)
        {
            return;
        }

        try
        {
            Minecraft mc = Minecraft.getMinecraft();

            GifImage image = this.gifFile.gif;
            int[] delays = new int[image.getFrameCount()];
            ResourceLocation[] frames = new ResourceLocation[delays.length];
            Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(mc.renderEngine);
            
            for (int i = 0; i < delays.length; i++)
            {
                delays[i] = image.getDelay(i);
                frames[i] = RLUtils.create(this.texture.getResourceDomain(), this.texture.getResourcePath() + ">/frame" + i + ".png");

                ITextureObject old = map.remove(frames[i]);

                if (old != null)
                {
                    if (old instanceof AbstractTexture)
                    {
                        ((AbstractTexture) old).deleteGlTexture();
                    }
                }

                mc.renderEngine.loadTexture(frames[i], new GifFrameTexture(this.gifFile, i));
            }

            GifTexture texture = new GifTexture(this.texture, delays, frames);
            ITextureObject old = map.remove(this.texture);

            if (old != null)
            {
                if (old instanceof AbstractTexture)
                {
                    ((AbstractTexture) old).deleteGlTexture();
                }
            }

            map.put(this.texture, texture);

            texture.calculateDuration();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public static void create(ResourceLocation location, GifFolder gif)
    {
        GifProcessThread thread = new GifProcessThread(location, gif);

        THREADS.put(location, thread);
        thread.run();
        THREADS.remove(location);
    }
}

==================================================

--- Файл №224 ---
Путь: main\java\mchorse\blockbuster\client\textures\GifTexture.java
--------------------
package mchorse.blockbuster.client.textures;

import java.io.IOException;
import java.lang.reflect.Field;
import java.util.Arrays;

import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.AbstractTexture;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GifTexture extends AbstractTexture
{
    public static int globalTick = 0;
    public static int entityTick = -1;

    public static boolean tried = false;
    public static Field fieldMultiTex = null;

    public ResourceLocation base;
    public ResourceLocation[] frames;
    public int[] delays;

    public int duration;

    public static void bindTexture(ResourceLocation location, int ticks, float partialTicks)
    {
        TextureManager textures = Minecraft.getMinecraft().renderEngine;

        if (location.getResourcePath().endsWith("gif"))
        {
            ITextureObject object = textures.getTexture(location);

            if (object instanceof GifTexture)
            {
                GifTexture texture = (GifTexture) object;

                location = texture.getFrame(ticks, partialTicks);
            }
        }

        textures.bindTexture(location);
    }

    public static void updateTick()
    {
        globalTick += 1;
    }

    public GifTexture(ResourceLocation texture, int[] delays, ResourceLocation[] frames)
    {
        this.base = texture;
        this.delays = Arrays.copyOf(delays, delays.length);
        this.frames = frames;
    }

    public void calculateDuration()
    {
        this.duration = 0;

        for (int delay : this.delays)
        {
            this.duration += delay;
        }
    }

    @Override
    public void loadTexture(IResourceManager resourceManager) throws IOException
    {}

    @Override
    public int getGlTextureId()
    {
        Minecraft mc = Minecraft.getMinecraft();
        TextureManager textures = mc.renderEngine;
        ResourceLocation rl = this.getFrame(entityTick > -1 ? entityTick : globalTick, mc.getRenderPartialTicks());

        textures.bindTexture(rl);

        ITextureObject texture = textures.getTexture(rl);

        this.updateMultiTex(texture);

        return texture.getGlTextureId();
    }

    @Override
    public void deleteGlTexture()
    {}

    public ResourceLocation getFrame(int ticks, float partialTicks)
    {
        int tick = (int) ((ticks + partialTicks) * 5 % this.duration);

        int duration = 0;
        int index = 0;

        for (int delay : this.delays)
        {
            duration += delay;

            if (tick < duration)
            {
                break;
            }

            index++;
        }

        index = MathUtils.clamp(index, 0, this.frames.length - 1);

        return this.frames[index];
    }

    private void updateMultiTex(ITextureObject texture)
    {
        if (!tried)
        {
            try
            {
                fieldMultiTex = AbstractTexture.class.getField("multiTex");
            }
            catch (NoSuchFieldException | SecurityException e)
            {
                fieldMultiTex = null;
            }

            tried = true;
        }

        if (texture instanceof AbstractTexture && fieldMultiTex != null)
        {
            try
            {
                Object obj = fieldMultiTex.get(texture);

                fieldMultiTex.set(this, obj);
            }
            catch (IllegalArgumentException | IllegalAccessException e)
            {}
        }
    }
}


==================================================

--- Файл №225 ---
Путь: main\java\mchorse\blockbuster\client\textures\MipmapTexture.java
--------------------
package mchorse.blockbuster.client.textures;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.nio.ByteBuffer;

import org.apache.commons.io.IOUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL12;
import org.lwjgl.opengl.GL14;

import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.texture.SimpleTexture;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraft.client.resources.IResource;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Mipmap texture class
 * 
 * This class is responsible for loading or rather replacing a regular 
 * texture with a mipmapped version of a texture. 
 */
@SideOnly(Side.CLIENT)
public class MipmapTexture extends SimpleTexture
{
    /**
     * Create a byte buffer from buffered image 
     */
    public static ByteBuffer bytesFromBuffer(BufferedImage image)
    {
        int w = image.getWidth();
        int h = image.getHeight();

        ByteBuffer buffer = GLAllocation.createDirectByteBuffer(w * h * 4);
        int[] pixels = new int[w * h];

        image.getRGB(0, 0, w, h, pixels, 0, w);

        for (int y = 0; y < h; y++)
        {
            for (int x = 0; x < w; x++)
            {
                int pixel = pixels[y * w + x];

                buffer.put((byte) ((pixel >> 16) & 0xFF));
                buffer.put((byte) ((pixel >> 8) & 0xFF));
                buffer.put((byte) (pixel & 0xFF));
                buffer.put((byte) ((pixel >> 24) & 0xFF));
            }
        }

        buffer.flip();

        return buffer;
    }

    public MipmapTexture(ResourceLocation textureResourceLocation)
    {
        super(textureResourceLocation);
    }

    @Override
    public void loadTexture(IResourceManager resourceManager) throws IOException
    {
        super.loadTexture(resourceManager);

        IResource resource = null;

        try
        {
            resource = resourceManager.getResource(this.textureLocation);
            BufferedImage image = TextureUtil.readBufferedImage(resource.getInputStream());

            int id = this.getGlTextureId();
            int w = image.getWidth();
            int h = image.getHeight();

            GlStateManager.bindTexture(id);
            GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL12.GL_TEXTURE_MIN_LOD, 0);
            GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL12.GL_TEXTURE_MAX_LOD, 3);
            GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL12.GL_TEXTURE_MAX_LEVEL, 3);
            GlStateManager.glTexParameterf(GL11.GL_TEXTURE_2D, GL14.GL_TEXTURE_LOD_BIAS, 0.0F);
            GlStateManager.glTexParameterf(GL11.GL_TEXTURE_2D, GL14.GL_GENERATE_MIPMAP, GL11.GL_TRUE);
            GlStateManager.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST_MIPMAP_LINEAR);
            GlStateManager.glTexParameterf(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST_MIPMAP_LINEAR);

            GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, w, h, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, bytesFromBuffer(image));
        }
        finally
        {
            IOUtils.closeQuietly(resource);
        }
    }
}

==================================================

--- Файл №226 ---
Путь: main\java\mchorse\blockbuster\client\textures\URLDownloadThread.java
--------------------
package mchorse.blockbuster.client.textures;

import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.Map;

import javax.imageio.ImageIO;

import mchorse.mclib.utils.ReflectionUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.SimpleTexture;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraft.util.ResourceLocation;

/**
 * URL download thread
 * 
 * This bad boy downloads a picture from internet and puts it into the 
 * texture manager's.
 */
public class URLDownloadThread implements Runnable
{
    /**
     * Look, MA! I'm Google Chrome on OS X!!! xD 
     */
    public static final String USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36";

    private ResourceLocation url;

    public URLDownloadThread(ResourceLocation url)
    {
        this.url = url;
    }

    public static InputStream downloadImage(final ResourceLocation url) throws IOException
    {
        URLConnection con = new URL(url.toString()).openConnection();
        con.setRequestProperty("User-Agent", USER_AGENT);

        InputStream stream = con.getInputStream();
        String type = con.getHeaderField("Content-Type");

        if (type != null && !type.startsWith("image/"))
        {
            return null;
        }

        return stream;
    }

    public static void addToManager(ResourceLocation url, InputStream is) throws IOException
    {
        BufferedImage image = ImageIO.read(is);

        SimpleTexture texture = new SimpleTexture(url);
        TextureUtil.uploadTextureImageAllocate(texture.getGlTextureId(), image, false, false);

        TextureManager manager = Minecraft.getMinecraft().renderEngine;
        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(manager);

        map.put(url, texture);
    }

    @Override
    public void run()
    {
        Minecraft.getMinecraft().addScheduledTask(() ->
        {
            try
            {
                InputStream stream = downloadImage(this.url);

                if (stream != null)
                {
                    addToManager(this.url, stream);
                }
            }
            catch (IOException e)
            {}
        });
    }
}

==================================================

--- Файл №227 ---
Путь: main\java\mchorse\blockbuster\commands\BBCommandBase.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import mchorse.mclib.commands.McCommandBase;
import mchorse.mclib.commands.utils.L10n;

public abstract class BBCommandBase extends McCommandBase
{
    @Override
    public L10n getL10n()
    {
        return Blockbuster.l10n;
    }
}


==================================================

--- Файл №228 ---
Путь: main\java\mchorse\blockbuster\commands\CommandAction.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.action.SubCommandActionAppend;
import mchorse.blockbuster.commands.action.SubCommandActionCancel;
import mchorse.blockbuster.commands.action.SubCommandActionClear;
import mchorse.blockbuster.commands.action.SubCommandActionPlay;
import mchorse.blockbuster.commands.action.SubCommandActionRecord;
import mchorse.blockbuster.commands.action.SubCommandActionRequest;
import mchorse.blockbuster.commands.action.SubCommandActionStop;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.commands.utils.L10n;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.world.World;

/**
 * Command /action
 *
 * This command is responsible for recording player actions or playbacking
 * already recorded player actions.
 *
 * This command is merged version of CommandPlay and CommandRecord (which both
 * were removed in 1.1). These commands were merged together, because they had
 * similar signature and work with player recordings.
 *
 * In 1.4, this command was refactored into {@link SubCommandBase} command.
 */
public class CommandAction extends SubCommandBase
{
    public CommandAction()
    {
        /* Register sub-commands in alphabetical order */
        this.add(new SubCommandActionAppend());
        this.add(new SubCommandActionCancel());
        this.add(new SubCommandActionClear());
        this.add(new SubCommandActionPlay());
        this.add(new SubCommandActionRecord());
        this.add(new SubCommandActionRequest());
        this.add(new SubCommandActionStop());
    }

    @Override
    public L10n getL10n()
    {
        return Blockbuster.l10n;
    }

    @Override
    public String getName()
    {
        return "action";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.help";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }

    /**
     * Create an actor from command line arguments (i.e. String array).
     * Description of every element in array:
     *
     * 1. Ignored (since it's filename)
     * 2. Invincible flag (boolean)
     * 3+. NBT data of the morph
     *
     * And of course, all of those arguments are optional (i.e. have default
     * values).
     */
    public static EntityActor actorFromArgs(String[] args, World world) throws CommandException
    {
        EntityActor actor;
        AbstractMorph morph = null;

        boolean invincible = args.length >= 2 && CommandBase.parseBoolean(args[1]);
        String model = args.length >= 3 ? String.join(" ",SubCommandBase.dropFirstArguments(args, 2)) : null;

        if (model != null)
        {
            try
            {
                morph = MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson(model));
            }
            catch (Exception e)
            {}
        }

        actor = new EntityActor(world);
        actor.modify(morph, false, true);
        actor.setEntityInvulnerable(invincible);

        return actor;
    }
}

==================================================

--- Файл №229 ---
Путь: main\java\mchorse\blockbuster\commands\CommandDamage.java
--------------------
package mchorse.blockbuster.commands;

import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.DamageSource;

public class CommandDamage extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "damage";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.damage.help";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}damage {7}<entity> <amount>{r}";
    }

    @Override
    public boolean isUsernameIndex(String[] args, int index)
    {
        return index == 0;
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        float damage = (float) CommandBase.parseDouble(args[1]);
        Entity entity = getEntity(server, sender, args[0]);

        if (damage < 0 && entity instanceof EntityLivingBase)
        {
            EntityLivingBase target = (EntityLivingBase) entity;

            target.setHealth(target.getHealth() + Math.abs(damage));
        }
        else if (damage > 0)
        {
            entity.attackEntityFrom(DamageSource.OUT_OF_WORLD, damage);
        }
    }
}


==================================================

--- Файл №230 ---
Путь: main\java\mchorse\blockbuster\commands\CommandItemNBT.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import javax.annotation.Nullable;
import java.util.List;

public class CommandItemNBT extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "item_nbt";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.item_nbt.help";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}item_nbt {7}<give_command>{r}";
    }

    @Override
    public boolean checkPermission(MinecraftServer server, ICommandSender sender)
    {
        return true;
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        ItemStack stack = Minecraft.getMinecraft().player.getHeldItemMainhand();

        if (stack.isEmpty())
        {
            Blockbuster.l10n.error(sender, "commands.item_nbt_empty");

            return;
        }

        boolean command = CommandBase.parseBoolean(args[0]);

        String output = "{}";

        if (command)
        {
            NBTTagCompound tag = new NBTTagCompound();

            stack.writeToNBT(tag);
            output = "/give @p " + tag.getString("id") + " " + stack.getCount() + " " + stack.getItemDamage();

            if (stack.hasTagCompound())
            {
                output += " " + stack.getTagCompound().toString();
            }
        }
        else if (stack.hasTagCompound())
        {
            output = stack.getTagCompound().toString();
        }

        GuiScreen.setClipboardString(output);
        Blockbuster.l10n.success(sender, "commands.item_nbt");
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos targetPos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, BOOLEANS);
        }

        return super.getTabCompletions(server, sender, args, targetPos);
    }
}

==================================================

--- Файл №231 ---
Путь: main\java\mchorse\blockbuster\commands\CommandModel.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.model.SubCommandModelClear;
import mchorse.blockbuster.commands.model.SubCommandModelClearStructures;
import mchorse.blockbuster.commands.model.SubCommandModelCombine;
import mchorse.blockbuster.commands.model.SubCommandModelConvertSkin;
import mchorse.blockbuster.commands.model.SubCommandModelExport;
import mchorse.blockbuster.commands.model.SubCommandModelExportObj;
import mchorse.blockbuster.commands.model.SubCommandModelReload;
import mchorse.blockbuster.commands.model.SubCommandModelReport;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.commands.utils.L10n;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /model
 *
 * Another client-side command which is responsible for
 */
public class CommandModel extends SubCommandBase
{
    /**
     * Model command's constructor
     *
     * This method is responsible for attaching sub commands for this model
     */
    public CommandModel()
    {
        this.add(new SubCommandModelClear());
        this.add(new SubCommandModelClearStructures());
        this.add(new SubCommandModelCombine());
        this.add(new SubCommandModelConvertSkin());
        this.add(new SubCommandModelExport());
        this.add(new SubCommandModelExportObj());
        this.add(new SubCommandModelReload());
        this.add(new SubCommandModelReport());
    }

    @Override
    public L10n getL10n()
    {
        return Blockbuster.l10n;
    }

    @Override
    public String getName()
    {
        return "model";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.help";
    }

    @Override
    public String getSyntax()
    {
        return "";
    }

    @Override
    public boolean checkPermission(MinecraftServer server, ICommandSender sender)
    {
        return true;
    }
}

==================================================

--- Файл №232 ---
Путь: main\java\mchorse\blockbuster\commands\CommandModelBlock.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.modelblock.SubCommandModelBlockMorph;
import mchorse.blockbuster.commands.modelblock.SubCommandModelBlockProperty;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.commands.utils.L10n;
import net.minecraft.command.ICommandSender;

public class CommandModelBlock extends SubCommandBase
{
    public CommandModelBlock()
    {
        this.add(new SubCommandModelBlockMorph());
        this.add(new SubCommandModelBlockProperty());
    }

    @Override
    public L10n getL10n()
    {
        return Blockbuster.l10n;
    }

    @Override
    public String getName()
    {
        return "modelblock";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.modelblock.help";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }
}

==================================================

--- Файл №233 ---
Путь: main\java\mchorse\blockbuster\commands\CommandMount.java
--------------------
package mchorse.blockbuster.commands;

import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.Entity;
import net.minecraft.server.MinecraftServer;

public class CommandMount extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "mount";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.mount.help";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}mount {8}<target>{r} {7}[destination]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Entity target = getEntity(server, sender, args[0]);

        if (args.length > 1)
        {
            target.startRiding(getEntity(server, sender, args[1]));
        }
        else
        {
            target.dismountRidingEntity();
        }
    }
}


==================================================

--- Файл №234 ---
Путь: main\java\mchorse\blockbuster\commands\CommandOnHead.java
--------------------
package mchorse.blockbuster.commands;

import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.server.MinecraftServer;

public class CommandOnHead extends CommandBase
{
    @Override
    public String getName()
    {
        return "on_head";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.on_head.help";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayer player = getCommandSenderAsPlayer(sender);
        ItemStack stack = player.getHeldItemMainhand();

        if (!stack.isEmpty())
        {
            player.setItemStackToSlot(EntityEquipmentSlot.HEAD, stack.copy());
        }
    }
}

==================================================

--- Файл №235 ---
Путь: main\java\mchorse\blockbuster\commands\CommandRecord.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.commands.record.SubCommandRecordAdd;
import mchorse.blockbuster.commands.record.SubCommandRecordApply;
import mchorse.blockbuster.commands.record.SubCommandRecordCalculateBodyYaw;
import mchorse.blockbuster.commands.record.SubCommandRecordCamera;
import mchorse.blockbuster.commands.record.SubCommandRecordClean;
import mchorse.blockbuster.commands.record.SubCommandRecordCreate;
import mchorse.blockbuster.commands.record.SubCommandRecordCut;
import mchorse.blockbuster.commands.record.SubCommandRecordDelete;
import mchorse.blockbuster.commands.record.SubCommandRecordDupe;
import mchorse.blockbuster.commands.record.SubCommandRecordErase;
import mchorse.blockbuster.commands.record.SubCommandRecordFade;
import mchorse.blockbuster.commands.record.SubCommandRecordFill;
import mchorse.blockbuster.commands.record.SubCommandRecordFlip;
import mchorse.blockbuster.commands.record.SubCommandRecordGet;
import mchorse.blockbuster.commands.record.SubCommandRecordInfo;
import mchorse.blockbuster.commands.record.SubCommandRecordMerge;
import mchorse.blockbuster.commands.record.SubCommandRecordOrigin;
import mchorse.blockbuster.commands.record.SubCommandRecordProcess;
import mchorse.blockbuster.commands.record.SubCommandRecordProlong;
import mchorse.blockbuster.commands.record.SubCommandRecordRemove;
import mchorse.blockbuster.commands.record.SubCommandRecordRemoveAll;
import mchorse.blockbuster.commands.record.SubCommandRecordRemoveBodyYaw;
import mchorse.blockbuster.commands.record.SubCommandRecordRename;
import mchorse.blockbuster.commands.record.SubCommandRecordRestore;
import mchorse.blockbuster.commands.record.SubCommandRecordReverse;
import mchorse.blockbuster.commands.record.SubCommandRecordSearch;
import mchorse.blockbuster.commands.record.SubCommandRecordTP;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.commands.utils.L10n;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;

import java.io.FileNotFoundException;

/**
 * Command /record
 *
 * This command provides an interface which allows the manipulation of player
 * recordings on the server.
 */
public class CommandRecord extends SubCommandBase
{
    public CommandRecord()
    {
        /* Register sub-commands */
        this.add(new SubCommandRecordAdd());
        this.add(new SubCommandRecordApply());
        this.add(new SubCommandRecordCalculateBodyYaw());

        if (CameraHandler.isApertureLoaded())
        {
            this.add(new SubCommandRecordCamera());
        }

        this.add(new SubCommandRecordClean());
        this.add(new SubCommandRecordCreate());
        this.add(new SubCommandRecordCut());
        this.add(new SubCommandRecordDupe());
        this.add(new SubCommandRecordErase());
        this.add(new SubCommandRecordFade());
        this.add(new SubCommandRecordFill());
        this.add(new SubCommandRecordFlip());
        this.add(new SubCommandRecordGet());
        this.add(new SubCommandRecordInfo());
        this.add(new SubCommandRecordMerge());
        this.add(new SubCommandRecordOrigin());
        this.add(new SubCommandRecordProcess());
        this.add(new SubCommandRecordProlong());
        this.add(new SubCommandRecordDelete());
        this.add(new SubCommandRecordRemove());
        this.add(new SubCommandRecordRemoveAll());
        this.add(new SubCommandRecordDelete());
        this.add(new SubCommandRecordRemoveBodyYaw());
        this.add(new SubCommandRecordRename());
        this.add(new SubCommandRecordRestore());
        this.add(new SubCommandRecordReverse());
        this.add(new SubCommandRecordSearch());
        this.add(new SubCommandRecordTP());
    }

    @Override
    public L10n getL10n()
    {
        return Blockbuster.l10n;
    }

    @Override
    public String getName()
    {
        return "record";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.help";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }

    /**
     * Get record by given filename
     *
     * This is a command-friendly method for retrieving a player recording. In
     * case of error, {@link CommandException} will be thrown.
     */
    public static Record getRecord(String filename) throws CommandException
    {
        try
        {
            return CommonProxy.manager.get(filename);
        }
        catch (FileNotFoundException e)
        {
            throw new CommandException("record.not_exist", filename);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            throw new CommandException("recording.read", filename);
        }
    }
}

==================================================

--- Файл №236 ---
Путь: main\java\mchorse\blockbuster\commands\CommandScene.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.recording.scene.Scene;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.List;

/**
 * Command /scene
 *
 * This command is responsible for playing or stopping scenes.
 */
public class CommandScene extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "scene";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.scene";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}scene {8}<play|toggle|stop|loop>{r} {7}<name> [flag]{r}";
    }

    @Override
    public int getRequiredPermissionLevel()
    {
        return 2;
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (args.length < 2)
        {
            throw new WrongUsageException(this.getUsage(null));
        }

        String action = args[0];
        String name = args[1];
        Scene scene = CommonProxy.scenes.get(name, sender.getEntityWorld());

        if (scene == null)
        {
            Blockbuster.l10n.error(sender, "scene.no_scene", name);
            return;
        }

        String play = "scene.play";
        String stop = "scene.stop";

        if (action.equals("play"))
        {
            if (scene.playing)
            {
                Blockbuster.l10n.error(sender, "scene.playing", name);
                return;
            }

            scene.startPlayback(0);
            Blockbuster.l10n.success(sender, play, name);
        }
        else if (action.equals("stop"))
        {
            if (!scene.playing)
            {
                Blockbuster.l10n.error(sender, "scene.stopped", name);
                return;
            }

            scene.stopPlayback(true);
            Blockbuster.l10n.success(sender, stop, name);
        }
        else if (action.equals("loop") && args.length >= 2)
        {
            scene.loops = CommandBase.parseBoolean(args[2]);

            try
            {
                CommonProxy.scenes.save(scene.getId(), scene);

                Blockbuster.l10n.info(sender, "scene." + (scene.loops ? "looped" : "unlooped"));
            }
            catch (Exception e)
            {}
        }
        else if (action.equals("toggle"))
        {
            boolean isPlaying = scene.togglePlayback();
            Blockbuster.l10n.success(sender, isPlaying ? play : stop, name);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, "play", "stop", "toggle", "loop");
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №237 ---
Путь: main\java\mchorse\blockbuster\commands\CommandSpectate.java
--------------------
package mchorse.blockbuster.commands;

import mchorse.blockbuster.Blockbuster;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.EntitySelector;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.GameType;

import java.util.List;

/**
 * Spectate entity command - /spectate &lt;player&gt; &lt;entity&gt;
 * 
 * This command allows to make given player a spectator of given entity. 
 * I don't know why it's useful, but I think this can be useful.
 */
public class CommandSpectate extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "spectate";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.spectate.help";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}spectate {8}<player>{r} {7}<entity>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayerMP player = getPlayer(server, sender, args[0]);

        if (player == null)
        {
            Blockbuster.l10n.error(sender, "commands.no_player", args[0]);

            return;
        }

        List<Entity> entities = EntitySelector.matchEntities(sender, args[1], Entity.class);

        if (entities.isEmpty())
        {
            Blockbuster.l10n.error(sender, "commands.no_entity", args[1]);

            return;
        }

        if (!player.isSpectator())
        {
            player.setGameType(GameType.SPECTATOR);
        }

        for (Entity entity : entities)
        {
            if (entity != player)
            {
                player.setSpectatingEntity(entity);

                break;
            }
        }
    }

    /**
     * Provide completion for player usernames for first argument
     */
    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, server.getOnlinePlayerNames());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №238 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionAppend.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.scene.Scene;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;

/**
 * Sub-command /action append
 *
 * This sub-command is responsible for starting recording given
 */
public class SubCommandActionAppend extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "append";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.append";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}append{r} {7}<filename> <offset> [scene]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);
        int offset = CommandBase.parseInt(args[1], 0);

        if (args.length >= 3)
        {
            Scene scene = CommonProxy.scenes.get(args[2], sender.getEntityWorld());

            if (scene != null)
            {
                CommonProxy.scenes.record(args[2], args[0], offset, player);
            }
        }
        else
        {
            CommonProxy.manager.record(args[0], player, Mode.ACTIONS, true, true, offset, null);
        }
    }
}

==================================================

--- Файл №239 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionCancel.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;

public class SubCommandActionCancel extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "cancel";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.cancel";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}cancel{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);

        if (CommonProxy.manager.cancel(player))
        {
            Blockbuster.l10n.info(sender, "action.cancel");
        }
    }
}

==================================================

--- Файл №240 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionClear.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.PacketUnloadRecordings;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;

/**
 * Sub-command /action clear
 *
 * This sub-command is responsible for clearing out tracking information about
 * the player records on the server and also sending a packet for unloading the
 * records on the client.
 *
 * Used in some buggy situations when server doesn't send unload packet or
 * doesn't want to send clients a new record.
 */
public class SubCommandActionClear extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "clear";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.clear";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}clear{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);
        Recording.get(player).removeRecordings();

        Dispatcher.sendTo(new PacketUnloadRecordings(), player);
    }
}

==================================================

--- Файл №241 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionPlay.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.commands.CommandAction;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.data.Mode;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.world.World;

/**
 * Sub-command /action play
 *
 * This sub-command is responsible for starting playback of ghost actor from
 * given attributes.
 */
public class SubCommandActionPlay extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "play";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.play";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}play{r} {7}<filename> [invincibility] [morph_nbt]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        World world = sender.getEntityWorld();
        EntityActor actor = CommandAction.actorFromArgs(args, world);

        CommonProxy.manager.play(args[0], actor, Mode.BOTH, true);
        world.spawnEntity(actor);
    }
}

==================================================

--- Файл №242 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionRecord.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.scene.Scene;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;

/**
 * Sub-command /action record
 *
 * This sub-command is responsible for starting recording given filename'd
 * action with optionally provided scene.
 */
public class SubCommandActionRecord extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "record";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.record";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}record{r} {7}<filename> [scene]{7}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);

        if (args.length >= 2)
        {
            Scene scene = CommonProxy.scenes.get(args[1], sender.getEntityWorld());

            if (scene != null)
            {
                CommonProxy.scenes.record(args[1], args[0], player);
            }
        }
        else
        {
            CommonProxy.manager.record(args[0], player, Mode.ACTIONS, true, true, null);
        }
    }
}

==================================================

--- Файл №243 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionRequest.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.recording.RecordUtils;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Sub-command /action request
 *
 * This command is responsible for requesting record frames from the server
 */
public class SubCommandActionRequest extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "request";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.request";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}request{r} {7}<filename>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        CommonProxy.scenes.play(args[0], sender.getEntityWorld());
        RecordUtils.sendRecordTo(args[0], getCommandSenderAsPlayer(sender));
    }
}

==================================================

--- Файл №244 ---
Путь: main\java\mchorse\blockbuster\commands\action\SubCommandActionStop.java
--------------------
package mchorse.blockbuster.commands.action;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Sub-command /action stop
 *
 * This sub-command is responsible for stopping the action recording of current
 * player.
 */
public class SubCommandActionStop extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "stop";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.action.stop";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}action {8}stop{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        CommonProxy.manager.halt(getCommandSenderAsPlayer(sender), false, true);
    }
}

==================================================

--- Файл №245 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelClear.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.client.model.parsing.ModelExtrudedLayer;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.mclib.utils.ReflectionUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.AbstractTexture;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.ResourceLocation;

import java.util.*;

/**
 * Command /model clear
 *
 * This sub-command is responsible for clearing texture cache from the textures
 * which were fetched from b.a domains, and were cached as dynamic 
 * texture (purple checkered).
 */
public class SubCommandModelClear extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "clear";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.clear";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}clear{r} {7}[path]{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        TextureManager manager = Minecraft.getMinecraft().renderEngine;
        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(manager);
        String prefix = args.length == 0 ? "" : args[0];

        if (map != null)
        {
            List<AbstractTexture> remove = new ArrayList<AbstractTexture>();

            Iterator<Map.Entry<ResourceLocation, ITextureObject>> it = map.entrySet().iterator();

            while (it.hasNext())
            {
                Map.Entry<ResourceLocation, ITextureObject> entry = it.next();
                ResourceLocation key = entry.getKey();
                ITextureObject texture = entry.getValue();
                String domain = key.getResourceDomain();

                List<String> domains = Arrays.asList("c.s", "s&b", "b.a", "http", "https");
                boolean bbDomain = domains.contains(domain);

                if (bbDomain && key.getResourcePath().startsWith(prefix) && texture instanceof AbstractTexture)
                {
                    remove.add((AbstractTexture) texture);

                    if (!prefix.isEmpty())
                    {
                        ModelExtrudedLayer.clearByTexture(key);
                    }

                    it.remove();
                }
            }

            for (AbstractTexture texture : remove)
            {
                if (texture != TextureUtil.MISSING_TEXTURE)
                {
                    texture.deleteGlTexture();
                }
            }
        }

        if (prefix.isEmpty())
        {
            ModelExtrudedLayer.clear();
        }
    }
}

==================================================

--- Файл №246 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelClearStructures.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /model clear_structures
 */
public class SubCommandModelClearStructures extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "clear_structures";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.clear_structures";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}clear_structures{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        StructureMorph.reloadStructures();
    }
}

==================================================

--- Файл №247 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelCombine.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.utils.TextureUtils;
import mchorse.mclib.utils.files.GlobalTree;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.mclib.utils.resources.FilteredResourceLocation;
import mchorse.mclib.utils.resources.MultiResourceLocation;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.mclib.utils.resources.TextureProcessor;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class SubCommandModelCombine extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "combine";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.combine";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}combine{r} {7}<paths...>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        List<MultiResourceLocation> toExport = new ArrayList<MultiResourceLocation>();
        List<FolderEntry> entries = new ArrayList<FolderEntry>();

        for (String path : args)
        {
            FolderEntry entry = GlobalTree.TREE.getByPath("b.a/" + path, null);

            if (entry != null)
            {
                entries.add(entry);
            }
        }

        if (entries.isEmpty())
        {
            Blockbuster.l10n.error(sender, "commands.combining_empty", toExport.size());
            return;
        }

        this.generate(toExport, entries);

        if (toExport.isEmpty())
        {
            Blockbuster.l10n.error(sender, "commands.combining_folders_empty", toExport.size());
            return;
        }

        Blockbuster.l10n.info(sender, "commands.started_combining", toExport.size());

        try
        {
            new Thread(new CombineThread(sender, toExport)).start();
        }
        catch (Exception e)
        {}
    }

    private void generate(List<MultiResourceLocation> toExport, List<FolderEntry> entries)
    {
        this.generateRLs(entries, entries.get(0), 0, "", (string) ->
        {
            String[] splits = string.substring(1).split("!");
            MultiResourceLocation location = new MultiResourceLocation();

            for (String split : splits)
            {
                location.children.add(new FilteredResourceLocation(RLUtils.create(split)));
            }

            toExport.add(location);
        });
    }

    private void generateRLs(List<FolderEntry> entries, FolderEntry folder, int index, String prefix, Consumer<String> callback)
    {
        for (AbstractEntry entry : folder.getEntries())
        {
            if (entry instanceof FileEntry)
            {
                FileEntry file = (FileEntry) entry;

                if (index == entries.size() - 1)
                {
                    callback.accept(prefix + "!" + file.resource);
                }
                else
                {
                    this.generateRLs(entries, entries.get(index + 1), index + 1, prefix + "!" + file.resource, callback);
                }
            }
        }
    }

    /**
     * Local thread that combines all the skins instead of
     * hanging the game until it's done...
     */
    public static class CombineThread implements Runnable
    {
        public ICommandSender sender;
        public List<MultiResourceLocation> locations;

        public CombineThread(ICommandSender sender, List<MultiResourceLocation> locations)
        {
            this.sender = sender;
            this.locations = locations;
        }

        @Override
        public void run()
        {
            int i = 0;

            for (MultiResourceLocation location : this.locations)
            {
                try
                {
                    BufferedImage image = TextureProcessor.process(location);
                    File folder = new File(ClientProxy.configFile, "export");
                    File file = TextureUtils.getFirstAvailableFile(folder, "combined_" + i);

                    folder.mkdirs();
                    ImageIO.write(image, "png", file);

                    Blockbuster.l10n.info(this.sender, "commands.combined", i);

                    Thread.sleep(50);
                }
                catch (Exception e)
                {}

                i += 1;
            }

            Blockbuster.l10n.info(this.sender, "commands.finished_combining");
        }
    }
}

==================================================

--- Файл №248 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelConvertSkin.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.utils.files.GlobalTree;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.IResource;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import org.apache.commons.io.FilenameUtils;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.awt.image.ImageObserver;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Command /model convert
 *
 * This command is responsible for converting 64x32 skins to 64x64 and 
 * vice versa. 
 */
public class SubCommandModelConvertSkin extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "convert";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.convert";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}convert{r} {7}<steve|fred> <skin>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String model = args[0];
        String skin = String.join(" ", SubCommandBase.dropFirstArgument(args));

        if (!(model.equals("steve") || model.equals("fred")))
        {
            throw new CommandException("blockbuster.error.commands.convert_model", model);
        }

        /* If extension or path exist, then it means we need to use the full path, not
         * not the shortened version... */
        String path = model + "/" + (skin.contains(".") || skin.contains("/") ? "skins/" + skin : skin);
        ResourceLocation location = RLUtils.create("b.a", path);

        try
        {
            IResource resource = Minecraft.getMinecraft().getResourceManager().getResource(location);
            BufferedImage image = ImageIO.read(resource.getInputStream());
            int w = image.getWidth();
            int h = image.getHeight();
            boolean one = w == h;

            /* Check for correct aspect ratio */
            if (!(w % 64 == 0 && h % (one ? 64 : 32) == 0 && (one || w == h * 2)))
            {
                throw new CommandException("blockbuster.error.commands.convert_skin_size", w, h);
            }

            BufferedImage target;

            if (model.equals("steve"))
            {
                /* Convert to 64x64 */
                target = new BufferedImage(w, h * 2, 2);

                Graphics graphics = target.getGraphics();
                float s = w / 64F;

                /* These coordinates were copied from
                 * ImageBufferDownload class */
                graphics.drawImage(image, 0, 0, null);
                graphics.setColor(new Color(0, 0, 0, 0));
                graphics.fillRect(0, h / 2, w, h / 2);
                this.drawImage(graphics, target, 24, 48, 20, 52, 4, 16, 8, 20, s);
                this.drawImage(graphics, target, 28, 48, 24, 52, 8, 16, 12, 20, s);
                this.drawImage(graphics, target, 20, 52, 16, 64, 8, 20, 12, 32, s);
                this.drawImage(graphics, target, 24, 52, 20, 64, 4, 20, 8, 32, s);
                this.drawImage(graphics, target, 28, 52, 24, 64, 0, 20, 4, 32, s);
                this.drawImage(graphics, target, 32, 52, 28, 64, 12, 20, 16, 32, s);
                this.drawImage(graphics, target, 40, 48, 36, 52, 44, 16, 48, 20, s);
                this.drawImage(graphics, target, 44, 48, 40, 52, 48, 16, 52, 20, s);
                this.drawImage(graphics, target, 36, 52, 32, 64, 48, 20, 52, 32, s);
                this.drawImage(graphics, target, 40, 52, 36, 64, 44, 20, 48, 32, s);
                this.drawImage(graphics, target, 44, 52, 40, 64, 40, 20, 44, 32, s);
                this.drawImage(graphics, target, 48, 52, 44, 64, 52, 20, 56, 32, s);
            }
            else
            {
                /* Else, convert from 64x64 to 64x32 */
                target = new BufferedImage(w, h / 2, 2);

                Graphics graphics = target.getGraphics();
                graphics.drawImage(image, 0, 0, (ImageObserver) null);
            }

            /* Set target to opposite model */
            String targetModel = model.equals("steve") ? "fred" : "steve";
            File file = new File(ClientProxy.configFile, "models/" + targetModel + "/skins/" + skin);

            file.mkdirs();
            ImageIO.write(target, "png", file);

            target.flush();
            image.flush();
        }
        catch (CommandException e)
        {
            throw e;
        }
        catch (IOException e)
        {
            e.printStackTrace();
            throw new CommandException("blockbuster.error.commands.convert_skin", model, skin, e.getMessage());
        }

        Blockbuster.l10n.success(sender, "commands.convert_skin", model, skin);
    }

    /**
     * Draw parts of the image to another image using graphics and with 
     * a custom scale so it could support high resolution skins
     */
    private void drawImage(Graphics graphics, BufferedImage image, float a1, float a2, float b1, float b2, float c1, float c2, float d1, float d2, float s)
    {
        graphics.drawImage(image, (int) (a1 * s), (int) (a2 * s), (int) (b1 * s), (int) (b2 * s), (int) (c1 * s), (int) (c2 * s), (int) (d1 * s), (int) (d2 * s), null);
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, "steve", "fred");
        }

        if (args.length >= 2 && Arrays.asList("steve", "fred").contains(args[0]))
        {
            String skin = String.join(" ", SubCommandBase.dropFirstArgument(args));
            String path = "b.a/" + args[0] + "/skins/" + skin;
            FolderEntry skins = GlobalTree.TREE.getByPath(path, null);
            String name = FilenameUtils.getBaseName(FilenameUtils.getPathNoEndSeparator(path));

            if (skins != null && skins.title.equals(name))
            {
                List<String> strings = new ArrayList<String>();
                String prefix = skin.contains("/") ? skin.substring(0, skin.lastIndexOf("/") + 1) : "";

                for (AbstractEntry entry : skins.getEntries())
                {
                    if (entry.title.contains(".."))
                    {
                        continue;
                    }

                    strings.add(prefix + entry.title);
                }

                return getListOfStringsMatchingLastWord(args, strings);
            }
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №249 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelExport.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.client.model.parsing.ModelExporter;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.metamorph.commands.CommandMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.entity.Render;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.server.CommandSummon;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityList;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.event.ClickEvent;

import javax.annotation.Nullable;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.util.Collections;
import java.util.List;

/**
 * Command /model export
 *
 * This command is responsible for converting (i.e. exporting) in-game Minecraft
 * models (ModelBase or his children) to JSON scheme that supports my custom
 * models.
 *
 * This is attempt number two, and it's a successful attempt!
 */
public class SubCommandModelExport extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "export";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.export";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}export{r} {7}<entity_name> [entity_tag]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    @SuppressWarnings({"rawtypes", "unchecked"})
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        /* Gather needed elements for exporter class */
        String type = args[0];
        Entity entity = EntityList.createEntityByIDFromName(new ResourceLocation(type), sender.getEntityWorld());

        if (args.length > 1)
        {
            try
            {
                NBTTagCompound tag = new NBTTagCompound();

                entity.writeToNBT(tag);
                tag.merge(JsonToNBT.getTagFromJson(CommandMorph.mergeArgs(args, 1)));
                entity.readFromNBT(tag);
            }
            catch (Exception e)
            {
                throw new CommandException("metamorph.error.morph.nbt", e.getMessage());
            }
        }

        Render render = Minecraft.getMinecraft().getRenderManager().getEntityRenderObject(entity);

        if (render == null || !(render instanceof RenderLivingBase) || !(entity instanceof EntityLivingBase))
        {
            Blockbuster.l10n.error(sender, "model.export.wrong_type", type);
            return;
        }

        /* Export the model */
        ModelExporter exporter = new ModelExporter((EntityLivingBase) entity, (RenderLivingBase) render);

        String output = exporter.exportJSON(type);
        File exportFolder = new File(CommonProxy.configFile.getAbsolutePath() + "/export");

        exportFolder.mkdirs();

        /* Save exported model */
        try
        {
            File destination = new File(CommonProxy.configFile.getAbsolutePath() + "/export/" + type.replaceAll("[^\\w\\d_-]", "_") + ".json");
            PrintWriter writer = new PrintWriter(destination);

            writer.print(output);
            writer.close();

            ITextComponent file = new TextComponentString(destination.getName());
            file.getStyle().setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_FILE, destination.getAbsolutePath()));
            file.getStyle().setUnderlined(Boolean.valueOf(true));

            Blockbuster.l10n.success(sender, "model.export.saved", type, file);
        }
        catch (FileNotFoundException e)
        {
            Blockbuster.l10n.error(sender, "model.export.error_save");
        }
    }

    /**
     * Auto-complete entity type list
     *
     * Brutally ripped from {@link CommandSummon} class
     */
    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos pos)
    {
        return args.length == 1 ? getListOfStringsMatchingLastWord(args, EntityList.getEntityNameList()) : Collections.<String>emptyList();
    }
}


==================================================

--- Файл №250 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelExportObj.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.parsing.ModelExporterOBJ;
import mchorse.blockbuster.commands.BBCommandBase;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraft.client.resources.IResource;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import org.apache.commons.io.FileUtils;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.List;

public class SubCommandModelExportObj extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "export_obj";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.export_obj";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}export_obj{r} {7}<model_name> [pose]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String modelName = args[0];
        ModelCustom model = ModelCustom.MODELS.get(modelName);

        if (model == null)
        {
            throw new CommandException("blockbuster.error.model.export.no_model", modelName);
        }

        Model data = model.model;
        ModelPose pose = args.length >= 2 ? data.getPose(args[1]) : data.getPose("standing");
        String obj = new ModelExporterOBJ(data, pose).export(modelName);

        /* Save */
        String filename = modelName.replaceAll("[^\\w\\d_-]", "_");
        File destination = new File(CommonProxy.configFile, "export/" + filename + ".obj");

        if (data.defaultTexture != null)
        {
            try
            {
                String mtl = "# MTL generated by Blockbuster (version " + Blockbuster.VERSION + ")\n\nnewmtl default\nKd 1.000000 1.000000 1.000000\nNi 1.000000\nd 1.000000\nillum 2\nmap_Kd " + filename + ".png";
                File mtlFile = new File(CommonProxy.configFile, "export/" + filename + ".mtl");
                FileUtils.writeStringToFile(mtlFile, mtl, StandardCharsets.UTF_8);
            }
            catch (Exception e)
            {}

            try
            {
                IResource resource = Minecraft.getMinecraft().getResourceManager().getResource(data.defaultTexture);
                BufferedImage image = TextureUtil.readBufferedImage(resource.getInputStream());
                File texture = new File(CommonProxy.configFile, "export/" + filename + ".png");

                ImageIO.write(image, "png", texture);
            }
            catch (Exception e)
            {}
        }

        try
        {
            FileUtils.writeStringToFile(destination, obj, StandardCharsets.UTF_8);

            Blockbuster.l10n.success(sender, "model.export.obj", modelName);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "model.export.obj", modelName);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, ModelCustom.MODELS.keySet());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №251 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelReload.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketReloadModels;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * /model reload
 * 
 * Model subcommand which is responsible for forcing the server to reload 
 * the models.
 */
public class SubCommandModelReload extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "reload";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.reload";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}reload{r} {7}[force]{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        boolean force = args.length >= 1 && CommandBase.parseBoolean(args[0]);

        /* Reload models and skin */
        Blockbuster.proxy.loadModels(force);

        Dispatcher.sendToServer(new PacketReloadModels(force));
    }
}

==================================================

--- Файл №252 ---
Путь: main\java\mchorse\blockbuster\commands\model\SubCommandModelReport.java
--------------------
package mchorse.blockbuster.commands.model;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.api.loaders.lazy.IModelLazyLoader;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderJSON;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderOBJ;
import mchorse.blockbuster.api.loaders.lazy.ModelLazyLoaderVOX;
import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.ResourceLocation;

import java.io.File;

/**
 * /model report
 *
 * This command generates a report of all the files in config/blockbuster/models/
 * and copies it to copy-paste buffer.
 */
public class SubCommandModelReport extends BBCommandBase
{
    @Override
    public String getName()
    {
        return "report";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.model.report";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}model {8}report{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        File models = new File(ClientProxy.configFile, "models");
        StringBuilder output = new StringBuilder();

        output.append("Models folder skins report:\n\n");

        this.processRecursively(output, models, models, "", "", false);

        GuiScreen.setClipboardString(output.toString().trim());

        Blockbuster.l10n.success(sender, "commands.model_report");
    }

    private void processRecursively(StringBuilder output, File root, File models, String prefix, String indent, boolean isModel)
    {
        if (!models.isDirectory())
        {
            return;
        }

        File[] files = models.listFiles();

        for (File file : files)
        {
            if (!file.isFile())
            {
                continue;
            }

            String name = file.getName();
            String aux = "";
            boolean obj = name.endsWith(".obj");
            boolean vox = name.endsWith(".vox");

            if (!isModel && (obj || name.equals("model.json") || vox))
            {
                IModelLazyLoader loader = Blockbuster.proxy.pack.models.get(prefix);

                if (loader instanceof ModelLazyLoaderOBJ && obj)
                {
                    isModel = true;
                    aux += ", loaded OBJ";
                }
                else if (loader instanceof ModelLazyLoaderVOX && vox)
                {
                    isModel = true;
                    aux += ", loaded VOX";
                }
                else if (loader != null && loader.getClass() == ModelLazyLoaderJSON.class)
                {
                    isModel = true;
                    aux += ", loaded JSON";
                }
            }

            if (name.endsWith(".png") || name.endsWith(".jpg") || name.endsWith(".jpeg") || name.endsWith(".gif"))
            {
                ResourceLocation location = RLUtils.create("b.a:" + (prefix.isEmpty() ? "" : prefix + "/") + name);
                ITextureObject texture = Minecraft.getMinecraft().renderEngine.getTexture(location);

                if (texture == TextureUtil.MISSING_TEXTURE)
                {
                    aux += ", loaded but missing";
                }
                else if (texture != null)
                {
                    aux += ", loaded";
                }
            }

            output.append(indent);
            output.append(name);
            output.append(aux);
            output.append("\n");
        }

        for (File file : files)
        {
            if (!file.isDirectory())
            {
                continue;
            }

            output.append(indent);
            output.append(file.getName());
            output.append("/\n");
            this.processRecursively(output, root, file, prefix.isEmpty() ? file.getName() : prefix + "/" + file.getName(), indent + "    ", isModel);
        }
    }
}

==================================================

--- Файл №253 ---
Путь: main\java\mchorse\blockbuster\commands\modelblock\SubCommandModelBlockBase.java
--------------------
package mchorse.blockbuster.commands.modelblock;

import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;

public abstract class SubCommandModelBlockBase extends BBCommandBase
{
    @Override
    public int getRequiredArgs()
    {
        return 3;
    }

    public TileEntityModel getModelBlock(ICommandSender sender, String[] args) throws CommandException
    {
        int x = CommandBase.parseInt(args[0]);
        int y = CommandBase.parseInt(args[1]);
        int z = CommandBase.parseInt(args[2]);

        TileEntity tile = sender.getEntityWorld().getTileEntity(new BlockPos(x, y, z));

        if (tile instanceof TileEntityModel)
        {
            return (TileEntityModel) tile;
        }

        throw new CommandException("modelblock.missing", x, y, z);
    }
}

==================================================

--- Файл №254 ---
Путь: main\java\mchorse\blockbuster\commands\modelblock\SubCommandModelBlockMorph.java
--------------------
package mchorse.blockbuster.commands.modelblock;

import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.common.network.NetworkRegistry;

public class SubCommandModelBlockMorph extends SubCommandModelBlockBase
{
    @Override
    public String getName()
    {
        return "morph";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.modelblock.morph";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}modelblock {8}morph{r} {7}<x> <y> <z> [morph_nbt]{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        TileEntityModel model = this.getModelBlock(sender, args);
        String morphData = args.length >= 4 ? String.join(" ", SubCommandBase.dropFirstArguments(args, 3)) : null;
        AbstractMorph morph = null;

        if (morphData != null)
        {
            try
            {
                morph = MorphManager.INSTANCE.morphFromNBT(JsonToNBT.getTagFromJson(morphData));
            }
            catch (Exception e)
            {}
        }

        model.setMorph(morph);

        int x = model.getPos().getX();
        int y = model.getPos().getY();
        int z = model.getPos().getZ();

        PacketModifyModelBlock message = new PacketModifyModelBlock(model.getPos(), model, true);
        Dispatcher.DISPATCHER.get().sendToAllAround(message, new NetworkRegistry.TargetPoint(sender.getEntityWorld().provider.getDimension(), x, y, z, 64));
    }
}

==================================================

--- Файл №255 ---
Путь: main\java\mchorse\blockbuster\commands\modelblock\SubCommandModelBlockProperty.java
--------------------
package mchorse.blockbuster.commands.modelblock;

import com.google.common.collect.ImmutableList;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.mclib.commands.McCommandBase;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.network.NetworkRegistry;

import javax.annotation.Nullable;
import java.util.List;

public class SubCommandModelBlockProperty extends SubCommandModelBlockBase
{
    public static final List<String> PROPERTIES = ImmutableList.of("enabled");

    @Override
    public String getName()
    {
        return "property";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.modelblock.property";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}modelblock {8}property{r} {7}<x> <y> <z> <property:enabled> <value>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 5;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        TileEntityModel model = this.getModelBlock(sender, args);
        String property = args[3];

        if (!PROPERTIES.contains(property))
        {
            throw new CommandException("modelblock.wrong_property", property);
        }

        if (property.equals("enabled"))
        {
            model.getSettings().setEnabled(CommandBase.parseBoolean(args[4]));
        }

        model.markDirty();

        int x = model.getPos().getX();
        int y = model.getPos().getY();
        int z = model.getPos().getZ();

        PacketModifyModelBlock message = new PacketModifyModelBlock(model.getPos(), model);
        Dispatcher.DISPATCHER.get().sendToAllAround(message, new NetworkRegistry.TargetPoint(sender.getEntityWorld().provider.getDimension(), x, y, z, 64));
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos targetPos)
    {
        if (args.length == 4)
        {
            return getListOfStringsMatchingLastWord(args, PROPERTIES);
        }
        else if (args.length == 5)
        {
            String property = args[3];

            if (property.equals("enabled"))
            {
                return getListOfStringsMatchingLastWord(args, McCommandBase.BOOLEANS);
            }
        }

        return super.getTabCompletions(server, sender, args, targetPos);
    }
}

==================================================

--- Файл №256 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordAdd.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.data.Record;
import mchorse.metamorph.commands.CommandMorph;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.List;

/**
 * Command /record add
 *
 * This command is responsible for adding a desired action to the given player
 * recording.
 */
public class SubCommandRecordAdd extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "add";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.add";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}add{r} {7}<filename> <tick> <action_type> [data_tag]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 3;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        int tick = CommandBase.parseInt(args[1], 0);
        Record record = CommandRecord.getRecord(filename);

        if (tick < 0 || tick >= record.actions.size())
        {
            throw new CommandException("record.tick_out_range", tick, record.actions.size() - 1);
        }

        if (!ActionRegistry.NAME_TO_CLASS.containsKey(args[2]))
        {
            throw new CommandException("record.wrong_action", args[2]);
        }

        try
        {
            Action action = ActionRegistry.fromName(args[2]);

            if (args.length > 3)
            {
                action.fromNBT(JsonToNBT.getTagFromJson(CommandMorph.mergeArgs(args, 3)));
            }

            record.addAction(tick, action);
            record.dirty = true;
        }
        catch (Exception e)
        {
            throw new CommandException("record.add", args[2], e.getMessage());
        }
    }

    /**
     * Tab complete action
     */
    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 3)
        {
            return getListOfStringsMatchingLastWord(args, ActionRegistry.NAME_TO_ID.keySet());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №257 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordApply.java
--------------------
package mchorse.blockbuster.commands.record;

import com.google.common.collect.ImmutableList;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

/**
 * Command /record apply
 * 
 * This command is responsible for applying one player recording to another
 * player recording file
 */
public class SubCommandRecordApply extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "apply";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.apply";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}apply{r} {7}<target> <source> <properties> [relative] [from] [to]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 3;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String target = args[0];
        String source = args[1];
        List<String> properties = new ArrayList<String>();

        if (args[2].contains(","))
        {
            properties.addAll(Arrays.asList(args[2].split(",")));
        }
        else
        {
            properties.add(args[2]);
        }

        Record targetRecord = CommandRecord.getRecord(target);
        Record sourceRecord = CommandRecord.getRecord(source);

        List<String> newProperties = new ArrayList<String>();

        for (String property : properties)
        {
            if (property.equalsIgnoreCase("head"))
            {
                newProperties.addAll(ImmutableList.of("yaw", "yaw_head", "pitch"));
            }
            else if (property.equalsIgnoreCase("position"))
            {
                newProperties.addAll(ImmutableList.of("x", "y", "z"));
            }
            else if (SubCommandRecordClean.PROPERTIES.contains(property))
            {
                newProperties.add(property);
            }
        }

        if (newProperties.isEmpty())
        {
            throw new CommandException("record.wrong_apply_property", String.join(", ", properties));
        }

        int start = 0;
        int end = Math.min(targetRecord.frames.size() - 1, sourceRecord.frames.size() - 1);
        boolean relative = args.length >= 4 && CommandBase.parseBoolean(args[3]);

        if (args.length >= 5)
        {
            start = CommandBase.parseInt(args[4], start, end);
        }

        if (args.length >= 6)
        {
            end = CommandBase.parseInt(args[5], start, end);
        }

        for (String property : newProperties)
        {
            this.apply(property, targetRecord, sourceRecord, relative, start, end);
        }

        try
        {
            RecordUtils.saveRecord(targetRecord);

            Blockbuster.l10n.success(sender, "record.apply", target, String.join(", ", newProperties), source, start, end);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }

    private void apply(String property, Record targetRecord, Record sourceRecord, boolean relative, int start, int end)
    {
        double firstOriginal = SubCommandRecordClean.get(property, sourceRecord.frames.get(start));

        for (int i = start; i <= end; i++)
        {
            double original = SubCommandRecordClean.get(property, sourceRecord.frames.get(i));
            double value = SubCommandRecordClean.get(property, targetRecord.frames.get(i));

            SubCommandRecordClean.set(property, targetRecord.frames.get(i), relative ? value + (original - firstOriginal) : original);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 3)
        {
            List<String> props = new ArrayList<>(SubCommandRecordClean.PROPERTIES);

            props.add("head");
            props.add("position");

            return getListOfStringsMatchingLastWord(args, props);
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №258 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordBase.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.commands.BBCommandBase;
import mchorse.blockbuster.recording.RecordUtils;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.List;

public abstract class SubCommandRecordBase extends BBCommandBase
{
    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, RecordUtils.getReplays());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №259 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordCalculateBodyYaw.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.SwipeAction;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.MathHelper;

import java.util.List;

public class SubCommandRecordCalculateBodyYaw extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "calculate_body_yaw";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.calculate_body_yaw";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}calculate_body_yaw{r} {7}<filename>{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        Record record = CommandRecord.getRecord(filename);
        Frame prev = null;
        float renderYawOffset = 0;
        int swingProgress = 0;

        for (int i = 0, c = record.frames.size(); i < c; i++)
        {
            Frame frame = record.frames.get(i);
            List<Action> actions = record.getActions(i);

            if (actions != null)
            {
                for (Action action : actions)
                {
                    if (action instanceof SwipeAction)
                    {
                        swingProgress = 6;
                    }
                }
            }

            if (prev == null)
            {
                prev = frame;
                renderYawOffset = prev.yaw;
            }

            double dx = frame.x - prev.x;
            double dz = frame.z - prev.z;
            float distSq = (float)(dx * dx + dz * dz);
            float tempRenderyawOffset = renderYawOffset;

            if (distSq > 0.0025000002F)
            {
                float f1 = (float) MathHelper.atan2(dz, dx) * (180F / (float)Math.PI) - 90.0F;
                float f2 = MathHelper.abs(MathHelper.wrapDegrees(frame.yaw) - f1);

                if (95.0F < f2 && f2 < 265.0F)
                {
                    tempRenderyawOffset = f1 - 180.0F;
                }
                else
                {
                    tempRenderyawOffset = f1;
                }
            }

            if (swingProgress > 0)
            {
                renderYawOffset = frame.yaw;
            }

            float coolBob = MathHelper.wrapDegrees(tempRenderyawOffset - renderYawOffset);
            renderYawOffset += coolBob * 0.3F;
            float anotherCoolBob = MathHelper.wrapDegrees(frame.yaw - renderYawOffset);

            if (anotherCoolBob < -75.0F)
            {
                anotherCoolBob = -75.0F;
            }

            if (anotherCoolBob >= 75.0F)
            {
                anotherCoolBob = 75.0F;
            }

            renderYawOffset = frame.yaw - anotherCoolBob;

            if (anotherCoolBob * anotherCoolBob > 2500.0F)
            {
                renderYawOffset += anotherCoolBob * 0.2F;
            }

            frame.hasBodyYaw = true;
            frame.bodyYaw = renderYawOffset;

            prev = frame;
            swingProgress--;
        }

        RecordUtils.dirtyRecord(record);

        Blockbuster.l10n.success(sender, "record.calculate_body_yaw", filename);
    }
}


==================================================

--- Файл №260 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordCamera.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.aperture.Aperture;
import mchorse.aperture.camera.CameraAPI;
import mchorse.aperture.camera.CameraProfile;
import mchorse.aperture.camera.CameraUtils;
import mchorse.aperture.camera.data.Position;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.Optional;

import java.util.List;

/**
 * Command /record camera
 *
 * This command is responsible for generating a player recording based on
 * an Aperture camera profile (works only if Aperture installed)
 */
public class SubCommandRecordCamera extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "camera";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.camera";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}camera{r} {7}<filename> <camera_profile> [x] [y] [z]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];

        try
        {
            float x = args.length >= 3 ? (float) CommandBase.parseDouble(args[2]) : 0;
            float y = args.length >= 4 ? (float) CommandBase.parseDouble(args[3]) : 0;
            float z = args.length >= 5 ? (float) CommandBase.parseDouble(args[4]) : 0;

            Record record = this.generate(filename, args[1], x, y, z);

            CommonProxy.manager.records.put(filename, record);
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.camera", filename, args[1]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", filename);
        }
    }

    private Record generate(String filename, String profile, float x, float y, float z) throws Exception
    {
        if (CameraHandler.isApertureLoaded())
        {
            return this.generateProfile(filename, profile, x, y, z);
        }

        throw new IllegalStateException("/record camera can't be used, because Aperture mod isn't installed!");
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    private Record generateProfile(String filename, String profile, float x, float y, float z) throws Exception
    {
        Record record = new Record(filename);
        CameraProfile camera = CameraUtils.readProfile(profile);
        Position prev = new Position();
        Position position = new Position();

        int c = (int) camera.getDuration();

        for (int i = 0; i <= c; i++)
        {
            Frame frame = new Frame();

            if (i == c)
            {
                camera.applyProfile(c - 1, 0.999F, position);
            }
            else
            {
                camera.applyProfile(i, 0, position);
            }

            if (i == 0)
            {
                prev.copy(position);
            }

            frame.x = position.point.x + x;
            frame.y = position.point.y + y;
            frame.z = position.point.z + z;
            frame.yaw = position.angle.yaw;
            frame.yawHead = position.angle.yaw;
            frame.bodyYaw = position.angle.yaw;
            frame.pitch = position.angle.pitch;
            frame.roll = position.angle.roll;

            frame.motionX = position.point.x - prev.point.x;
            frame.motionY = position.point.y - prev.point.y;
            frame.motionZ = position.point.z - prev.point.z;

            frame.hasBodyYaw = true;

            record.frames.add(frame);
            record.actions.add(null);

            prev.copy(position);
        }

        return record;
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 2 && CameraHandler.isApertureLoaded())
        {
            return getListOfStringsMatchingLastWord(args, getCameraProfiles());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }

    @Optional.Method(modid = Aperture.MOD_ID)
    private List<String> getCameraProfiles()
    {
        return CameraAPI.getServerProfiles();
    }
}

==================================================

--- Файл №261 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordClean.java
--------------------
package mchorse.blockbuster.commands.record;

import com.google.common.collect.ImmutableSet;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.List;
import java.util.Set;

/**
 * Command /record clean
 *
 * This command is responsible for cleaning given property from player 
 * recording.
 */
public class SubCommandRecordClean extends SubCommandRecordBase
{
    public static final Set<String> PROPERTIES = ImmutableSet.of("x", "y", "z", "yaw", "yaw_head", "body_yaw", "pitch", "fall_distance", "sprinting", "sneaking", "active_hands", "mounted", "roll");

    public static double get(String property, Frame frame)
    {
        if (property.equals("x"))
        {
            return frame.x;
        }
        else if (property.equals("y"))
        {
            return frame.y;
        }
        else if (property.equals("z"))
        {
            return frame.z;
        }
        else if (property.equals("yaw"))
        {
            return frame.yaw;
        }
        else if (property.equals("yaw_head"))
        {
            return frame.yawHead;
        }
        else if (property.equals("body_yaw"))
        {
            return frame.bodyYaw;
        }
        else if (property.equals("pitch"))
        {
            return frame.pitch;
        }
        else if (property.equals("fall_distance"))
        {
            return frame.fallDistance;
        }
        else if (property.equals("sprinting"))
        {
            return frame.isSprinting ? 1 : 0;
        }
        else if (property.equals("sneaking"))
        {
            return frame.isSneaking ? 1 : 0;
        }
        else if (property.equals("active_hands"))
        {
            return frame.activeHands;
        }
        else if (property.equals("mounted"))
        {
            return frame.isMounted ? 1 : 0;
        }
        else if (property.equals("roll"))
        {
            return frame.roll;
        }

        return 0;
    }

    public static void set(String property, Frame frame, double value)
    {
        if (property.equals("x"))
        {
            frame.x = value;
        }
        else if (property.equals("y"))
        {
            frame.y = value;
        }
        else if (property.equals("z"))
        {
            frame.z = value;
        }
        else if (property.equals("yaw"))
        {
            frame.yaw = (float) value;
        }
        else if (property.equals("yaw_head"))
        {
            frame.yawHead = (float) value;
        }
        else if (property.equals("body_yaw"))
        {
            frame.hasBodyYaw = true;
            frame.bodyYaw = (float) value;
        }
        else if (property.equals("pitch"))
        {
            frame.pitch = (float) value;
        }
        else if (property.equals("fall_distance"))
        {
            frame.fallDistance = (float) value;
        }
        else if (property.equals("sprinting"))
        {
            frame.isSprinting = value == 1;
        }
        else if (property.equals("sneaking"))
        {
            frame.isSneaking = value == 1;
        }
        else if (property.equals("active_hands"))
        {
            frame.activeHands = (int) value;
        }
        else if (property.equals("mounted"))
        {
            frame.isMounted = value == 1;
        }
        else if (property.equals("roll"))
        {
            frame.roll = (float) value;
        }
    }

    @Override
    public String getName()
    {
        return "clean";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.clean";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}clean{r} {7}<filename> <property> [value] [from] [to]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        String property = args[1];
        Record record = CommandRecord.getRecord(filename);

        if (!PROPERTIES.contains(property))
        {
            throw new CommandException("record.wrong_clean_property", property);
        }

        int start = 0;
        int end = record.getLength() - 1;

        if (args.length >= 4)
        {
            start = CommandBase.parseInt(args[3], start, end);
        }

        if (args.length >= 5)
        {
            end = CommandBase.parseInt(args[4], start, end);
        }

        double original = get(property, record.frames.get(start));

        if (args.length >= 3)
        {
            original = CommandBase.parseDouble(original, args[2], false);
        }

        for (int i = start; i <= end; i++)
        {
            set(property, record.frames.get(i), original);
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.clean", filename, property, start, end);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 2)
        {
            return getListOfStringsMatchingLastWord(args, PROPERTIES);
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №262 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordCreate.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.Vec3d;

/**
 * Command /record create
 *
 * This command is responsible for generating an empty player recording based on
 * current player's position or arbitrary position and rotation
 */
public class SubCommandRecordCreate extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "create";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.create";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}create{r} {7}<filename> <duration> [x] [y] [z] [yaw] [pitch]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];

        try
        {
            Vec3d pos = sender.getPositionVector();
            EntityPlayer player = sender instanceof EntityPlayer ? (EntityPlayer) sender : null;

            int duration = CommandBase.parseInt(args[1], 1, 100000);
            float yaw = player == null ? 0 : player.rotationYaw;
            float pitch = player == null ? 0 : player.rotationPitch;

            double x = args.length >= 3 ? CommandBase.parseDouble(pos.x, args[2], false) : pos.x;
            double y = args.length >= 4 ? CommandBase.parseDouble(pos.y, args[3], false) : pos.y;
            double z = args.length >= 5 ? CommandBase.parseDouble(pos.z, args[4], false) : pos.z;
            yaw = args.length >= 6 ? (float) CommandBase.parseDouble(yaw, args[5], false) : yaw;
            pitch = args.length >= 7 ? (float) CommandBase.parseDouble(pitch, args[6], false) : pitch;

            Record record = this.generateProfile(player, filename, duration, x, y, z, yaw, pitch);

            CommonProxy.manager.records.put(filename, record);
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.create", filename, duration);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", filename);
        }
    }

    private Record generateProfile(EntityPlayer player, String filename, int duration, double x, double y, double z, float yaw, float pitch)
    {
        Record record = new Record(filename);
        Frame original = new Frame();

        if (player != null)
        {
            original.fromPlayer(player);
        }

        original.x = x;
        original.y = y;
        original.z = z;
        original.yaw = original.yawHead = original.bodyYaw = yaw;
        original.pitch = pitch;
        original.hasBodyYaw = true;

        for (int i = 0; i <= duration; i++)
        {
            record.frames.add(original.copy());
            record.actions.add(null);
        }

        return record;
    }
}

==================================================

--- Файл №263 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordCut.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

import java.util.ArrayList;
import java.util.List;

public class SubCommandRecordCut extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "cut";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.cut";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}cut{r} {7}<filename> <before> <after>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 3;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Record record = CommandRecord.getRecord(args[0]);
        int from = CommandBase.parseInt(args[1], 0, record.getLength() - 1);
        int to = CommandBase.parseInt(args[2], 0, record.getLength() - 1);
        int min = Math.min(from, to);

        to = Math.max(from, to);
        from = min;

        if (record.getLength() == 0)
        {
            Blockbuster.l10n.error(sender, "record.empty", record.filename);

            return;
        }

        /* Process */
        List<Frame> frames = new ArrayList<Frame>();
        List<List<Action>> actions = new ArrayList<List<Action>>();

        frames.addAll(record.frames.subList(from, to));
        actions.addAll(record.actions.subList(from, to));

        record.frames = frames;
        record.actions = actions;

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.cut", args[0], args[1], args[2]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}

==================================================

--- Файл №264 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordDelete.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.mclib.client.gui.framework.elements.GuiConfirmationScreen;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.client.ClientHandlerConfirm;
import mchorse.mclib.network.mclib.common.PacketConfirm;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Command /record delete
 *
 * This command is responsible for deleting a recording.
 */
public class SubCommandRecordDelete extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "delete";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.delete";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}delete{r} {7}<filename> [force]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);

        if (!OpHelper.isPlayerOp(player))
        {
            throw new CommandException("record.delete_rights");
        }

        String filename = args[0];

        //throws exception if recording doesn't exist
        CommandRecord.getRecord(filename);

        boolean force = (args.length>1) ? CommandBase.parseBoolean(args[1]) : false;

        if (force)
        {
            this.deleteRecording(filename);
        }
        else
        {
            Dispatcher.sendTo(new PacketConfirm(ClientHandlerConfirm.GUI.MCSCREEN, IKey.format("blockbuster.commands.record.delete_modal", filename),
                    (value) ->
                    {
                        if(value)
                        {
                            this.deleteRecording(filename);
                        }
                    }), player);
        }
    }

    private void deleteRecording(String filename)
    {
        try
        {
            RecordUtils.replayFile(filename).delete();
            RecordUtils.unloadRecord(CommonProxy.manager.records.get(filename));
            CommonProxy.manager.records.remove(filename);
        }
        catch (NullPointerException e)
        {}
    }
}


==================================================

--- Файл №265 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordDupe.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record dupe
 * 
 * This command is responsible for duplicating player recording to a new 
 * player recording file
 */
public class SubCommandRecordDupe extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "dupe";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.dupe";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}dupe{r} {7}<filename> <new_filename> [overwrite]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        boolean overwrite = (args.length>2) ? CommandBase.parseBoolean(args[2]) : false;

        if (RecordUtils.isReplayExists(args[1]) && !overwrite)
        {
            throw new CommandException("record.already_exists", args[1]);
        }

        try
        {
            Record record = CommandRecord.getRecord(args[0]).clone();

            record.filename = args[1];
            record.save(RecordUtils.replayFile(record.filename));

            CommonProxy.manager.records.put(args[1], record);
            Blockbuster.l10n.success(sender, "record.duped", args[0], args[1]);
        }
        catch (Exception e)
        {
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}

==================================================

--- Файл №266 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordErase.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

import java.util.ArrayList;
import java.util.List;

public class SubCommandRecordErase extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "erase";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.erase";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}erase{r} {7}<filename> <count> <from>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 3;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Record record = CommandRecord.getRecord(args[0]);
        int count = CommandBase.parseInt(args[1], 0);
        int from = CommandBase.parseInt(args[2], 0, record.getLength() - 1);

        count = MathUtils.clamp(count, 0, record.getLength() - 1 - from);

        if (record.getLength() == 0)
        {
            Blockbuster.l10n.error(sender, "record.empty", record.filename);

            return;
        }

        /* Process */
        List<Frame> frames = new ArrayList<Frame>();
        List<List<Action>> actions = new ArrayList<List<Action>>();

        frames.addAll(record.frames);
        actions.addAll(record.actions);

        for (int i = 0; i < count; i++)
        {
            frames.remove(from);
            actions.remove(from);
        }

        record.frames = frames;
        record.actions = actions;

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.erase", count, from, args[0], record.getLength());
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}

==================================================

--- Файл №267 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordFade.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record fade
 *
 * This command is responsible for fading out the player recording to
 * the first frame.
 */
public class SubCommandRecordFade extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "fade";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.fade";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}fade{r} {7}<filename> <fade_out>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Record record = CommandRecord.getRecord(args[0]);
        int length = record.getLength();
        int fadeOut = CommandBase.parseInt(args[1], 1, length);

        if (length == 0)
        {
            Blockbuster.l10n.error(sender, "record.empty", record.filename);

            return;
        }

        /* Process */
        Frame first = record.getFrame(0);
        Frame last = record.getFrame(length - fadeOut - 1);

        for (int i = 0; i < fadeOut; i ++)
        {
            Frame current = record.getFrame(length - fadeOut + i);
            float x = i / (float) fadeOut;

            current.x = Interpolations.lerp(last.x, first.x, x);
            current.y = Interpolations.lerp(last.y, first.y, x);
            current.z = Interpolations.lerp(last.z, first.z, x);
            current.yaw = Interpolations.lerpYaw(last.yaw, first.yaw, x);
            current.yawHead = Interpolations.lerpYaw(last.yawHead, first.yawHead, x);
            current.mountYaw = Interpolations.lerp(last.mountYaw, first.mountYaw, x);
            current.pitch = Interpolations.lerp(last.pitch, first.pitch, x);
            current.mountPitch = Interpolations.lerp(last.mountPitch, first.mountPitch, x);

            if (current.hasBodyYaw && first.hasBodyYaw)
            {
                current.bodyYaw = Interpolations.lerpYaw(last.bodyYaw, first.bodyYaw, x);
            }
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.faded", args[0], args[1]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}


==================================================

--- Файл №268 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordFill.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

import java.util.ArrayList;
import java.util.List;

public class SubCommandRecordFill extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "fill";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.fill";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}fill{r} {7}<filename> <count> [tick]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        int count = CommandBase.parseInt(args[1], 1);
        Record record = CommandRecord.getRecord(filename);

        int tick = record.frames.size() - 1;
        boolean add = true;

        if (args.length > 2)
        {
            tick = CommandBase.parseInt(args[2], 0, tick);
            add = false;
        }

        Frame original = record.getFrame(tick).copy();

        List<Frame> frames = record.frames;
        List<List<Action>> actions = record.actions;

        if (!add)
        {
            frames = new ArrayList<Frame>();
            actions = new ArrayList<List<Action>>();

            for (int i = 0; i <= tick; i ++)
            {
                frames.add(record.getFrame(i));
                actions.add(record.getActions(i));
            }
        }

        for (int i = 0; i < count; i ++)
        {
            frames.add(original.copy());
            actions.add(null);
        }

        if (!add)
        {
            for (int i = tick + 1; i < record.frames.size(); i ++)
            {
                frames.add(record.getFrame(i));
                actions.add(record.getActions(i));
            }

            record.frames = frames;
            record.actions = actions;
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.fill", count, tick, filename, record.frames.size());
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}


==================================================

--- Файл №269 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordFlip.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

import java.util.Arrays;
import java.util.List;

public class SubCommandRecordFlip extends SubCommandRecordBase
{
    public static List<String> ALLOWED_AXES = Arrays.asList("x", "z");

    @Override
    public String getName()
    {
        return "flip";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.flip";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}flip{r} {7}<filename> <axis:X|Z> <coordinate> [center]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 3;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Record record = CommandRecord.getRecord(args[0]);
        String axis = args[1].toLowerCase();
        boolean center = args.length < 4 ? true : CommandBase.parseBoolean(args[3]);
        double coordinate = CommandBase.parseInt(args[2]) + (center ? 0.5 : 0);

        if (!ALLOWED_AXES.contains(axis))
        {
            Blockbuster.l10n.error(sender, "record.wrong_axis", args[1]);

            return;
        }

        for (Frame frame : record.frames)
        {
            if (axis.equals("x"))
            {
                double diff = coordinate - frame.x;

                frame.x = coordinate + diff;
                frame.yaw *= -1;
                frame.yawHead *= -1;
                frame.mountYaw *= -1;
            }
            else
            {
                double diff = coordinate - frame.z;

                frame.z = coordinate + diff;
                frame.yaw = -frame.yaw + 180;
                frame.yawHead = -frame.yawHead + 180;
                frame.mountYaw = -frame.mountYaw + 180;
            }
        }

        for (List<Action> actions : record.actions)
        {
            if (actions == null)
            {
                continue;
            }

            for (Action action : actions)
            {
                action.flip(axis, center ? Math.floor(coordinate) : coordinate - 0.5);
            }
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.flipped", args[0], args[1], args[2]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 2)
        {
            return getListOfStringsMatchingLastWord(args, ALLOWED_AXES);
        }
        else if (args.length == 3 && ALLOWED_AXES.contains(args[1]))
        {
            Vec3d vec3d = sender.getPositionVector();
            int coordinate = (int) Math.floor(args[1].equals("x") ? vec3d.x : vec3d.z);

            return getListOfStringsMatchingLastWord(args, Arrays.asList(coordinate));
        }
        else if (args.length == 4)
        {
            return getListOfStringsMatchingLastWord(args, new String[] {"true", "false"});
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №270 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordGet.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;

import java.util.List;

/**
 * Command /record get
 *
 * This command is responsible for outputting data of action at given tick and
 * player recording.
 */
public class SubCommandRecordGet extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "get";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.get";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}get{r} {7}<filename> <tick>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        int tick = CommandBase.parseInt(args[1], 0);
        Record record = CommandRecord.getRecord(filename);

        if (tick <= 0 || tick >= record.actions.size())
        {
            throw new CommandException("record.tick_out_range", tick, record.actions.size() - 1);
        }

        List<Action> actions = record.actions.get(tick);

        if (actions == null)
        {
            throw new CommandException("record.no_action", filename, tick);
        }

        for (int i = 0, c = actions.size(); i < c; i++)
        {
            Action action = actions.get(i);
            NBTTagCompound tag = new NBTTagCompound();
            String type = ActionRegistry.NAME_TO_CLASS.inverse().get(action.getClass());
            action.toNBT(tag);

            Blockbuster.l10n.info(sender, "record.action", tick, type, i, tag.toString());
        }
    }
}

==================================================

--- Файл №271 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordInfo.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record info
 *
 * This command is responsible for outputting information about given record.
 */
public class SubCommandRecordInfo extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "info";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.info";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}info{r} {7}<filename>{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        Record record = CommandRecord.getRecord(filename);

        Blockbuster.l10n.info(sender, "record.info", args[0], record.version, record.frames.size(), record.unload);
    }
}

==================================================

--- Файл №272 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordMerge.java
--------------------
package mchorse.blockbuster.commands.record;

import java.util.ArrayList;
import java.util.List;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.MorphAction;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record merge
 *
 * This command is responsible for merging the actions in the 
 * source record into the destination record.
 */
public class SubCommandRecordMerge extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "merge";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.merge";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}merge{r} {7}<source> <destination> [morph_only]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Record src = CommandRecord.getRecord(args[0]);
        Record dst = CommandRecord.getRecord(args[1]);
        boolean morph = false;

        if (args.length > 2)
        {
            morph = CommandBase.parseBoolean(args[2]);
        }

        int size = Math.min(src.actions.size(), dst.actions.size());

        for (int i = 0; i < size; i++)
        {
            if (i >= dst.actions.size())
            {
                break;
            }

            List<Action> srcActions = src.actions.get(i);
            List<Action> dstActions = dst.actions.get(i);

            if (srcActions != null)
            {
                for (Action action : srcActions)
                {
                    if (!morph || action instanceof MorphAction)
                    {
                        if (dstActions == null)
                        {
                            dstActions = new ArrayList<Action>();

                            dst.actions.set(i, dstActions);
                        }

                        dstActions.add(action);
                    }
                }
            }
        }

        try
        {
            RecordUtils.saveRecord(dst);

            Blockbuster.l10n.success(sender, "record.merge", args[0], args[1]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}


==================================================

--- Файл №273 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordOrigin.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.Vec3d;

import java.util.List;

/**
 * Command /record origin
 *
 * This command is responsible for changing the origin of player recordings.
 */
public class SubCommandRecordOrigin extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "origin";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.origin";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}origin{r} {7}<filename> [rotation] [x] [y] [z]{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];

        Vec3d position = sender.getPositionVector();
        Record record = CommandRecord.getRecord(filename);

        double x = position.x;
        double y = position.y;
        double z = position.z;

        double rotation = args.length >= 2 ? CommandBase.parseDouble(args[1]) : 0;

        double firstX = 0;
        double firstY = 0;
        double firstZ = 0;
        int i = 0;

        for (Frame frame : record.frames)
        {
            if (i == 0)
            {
                firstX = frame.x;
                firstY = frame.y;
                firstZ = frame.z;

                if (args.length >= 5)
                {
                    x = CommandBase.parseDouble(firstX, args[2], false);
                    y = CommandBase.parseDouble(firstY, args[3], false);
                    z = CommandBase.parseDouble(firstZ, args[4], false);
                }
            }

            double frameX = frame.x - firstX;
            double frameY = frame.y - firstY;
            double frameZ = frame.z - firstZ;

            if (rotation != 0)
            {
                float cos = (float) Math.cos(rotation / 180 * Math.PI);
                float sin = (float) Math.sin(rotation / 180 * Math.PI);

                double xx = frameX * cos - frameZ * sin;
                double zz = frameX * sin + frameZ * cos;

                frameX = xx;
                frameZ = zz;

                frame.yaw += rotation;
                frame.yawHead += rotation;

                if (frame.hasBodyYaw)
                {
                    frame.bodyYaw += rotation;
                }
            }

            frame.x = x + frameX;
            frame.y = y + frameY;
            frame.z = z + frameZ;

            i++;
        }

        for (List<Action> actions : record.actions)
        {
            if (actions == null || actions.isEmpty())
            {
                continue;
            }

            for (Action action : actions)
            {
                action.changeOrigin(rotation, x, y, z, firstX, firstY, firstZ);
            }
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.changed_origin", args[0], firstX, firstY, firstZ, x, y, z);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}

==================================================

--- Файл №274 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordProcess.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.MathBuilder;
import mchorse.mclib.math.Variable;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.List;

/**
 * Command /record process
 *
 * This command is responsible for processing given property according to given
 * math expression
 */
public class SubCommandRecordProcess extends SubCommandRecordBase
{
    public MathBuilder builder;
    public Variable initial;
    public Variable value;
    public Variable tick;
    public Variable from;
    public Variable to;
    public Variable factor;

    public SubCommandRecordProcess()
    {
        this.builder = new MathBuilder();

        this.builder.register(this.initial = new Variable("initial", 0));
        this.builder.register(this.value = new Variable("value", 0));
        this.builder.register(this.tick = new Variable("tick", 0));
        this.builder.register(this.from = new Variable("from", 0));
        this.builder.register(this.to = new Variable("to", 0));
        this.builder.register(this.factor = new Variable("factor", 0));
}

    @Override
    public String getName()
    {
        return "process";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.process";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}process{r} {7}<filename> <property> <from> <to> <math>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 5;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        String property = args[1];
        Record record = CommandRecord.getRecord(filename);

        if (!SubCommandRecordClean.PROPERTIES.contains(property))
        {
            throw new CommandException("record.wrong_clean_property", property);
        }

        int start = 0;
        int end = record.getLength() - 1;

        start = CommandBase.parseInt(args[2], start, end);
        end = CommandBase.parseInt(args[3], start, end);

        double initial = SubCommandRecordClean.get(property, record.frames.get(start));
        String expression = String.join(" ", SubCommandBase.dropFirstArguments(args, 4));
        IValue math;

        try
        {
            math = this.builder.parse(expression);
        }
        catch (Exception e)
        {
            throw new CommandException("record.invalid_math_expression", expression);
        }

        this.from.set(start);
        this.to.set(end);

        for (int i = start; i <= end; i++)
        {
            Frame frame = record.frames.get(i);

            this.initial.set(initial);
            this.value.set(SubCommandRecordClean.get(property, frame));
            this.tick.set(i);
            this.factor.set((i - start) / (double) (end - start));

            SubCommandRecordClean.set(property, frame, math.get().doubleValue());
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.process", filename, property, start, end);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 2)
        {
            return getListOfStringsMatchingLastWord(args, SubCommandRecordClean.PROPERTIES);
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №275 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordProlong.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record prolong
 * 
 * This command is responsible for duplicating player recording to a new 
 * player recording file
 */
public class SubCommandRecordProlong extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "prolong";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.prolong";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}prolong{r} {7}<filename> [post_delay] [pre_delay]{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Record record = CommandRecord.getRecord(args[0]);

        if (args.length >= 2)
        {
            record.postDelay = CommandBase.parseInt(args[1]);
        }

        if (args.length >= 3)
        {
            record.preDelay = CommandBase.parseInt(args[2]);
        }

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.prolonged", args[0], record.preDelay, record.postDelay);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}

==================================================

--- Файл №276 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordRemove.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.client.gui.framework.elements.GuiConfirmationScreen;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.client.ClientHandlerConfirm;
import mchorse.mclib.network.mclib.common.PacketConfirm;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;
import java.util.function.Consumer;

/**
 * Command /record remove
 *
 * This command is responsible for removing action(s) from given player
 * recording.
 */
public class SubCommandRecordRemove extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "remove";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.remove";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}remove{r} {7}<filename> <tick> [index] [force]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        int tick = CommandBase.parseInt(args[1], 0);
        Record record = CommandRecord.getRecord(filename);

        if (tick < 0 || tick >= record.actions.size())
        {
            throw new CommandException("record.tick_out_range", tick, record.actions.size() - 1);
        }

        this.removeActions(args, sender, record, tick);
    }

    /**
     * Remove action(s) from given record at given tick
     */
    private void removeActions(String[] args, ICommandSender sender, Record record, int tick) throws CommandException
    {
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);

        boolean force = (args.length>3) ? CommandBase.parseBoolean(args[3]) : false;

        //index of -1 means to remove all actions
        if (args.length > 2 && CommandBase.parseInt(args[2]) != -1)
        {
            int index = CommandBase.parseInt(args[2]);
            List<Action> actions = record.actions.get(tick);

            if (actions == null)
            {
                throw new CommandException("record.already_empty", args[1], args[0]);
            }

            if (index < -1 || index >= actions.size())
            {
                throw new CommandException("record.index_out_range", index, actions.size() - 1);
            }

            dispatchConfirm(player, force, (value) ->
            {
                if (value)
                {
                    /* Remove action at given tick */
                    if (actions.size() <= 1)
                    {
                        record.actions.set(tick, null);
                    }
                    else
                    {
                        actions.remove(index);
                    }
                }
            });
        }
        else
        {
            dispatchConfirm(player, force, (value) ->
            {
                if (value)
                {
                    /* Remove all actions at tick */
                    record.actions.set(tick, null);
                }
            });
        }

        record.dirty = true;
    }

    private void dispatchConfirm(EntityPlayerMP player, boolean force, Consumer<Boolean> callback)
    {
        if (force)
        {
            callback.accept(force);
        }
        else
        {
            Dispatcher.sendTo(new PacketConfirm(ClientHandlerConfirm.GUI.MCSCREEN, IKey.lang("blockbuster.commands.record.remove_modal"),(value) ->
            {
                callback.accept(value);
            }), player);
        }
    }
}

==================================================

--- Файл №277 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordRemoveAll.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.client.ClientHandlerConfirm;
import mchorse.mclib.network.mclib.common.PacketConfirm;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;

import java.util.function.Consumer;

public class SubCommandRecordRemoveAll extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "remove_all";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.remove_all";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}remove_all{r} {7}<filename> [force]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        Record record = CommandRecord.getRecord(filename);
        boolean force = (args.length > 1) ? CommandBase.parseBoolean(args[1]) : false;
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);

        this.dispatchConfirm(player, force, filename, (value) ->
        {
            if (value)
            {
                record.actions.replaceAll((actions) ->
                {
                    return null;
                });
            }
        });
    }

    private void dispatchConfirm(EntityPlayerMP player, boolean force, String filename, Consumer<Boolean> callback)
    {
        if (force)
        {
            callback.accept(force);
        }
        else
        {
            Dispatcher.sendTo(new PacketConfirm(ClientHandlerConfirm.GUI.MCSCREEN, IKey.format("blockbuster.commands.record.remove_all_modal", filename),(value) ->
            {
                callback.accept(value);
            }), player);
        }
    }
}


==================================================

--- Файл №278 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordRemoveBodyYaw.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

public class SubCommandRecordRemoveBodyYaw extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "remove_body_yaw";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.remove_body_yaw";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}remove_body_yaw{r} {7}<filename>{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        Record record = CommandRecord.getRecord(filename);

        for (int i = 0, c = record.frames.size(); i < c; i++)
        {
            Frame frame = record.frames.get(i);

            frame.hasBodyYaw = false;
            frame.bodyYaw = 0F;
        }

        RecordUtils.dirtyRecord(record);

        Blockbuster.l10n.success(sender, "record.remove_body_yaw", filename);
    }
}


==================================================

--- Файл №279 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordRename.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

public class SubCommandRecordRename extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "rename";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.rename";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}rename{r} {7}<filename> <new_filename>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (RecordUtils.isReplayExists(args[1]))
        {
            throw new CommandException("record.already_exists", args[1]);
        }

        try
        {
            Record record = CommandRecord.getRecord(args[0]).clone();

            record.filename = args[1];
            record.save(RecordUtils.replayFile(record.filename));

            CommonProxy.manager.rename(args[0], record);

            Blockbuster.l10n.success(sender, "record.renamed", args[0], args[1]);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", args[1]);
        }
    }
}

==================================================

--- Файл №280 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordRestore.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.io.File;
import java.util.List;

public class SubCommandRecordRestore extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "restore";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.restore";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}restore{r} {7}<filename> <iteration>{r}";
    }

    @Override
    public int getRequiredArgs() {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String name = args[0];
        String iteration = args[1];
        Record record = CommandRecord.getRecord(name);

        if (RecordUtils.getReplayIterations(record.filename).contains(iteration))
        {
            File current = RecordUtils.replayFile(name);
            File toRestore = new File(RecordUtils.replayFile(name).getAbsolutePath() + "~" + iteration);
            File temporary = RecordUtils.replayFile("mchorse is the coolest");

            if (temporary.exists())
            {
                Blockbuster.l10n.error(sender, "record.cant_restore", name);
            }
            else
            {
                current.renameTo(temporary);
                toRestore.renameTo(current);
                temporary.renameTo(toRestore);

                CommonProxy.manager.records.remove(record.filename);
                RecordUtils.unloadRecord(record);

                Blockbuster.l10n.success(sender, "record.restored", name, iteration);
            }
        }
        else
        {
            Blockbuster.l10n.error(sender, "record.not_exist_iteration", name, iteration);
        }
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos) {
        if (args.length == 2)
        {
            List<String> iterations = RecordUtils.getReplayIterations(args[0]);

            if (!iterations.isEmpty())
            {
                return getListOfStringsMatchingLastWord(args, iterations);
            }
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №281 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordReverse.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record reverse
 *
 * This command is responsible for reversing all frames and actions in
 * the player recording
 */
public class SubCommandRecordReverse extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "reverse";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.reverse";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}reverse{r} {7}<filename>{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        Record record = CommandRecord.getRecord(filename);

        record.reverse();

        try
        {
            RecordUtils.saveRecord(record);

            Blockbuster.l10n.success(sender, "record.reversed", filename);
        }
        catch (Exception e)
        {
            e.printStackTrace();
            Blockbuster.l10n.error(sender, "record.couldnt_save", filename);
        }
    }
}

==================================================

--- Файл №282 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordSearch.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import java.util.List;

public class SubCommandRecordSearch extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "search";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.search";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}search{r} {7}<filename> <action_type> [limit] [output_tags]{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (!ActionRegistry.NAME_TO_CLASS.containsKey(args[1]))
        {
            throw new CommandException("record.wrong_action", args[1]);
        }

        String filename = args[0];
        byte type = ActionRegistry.NAME_TO_ID.get(args[1]).byteValue();
        Record record = CommandRecord.getRecord(filename);

        int i = 0;
        int tick = -1;

        int limit = record.actions.size() + 1;
        boolean outputData = args.length >= 4 ? CommandBase.parseBoolean(args[3]) : false;

        if (args.length >= 3)
        {
            int temp = CommandBase.parseInt(args[2], -1);

            if (temp >= 0)
            {
                limit = temp;
            }
        }

        Blockbuster.l10n.info(sender, "record.search_type", args[1]);

        for (List<Action> actions : record.actions)
        {
            tick++;

            if (actions == null)
            {
                continue;
            }

            if (i >= limit)
            {
                break;
            }

            int j = -1;

            for (Action action : actions)
            {
                j++;

                if (ActionRegistry.getType(action) != type)
                {
                    continue;
                }

                if (outputData)
                {
                    NBTTagCompound tag = new NBTTagCompound();
                    action.toNBT(tag);

                    Blockbuster.l10n.info(sender, "record.search_action_data", tick, j, tag.toString());
                }
                else
                {
                    Blockbuster.l10n.info(sender, "record.search_action", tick, j);
                }
            }

            i++;
        }

    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 2)
        {
            return getListOfStringsMatchingLastWord(args, ActionRegistry.NAME_TO_CLASS.keySet());
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №283 ---
Путь: main\java\mchorse\blockbuster\commands\record\SubCommandRecordTP.java
--------------------
package mchorse.blockbuster.commands.record;

import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;

/**
 * Command /record tp
 * 
 * This command is responsible for teleporting the player to the given 
 * frame at tick in given player recording.
 */
public class SubCommandRecordTP extends SubCommandRecordBase
{
    @Override
    public String getName()
    {
        return "tp";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "blockbuster.commands.record.tp";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}record {8}tp{r} {7}<filename> [tick]{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        String filename = args[0];
        int tick = args.length > 1 ? CommandBase.parseInt(args[1]) : 0;
        Record record = CommandRecord.getRecord(filename);
        EntityPlayerMP player = getCommandSenderAsPlayer(sender);

        RecordUtils.applyFrameOnEntity(player, record, tick);
    }
}

==================================================

--- Файл №284 ---
Путь: main\java\mchorse\blockbuster\common\BlockbusterPermissions.java
--------------------
package mchorse.blockbuster.common;

import mchorse.mclib.permissions.PermissionCategory;

public class BlockbusterPermissions
{
    public static PermissionCategory editModelBlock;
    public static PermissionCategory openScene;
}


==================================================

--- Файл №285 ---
Путь: main\java\mchorse\blockbuster\common\BlockbusterTab.java
--------------------
package mchorse.blockbuster.common;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.common.item.ItemBlockGreen;
import net.minecraft.creativetab.CreativeTabs;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemMonsterPlacer;
import net.minecraft.item.ItemStack;
import net.minecraft.util.NonNullList;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Blockbuster creative tab
 *
 * This is a creative tab for Blockbuster mod. What it does, it basically
 * provides the icon for this tab and also appends actor egg to this tab (since
 * it's really annoying to find actor egg when it's in other tab).
 */
public class BlockbusterTab extends CreativeTabs
{
    public BlockbusterTab()
    {
        super("blockbuster");
    }

    @Override
    @SideOnly(Side.CLIENT)
    public ItemStack getTabIconItem()
    {
        return new ItemStack(Item.getItemFromBlock(Blockbuster.directorBlock));
    }

    /**
     * Display all items and also an actor egg
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void displayAllRelevantItems(NonNullList<ItemStack> items)
    {
        Item.getItemFromBlock(Blockbuster.greenBlock).getSubItems(this, items);
        items.add(ItemStack.EMPTY);
        Item.getItemFromBlock(Blockbuster.dimGreenBlock).getSubItems(this, items);
        items.add(ItemStack.EMPTY);

        for (int i = 0; i < 9; i ++)
        {
            items.add(ItemStack.EMPTY);
        }

        for (Item item : Item.REGISTRY)
        {
            if (item instanceof ItemBlockGreen)
            {
                continue;
            }

            item.getSubItems(this, items);
        }

        /*ItemStack modelBlockStack = new ItemStack(Blockbuster.modelBlockItems[0]);

        items.add(modelBlockStack);*/

        ItemStack stack = new ItemStack(Items.SPAWN_EGG);
        ItemMonsterPlacer.applyEntityIdToItemStack(stack, new ResourceLocation("blockbuster", "actor"));

        items.add(stack);

        if (Blockbuster.addUtilityBlocks.get())
        {
            items.add(new ItemStack(Blocks.COMMAND_BLOCK));
            items.add(new ItemStack(Blocks.STRUCTURE_BLOCK));
            items.add(new ItemStack(Blocks.BARRIER));
        }
    }
}

==================================================

--- Файл №286 ---
Путь: main\java\mchorse\blockbuster\common\GuiHandler.java
--------------------
package mchorse.blockbuster.common;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.aperture.gui.GuiPlayback;
import mchorse.blockbuster.client.gui.GuiActor;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanels;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.Optional.Method;
import net.minecraftforge.fml.common.network.IGuiHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Gui handler class
 *
 * This class is responsible for opening GUIs.
 */
public class GuiHandler implements IGuiHandler
{
    /* GUI ids */
    public static final int PLAYBACK = 0;
    public static final int ACTOR = 1;
    public static final int MODEL_BLOCK = 3;

    /**
     * Shortcut for {@link EntityPlayer#openGui(Object, int, World, int, int, int)}
     */
    public static void open(EntityPlayer player, int ID, int x, int y, int z)
    {
        player.openGui(Blockbuster.instance, ID, player.world, x, y, z);
    }

    /**
     * There's two types of GUI are available right now:
     *
     * - Actor configuration GUI
     * - Director block management GUIs
     * - Playback button GUI
     *
     * IGuiHandler is used to centralize GUI invocations
     */
    @Override
    @SideOnly(Side.CLIENT)
    public Object getClientGuiElement(int ID, EntityPlayer player, World world, int x, int y, int z)
    {
        Entity entity = world.getEntityByID(x);

        if (ID == PLAYBACK && CameraHandler.isApertureLoaded())
        {
            return this.getPlayback();
        }
        else if (ID == ACTOR && entity instanceof EntityActor)
        {
            return new GuiActor(Minecraft.getMinecraft(), (EntityActor) entity);
        }
        else if (ID == MODEL_BLOCK)
        {
            TileEntityModel model = (TileEntityModel) world.getTileEntity(new BlockPos(x, y, z));

            GuiDashboard dashboard = GuiDashboard.get();
            GuiBlockbusterPanels panels = ClientProxy.panels;

            dashboard.panels.setPanel(panels.modelPanel);
            panels.modelPanel.openModelBlock(model);

            return dashboard;
        }

        return null;
    }

    /**
     * Returns created playback GUI
     *
     * The reason behind creating it here, instead of in the
     * getClientGuiElement method, is because it may get Aperture's classes get
     * referenced which might cause I crash.
     *
     * So instead, I'm creating it here, so Method annotation would strip away
     * reference to {@link GuiPlayback} (which in turn will reference
     * Aperture's classes).
     */
    @Method(modid = "aperture")
    private Object getPlayback()
    {
        return new GuiPlayback();
    }

    /**
     * This method is empty, because there's no need for this method to be
     * filled with code. This mod doesn't seem to provide any interaction with
     * Containers.
     */
    @Override
    public Object getServerGuiElement(int ID, EntityPlayer player, World world, int x, int y, int z)
    {
        return null;
    }
}

==================================================

--- Файл №287 ---
Путь: main\java\mchorse\blockbuster\common\GunProps.java
--------------------
package mchorse.blockbuster.common;

import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagFloat;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.world.World;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

/**
 * Blockbuster gun properties
 * <p>
 * This savage fellow is responsible for keeping all of the properties
 * that a gun can have. Those are including: gun properties itself,
 * projectile that will be spawned from the gun, and projectile impact
 * properties.
 */
public class GunProps
{
    /* Gun properties */
    public AbstractMorph defaultMorph;
    public AbstractMorph firingMorph;
    public String fireCommand;
    public int delay;
    public int projectiles;
    public float scatterX;
    public float scatterY;
    public boolean launch;
    public boolean useTarget;
    public ItemStack ammoStack = ItemStack.EMPTY;

    /* Evanechecssss' options */
    public boolean staticRecoil;
    public float recoilXMin;
    public float recoilXMax;
    public float recoilYMin;
    public float recoilYMax;

    public boolean enableArmsShootingPose;
    public boolean alwaysArmsShootingPose;

    public float shootingOffsetX;
    public float shootingOffsetY;
    public float shootingOffsetZ;

    public AbstractMorph inventoryMorph;
    public AbstractMorph crosshairMorph;
    public AbstractMorph handsMorph;
    public AbstractMorph reloadMorph;
    public AbstractMorph zoomOverlayMorph;

    public boolean hideCrosshairOnZoom;
    public boolean useInventoryMorph;
    public boolean hideHandsOnZoom;
    public boolean useZoomOverlayMorph;

    public float zoomFactor;
    public int ammo;
    public boolean useReloading;
    public long reloadingTime;
    public long shotDelay;
    public boolean shootWhenHeld;

    public String destroyCommand;
    public String meleeCommand;
    public String reloadCommand;
    public String zoomOnCommand;
    public String zoomOffCommand;

    public float meleeDamage;
    public float mouseZoom;
    public int durability;
    public boolean preventLeftClick;
    public boolean preventRightClick;
    public boolean preventEntityAttack;

    public int storedAmmo;
    public long storedReloadingTime;
    public long storedShotDelay;
    public int storedDurability;
    public ItemGun.GunState state = ItemGun.GunState.READY_TO_SHOOT;

    /* Projectile properties */
    public AbstractMorph projectileMorph;
    public String tickCommand;
    public int ticking;
    public int lifeSpan;
    public boolean yaw;
    public boolean pitch;
    public boolean sequencer;
    public boolean random;
    public float hitboxX;
    public float hitboxY;
    public float speed;
    public float friction;
    public float gravity;
    public int fadeIn;
    public int fadeOut;

    /* Impact properties */
    public AbstractMorph impactMorph;
    public String impactCommand;
    public String impactEntityCommand;
    public int impactDelay;
    public boolean vanish;
    public boolean bounce;
    public boolean sticks;
    public int hits;
    public float damage;
    public float knockbackHorizontal;
    public float knockbackVertical;
    public float bounceFactor;
    public String vanishCommand;
    public int vanishDelay;
    public float penetration;
    public boolean ignoreBlocks;
    public boolean ignoreEntities;

    /* Transforms */
    public ModelTransform gunTransform = new ModelTransform();
    public ModelTransform gunTransformFirstPerson = new ModelTransform();
    public ModelTransform projectileTransform = new ModelTransform();

    private int shoot = 0;
    private Morph current = new Morph();
    private Morph currentHands = new Morph();
    private Morph currentInventory = new Morph();
    private Morph currentZoomOverlay = new Morph();
    public Morph currentCrosshair = new Morph();
    private boolean renderLock;

    public EntityLivingBase target;
    public ItemGun.GunState lastState = ItemGun.GunState.READY_TO_SHOOT;

    public GunProps()
    {
        this.reset();
    }

    public GunProps(NBTTagCompound tag)
    {
        this.fromNBT(tag);
    }

    public void setCurrent(AbstractMorph morph)
    {
        this.current.setDirect(morph);
    }

    public void setCurrentZoomOverlay(AbstractMorph morph)
    {
        this.currentZoomOverlay.setDirect(morph);
    }

    public void setHandsMorph(AbstractMorph morph)
    {
        this.currentHands.setDirect(morph);
    }

    public void setCrosshairMorph(AbstractMorph morph)
    {
        this.currentCrosshair.setDirect(morph);
    }

    public void setInventoryMorph(AbstractMorph morph)
    {
        this.currentInventory.setDirect(morph);
    }

    public void shot()
    {
        if (this.delay <= 0)
        {
            return;
        }

        this.shoot = this.delay;
        this.current.set(MorphUtils.copy(this.firingMorph));
    }

    @SideOnly(Side.CLIENT)
    public void createEntity()
    {
        this.createEntity(Minecraft.getMinecraft().world);
    }

    public void createEntity(World world)
    {
        if (this.target != null)
        {
            return;
        }

        this.target = new EntityActor(world);
        this.target.onGround = true;
        this.target.rotationYaw = this.target.prevRotationYaw = 0;
        this.target.rotationYawHead = this.target.prevRotationYawHead = 0;
        this.target.rotationPitch = this.target.prevRotationPitch = 0;
    }

    public EntityLivingBase getEntity(EntityGunProjectile entity)
    {
        if (this.target != null)
        {
            this.target.prevPosX = entity.prevPosX;
            this.target.prevPosY = entity.prevPosY;
            this.target.prevPosZ = entity.prevPosZ;

            this.target.posX = entity.posX;
            this.target.posY = entity.posY;
            this.target.posZ = entity.posZ;
        }

        return this.target;
    }

    @SideOnly(Side.CLIENT)
    public void update()
    {
        if (this.target != null)
        {
            this.target.ticksExisted++;

            boolean lastReload = this.lastState == ItemGun.GunState.RELOADING;
            boolean currentReload = this.state == ItemGun.GunState.RELOADING;

            if (currentReload != lastReload)
            {
                if (currentReload)
                {
                    this.current.set(this.reloadMorph);
                }
                else
                {
                    this.current.set(this.defaultMorph);
                }
            }

            this.lastState = this.state;

            AbstractMorph morph = this.current.get();

            if (morph != null)
            {
                morph.update(this.target);
            }

            if (!this.currentCrosshair.isEmpty())
            {
                this.currentCrosshair.get().update(this.target);
            }

            if (!this.currentHands.isEmpty())
            {
                this.currentHands.get().update(this.target);
            }

            if (!this.currentInventory.isEmpty())
            {
                this.currentInventory.get().update(this.target);
            }

            if (!this.currentZoomOverlay.isEmpty())
            {
                this.currentZoomOverlay.get().update(this.target);
            }
        }

        if (this.shoot > 0)
        {
            this.shoot--;

            if (this.shoot == 0)
            {
                this.current.set(MorphUtils.copy(this.defaultMorph));

            }
        }

    }

    @SideOnly(Side.CLIENT)
    public void renderZoomOverlay(EntityLivingBase lastItemHolder, float partialTicks)
    {
        if (this.renderLock)
        {
            return;
        }

        this.renderLock = true;

        if (this.target == null)
        {
            this.createEntity();
        }

        EntityLivingBase entity = this.useTarget ? target : this.target;
        AbstractMorph morph = this.currentZoomOverlay.get();

        if (morph != null && entity != null)
        {
            float rotationYaw = entity.renderYawOffset;
            float prevRotationYaw = entity.prevRenderYawOffset;
            float rotationYawHead = entity.rotationYawHead;
            float prevRotationYawHead = entity.prevRotationYawHead;

            entity.rotationYawHead -= entity.renderYawOffset;
            entity.prevRotationYawHead -= entity.prevRenderYawOffset;
            entity.renderYawOffset = entity.prevRenderYawOffset = 0.0F;

            GL11.glPushMatrix();
            GL11.glTranslatef(0.5F, 0, 0.5F);

            this.setupEntity();
            MorphUtils.render(morph, entity, 0, 0, 0, 0, partialTicks);

            GL11.glPopMatrix();

            entity.renderYawOffset = rotationYaw;
            entity.prevRenderYawOffset = prevRotationYaw;
            entity.rotationYawHead = rotationYawHead;
            entity.prevRotationYawHead = prevRotationYawHead;
        }

        this.renderLock = false;
    }

    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase target, float partialTicks, boolean firstPerson)
    {
        if (this.renderLock)
        {
            return;
        }

        this.renderLock = true;

        if (this.target == null)
        {
            this.createEntity();
        }

        EntityLivingBase entity = this.useTarget ? target : this.target;
        AbstractMorph morph = this.current.get();

        if (morph != null && entity != null)
        {
            float rotationYaw = entity.renderYawOffset;
            float prevRotationYaw = entity.prevRenderYawOffset;
            float rotationYawHead = entity.rotationYawHead;
            float prevRotationYawHead = entity.prevRotationYawHead;

            entity.rotationYawHead -= entity.renderYawOffset;
            entity.prevRotationYawHead -= entity.prevRenderYawOffset;
            entity.renderYawOffset = entity.prevRenderYawOffset = 0.0F;

            GL11.glPushMatrix();
            GL11.glTranslatef(0.5F, 0, 0.5F);
            (firstPerson ? this.gunTransformFirstPerson : this.gunTransform).transform();

            this.setupEntity();

            MorphUtils.render(morph, entity, 0, 0, 0, 0, partialTicks);

            GL11.glPopMatrix();

            entity.renderYawOffset = rotationYaw;
            entity.prevRenderYawOffset = prevRotationYaw;
            entity.rotationYawHead = rotationYawHead;
            entity.prevRotationYawHead = prevRotationYawHead;
        }

        this.renderLock = false;
    }

    @SideOnly(Side.CLIENT)
    public void renderInventoryMorph(EntityLivingBase target, float partialTicks)
    {
        if (this.renderLock)
        {
            return;
        }

        this.renderLock = true;

        if (this.target == null)
        {
            this.createEntity();
        }

        EntityLivingBase entity = this.useTarget ? target : this.target;
        AbstractMorph morph = this.currentInventory.get();

        if (morph != null && entity != null)
        {
            GL11.glPushMatrix();
            GL11.glTranslatef(0.5F, 0, 0.5F);
            GlStateManager.enableDepth();
            this.setupEntity();
            MorphUtils.render(morph, entity, 0, 0, 0, 0, partialTicks);
            GL11.glPopMatrix();
        }

        this.renderLock = false;
    }

    @SideOnly(Side.CLIENT)
    public void renderHands(EntityLivingBase target, float partialTicks, boolean firstPerson)
    {
        if (this.renderLock)
        {
            return;
        }

        this.renderLock = true;

        if (this.target == null)
        {
            this.createEntity();
        }

        EntityLivingBase entity = this.useTarget ? target : this.target;
        AbstractMorph morph = this.currentHands.get();

        if (morph != null && entity != null)
        {
            float rotationYaw = entity.renderYawOffset;
            float prevRotationYaw = entity.prevRenderYawOffset;
            float rotationYawHead = entity.rotationYawHead;
            float prevRotationYawHead = entity.prevRotationYawHead;

            entity.rotationYawHead -= entity.renderYawOffset;
            entity.prevRotationYawHead -= entity.prevRenderYawOffset;
            entity.renderYawOffset = entity.prevRenderYawOffset = 0.0F;

            GL11.glPushMatrix();
            GL11.glTranslatef(0.5F, 0, 0.5F);
            (firstPerson ? this.gunTransformFirstPerson : this.gunTransform).transform();

            this.setupEntity();
            MorphUtils.render(morph, entity, 0, 0, 0, 0, partialTicks);

            GL11.glPopMatrix();

            entity.renderYawOffset = rotationYaw;
            entity.prevRenderYawOffset = prevRotationYaw;
            entity.rotationYawHead = rotationYawHead;
            entity.prevRotationYawHead = prevRotationYawHead;
        }

        this.renderLock = false;
    }


    @SideOnly(Side.CLIENT)
    private void setupEntity()
    {
        /* Reset entity's values, just in case some weird shit is going
         * to happen in morph's update code*/
        this.target.setPositionAndRotation(0, 0, 0, 0, 0);
        this.target.setLocationAndAngles(0, 0, 0, 0, 0);
        this.target.rotationYawHead = this.target.prevRotationYawHead = 0;
        this.target.rotationYaw = this.target.prevRotationYaw = 0;
        this.target.rotationPitch = this.target.prevRotationPitch = 0;
        this.target.renderYawOffset = this.target.prevRenderYawOffset = 0;
        this.target.setVelocity(0, 0, 0);
    }

    /**
     * Reset properties to default values
     */
    public void reset()
    {
        /* Gun properties */
        this.defaultMorph = null;
        this.handsMorph = null;
        this.inventoryMorph = null;
        this.reloadMorph = null;
        this.crosshairMorph = null;
        this.zoomOverlayMorph = null;
        this.firingMorph = null;
        this.fireCommand = "";
        this.delay = 0;
        this.projectiles = 1;
        /* McHorse: screw organizing this */
        this.storedAmmo = 1;
        this.reloadingTime = 0;
        this.storedShotDelay = 0;
        this.shotDelay = 0;
        this.ammo = 1;
        this.storedReloadingTime = 0;
        this.scatterX = this.scatterY = 0F;
        this.launch = false;
        this.useInventoryMorph = false;
        this.useTarget = false;
        this.ammoStack = ItemStack.EMPTY;
        this.zoomFactor = 0;
        this.recoilXMin = 0;
        this.shootingOffsetX = 0;
        this.mouseZoom = 0.5F;
        this.meleeDamage = 0;
        this.shootingOffsetY = 0;
        this.shootingOffsetZ = 0;
        this.staticRecoil = true;
        this.recoilXMax = 0;
        this.recoilYMin = 0;
        this.recoilYMax = 0;
        /* Projectile properties */
        this.projectileMorph = null;
        this.tickCommand = "";
        this.zoomOffCommand = "";
        this.zoomOnCommand = "";
        this.reloadCommand = "";
        this.meleeCommand = "";
        this.destroyCommand = "";
        this.ticking = 0;
        this.durability = 0;
        this.storedDurability = 0;
        this.lifeSpan = 200;
        this.yaw = true;
        this.useZoomOverlayMorph = false;
        this.hideHandsOnZoom = false;
        this.hideCrosshairOnZoom = false;
        this.enableArmsShootingPose = false;
        this.preventRightClick = false;
        this.preventLeftClick = false;
        this.preventEntityAttack = false;
        this.shootWhenHeld = true;
        this.alwaysArmsShootingPose = false;
        this.pitch = true;
        this.sequencer = false;
        this.random = false;
        this.hitboxX = 0.25F;
        this.hitboxY = 0.25F;
        this.speed = 1.0F;
        this.friction = 0.99F;
        this.gravity = 0.03F;
        this.fadeIn = this.fadeOut = 10;

        /* Impact properties */
        this.impactMorph = null;
        this.impactCommand = "";
        this.impactEntityCommand = "";
        this.impactDelay = 0;
        this.vanish = true;
        this.bounce = false;
        this.sticks = false;
        this.hits = 1;
        this.state = ItemGun.GunState.READY_TO_SHOOT;
        this.damage = 0F;
        this.knockbackHorizontal = 0F;
        this.knockbackVertical = 0F;
        this.bounceFactor = 1F;
        this.vanishCommand = "";
        this.vanishDelay = 0;
        this.penetration = 0;
        this.ignoreBlocks = false;
        this.ignoreEntities = false;

        /* Transforms */
        this.gunTransform = new ModelTransform();
        this.projectileTransform = new ModelTransform();
    }

    public void fromNBT(NBTTagCompound tag)
    {
        this.reset();

        /* Gun properties */
        this.defaultMorph = this.create(tag, "Morph");
        this.handsMorph = this.create(tag, "HandsMorph");
        this.inventoryMorph = this.create(tag, "InventoryMorph");
        this.reloadMorph = this.create(tag, "ReloadMorph");
        this.crosshairMorph = this.create(tag, "CrosshairMorph");
        this.zoomOverlayMorph = this.create(tag, "ZoomOverlayMorph");
        this.firingMorph = this.create(tag, "Fire");

        if (tag.hasKey("FireCommand")) this.fireCommand = tag.getString("FireCommand");
        if (tag.hasKey("Delay")) this.delay = tag.getInteger("Delay");

        if (tag.hasKey("Projectiles")) this.projectiles = tag.getInteger("Projectiles");
        if (tag.hasKey("StoredReloadingTime")) this.storedReloadingTime = tag.getInteger("StoredReloadingTime");

        if (tag.hasKey("Scatter"))
        {
            NBTBase scatter = tag.getTag("Scatter");

            if (scatter instanceof NBTTagList)
            {
                NBTTagList list = (NBTTagList) scatter;

                if (list.tagCount() >= 2)
                {
                    this.scatterX = list.getFloatAt(0);
                    this.scatterY = list.getFloatAt(1);
                }
            }
            else
            {
                /* Old compatibility scatter */
                this.scatterX = this.scatterY = tag.getFloat("Scatter");
            }
        }
        if (tag.hasKey("ScatterY")) this.scatterY = tag.getFloat("ScatterY");
        if (tag.hasKey("Launch")) this.launch = tag.getBoolean("Launch");
        if (tag.hasKey("UseInventoryMorph")) this.useInventoryMorph = tag.getBoolean("UseInventoryMorph");
        if (tag.hasKey("UseReloading")) this.useReloading = tag.getBoolean("UseReloading");


        if (tag.hasKey("Target")) this.useTarget = tag.getBoolean("Target");
        if (tag.hasKey("AmmoStack")) this.ammoStack = new ItemStack(tag.getCompoundTag("AmmoStack"));

        /* Projectile properties */
        this.projectileMorph = this.create(tag, "Projectile");
        if (tag.hasKey("TickCommand")) this.tickCommand = tag.getString("TickCommand");
        if (tag.hasKey("MeleeCommand")) this.meleeCommand = tag.getString("MeleeCommand");
        if (tag.hasKey("DestroyCommand")) this.destroyCommand = tag.getString("DestroyCommand");
        if (tag.hasKey("ReloadCommand")) this.reloadCommand = tag.getString("ReloadCommand");
        if (tag.hasKey("ZoomOnCommand")) this.zoomOnCommand = tag.getString("ZoomOnCommand");
        if (tag.hasKey("ZoomOffCommand")) this.zoomOffCommand = tag.getString("ZoomOffCommand");


        if (tag.hasKey("Ticking")) this.ticking = tag.getInteger("Ticking");
        if (tag.hasKey("StoredAmmo")) this.storedAmmo = tag.getInteger("StoredAmmo");
        if (tag.hasKey("ReloadingTime")) this.reloadingTime = tag.getInteger("ReloadingTime");
        if (tag.hasKey("StoredShotDelay")) this.storedShotDelay = tag.getLong("StoredShotDelay");
        if (tag.hasKey("ShotDelay")) this.shotDelay = tag.getLong("ShotDelay");


        if (tag.hasKey("Ammo")) this.ammo = tag.getInteger("Ammo");

        if (tag.hasKey("LifeSpan")) this.lifeSpan = tag.getInteger("LifeSpan");
        if (tag.hasKey("Yaw")) this.yaw = tag.getBoolean("Yaw");
        if (tag.hasKey("UseZoomOverlayMorph")) this.useZoomOverlayMorph = tag.getBoolean("UseZoomOverlayMorph");
        if (tag.hasKey("HideHandsOnZoom")) this.hideHandsOnZoom = tag.getBoolean("HideHandsOnZoom");
        if (tag.hasKey("HideCrosshairOnZoom")) this.hideCrosshairOnZoom = tag.getBoolean("HideCrosshairOnZoom");


        if (tag.hasKey("ShootWhenHeld")) this.shootWhenHeld = tag.getBoolean("ShootWhenHeld");


        if (tag.hasKey("ArmPose")) this.enableArmsShootingPose = tag.getBoolean("ArmPose");
        if (tag.hasKey("ArmPoseAlways")) this.alwaysArmsShootingPose = tag.getBoolean("ArmPoseAlways");
        if (tag.hasKey("PreventLeftClick")) this.preventLeftClick = tag.getBoolean("PreventLeftClick");
        if (tag.hasKey("PreventRightClick")) this.preventRightClick = tag.getBoolean("PreventRightClick");
        if (tag.hasKey("PreventEntityAttack")) this.preventEntityAttack = tag.getBoolean("PreventEntityAttack");


        if (tag.hasKey("Pitch")) this.pitch = tag.getBoolean("Pitch");
        if (tag.hasKey("Sequencer")) this.sequencer = tag.getBoolean("Sequencer");
        if (tag.hasKey("Random")) this.random = tag.getBoolean("Random");
        if (tag.hasKey("HX")) this.hitboxX = tag.getFloat("HX");
        if (tag.hasKey("HY")) this.hitboxY = tag.getFloat("HY");
        if (tag.hasKey("Speed")) this.speed = tag.getFloat("Speed");
        if (tag.hasKey("Zoom")) this.zoomFactor = tag.getFloat("Zoom");
        if (tag.hasKey("RecoilMinX")) this.recoilXMin = tag.getFloat("RecoilMinX");
        if (tag.hasKey("ShootingOffsetX")) this.shootingOffsetX = tag.getFloat("ShootingOffsetX");
        if (tag.hasKey("MouseZoom")) this.mouseZoom = tag.getFloat("MouseZoom");
        if (tag.hasKey("MeleeDamage")) this.meleeDamage = tag.getFloat("MeleeDamage");


        if (tag.hasKey("ShootingOffsetY")) this.shootingOffsetY = tag.getFloat("ShootingOffsetY");
        if (tag.hasKey("ShootingOffsetZ")) this.shootingOffsetZ = tag.getFloat("ShootingOffsetZ");


        if (tag.hasKey("StaticRecoil")) this.staticRecoil = tag.getBoolean("StaticRecoil");

        if (tag.hasKey("RecoilMaxX")) this.recoilXMax = tag.getFloat("RecoilMaxX");
        if (tag.hasKey("RecoilMinY")) this.recoilYMin = tag.getFloat("RecoilMinY");
        if (tag.hasKey("RecoilMaxY")) this.recoilYMax = tag.getFloat("RecoilMaxY");

        if (tag.hasKey("Friction")) this.friction = tag.getFloat("Friction");
        if (tag.hasKey("Gravity")) this.gravity = tag.getFloat("Gravity");

        if (tag.hasKey("Durability")) this.durability = tag.getInteger("Durability");
        if (tag.hasKey("StoredDurability")) this.storedDurability = tag.getInteger("StoredDurability");


        if (tag.hasKey("FadeIn")) this.fadeIn = tag.getInteger("FadeIn");
        if (tag.hasKey("FadeOut")) this.fadeOut = tag.getInteger("FadeOut");
        /* Impact properties */
        this.impactMorph = this.create(tag, "Impact");
        if (tag.hasKey("ImpactCommand")) this.impactCommand = tag.getString("ImpactCommand");
        if (tag.hasKey("ImpactEntityCommand")) this.impactEntityCommand = tag.getString("ImpactEntityCommand");
        if (tag.hasKey("ImpactDelay")) this.impactDelay = tag.getInteger("ImpactDelay");
        if (tag.hasKey("Vanish")) this.vanish = tag.getBoolean("Vanish");
        if (tag.hasKey("Bounce")) this.bounce = tag.getBoolean("Bounce");
        if (tag.hasKey("Stick")) this.sticks = tag.getBoolean("Stick");
        if (tag.hasKey("Hits")) this.hits = tag.getInteger("Hits");

        if (tag.hasKey("State")) this.state = ItemGun.GunState.values()[tag.getInteger("State")];

        if (tag.hasKey("Damage")) this.damage = tag.getFloat("Damage");
        if (tag.hasKey("KnockbackH")) this.knockbackHorizontal = tag.getFloat("KnockbackH");
        if (tag.hasKey("KnockbackV")) this.knockbackVertical = tag.getFloat("KnockbackV");
        if (tag.hasKey("BFactor")) this.bounceFactor = tag.getFloat("BFactor");
        if (tag.hasKey("VanishCommand")) this.vanishCommand = tag.getString("VanishCommand");
        if (tag.hasKey("VDelay")) this.vanishDelay = tag.getInteger("VDelay");
        if (tag.hasKey("Penetration")) this.penetration = tag.getFloat("Penetration");
        if (tag.hasKey("IBlocks")) this.ignoreBlocks = tag.getBoolean("IBlocks");
        if (tag.hasKey("IEntities")) this.ignoreEntities = tag.getBoolean("IEntities");

        /* Transforms */
        if (tag.hasKey("Gun")) this.gunTransform.fromNBT(tag.getCompoundTag("Gun"));
        if (tag.hasKey("GunFirstPerson")) this.gunTransformFirstPerson.fromNBT(tag.getCompoundTag("GunFirstPerson"));
        if (tag.hasKey("Transform")) this.projectileTransform.fromNBT(tag.getCompoundTag("Transform"));

        if (FMLCommonHandler.instance().getSide() == Side.CLIENT)
        {
            if (this.state == ItemGun.GunState.RELOADING)
            {
                /*
                 * Minecraft has been replacing the client's itemstack, so reloadMorph is never updated, 
                 * and I think BBGun needs a big rewrite to counter Minecraft's own mechanism
                 */
                this.current.set(MorphUtils.copy(this.reloadMorph));
            }
            else
            {
                this.current.set(MorphUtils.copy(this.defaultMorph));
            }

            this.currentHands.set(MorphUtils.copy(this.handsMorph));
            this.currentZoomOverlay.set(MorphUtils.copy(this.zoomOverlayMorph));
            this.currentInventory.set(MorphUtils.copy(this.inventoryMorph));
            this.currentCrosshair.set(MorphUtils.copy(this.crosshairMorph));
        }
    }

    private AbstractMorph create(NBTTagCompound tag, String key)
    {
        if (tag.hasKey(key, NBT.TAG_COMPOUND))
        {
            return MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag(key));
        }

        return null;
    }

    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();

        /* Gun properties */
        if (this.defaultMorph != null) tag.setTag("Morph", this.to(this.defaultMorph));
        if (this.firingMorph != null) tag.setTag("Fire", this.to(this.firingMorph));
        if (!this.fireCommand.isEmpty()) tag.setString("FireCommand", this.fireCommand);
        if (this.delay != 0) tag.setInteger("Delay", this.delay);
        if (this.projectiles != 1) tag.setInteger("Projectiles", this.projectiles);
        if (this.scatterX != 0F || this.scatterY != 0F)
        {
            NBTTagList scatter = new NBTTagList();

            scatter.appendTag(new NBTTagFloat(this.scatterX));
            scatter.appendTag(new NBTTagFloat(this.scatterY));

            tag.setTag("Scatter", scatter);
        }
        if (this.launch) tag.setBoolean("Launch", this.launch);
        if (this.useTarget) tag.setBoolean("Target", this.useTarget);
        if (!this.ammoStack.isEmpty()) tag.setTag("AmmoStack", this.ammoStack.writeToNBT(new NBTTagCompound()));

        /* Evanechecssss' options */
        if (!this.staticRecoil) tag.setBoolean("StaticRecoil", this.staticRecoil);
        if (this.recoilXMin != 0) tag.setFloat("RecoilMinX", this.recoilXMin);
        if (this.recoilXMax != 0) tag.setFloat("RecoilMaxX", this.recoilXMax);
        if (this.recoilYMin != 0) tag.setFloat("RecoilMinY", this.recoilYMin);
        if (this.recoilYMax != 0) tag.setFloat("RecoilMaxY", this.recoilYMax);

        if (this.enableArmsShootingPose) tag.setBoolean("ArmPose", this.enableArmsShootingPose);
        if (this.alwaysArmsShootingPose) tag.setBoolean("ArmPoseAlways", this.alwaysArmsShootingPose);

        if (this.shootingOffsetX != 0) tag.setFloat("ShootingOffsetX", this.shootingOffsetX);
        if (this.shootingOffsetY != 0) tag.setFloat("ShootingOffsetY", this.shootingOffsetY);
        if (this.shootingOffsetZ != 0) tag.setFloat("ShootingOffsetZ", this.shootingOffsetZ);

        if (this.inventoryMorph != null) tag.setTag("InventoryMorph", this.to(this.inventoryMorph));
        if (this.crosshairMorph != null) tag.setTag("CrosshairMorph", this.to(this.crosshairMorph));
        if (this.handsMorph != null) tag.setTag("HandsMorph", this.to(this.handsMorph));
        if (this.reloadMorph != null) tag.setTag("ReloadMorph", this.to(this.reloadMorph));
        if (this.zoomOverlayMorph != null) tag.setTag("ZoomOverlayMorph", this.to(this.zoomOverlayMorph));

        if (this.hideCrosshairOnZoom) tag.setBoolean("HideCrosshairOnZoom", this.hideCrosshairOnZoom);
        if (this.useInventoryMorph) tag.setBoolean("UseInventoryMorph", this.useInventoryMorph);
        if (this.hideHandsOnZoom) tag.setBoolean("HideHandsOnZoom", this.hideHandsOnZoom);
        if (this.useZoomOverlayMorph) tag.setBoolean("UseZoomOverlayMorph", this.useZoomOverlayMorph);

        if (this.zoomFactor != 0) tag.setFloat("Zoom", this.zoomFactor);
        if (this.ammo != 1) tag.setInteger("Ammo", this.ammo);
        if (this.useReloading) tag.setBoolean("UseReloading", this.useReloading);
        if (this.reloadingTime != 0) tag.setLong("ReloadingTime", this.reloadingTime);
        if (this.shotDelay != 0) tag.setLong("ShotDelay", this.shotDelay);
        if (!this.shootWhenHeld) tag.setBoolean("ShootWhenHeld", this.shootWhenHeld);

        if (!this.destroyCommand.isEmpty()) tag.setString("DestroyCommand", this.destroyCommand);
        if (!this.meleeCommand.isEmpty()) tag.setString("MeleeCommand", this.meleeCommand);
        if (!this.reloadCommand.isEmpty()) tag.setString("ReloadCommand", this.reloadCommand);
        if (!this.zoomOnCommand.isEmpty()) tag.setString("ZoomOnCommand", this.zoomOnCommand);
        if (!this.zoomOffCommand.isEmpty()) tag.setString("ZoomOffCommand", this.zoomOffCommand);

        if (this.meleeDamage != 0) tag.setFloat("MeleeDamage", this.meleeDamage);
        if (this.mouseZoom != 0.5F) tag.setFloat("MouseZoom", this.mouseZoom);
        if (this.durability != 0) tag.setInteger("Durability", this.durability);
        if (this.preventLeftClick) tag.setBoolean("PreventLeftClick", this.preventLeftClick);
        if (this.preventRightClick) tag.setBoolean("PreventRightClick", this.preventRightClick);
        if (this.preventEntityAttack) tag.setBoolean("PreventEntityAttack", this.preventEntityAttack);

        if (this.storedAmmo != 1) tag.setInteger("StoredAmmo", this.storedAmmo);
        if (this.storedReloadingTime != 0) tag.setLong("StoredReloadingTime", this.storedReloadingTime);
        if (this.storedShotDelay != 0) tag.setLong("StoredShotDelay", this.storedShotDelay);
        if (this.storedDurability != 0) tag.setInteger("StoredDurability", this.storedDurability);
        if (this.state != ItemGun.GunState.READY_TO_SHOOT) tag.setInteger("State", this.state.ordinal());

        /* Projectile properties */
        if (this.projectileMorph != null) tag.setTag("Projectile", this.to(this.projectileMorph));
        if (!this.tickCommand.isEmpty()) tag.setString("TickCommand", this.tickCommand);
        if (this.ticking != 0) tag.setInteger("Ticking", this.ticking);
        if (this.lifeSpan != 200) tag.setInteger("LifeSpan", this.lifeSpan);
        if (!this.yaw) tag.setBoolean("Yaw", this.yaw);
        if (!this.pitch) tag.setBoolean("Pitch", this.pitch);
        if (this.sequencer) tag.setBoolean("Sequencer", this.sequencer);
        if (this.random) tag.setBoolean("Random", this.random);
        if (this.hitboxX != 0.25F) tag.setFloat("HX", this.hitboxX);
        if (this.hitboxY != 0.25F) tag.setFloat("HY", this.hitboxY);
        if (this.speed != 1.0F) tag.setFloat("Speed", this.speed);
        if (this.friction != 0.99F) tag.setFloat("Friction", this.friction);
        if (this.gravity != 0.03F) tag.setFloat("Gravity", this.gravity);
        if (this.fadeIn != 10) tag.setInteger("FadeIn", this.fadeIn);
        if (this.fadeOut != 10) tag.setInteger("FadeOut", this.fadeOut);

        /* Impact properties */
        if (this.impactMorph != null) tag.setTag("Impact", this.to(this.impactMorph));
        if (!this.impactCommand.isEmpty()) tag.setString("ImpactCommand", this.impactCommand);
        if (!this.impactEntityCommand.isEmpty()) tag.setString("ImpactEntityCommand", this.impactEntityCommand);
        if (this.impactDelay != 0) tag.setInteger("ImpactDelay", this.impactDelay);
        if (!this.vanish) tag.setBoolean("Vanish", this.vanish);
        if (this.bounce) tag.setBoolean("Bounce", this.bounce);
        if (this.sticks) tag.setBoolean("Stick", this.sticks);
        if (this.hits != 1) tag.setInteger("Hits", this.hits);
        if (this.damage != 0) tag.setFloat("Damage", this.damage);
        if (this.knockbackHorizontal != 0F) tag.setFloat("KnockbackH", this.knockbackHorizontal);
        if (this.knockbackVertical != 0F) tag.setFloat("KnockbackV", this.knockbackVertical);
        if (this.bounceFactor != 1F) tag.setFloat("BFactor", this.bounceFactor);
        if (!this.vanishCommand.isEmpty()) tag.setString("VanishCommand", this.vanishCommand);
        if (this.vanishDelay != 0) tag.setInteger("VDelay", this.vanishDelay);
        if (this.penetration != 0) tag.setFloat("Penetration", this.penetration);
        if (this.ignoreBlocks) tag.setBoolean("IBlocks", this.ignoreBlocks);
        if (this.ignoreEntities) tag.setBoolean("IEntities", this.ignoreEntities);

        /* Transforms */
        if (!this.gunTransform.isDefault()) tag.setTag("Gun", this.gunTransform.toNBT());
        if (!this.gunTransformFirstPerson.isDefault()) tag.setTag("GunFirstPerson", this.gunTransformFirstPerson.toNBT());
        if (!this.projectileTransform.isDefault()) tag.setTag("Transform", this.projectileTransform.toNBT());

        return tag;
    }

    private NBTTagCompound to(AbstractMorph morph)
    {
        NBTTagCompound tag = new NBTTagCompound();
        morph.toNBT(tag);

        return tag;
    }
}

==================================================

--- Файл №288 ---
Путь: main\java\mchorse\blockbuster\common\OrientedBB.java
--------------------
package mchorse.blockbuster.common;

import javax.vecmath.Matrix4f;

import java.util.ArrayList;
import java.util.List;

import javax.annotation.Nullable;
import javax.vecmath.Matrix3d;
import javax.vecmath.Vector3d;

import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL20;

import mchorse.blockbuster.client.RenderingHandler;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.Entity;
import net.minecraftforge.client.event.RenderWorldLastEvent;

/**
 * This is an implentation of an oriented bounding box.
 * 
 * The implementation is specifically designed for the Minecraft Blockbuster
 * mod, created by McHorse. Special attributes or functions that are used for
 * the Blockbuster mod are for example: initial rotation (which can be
 * changed in the GUI of the model editor), limb and anchor offsets. 
 * Limb offset defines the offset from a selected object part. 
 * The anchor offset is used for the initial rotation, to rotate around a certain point.
 * <p>
 * How it works (currently): Inside the render() method of ModelCustomRenderer
 * the modelview of the limb is computated and calculates the relative offset to
 * the main morph center. This data is passed to the offset attribute in OBB. In
 * the applyRotations() method of RenderCustomModel the center of the entity is
 * calculated which gets passed to the center variable here in the OBB. Then the
 * method buildCorners() is being called, which uses offset and center to
 * calculate the real centerpoint of this OBB.
 * 
 * buildCorners() is the most important method, as it computes all the corners
 * according to the offsets, rotations and other transformations. This should be
 * called at least once somewhere before the collision is tested.
 * <p>
 * The learning sources that were used for the general concept 
 * of an OBB implementation:
 * 
 *      http://www.cie.bgu.tum.de/publications/bachelorthesis/2014_Engeser.pdf
 *      https://www.sciencedirect.com/topics/computer-science/oriented-bounding-box
 * <p>
 * @author Christian F. (known as Chryfi)
 * @see https://github.com/Chryfi
 * @see https://www.youtube.com/Chryfi
 * @see https://twitter.com/Chryfi
 */
public class OrientedBB
{
    /** local basis vector x */
    private Vector3d w = new Vector3d(1, 0, 0);
    /** local basis vector y */
    private Vector3d u = new Vector3d(0, 1, 0);
    /** local basis vector z */
    private Vector3d v = new Vector3d(0, 0, 1);

    /** global anchor point - mostly for rendering anchorpoints */
    private Vector3d anchorPoint = new Vector3d();
    
    public static Matrix4f modelView = new Matrix4f();

    /** scale factor determined by modelView and other scaling factors */
    public Matrix3d scale = new Matrix3d();
    
    public Matrix3d rotation = new Matrix3d();

    /** initial rotation defined at the beginning of model creation */
    public double[] rotation0 = { 0, 0, 0 };

    /** global center point (not the anchor) */
    public Vector3d center = new Vector3d();

    /** half-width */
    public double hw;
    /** half-height */
    public double hu;
    /** half-depth */
    public double hv;

    /** corners - starting from maxXYZ (1,1,1) going clockwise same thing for bottom - starting at maxXminYmaxZ */
    public Corner[] corners = new Corner[8];

    /** offset from limb (calculated through modelview) */
    public Vector3d limbOffset = new Vector3d();

    /** anchor of the obb - for initial rotation */
    public Vector3d anchorOffset = new Vector3d();

    /** offset from main entity */
    public Vector3d offset = new Vector3d();

    public OrientedBB(@Nullable Vector3d center, @Nullable double[] rotation0, float width, float height, float depth)
    {
        if (center == null)
        {
            center = new Vector3d();
        }
        
        if (rotation0 == null)
        {
            rotation0 = new double[3];
        }
        
        setup(rotation0, width, height, depth);
        this.center.set(center);
    }

    public OrientedBB()
    {
        double[] rotation0 = new double[3];

        rotation.setIdentity();
        setup(rotation0, 0, 0, 0);
        buildCorners();
    }

    public void setup(double[] rotation0, float width, float height, float depth)
    {
        this.center = new Vector3d();
        this.hw = Math.abs(width) / 2;
        this.hu = Math.abs(height) / 2;
        this.hv = Math.abs(depth) / 2;
        this.rotation0 = rotation0;
        
        RenderingHandler.obbsToRender.add(this);
        this.rotation.setIdentity();
        this.scale.setIdentity();
    }

    public void render(RenderWorldLastEvent event)
    {
        int shader = GL11.glGetInteger(GL20.GL_CURRENT_PROGRAM);

        if (shader != 0)
        {
            OpenGlHelper.glUseProgram(0);
        }

        Color color = ColorUtils.COLOR;
        Entity player = Minecraft.getMinecraft().getRenderViewEntity();

        double playerX = player.prevPosX + (player.posX - player.prevPosX) * event.getPartialTicks();
        double playerY = player.prevPosY + (player.posY - player.prevPosY) * event.getPartialTicks();
        double playerZ = player.prevPosZ + (player.posZ - player.prevPosZ) * event.getPartialTicks();

        GlStateManager.glLineWidth(3F);
        GlStateManager.disableLighting();
        GlStateManager.disableTexture2D();
        
        color.set(1F, 1F, 1F, 1F);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder builder = tessellator.getBuffer();

        builder.setTranslation(-playerX, -playerY, -playerZ);
        builder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

        Corner[] startCorners = { this.corners[0], this.corners[2], this.corners[5], this.corners[7] };
        
        for (Corner start : startCorners)
        {
            for (Corner end : start.connections)
            {
                builder.pos(start.position.x, start.position.y, start.position.z).color(color.r, color.g, color.b, color.a).endVertex();
                builder.pos(end.position.x, end.position.y, end.position.z).color(color.r, color.g, color.b, color.a).endVertex();
            }
        }
        
        builder.setTranslation(0, 0, 0);
        tessellator.draw();
        
        renderAxes(new double[]{-playerX, -playerY, -playerZ}, color, this.anchorPoint, 4, true, false);
        
        GlStateManager.enableTexture2D();
        GlStateManager.enableLighting();
        GlStateManager.glLineWidth(1F);

        if (shader != 0)
        {
            OpenGlHelper.glUseProgram(shader);
        }
    }

    /**
     * This method renders 3 axes. If wanted, it can rotate according to the rotation matrices in the OBB.
     * 
     * @param translation for OpenGL translation (usually player position)
     * @param color the color of the axes
     * @param center0 the center of the plain Axis
     * @param length  the half-length of the axis measured in Minecraft pixels
     * @param rotate  if true the plain axis will be rotated by rotation0 and rotation
     * @param depth control GlStateManager depth
     */
    public void renderAxes(double[] translation, Color color, Vector3d center0, double length, boolean rotate, boolean depth)
    {
        GlStateManager.glLineWidth(2F);
        GlStateManager.disableLighting();
        GlStateManager.disableTexture2D();
        
        if(!depth)
        {
            GlStateManager.disableDepth();
        }

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder builder = tessellator.getBuffer();

        builder.setTranslation(translation[0], translation[1], translation[2]);
        builder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

        Matrix3d rotation0 = anglesToMatrix(this.rotation0[0], this.rotation0[1], this.rotation0[2]);
        length /= 32; // 1 <=> 1 pixel => divide by 16 and by 2 as it's half length
        Vector3d axisX1 = new Vector3d(length, 0, 0);
        Vector3d axisX2 = new Vector3d(0, length, 0);
        Vector3d axisX3 = new Vector3d(0, 0, length);
        
        if (rotate)
        {
            this.rotation.transform(axisX1);
            rotation0.transform(axisX1);
            
            this.rotation.transform(axisX2);
            rotation0.transform(axisX2);
            
            this.rotation.transform(axisX3);
            rotation0.transform(axisX3);
        }
        
        builder.pos(center0.x + axisX1.x, center0.y + axisX1.y, center0.z + axisX1.z).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(center0.x - axisX1.x, center0.y - axisX1.y, center0.z - axisX1.z).color(color.r, color.g, color.b, color.a).endVertex();

        builder.pos(center0.x + axisX2.x, center0.y + axisX2.y, center0.z + axisX2.z).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(center0.x - axisX2.x, center0.y - axisX2.y, center0.z - axisX2.z).color(color.r, color.g, color.b, color.a).endVertex();

        builder.pos(center0.x + axisX3.x, center0.y + axisX3.y, center0.z + axisX3.z).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(center0.x - axisX3.x, center0.y - axisX3.y, center0.z - axisX3.z).color(color.r, color.g, color.b, color.a).endVertex();
        
        builder.setTranslation(0, 0, 0);
        tessellator.draw();
        
        if(!depth)
        {
            GlStateManager.enableDepth();
        }
    }

    /**
     * This method calculates all the corners of the OBB according to rotation,
     * anchor and other transformation. The corners are saved inside the attribute
     * corners.
     */
    public void buildCorners()
    {
        if (!RenderingHandler.obbsToRender.contains(this))
        {
            RenderingHandler.obbsToRender.add(this);
        }

        Vector3d width = new Vector3d(this.w);
        Vector3d height = new Vector3d(this.u);
        Vector3d depth = new Vector3d(this.v);
        Matrix3d rotation0 = anglesToMatrix(this.rotation0[0], this.rotation0[1], this.rotation0[2]);
        
        width.scale(this.hw);
        height.scale(this.hu);
        depth.scale(this.hv);
        
        Vector3d limbOffset0 = new Vector3d(this.limbOffset);

        Vector3d anchorOffset0 = new Vector3d(this.anchorOffset);

        Vector3d offset0 = new Vector3d(this.offset);

        Matrix3d rotscale = new Matrix3d(this.scale);
        
        rotscale.mul(this.rotation);
        rotscale.mul(rotation0);
        
        this.rotation.transform(limbOffset0);
        this.scale.transform(limbOffset0);
        
        rotscale.transform(anchorOffset0); // not entirely sure if that is correct - testing later in gui
        rotscale.transform(width);
        rotscale.transform(height);
        rotscale.transform(depth);

        Vector3d center = new Vector3d(this.center);
        
        center.add(offset0);
        this.anchorPoint.set(center);
        center.add(anchorOffset0);
        center.add(limbOffset0);
        
        
        /* calculate the corners */
        Vector3d pos = new Vector3d(center);
        pos.add(width);
        pos.add(height);
        pos.add(depth);
        
        Corner maxXYZ = new Corner(pos);
        this.corners[0] = maxXYZ;

        pos.set(center);
        pos.sub(width);
        pos.add(height);
        pos.add(depth);
        
        Corner minXmaxYZ = new Corner(pos);
        this.corners[1] = minXmaxYZ;

        pos.set(center);
        pos.sub(width);
        pos.add(height);
        pos.sub(depth);
        
        Corner minXmaxYminZ = new Corner(pos);
        this.corners[2] = minXmaxYminZ;

        pos.set(center);
        pos.add(width);
        pos.add(height);
        pos.sub(depth);
        
        Corner maxXYminZ = new Corner(pos);
        this.corners[3] = maxXYminZ;

        pos.set(center);
        pos.add(width);
        pos.sub(height);
        pos.add(depth);
        
        Corner maxXminYmaxZ = new Corner(pos);
        this.corners[4] = maxXminYmaxZ;

        pos.set(center);
        pos.sub(width);
        pos.sub(height);
        pos.add(depth);
        
        Corner minXYmaxZ = new Corner(pos);
        this.corners[5] = minXYmaxZ;

        pos.set(center);
        pos.sub(width);
        pos.sub(height);
        pos.sub(depth);
        
        Corner minXYZ = new Corner(pos);
        this.corners[6] = minXYZ;

        pos.set(center);
        pos.add(width);
        pos.sub(height);
        pos.sub(depth);
        
        Corner maxXminYZ = new Corner(pos);
        this.corners[7] = maxXminYZ;

        /* connect the corners */
        maxXYZ.connect(maxXYminZ);
        maxXYZ.connect(minXmaxYZ);
        maxXYZ.connect(maxXminYmaxZ);

        minXmaxYminZ.connect(maxXYminZ);
        minXmaxYminZ.connect(minXYZ);
        minXmaxYminZ.connect(minXmaxYZ);

        minXYmaxZ.connect(maxXminYmaxZ);
        minXYmaxZ.connect(minXYZ);
        minXYmaxZ.connect(minXmaxYZ);

        maxXminYZ.connect(maxXYminZ);
        maxXminYZ.connect(minXYZ);
        maxXminYZ.connect(maxXminYmaxZ);
    }

    /**
     * This method converts the given angles into one single 3x3 rotation matrix.
     * The rotation mode is XYZ
     * 
     * @param angleX rotation around X
     * @param angleY rotation around Y (Minecraft height axis)
     * @param angleZ rotation around Z
     * @return the complete rotation Matrix3d
     */
    public static Matrix3d anglesToMatrix(double angleX, double angleY, double angleZ)
    {
        double radX = Math.toRadians(angleX);
        double radY = Math.toRadians(angleY);
        double radZ = Math.toRadians(angleZ);
        Matrix3d rotation = new Matrix3d();
        Matrix3d rot = new Matrix3d();

        rotation.setIdentity();
        rot.rotX(radX);
        rotation.mul(rot);
        rot.rotY(radY);
        rotation.mul(rot);
        rot.rotZ(radZ);
        rotation.mul(rot);
        
        return rotation;
    }
    
    public OrientedBB clone()
    {
        OrientedBB d = new OrientedBB();
        d.hu = this.hu;
        d.hw = this.hw;
        d.hv = this.hv;
        d.anchorOffset.set(this.anchorOffset);
        d.offset.set(this.offset);
        d.center.set(this.center);
        d.limbOffset.set(this.limbOffset);
        d.rotation.set(this.rotation);
        d.rotation0 = this.rotation0;
        d.scale.set(this.scale);
        return d;
    }

    @Override
    public String toString()
    {
        return "OBB - center: " + this.center;
    }

    private class Corner
    {
        /** global position (could it be also local???) */
        public Vector3d position;

        /**
         * List of corners that should be connected with this corner. 
         * Corners inside this list should also have a connection to this corner
         */
        private List<Corner> connections;

        public Corner(Vector3d pos)
        {
            this.position = new Vector3d(pos);
            this.connections = new ArrayList<>();
        }

        /**
         * This method connects the given corner with this corner. 
         * It adds given corner to this connection list and this corner to given corner's connection list.
         * 
         * @param corner
         * @return true if connection was established. False means that no connection was made as both lists contain already the corners
         */
        public boolean connect(Corner corner)
        {
            if (!corner.connections.contains(this) && !this.connections.contains(corner))
            {
                corner.connections.add(this);
                this.connections.add(corner);
                
                return true;
            } 
            else if (!corner.connections.contains(this))
            {
                corner.connections.add(this);
                
                return true;
            } 
            else if (!this.connections.contains(corner))
            {
                this.connections.add(corner);
                
                return true;
            }
            
            return false;
        }

        /**
         * This method removes the given corner and this corner from both connection lists.
         * 
         * @param corner
         * @return false if both connection lists don't have the corners.
         */
        public boolean disconnect(Corner corner)
        {
            if (corner.connections.contains(this) && this.connections.contains(corner))
            {
                corner.connections.remove(this);
                this.connections.remove(corner);
                
                return true;
            } 
            else if (corner.connections.contains(this))
            {
                corner.connections.remove(this);
                
                return true;
            } 
            else if (this.connections.contains(corner))
            {
                this.connections.remove(corner);
                
                return true;
            }
            
            return false;
        }
    }
}


==================================================

--- Файл №289 ---
Путь: main\java\mchorse\blockbuster\common\block\BlockDimGreen.java
--------------------
package mchorse.blockbuster.common.block;

import net.minecraft.block.BlockSlab;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.item.ItemStack;
import net.minecraft.util.IStringSerializable;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

public class BlockDimGreen extends BlockGreen
{
    public BlockDimGreen()
    {
        super();
        this.setLightLevel(0.0F);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World player, List<String> tooltip, ITooltipFlag advanced)
    {
        super.addInformation(stack, player, tooltip, advanced);
        tooltip.add(I18n.format("blockbuster.info.dim_green_block"));
    }

    @Override
    @SideOnly(Side.CLIENT)
    public float getAmbientOcclusionLightValue(IBlockState state)
    {
        return 1;
    }

    @SideOnly(Side.CLIENT)
    @Override
    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos)
    {
        int i = source.getCombinedLight(pos, state.getLightValue(source, pos));

        if (i == 0 && state.getBlock() instanceof BlockSlab)
        {
            pos = pos.down();
            state = source.getBlockState(pos);
            return source.getCombinedLight(pos, state.getLightValue(source, pos));
        }
        else
        {
            return i;
        }
    }
}

==================================================

--- Файл №290 ---
Путь: main\java\mchorse\blockbuster\common\block\BlockDirector.java
--------------------
package mchorse.blockbuster.common.block;

import java.lang.reflect.Field;
import java.util.List;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.common.GuiHandler;
import mchorse.blockbuster.common.item.ItemPlayback;
import mchorse.blockbuster.common.item.ItemRegister;
import mchorse.blockbuster.common.tileentity.TileEntityDirector;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.block.Block;
import net.minecraft.block.ITileEntityProvider;
import net.minecraft.block.material.Material;
import net.minecraft.block.properties.IProperty;
import net.minecraft.block.properties.PropertyBool;
import net.minecraft.block.state.BlockStateContainer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumBlockRenderType;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.util.text.TextFormatting;
import net.minecraft.util.text.event.ClickEvent;
import net.minecraft.util.text.event.HoverEvent;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Director block
 *
 * This block is the one that responsible for machinimas creation.
 */
public class BlockDirector extends Block implements ITileEntityProvider
{
    /**
     * The playing state property of director block 
     */
    public static final PropertyBool PLAYING = PropertyBool.create("playing");

    /**
     * The hidden state property of director block 
     */
    public static final PropertyBool HIDDEN = PropertyBool.create("hidden");

    public BlockDirector()
    {
        super(Material.ROCK);
        this.setDefaultState(this.getDefaultState().withProperty(PLAYING, false).withProperty(HIDDEN, false));
        this.setCreativeTab(Blockbuster.blockbusterTab);
        this.setBlockUnbreakable();
        this.setResistance(6000000.0F);
        this.setRegistryName("director");
        this.setUnlocalizedName("blockbuster.director");
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World player, List<String> tooltip, ITooltipFlag advanced)
    {
        tooltip.add(I18n.format("blockbuster.info.director_block"));
    }

    @Override
    public boolean canHarvestBlock(IBlockAccess world, BlockPos pos, EntityPlayer player)
    {
        return true;
    }

    @Override
    public boolean isOpaqueCube(IBlockState state)
    {
        return !state.getValue(HIDDEN);
    }

    @Override
    public boolean isFullCube(IBlockState state)
    {
        return !state.getValue(HIDDEN);
    }

    @Override
    public EnumBlockRenderType getRenderType(IBlockState state)
    {
        return state.getValue(HIDDEN) ? EnumBlockRenderType.ENTITYBLOCK_ANIMATED : super.getRenderType(state);
    }

    @Override
    public AxisAlignedBB getCollisionBoundingBox(IBlockState state, IBlockAccess worldIn, BlockPos pos)
    {
        return state.getValue(HIDDEN) ? null : super.getCollisionBoundingBox(state, worldIn, pos);
    }

    /* States */

    @Override
    public int getMetaFromState(IBlockState state)
    {
        int meta = state.getValue(PLAYING) ? 0 : 1;
        meta |= state.getValue(HIDDEN) ? 0b10 : 0;

        return meta;
    }

    @Override
    public IBlockState getStateFromMeta(int meta)
    {
        return this.getDefaultState().withProperty(PLAYING, (meta & 0b1) == 0b1).withProperty(HIDDEN, (meta & 0b10) == 0b10);
    }

    @Override
    protected BlockStateContainer createBlockState()
    {
        return new BlockStateContainer(this, PLAYING, HIDDEN);
    }

    /* Redstone */

    @Override
    public boolean canProvidePower(IBlockState state)
    {
        return true;
    }

    /**
     * Power west side of the block while block is playing and power east side
     * of the block while isn't playback actors.
     */
    @Override
    public int getWeakPower(IBlockState blockState, IBlockAccess blockAccess, BlockPos pos, EnumFacing side)
    {
        boolean isPlaying = blockState.getValue(PLAYING);

        return (isPlaying && side == EnumFacing.WEST) || (!isPlaying && side == EnumFacing.EAST) ? 15 : 0;
    }

    /* Player interaction */

    @Override
    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
    {
        if (!worldIn.isRemote)
        {
            EntityUtils.sendStatusMessage((EntityPlayerMP) playerIn, new TextComponentTranslation("blockbuster.bye_director_block"));

            ITextComponent link = new TextComponentTranslation("blockbuster.bye_director_block_guide");
            ITextComponent youtube = new TextComponentTranslation("blockbuster.bye_director_block_guide_watch");
            String url = getUrl(playerIn);

            youtube.getStyle().setClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, url));
            youtube.getStyle().setHoverEvent(new HoverEvent(HoverEvent.Action.SHOW_TEXT, new TextComponentString(url)));
            youtube.getStyle().setColor(TextFormatting.GRAY).setUnderlined(true);

            playerIn.sendMessage(link.appendSibling(youtube).appendSibling(new TextComponentString(".")));
        }

        return true;
    }

    /**
     * Get video URL based on language, for Chinese users it uses Bilibili video link
     */
    private String getUrl(EntityPlayer playerIn)
    {
        Field field = null;

        for (Field member : EntityPlayerMP.class.getDeclaredFields())
        {
            if (member.getType() == String.class)
            {
                field = member;

                break;
            }
        }

        if (field != null)
        {
            try
            {
                field.setAccessible(true);

                String language = (String) field.get(playerIn);

                if (language.startsWith("zh_"))
                {
                    return "https://bilibili.com/video/BV1SV41117Pm";
                }
            }
            catch (Exception e)
            {}
        }

        return "https://youtu.be/nMOb8RnuyuE";
    }

    @Override
    public TileEntity createNewTileEntity(World worldIn, int meta)
    {
        return new TileEntityDirector();
    }
}

==================================================

--- Файл №291 ---
Путь: main\java\mchorse\blockbuster\common\block\BlockGreen.java
--------------------
package mchorse.blockbuster.common.block;

import java.util.List;

import mchorse.blockbuster.Blockbuster;
import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.block.properties.IProperty;
import net.minecraft.block.properties.PropertyEnum;
import net.minecraft.block.state.BlockStateContainer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.creativetab.CreativeTabs;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.util.IStringSerializable;
import net.minecraft.util.NonNullList;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class BlockGreen extends Block
{
    public static final PropertyEnum<ChromaColor> COLOR = PropertyEnum.<ChromaColor>create("color", ChromaColor.class);

    public BlockGreen()
    {
        super(Material.CLAY);
        this.setCreativeTab(Blockbuster.blockbusterTab);
        this.setResistance(6000000.0F);
        this.setLightLevel(1.0F / 15.0F);

        this.setDefaultState(this.getDefaultState().withProperty(COLOR, ChromaColor.GREEN));
    }

    @Override
    public IBlockState getStateFromMeta(int meta)
    {
        ChromaColor[] values = ChromaColor.values();

        if (meta >= values.length || meta < 0)
        {
            return this.getDefaultState();
        }

        return this.getDefaultState().withProperty(COLOR, values[meta]);
    }

    @Override
    public int getMetaFromState(IBlockState state)
    {
        return state.getValue(COLOR).ordinal();
    }

    @Override
    protected BlockStateContainer createBlockState()
    {
        return new BlockStateContainer(this, new IProperty[] {COLOR});
    }

    @Override
    public ItemStack getPickBlock(IBlockState state, RayTraceResult target, World world, BlockPos pos, EntityPlayer player)
    {
        int meta = state.getValue(COLOR).ordinal();

        return new ItemStack(Item.getItemFromBlock(this), 1, meta);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void getSubBlocks(CreativeTabs itemIn, NonNullList<ItemStack> items)
    {
        for (ChromaColor color : ChromaColor.values())
        {
            items.add(new ItemStack(this, 1, color.ordinal()));
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World player, List<String> tooltip, ITooltipFlag advanced)
    {
        tooltip.add(I18n.format("blockbuster.info.green_block", I18n.format("blockbuster.chroma_blocks." + stack.getMetadata())));
    }

    @Override
    @SideOnly(Side.CLIENT)
    public float getAmbientOcclusionLightValue(IBlockState state)
    {
        return 1;
    }

    @SideOnly(Side.CLIENT)
    @Override
    public int getPackedLightmapCoords(IBlockState state, IBlockAccess source, BlockPos pos) {
        return 15728880; // 15 << 20 | 15 << 4
    }

    public static enum ChromaColor implements IStringSerializable
    {
        GREEN("green"), BLUE("blue"), RED("red"), YELLOW("yellow"), CYAN("cyan"), PURPLE("purple"), WHITE("white"), BLACK("black");

        public final String name;

        private ChromaColor(String name)
        {
            this.name = name;
        }

        @Override
        public String getName()
        {
            return this.name;
        }
    }
}

==================================================

--- Файл №292 ---
Путь: main\java\mchorse\blockbuster\common\block\BlockModel.java
--------------------
package mchorse.blockbuster.common.block;

import java.util.List;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.common.BlockbusterPermissions;
import mchorse.blockbuster.common.GuiHandler;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.recording.capturing.ActionHandler;
import mchorse.mclib.permissions.PermissionUtils;
import mchorse.mclib.utils.EntityUtils;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.block.Block;
import net.minecraft.block.ITileEntityProvider;
import net.minecraft.block.material.Material;
import net.minecraft.block.properties.PropertyInteger;
import net.minecraft.block.state.BlockFaceShape;
import net.minecraft.block.state.BlockStateContainer;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.particle.ParticleManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumBlockRenderType;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.NonNullList;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.world.IBlockAccess;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Block model
 * 
 * This block is responsible for providing a tile entity which is 
 * responsible for rendering a morph. 
 */
public class BlockModel extends Block implements ITileEntityProvider
{
    public static final PropertyInteger LIGHT = PropertyInteger.create("light",0,15);

    /**
     * Used to setup the yaw for the tile entity
     */
    private float lastYaw;

    public BlockModel()
    {
        super(Material.ROCK);
        this.setCreativeTab(Blockbuster.blockbusterTab);
        this.setResistance(6000000.0F);
        this.setRegistryName("model");
        this.setUnlocalizedName("blockbuster.model");

        this.setDefaultState(this.getDefaultState().withProperty(LIGHT, 0));
    }

    public static ItemStack getItemStack(int meta)
    {
        Item modelBlockItem = Blockbuster.modelBlockItems[0];

        if (meta >= 0 && meta <= 15)
        {
            modelBlockItem = Blockbuster.modelBlockItems[meta];
        }

        return new ItemStack(modelBlockItem, 1);
    }

    /**
     * Get the itemstack containing one item of this block according to the blockstate
     * @param state
     * @return itemstack with the metadata returned by {@link #damageDropped(IBlockState)}
     */
    public ItemStack getItemStack(IBlockState state)
    {
        int meta = this.damageDropped(state);

        return getItemStack(meta);
    }

    @Override
    public int getLightValue(IBlockState state, IBlockAccess world, BlockPos pos)
    {
        return state.getValue(LIGHT);
    }

    @Override
    public ItemStack getItem(World worldIn, BlockPos pos, IBlockState state)
    {
        ItemStack stack = this.getItemStack(state);
        TileEntityModel model = new TileEntityModel();

        model.getSettings().setLightValue(this.damageDropped(state));

        this.setTENBTtoStack(stack, model);

        return stack;
    }

    /**
     * Gets the metadata of the item this Block can drop.
     * This method is called when the block gets destroyed.
     * It returns the metadata of the dropped item based on the old metadata of the block.
     */
    @Override
    public int damageDropped(IBlockState state)
    {
        return this.getMetaFromState(state);
    }

    @Override
    protected BlockStateContainer createBlockState()
    {
        return new BlockStateContainer(this, LIGHT);
    }

    @Override
    public int getMetaFromState(IBlockState state)
    {
        return state.getValue(LIGHT);
    }

    @Override
    public IBlockState getStateFromMeta(int meta)
    {
        return this.getDefaultState().withProperty(LIGHT, meta);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World player, List<String> tooltip, ITooltipFlag advanced)
    {
        tooltip.add(I18n.format("blockbuster.info.model_block"));
    }

    @Override
    public void getDrops(NonNullList<ItemStack> drops, IBlockAccess world, BlockPos pos, IBlockState state, int fortune)
    {
        ItemStack stack = this.getItemStack(state);
        TileEntity te = ActionHandler.lastTE;

        if (te instanceof TileEntityModel)
        {
            TileEntityModel model = (TileEntityModel) te;

            this.setTENBTtoStack(stack, model);
        }

        drops.add(stack);
    }

    /**
     * Set the NBT tag of the provided TileEntityModel to the given stack.
     * @param stack
     * @param teModel
     * @return
     */
    public ItemStack setTENBTtoStack(ItemStack stack, TileEntityModel teModel)
    {
        NBTTagCompound tag = teModel.writeToNBT(new NBTTagCompound());
        NBTTagCompound block = new NBTTagCompound();

        tag.removeTag("x");
        tag.removeTag("y");
        tag.removeTag("z");

        block.setTag("BlockEntityTag", tag);

        if (!(tag.getSize() == 2 && tag.hasKey("id") && tag.hasKey("Morph") && tag.getTag("Morph").equals(TileEntityModel.getDefaultMorph().toNBT())))
        {
            stack.setTagCompound(block);
        }

        return stack;
    }

    @Override
    public boolean addDestroyEffects(World world, BlockPos pos, ParticleManager manager)
    {
        return true;
    }

    @Override
    public boolean canHarvestBlock(IBlockAccess world, BlockPos pos, EntityPlayer player)
    {
        return true;
    }

    @Override
    public boolean onBlockActivated(World worldIn, BlockPos pos, IBlockState state, EntityPlayer playerIn, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
    {
        if (worldIn.isRemote && !EntityUtils.isAdventureMode(playerIn))
        {
            PermissionUtils.hasPermission(playerIn, BlockbusterPermissions.editModelBlock, (bool) ->
            {
                if (bool)
                {
                    GuiHandler.open(playerIn, GuiHandler.MODEL_BLOCK, pos.getX(), pos.getY(), pos.getZ());
                }
            });
        }

        return true;
    }

    @Override
    public IBlockState getStateForPlacement(World world, BlockPos pos, EnumFacing facing, float hitX, float hitY, float hitZ, int meta, EntityLivingBase placer, EnumHand hand)
    {
        this.lastYaw = placer.isSneaking() ? MathHelper.wrapDegrees(180 - placer.rotationYaw) : 0;

        return super.getStateForPlacement(world, pos, facing, hitX, hitY, hitZ, meta, placer, hand);
    }

    @Override
    public void onBlockPlacedBy(World world, BlockPos pos, IBlockState state, EntityLivingBase placer, ItemStack stack)
    {
        if (world.isRemote && stack.hasTagCompound() && hasTileEntity(state) && stack.getTagCompound().hasKey("BlockEntityTag"))
        {
            TileEntity tileEntity = world.getTileEntity(pos);

            if (tileEntity != null)
            {
                tileEntity.handleUpdateTag(stack.getTagCompound().getCompoundTag("BlockEntityTag"));
            }
        }
    }

    @Override
    public TileEntity createNewTileEntity(World worldIn, int meta)
    {
        TileEntity entity = new TileEntityModel(this.lastYaw);

        this.lastYaw = 0;

        return entity;
    }

    /* Setting up visual properties and collision box */

    /**
     * Don't connect to fences 
     */
    @Override
    public BlockFaceShape getBlockFaceShape(IBlockAccess worldIn, IBlockState state, BlockPos pos, EnumFacing face)
    {
        return BlockFaceShape.UNDEFINED;
    }

    public boolean isOpaqueCube(IBlockState state)
    {
        return false;
    }

    public boolean isFullCube(IBlockState state)
    {
        return false;
    }

    @Override
    public boolean canSpawnInBlock()
    {
        return true;
    }

    public EnumBlockRenderType getRenderType(IBlockState state)
    {
        return EnumBlockRenderType.ENTITYBLOCK_ANIMATED;
    }

    @Override
    public AxisAlignedBB getCollisionBoundingBox(IBlockState blockState, IBlockAccess worldIn, BlockPos pos)
    {
        TileEntity te = worldIn.getTileEntity(pos);

        if (te instanceof TileEntityModel && ((TileEntityModel) te).getSettings().isBlockHitbox())
        {
            return super.getCollisionBoundingBox(blockState, worldIn, pos);
        }

        return null;
    }
}

==================================================

--- Файл №293 ---
Путь: main\java\mchorse\blockbuster\common\entity\EntityActor.java
--------------------
package mchorse.blockbuster.common.entity;

import com.google.common.collect.Queues;
import com.mojang.authlib.GameProfile;
import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.render.IRenderLast;
import mchorse.blockbuster.common.GuiHandler;
import mchorse.blockbuster.common.item.ItemActorConfig;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyActor;
import mchorse.blockbuster.network.common.recording.PacketRequestFrames;
import mchorse.blockbuster.network.common.recording.PacketSyncTick;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestAction;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.recording.data.Record.MorphType;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.mclib.utils.Interpolations;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityBodyHelper;
import net.minecraft.entity.EntityCreature;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.IEntityLivingData;
import net.minecraft.entity.MoverType;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.ContainerChest;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.inventory.IInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.DifficultyInstance;
import net.minecraft.world.IInteractionObject;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.registry.IEntityAdditionalSpawnData;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Objects;
import java.util.Queue;

import javax.annotation.Nullable;
import javax.vecmath.Vector3d;

/**
 * Actor entity class
 *
 * Actor entity class is responsible for recording player's actions and execute
 * them. I'm also thinking about giving them controllable AI settings so they
 * could be used without recording (like during the battles between two or more
 * actors).
 *
 * Also, it would be cool to add something like simple crowd control for bigger
 * scenes (like one from Van Helsing in beginning with big crowd with torches,
 * fire and stuff).
 */
public class EntityActor extends EntityCreature implements IEntityAdditionalSpawnData, IMorphProvider, IRenderLast
{
    /**
     * This field is needed to make actors invisible. This is helpful for
     * scenes with different characters, which isn't needed to be seen.
     */
    public boolean invisible = false;

    /**
     * Fake player used in some of methods like onBlockActivated to avoid
     * NullPointerException (and some math like the direction in which to open
     * the fence or something).
     */
    public EntityFakePlayer fakePlayer;

    /**
     * In Soviet Russia, playback plays you
     */
    public RecordPlayer playback;

    /**
     * Metamorph's morph for this actor
     */
    public Morph morph = new Morph();

    /* Elytra interpolated animated properties */
    public float rotateElytraX = 0.0F;
    public float rotateElytraY = 0.0F;
    public float rotateElytraZ = 0.0F;

    /**
     * Whether this actor is mounted (used for hacking riding pose for 
     * 3rd party sit-able mods, such as CFM or Quark) 
     */
    public boolean isMounted;

    /**
     * Whether this actor was attached to director block 
     */
    public boolean wasAttached;

    /**
     * Whether the control of playback should be manual 
     */
    public boolean manual = false;

    public int pauseOffset = -1;
    public AbstractMorph pausePreviousMorph;
    public int pausePreviousOffset = -1;
    public boolean forceMorph = false;

    public float prevRoll;
    public float roll;

    public boolean renderLast;

    public boolean enableBurning;
    
    public Queue<PacketModifyActor> modify = Queues.<PacketModifyActor>newArrayDeque();

    public EntityActor(World worldIn)
    {
        super(worldIn);

        this.fakePlayer = new EntityFakePlayer(worldIn, this, new GameProfile(null, "xXx_Fake_Player_420_xXx"));
        this.fakePlayer.capabilities.isCreativeMode = true;
    }

    @Override
    public AbstractMorph getMorph()
    {
        return this.morph.get();
    }

    @Override
    public Vector3d getRenderLastPos()
    {
        float partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();

        return new Vector3d(Interpolations.lerp(this.prevPosX, this.posX, partialTicks), Interpolations.lerp(this.prevPosY, this.posY, partialTicks), Interpolations.lerp(this.prevPosZ, this.posZ, partialTicks));
    }

    @Override
    public boolean isBurning()
    {
        return this.enableBurning && super.isBurning();
    }

    /**
     * Check whether this actor is playing
     */
    public boolean isPlaying()
    {
        return this.playback != null && this.playback.playing && !this.playback.isFinished();
    }

    /**
     * Returns the Y Offset of this entity.
     *
     * Taken from EntityPlayer.
     */
    @Override
    public double getYOffset()
    {
        return -0.35D;
    }

    /**
     * Can't despawn an actor
     */
    @Override
    protected boolean canDespawn()
    {
        return false;
    }

    /**
     * Yes, this boy can be ridden!
     */
    @Override
    protected boolean canBeRidden(Entity entityIn)
    {
        return true;
    }

    /**
     * No, this boy can't be steered!
     */
    @Override
    public boolean canBeSteered()
    {
        return false;
    }

    @Override
    public boolean canPassengerSteer()
    {
        return false;
    }

    /**
     * For vehicles, the first passenger is generally considered the controller and "drives" the vehicle. For example,
     * Pigs, Horses, and Boats are generally "steered" by the controlling passenger.
     */
    @Override
    @Nullable
    public Entity getControllingPassenger()
    {
        return this.getPassengers().isEmpty() ? null : (Entity) this.getPassengers().get(0);
    }

    /**
     * Give a morph to an actor
     */
    @Override
    public IEntityLivingData onInitialSpawn(DifficultyInstance difficulty, IEntityLivingData livingdata)
    {
        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Name", "blockbuster.steve");
        this.morph.fromNBT(tag);

        return super.onInitialSpawn(difficulty, livingdata);
    }

    /**
     * Apply first frame for new actor.
     */
    @Override
    public void onEntityUpdate()
    {
        boolean spawn = this.world.isRemote && this.ticksExisted < 2;
        Record record = this.playback == null ? null : this.playback.record;

        spawn &= record != null && record.getFrame(0) != null;

        if (spawn)
        {
            this.playback.applyFrame(this.playback.tick - 1, this, true);

            Frame frame = record.getFrameSafe(this.playback.tick - record.preDelay - 1);

            if (frame.hasBodyYaw)
            {
                this.renderYawOffset = frame.bodyYaw;
            }
        }

        super.onEntityUpdate();

        if (spawn && this.playback.playing)
        {
            playback.applyFrame(this.playback.tick, this, true);

            Frame frame = record.getFrameSafe(this.playback.tick - record.preDelay);

            if (frame.hasBodyYaw)
            {
                this.renderYawOffset = frame.bodyYaw;
            }
        }
    }

    /**
     * Adjust the movement, limb swinging, and process action stuff.
     *
     * See process actions method for more information.
     */
    @Override
    public void onLivingUpdate()
    {
        if (!this.world.isRemote && this.playback != null && this.playback.playing && !this.manual)
        {
            int tick = this.playback.tick;

            if (this.playback.isFinished() && !this.noClip)
            {
                this.playback.stopPlaying();
            }
            else if (tick != 0 && tick % Blockbuster.recordSyncRate.get() == 0)
            {
                Dispatcher.sendToTracked(this, new PacketSyncTick(this.getEntityId(), tick));
            }
        }

        if (this.noClip && !this.world.isRemote)
        {
            if (this.playback != null)
            {
                this.playback.next();
            }

            return;
        }

        this.pickUpNearByItems();

        if (this.playback != null)
        {
            if (this.manual)
            {
                this.playback.applyFrame(this.playback.tick, this, true);
                this.playback.applyAction(this.playback.tick, this, true);
                this.playback.tick++;
            }
            else
            {
                this.playback.next();
            }
        }

        if (this.world.isRemote && this.newPosRotationIncrements > 0)
        {
            double d0 = this.posX + (this.interpTargetX - this.posX) / this.newPosRotationIncrements;
            double d1 = this.posY + (this.interpTargetY - this.posY) / this.newPosRotationIncrements;
            double d2 = this.posZ + (this.interpTargetZ - this.posZ) / this.newPosRotationIncrements;

            this.newPosRotationIncrements--;
            this.setPosition(d0, d1, d2);
        }
        else if (!this.isServerWorld())
        {
            this.motionX *= 0.98D;
            this.motionY *= 0.98D;
            this.motionZ *= 0.98D;
        }

        if (Math.abs(this.motionX) < 0.005D) this.motionX = 0.0D;
        if (Math.abs(this.motionY) < 0.005D) this.motionY = 0.0D;
        if (Math.abs(this.motionZ) < 0.005D) this.motionZ = 0.0D;

        this.updateArmSwingProgress();

        /* Make foot steps sound more player-like */
        if (!this.world.isRemote && this.isPlaying() && this.playback.tick < this.playback.record.frames.size() - 1 && !this.isSneaking() && this.onGround)
        {
            Frame current = this.playback.record.frames.get(this.playback.tick);
            Frame next = this.playback.record.frames.get(this.playback.tick + 1);

            double dx = next.x - current.x;
            double dy = next.y - current.y;
            double dz = next.z - current.z;

            this.distanceWalkedModified = this.distanceWalkedModified + MathHelper.sqrt(dx * dx + dz * dz) * 0.32F;
            this.distanceWalkedOnStepModified = this.distanceWalkedOnStepModified + MathHelper.sqrt(dx * dx + dy * dy + dz * dz) * 0.32F;
        }

        if (this.playback != null)
        {
            double posX = this.posX;
            double posY = this.posY;
            double posZ = this.posZ;
            double prevPosX = this.prevPosX;
            double prevPosY = this.prevPosY;
            double prevPosZ = this.prevPosZ;

            /* Trigger pressure playback */
            this.travel(this.moveStrafing, this.moveVertical, this.moveForward);

            /* Restore the position from the playback which fixes weird sliding */
            this.posX = posX;
            this.posY = posY;
            this.posZ = posZ;
            this.prevPosX = prevPosX;
            this.prevPosY = prevPosY;
            this.prevPosZ = prevPosZ;
        }
        else
        {
            /* Trigger pressure playback */
            this.travel(this.moveStrafing, this.moveVertical, this.moveForward);
        }
    }

    /**
     * Update fall state.
     *
     * This override is responsible for applying fall damage on the actor.
     * {@link #move(MoverType, double, double, double)} seem to override onGround
     * property wrongly on the server.
     */
    @Override
    protected void updateFallState(double y, boolean onGroundIn, IBlockState state, BlockPos pos)
    {
        if (!this.world.isRemote && Blockbuster.actorFallDamage.get() && this.playback != null)
        {
            int tick = this.playback.getTick();

            /* Override onGround field */
            if (tick >= 1 && tick < this.playback.record.frames.size())
            {
                this.onGround = onGroundIn = this.playback.record.frames.get(tick - 1).onGround;
            }
        }

        super.updateFallState(y, onGroundIn, state, pos);
    }

    /**
     * Destroy near by items
     *
     * Taken from super implementation of onLivingUpdate. You can't use
     * super.onLivingUpdate() in onLivingUpdate(), because it will distort
     * actor's movement (make it more laggy)
     */
    private void pickUpNearByItems()
    {
        if (!this.world.isRemote && !this.dead)
        {
            for (EntityItem entityitem : this.world.getEntitiesWithinAABB(EntityItem.class, this.getEntityBoundingBox().expand(1.0D, 0.0D, 1.0D)))
            {
                if (!entityitem.isDead && entityitem.getItem() != null && !entityitem.cannotPickup())
                {
                    this.onItemPickup(entityitem, 1);
                    entityitem.setDead();
                }
            }
        }
    }

    /**
     * Roll back to {@link EntityLivingBase}'s updateDistance methods.
     *
     * Its implementation supports much superior renderYawOffset animation.
     * Well, at least that's what I think. I should check out
     * {@link EntityBodyHelper} before making final decision.
    */
    @Override
    protected float updateDistance(float renderYawOffset, float distance)
    {
        boolean shouldAutoAlign = true;

        if (Blockbuster.actorPlaybackBodyYaw.get() && this.playback != null && this.playback.record != null)
        {
            Frame previous = this.playback.record.getFrame(this.playback.getTick() - 1);
            Frame frame = this.playback.getCurrentFrame();

            if (frame != null && frame.hasBodyYaw)
            {
                this.renderYawOffset = frame.bodyYaw;
                this.prevRenderYawOffset = previous == null || !this.playback.playing ? frame.bodyYaw : previous.bodyYaw;

                shouldAutoAlign = false;
            }
        }

        if (shouldAutoAlign)
        {
            float tempRenderYawOffset = MathHelper.wrapDegrees(renderYawOffset - this.renderYawOffset);
            this.renderYawOffset += tempRenderYawOffset * 0.3F;
            tempRenderYawOffset = MathHelper.wrapDegrees(this.rotationYaw - this.renderYawOffset);
            boolean isBackwards = tempRenderYawOffset < -90.0F || tempRenderYawOffset >= 90.0F;

            if (tempRenderYawOffset < -75.0F)
            {
                tempRenderYawOffset = -75.0F;
            }

            if (tempRenderYawOffset >= 75.0F)
            {
                tempRenderYawOffset = 75.0F;
            }

            this.renderYawOffset = this.rotationYaw - tempRenderYawOffset;

            if (tempRenderYawOffset * tempRenderYawOffset > 2500.0F)
            {
                this.renderYawOffset += tempRenderYawOffset * 0.2F;
            }

            if (isBackwards)
            {
                distance *= -1.0F;
            }
        }

        /* Explanation: Why do we update morph here? Because for some reason
         * the EntityMorph morphs don't turn smoothly in onLivingUpdate method */
        AbstractMorph morph = this.morph.get();

        if (morph != null)
        {
            morph.update(this);
        }

        while (!this.modify.isEmpty())
        {
            this.applyModifyPacket(this.modify.poll());
        }

        return distance;
    }

    /* Processing interaction with player */

    /**
     * Process interact
     *
     * Inject UUID of actor to registering device, open GUI for changing actor's
     * skin, or start recording him
     */
    @Override
    protected boolean processInteract(EntityPlayer player, EnumHand hand)
    {
        ItemStack item = player.getHeldItem(hand);
        boolean empty = item.isEmpty();

        if (empty)
        {
            if (!this.world.isRemote && !Blockbuster.actorDisableRiding.get())
            {
                if (!player.isSneaking())
                {
                    player.startRiding(this);
                }
            }

            return true;
        }
        else if (item.getItem() instanceof ItemActorConfig)
        {
            player.openGui(Blockbuster.instance, GuiHandler.ACTOR, player.world, this.getEntityId(), 0, 0);

            return true;
        }

        return false;
    }

    /* Public API */

    public void applyModifyPacket(PacketModifyActor message)
    {
        this.forceMorph = message.forceMorph;

        if (message.offset >= 0)
        {
            this.invisible = message.invisible;
            this.applyPause(message.morph, message.offset, message.previous, message.previousOffset, this.forceMorph);

            if (this.forceMorph)
            {
                this.pauseOffset = -1;
                this.pausePreviousMorph = null;
                this.pausePreviousOffset = -1;
                this.forceMorph = false;
            }
        }
        else
        {
            this.modify(message.morph, message.invisible, false);
        }
    }

    /**
     * Configure this actor
     *
     * Takes four properties to modify: filename used as id for recording,
     * displayed name, rendering skin and invulnerability flag
     */
    public void modify(AbstractMorph morph, boolean invisible, boolean notify)
    {
        if (this.forceMorph)
        {
            this.morph.setDirect(morph);
        }
        else
        {
            this.morph.set(morph);
        }

        this.invisible = invisible;

        if (!this.world.isRemote && notify)
        {
            this.notifyPlayers();
        }
    }

    /**
     * Morph this actor into given morph (used on the server side)
     */
    public void morph(AbstractMorph morph, boolean force)
    {
        this.pauseOffset = -1;
        this.pausePreviousMorph = null;
        this.pausePreviousOffset = -1;
        this.forceMorph = force;

        this.morph.set(morph);
    }

    /**
     * Stores the data for paused morph
     */
    public void morphPause(AbstractMorph morph, int offset, AbstractMorph previous, int previousOffset, boolean resume)
    {
        this.pauseOffset = offset;
        this.pausePreviousMorph = previous;
        this.pausePreviousOffset = previousOffset;
        this.forceMorph = resume;

        this.morph.setDirect(morph);
    }

    /**
     * Apply pause on the morph
     */
    public void applyPause(AbstractMorph morph, int offset, AbstractMorph previous, int previousOffset, boolean resume)
    {
        this.morphPause(morph, offset, previous, previousOffset, resume);

        MorphUtils.pause(previous, null, previousOffset);
        MorphUtils.pause(morph, previous, offset);
        
        if (resume)
        {
            MorphUtils.resume(morph);
        }
    }

    /**
     * Notify trackers of data changes happened in this actor
     */
    public void notifyPlayers()
    {
        if (!this.manual && this.playback != null)
        {
            this.playback.sendToTracked(new PacketModifyActor(this));
        }
    }

    /* Reading/writing to disk */

    @Override
    public void readEntityFromNBT(NBTTagCompound tag)
    {
        super.readEntityFromNBT(tag);

        this.morph.setDirect(MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag("Morph")));
        this.invisible = tag.getBoolean("Invisible");
        this.enableBurning = tag.getBoolean("EnableBurning");
        this.wasAttached = tag.getBoolean("WasAttached");

        if (!this.world.isRemote)
        {
            this.notifyPlayers();
        }
    }

    @Override
    public void writeEntityToNBT(NBTTagCompound tag)
    {
        super.writeEntityToNBT(tag);

        if (!this.morph.isEmpty())
        {
            tag.setTag("Morph", this.morph.get().toNBT());
        }

        tag.setBoolean("Invisible", this.invisible);
        tag.setBoolean("EnableBurning", this.enableBurning);
        tag.setBoolean("WasAttached", this.wasAttached);
    }

    /* IEntityAdditionalSpawnData implementation */

    @Override
    public void writeSpawnData(ByteBuf buffer)
    {
        if (this.wasAttached && this.playback == null)
        {
            this.setDead();
        }

        MorphUtils.morphToBuf(buffer, this.morph.get());

        buffer.writeBoolean(this.invisible);
        buffer.writeBoolean(this.enableBurning);
        buffer.writeBoolean(this.noClip);
        buffer.writeBoolean(this.playback != null);

        if (this.playback != null)
        {
            buffer.writeBoolean(this.playback.playing);
            buffer.writeInt(this.playback.tick);
            ByteBufUtils.writeUTF8String(buffer, this.playback.record.filename);

            buffer.writeBoolean(this.playback.getReplay() != null && this.playback.getReplay().morph != null);

            if (this.playback.getReplay() != null && this.playback.getReplay().morph != null)
            {
                MorphUtils.morphToBuf(buffer, this.playback.getReplay().morph);
            }
        }

        buffer.writeBoolean(this.isEntityInvulnerable(DamageSource.ANVIL));
        buffer.writeBoolean(this.renderLast);
    }

    @Override
    public void readSpawnData(ByteBuf buffer)
    {
        this.morph.setDirect(MorphUtils.morphFromBuf(buffer));
        this.invisible = buffer.readBoolean();
        this.enableBurning = buffer.readBoolean();
        this.noClip = buffer.readBoolean();

        if (buffer.readBoolean())
        {
            boolean playing = buffer.readBoolean();
            int tick = buffer.readInt();
            String filename = ByteBufUtils.readUTF8String(buffer);
            Replay replay = null;

            if (buffer.readBoolean())
            {
                replay = new Replay();
                replay.morph = MorphUtils.morphFromBuf(buffer);
            }

            if (this.playback == null)
            {
                Record record = ClientProxy.manager.getClient(filename);

                if (record != null)
                {
                    this.playback = new RecordPlayer(record, Mode.FRAMES, this);

                    record.applyPreviousMorph(this, replay, tick - record.preDelay, playing ? MorphType.FORCE : MorphType.PAUSE);
                }
                else
                {
                    this.playback = new RecordPlayer(null, Mode.FRAMES, this);

                    Dispatcher.sendToServer(new PacketRequestAction(filename, false));
                    Dispatcher.sendToServer(new PacketRequestFrames(this.getEntityId(), filename));
                }
            }

            if (this.playback != null)
            {
                this.playback.tick = tick;
                this.playback.playing = playing;
            }
        }

        this.setEntityInvulnerable(buffer.readBoolean());
        this.renderLast = buffer.readBoolean();
    }

    @Override
    public boolean canBeLeashedTo(EntityPlayer player) {
        return !this.getLeashed();
    }

    /**
     * Used by playback code to set item animation thingy
     */
    public void setItemStackInUse(int activeCount)
    {
        this.activeItemStackUseCount = activeCount;
    }

    /**
     * Is actor in range in render distance
     *
     * This method is responsible for checking if this entity is 
     * available for rendering. Rendering range is configurable.
     */
    @SideOnly(Side.CLIENT)
    @Override
    public boolean isInRangeToRenderDist(double distance)
    {
        double d0 = this.getEntityBoundingBox().getAverageEdgeLength();

        if (Double.isNaN(d0))
        {
            d0 = 1.0D;
        }

        d0 = d0 * Blockbuster.actorRenderingRange.get();
        return distance < d0 * d0;
    }

    public static class EntityFakePlayer extends EntityPlayer
    {
        public EntityActor actor;

        public EntityFakePlayer(World world, EntityActor actor, GameProfile profile)
        {
            super(world, profile);

            this.actor = actor;
        }

        @Override
        public boolean isSpectator()
        {
            return false;
        }

        @Override
        public boolean isCreative()
        {
            return false;
        }

        @Override
        public void onUpdate()
        {
            if (this.actor.isDead)
            {
                this.setDead();

                return;
            }

            this.width = this.actor.width;
            this.height = this.actor.height;
            this.eyeHeight = this.actor.getEyeHeight();
            this.setEntityBoundingBox(this.actor.getEntityBoundingBox());

            if (this.actor.getRidingEntity() != this)
            {
                this.posX = this.actor.posX;
                this.posY = this.actor.posY;
                this.posZ = this.actor.posZ;
            }

            this.rotationYaw = this.actor.rotationYaw;
            this.rotationPitch = this.actor.rotationPitch;

            if (!Objects.equals(this.getItemStackFromSlot(EntityEquipmentSlot.MAINHAND), this.actor.getHeldItemMainhand()))
            {
                this.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, this.actor.getHeldItemMainhand());
            }

            if (!Objects.equals(this.getItemStackFromSlot(EntityEquipmentSlot.OFFHAND), this.actor.getHeldItemOffhand()))
            {
                this.setItemStackToSlot(EntityEquipmentSlot.OFFHAND, this.actor.getHeldItemOffhand());
            }
        }

        @Override
        public void displayGUIChest(IInventory chestInventory)
        {
            if (this.openContainer != this.inventoryContainer)
            {
                this.closeScreen();
            }

            if (chestInventory instanceof IInteractionObject)
            {
                this.openContainer = ((IInteractionObject)chestInventory).createContainer(this.inventory, this);
            }
            else
            {
                this.openContainer = new ContainerChest(this.inventory, chestInventory, this);
            }
        }

        @Override
        public void closeScreen()
        {
            this.openContainer.onContainerClosed(this);

            super.closeScreen();
        }

        @Override
        public void readFromNBT(NBTTagCompound compound)
        {
            this.setDead();
        }

        @Override
        public NBTTagCompound writeToNBT(NBTTagCompound compound)
        {
            return compound;
        }
    }
}

==================================================

--- Файл №294 ---
Путь: main\java\mchorse\blockbuster\common\entity\EntityGunProjectile.java
--------------------
package mchorse.blockbuster.common.entity;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketGunProjectile;
import mchorse.blockbuster.network.common.guns.PacketGunProjectileVanish;
import mchorse.blockbuster.network.common.guns.PacketGunStuck;
import mchorse.mclib.utils.NBTUtils;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.MoverType;
import net.minecraft.entity.projectile.EntityThrowable;
import net.minecraft.init.Blocks;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumFacing.Axis;
import net.minecraft.util.EnumParticleTypes;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.RayTraceResult.Type;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.registry.IEntityAdditionalSpawnData;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * Gun projectile entity
 * <p>
 * This bad boy is responsible for being a gun projectile. It works in a
 * similar fashion as a snowball, but holds a morph
 */
public class EntityGunProjectile extends EntityThrowable implements IEntityAdditionalSpawnData
{
    public GunProps props;
    public AbstractMorph original;
    public Morph morph = new Morph();
    public int hits;
    public int impact;
    public boolean vanish;
    public int vanishDelay;
    public boolean stuck;

    /* Syncing on the client side the position */
    public int updatePos;
    public double targetX;
    public double targetY;
    public double targetZ;

    public double initMX;
    public double initMY;
    public double initMZ;

    public boolean setInit;

    public EntityGunProjectile(World worldIn)
    {
        this(worldIn, null, null);
    }

    public EntityGunProjectile(World worldIn, GunProps props, AbstractMorph morph)
    {
        super(worldIn);

        this.props = props;
        this.morph.setDirect(morph);
        this.original = this.morph.copy();
        if (props != null)
        {
            this.setSize(props.hitboxX, props.hitboxY);
        }

        this.impact = -1;
    }

    @Override
    public void shoot(Entity entityThrower, float rotationPitchIn, float rotationYawIn, float pitchOffset, float velocity, float inaccuracy)
    {
        if (entityThrower instanceof EntityActor.EntityFakePlayer)
        {
            this.thrower = ((EntityActor.EntityFakePlayer) entityThrower).actor;
        }
        else if (entityThrower instanceof EntityLivingBase)
        {
            this.thrower = (EntityLivingBase) entityThrower;
        }

        super.shoot(entityThrower, rotationPitchIn, rotationYawIn, pitchOffset, velocity, inaccuracy);
    }

    public void setInitialMotion()
    {
        this.initMX = this.motionX;
        this.initMY = this.motionY;
        this.initMZ = this.motionZ;
    }

    @Override
    public void onUpdate()
    {
        if (this.vanish)
        {
            if (!this.world.isRemote && this.vanishDelay <= 0)
            {
                this.setDead();
            }

            if (this.vanishDelay > 0)
            {
                this.vanishDelay--;
            }
        }

        if (!this.world.isBlockLoaded(this.getPosition(), false))
        {
            this.setDead();
        }

        this.lastTickPosX = this.posX;
        this.lastTickPosY = this.posY;
        this.lastTickPosZ = this.posZ;

        if (!this.world.isRemote)
        {
            this.setFlag(6, this.isGlowing());
        }
        else if (!this.setInit)
        {
            this.setInit = true;
            this.motionX = this.initMX;
            this.motionY = this.initMY;
            this.motionZ = this.initMZ;
        }

        this.onEntityUpdate();

        if (!this.stuck)
        {
            /* Ray trace for impact */
            Vec3d position = new Vec3d(this.posX, this.posY, this.posZ);
            Vec3d next = new Vec3d(this.posX + this.motionX, this.posY + this.motionY, this.posZ + this.motionZ);
            Entity entity = null;
            RayTraceResult result = this.world.rayTraceBlocks(position, next, false, true, false);

            if (result != null)
            {
                next = new Vec3d(result.hitVec.x, result.hitVec.y, result.hitVec.z);
            }

            if (!this.props.ignoreEntities)
            {
                List<Entity> list = this.world.getEntitiesWithinAABBExcludingEntity(this, this.getEntityBoundingBox().expand(this.motionX, this.motionY, this.motionZ).grow(1.0D));
                double dist = 0.0D;

                for (int i = 0; i < list.size(); ++i)
                {
                    Entity current = list.get(i);

                    if (current.canBeCollidedWith())
                    {
                        AxisAlignedBB box = current.getEntityBoundingBox().grow(0.30000001192092896D);
                        RayTraceResult ray = box.calculateIntercept(position, next);

                        if (ray != null)
                        {
                            double d1 = position.squareDistanceTo(ray.hitVec);

                            if (!(current instanceof EntityGunProjectile) && current != this.thrower && (d1 < dist || dist == 0.0D))
                            {
                                entity = current;
                                dist = d1;
                            }
                        }
                    }
                }
            }

            if (entity != null)
            {
                result = new RayTraceResult(entity);
            }

            /* Update position */
            this.posX += this.motionX;
            this.posY += this.motionY;
            this.posZ += this.motionZ;

            if (result != null)
            {
                if (result.typeOfHit == RayTraceResult.Type.BLOCK && this.world.getBlockState(result.getBlockPos()).getBlock() == Blocks.PORTAL)
                {
                    this.setPortal(result.getBlockPos());
                }
                else
                {
                    if (!net.minecraftforge.common.ForgeHooks.onThrowableImpact(this, result))
                    {
                        this.onImpact(result);
                    }
                }
            }

            /* Update position, motion and rotation */
            float distance = MathHelper.sqrt(this.motionX * this.motionX + this.motionZ * this.motionZ);
            this.rotationYaw = (float) (MathHelper.atan2(this.motionX, this.motionZ) * (180D / Math.PI));

            for (this.rotationPitch = (float) (MathHelper.atan2(this.motionY, distance) * (180D / Math.PI)); this.rotationPitch - this.prevRotationPitch < -180.0F; this.prevRotationPitch -= 360.0F)
            {}

            while (this.rotationPitch - this.prevRotationPitch >= 180.0F)
                this.prevRotationPitch += 360.0F;
            while (this.rotationYaw - this.prevRotationYaw < -180.0F)
                this.prevRotationYaw -= 360.0F;
            while (this.rotationYaw - this.prevRotationYaw >= 180.0F)
                this.prevRotationYaw += 360.0F;

            this.rotationPitch = this.prevRotationPitch + (this.rotationPitch - this.prevRotationPitch) * 0.2F;
            this.rotationYaw = this.prevRotationYaw + (this.rotationYaw - this.prevRotationYaw) * 0.2F;
            float friction = this.props == null ? 1 : this.props.friction;

            if (this.isInWater())
            {
                for (int j = 0; j < 4; ++j)
                {
                    this.world.spawnParticle(EnumParticleTypes.WATER_BUBBLE, this.posX - this.motionX * 0.25D, this.posY - this.motionY * 0.25D, this.posZ - this.motionZ * 0.25D, this.motionX, this.motionY, this.motionZ, new int[0]);
                }

                friction *= 0.8F;
            }

            if (this.onGround)
            {
                friction *= 0.9F;
            }

            this.motionX *= friction;
            this.motionY *= friction;
            this.motionZ *= friction;

            if (!this.hasNoGravity())
            {
                this.motionY -= this.getGravityVelocity();
            }

            if (this.hits < this.props.hits)
            {
                double diff = this.motionX * this.motionX + this.motionY * this.motionY + this.motionZ * this.motionZ;

                if (diff < 100 * 100)
                {
                    this.noClip = this.props.ignoreBlocks;
                    this.move(MoverType.SELF, this.motionX, this.motionY, this.motionZ);
                }
                else
                {
                    this.setDead();
                }
            }
            else
            {
                this.setPosition(this.posX, this.posY, this.posZ);
            }
        }

        this.updateProjectile();
    }

    /**
     * Update projectile's properties
     */
    private void updateProjectile()
    {
        if (this.world.isRemote && this.updatePos > 0)
        {
            double d0 = this.posX + (this.targetX - this.posX) / this.updatePos;
            double d1 = this.posY + (this.targetY - this.posY) / this.updatePos;
            double d2 = this.posZ + (this.targetZ - this.posZ) / this.updatePos;

            this.updatePos--;
            this.setPosition(d0, d1, d2);
        }

        AbstractMorph morph = this.morph.get();

        if (morph != null)
        {
            this.props.createEntity(this.world);
            this.props.target.posX = this.posX;
            this.props.target.posY = this.posY;
            this.props.target.posZ = this.posZ;
            morph.update(this.props.getEntity(this));
        }

        if (this.props == null || this.world.isRemote)
        {
            return;
        }

        if (this.ticksExisted > this.props.lifeSpan)
        {
            this.setDead();

            if (!this.props.vanishCommand.isEmpty())
            {
                this.getServer().commandManager.executeCommand(this, this.props.vanishCommand);
            }
        }

        if (this.props.ticking > 0 && this.ticksExisted % this.props.ticking == 0 && !this.props.tickCommand.isEmpty())
        {
            this.getServer().commandManager.executeCommand(this, this.props.tickCommand);
        }

        if (this.impact >= 0)
        {
            if (this.impact == 0)
            {
                AbstractMorph original = MorphUtils.copy(this.original);

                this.morph.set(original);

                Dispatcher.sendToTracked(this, new PacketGunProjectile(this.getEntityId(), original));
            }

            this.impact--;
        }
    }

    @Override
    protected void onImpact(RayTraceResult result)
    {
        if (this.stuck || this.vanish || this.props == null)
        {
            return;
        }

        this.hits++;

        boolean shouldDie = this.props.vanish && this.hits >= this.props.hits && !this.props.sticks;
        boolean impactMorph = false;

        if (result.typeOfHit == Type.BLOCK && !this.props.ignoreBlocks)
        {
            Axis axis = result.sideHit.getAxis();
            float factor = (this.props.bounce && this.hits <= this.props.hits ? -1 : 0);

            if (axis == Axis.X) this.motionX *= factor;
            if (axis == Axis.Y) this.motionY *= factor;
            if (axis == Axis.Z) this.motionZ *= factor;

            this.motionX *= this.props.bounceFactor;
            this.motionY *= this.props.bounceFactor;
            this.motionZ *= this.props.bounceFactor;

            this.posX = result.hitVec.x + this.width / 2 * result.sideHit.getFrontOffsetX();
            this.posY = result.hitVec.y - this.height * (result.sideHit == EnumFacing.DOWN ? 1 : 0);
            this.posZ = result.hitVec.z + this.width / 2 * result.sideHit.getFrontOffsetZ();

            if (this.props.sticks)
            {
                this.stuck = true;

                if (!this.world.isRemote)
                {
                    if (result.sideHit == EnumFacing.WEST || result.sideHit == EnumFacing.EAST) this.posX += this.props.penetration * result.sideHit.getFrontOffsetX();
                    else if (result.sideHit == EnumFacing.UP || result.sideHit == EnumFacing.DOWN) this.posY += this.props.penetration * result.sideHit.getFrontOffsetY();
                    else if (result.sideHit == EnumFacing.NORTH || result.sideHit == EnumFacing.SOUTH) this.posZ += this.props.penetration * result.sideHit.getFrontOffsetZ();

                    Dispatcher.sendToTracked(this, new PacketGunStuck(this.getEntityId(), (float) this.posX, (float) this.posY, (float) this.posZ));
                }
            }
        }

        if (!this.world.isRemote)
        {
            if (result.typeOfHit == Type.BLOCK && !this.props.ignoreBlocks)
            {
                if (!this.props.impactCommand.isEmpty())
                {
                    String command = this.props.impactCommand;
                    int x = Math.round((float) this.posX);
                    int y = Math.round((float) this.posY);
                    int z = Math.round((float) this.posZ);

                    if (result.typeOfHit == Type.BLOCK)
                    {
                        x = result.getBlockPos().getX();
                        y = result.getBlockPos().getY();
                        z = result.getBlockPos().getZ();
                    }

                    command = command.replaceAll("\\$\\{x\\}", String.valueOf(x));
                    command = command.replaceAll("\\$\\{y\\}", String.valueOf(y));
                    command = command.replaceAll("\\$\\{z\\}", String.valueOf(z));

                    if (this.getServer() != null)
                    {
                        this.getServer().commandManager.executeCommand(this, command);
                    }
                }

                impactMorph = true;
            }

            if (result.typeOfHit == Type.ENTITY && !this.props.ignoreEntities)
            {
                if (!this.props.impactEntityCommand.isEmpty())
                {
                    this.getServer().commandManager.executeCommand(this, this.props.impactEntityCommand);
                }

                if (this.props.damage > 0)
                {
                    if (result.entityHit instanceof EntityLiving)
                    {
                        EntityLiving living = (EntityLiving) result.entityHit;

                        result.entityHit.attackEntityFrom(DamageSource.causeThrownDamage(this, null), 0);
                        living.setHealth(living.getHealth() - this.props.damage);
                    }
                    else
                    {
                        result.entityHit.attackEntityFrom(DamageSource.causeThrownDamage(this, null), this.props.damage);
                    }
                }

                if (this.props.knockbackHorizontal != 0 && result.entityHit instanceof EntityLivingBase)
                {
                    ((EntityLivingBase) result.entityHit).knockBack(this, Math.abs(this.props.knockbackHorizontal), -this.motionX, -this.motionZ);

                    if (this.props.knockbackHorizontal < 0)
                    {
                        result.entityHit.motionX *= -1;
                        result.entityHit.motionZ *= -1;
                    }
                }

                result.entityHit.motionY += this.props.knockbackVertical;

                impactMorph = true;
            }

            if (shouldDie)
            {
                this.vanish = true;
                this.vanishDelay = this.props.vanishDelay;

                if (this.vanishDelay > 0)
                {
                    Dispatcher.sendToTracked(this, new PacketGunProjectileVanish(this.getEntityId(), this.vanishDelay));
                }

                return;
            }

            /* Change to impact morph */
            if (impactMorph && this.props.impactDelay > 0)
            {
                AbstractMorph morph = MorphUtils.copy(this.props.impactMorph);

                this.morph.set(morph);
                this.impact = this.props.impactDelay;

                Dispatcher.sendToTracked(this, new PacketGunProjectile(this.getEntityId(), morph));
            }
        }
    }

    @Override
    protected float getGravityVelocity()
    {
        return this.props == null ? super.getGravityVelocity() : this.props.gravity;
    }

    /* NBT and ByteBuf read/write methods */

    @Override
    public void writeSpawnData(ByteBuf buffer)
    {
        buffer.writeBoolean(this.props != null);

        if (this.props != null)
        {
            ByteBufUtils.writeTag(buffer, this.props.toNBT());
        }

        buffer.writeBoolean(this.morph.get() != null);

        if (this.morph.get() != null)
        {
            ByteBufUtils.writeTag(buffer, this.morph.toNBT());
        }

        buffer.writeDouble(this.initMX);
        buffer.writeDouble(this.initMY);
        buffer.writeDouble(this.initMZ);
    }

    @Override
    public void readSpawnData(ByteBuf additionalData)
    {
        if (additionalData.readBoolean())
        {
            this.props = new GunProps(NBTUtils.readInfiniteTag(additionalData));
            this.setSize(this.props.hitboxX, this.props.hitboxY);
        }

        if (additionalData.readBoolean())
        {
            this.morph.fromNBT(NBTUtils.readInfiniteTag(additionalData));
        }

        this.initMX = additionalData.readDouble();
        this.initMY = additionalData.readDouble();
        this.initMZ = additionalData.readDouble();
    }

    /**
     * Don't restore the entity from NBT, kill the projectile immediately
     */
    @Override
    public void readEntityFromNBT(NBTTagCompound compound)
    {
        super.readEntityFromNBT(compound);

        this.setDead();
    }

    /* Client side methods */

    /**
     * Update position from the server, only in case if there is a big
     * desync enough to be noticeable
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void setPositionAndRotationDirect(double x, double y, double z, float yaw, float pitch, int posRotationIncrements, boolean teleport)
    {
        if (this.stuck)
        {
            return;
        }

        double dx = this.posX - x;
        double dy = this.posY - y;
        double dz = this.posZ - z;
        double dist = dx * dx + dy * dy + dz * dz;
        double syncDistance = Blockbuster.bbGunSyncDistance.get();

        if (syncDistance > 0 && dist > syncDistance * syncDistance)
        {
            this.updatePos = posRotationIncrements;
            this.targetX = x;
            this.targetY = y;
            this.targetZ = z;
        }
    }

    /**
     * Is projectile in range in render distance
     * <p>
     * This method is responsible for checking if this entity is
     * available for rendering. Rendering range is configurable.
     */
    @SideOnly(Side.CLIENT)
    @Override
    public boolean isInRangeToRenderDist(double distance)
    {
        double d0 = Blockbuster.actorRenderingRange.get();
        return distance < d0 * d0;
    }
}

==================================================

--- Файл №295 ---
Путь: main\java\mchorse\blockbuster\common\entity\ExpirableDummyEntity.java
--------------------
package mchorse.blockbuster.common.entity;

import mchorse.mclib.utils.DummyEntity;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.world.World;

public class ExpirableDummyEntity extends DummyEntity
{
    private int lifetime;
    private int age;

    /**
     * Sets the height and width to 0
     * @param worldIn
     * @param lifetime
     */
    public ExpirableDummyEntity(World worldIn, int lifetime)
    {
        this(worldIn, lifetime, 0, 0);
    }

    public ExpirableDummyEntity(World worldIn, int lifetime, float height, float width)
    {
        super(worldIn);

        this.lifetime = lifetime;
        this.height = height;
        this.width = width;
    }

    public void setLifetime(int lifetime)
    {
        this.lifetime = lifetime;
    }

    public int getLifetime()
    {
        return this.lifetime;
    }

    public int getAge()
    {
        return this.age;
    }

    @Override
    public void onEntityUpdate()
    {
        super.onEntityUpdate();

        if (this.age >= this.lifetime)
        {
            this.setDead();
        }

        this.age++;
    }

    @Override
    public boolean canBeCollidedWith()
    {
        return false;
    }

    @Override
    public void onCollideWithPlayer(EntityPlayer entityIn) {}

    @Override
    public boolean canBePushed()
    {
        return false;
    }

    @Override
    protected void collideWithEntity(Entity entityIn)
    {

    }
}


==================================================

--- Файл №296 ---
Путь: main\java\mchorse\blockbuster\common\item\ItemActorConfig.java
--------------------
package mchorse.blockbuster.common.item;

import java.util.List;

import mchorse.blockbuster.Blockbuster;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * This item is used for opening actor's configuration GUI.
 *
 * I really like the icon, it looks badass!
 */
public class ItemActorConfig extends Item
{
    public ItemActorConfig()
    {
        this.setMaxStackSize(1);
        this.setRegistryName("actor_config");
        this.setUnlocalizedName("blockbuster.actor_config");
        this.setCreativeTab(Blockbuster.blockbusterTab);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn)
    {
        tooltip.add(I18n.format("blockbuster.info.actor_config"));
    }
}

==================================================

--- Файл №297 ---
Путь: main\java\mchorse\blockbuster\common\item\ItemBlockGreen.java
--------------------
package mchorse.blockbuster.common.item;

import net.minecraft.block.Block;
import net.minecraft.item.ItemColored;

public class ItemBlockGreen extends ItemColored
{
    public ItemBlockGreen(Block block, boolean hasSubtypes)
    {
        super(block, hasSubtypes);
    }
}

==================================================

--- Файл №298 ---
Путь: main\java\mchorse\blockbuster\common\item\ItemBlockModel.java
--------------------
package mchorse.blockbuster.common.item;

import mchorse.blockbuster.Blockbuster;
import net.minecraft.advancements.CriteriaTriggers;
import net.minecraft.block.Block;
import net.minecraft.block.SoundType;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.creativetab.CreativeTabs;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.EnumActionResult;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.NonNullList;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.util.List;

/**
 * Item for Model Block with light strength.
 * It cannot extend ItemBlock because it seems like Optifine does not
 * recognise ItemBlock subclasses for dynamic_lighting.properties.
 *
 * Block items not extending ItemBlock do not seem to copy NBT on Spigot servers.
 * This class is only for the ModelBlocks that have a light strength.
 */
public class ItemBlockModel extends Item
{
    private int lightValue;
    private Block block;

    public ItemBlockModel(Block block, int lightValue)
    {
        String name = "model" + ((lightValue != 0) ? lightValue : "");

        this.block = block;
        this.lightValue = lightValue;

        this.setRegistryName(name);
        this.setUnlocalizedName("blockbuster." + name);

        if (lightValue == 0)
        {
            this.setCreativeTab(Blockbuster.blockbusterTab);
        }
    }

    @Override
    /**
     * Copied from ItemBlock class
     */
    public EnumActionResult onItemUse(EntityPlayer player, World worldIn, BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
    {
        IBlockState iblockstate = worldIn.getBlockState(pos);
        Block block = iblockstate.getBlock();

        if (!block.isReplaceable(worldIn, pos))
        {
            pos = pos.offset(facing);
        }

        ItemStack itemstack = player.getHeldItem(hand);

        if (!itemstack.isEmpty() && player.canPlayerEdit(pos, facing, itemstack) && worldIn.mayPlace(this.block, pos, false, facing, (Entity)null))
        {
            /* The Model Block uses metadata for lightValue, the item should use its lightValue as "metadata" for that purpose */
            int i = this.lightValue;
            IBlockState iblockstate1 = this.block.getStateForPlacement(worldIn, pos, facing, hitX, hitY, hitZ, i, player, hand);

            if (placeBlockAt(itemstack, player, worldIn, pos, facing, hitX, hitY, hitZ, iblockstate1))
            {
                iblockstate1 = worldIn.getBlockState(pos);
                SoundType soundtype = iblockstate1.getBlock().getSoundType(iblockstate1, worldIn, pos, player);
                worldIn.playSound(player, pos, soundtype.getPlaceSound(), SoundCategory.BLOCKS, (soundtype.getVolume() + 1.0F) / 2.0F, soundtype.getPitch() * 0.8F);
                itemstack.shrink(1);
            }

            return EnumActionResult.SUCCESS;
        }
        else
        {
            return EnumActionResult.FAIL;
        }
    }

    /**
     * Copied from ItemBlock class
     */
    public static boolean setTileEntityNBT(World worldIn, @Nullable EntityPlayer player, BlockPos pos, ItemStack stackIn)
    {
        MinecraftServer minecraftserver = worldIn.getMinecraftServer();

        if (minecraftserver == null)
        {
            return false;
        }
        else
        {
            NBTTagCompound nbttagcompound = stackIn.getSubCompound("BlockEntityTag");

            if (nbttagcompound != null)
            {
                TileEntity tileentity = worldIn.getTileEntity(pos);

                if (tileentity != null)
                {
                    if (!worldIn.isRemote && tileentity.onlyOpsCanSetNbt() && (player == null || !player.canUseCommandBlock()))
                    {
                        return false;
                    }

                    NBTTagCompound nbttagcompound1 = tileentity.writeToNBT(new NBTTagCompound());
                    NBTTagCompound nbttagcompound2 = nbttagcompound1.copy();
                    nbttagcompound1.merge(nbttagcompound);
                    nbttagcompound1.setInteger("x", pos.getX());
                    nbttagcompound1.setInteger("y", pos.getY());
                    nbttagcompound1.setInteger("z", pos.getZ());

                    if (!nbttagcompound1.equals(nbttagcompound2))
                    {
                        tileentity.readFromNBT(nbttagcompound1);
                        tileentity.markDirty();

                        return true;
                    }
                }
            }

            return false;
        }
    }

    /**
     * allows items to add custom lines of information to the mouseover description
     */
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, @Nullable World worldIn, List<String> tooltip, ITooltipFlag flagIn)
    {
        super.addInformation(stack, worldIn, tooltip, flagIn);
        this.block.addInformation(stack, worldIn, tooltip, flagIn);
    }

    /**
     * Called to actually place the block, after the location is determined
     * and all permission checks have been made.
     *
     * @param stack The item stack that was used to place the block. This can be changed inside the method.
     * @param player The player who is placing the block. Can be null if the block is not being placed by a player.
     * @param side The side the player (or machine) right-clicked on.
     */
    public boolean placeBlockAt(ItemStack stack, EntityPlayer player, World world, BlockPos pos, EnumFacing side, float hitX, float hitY, float hitZ, IBlockState newState)
    {
        if (!world.setBlockState(pos, newState, 11))
        {
            return false;
        }

        IBlockState state = world.getBlockState(pos);

        if (state.getBlock() == this.block)
        {
            this.setTileEntityNBT(world, player, pos, stack);

            this.block.onBlockPlacedBy(world, pos, state, player, stack);

            if (player instanceof EntityPlayerMP)
            {
                CriteriaTriggers.PLACED_BLOCK.trigger((EntityPlayerMP)player, pos, stack);
            }
        }

        return true;
    }
}


==================================================

--- Файл №299 ---
Путь: main\java\mchorse\blockbuster\common\item\ItemGun.java
--------------------
package mchorse.blockbuster.common.item;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer.GunEntry;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.entity.EntityActor.EntityFakePlayer;
import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketGunInfo;
import mchorse.blockbuster.network.common.guns.PacketGunShot;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ShootGunAction;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.blockbuster_pack.morphs.SequencerMorph;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.OpHelper;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.init.Items;
import net.minecraft.item.EnumAction;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import javax.vecmath.Matrix3f;
import javax.vecmath.Vector3f;

import java.util.List;
import java.util.Objects;

public class ItemGun extends Item
{
    public static float getRandom(float a, float b)
    {
        return (float) Math.random() * (a - b) + b;
    }

    public ItemGun()
    {
        this.setMaxStackSize(1);
        this.setRegistryName("gun");
        this.setUnlocalizedName("blockbuster.gun");
        this.setCreativeTab(Blockbuster.blockbusterTab);
    }

    @Override
    public boolean shouldCauseReequipAnimation(ItemStack from, ItemStack to, boolean changed) {
        if (!changed && to.getItem() instanceof ItemGun) {
            GunEntry oldEntry = TileEntityGunItemStackRenderer.models.get(from);
            GunEntry newEntry = TileEntityGunItemStackRenderer.models.get(to);

            if (oldEntry != null) {
                GunProps newProps = NBTUtils.getGunProps(to);
                boolean isSameModel = true;

                isSameModel &= Objects.equals(oldEntry.props.defaultMorph, newProps.defaultMorph);
                isSameModel &= Objects.equals(oldEntry.props.firingMorph, newProps.firingMorph);
                isSameModel &= Objects.equals(oldEntry.props.crosshairMorph, newProps.crosshairMorph);
                isSameModel &= Objects.equals(oldEntry.props.handsMorph, newProps.handsMorph);
                isSameModel &= Objects.equals(oldEntry.props.reloadMorph, newProps.reloadMorph);
                isSameModel &= Objects.equals(oldEntry.props.zoomOverlayMorph, newProps.zoomOverlayMorph);

                if (isSameModel && newEntry == null) {
                    // Moving the old model to the new stack only if there's not already a model associated with the 'to' stack
                    TileEntityGunItemStackRenderer.models.put(to, TileEntityGunItemStackRenderer.models.remove(from));
                }

                return !isSameModel;
            }
        }

        return true; // what animation to use when the player holds the "use" button
    }

    @Override
    public boolean hitEntity(ItemStack stack, EntityLivingBase target, EntityLivingBase attacker)
    {
        GunProps props = NBTUtils.getGunProps(stack);
        boolean result = super.hitEntity(stack, target, attacker);

        if (props == null)
        {
            return result;
        }

        if (!result)
        {
            if (!props.meleeCommand.isEmpty())
            {
                if (attacker instanceof EntityPlayerMP)
                {
                    EntityPlayerMP player = (EntityPlayerMP) attacker;

                    player.getServer().commandManager.executeCommand(player, props.meleeCommand);
                }
            }

            target.setHealth(target.getHealth() - props.meleeDamage);

            return false;
        }

        return true;
    }

    @Override
    public EnumAction getItemUseAction(ItemStack stack)
    {
        return EnumAction.NONE;
    }

    @Override
    public int getMaxItemUseDuration(ItemStack stack)
    {
        return 0;
    }

    public static void decreaseTime(ItemStack stack, EntityPlayer player)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        if (props.storedShotDelay > 0)
        {
            props.storedShotDelay = Math.max(props.storedShotDelay - 1, 0);

            NBTUtils.saveGunProps(stack, props.toNBT());

            if (!player.world.isRemote)
            {
                Dispatcher.sendTo(new PacketGunInfo(props.toNBT(), player.getEntityId()), (EntityPlayerMP) player);
                Dispatcher.sendToTracked(player, new PacketGunInfo(props.toNBT(), player.getEntityId()));
            }
        }
    }

    private void resetTime(ItemStack stack, EntityPlayer player)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        props.storedShotDelay = props.shotDelay;

        NBTUtils.saveGunProps(stack, props.toNBT());
    }

    public static void decreaseReload(ItemStack stack, EntityPlayer player)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        if (props.state == GunState.RELOADING)
        {
            props.storedReloadingTime = props.storedReloadingTime - 1;

            if (props.storedReloadingTime <= 0)
            {
                props.storedReloadingTime = 0;
                props.state = GunState.READY_TO_SHOOT;
            }

            NBTUtils.saveGunProps(stack, props.toNBT());

            if (!player.world.isRemote)
            {
                Dispatcher.sendTo(new PacketGunInfo(props.toNBT(), player.getEntityId()), (EntityPlayerMP) player);
                Dispatcher.sendToTracked(player, new PacketGunInfo(props.toNBT(), player.getEntityId()));
            }
        }
    }

    public void decreaseDurability(GunProps props, ItemStack stack, EntityPlayer player)
    {
        
        if (props == null)
        {
            return;
        }

        if (props.durability != 0)
        {
            int val = props.storedDurability - 1;

            if (val <= 0)
            {
                if (!props.destroyCommand.isEmpty())
                {
                    player.getServer().commandManager.executeCommand(player, props.destroyCommand);
                }

                player.getHeldItemMainhand().setCount(0);
            }

            props.storedDurability = val;
            
            if (NBTUtils.saveGunProps(stack, props.toNBT()))
            {
                IMessage packet = new PacketGunInfo(props.toNBT(), player.getEntityId());
                synchronize((EntityPlayerMP) player,props.toNBT());
                Dispatcher.sendTo(packet, (EntityPlayerMP) player);
                Dispatcher.sendToTracked(player, packet);
                
            }
    
            
        }
    }
    
    private void synchronize(EntityPlayerMP player, NBTTagCompound tag)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }
        
        ItemStack stack = player.getHeldItemMainhand();
        
        if (NBTUtils.saveGunProps(stack, tag))
        {
            IMessage packet = new PacketGunInfo(tag, player.getEntityId());
            Dispatcher.sendTo(packet, player);
            Dispatcher.sendToTracked(player, packet);
        }
    }
    
    @Override
    public boolean onLeftClickEntity(ItemStack p_onLeftClickEntity_1_, EntityPlayer p_onLeftClickEntity_2_, Entity p_onLeftClickEntity_3_)
    {
        return false;
    }

    public void shootIt(ItemStack stack, EntityPlayer player, World world)
    {
        resetTime(stack, player);
        GunProps props = NBTUtils.getGunProps(stack);

        if (world.isRemote && props != null)
        {
            if (props.staticRecoil)
            {
                player.rotationPitch += Interpolation.QUINT_IN.interpolate(player.prevRotationPitch, player.prevRotationPitch + props.recoilXMin, 1F) - player.prevRotationPitch;
                player.rotationYaw += Interpolation.QUINT_IN.interpolate(player.prevRotationYaw, player.prevRotationYaw + props.recoilYMin, 1F) - player.prevRotationYaw;
            }
            else
            {
                player.rotationPitch += Interpolation.SINE_IN.interpolate(player.prevRotationPitch, player.prevRotationPitch + getRandom(props.recoilXMin, props.recoilXMax), 1F) - player.prevRotationPitch;
                player.rotationYaw += Interpolation.SINE_IN.interpolate(player.prevRotationYaw, player.prevRotationYaw + getRandom(props.recoilYMin, props.recoilYMax), 1F) - player.prevRotationYaw;
            }

            if (props.launch)
            {
                float pitch = player.rotationPitch + (float) ((Math.random() - 0.5) * props.scatterY);
                float yaw = player.rotationYaw + (float) ((Math.random() - 0.5) * props.scatterX);

                this.setThrowableHeading(player, pitch, yaw, 0, props.speed);
            }
        }

        this.shoot(stack, props, player, world);
    }

    public boolean shoot(ItemStack stack, GunProps props, EntityPlayer player, World world)
    {
        if (props == null)
        {
            return false;
        }

        /* Launch the player is enabled */
        if (props.launch)
        {
            float pitch = player.rotationPitch + (float) ((Math.random() - 0.5) * props.scatterY);
            float yaw = player.rotationYaw + (float) ((Math.random() - 0.5) * props.scatterX);

            this.setThrowableHeading(player, pitch, yaw, 0, props.speed);

            if (!props.fireCommand.isEmpty())
            {
                player.getServer().commandManager.executeCommand(player, props.fireCommand);
            }
        }
        else
        {
            /* Or otherwise launch bullets */
            if (!this.consumeInnerAmmo(stack, player))
            {
                return false;
            }

            EntityGunProjectile last = null;

            for (int i = 0; i < Math.max(props.projectiles, 1); i++)
            {
                AbstractMorph morph = props.projectileMorph;

                if (props.sequencer && morph instanceof SequencerMorph)
                {
                    SequencerMorph seq = ((SequencerMorph) morph);
                    morph = props.random ? seq.getRandom() : seq.get(i % seq.morphs.size());
                }

                morph = MorphUtils.copy(morph);

                EntityGunProjectile projectile = new EntityGunProjectile(world, props, morph);

                float pitch = player.rotationPitch + (float) ((Math.random() - 0.5) * props.scatterY);
                float yaw = player.rotationYaw + (float) ((Math.random() - 0.5) * props.scatterX);
                double x = player.posX;
                double y = player.posY + player.getEyeHeight();
                double z = player.posZ;
                Vector3f offset = new Vector3f(props.shootingOffsetX, props.shootingOffsetY, props.shootingOffsetZ);
                Vector3f vector = this.rotate(offset, player.rotationYaw, player.rotationPitch);

                x += vector.x;
                y += vector.y;
                z += vector.z;

                projectile.setPosition(x, y, z);
                projectile.shoot(player, pitch, yaw, 0, props.speed, 0);
                projectile.setInitialMotion();
                if (props.projectiles > 0)
                {
                    if (!world.isRemote)
                    {
                        world.spawnEntity(projectile);
                    }
                }

                last = projectile;
            }

            if (!props.fireCommand.isEmpty())
            {
                player.getServer().commandManager.executeCommand(last, props.fireCommand);
            }
        }

        if (!world.isRemote)
        {
            Entity entity = player instanceof EntityFakePlayer ? ((EntityFakePlayer) player).actor : player;
            int id = entity.getEntityId();

            if (player instanceof EntityPlayerMP)
            {
                Dispatcher.sendTo(new PacketGunShot(id), (EntityPlayerMP) player);
            }

            Dispatcher.sendToTracked(entity, new PacketGunShot(id));

            List<Action> events = CommonProxy.manager.getActions(player);

            if (events != null)
            {
                events.add(new ShootGunAction(stack));
            }
    
            
            decreaseDurability(NBTUtils.getGunProps(stack), stack, player);
            
            if (player instanceof EntityPlayerMP)
            {
                GunProps p = NBTUtils.getGunProps(stack);
                NBTUtils.saveGunProps(stack, p.toNBT());
                Dispatcher.sendTo(new PacketGunInfo(p.toNBT(), entity.getEntityId()), (EntityPlayerMP) player);
                Dispatcher.sendToTracked(player, new PacketGunInfo(p.toNBT(), entity.getEntityId()));
                
            }
            
        }

        return true;
    }

    private Vector3f rotate(Vector3f vector, float yaw, float pitch)
    {
        Matrix3f a = new Matrix3f();
        Matrix3f b = new Matrix3f();

        a.rotY((180 - yaw) / 180F * (float) Math.PI);
        b.rotX(-pitch / 180F * (float) Math.PI);
        a.mul(b);
        a.transform(vector);

        return vector;
    }

    public static void checkGunState(ItemStack stack, EntityPlayer player)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        if (props.storedAmmo <= 0 && props.useReloading && props.state == GunState.READY_TO_SHOOT)
        {
            props.state = GunState.NEED_TO_BE_RELOAD;
        }

        //this check fixes that the name of the gun appears on the screen when you shoot (only if you don't have ammo)
        if (props.ammoStack.isEmpty())
        {
            return;
        }

        NBTUtils.saveGunProps(player.getHeldItemMainhand(), props.toNBT());

        if (!player.world.isRemote)
        {
            Dispatcher.sendTo(new PacketGunInfo(props.toNBT(), player.getEntityId()), (EntityPlayerMP) player);
            Dispatcher.sendToTracked(player, new PacketGunInfo(props.toNBT(), player.getEntityId()));
        }
    }

    public static void checkGunReload(ItemStack stack, EntityPlayer player)
    {
        if (!player.world.isRemote)
        {
            GunProps props = NBTUtils.getGunProps(stack);

            if (props.state == ItemGun.GunState.NEED_TO_BE_RELOAD && props.storedShotDelay == 0)
            {
                ItemGun gun = (ItemGun) stack.getItem();
                
                gun.reload(player, stack);
            }
        }
    }

    private boolean consumeInnerAmmo(ItemStack stack, EntityPlayer player)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return false;
        }

        int ammo = props.storedAmmo;

        if (ammo <= 0)
        {
            if (props.useReloading)
            {
                return false;
            }
            else
            {
                props.storedAmmo = props.ammo;

                NBTUtils.saveGunProps(player.getHeldItemMainhand(), props.toNBT());

                if (!player.capabilities.isCreativeMode && !props.ammoStack.isEmpty())
                {
                    return this.consumeAmmoStack(player, props.ammoStack, props.ammoStack.getCount()) >= 0;
                }
                else
                {
                    return true;
                }
            }
        }

        this.consumeAmmo(stack, player);

        return true;
    }

    private void consumeAmmo(ItemStack stack, EntityPlayer player)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        props.storedAmmo -= 1;

        NBTUtils.saveGunProps(player.getHeldItemMainhand(), props.toNBT());

    }

    public int consumeAmmoStack(EntityPlayer player, ItemStack ammo, int count)
    {
        return player.inventory.clearMatchingItems(ammo.getItem(), -1, count, ammo.getTagCompound());
    }

    private void setThrowableHeading(EntityLivingBase entityThrower, float rotationPitchIn, float rotationYawIn, float pitchOffset, float velocity)
    {
        float f = -MathHelper.sin(rotationYawIn * 0.017453292F) * MathHelper.cos(rotationPitchIn * 0.017453292F);
        float f1 = -MathHelper.sin((rotationPitchIn + pitchOffset) * 0.017453292F);
        float f2 = MathHelper.cos(rotationYawIn * 0.017453292F) * MathHelper.cos(rotationPitchIn * 0.017453292F);

        this.setThrowableHeading(entityThrower, (double) f, (double) f1, (double) f2, velocity);
    }

    public void setThrowableHeading(EntityLivingBase entity, double x, double y, double z, float velocity)
    {
        float distance = MathHelper.sqrt(x * x + y * y + z * z);

        entity.motionX = x / distance * velocity;
        entity.motionY = y / distance * velocity;
        entity.motionZ = z / distance * velocity;
    }

    public void reload(EntityPlayer player, ItemStack stack)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        int count = 0;

        if (!player.capabilities.isCreativeMode && !props.ammoStack.isEmpty())
        {
            ItemStack ammo = props.ammoStack;

            count = this.consumeAmmoStack(player, ammo, props.ammo - props.storedAmmo);
        }
        else
        {
            count = props.ammo - props.storedAmmo;
        }

        if (count > 0)
        {
            props.state = ItemGun.GunState.RELOADING;
            props.storedAmmo += count;
            props.storedReloadingTime = props.reloadingTime;

            if (!props.reloadCommand.isEmpty())
            {
                player.getServer().commandManager.executeCommand(player, props.reloadCommand);
            }

            NBTUtils.saveGunProps(stack, props.toNBT());
            Dispatcher.sendTo(new PacketGunInfo(props.toNBT(), player.getEntityId()), (EntityPlayerMP) player);
            Dispatcher.sendToTracked(player, new PacketGunInfo(props.toNBT(), player.getEntityId()));
        }
    }

    @Override
    public boolean showDurabilityBar(ItemStack stack)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props != null)
        {
            return props.state == GunState.RELOADING || props.ammo > 1 || props.durability > 0;
        }

        return super.showDurabilityBar(stack);
    }

    @Override
    public double getDurabilityForDisplay(ItemStack stack)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props != null)
        {
            if (props.state != GunState.READY_TO_SHOOT)
            {
                if (props.state == GunState.RELOADING && props.reloadingTime > 0)
                {
                    return ((double) props.storedReloadingTime / props.reloadingTime);
                }
                else
                {
                    return 1.0;
                }
            }
            else if (props.ammo > 1)
            {
                return 1.0 - ((double) props.storedAmmo / props.ammo);
            }
            else if (props.durability > 0)
            {
                return 1.0 - ((double) props.storedDurability / props.durability);
            }
        }

        return super.getDurabilityForDisplay(stack);
    }

    @Override
    public int getRGBDurabilityForDisplay(ItemStack stack)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (props != null)
        {
            if (props.state != GunState.READY_TO_SHOOT)
            {
                return 0xFFFF0000;
            }
            else if (props.ammo > 1)
            {
                return 0xFF2FC0FF;
            }
        }

        return super.getRGBDurabilityForDisplay(stack);
    }

    public enum GunState
    {
        READY_TO_SHOOT,
        RELOADING,
        NEED_TO_BE_RELOAD
    }
}

==================================================

--- Файл №300 ---
Путь: main\java\mchorse\blockbuster\common\item\ItemPlayback.java
--------------------
package mchorse.blockbuster.common.item;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketPlaybackButton;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ActionResult;
import net.minecraft.util.EnumActionResult;
import net.minecraft.util.EnumHand;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * Playback button item
 *
 * Push to start playing back the scene
 */
public class ItemPlayback extends Item
{
    /* ItemPlayback */

    public ItemPlayback()
    {
        this.setMaxStackSize(1);
        this.setRegistryName("playback");
        this.setUnlocalizedName("blockbuster.playback");
        this.setCreativeTab(Blockbuster.blockbusterTab);
    }

    /**
     * Adds information about camera profile and the location of director block
     * to which it's attached
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn)
    {
        tooltip.add(I18n.format("blockbuster.info.playback_button"));

        NBTTagCompound tag = stack.getTagCompound();

        if (tag == null)
        {
            return;
        }

        if (tag.hasKey("CameraProfile"))
        {
            tooltip.add(I18n.format("blockbuster.info.playback_profile", tag.getString("CameraProfile")));
        }
        else if (tag.hasKey("CameraPlay"))
        {
            tooltip.add(I18n.format("blockbuster.info.playback_play"));
        }

        if (tag.hasKey("Scene"))
        {
            tooltip.add(I18n.format("blockbuster.info.playback_scene", tag.getString("Scene")));
        }
    }

    /**
     * This method starts playback of the director block's actors (if the
     * director block is attached to this item stack).
     */
    @Override
    public ActionResult<ItemStack> onItemRightClick(World worldIn, EntityPlayer player, EnumHand handIn)
    {
        ItemStack stack = player.getHeldItem(handIn);

        if (!worldIn.isRemote)
        {
            NBTTagCompound tag = stack.getTagCompound();

            if (player.isSneaking() && OpHelper.isPlayerOp((EntityPlayerMP) player))
            {
                if (tag == null)
                {
                    tag = new NBTTagCompound();
                }

                String profile = tag.getString("CameraProfile");
                String scene = tag.getString("Scene");

                Dispatcher.sendTo(new PacketPlaybackButton(new SceneLocation(scene), CameraHandler.getModeFromNBT(tag), profile).withScenes(CommonProxy.scenes.sceneFiles()), ((EntityPlayerMP) player));

                return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, stack);
            }

            if (tag == null)
            {
                return new ActionResult<ItemStack>(EnumActionResult.PASS, stack);
            }

            String scene = tag.getString("Scene");

            if (!scene.isEmpty() && CommonProxy.scenes.toggle(scene, player.world) && CameraHandler.isApertureLoaded())
            {
                CameraHandler.handlePlaybackItem(player, tag);
            }
        }

        return new ActionResult<ItemStack>(EnumActionResult.SUCCESS, stack);
    }
}

==================================================

--- Файл №301 ---
Путь: main\java\mchorse\blockbuster\common\item\ItemRegister.java
--------------------
package mchorse.blockbuster.common.item;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.client.resources.I18n;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ActionResult;
import net.minecraft.util.EnumActionResult;
import net.minecraft.util.EnumHand;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

/**
 * Register item
 *
 * Used to register an actor to director block (a scene) and
 * open a director block remotely
 */
public class ItemRegister extends Item
{
    public ItemRegister()
    {
        this.setMaxStackSize(1);
        this.setRegistryName("register");
        this.setUnlocalizedName("blockbuster.register");
        this.setCreativeTab(Blockbuster.blockbusterTab);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void addInformation(ItemStack stack, World worldIn, List<String> tooltip, ITooltipFlag flagIn)
    {
        tooltip.add(I18n.format("blockbuster.info.register"));
    }

    /**
     * On right click, show the director block GUI, if this item has attached
     * director block, then we can show the director block GUI.
     */
    @Override
    public ActionResult<ItemStack> onItemRightClick(World world, EntityPlayer player, EnumHand hand)
    {
        if (!world.isRemote)
        {
            EntityUtils.sendStatusMessage((EntityPlayerMP) player, new TextComponentTranslation("blockbuster.bye_register_item"));
        }

        return new ActionResult<ItemStack>(EnumActionResult.PASS, player.getHeldItem(hand));
    }
}

==================================================

--- Файл №302 ---
Путь: main\java\mchorse\blockbuster\common\tileentity\TileEntityDirector.java
--------------------
package mchorse.blockbuster.common.tileentity;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.recording.scene.Scene;
import net.minecraft.block.state.IBlockState;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.tileentity.TileEntityFlowerPot;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Director tile entity
 *
 * Goodbye director blocks...
 */
public class TileEntityDirector extends TileEntityFlowerPot
{
    @Override
    public boolean shouldRefresh(World world, BlockPos pos, IBlockState oldState, IBlockState newSate)
    {
        return oldState.getBlock() != newSate.getBlock();
    }

    /* Read/write this TE to disk */

    @Override
    public void readFromNBT(NBTTagCompound compound)
    {
        super.readFromNBT(compound);

        /* At least the data wouldn't be lost */
        if (compound.hasKey("Actors"))
        {
            Scene scene = new Scene();

            scene.fromNBT(compound);
            scene.setId("director_block_" + this.pos.getX() + "_" + this.pos.getY() + "_" + this.pos.getZ());

            try
            {
                CommonProxy.scenes.save(scene.getId(), scene);
            }
            catch (Exception e)
            {}
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public AxisAlignedBB getRenderBoundingBox()
    {
        return TileEntity.INFINITE_EXTENT_AABB;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public double getMaxRenderDistanceSquared()
    {
        float range = Blockbuster.actorRenderingRange.get();

        return range * range;
    }
}

==================================================

--- Файл №303 ---
Путь: main\java\mchorse\blockbuster\common\tileentity\TileEntityModel.java
--------------------
package mchorse.blockbuster.common.tileentity;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.render.IRenderLast;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.network.NetworkManager;
import net.minecraft.network.play.server.SPacketUpdateTileEntity;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ITickable;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Vector3d;

/**
 * Model tile entity
 * 
 * This little guy is responsible for storing visual data about model's 
 * rendering.
 */
public class TileEntityModel extends TileEntity implements ITickable, IRenderLast, IByteBufSerializable
{
    private static AbstractMorph DEFAULT_MORPH;

    public Morph morph = new Morph();
    public EntityLivingBase entity;

    private long lastModelUpdate;
    private TileEntityModelSettings settings = new TileEntityModelSettings();

    static
    {
        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Name", "blockbuster.fred");

        DEFAULT_MORPH = MorphManager.INSTANCE.morphFromNBT(tag);
    }

    public TileEntityModel()
    {
        this.morph.setDirect(MorphUtils.copy(getDefaultMorph()));

        this.lastModelUpdate = Scene.lastUpdate;
    }

    public TileEntityModel(float yaw)
    {
        this();

        this.settings.setRy(yaw);
    }

    /**
     * @return reference to this {@link #settings} object.
     */
    public TileEntityModelSettings getSettings()
    {
        return this.settings;
    }

    public static AbstractMorph getDefaultMorph()
    {
        return DEFAULT_MORPH;
    }

    @Override
    public Vector3d getRenderLastPos()
    {
        BlockPos blockPos = this.getPos();

        return new Vector3d(blockPos.getX() + this.settings.getX(),
                         blockPos.getY() + this.settings.getY(),
                         blockPos.getZ() + this.settings.getZ());
    }

    @Override
    public boolean shouldRenderInPass(int pass)
    {
        return super.shouldRenderInPass(pass) && !(this.settings.isRenderLast() && RenderingHandler.addRenderLast(this));
    }

    public void setMorph(AbstractMorph morph)
    {
        this.morph.set(morph);
        this.markDirty();
    }

    public void createEntity(World world)
    {
        if (world == null)
        {
            return;
        }

        this.entity = new EntityActor(world);
        this.entity.onGround = true;
        this.updateEntity();
    }

    public void updateEntity()
    {
        if (this.entity == null)
        {
            return;
        }

        for (int i = 0; i < this.settings.getSlots().length; i++)
        {
            this.entity.setItemStackToSlot(EntityEquipmentSlot.values()[i], this.settings.getSlots()[i]);
        }

        this.entity.posX = this.pos.getX() + this.settings.getX() + 0.5;
        this.entity.posY = this.pos.getY() + this.settings.getY();
        this.entity.posZ = this.pos.getZ() + this.settings.getZ() + 0.5;
    }

    @Override
    public void update()
    {
        if (this.entity == null)
        {
            this.createEntity(this.world);
        }

        if (this.entity != null && this.settings.isEnabled())
        {
            this.entity.ticksExisted++;
            this.entity.posX = this.pos.getX() + this.settings.getX() + 0.5;
            this.entity.posY = this.pos.getY() + this.settings.getY();
            this.entity.posZ = this.pos.getZ() + this.settings.getZ() + 0.5;

            if (!this.morph.isEmpty())
            {
                this.morph.get().update(this.entity);
            }
        }

        if (this.lastModelUpdate < Scene.lastUpdate && !this.settings.isExcludeResetPlayback())
        {
            if (this.world != null && !this.world.isRemote)
            {
                BlockPos pos = this.pos;
                PacketModifyModelBlock message = new PacketModifyModelBlock(pos, this);

                Dispatcher.DISPATCHER.get().sendToDimension(message, this.world.provider.getDimension());
            }

            this.lastModelUpdate = Scene.lastUpdate;
        }
    }

    /**
     * Infinite extend AABB allows to avoid frustum culling which can be 
     * used for some interesting things (like placing a whole OBJ level 
     * in the game)
     */
    @Override
    @SideOnly(Side.CLIENT)
    public AxisAlignedBB getRenderBoundingBox()
    {
        return TileEntity.INFINITE_EXTENT_AABB;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public double getMaxRenderDistanceSquared()
    {
        float range = Blockbuster.actorRenderingRange.get();

        return range * range;
    }

    /**
     * Dont refresh tile entity when blockstate changes - only when block changes
     * @param world
     * @param pos
     * @param oldState
     * @param newSate
     * @return
     */
    @Override
    public boolean shouldRefresh(World world, BlockPos pos, IBlockState oldState, IBlockState newSate)
    {
        return (oldState.getBlock() != newSate.getBlock());
    }

    /* NBT methods */

    /**
     * That's important too for 
     * {@link #onDataPacket(NetworkManager, SPacketUpdateTileEntity)} to 
     * fix the flower pot thing. 
     */
    @Override
    public NBTTagCompound getUpdateTag()
    {
        return this.writeToNBT(new NBTTagCompound());
    }

    @Override
    public SPacketUpdateTileEntity getUpdatePacket()
    {
        return new SPacketUpdateTileEntity(this.pos, this.getBlockMetadata(), this.getUpdateTag());
    }

    /**
     * This method fixes the old thing with flower pot thanks to asie!
     * 
     * @link https://www.reddit.com/r/feedthebeast/comments/b7h6fb/modders_what_embarrassingdirty_trick_did_you_do/ejtdydo/?context=3
     */
    @Override
    public void onDataPacket(NetworkManager net, SPacketUpdateTileEntity pkt)
    {
        this.readFromNBT(pkt.getNbtCompound());
    }

    public void copyData(TileEntityModel model, boolean merge)
    {
        this.settings.copy(model.settings);

        if (merge)
        {
            this.morph.set(model.morph.get());
        }
        else
        {
            this.morph.setDirect(model.morph.get());
        }

        this.updateEntity();
        this.markDirty();
    }

    @Override
    public NBTTagCompound writeToNBT(NBTTagCompound compound)
    {
        this.settings.toNBT(compound);

        if (!this.morph.isEmpty())
        {
            compound.setTag("Morph", this.morph.toNBT());
        }

        return super.writeToNBT(compound);
    }

    @Override
    public void readFromNBT(NBTTagCompound compound)
    {
        super.readFromNBT(compound);

        this.settings.fromNBT(compound);

        if (compound.hasKey("Morph", 10))
        {
            this.morph.setDirect(MorphManager.INSTANCE.morphFromNBT(compound.getCompoundTag("Morph")));
        }
    }

    public void fromBytes(ByteBuf buf)
    {
        this.settings.fromBytes(buf);

        this.morph.setDirect(MorphUtils.morphFromBuf(buf));
    }

    public void toBytes(ByteBuf buf)
    {
        this.settings.toBytes(buf);

        MorphUtils.morphToBuf(buf, this.morph.get());
    }
}

==================================================

--- Файл №304 ---
Путь: main\java\mchorse\blockbuster\common\tileentity\TileEntityModelSettings.java
--------------------
package mchorse.blockbuster.common.tileentity;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations.TransformOrientation;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueFloat;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueItemSlots;
import mchorse.mclib.config.values.ValueRotationOrder;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.mclib.network.INBTSerializable;
import mchorse.mclib.utils.ICopy;
import mchorse.mclib.utils.ITransformationObject;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.ValueSerializer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector4f;

public class TileEntityModelSettings implements IByteBufSerializable, INBTSerializable, ITransformationObject, ICopy<TileEntityModelSettings>
{
    private final ValueBoolean enabled = new ValueBoolean("enabled", true);
    private final ValueInt lightValue = new ValueInt("lightValue");
    private final ValueBoolean shadow = new ValueBoolean("shadow", true);
    private final ValueBoolean global = new ValueBoolean("global");
    private final ValueBoolean excludeResetPlayback = new ValueBoolean("excludeResetPlayback");
    private final ValueBoolean renderLast = new ValueBoolean("renderLast");
    private final ValueBoolean renderAlways = new ValueBoolean("renderAlways");
    private final ValueBoolean enableBlockHitbox = new ValueBoolean("enableBlockHitbox");
    private final ValueItemSlots slots = new ValueItemSlots("slots", 6);

    /* Entity rotations */
    private final ValueFloat rotateYawHead = new ValueFloat("rotateYawHead");
    private final ValueFloat rotatePitch = new ValueFloat("rotatePitch");
    private final ValueFloat rotateBody = new ValueFloat("rotateBody");

    /* Translation */
    private final ValueFloat x = new ValueFloat("x");
    private final ValueFloat y = new ValueFloat("y");
    private final ValueFloat z = new ValueFloat("z");

    /* Rotation */
    private final ValueRotationOrder order = new ValueRotationOrder("order", MatrixUtils.RotationOrder.ZYX);
    private final ValueFloat rx = new ValueFloat("rx");
    private final ValueFloat ry = new ValueFloat("ry");
    private final ValueFloat rz = new ValueFloat("rz");

    /* Scale */
    private final ValueBoolean uniform = new ValueBoolean("uniform");
    private final ValueFloat sx = new ValueFloat("sx",1);
    private final ValueFloat sy = new ValueFloat("sy",1);
    private final ValueFloat sz = new ValueFloat("sz",1);

    private ValueSerializer serializer = new ValueSerializer();

    public TileEntityModelSettings()
    {
        this.serializer.registerValue(this.enabled).serializeNBT("Enabled");
        this.serializer.registerValue(this.order).serializeNBT("Order");
        this.serializer.registerValue(this.rotateYawHead).serializeNBT("Yaw");
        this.serializer.registerValue(this.rotatePitch).serializeNBT("Pitch");
        this.serializer.registerValue(this.rotateBody).serializeNBT("Body");
        this.serializer.registerValue(this.x).serializeNBT("ShiftX");
        this.serializer.registerValue(this.y).serializeNBT("ShiftY");
        this.serializer.registerValue(this.z).serializeNBT("ShiftZ");
        this.serializer.registerValue(this.rx).serializeNBT("RotateX");
        this.serializer.registerValue(this.ry).serializeNBT("RotateY");
        this.serializer.registerValue(this.rz).serializeNBT("RotateZ");
        this.serializer.registerValue(this.uniform).serializeNBT("Scale");
        this.serializer.registerValue(this.sx).serializeNBT("ScaleX");
        this.serializer.registerValue(this.sy).serializeNBT("ScaleY");
        this.serializer.registerValue(this.sz).serializeNBT("ScaleZ");
        this.serializer.registerValue(this.shadow).serializeNBT("Shadow");
        this.serializer.registerValue(this.global).serializeNBT("Global");
        this.serializer.registerValue(this.slots).serializeNBT("Items");
        this.serializer.registerValue(this.lightValue).serializeNBT("LightValue");
        this.serializer.registerValue(this.renderLast).serializeNBT("RenderLast");
        this.serializer.registerValue(this.renderAlways).serializeNBT("RenderAlways");
        this.serializer.registerValue(this.enableBlockHitbox).serializeNBT("Hitbox");
        this.serializer.registerValue(this.excludeResetPlayback).serializeNBT("ExcludeResetPlayback");
    }

    public boolean isBlockHitbox()
    {
        return this.enableBlockHitbox.get();
    }

    public void setEnableBlockHitbox(boolean enableBlockHitbox)
    {
        this.enableBlockHitbox.set(enableBlockHitbox);
    }

    public int getLightValue()
    {
        return this.lightValue.get();
    }

    public void setLightValue(int lightValue)
    {
        this.lightValue.set(lightValue);
    }

    public boolean isExcludeResetPlayback()
    {
        return this.excludeResetPlayback.get();
    }

    public void setExcludeResetPlayback(boolean excludeResetPlayback)
    {
        this.excludeResetPlayback.set(excludeResetPlayback);
    }

    public boolean isRenderLast()
    {
        return this.renderLast.get();
    }

    public void setRenderLast(boolean renderLast)
    {
        this.renderLast.set(renderLast);
    }

    public boolean isRenderAlways()
    {
        return this.renderAlways.get();
    }

    public void setRenderAlways(boolean renderAlways)
    {
        this.renderAlways.set(renderAlways);
    }

    public ItemStack[] getSlots()
    {
        return slots.get();
    }

    public void setSlots(ItemStack[] slots)
    {
        this.slots.set(slots);
    }

    /**
     * Calls {@link ValueItemSlots#set(ItemStack, int)}, which copies the provided ItemStack
     * @param item
     * @param slot
     */
    public void setSlot(ItemStack item, int slot)
    {
        this.slots.set(item, slot);
    }

    public MatrixUtils.RotationOrder getOrder()
    {
        return this.order.get();
    }

    public void setOrder(MatrixUtils.RotationOrder order)
    {
        this.order.set(order);
    }

    public float getRotateYawHead()
    {
        return this.rotateYawHead.get();
    }

    public void setRotateYawHead(float rotateYawHead)
    {
        this.rotateYawHead.set(rotateYawHead);
    }

    public float getRotatePitch()
    {
        return rotatePitch.get();
    }

    public void setRotatePitch(float rotatePitch)
    {
        this.rotatePitch.set(rotatePitch);
    }

    public float getRotateBody()
    {
        return rotateBody.get();
    }

    public void setRotateBody(float rotateBody)
    {
        this.rotateBody.set(rotateBody);
    }

    public float getX()
    {
        return x.get();
    }

    public void setX(float x)
    {
        this.x.set(x);
    }

    public float getY()
    {
        return this.y.get();
    }

    public void setY(float y)
    {
        this.y.set(y);
    }

    public float getZ()
    {
        return this.z.get();
    }

    public void setZ(float z)
    {
        this.z.set(z);
    }

    /**
     * Add a translation on top of this translation.
     * @param x
     * @param y
     * @param z
     */
    @Override
    public void addTranslation(double x, double y, double z, TransformOrientation orientation)
    {
        Vector4f trans = new Vector4f((float) x, (float) y, (float) z, 1F);

        if (orientation == TransformOrientation.LOCAL)
        {
            float rotX = (float) Math.toRadians(this.getRx());
            float rotY = (float) Math.toRadians(this.getRy());
            float rotZ = (float) Math.toRadians(this.getRz());

            MatrixUtils.getRotationMatrix(rotX, rotY, rotZ, this.order.get()).transform(trans);
        }

        this.x.set(this.x.get() + trans.x);
        this.y.set(this.y.get() + trans.y);
        this.z.set(this.z.get() + trans.z);
    }

    public float getRx()
    {
        return this.rx.get();
    }

    public void setRx(float rx)
    {
        this.rx.set(rx);
    }

    public float getRy()
    {
        return this.ry.get();
    }

    public void setRy(float ry)
    {
        this.ry.set(ry);
    }

    public float getRz()
    {
        return this.rz.get();
    }

    public void setRz(float rz)
    {
        this.rz.set(rz);
    }

    public boolean isUniform()
    {
        return this.uniform.get();
    }

    public void setUniform(boolean uniform)
    {
        this.uniform.set(uniform);
    }

    public float getSx()
    {
        return this.sx.get();
    }

    public void setSx(float sx)
    {
        this.sx.set(sx);
    }

    public float getSy()
    {
        return this.sy.get();
    }

    public void setSy(float sy)
    {
        this.sy.set(sy);
    }

    public float getSz()
    {
        return this.sz.get();
    }

    public void setSz(float sz)
    {
        this.sz.set(sz);
    }

    public boolean isShadow()
    {
        return this.shadow.get();
    }

    public void setShadow(boolean shadow)
    {
        this.shadow.set(shadow);
    }

    public boolean isGlobal()
    {
        return this.global.get();
    }

    public void setGlobal(boolean global)
    {
        this.global.set(global);
    }

    public boolean isEnabled()
    {
        return this.enabled.get();
    }

    public void setEnabled(boolean enabled)
    {
        this.enabled.set(enabled);
    }

    @Override
    public TileEntityModelSettings copy()
    {
        TileEntityModelSettings copy = new TileEntityModelSettings();

        copy.copy(this);

        return copy;
    }

    @Override
    public void copy(TileEntityModelSettings settings)
    {
        this.serializer.copyValues(settings.serializer);
    }

    @Override
    public void fromBytes(ByteBuf byteBuf)
    {
        this.serializer.fromBytes(byteBuf);
    }

    @Override
    public void toBytes(ByteBuf byteBuf)
    {
        this.serializer.toBytes(byteBuf);
    }

    @Override
    public void fromNBT(NBTTagCompound nbtTagCompound)
    {
        this.serializer.fromNBT(nbtTagCompound);
    }

    @Override
    public NBTTagCompound toNBT(NBTTagCompound nbtTagCompound)
    {
        return this.serializer.toNBT(nbtTagCompound);
    }
}


==================================================

--- Файл №305 ---
Путь: main\java\mchorse\blockbuster\core\BBCoreClassTransformer.java
--------------------
package mchorse.blockbuster.core;

import mchorse.blockbuster.core.transformers.*;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

import java.util.Iterator;

public class BBCoreClassTransformer extends CoreClassTransformer
{
    private WorldTransformer world = new WorldTransformer();
    private RenderGlobalTransformer render = new RenderGlobalTransformer();
    private EntityRendererTransformer entityRenderer = new EntityRendererTransformer();
    private RenderPlayerTransformer playerTransformer = new RenderPlayerTransformer();
    private RenderItemTransformer renderItem = new RenderItemTransformer();
    private RenderEntityItemTransformer renderEntityItemTransformer = new RenderEntityItemTransformer();
    private EntityTransformer entity = new EntityTransformer();
    private EntityTransformationUtilsTransformer entityTransformationUtils = new EntityTransformationUtilsTransformer();
    private EntityItemTransformer entityItemTransformer = new EntityItemTransformer();
    private InventoryPlayerTransformer inventoryPlayerTransformer = new InventoryPlayerTransformer();

    @Override
    public byte[] transform(String name, String transformedName, byte[] basicClass)
    {
        if (checkName(name, "amu", "net.minecraft.world.World"))
        {
            System.out.println("BBCoreMod: Transforming World class (" + name + ")");

            return this.world.transform(name, basicClass);
        }
        else if (checkName(name, "cct", "net.minecraft.client.renderer.entity.RenderPlayer")){

            System.out.println("BBCoreMod: Transforming RenderPlayer class (" + name + ")");

            return this.playerTransformer.transform(name,basicClass);
        }
        else if (checkName(name, "buy", "net.minecraft.client.renderer.RenderGlobal"))
        {
            System.out.println("BBCoreMod: Transforming RenderGlobal class (" + name + ")");

            return this.render.transform(name, basicClass);
        }
        else if (checkName(name, "vg", "net.minecraft.entity.Entity"))
        {
            System.out.println("BBCoreMod: Transforming Entity class (" + name + ")");

            return this.entity.transform(name, basicClass);
        }
        else if (name.equals("mchorse.blockbuster.utils.EntityTransformationUtils"))
        {
            System.out.println("BBCoreMod: Transforming EntityTransformationUtils class (" + name + ")");

            return this.entityTransformationUtils.transform(name, basicClass);
        }
        else if (checkName(name, "buq", "net.minecraft.client.renderer.EntityRenderer"))
        {
            System.out.println("BBCoreMod: Transforming EntityRenderer class (" + name + ")");

            return this.entityRenderer.transform(name, basicClass);
        }
        else if (checkName(name, "bzw", "net.minecraft.client.renderer.RenderItem"))
        {
            System.out.println("BBCoreMod: Transforming RenderItem class (" + name + ")");

            return this.renderItem.transform(name, basicClass);
        }
        else if (checkName(name, "bzu", "net.minecraft.client.renderer.entity.RenderEntityItem"))
        {
            System.out.println("BBCoreMod: Transforming RenderItem class (" + name + ")");

            return this.renderEntityItemTransformer.transform(name, basicClass);
        }
        else if (checkName(name, "acl", "net.minecraft.entity.item.EntityItem"))
        {
            System.out.println("BBCoreMod: Transforming EntityItem class (" + name + ")");

            return this.entityItemTransformer.transform(name, basicClass);
        }
        else if (checkName(name, "aec", "net.minecraft.entity.player.InventoryPlayer"))
        {
            System.out.println("BBCoreMod: Transforming InventoryPlayer class (" + name + ")");

            return this.inventoryPlayerTransformer.transform(name, basicClass);
        }

        return basicClass;
    }

    public static void debugInstructions(InsnList list)
    {
        debugInstructions(list, Integer.MAX_VALUE);
    }

    public static void debugInstructions(InsnList list, int max)
    {
        Iterator<AbstractInsnNode> nodes = list.iterator();

        int i = 0;

        while (nodes.hasNext())
        {
            AbstractInsnNode node = nodes.next();

            System.out.println("Offset: " + i + " " + node.getClass().getSimpleName() + " " + debugNode(node));

            if (i >= max)
            {
                break;
            }

            i++;
        }
    }

    public static String debugNode(AbstractInsnNode node)
    {
        if (node instanceof LabelNode)
        {
            return "label " + ((LabelNode) node).getLabel().toString();
        }
        else if (node instanceof LineNumberNode)
        {
            return "line " + String.valueOf(((LineNumberNode) node).line);
        }
        else if (node instanceof MethodInsnNode)
        {
            MethodInsnNode method = (MethodInsnNode) node;

            return method.getOpcode() + " " + method.owner + "." + method.name + ":" + method.desc;
        }
        else if (node instanceof FieldInsnNode)
        {
            FieldInsnNode field = (FieldInsnNode) node;

            return field.getOpcode() + " " + field.owner + "." + field.name + ":" + field.desc;
        }
        else if (node instanceof VarInsnNode)
        {
            VarInsnNode var = (VarInsnNode) node;

            return "opcode " + var.getOpcode() + " var " + var.var;
        }
        else if (node instanceof LdcInsnNode)
        {
            LdcInsnNode ldc = (LdcInsnNode) node;

            return "LDC " + ldc.cst.toString();
        }

        return "opcode " + String.valueOf(node.getOpcode());
    }
}

==================================================

--- Файл №306 ---
Путь: main\java\mchorse\blockbuster\core\BBCoreMod.java
--------------------
package mchorse.blockbuster.core;

import java.util.Map;

import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin;
import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin.MCVersion;
import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin.Name;
import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin.SortingIndex;

@Name("BlockbusterCore")
@MCVersion("1.12.2")
@SortingIndex(1)
public class BBCoreMod implements IFMLLoadingPlugin
{
    @Override
    public String[] getASMTransformerClass()
    {
        return new String[] {BBCoreClassTransformer.class.getName()};
    }

    @Override
    public String getModContainerClass()
    {
        return BBCoreModInfo.class.getName();
    }

    @Override
    public String getSetupClass()
    {
        return null;
    }

    @Override
    public void injectData(Map<String, Object> data)
    {}

    @Override
    public String getAccessTransformerClass()
    {
        return null;
    }
}

==================================================

--- Файл №307 ---
Путь: main\java\mchorse\blockbuster\core\BBCoreModInfo.java
--------------------
package mchorse.blockbuster.core;

import net.minecraftforge.fml.common.DummyModContainer;

public class BBCoreModInfo extends DummyModContainer
{
    @Override
    public String getName()
    {
        return "Blockbuster Core mod";
    }

    @Override
    public String getModId()
    {
        return "blockbuster_core";
    }

    @Override
    public Object getMod()
    {
        return null;
    }

    @Override
    public String getVersion()
    {
        return "%VERSION%";
    }
}

==================================================

--- Файл №308 ---
Путь: main\java\mchorse\blockbuster\core\transformers\EntityItemTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassMethodTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

import java.util.Iterator;

public class EntityItemTransformer extends ClassMethodTransformer
{
    public EntityItemTransformer()
    {
        /*
         * insert a hook right before item is added and forge's item pickup event is called
         * this is used to prevent item pick up during first person playback
         */
        this.setMcp("onCollideWithPlayer", "(Lnet/minecraft/entity/player/EntityPlayer;)V");
        this.setNotch("d", "(Laed;)V");
    }

    @Override
    public void processMethod(String name, MethodNode method)
    {
        InsnList list = method.instructions;
        Iterator<AbstractInsnNode> it = list.iterator();

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node instanceof VarInsnNode)
            {
                VarInsnNode varInsnNode = (VarInsnNode) node;

                /*
                 * ItemStack clone = itemstack.copy(); is stored at place 6
                 * this is right before item is added to inventory in the if statement
                 */
                if (varInsnNode.getOpcode() == Opcodes.ASTORE && varInsnNode.var == 6)
                {
                    VarInsnNode loadEntityPlayerArg = new VarInsnNode(Opcodes.ALOAD, 1);

                    /* load itemStack variable (ItemStack itemStack = this.getItem();*/
                    VarInsnNode loadItemStack = new VarInsnNode(Opcodes.ALOAD, 2);
                    String itemStackClassName = CoreClassTransformer.get("Laed;Laip;", "Lnet/minecraft/entity/player/EntityPlayer;Lnet/minecraft/item/ItemStack;");

                    method.instructions.insert(varInsnNode, loadEntityPlayerArg);
                    method.instructions.insert(loadEntityPlayerArg, loadItemStack);
                    method.instructions.insert(loadItemStack, new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/events/PlayerHandler", "beforePlayerItemPickUp", "(" + itemStackClassName + ")V", false));

                    System.out.println("BBCoreMod: successfully patched EntityItem!");

                    return;
                }
            }
        }
    }
}


==================================================

--- Файл №309 ---
Путь: main\java\mchorse\blockbuster\core\transformers\EntityRendererTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassMethodTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

import java.util.Iterator;

public class EntityRendererTransformer extends ClassMethodTransformer
{
    public EntityRendererTransformer()
    {
        super();

        this.setMcp("renderWorldPass", "(IFJ)V");
        this.setNotch("a", "(IFJ)V");
    }

    @Override
    public void processMethod(String s, MethodNode methodNode)
    {
        AbstractInsnNode renderLitNode = null;
        AbstractInsnNode renderNode = null;

        String owner = CoreClassTransformer.obfuscated ? "btg" : "net/minecraft/client/particle/ParticleManager";
        String renderLit = CoreClassTransformer.obfuscated ? "b" : "renderLitParticles";
        String render = CoreClassTransformer.obfuscated ? "a" : "renderParticles";
        String desc = CoreClassTransformer.obfuscated ? "(Lvg;F)V" : "(Lnet/minecraft/entity/Entity;F)V";

        /* Find these alive */
        Iterator<AbstractInsnNode> it = methodNode.instructions.iterator();

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node.getOpcode() == Opcodes.INVOKEVIRTUAL)
            {
                MethodInsnNode invoke = (MethodInsnNode) node;

                if (invoke.owner.equals(owner) && invoke.desc.equals(desc))
                {
                    if (invoke.name.equals(renderLit))
                    {
                        renderLitNode = node;
                    }
                    else if (invoke.name.equals(render))
                    {
                        renderNode = node;
                    }
                }
            }
        }

        if (renderLitNode != null && renderNode != null)
        {
            InsnList renderLitList = new InsnList();
            InsnList rendeList = new InsnList();

            renderLitList.add(new VarInsnNode(Opcodes.FLOAD, 2));
            renderLitList.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "renderLitParticles", "(F)V", false));
            rendeList.add(new VarInsnNode(Opcodes.FLOAD, 2));
            rendeList.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "renderParticles", "(F)V", false));

            methodNode.instructions.insert(renderLitNode, renderLitList);
            methodNode.instructions.insert(renderNode, rendeList);

            System.out.println("BBCoreMod: successfully patched renderWorldPass!");
        }
        else
        {
            System.out.println("BBCoreMod: failed to find particle nodes: " + renderLitNode + " and " +renderNode);
        }
    }
}

==================================================

--- Файл №310 ---
Путь: main\java\mchorse\blockbuster\core\transformers\EntityTransformationUtilsTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

import java.util.Iterator;

public class EntityTransformationUtilsTransformer extends ClassTransformer
{
    @Override
    public void process(String s, ClassNode node)
    {
        for (MethodNode method : node.methods)
        {
            String entityDesc = "Lnet/minecraft/entity/Entity;";

            if (method.name.equals("getPrevPrevPosX") && method.desc.equals("("+entityDesc+")D"))
            {
                this.processGetPrevPrevPos(method, "X");
            }
            else if (method.name.equals("getPrevPrevPosY") && method.desc.equals("("+entityDesc+")D"))
            {
                this.processGetPrevPrevPos(method, "Y");
            }
            else if (method.name.equals("getPrevPrevPosZ") && method.desc.equals("("+entityDesc+")D"))
            {
                this.processGetPrevPrevPos(method, "Z");
            }
        }

        System.out.println("BBCoreMod: successfully patched EntityTransformationUtils!");
    }

    public void processGetPrevPrevPos(MethodNode method, String axis)
    {
        Iterator<AbstractInsnNode> it = method.instructions.iterator();
        AbstractInsnNode target = null;
        int index = -1;

        while (it.hasNext())
        {
            index++;
            AbstractInsnNode node = it.next();

            if (node instanceof InsnNode)
            {
                if (node.getOpcode() == Opcodes.DCONST_0)
                {
                    target = node;

                    break;
                }
            }
        }

        method.instructions.remove(target);

        target =  method.instructions.get(index-1);
        InsnList list = new InsnList();

        list.add(new VarInsnNode(Opcodes.ALOAD, 0));
        list.add(new FieldInsnNode(Opcodes.GETFIELD, CoreClassTransformer.get("vg", "net/minecraft/entity/Entity"), "prevPrevPos"+axis, "D"));
        method.instructions.insert(target, list);

        System.out.println("BBCoreMod: successfully patched getPrevPrevPos"+axis+"!");
    }
}


==================================================

--- Файл №311 ---
Путь: main\java\mchorse\blockbuster\core\transformers\EntityTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

/**
 * This patches the entity to save the position before the previous position.
 * The reason for this is to be able to calculate acceleration - the difference of previous velocity and current velocity
 * @author Christian F. (known as Chryfi)
 */

public class EntityTransformer extends ClassTransformer
{

    @Override
    public void process(String s, ClassNode node)
    {
        FieldNode prevPrevPosX = new FieldNode(Opcodes.ASM4, Opcodes.ACC_PUBLIC, "prevPrevPosX", "D", null, null);
        FieldNode prevPrevPosY = new FieldNode(Opcodes.ASM4, Opcodes.ACC_PUBLIC, "prevPrevPosY", "D", null, null);
        FieldNode prevPrevPosZ = new FieldNode(Opcodes.ASM4, Opcodes.ACC_PUBLIC, "prevPrevPosZ", "D", null, null);
        
        node.fields.add(prevPrevPosX);
        node.fields.add(prevPrevPosY);
        node.fields.add(prevPrevPosZ);

        for (MethodNode method : node.methods)
        {
            String methodName = this.checkName(method, "Y", "()V", "onEntityUpdate", "()V");

            if (methodName != null)
            {
                this.processOnEntityUpdate(method);

                break;
            }
        }
        
        System.out.println("BBCoreMod: successfully patched Entities!");
    }

    public void processOnEntityUpdate(MethodNode method)
    {
        InsnList list = new InsnList();
        String entity = CoreClassTransformer.get("vg", "net/minecraft/entity/Entity");
        String prevPosX = CoreClassTransformer.get("m", "prevPosX");
        String prevPosY = CoreClassTransformer.get("n", "prevPosY");
        String prevPosZ = CoreClassTransformer.get("o", "prevPosZ");

        buildFieldAssignmentInsn(list, entity, prevPosX, "prevPrevPosX");
        buildFieldAssignmentInsn(list, entity, prevPosY, "prevPrevPosY");
        buildFieldAssignmentInsn(list, entity, prevPosZ, "prevPrevPosZ");

        method.instructions.insert(this.getFirstLabel(method), list);

        System.out.println("BBCoreMod: successfully patched onEntityUpdate!");
    }

    public void buildFieldAssignmentInsn(InsnList list, String owner, String get, String put)
    {
        list.add(new VarInsnNode(Opcodes.ALOAD, 0));
        list.add(new VarInsnNode(Opcodes.ALOAD, 0));
        list.add(new FieldInsnNode(Opcodes.GETFIELD, owner, get, "D"));
        list.add(new FieldInsnNode(Opcodes.PUTFIELD, owner, put, "D"));
    }
}

==================================================

--- Файл №312 ---
Путь: main\java\mchorse\blockbuster\core\transformers\InventoryPlayerTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassMethodTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import net.minecraft.item.ItemStack;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;
import org.objectweb.asm.Opcodes;

import java.util.Iterator;

public class InventoryPlayerTransformer extends ClassMethodTransformer
{
    public InventoryPlayerTransformer()
    {
        /* insert a hook before and after something is added to inventory */
        this.setMcp("addItemStackToInventory", "(Lnet/minecraft/item/ItemStack;)Z");
        this.setNotch("e", "(Laip;)Z");
    }

    @Override
    public void processMethod(String name, MethodNode method)
    {
        InsnList list = method.instructions;
        Iterator<AbstractInsnNode> it = list.iterator();
        String inventoryPlayerClassName = CoreClassTransformer.get("Laec;", "Lnet/minecraft/entity/player/InventoryPlayer;");

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            /* only call in this method is this.add(...) -> search for ALOAD of this*/
            if (node instanceof VarInsnNode && node.getOpcode() == Opcodes.ALOAD && ((VarInsnNode) node).var == 0)
            {
                MethodInsnNode beforeEvent = new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/events/PlayerHandler", "beforeItemStackAdd", "(" + inventoryPlayerClassName + ")V", false);
                MethodInsnNode afterEvent = new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/events/PlayerHandler", "afterItemStackAdd", "(" + inventoryPlayerClassName + ")V", false);

                InsnList preInstructions = new InsnList();
                InsnList postInstructions = new InsnList();

                preInstructions.add(beforeEvent);
                preInstructions.add(new VarInsnNode(Opcodes.ALOAD, 0));

                postInstructions.add(new VarInsnNode(Opcodes.ISTORE, 2));
                postInstructions.add(new VarInsnNode(Opcodes.ALOAD, 0));
                postInstructions.add(afterEvent);
                postInstructions.add(new VarInsnNode(Opcodes.ILOAD, 2));

                method.instructions.insert(node, preInstructions);

                /* go to method call of this.add() */
                while (it.hasNext())
                {
                    AbstractInsnNode node2 = it.next();

                    if (node2 instanceof MethodInsnNode && node2.getOpcode() == Opcodes.INVOKEVIRTUAL)
                    {
                        method.instructions.insert(node2, postInstructions);

                        System.out.println("BBCoreMod: successfully patched InventoryPlayer!");

                        return;
                    }
                }
            }
        }
    }
}


==================================================

--- Файл №313 ---
Путь: main\java\mchorse\blockbuster\core\transformers\RenderEntityItemTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class RenderEntityItemTransformer extends ClassTransformer
{
    @Override
    public void process(String s, ClassNode classNode) {
        for (MethodNode method : classNode.methods) {
            String methodName = this.checkName(method, "a", "(Lvg;DDDFF)V", "doRender", "(Lnet/minecraft/entity/item/EntityItem;DDDFF)V");
            if (methodName != null) {
                this.processMethod(methodName, method);
            }
        }
    }
    public void processMethod(String methodName, MethodNode method)
    {
        InsnList list = new InsnList();
        list.add(new FieldInsnNode(Opcodes.GETSTATIC, "net/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType", "GROUND", "Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;"));
        list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "setTSRTTransform", "(Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;)V", false));
        method.instructions.insert(list);
    }
}

==================================================

--- Файл №314 ---
Путь: main\java\mchorse\blockbuster\core\transformers\RenderGlobalTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.LocalVariableNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

import java.util.Iterator;

public class RenderGlobalTransformer extends ClassTransformer
{
    @Override
    public void process(String name, ClassNode node)
    {
        for (MethodNode method : node.methods)
        {
            String methodName = this.checkName(method, "a", "(FI)V", "renderSky", "(FI)V");

            if (methodName != null)
            {
                this.processRenderSky(method);
            }

            methodName = this.checkName(method, "a", "(FIDDD)V", "renderClouds", "(FIDDD)V");

            if (methodName != null)
            {
                this.processRenderClouds(method);
            }

            methodName = this.checkName(method, "a", "(Lvg;Lbxy;F)V", "renderEntities", "(Lnet/minecraft/entity/Entity;Lnet/minecraft/client/renderer/culling/ICamera;F)V");

            if (methodName != null)
            {
                this.processRenderEntities(method);
            }
        }
    }

    private void processRenderSky(MethodNode method)
    {
        LabelNode label = this.getFirstLabel(method);

        if (label != null)
        {
            InsnList list = new InsnList();

            list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "isGreenSky", "()Z", false));
            list.add(new JumpInsnNode(Opcodes.IFEQ, label));
            list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "renderGreenSky", "()V", false));
            list.add(new InsnNode(Opcodes.RETURN));

            method.instructions.insert(list);

            System.out.println("BBCoreMod: successfully patched renderSky!");
        }
    }

    private void processRenderClouds(MethodNode method)
    {
        LabelNode label = this.getFirstLabel(method);

        if (label != null)
        {
            InsnList list = new InsnList();

            list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "isGreenSky", "()Z", false));
            list.add(new JumpInsnNode(Opcodes.IFEQ, label));
            list.add(new InsnNode(Opcodes.RETURN));

            method.instructions.insert(list);

            System.out.println("BBCoreMod: successfully patched renderClouds!");
        }
    }

    private void processRenderEntities(MethodNode method)
    {
        LabelNode releaseLabel = null;
        LabelNode renderEntityLabel = null;
        LabelNode lastLabel = null;
        boolean captureNext = false;
        int renderCounter = 0;
        Iterator<AbstractInsnNode> it = method.instructions.iterator();
        boolean insertedRenderLastCall = false;
        boolean foundAllForAddEntitiesHook = false;

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (!foundAllForAddEntitiesHook && node instanceof LabelNode)
            {
                lastLabel = (LabelNode) node;

                if (captureNext && renderEntityLabel == null)
                {
                    renderEntityLabel = lastLabel;
                    captureNext = false;
                }
            }

            if (node instanceof MethodInsnNode)
            {
                MethodInsnNode methodInsnNode = (MethodInsnNode) node;

                if (!foundAllForAddEntitiesHook)
                {
                    if (CoreClassTransformer.checkName(methodInsnNode.owner, "bzf", "net/minecraft/client/renderer/entity/RenderManager")
                            && CoreClassTransformer.checkName(methodInsnNode.name, "a", "renderEntityStatic")
                            && CoreClassTransformer.checkName(methodInsnNode.desc, "(Lvg;FZ)V", "(Lnet/minecraft/entity/Entity;FZ)V"))
                    {
                        if (renderCounter == 1)
                        {
                            captureNext = true;
                        }

                        renderCounter += 1;
                    }

                    if (CoreClassTransformer.checkName(methodInsnNode.owner, "et$b", "net/minecraft/util/math/BlockPos$PooledMutableBlockPos")
                            && CoreClassTransformer.checkName(methodInsnNode.name, "t", "release")
                            && methodInsnNode.desc.equals("()V"))
                    {
                        releaseLabel = lastLabel;

                        foundAllForAddEntitiesHook = true;
                    }
                }

                /* this should indicate the end of the method renderEntities (postRenderDamagedBlocks is the 3rd method before end) */
                if (CoreClassTransformer.checkName(methodInsnNode.owner, "buy", "net/minecraft/client/renderer/RenderGlobal")
                    && CoreClassTransformer.checkName(methodInsnNode.name, "v", "postRenderDamagedBlocks")
                    && methodInsnNode.desc.equals("()V"))
                {
                    /* Render last entities after postRenderDamagedBlocks to avoid OpenGL states that were meant for damagedBlocks */
                    method.instructions.insert(methodInsnNode, new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "renderLastEntities", "()V", false));

                    insertedRenderLastCall = true;

                    break;
                }
            }
        }

        if (renderEntityLabel != null && releaseLabel != null)
        {
            /* In non-Optifine Minecraft, the index of the entity variable is 27,
             * however due to Optifine modifications, it's another index, but it
             * should be the last local variable... */
            final String entity = CoreClassTransformer.get("Lvg;", "Lnet/minecraft/entity/Entity;");
            int localIndex = 0;

            for (LocalVariableNode var : method.localVariables)
            {
                if (var.desc.equals(entity))
                {
                    localIndex = Math.max(localIndex, var.index);
                }
            }

            /* Add render entity */
            InsnList list = new InsnList();

            list.add(new VarInsnNode(Opcodes.ALOAD, localIndex));
            list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "addRenderedEntity", "(" + entity + ")V", false));

            /* avoid memory leak - if renderLast method is not called, the list of rendered entities would not be cleared */
            if (insertedRenderLastCall)
            {
                method.instructions.insert(renderEntityLabel, list);

                System.out.println("BBCoreMod: successfully patched renderEntities!");
            }
        }
    }
}

==================================================

--- Файл №315 ---
Путь: main\java\mchorse\blockbuster\core\transformers\RenderItemTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import mchorse.blockbuster.utils.mclib.coremod.ClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.*;

import java.util.Iterator;

public class RenderItemTransformer extends ClassTransformer
{

    @Override
    public void process(String s, ClassNode classNode)
    {
        for (MethodNode method : classNode.methods)
        {
            String methodName = this.checkName(method, "a", "(Laip;Lvp;Lbwc$b;Z)V", "renderItem", "(Lnet/minecraft/item/ItemStack;Lnet/minecraft/entity/EntityLivingBase;Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;Z)V");
            
            if (methodName != null)
            {
                this.processRenderItemMethod(methodName,method);
            }

            methodName = this.checkName(method,"a","(Laip;Lcfy;Lbwc$b;Z)V","renderItemModel", "(Lnet/minecraft/item/ItemStack;Lnet/minecraft/client/renderer/block/model/IBakedModel;Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;Z)V");
            
            if (methodName != null)
            {
                this.processRenderItemModel(methodName,method);
            }
            
            methodName = this.checkName(method,"a","(Laip;Lbwc$b;)V","renderItem", "(Lnet/minecraft/item/ItemStack;Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;)V");
            
            if (methodName != null)
            {
                this.processRenderItem(methodName,method);
            }
            
            methodName = this.checkName(method,"a","(Laip;IILcfy;)V","renderItemModelIntoGUI", "(Lnet/minecraft/item/ItemStack;IILnet/minecraft/client/renderer/block/model/IBakedModel;)V");
            
            if (methodName != null)
            {
                this.processRenderItemModelInGUI(methodName,method);
            }
        }
    }

    public void processRenderItemMethod(String methodName, MethodNode method)
    {
        String entity = CoreClassTransformer.obfuscated ? "Lvp;" : "Lnet/minecraft/entity/EntityLivingBase;";
        String transform = CoreClassTransformer.obfuscated ? "Lbwc$b;" : "Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;";
        InsnList before = new InsnList();

        before.add(new VarInsnNode(Opcodes.ALOAD, 2));
        before.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "setLastItemHolder", "(" + entity + ")V", false));

        method.instructions.insert(before);
        InsnList midle = new InsnList();
        midle.add(new VarInsnNode(Opcodes.ALOAD, 3));
        midle.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler",
                "setTSRTTransform", "(" + transform+ ")V", false));
        method.instructions.insert(midle);
        InsnList after = new InsnList();

        after.add(new VarInsnNode(Opcodes.ALOAD, 2));
        after.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "resetLastItemHolder", "(" + entity + ")V", false));


        AbstractInsnNode target = null;
        Iterator<AbstractInsnNode> it = method.instructions.iterator();

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node.getOpcode() == Opcodes.RETURN)
            {
                target = node;

                break;
            }
        }

        if (target != null)
        {
            method.instructions.insertBefore(target, after);

            System.out.println("BBCoreMod: successfully patched renderItem!");
        }
    }

    public void processRenderItem(String methodName, MethodNode method)
    {
        String transform = CoreClassTransformer.obfuscated ? "Lbwc$b;" : "Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;";
        InsnList before = new InsnList();
        before.add(new VarInsnNode(Opcodes.ALOAD, 2));
        before.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler",
                "setTSRTTransform", "(" + transform+ ")V", false));
        method.instructions.insert(before);
    }

    public void processRenderItemModel(String methodName, MethodNode method)
    {
        String transform = CoreClassTransformer.obfuscated ? "Lbwc$b;" : "Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;";
        InsnList before = new InsnList();
        before.add(new VarInsnNode(Opcodes.ALOAD, 3));
        before.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler",
                "setTSRTTransform", "(" + transform+ ")V", false));
        method.instructions.insert(before);
    }

    public void processRenderItemModelInGUI(String methodName, MethodNode method)
    {
        InsnList list = new InsnList();
        list.add(new FieldInsnNode(Opcodes.GETSTATIC, "net/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType", "GUI", "Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;"));
        list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "setTSRTTransform", "(Lnet/minecraft/client/renderer/block/model/ItemCameraTransforms$TransformType;)V", false));
        method.instructions.insert(list);
    }

}

==================================================

--- Файл №316 ---
Путь: main\java\mchorse\blockbuster\core\transformers\RenderPlayerTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import mchorse.blockbuster.utils.mclib.coremod.ClassMethodTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

import java.util.Iterator;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class RenderPlayerTransformer extends ClassMethodTransformer
{
    public RenderPlayerTransformer()
    {
        super();

        this.setMcp("setModelVisibilities", "(Lnet/minecraft/client/entity/AbstractClientPlayer;)V");
        this.setNotch("d", "(Lbua;)V");
    }

    @Override
    public void processMethod(String name, MethodNode method)
    {
        String player = CoreClassTransformer.obfuscated ? "Lbua;" : "Lnet/minecraft/client/entity/AbstractClientPlayer;";
        String model = CoreClassTransformer.obfuscated ? "Lbqj;" : "Lnet/minecraft/client/model/ModelPlayer;";
        //INSTRUCTIONS
        InsnList list = new InsnList();
        list.add(new VarInsnNode(Opcodes.ALOAD, 1));
        list.add(new VarInsnNode(Opcodes.ALOAD, 2));
        list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/client/RenderingHandler", "changePlayerHand", "(" + player + "" + model + ")V", false));
        //INSTRUCTION ITERATIONS
        Iterator<AbstractInsnNode> it = method.instructions.iterator();
        AbstractInsnNode target = null;
        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node.getOpcode() == Opcodes.RETURN)
            {
                target = node;
                break;
            }
        }
        //INVOKING
        if (target != null)
        {
            method.instructions.insertBefore(target, list);
        }
    }
}

==================================================

--- Файл №317 ---
Путь: main\java\mchorse\blockbuster\core\transformers\WorldTransformer.java
--------------------
package mchorse.blockbuster.core.transformers;

import java.util.Iterator;

import mchorse.blockbuster.utils.mclib.coremod.ClassMethodTransformer;
import mchorse.blockbuster.utils.mclib.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.VarInsnNode;

public class WorldTransformer extends ClassMethodTransformer
{
    public WorldTransformer()
    {
        this.setMcp("setBlockState", "(Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/state/IBlockState;I)Z");
        this.setNotch("a", "(Let;Lawt;I)Z");
    }

    @Override
    public void processMethod(String name, MethodNode method)
    {
        InsnList list = method.instructions;
        Iterator<AbstractInsnNode> it = list.iterator();
        int i = 0;

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node.getOpcode() == Opcodes.IRETURN)
            {
                i++;

                continue;
            }

            if (i == 2)
            {
                InsnList newList = new InsnList();
                String desc = CoreClassTransformer.get("(Lamu;Let;Lawt;I)V", "(Lnet/minecraft/world/World;Lnet/minecraft/util/math/BlockPos;Lnet/minecraft/block/state/IBlockState;I)V");

                newList.add(new VarInsnNode(Opcodes.ALOAD, 0));
                newList.add(new VarInsnNode(Opcodes.ALOAD, 1));
                newList.add(new VarInsnNode(Opcodes.ALOAD, 2));
                newList.add(new VarInsnNode(Opcodes.ILOAD, 3));
                newList.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/blockbuster/recording/capturing/WorldEventListener", "setBlockState", desc, false));
                list.insert(node, newList);

                System.out.println("BBCoreMod: successfully patched setBlockState!");

                break;
            }
        }
    }
}


==================================================

--- Файл №318 ---
Путь: main\java\mchorse\blockbuster\events\ActionPanelRegisterEvent.java
--------------------
package mchorse.blockbuster.events;

import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordingEditorPanel;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.actions.GuiActionPanel;
import mchorse.blockbuster.recording.actions.Action;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class ActionPanelRegisterEvent extends Event
{
    public GuiRecordingEditorPanel panel;

    public ActionPanelRegisterEvent(GuiRecordingEditorPanel panel)
    {
        this.panel = panel;
    }

    public void register(Class<? extends Action> action, GuiActionPanel<? extends Action> panel)
    {
        this.panel.panels.put(action, panel);
    }
}

==================================================

--- Файл №319 ---
Путь: main\java\mchorse\blockbuster\events\GunShootHandler.java
--------------------
package mchorse.blockbuster.events;

import java.lang.reflect.Field;

import mchorse.blockbuster.client.KeyboardHandler;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketGunInteract;
import mchorse.blockbuster.network.common.guns.PacketGunReloading;
import mchorse.blockbuster.utils.NBTUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.Phase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */

public class GunShootHandler
{
    private boolean canBeShotPress = true;
    private boolean canBeReloaded = true;
    private Field leftClickCounter = null;

    @SideOnly(Side.CLIENT)
    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onTick(TickEvent.ClientTickEvent event)
    {
        if (event.phase != TickEvent.Phase.END)
        {
            return;
        }

        Minecraft mc = Minecraft.getMinecraft();

        if (mc.player == null)
        {
            return;
        }

        ItemStack stack = mc.player.getHeldItemMainhand();

        if (stack.getItem() instanceof ItemGun)
        {
            this.blockLeftClick(mc);
            this.handleShootKey(mc, stack);
            this.handleReloading(mc, stack);
        }
    }

    @SideOnly(Side.CLIENT)
    private void handleShootKey(Minecraft mc, ItemStack stack)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (KeyboardHandler.gunShoot.isKeyDown())
        {
            if (canBeShotPress && props.storedShotDelay == 0 && props.state == ItemGun.GunState.READY_TO_SHOOT)
            {
                Dispatcher.sendToServer(new PacketGunInteract(stack, mc.player.getEntityId()));

                canBeShotPress = false;

                return;
            }

            if (props.storedShotDelay == 0 && props.shootWhenHeld)
            {
                canBeShotPress = true;
            }
        }
        else
        {
            canBeShotPress = true;
        }
    }

    @SideOnly(Side.CLIENT)
    private void handleReloading(Minecraft mc, ItemStack stack)
    {
        GunProps props = NBTUtils.getGunProps(stack);

        if (KeyboardHandler.gunReload.isKeyDown() && canBeReloaded && props.state == ItemGun.GunState.READY_TO_SHOOT)
        {
            Dispatcher.sendToServer(new PacketGunReloading(stack, mc.player.getEntityId()));

            canBeReloaded = false;
        }
        else
        {
            canBeReloaded = true;
        }
    }

    @SideOnly(Side.CLIENT)
    private void blockLeftClick(Minecraft mc)
    {
        if (KeyboardHandler.gunShoot.conflicts(mc.gameSettings.keyBindAttack))
        {
            if (leftClickCounter == null)
            {
                try
                {
                    leftClickCounter = Minecraft.class.getDeclaredField("field_71429_W");
                    leftClickCounter.setAccessible(true);
                }
                catch (NoSuchFieldException | SecurityException e)
                {
                    try
                    {
                        leftClickCounter = Minecraft.class.getDeclaredField("leftClickCounter");
                        leftClickCounter.setAccessible(true);
                    }
                    catch (NoSuchFieldException | SecurityException e1)
                    {}
                }
            }

            try
            {
                this.leftClickCounter.setInt(mc, 10000);
            }
            catch (IllegalArgumentException | IllegalAccessException e)
            {}
        }
    }
}

==================================================

--- Файл №320 ---
Путь: main\java\mchorse\blockbuster\events\PlayerHandler.java
--------------------
package mchorse.blockbuster.events;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.SkinHandler;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer;
import mchorse.blockbuster.client.textures.GifTexture;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.InventoryPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumActionResult;
import net.minecraft.util.NonNullList;
import net.minecraftforge.event.entity.living.LivingAttackEvent;
import net.minecraftforge.event.entity.living.LivingEvent;
import net.minecraftforge.event.entity.player.PlayerInteractEvent;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.Phase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Iterator;
import java.util.Map;
import java.util.function.Function;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class PlayerHandler
{
    private Function<GunProps, Boolean> leftHandler = (props) -> props.preventLeftClick;
    private Function<GunProps, Boolean> rightHandler = (props) -> props.preventRightClick;
    private Function<GunProps, Boolean> attackHandler = (props) -> props.preventEntityAttack;

    private int timer;
    private int skinsTimer;

    private static NonNullList<ItemStack> mainInventoryBefore = NonNullList.withSize(36, ItemStack.EMPTY);

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onLivingAttack(LivingAttackEvent event)
    {
        Entity source = event.getSource().getTrueSource();

        if (source instanceof EntityPlayer)
        {
            this.handle((EntityPlayer) source, event, attackHandler);
        }
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerInteract(PlayerInteractEvent.LeftClickBlock event)
    {
        this.handle(event.getEntityPlayer(), event, leftHandler);
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerInteract(PlayerInteractEvent.EntityInteract event)
    {
        this.handle(event.getEntityPlayer(), event, rightHandler);
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerInteract(PlayerInteractEvent.RightClickBlock event)
    {
        this.handle(event.getEntityPlayer(), event, rightHandler);
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerInteract(PlayerInteractEvent.RightClickItem event)
    {
        this.handle(event.getEntityPlayer(), event, rightHandler);
    }

    private static void preventItemPickUpScenePlayback(InventoryPlayer inventoryPlayer)
    {
        for (Map.Entry<String, Scene> scene : CommonProxy.scenes.getScenes().entrySet())
        {
            for (EntityPlayer player : scene.getValue().getTargetPlaybackPlayers())
            {
                if (player.inventory == inventoryPlayer)
                {
                    preventItemPickUp(player);
                }
            }
        }
    }

    /**
     * Reset the inventory to what it was before the item was picked up.
     * This also absorbs the dropped item
     */
    public static void preventItemPickUp(EntityPlayer player)
    {
        for (int i = 0; i < player.inventory.mainInventory.size(); i++)
        {
            ItemStack itemStackNow = player.inventory.mainInventory.get(i);
            ItemStack itemStackBefore = mainInventoryBefore.get(i);

            if (!ItemStack.areItemStacksEqual(itemStackNow, itemStackBefore))
            {
                player.inventory.mainInventory.set(i, itemStackBefore);
            }
        }
    }

    /**
     * Called by ASM {@link mchorse.blockbuster.core.transformers.EntityItemTransformer}
     * before item pick up event is fired and before the item is added to the inventory
     * @param entity
     * @param itemStack
     */
    public static void beforePlayerItemPickUp(EntityPlayer entity, ItemStack itemStack)
    {
    }

    /**
     * Called by ASM {@link mchorse.blockbuster.core.transformers.InventoryPlayerTransformer}
     * before an item is added to inventory in {@link InventoryPlayer}
     * @param inventory the inventory where this method is called from
     */
    public static void beforeItemStackAdd(InventoryPlayer inventory)
    {
        for (int i = 0; i < inventory.mainInventory.size(); i++)
        {
            ItemStack copy = inventory.mainInventory.get(i).copy();

            mainInventoryBefore.set(i, copy);
        }
    }

    /**
     * Called by ASM {@link mchorse.blockbuster.core.transformers.InventoryPlayerTransformer}
     * after an item is added to inventory in {@link InventoryPlayer}
     * @param inventory the inventory where this method is called from
     */
    public static void afterItemStackAdd(InventoryPlayer inventory)
    {
        preventItemPickUpScenePlayback(inventory);
    }

    private void handle(EntityPlayer player, LivingEvent event, Function<GunProps, Boolean> handler)
    {
        ItemStack stack = player.getHeldItemMainhand();

        if (!(stack.getItem() instanceof ItemGun))
        {
            return;
        }

        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        if (handler.apply(props) && event.isCancelable())
        {
            event.setCanceled(true);

            if (event instanceof PlayerInteractEvent)
            {
                ((PlayerInteractEvent) event).setCancellationResult(EnumActionResult.FAIL);
            }
        }
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerTick(TickEvent.PlayerTickEvent event)
    {
        if (event.phase == Phase.END)
        {
            /* Update TEs in the model's TEISR */
            if (event.player.world.isRemote)
            {
                /*
                 * The PlayerTickEvent is called for every player on a server.
                 * Only update the client once per tick.
                 */
                if (Minecraft.getMinecraft().player == event.player)
                {
                    this.updateClient();
                }
            }
            else
            {
                if (this.timer % 100 == 0)
                {
                    StructureMorph.checkStructures();

                    this.timer = 0;
                }

                this.timer += 1;
            }

            return;
        }

        EntityPlayer player = event.player;
        ItemStack stack = player.getHeldItemMainhand();

        if (stack.getItem() instanceof ItemGun)
        {
            ItemGun.decreaseReload(stack, player);
            ItemGun.decreaseTime(stack, player);
            ItemGun.checkGunState(stack, player);
            ItemGun.checkGunReload(stack, player);
        }
    }

    @SideOnly(Side.CLIENT)
    private void updateClient()
    {
        /* model blocks item update */
        Iterator<Map.Entry<NBTTagCompound, TileEntityModelItemStackRenderer.TEModel>> iter0 = TileEntityModelItemStackRenderer.models.entrySet().iterator();

        while (iter0.hasNext())
        {
            TileEntityModelItemStackRenderer.TEModel model = iter0.next().getValue();
            /* remove invisible models from the rendering cache*/
            if (model.timer <= 0)
            {
                iter0.remove();
                continue;
            }

            model.model.update();
            model.timer--;
        }

        /* gun itemstack update */
        Iterator<Map.Entry<ItemStack, TileEntityGunItemStackRenderer.GunEntry>> iter1 = TileEntityGunItemStackRenderer.models.entrySet().iterator();

        while (iter1.hasNext())
        {
            TileEntityGunItemStackRenderer.GunEntry model = iter1.next().getValue();
            if (model.timer <= 0)
            {
                iter1.remove();
                continue;
            }

            model.props.update();
            model.timer--;
        }

        if (this.skinsTimer++ >= 30)
        {
            SkinHandler.checkSkinsFolder();
            this.skinsTimer = 0;
        }

        RenderingHandler.updateEmitters();
        GifTexture.updateTick();
    }
}

==================================================

--- Файл №321 ---
Путь: main\java\mchorse\blockbuster\events\TickHandler.java
--------------------
package mchorse.blockbuster.events;

import mchorse.mclib.utils.DummyEntity;
import net.minecraft.client.Minecraft;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.Side;

import java.util.*;

public class TickHandler
{
    /**
     * The Set is identity based so the same Runnable instance cannot be executed multiple times for one event.
     */
    private final Map<TickIdentifier, Set<Runnable>> runnables = new HashMap<>();

    public void addRunnable(Class<? extends TickEvent> eventType, Side side, Runnable runnable)
    {
        this.addRunnable(eventType, side, TickEvent.Phase.START, runnable);
    }

    public void addRunnable(Class<? extends TickEvent> eventType, Side side, TickEvent.Phase phase, Runnable runnable)
    {
        this.runnables.computeIfAbsent(new TickIdentifier(eventType, phase, side),
                        k -> Collections.newSetFromMap(new IdentityHashMap<>()))
                .add(runnable);
    }

    public void removeRunnable(Class<? extends TickEvent> eventType, Side side, TickEvent.Phase phase, Runnable runnable)
    {
        TickIdentifier identifier = new TickIdentifier(eventType, phase, side);

        Set<Runnable> runnableSet = this.runnables.get(identifier);
        if (runnableSet != null)
        {
            runnableSet.remove(runnable);

            if (runnableSet.isEmpty())
            {
                this.runnables.remove(identifier);
            }
        }
    }

    public void removeRunnable(Class<? extends TickEvent> eventType, Side side, Runnable runnable)
    {
        this.removeRunnable(eventType, side, TickEvent.Phase.START, runnable);
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onWorldTick(TickEvent.WorldTickEvent event)
    {
        this.runRunnables(new TickIdentifier(TickEvent.WorldTickEvent.class, event.phase, event.side));
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onPlayerTick(TickEvent.PlayerTickEvent event)
    {
        Class<? extends TickEvent> eventType = TickEvent.PlayerTickEvent.class;

        /*
         * The PlayerTickEvent is called for every player on a server.
         * Here we do a workaround to call an event type only once on the client side during playertick.
         */
        if (event.side == Side.CLIENT && Minecraft.getMinecraft().player == event.player)
        {
            eventType = WorldClientTickEvent.class;
        }

        this.runRunnables(new TickIdentifier(eventType, event.phase, event.side));
    }

    @SubscribeEvent(priority = EventPriority.HIGHEST)
    public void onClientTick(TickEvent.ClientTickEvent event)
    {
        this.runRunnables(new TickIdentifier(TickEvent.ClientTickEvent.class, event.phase, event.side));
    }

    private void runRunnables(TickIdentifier identifier)
    {
        Set<Runnable> runnableSet = this.runnables.get(identifier);

        if (runnableSet == null) return;

        for (Iterator<Runnable> i = runnableSet.iterator(); i.hasNext();) {
            final Runnable runnable = i.next();

            runnable.run();
            if (runnable instanceof IRunnable &&  ((IRunnable) runnable).shouldRemove())
            {
                i.remove();
            }
        }

        if (runnableSet.isEmpty())
        {
            this.runnables.remove(identifier);
        }
    }

    public interface IRunnable extends Runnable
    {
        public boolean shouldRemove();
    }

    public static class TickIdentifier
    {
        public final Class<? extends TickEvent> eventType;
        public final TickEvent.Phase eventPhase;
        public final Side side;

        public TickIdentifier(Class<? extends TickEvent> eventType, TickEvent.Phase eventPhase, Side side)
        {
            this.eventType = eventType;
            this.eventPhase = eventPhase;
            this.side = side;
        }

        @Override
        public boolean equals(Object o)
        {
            if (this == o) return true;
            if (!(o instanceof TickIdentifier)) return false;
            TickIdentifier that = (TickIdentifier) o;
            return Objects.equals(eventType, that.eventType) && eventPhase == that.eventPhase && side == that.side;
        }

        @Override
        public int hashCode()
        {
            return Objects.hash(eventType, eventPhase, side);
        }
    }

    /**
     * Forge's WorldTickEvent is only fired for servers. I don't want to ASM bytecode inject my own tick event.
     * There is PlayerTickEvent but it is fired for every player on a server leading to weird behavior if a method should
     * only be executed once per tick. This class is a sort of Adapter workaround.
     */
    public static class WorldClientTickEvent extends TickEvent.WorldTickEvent {
        public WorldClientTickEvent(Phase phase, World world) {
            super(Side.CLIENT, phase, world);
        }
    }
}


==================================================

--- Файл №322 ---
Путь: main\java\mchorse\blockbuster\network\Dispatcher.java
--------------------
package mchorse.blockbuster.network;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.network.client.ClientHandlerActorPause;
import mchorse.blockbuster.network.client.ClientHandlerCaption;
import mchorse.blockbuster.network.client.ClientHandlerModifyActor;
import mchorse.blockbuster.network.client.ClientHandlerModifyModelBlock;
import mchorse.blockbuster.network.client.ClientHandlerPlaybackButton;
import mchorse.blockbuster.network.client.ClientHandlerStructure;
import mchorse.blockbuster.network.client.ClientHandlerStructureList;
import mchorse.blockbuster.network.client.audio.ClientHandlerAudio;
import mchorse.blockbuster.network.client.guns.ClientHandlerGunInfo;
import mchorse.blockbuster.network.client.guns.ClientHandlerGunInteract;
import mchorse.blockbuster.network.client.guns.ClientHandlerGunProjectile;
import mchorse.blockbuster.network.client.guns.ClientHandlerGunProjectileVanish;
import mchorse.blockbuster.network.client.guns.ClientHandlerGunShot;
import mchorse.blockbuster.network.client.guns.ClientHandlerGunStuck;
import mchorse.blockbuster.network.client.recording.ClientHandlerApplyFrame;
import mchorse.blockbuster.network.client.recording.ClientHandlerFramesLoad;
import mchorse.blockbuster.network.client.recording.ClientHandlerPlayback;
import mchorse.blockbuster.network.client.recording.ClientHandlerPlayerRecording;
import mchorse.blockbuster.network.client.recording.ClientHandlerRequestedFrames;
import mchorse.blockbuster.network.client.recording.ClientHandlerSyncTick;
import mchorse.blockbuster.network.client.recording.ClientHandlerUnloadFrames;
import mchorse.blockbuster.network.client.recording.ClientHandlerUnloadRecordings;
import mchorse.blockbuster.network.client.recording.actions.ClientHandlerActionList;
import mchorse.blockbuster.network.client.recording.actions.ClientHandlerActions;
import mchorse.blockbuster.network.client.scene.ClientHandlerSceneCast;
import mchorse.blockbuster.network.client.scene.ClientHandlerSceneManage;
import mchorse.blockbuster.network.client.scene.ClientHandlerScenes;
import mchorse.blockbuster.network.common.PacketActorPause;
import mchorse.blockbuster.network.common.PacketCaption;
import mchorse.blockbuster.network.common.PacketDamageControlCheck;
import mchorse.blockbuster.network.common.PacketModifyActor;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.blockbuster.network.common.PacketPlaybackButton;
import mchorse.blockbuster.network.common.PacketReloadModels;
import mchorse.blockbuster.network.common.audio.PacketAudio;
import mchorse.blockbuster.network.common.guns.PacketGunInfo;
import mchorse.blockbuster.network.common.guns.PacketGunInteract;
import mchorse.blockbuster.network.common.guns.PacketGunProjectile;
import mchorse.blockbuster.network.common.guns.PacketGunProjectileVanish;
import mchorse.blockbuster.network.common.guns.PacketGunReloading;
import mchorse.blockbuster.network.common.guns.PacketGunShot;
import mchorse.blockbuster.network.common.guns.PacketGunStuck;
import mchorse.blockbuster.network.common.guns.PacketZoomCommand;
import mchorse.blockbuster.network.common.recording.PacketApplyFrame;
import mchorse.blockbuster.network.common.recording.PacketFramesChunk;
import mchorse.blockbuster.network.common.recording.PacketFramesLoad;
import mchorse.blockbuster.network.common.recording.PacketFramesOverwrite;
import mchorse.blockbuster.network.common.recording.PacketPlayback;
import mchorse.blockbuster.network.common.recording.PacketPlayerRecording;
import mchorse.blockbuster.network.common.recording.PacketRequestFrames;
import mchorse.blockbuster.network.common.recording.PacketRequestRecording;
import mchorse.blockbuster.network.common.recording.PacketRequestedFrames;
import mchorse.blockbuster.network.common.recording.PacketSyncTick;
import mchorse.blockbuster.network.common.recording.PacketUnloadFrames;
import mchorse.blockbuster.network.common.recording.PacketUnloadRecordings;
import mchorse.blockbuster.network.common.recording.PacketUpdatePlayerData;
import mchorse.blockbuster.network.common.recording.actions.PacketActionsChange;
import mchorse.blockbuster.network.common.recording.actions.PacketActionList;
import mchorse.blockbuster.network.common.recording.actions.PacketActions;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestAction;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestActions;
import mchorse.blockbuster.network.common.scene.PacketRequestScenes;
import mchorse.blockbuster.network.common.scene.PacketSceneCast;
import mchorse.blockbuster.network.common.scene.PacketSceneManage;
import mchorse.blockbuster.network.common.scene.PacketScenePause;
import mchorse.blockbuster.network.common.scene.PacketScenePlayback;
import mchorse.blockbuster.network.common.scene.PacketSceneRecord;
import mchorse.blockbuster.network.common.scene.PacketSceneRequestCast;
import mchorse.blockbuster.network.common.scene.PacketScenes;
import mchorse.blockbuster.network.common.scene.sync.PacketSceneGoto;
import mchorse.blockbuster.network.common.scene.sync.PacketScenePlay;
import mchorse.blockbuster.network.common.structure.PacketStructure;
import mchorse.blockbuster.network.common.structure.PacketStructureList;
import mchorse.blockbuster.network.common.structure.PacketStructureListRequest;
import mchorse.blockbuster.network.common.structure.PacketStructureRequest;
import mchorse.blockbuster.network.server.ServerHandlerApplyFrame;
import mchorse.blockbuster.network.server.ServerHandlerDamageControlCheck;
import mchorse.blockbuster.network.server.ServerHandlerModifyActor;
import mchorse.blockbuster.network.server.ServerHandlerModifyModelBlock;
import mchorse.blockbuster.network.server.ServerHandlerPlaybackButton;
import mchorse.blockbuster.network.server.ServerHandlerReloadModels;
import mchorse.blockbuster.network.server.ServerHandlerStructureListRequest;
import mchorse.blockbuster.network.server.ServerHandlerStructureRequest;
import mchorse.blockbuster.network.server.gun.ServerHandlerGunInfo;
import mchorse.blockbuster.network.server.gun.ServerHandlerGunInteract;
import mchorse.blockbuster.network.server.gun.ServerHandlerGunReloading;
import mchorse.blockbuster.network.server.gun.ServerHandlerZoomCommand;
import mchorse.blockbuster.network.server.recording.ServerHandlerFramesChunk;
import mchorse.blockbuster.network.server.recording.ServerHandlerFramesOverwrite;
import mchorse.blockbuster.network.server.recording.ServerHandlerPlayback;
import mchorse.blockbuster.network.server.recording.ServerHandlerRequestFrames;
import mchorse.blockbuster.network.server.recording.ServerHandlerRequestRecording;
import mchorse.blockbuster.network.server.recording.ServerHandlerUpdatePlayerData;
import mchorse.blockbuster.network.server.recording.actions.ServerHandlerActionsChange;
import mchorse.blockbuster.network.server.recording.actions.ServerHandlerRequestAction;
import mchorse.blockbuster.network.server.recording.actions.ServerHandlerRequestActions;
import mchorse.blockbuster.network.server.scene.ServerHandlerRequestScenes;
import mchorse.blockbuster.network.server.scene.ServerHandlerSceneCast;
import mchorse.blockbuster.network.server.scene.ServerHandlerSceneManage;
import mchorse.blockbuster.network.server.scene.ServerHandlerScenePause;
import mchorse.blockbuster.network.server.scene.ServerHandlerScenePlayback;
import mchorse.blockbuster.network.server.scene.ServerHandlerSceneRecord;
import mchorse.blockbuster.network.server.scene.ServerHandlerSceneRequestCast;
import mchorse.blockbuster.network.server.scene.sync.ServerHandlerSceneGoto;
import mchorse.blockbuster.network.server.scene.sync.ServerHandlerScenePlay;
import mchorse.mclib.network.AbstractDispatcher;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.relauncher.Side;

public class Dispatcher
{
    public static final AbstractDispatcher DISPATCHER = new AbstractDispatcher(Blockbuster.MOD_ID)
    {
        @Override
        public void register()
        {
            /* Update actor properties */
            register(PacketModifyActor.class, ClientHandlerModifyActor.class, Side.CLIENT);
            register(PacketModifyActor.class, ServerHandlerModifyActor.class, Side.SERVER);
            register(PacketActorPause.class, ClientHandlerActorPause.class, Side.CLIENT);

            /* Update model block properties */
            register(PacketModifyModelBlock.class, ClientHandlerModifyModelBlock.class, Side.CLIENT);
            register(PacketModifyModelBlock.class, ServerHandlerModifyModelBlock.class, Side.SERVER);

            /* Recording */
            register(PacketCaption.class, ClientHandlerCaption.class, Side.CLIENT);
            register(PacketPlayerRecording.class, ClientHandlerPlayerRecording.class, Side.CLIENT);

            register(PacketSyncTick.class, ClientHandlerSyncTick.class, Side.CLIENT);
            register(PacketPlayback.class, ClientHandlerPlayback.class, Side.CLIENT);
            register(PacketPlayback.class, ServerHandlerPlayback.class, Side.SERVER);

            register(PacketUnloadFrames.class, ClientHandlerUnloadFrames.class, Side.CLIENT);
            register(PacketUnloadRecordings.class, ClientHandlerUnloadRecordings.class, Side.CLIENT);

            register(PacketFramesLoad.class, ClientHandlerFramesLoad.class, Side.CLIENT);
            register(PacketFramesChunk.class, ServerHandlerFramesChunk.class, Side.SERVER);
            register(PacketRequestedFrames.class, ClientHandlerRequestedFrames.class, Side.CLIENT);
            register(PacketRequestFrames.class, ServerHandlerRequestFrames.class, Side.SERVER);
            register(PacketFramesOverwrite.class, ServerHandlerFramesOverwrite.class, Side.SERVER);

            register(PacketApplyFrame.class, ClientHandlerApplyFrame.class, Side.CLIENT);
            register(PacketApplyFrame.class, ServerHandlerApplyFrame.class, Side.SERVER);

            register(PacketActionsChange.class, ServerHandlerActionsChange.class, Side.SERVER);
            register(PacketActions.class, ClientHandlerActions.class, Side.CLIENT);
            register(PacketRequestAction.class, ServerHandlerRequestAction.class, Side.SERVER);
            register(PacketRequestActions.class, ServerHandlerRequestActions.class, Side.SERVER);
            register(PacketRequestRecording.class, ServerHandlerRequestRecording.class, Side.SERVER);
            register(PacketActionList.class, ClientHandlerActionList.class, Side.CLIENT);

            /* Scene management messages */
            register(PacketSceneCast.class, ClientHandlerSceneCast.class, Side.CLIENT);
            register(PacketSceneCast.class, ServerHandlerSceneCast.class, Side.SERVER);
            register(PacketSceneRequestCast.class, ServerHandlerSceneRequestCast.class, Side.SERVER);

            register(PacketScenes.class, ClientHandlerScenes.class, Side.CLIENT);
            register(PacketRequestScenes.class, ServerHandlerRequestScenes.class, Side.SERVER);
            register(PacketSceneManage.class, ClientHandlerSceneManage.class, Side.SERVER);
            register(PacketSceneManage.class, ServerHandlerSceneManage.class, Side.SERVER);

            register(PacketUpdatePlayerData.class, ServerHandlerUpdatePlayerData.class, Side.SERVER);

            /* Scene syncing */
            register(PacketSceneGoto.class, ServerHandlerSceneGoto.class, Side.SERVER);
            register(PacketScenePlay.class, ServerHandlerScenePlay.class, Side.SERVER);
            register(PacketScenePlayback.class, ServerHandlerScenePlayback.class, Side.SERVER);
            register(PacketSceneRecord.class, ServerHandlerSceneRecord.class, Side.SERVER);
            register(PacketScenePause.class, ServerHandlerScenePause.class, Side.SERVER);

            /* Multiplayer */
            register(PacketReloadModels.class, ServerHandlerReloadModels.class, Side.SERVER);

            /* Guns */
            register(PacketGunInfo.class, ServerHandlerGunInfo.class, Side.SERVER);
            register(PacketZoomCommand.class, ServerHandlerZoomCommand.class, Side.SERVER);
            register(PacketGunInfo.class, ClientHandlerGunInfo.class, Side.CLIENT);
            register(PacketGunShot.class, ClientHandlerGunShot.class, Side.CLIENT);
            register(PacketGunProjectile.class, ClientHandlerGunProjectile.class, Side.CLIENT);
            register(PacketGunInteract.class, ServerHandlerGunInteract.class, Side.SERVER);
            register(PacketGunReloading.class, ServerHandlerGunReloading.class, Side.SERVER);
            register(PacketGunInteract.class, ClientHandlerGunInteract.class, Side.CLIENT);
            register(PacketGunProjectileVanish.class, ClientHandlerGunProjectileVanish.class, Side.CLIENT);
            register(PacketGunStuck.class, ClientHandlerGunStuck.class, Side.CLIENT);

            /* Structure morph */
            register(PacketStructure.class, ClientHandlerStructure.class, Side.CLIENT);
            register(PacketStructureRequest.class, ServerHandlerStructureRequest.class, Side.SERVER);
            register(PacketStructureList.class, ClientHandlerStructureList.class, Side.CLIENT);
            register(PacketStructureListRequest.class, ServerHandlerStructureListRequest.class, Side.SERVER);

            /* Playback button */
            register(PacketPlaybackButton.class, ServerHandlerPlaybackButton.class, Side.SERVER);
            register(PacketPlaybackButton.class, ClientHandlerPlaybackButton.class, Side.CLIENT);

            /* Audio */
            register(PacketAudio.class, ClientHandlerAudio.class, Side.CLIENT);
            
            /* Damage Control */
            register(PacketDamageControlCheck.class, ServerHandlerDamageControlCheck.class, Side.SERVER);

            CameraHandler.registerMessages();
        }
    };

    /**
     * Send message to players who are tracking given entity
     */
    public static void sendToTracked(Entity entity, IMessage message)
    {
        DISPATCHER.sendToTracked(entity, message);
    }

    /**
     * Send message to given player
     */
    public static void sendTo(IMessage message, EntityPlayerMP player)
    {
        DISPATCHER.sendTo(message, player);
    }

    /**
     * Send message to the server
     */
    public static void sendToServer(IMessage message)
    {
        DISPATCHER.sendToServer(message);
    }

    public static void sendToAll(IMessage message)
    {
        DISPATCHER.sendToAll(message);
    }

    public static void sendToAllAround(IMessage message, NetworkRegistry.TargetPoint point)
    {
        DISPATCHER.sendToAllAround(message, point);
    }

    /**
     * Register all the networking messages and message handlers
     */
    public static void register()
    {
        DISPATCHER.register();
    }
}

==================================================

--- Файл №323 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerActorPause.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.network.common.PacketActorPause;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerActorPause extends ClientMessageHandler<PacketActorPause>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketActorPause message)
    {
        EntityLivingBase actor = (EntityLivingBase) player.world.getEntityByID(message.id);
        RecordPlayer playback = EntityUtils.getRecordPlayer(actor);

        if (playback != null)
        {
            if (message.pause) playback.pause();
            else playback.resume(message.tick);

            playback.tick = message.tick;
            playback.playing = !message.pause;

            if (playback.record != null)
            {
                Record record = playback.record;

                playback.applyFrame(message.tick - 1, actor, true);

                Frame frame = record.getFrameSafe(message.tick - record.preDelay - 1);

                if (frame != null && frame.hasBodyYaw)
                {
                    actor.renderYawOffset = frame.bodyYaw;
                }

                actor.lastTickPosX = actor.prevPosX = actor.posX;
                actor.lastTickPosY = actor.prevPosY = actor.posY;
                actor.lastTickPosZ = actor.prevPosZ = actor.posZ;
                actor.prevRotationPitch = actor.rotationPitch;
                actor.prevRotationYaw = actor.rotationYaw;
                actor.prevRotationYawHead = actor.rotationYawHead;
                actor.prevRenderYawOffset = actor.renderYawOffset;
            }
        }
    }
}

==================================================

--- Файл №324 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerCaption.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.PacketCaption;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerCaption extends ClientMessageHandler<PacketCaption>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketCaption message)
    {
        String caption = message.caption == null ? "" : message.caption.getUnformattedText();

        ClientProxy.recordingOverlay.setVisible(!caption.isEmpty());
        ClientProxy.recordingOverlay.setCaption(caption, false);
    }
}

==================================================

--- Файл №325 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerModifyActor.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.common.PacketModifyActor;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerModifyActor extends ClientMessageHandler<PacketModifyActor>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketModifyActor message)
    {
        EntityActor actor = (EntityActor) player.world.getEntityByID(message.id);

        if (actor != null)
        {
            actor.modify.add(message);
        }
    }
}

==================================================

--- Файл №326 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerModifyModelBlock.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerModifyModelBlock extends ClientMessageHandler<PacketModifyModelBlock>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketModifyModelBlock message)
    {
        int blockRange = Minecraft.getMinecraft().gameSettings.renderDistanceChunks * 16;
        BlockPos a = new BlockPos(message.pos).subtract(player.getPosition());

        /* check if the pos is in the quadrat defined by blockRange */
        if (Math.abs(a.getX()) > blockRange || Math.abs(a.getZ()) > blockRange)
        {
            return;
        }

        TileEntity tile = player.world.getTileEntity(message.pos);

        if (tile instanceof TileEntityModel)
        {
            TileEntityModel model = (TileEntityModel) tile;

            model.copyData(message.model, message.merge);
            model.entity.ticksExisted = 0;
        }
    }
}

==================================================

--- Файл №327 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerPlaybackButton.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.aperture.gui.GuiPlayback;
import mchorse.blockbuster.network.common.PacketPlaybackButton;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerPlaybackButton extends ClientMessageHandler<PacketPlaybackButton>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketPlaybackButton message)
    {
        GuiPlayback playback = new GuiPlayback();

        playback.setLocation(message.location, message.scenes);
        Minecraft.getMinecraft().displayGuiScreen(playback);
    }
}


==================================================

--- Файл №328 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerStructure.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.network.common.structure.PacketStructure;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.blockbuster_pack.morphs.structure.StructureRenderer;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.multiplayer.ChunkProviderClient;
import net.minecraft.init.Biomes;
import net.minecraft.profiler.Profiler;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.GameType;
import net.minecraft.world.World;
import net.minecraft.world.WorldProvider;
import net.minecraft.world.WorldProviderSurface;
import net.minecraft.world.WorldSettings;
import net.minecraft.world.WorldType;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.chunk.IChunkProvider;
import net.minecraft.world.gen.structure.template.PlacementSettings;
import net.minecraft.world.gen.structure.template.Template;
import net.minecraft.world.storage.ISaveHandler;
import net.minecraft.world.storage.WorldInfo;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerStructure extends ClientMessageHandler<PacketStructure>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketStructure message)
    {
        Minecraft.getMinecraft().addScheduledTask(() ->
        {
            try
            {
                /* Remove the structure if null was sent */
                if (message.tag == null)
                {
                    StructureRenderer renderer = StructureMorph.STRUCTURES.get(message.name);

                    if (renderer != null)
                    {
                        renderer.delete();
                    }

                    return;
                }

                /* Finally clean the old one, if there was, and fill the structure */
                StructureRenderer renderer = createListFromTemplate(message);
                StructureRenderer old = StructureMorph.STRUCTURES.remove(message.name);

                if (old != null)
                {
                    old.delete();
                }

                StructureMorph.STRUCTURES.put(message.name, renderer);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        });
    }

    /**
     * This method creates a renderable display list which allows 
     * rendering fully baked into a display list.
     * 
     * This was harder than I thought...
     */
    @SideOnly(Side.CLIENT)
    private StructureRenderer createListFromTemplate(PacketStructure message)
    {
        Profiler profiler = new Profiler();
        Template template = new Template();
        PlacementSettings placement = new PlacementSettings();

        WorldSettings settings = new WorldSettings(0, GameType.CREATIVE, true, false, WorldType.DEFAULT);
        WorldInfo info = new WorldInfo(settings, message.name);
        WorldProvider provider = new WorldProviderSurface();
        FakeWorld world = new FakeWorld(null, info, provider, profiler, true);

        provider.setWorld(world);
        template.read(message.tag);

        BlockPos origin = new BlockPos(1, 1, 1);
        int w = template.getSize().getX();
        int d = template.getSize().getZ();

        for (int x = 0, cx = (w + 2) / 16 + 1; x < cx; x++)
        {
            for (int z = 0, cz = (d + 2) / 16 + 1; z < cz; z++)
            {
                ((ChunkProviderClient) world.getChunkProvider()).loadChunk(x, z);
            }
        }

        template.addBlocksToWorld(world, origin, placement);

        return new StructureRenderer(template.getSize(), world);
    }

    /**
     * Fake world class
     * 
     * Because the base world isn't enough to make this thing work
     */
    @SideOnly(Side.CLIENT)
    public static class FakeWorld extends World
    {
        public ChunkProviderClient clientChunkProvider;
        public Biome biome;

        public FakeWorld(ISaveHandler saveHandlerIn, WorldInfo info, WorldProvider providerIn, Profiler profilerIn, boolean client)
        {
            super(saveHandlerIn, info, providerIn, profilerIn, client);

            /* If not called, there would be NPE any time blocks accessed */
            this.chunkProvider = this.createChunkProvider();
            this.biome = Biomes.DEFAULT;
        }

        @Override
        protected boolean isChunkLoaded(int x, int z, boolean allowEmpty)
        {
            return allowEmpty || !this.getChunkProvider().provideChunk(x, z).isEmpty();
        }

        @Override
        protected IChunkProvider createChunkProvider()
        {
            if (this.clientChunkProvider == null)
            {
                this.clientChunkProvider = new ChunkProviderClient(this);
            }

            return this.clientChunkProvider;
        }

        /**
         * This method fixes issues with lighting not being updated 
         * when structure template is being pasted into constructed 
         * world.
         */
        @Override
        public boolean isAreaLoaded(BlockPos center, int radius, boolean allowEmpty)
        {
            return true;
        }

        @Override
        public Biome getBiome(BlockPos pos)
        {
            return this.biome;
        }
    }
}

==================================================

--- Файл №329 ---
Путь: main\java\mchorse\blockbuster\network\client\ClientHandlerStructureList.java
--------------------
package mchorse.blockbuster.network.client;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.network.common.structure.PacketStructureList;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.blockbuster_pack.morphs.structure.StructureRenderer;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerStructureList extends ClientMessageHandler<PacketStructureList>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketStructureList message)
    {
        for (String str : message.structures)
        {
            StructureRenderer renderer = StructureMorph.STRUCTURES.get(str);

            if (renderer == null)
            {
                renderer = new StructureRenderer();
                StructureMorph.STRUCTURES.put(str, renderer);
            }
        }

        Blockbuster.proxy.factory.section.addStructures(message.structures);
    }
}

==================================================

--- Файл №330 ---
Путь: main\java\mchorse\blockbuster\network\client\audio\ClientHandlerAudio.java
--------------------
package mchorse.blockbuster.network.client.audio;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.audio.PacketAudio;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerAudio extends ClientMessageHandler<PacketAudio>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketAudio message)
    {
        ClientProxy.audio.handleAudio(message.audio, message.state, message.shift, message.delay);
    }
}

==================================================

--- Файл №331 ---
Путь: main\java\mchorse\blockbuster\network\client\guns\ClientHandlerGunInfo.java
--------------------
package mchorse.blockbuster.network.client.guns;

import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer.GunEntry;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.network.common.guns.PacketGunInfo;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerGunInfo extends ClientMessageHandler<PacketGunInfo>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketGunInfo message)
    {
        Entity entity = player.world.getEntityByID(message.entity);

        if (entity instanceof EntityLivingBase)
        {
            EntityLivingBase base = (EntityLivingBase) entity;
            ItemStack stack = base.getHeldItemMainhand();
            
            if (!stack.isEmpty())
            {
                NBTUtils.saveGunProps(stack, message.tag);

                if (TileEntityGunItemStackRenderer.models.containsKey(stack))
                {
                    GunEntry entry = TileEntityGunItemStackRenderer.models.get(stack);
                    GunProps props = new GunProps(message.tag);

                    entry.props.state = props.state;
                }
            }
        }
    }
}

==================================================

--- Файл №332 ---
Путь: main\java\mchorse\blockbuster\network\client\guns\ClientHandlerGunInteract.java
--------------------
package mchorse.blockbuster.network.client.guns;

import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.network.common.guns.PacketGunInteract;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class ClientHandlerGunInteract extends ClientMessageHandler<PacketGunInteract>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketGunInteract packet)
    {
        if (!(packet.stack.getItem() instanceof ItemGun))
        {
            return;
        }

        ItemGun gun = (ItemGun) packet.stack.getItem();
        Entity entity = player.world.getEntityByID(packet.id);
        GunProps props = NBTUtils.getGunProps(packet.stack);

        if (entity instanceof EntityPlayer)
        {
            if (props.state == ItemGun.GunState.READY_TO_SHOOT && props.storedShotDelay == 0)
            {
                gun.shootIt(packet.stack, player, entity.world);
            }
        }
    }
}

==================================================

--- Файл №333 ---
Путь: main\java\mchorse\blockbuster\network\client\guns\ClientHandlerGunProjectile.java
--------------------
package mchorse.blockbuster.network.client.guns;

import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.network.common.guns.PacketGunProjectile;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerGunProjectile extends ClientMessageHandler<PacketGunProjectile>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketGunProjectile message)
    {
        Entity entity = player.world.getEntityByID(message.id);

        if (entity instanceof EntityGunProjectile)
        {
            ((EntityGunProjectile) entity).morph.set(message.morph);
        }
    }
}

==================================================

--- Файл №334 ---
Путь: main\java\mchorse\blockbuster\network\client\guns\ClientHandlerGunProjectileVanish.java
--------------------
package mchorse.blockbuster.network.client.guns;

import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.network.common.guns.PacketGunProjectileVanish;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerGunProjectileVanish extends ClientMessageHandler<PacketGunProjectileVanish>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketGunProjectileVanish message)
    {
        Entity entity = player.world.getEntityByID(message.id);

        if (entity instanceof EntityGunProjectile)
        {
            EntityGunProjectile projectile = (EntityGunProjectile) entity;

            projectile.vanish = true;
            projectile.vanishDelay = message.delay;
        }
    }
}

==================================================

--- Файл №335 ---
Путь: main\java\mchorse\blockbuster\network\client\guns\ClientHandlerGunShot.java
--------------------
package mchorse.blockbuster.network.client.guns;

import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.network.common.guns.PacketGunShot;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerGunShot extends ClientMessageHandler<PacketGunShot>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketGunShot message)
    {
        Entity entity = player.world.getEntityByID(message.entity);

        if (entity instanceof EntityLivingBase)
        {
            EntityLivingBase base = (EntityLivingBase) entity;
            TileEntityGunItemStackRenderer.GunEntry gun = TileEntityGunItemStackRenderer.models.get(base.getHeldItemMainhand());

            if (gun != null)
            {
                gun.props.shot();
            }
        }
    }
}

==================================================

--- Файл №336 ---
Путь: main\java\mchorse\blockbuster\network\client\guns\ClientHandlerGunStuck.java
--------------------
package mchorse.blockbuster.network.client.guns;

import mchorse.blockbuster.common.entity.EntityGunProjectile;
import mchorse.blockbuster.network.common.guns.PacketGunStuck;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerGunStuck extends ClientMessageHandler<PacketGunStuck>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketGunStuck packet)
    {
        Entity entity = player.world.getEntityByID(packet.id);

        if (entity instanceof EntityGunProjectile)
        {
            EntityGunProjectile bullet = (EntityGunProjectile) entity;

            bullet.stuck = true;
            bullet.posX = bullet.targetX = packet.x;
            bullet.posY = bullet.targetY = packet.y;
            bullet.posZ = bullet.targetZ = packet.z;
            bullet.setPosition(packet.x, packet.y, packet.z);
        }
    }
}

==================================================

--- Файл №337 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerApplyFrame.java
--------------------
package mchorse.blockbuster.network.client.recording;

import mchorse.blockbuster.network.common.recording.PacketApplyFrame;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;

public class ClientHandlerApplyFrame extends ClientMessageHandler<PacketApplyFrame>
{
    @Override
    public void run(EntityPlayerSP entityPlayerSP, PacketApplyFrame packetApplyFrame)
    {
        Entity entity = entityPlayerSP.world.getEntityByID(packetApplyFrame.getEntityID());

        if (entity instanceof EntityLivingBase)
        {
            packetApplyFrame.getFrame().apply((EntityLivingBase) entity, true);

            /* Frame does not apply bodyYaw, EntityActor.updateDistance() does... TODO refactor this*/
            ((EntityLivingBase) entity).renderYawOffset = packetApplyFrame.getFrame().bodyYaw;
        }
    }
}


==================================================

--- Файл №338 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerFramesLoad.java
--------------------
package mchorse.blockbuster.network.client.recording;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.recording.PacketFramesLoad;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ClientMessageHandler;
import mchorse.mclib.utils.Consumers;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.function.Consumer;

/**
 * Client handler frames
 *
 * This client handler is responsible for inserting a record received from the
 * server into client's record repository (record manager).
 */
public class ClientHandlerFramesLoad extends ClientMessageHandler<PacketFramesLoad>
{
    private static final Consumers<Record> consumers = new Consumers();

    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketFramesLoad message)
    {
        Record record = null;

        if (message.getState() == PacketFramesLoad.State.LOAD)
        {
            record = new Record(message.filename);
            record.frames = message.frames;
            record.preDelay = message.preDelay;
            record.postDelay = message.postDelay;

            ClientProxy.manager.records.put(message.filename, record);

            if (ClientProxy.panels != null)
            {
                ClientProxy.panels.recordingEditorPanel.reselectRecord(record);
            }
        }
        else if (message.getState() == PacketFramesLoad.State.NOCHANGES)
        {
            record = ClientProxy.manager.records.get(message.filename);
        }

        if (message.getCallbackID().isPresent())
        {
            consumers.consume(message.getCallbackID().get(), record);
        }
    }

    public static int registerConsumer(Consumer<Record> consumer)
    {
        return consumers.register(consumer);
    }
}

==================================================

--- Файл №339 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerPlayback.java
--------------------
package mchorse.blockbuster.network.client.recording;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.PacketPlayback;
import mchorse.blockbuster.network.common.recording.PacketRequestFrames;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Client handler actor playback
 *
 * This client handler is responsible for starting actor playback. There are
 * few cases to consider.
 *
 * If the message says to stop playback, it is quite simple, but for start
 * playback there are few checks required to be made.
 *
 * If record exists on the client, we'll simply create new record player and
 * request tick and delay, just in case, for synchronization purpose, but if
 * client doesn't have a record, it should request the server to provide one.
 */
public class ClientHandlerPlayback extends ClientMessageHandler<PacketPlayback>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketPlayback message)
    {
        EntityLivingBase actor = (EntityLivingBase) player.world.getEntityByID(message.id);

        if (message.state)
        {
            Record record = ClientProxy.manager.getClient(message.filename);
            RecordPlayer recordPlayer = EntityUtils.getRecordPlayer(actor);

            if (recordPlayer == null)
            {
                recordPlayer = new RecordPlayer(record, Mode.FRAMES, actor);

                recordPlayer.setReplay(message.replay);

                if (message.realPlayer)
                {
                    recordPlayer.realPlayer();
                }

                EntityUtils.setRecordPlayer(actor, recordPlayer);
            }
            else
            {
                recordPlayer.setReplay(message.replay);
                recordPlayer.record = record;
                recordPlayer.realPlayer = message.realPlayer;
                recordPlayer.tick = 0;
            }

            if (record == null)
            {
                Dispatcher.sendToServer(new PacketRequestFrames(message.id, message.filename));
            }
        }
        else
        {
            EntityUtils.setRecordPlayer(actor, null);

            if (actor == Minecraft.getMinecraft().player)
            {
                CameraHandler.resetRoll();
            }
        }
    }
}

==================================================

--- Файл №340 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerPlayerRecording.java
--------------------
package mchorse.blockbuster.network.client.recording;

import java.util.ArrayList;
import java.util.List;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.PacketFramesChunk;
import mchorse.blockbuster.network.common.recording.PacketPlayerRecording;
import mchorse.blockbuster.recording.RecordRecorder;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Client hanlder player recording
 *
 * This client handler is responsible for updating recording overlay status and
 * starting or stopping the recording based on the state given from packet.
 */
public class ClientHandlerPlayerRecording extends ClientMessageHandler<PacketPlayerRecording>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketPlayerRecording message)
    {
        ClientProxy.recordingOverlay.setVisible(message.recording);
        ClientProxy.recordingOverlay.setCaption(message.filename, true);

        if (message.recording)
        {
            ClientProxy.manager.record(message.filename, player, Mode.FRAMES, false, false, message.offset, null);
        }
        else
        {
            if (!message.canceled)
            {
                this.sendFrames(ClientProxy.manager.recorders.get(player));
            }

            ClientProxy.manager.halt(player, false, false, message.canceled);
        }
    }

    /**
     * Send frames to the server
     *
     * Send chunked frames to the server
     */
    @SideOnly(Side.CLIENT)
    private void sendFrames(RecordRecorder recorder)
    {
        Record record = recorder.record;

        int cap = 400;
        int length = record.getLength();
        int offset = recorder.offset;

        /* Send only one message if it's below 500 frames */
        if (length < cap)
        {
            Dispatcher.sendToServer(new PacketFramesChunk(0, 1, offset, record.filename, record.frames));

            return;
        }

        /* Send chunked frames to the server */
        for (int i = 0, c = (length / cap) + 1; i < c; i++)
        {
            List<Frame> frames = new ArrayList<Frame>();

            for (int j = 0, d = length - i * cap > cap ? cap : (length % cap); j < d; j++)
            {
                frames.add(record.frames.get(j + i * cap));
            }

            Dispatcher.sendToServer(new PacketFramesChunk(i, c, offset, record.filename, frames));
        }
    }
}

==================================================

--- Файл №341 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerRequestedFrames.java
--------------------
package mchorse.blockbuster.network.client.recording;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.recording.PacketRequestedFrames;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Client handler requested frames
 *
 * This client handler is responsible for saving received frames into the client
 * record manager and also injecting received record into the provided actor.
 */
public class ClientHandlerRequestedFrames extends ClientMessageHandler<PacketRequestedFrames>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketRequestedFrames message)
    {
        Record record = new Record(message.filename);
        record.frames = message.frames;
        record.preDelay = message.preDelay;
        record.postDelay = message.postDelay;

        ClientProxy.manager.records.put(record.filename, record);
        RecordPlayer playback = EntityUtils.getRecordPlayer((EntityLivingBase) player.world.getEntityByID(message.id));

        if (playback != null)
        {
            playback.record = record;
        }

        if (ClientProxy.panels != null && ClientProxy.panels.recordingEditorPanel != null)
        {
            ClientProxy.panels.recordingEditorPanel.reselectRecord(record);
        }
    }
}

==================================================

--- Файл №342 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerSyncTick.java
--------------------
package mchorse.blockbuster.network.client.recording;


import mchorse.blockbuster.network.common.recording.PacketSyncTick;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Client handler synchronize ticks.
 *
 * This client handler is responsible for synchronizing client's ticks.
 */
public class ClientHandlerSyncTick extends ClientMessageHandler<PacketSyncTick>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketSyncTick message)
    {
        EntityLivingBase actor = (EntityLivingBase) player.world.getEntityByID(message.id);
        RecordPlayer playback = EntityUtils.getRecordPlayer(actor);

        if (playback != null && playback.record != null)
        {
            playback.tick = message.tick;

            if (!playback.playing)
            {
                playback.applyFrame(message.tick - 1, actor, false);
            }
        }
    }
}

==================================================

--- Файл №343 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerUnloadFrames.java
--------------------
package mchorse.blockbuster.network.client.recording;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.recording.PacketUnloadFrames;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerUnloadFrames extends ClientMessageHandler<PacketUnloadFrames>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketUnloadFrames message)
    {
        ClientProxy.manager.records.remove(message.filename);
    }
}

==================================================

--- Файл №344 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\ClientHandlerUnloadRecordings.java
--------------------
package mchorse.blockbuster.network.client.recording;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.recording.PacketUnloadRecordings;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerUnloadRecordings extends ClientMessageHandler<PacketUnloadRecordings>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketUnloadRecordings message)
    {
        ClientProxy.manager.records.clear();
    }
}

==================================================

--- Файл №345 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\actions\ClientHandlerActionList.java
--------------------
package mchorse.blockbuster.network.client.recording.actions;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.recording.actions.PacketActionList;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerActionList extends ClientMessageHandler<PacketActionList>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketActionList message)
    {
        if (ClientProxy.panels.recordingEditorPanel != null)
        {
            ClientProxy.panels.recordingEditorPanel.addRecords(message.records);
        }
    }
}

==================================================

--- Файл №346 ---
Путь: main\java\mchorse\blockbuster\network\client\recording\actions\ClientHandlerActions.java
--------------------
package mchorse.blockbuster.network.client.recording.actions;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.network.common.recording.actions.PacketActions;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerActions extends ClientMessageHandler<PacketActions>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketActions message)
    {
        Record record = ClientProxy.manager.records.get(message.filename);

        if (record == null)
        {
            record = new Record(message.filename);
            ClientProxy.manager.records.put(message.filename, record);
        }

        if (record != null)
        {
            record.actions = message.actions;

            if (ClientProxy.panels.recordingEditorPanel != null && message.open)
            {
                ClientProxy.panels.recordingEditorPanel.selectRecord(record);
            }
        }
    }
}

==================================================

--- Файл №347 ---
Путь: main\java\mchorse\blockbuster\network\client\scene\ClientHandlerSceneCast.java
--------------------
package mchorse.blockbuster.network.client.scene;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanels;
import mchorse.blockbuster.network.common.scene.PacketSceneCast;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.GuiScreen;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Client handler director cast
 *
 * This client handler is responsible for transferring requested director block
 * cast to current director panel.
 */
public class ClientHandlerSceneCast extends ClientMessageHandler<PacketSceneCast>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketSceneCast message)
    {
        GuiDashboard dashboard = GuiDashboard.get();
        GuiBlockbusterPanels panels = ClientProxy.panels;
        GuiScreen screen = Minecraft.getMinecraft().currentScreen;

        boolean opened = message.open && screen == null;

        if (opened)
        {
            panels.scenePanel.openScene(message.location);
        }
        else if (screen == dashboard)
        {
            panels.scenePanel.setScene(message.location);
        }
        else
        {
            panels.scenePanel.set(message.location);
        }

        if (opened)
        {
            dashboard.panels.setPanel(panels.scenePanel);
            Minecraft.getMinecraft().displayGuiScreen(GuiDashboard.get());
        }
    }
}

==================================================

--- Файл №348 ---
Путь: main\java\mchorse\blockbuster\network\client\scene\ClientHandlerSceneManage.java
--------------------
package mchorse.blockbuster.network.client.scene;

import mchorse.blockbuster.network.common.scene.PacketSceneManage;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerSceneManage extends ClientMessageHandler<PacketSceneManage>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP entityPlayerSP, PacketSceneManage packetSceneManage)
    {

    }
}

==================================================

--- Файл №349 ---
Путь: main\java\mchorse\blockbuster\network\client\scene\ClientHandlerScenes.java
--------------------
package mchorse.blockbuster.network.client.scene;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.dashboard.GuiBlockbusterPanels;
import mchorse.blockbuster.network.common.scene.PacketScenes;
import mchorse.mclib.network.ClientMessageHandler;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerScenes extends ClientMessageHandler<PacketScenes>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP entityPlayerSP, PacketScenes packetScenes)
    {
        GuiBlockbusterPanels dashboard = ClientProxy.panels;

        if (dashboard.scenePanel != null)
        {
            dashboard.scenePanel.scenes.add(packetScenes.scenes);
        }
    }
}

==================================================

--- Файл №350 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketActorPause.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketActorPause implements IMessage
{
    public int id;
    public boolean pause;
    public int tick;

    public PacketActorPause()
    {}

    public PacketActorPause(int id, boolean pause, int tick)
    {
        this.id = id;
        this.pause = pause;
        this.tick = tick;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.pause = buf.readBoolean();
        this.tick = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        buf.writeBoolean(this.pause);
        buf.writeInt(this.tick);
    }
}

==================================================

--- Файл №351 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketCaption.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.ITextComponent.Serializer;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketCaption implements IMessage
{
    public ITextComponent caption;

    public PacketCaption()
    {}

    public PacketCaption(ITextComponent caption)
    {
        this.caption = caption;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        if (buf.readBoolean())
        {
            this.caption = Serializer.jsonToComponent(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeBoolean(this.caption != null);

        if (this.caption != null)
        {
            ByteBufUtils.writeUTF8String(buf, Serializer.componentToJson(this.caption));
        }
    }
}

==================================================

--- Файл №352 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketDamageControlCheck.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketDamageControlCheck implements IMessage
{
public BlockPos pointPos;
    
    public PacketDamageControlCheck() {
        pointPos = null;
    }
    
    public PacketDamageControlCheck(BlockPos pointPos) {
        this.pointPos = pointPos;
    }

    @Override
    public void fromBytes(ByteBuf buf) {
        boolean havePointPos = buf.readBoolean();
        int x = buf.readInt();
        int y = buf.readInt();
        int z = buf.readInt();
        if (havePointPos)
            pointPos = new BlockPos(x, y, z);
    }

    @Override
    public void toBytes(ByteBuf buf) {
        buf.writeBoolean(pointPos != null);
        buf.writeInt(pointPos != null ? pointPos.getX() : 0);
        buf.writeInt(pointPos != null ? pointPos.getY() : 0);
        buf.writeInt(pointPos != null ? pointPos.getZ() : 0);
    }
}


==================================================

--- Файл №353 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketModifyActor.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketModifyActor implements IMessage
{
    public int id;
    public AbstractMorph morph;
    public boolean invisible;

    public int offset;
    public AbstractMorph previous;
    public int previousOffset;
    public boolean forceMorph;

    public PacketModifyActor()
    {}

    public PacketModifyActor(EntityActor actor)
    {
        this.id = actor.getEntityId();
        this.morph = actor.morph.get();
        this.invisible = actor.invisible;

        this.offset = actor.pauseOffset;
        this.previous = actor.pausePreviousMorph;
        this.previousOffset = actor.pausePreviousOffset;
        this.forceMorph = actor.forceMorph;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.invisible = buf.readBoolean();
        this.morph = MorphUtils.morphFromBuf(buf);

        this.offset = buf.readInt();

        if (buf.readBoolean())
        {
            this.previous = MorphUtils.morphFromBuf(buf);
        }

        this.previousOffset = buf.readInt();
        this.forceMorph = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        buf.writeBoolean(this.invisible);
        MorphUtils.morphToBuf(buf, this.morph);

        buf.writeInt(this.offset);
        buf.writeBoolean(this.previous != null);

        if (this.previous != null)
        {
            MorphUtils.morphToBuf(buf, this.previous);
        }

        buf.writeInt(this.previousOffset);
        buf.writeBoolean(this.forceMorph);
    }
}

==================================================

--- Файл №354 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketModifyModelBlock.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketModifyModelBlock implements IMessage
{
    public BlockPos pos;
    public TileEntityModel model;
    public boolean merge;

    public PacketModifyModelBlock()
    {}

    public PacketModifyModelBlock(BlockPos pos, TileEntityModel model)
    {
        this.pos = pos;
        this.model = model;
    }

    public PacketModifyModelBlock(BlockPos pos, TileEntityModel model, boolean merge)
    {
        this(pos, model);

        this.merge = merge;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.pos = new BlockPos(buf.readInt(), buf.readInt(), buf.readInt());

        if (buf.readBoolean())
        {
            this.model = new TileEntityModel();
            this.model.fromBytes(buf);
        }

        this.merge = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.pos.getX());
        buf.writeInt(this.pos.getY());
        buf.writeInt(this.pos.getZ());
        buf.writeBoolean(this.model != null);

        if (this.model != null)
        {
            this.model.toBytes(buf);
        }

        buf.writeBoolean(this.merge);
    }
}

==================================================

--- Файл №355 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketPlaybackButton.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.network.common.scene.PacketScene;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.recording.scene.SceneLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import java.util.ArrayList;
import java.util.List;

public class PacketPlaybackButton extends PacketScene
{
    public int mode;
    public String profile = "";
    public List<String> scenes = new ArrayList<String>();

    public PacketPlaybackButton()
    {}

    public PacketPlaybackButton(SceneLocation location, int mode, String profile)
    {
        super(location);
        this.mode = mode;
        this.profile = profile;
    }

    public PacketPlaybackButton withScenes(List<String> scenes)
    {
        this.scenes.addAll(scenes);

        return this;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.mode = buf.readInt();
        this.profile = ByteBufUtils.readUTF8String(buf);

        int count = buf.readInt();

        for (int i = 0; i < count; i++)
        {
            this.scenes.add(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.mode);
        ByteBufUtils.writeUTF8String(buf, this.profile);

        buf.writeInt(this.scenes.size());

        for (String scene : this.scenes)
        {
            ByteBufUtils.writeUTF8String(buf, scene);
        }
    }
}

==================================================

--- Файл №356 ---
Путь: main\java\mchorse\blockbuster\network\common\PacketReloadModels.java
--------------------
package mchorse.blockbuster.network.common;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketReloadModels implements IMessage
{
    public boolean force;

    public PacketReloadModels()
    {}

    public PacketReloadModels(boolean force)
    {
        this.force = force;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.force = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeBoolean(this.force);
    }
}

==================================================

--- Файл №357 ---
Путь: main\java\mchorse\blockbuster\network\common\audio\PacketAudio.java
--------------------
package mchorse.blockbuster.network.common.audio;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.audio.AudioState;
import mchorse.mclib.utils.LatencyTimer;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import javax.annotation.Nullable;

public class PacketAudio implements IMessage
{
    public String audio;
    public AudioState state;
    public int shift;

    /**
     * For syncing purposes to clock the delay
     * between networking and loading the file
     */
    public LatencyTimer delay;

    public PacketAudio()
    {}

    public PacketAudio(String audio, AudioState state, int shift)
    {
        this(audio, state, shift, null);
    }

    public PacketAudio(String audio, AudioState state, int shift, @Nullable LatencyTimer delay)
    {
        this.audio = audio;
        this.state = state;
        this.shift = shift;
        this.delay = delay;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.audio = ByteBufUtils.readUTF8String(buf);
        this.state = AudioState.values()[buf.readInt()];
        this.shift = buf.readInt();

        if (buf.readBoolean())
        {
            this.delay = new LatencyTimer();

            this.delay.fromBytes(buf);
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.audio);
        buf.writeInt(this.state.ordinal());
        buf.writeInt(this.shift);

        buf.writeBoolean(this.delay != null);

        if (this.delay != null)
        {
            this.delay.toBytes(buf);
        }
    }
}

==================================================

--- Файл №358 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunInfo.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketGunInfo implements IMessage
{
    public NBTTagCompound tag;
    public int entity;

    public PacketGunInfo()
    {
        this.tag = new NBTTagCompound();
    }

    public PacketGunInfo(NBTTagCompound tag, int entity)
    {
        this.tag = tag;
        this.entity = entity;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.tag = NBTUtils.readInfiniteTag(buf);
        this.entity = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeTag(buf, this.tag);
        buf.writeInt(this.entity);
    }
}

==================================================

--- Файл №359 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunInteract.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class PacketGunInteract implements IMessage
{
    public ItemStack stack;
    public int id;

    public PacketGunInteract()
    {}

    public PacketGunInteract(ItemStack stack, int id)
    {
        this.stack = stack;
        this.id = id;
    }

    @Override
    public void fromBytes(ByteBuf byteBuf)
    {
        this.stack = ByteBufUtils.readItemStack(byteBuf);
        this.id = byteBuf.readInt();
    }

    @Override
    public void toBytes(ByteBuf byteBuf)
    {
        ByteBufUtils.writeItemStack(byteBuf, this.stack);
        byteBuf.writeInt(this.id);
    }
}

==================================================

--- Файл №360 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunProjectile.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketGunProjectile implements IMessage
{
    public int id;
    public AbstractMorph morph;

    public PacketGunProjectile()
    {}

    public PacketGunProjectile(int id, AbstractMorph morph)
    {
        this.id = id;
        this.morph = morph;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.morph = MorphUtils.morphFromBuf(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        MorphUtils.morphToBuf(buf, this.morph);
    }
}

==================================================

--- Файл №361 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunProjectileVanish.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketGunProjectileVanish implements IMessage
{
    public int id;
    public int delay;

    public PacketGunProjectileVanish()
    {}

    public PacketGunProjectileVanish(int id, int delay)
    {
        this.id = id;
        this.delay = delay;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.delay = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        buf.writeInt(this.delay);
    }
}

==================================================

--- Файл №362 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunReloading.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class PacketGunReloading implements IMessage
{
    public ItemStack stack;
    public int id;

    public PacketGunReloading()
    {}

    public PacketGunReloading(ItemStack stack, int id)
    {
        this.stack = stack;
        this.id = id;
    }

    @Override
    public void fromBytes(ByteBuf byteBuf)
    {
        this.stack = ByteBufUtils.readItemStack(byteBuf);
        this.id = byteBuf.readInt();
    }

    @Override
    public void toBytes(ByteBuf byteBuf)
    {
        ByteBufUtils.writeItemStack(byteBuf, this.stack);
        byteBuf.writeInt(this.id);
    }
}

==================================================

--- Файл №363 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunShot.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketGunShot implements IMessage
{
    public int entity;

    public PacketGunShot()
    {}

    public PacketGunShot(int entity)
    {
        this.entity = entity;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.entity = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.entity);
    }
}

==================================================

--- Файл №364 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketGunStuck.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketGunStuck implements IMessage
{
    public int id;
    public float x;
    public float y;
    public float z;

    public PacketGunStuck(int id, float x, float y, float z)
    {
        this.id = id;
        this.x = x;
        this.y = y;
        this.z = z;
    }

    public PacketGunStuck()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.x = buf.readFloat();
        this.y = buf.readFloat();
        this.z = buf.readFloat();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        buf.writeFloat(this.x);
        buf.writeFloat(this.y);
        buf.writeFloat(this.z);
    }
}


==================================================

--- Файл №365 ---
Путь: main\java\mchorse\blockbuster\network\common\guns\PacketZoomCommand.java
--------------------
package mchorse.blockbuster.network.common.guns;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class PacketZoomCommand implements IMessage
{
    public int entity;
    public boolean zoomOn;

    public PacketZoomCommand()
    {}

    public PacketZoomCommand(int entity, boolean zoomOn)
    {
        super();
        this.entity = entity;
        this.zoomOn = zoomOn;
    }

    @Override
    public void fromBytes(ByteBuf byteBuf)
    {
        this.entity = byteBuf.readInt();
        this.zoomOn = byteBuf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf byteBuf)
    {
        byteBuf.writeInt(this.entity);
        byteBuf.writeBoolean(this.zoomOn);
    }
}

==================================================

--- Файл №366 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketApplyFrame.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketApplyFrame implements IMessage
{
    private Frame frame;
    private int entityID;

    public PacketApplyFrame()
    { }

    public PacketApplyFrame(Frame frame, int entityID)
    {
        this.frame = frame;
        this.entityID = entityID;
    }

    public Frame getFrame()
    {
        return this.frame.copy();
    }

    public int getEntityID()
    {
        return this.entityID;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        if (buf.readBoolean())
        {
            this.frame = new Frame();

            this.frame.fromBytes(buf);
        }

        this.entityID = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeBoolean(this.frame != null);

        if (this.frame != null)
        {
            this.frame.toBytes(buf);
        }

        buf.writeInt(this.entityID);
    }
}


==================================================

--- Файл №367 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketFrames.java
--------------------
package mchorse.blockbuster.network.common.recording;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufInputStream;
import io.netty.buffer.ByteBufOutputStream;
import mchorse.blockbuster.recording.data.Frame;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * Packet that responsible for delivering recorded frames either to server for
 * saving or to client for playback.
 */
public abstract class PacketFrames implements IMessage
{
    public String filename;
    public int preDelay;
    public int postDelay;
    public List<Frame> frames;

    public PacketFrames()
    {}

    public PacketFrames(String filename, int preDelay, int postDelay, List<Frame> frames)
    {
        this.filename = filename;
        this.preDelay = preDelay;
        this.postDelay = postDelay;
        this.frames = frames;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        List<Frame> frames = new ArrayList<Frame>();

        this.filename = ByteBufUtils.readUTF8String(buf);
        this.preDelay = buf.readInt();
        this.postDelay = buf.readInt();

        if (buf.readBoolean())
        {
            int count = buf.readInt();

            for (int i = 0; i < count; i++)
            {
                Frame frame = new Frame();

                frame.fromBytes(buf);
                frames.add(frame);
            }

            this.frames = frames;
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeInt(this.preDelay);
        buf.writeInt(this.postDelay);
        buf.writeBoolean(this.frames != null);

        if (this.frames != null)
        {
            buf.writeInt(this.frames.size());

            for (Frame frame : this.frames)
            {
                frame.toBytes(buf);
            }
        }
    }
}

==================================================

--- Файл №368 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketFramesChunk.java
--------------------
package mchorse.blockbuster.network.common.recording;

import java.util.List;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;

public class PacketFramesChunk extends PacketFrames
{
    public int index;
    public int count;
    public int offset;

    public PacketFramesChunk()
    {}

    public PacketFramesChunk(int index, int count, int offset, String filename, List<Frame> frames)
    {
        super(filename, 0, 0, frames);

        this.index = index;
        this.count = count;
        this.offset = offset;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.index = buf.readInt();
        this.count = buf.readInt();
        this.offset = buf.readInt();

        super.fromBytes(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.index);
        buf.writeInt(this.count);
        buf.writeInt(this.offset);

        super.toBytes(buf);
    }
}

==================================================

--- Файл №369 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketFramesLoad.java
--------------------
package mchorse.blockbuster.network.common.recording;

import java.util.List;
import java.util.Optional;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;

import javax.annotation.Nullable;

public class PacketFramesLoad extends PacketFrames
{
    private int callbackID = -1;
    private State loaded = State.LOAD;

    public PacketFramesLoad()
    {}

    public PacketFramesLoad(String filename, State loaded, int callbackID)
    {
        this.loaded = loaded;
        this.callbackID = callbackID;
        this.filename = filename;
    }

    public PacketFramesLoad(String filename, State loaded)
    {
        this(filename, loaded, -1);
    }

    public PacketFramesLoad(String filename, int preDelay, int postDelay, List<Frame> frames)
    {
        super(filename, preDelay, postDelay, frames);
    }

    public PacketFramesLoad(String filename, int preDelay, int postDelay, List<Frame> frames, int callbackID)
    {
        super(filename, preDelay, postDelay, frames);

        this.callbackID = callbackID;
    }

    public Optional<Integer> getCallbackID()
    {
        return Optional.ofNullable(this.callbackID == -1 ? null : this.callbackID);
    }

    public State getState()
    {
        return this.loaded;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.loaded = State.values()[buf.readInt()];
        this.callbackID = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.loaded.ordinal());
        buf.writeInt(this.callbackID);
    }

    public enum State
    {
        LOAD,
        ERROR,
        NOCHANGES
    }
}

==================================================

--- Файл №370 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketFramesOverwrite.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.mclib.common.IAnswerRequest;
import mchorse.mclib.network.mclib.common.PacketAnswer;
import java.util.AbstractMap.SimpleEntry;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Optional;

/**
 * Packet of frame ranges, split up in chunks to avoid max packet size error
 */
public class PacketFramesOverwrite extends PacketFrames implements IAnswerRequest<SimpleEntry<IKey, Boolean>>
{
    /**
     * overwrite frames from tick.
     * This is separate from frame chunk splitting.
     */
    private int from;
    /**
     * overwrite frames to tick.
     * This is separate from frame chunk splitting.
     */
    private int to;
    /**
     * The start index of this frame chunk, relative to {@link #from}
     * This is needed to split it into chunks.
     */
    private int index;
    private int callbackID = -1;

    public PacketFramesOverwrite()
    {

    }

    public PacketFramesOverwrite(int from, int to, int index, String filename, List<Frame> frames)
    {
        super(filename, 0, 0, frames);

        this.from = from;
        this.to = to;
        this.index = index;
    }

    public PacketFramesOverwrite(int from, int to, int index, String filename, List<Frame> frames, int callbackID)
    {
        this(from, to, index, filename, frames);

        this.callbackID = callbackID;
    }

    public int getFrom()
    {
        return this.from;
    }

    public int getTo()
    {
        return this.to;
    }

    public int getIndex()
    {
        return this.index;
    }

    @Override
    public void setCallbackID(int callbackID)
    {
        this.callbackID = callbackID;
    }

    public Optional<Integer> getCallbackID()
    {
        return Optional.ofNullable(this.callbackID == -1 ? null : this.callbackID);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.from = buf.readInt();
        this.to = buf.readInt();
        this.index = buf.readInt();
        this.callbackID = buf.readInt();

        super.fromBytes(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.from);
        buf.writeInt(this.to);
        buf.writeInt(this.index);
        buf.writeInt(this.callbackID);

        super.toBytes(buf);
    }

    /**
     *
     * @param value expects {String, boolean}
     * @return the packet answer or null if no callback has been registered
     */
    @Override
    public PacketAnswer<SimpleEntry<IKey, Boolean>> getAnswer(SimpleEntry<IKey, Boolean> value) throws NoSuchElementException
    {
        return new PacketAnswer<>(this.getCallbackID().get(), value);
    }
}


==================================================

--- Файл №371 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketPlayback.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.scene.Replay;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketPlayback implements IMessage
{
    public int id;
    public boolean state;
    public boolean realPlayer;
    public String filename;
    public Replay replay;

    public PacketPlayback()
    {}

    public PacketPlayback(int id, boolean state, boolean realPlayer, String filename)
    {
        this.id = id;
        this.state = state;
        this.filename = filename;
        this.realPlayer = realPlayer;
    }

    public PacketPlayback(int id, boolean state, boolean realPlayer, String filename, Replay replay)
    {
        this(id, state, realPlayer, filename);

        this.replay = replay;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.state = buf.readBoolean();
        this.realPlayer = buf.readBoolean();
        this.filename = ByteBufUtils.readUTF8String(buf);

        if (buf.readBoolean())
        {
            this.replay = new Replay();

            this.replay.fromBuf(buf);
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        buf.writeBoolean(this.state);
        buf.writeBoolean(this.realPlayer);
        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeBoolean(this.replay != null);

        if (this.replay != null)
        {
            this.replay.toBuf(buf);
        }
    }
}


==================================================

--- Файл №372 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketPlayerRecording.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketPlayerRecording implements IMessage
{
    public boolean recording;
    public String filename;
    public int offset;
    public boolean canceled;

    public PacketPlayerRecording()
    {}

    public PacketPlayerRecording(boolean recording, String filename, int offset, boolean canceled)
    {
        this.recording = recording;
        this.filename = filename;
        this.offset = offset;
        this.canceled = canceled;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.recording = buf.readBoolean();
        this.filename = ByteBufUtils.readUTF8String(buf);
        this.offset = buf.readInt();
        this.canceled = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeBoolean(this.recording);
        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeInt(this.offset);
        buf.writeBoolean(this.canceled);
    }
}

==================================================

--- Файл №373 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketRequestedFrames.java
--------------------
package mchorse.blockbuster.network.common.recording;

import java.util.List;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;

public class PacketRequestedFrames extends PacketFrames
{
    public int id;

    public PacketRequestedFrames()
    {}

    public PacketRequestedFrames(int id, String filename, int preDelay, int postDelay, List<Frame> frames)
    {
        super(filename, preDelay, postDelay, frames);

        this.id = id;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.id = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.id);
    }
}

==================================================

--- Файл №374 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketRequestFrames.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketRequestFrames implements IMessage
{
    public int id;
    public String filename;

    public PacketRequestFrames()
    {}

    public PacketRequestFrames(int id, String filename)
    {
        this.id = id;
        this.filename = filename;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.filename = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        ByteBufUtils.writeUTF8String(buf, this.filename);
    }
}

==================================================

--- Файл №375 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketRequestRecording.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import javax.annotation.Nullable;
import java.util.Optional;

public class PacketRequestRecording implements IMessage
{
    private String filename = "";
    private int callbackID = -1;

    public PacketRequestRecording()
    {}

    public PacketRequestRecording(String record)
    {
        this(record, -1);
    }

    public PacketRequestRecording(String record, int callbackID)
    {
        this.filename = record;
        this.callbackID = callbackID;
    }

    public String getFilename()
    {
        return this.filename;
    }

    public Optional<Integer> getCallbackID()
    {
        return Optional.ofNullable(this.callbackID == -1 ? null : this.callbackID);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.filename = ByteBufUtils.readUTF8String(buf);
        this.callbackID = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeInt(this.callbackID);
    }
}

==================================================

--- Файл №376 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketSyncTick.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketSyncTick implements IMessage
{
    public int id;
    public int tick;

    public PacketSyncTick()
    {}

    public PacketSyncTick(int id, int tick)
    {
        this.id = id;
        this.tick = tick;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.id = buf.readInt();
        this.tick = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.id);
        buf.writeInt(this.tick);
    }
}

==================================================

--- Файл №377 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketUnloadFrames.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketUnloadFrames implements IMessage
{
    public String filename;

    public PacketUnloadFrames()
    {}

    public PacketUnloadFrames(String filename)
    {
        this.filename = filename;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.filename = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.filename);
    }
}

==================================================

--- Файл №378 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketUnloadRecordings.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketUnloadRecordings implements IMessage
{
    public PacketUnloadRecordings()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}


==================================================

--- Файл №379 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\PacketUpdatePlayerData.java
--------------------
package mchorse.blockbuster.network.common.recording;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketUpdatePlayerData implements IMessage
{
    public String record = "";

    public PacketUpdatePlayerData()
    {}

    public PacketUpdatePlayerData(String record)
    {
        this.record = record;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.record = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.record);
    }
}

==================================================

--- Файл №380 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\actions\PacketActionList.java
--------------------
package mchorse.blockbuster.network.common.recording.actions;

import java.util.ArrayList;
import java.util.List;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketActionList implements IMessage
{
    public List<String> records = new ArrayList<String>();

    public PacketActionList()
    {}

    public PacketActionList(List<String> records)
    {
        this.records.addAll(records);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        for (int i = 0, c = buf.readInt(); i < c; i++)
        {
            this.records.add(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.records.size());

        for (String record : this.records)
        {
            ByteBufUtils.writeUTF8String(buf, record);
        }
    }
}

==================================================

--- Файл №381 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\actions\PacketActions.java
--------------------
package mchorse.blockbuster.network.common.recording.actions;

import java.util.ArrayList;
import java.util.List;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.actions.Action;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketActions implements IMessage
{
    public String filename;
    public List<List<Action>> actions;
    public boolean open;

    public PacketActions()
    {
        this.actions = new ArrayList<List<Action>>();
    }

    public PacketActions(String filename, List<List<Action>> actions, boolean open)
    {
        this.filename = filename;
        this.actions = actions;
        this.open = open;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.filename = ByteBufUtils.readUTF8String(buf);

        for (int i = 0, c = buf.readInt(); i < c; i++)
        {
            int count = buf.readByte();

            if (count != 0)
            {
                List<Action> actions = new ArrayList<Action>();

                for (int j = 0; j < count; j++)
                {
                    Action action = ActionRegistry.fromByteBuf(buf);

                    if (action != null)
                    {
                        actions.add(action);
                    }
                }

                this.actions.add(actions);
            }
            else
            {
                this.actions.add(null);
            }
        }

        this.open = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        int i = 0;

        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeInt(this.actions.size());

        for (List<Action> list : this.actions)
        {
            int count = list == null ? 0 : list.size();

            buf.writeByte(count);

            if (count != 0)
            {
                for (Action action : list)
                {
                    ActionRegistry.toByteBuf(action, buf);
                }
            }
        }

        buf.writeBoolean(this.open);
    }
}

==================================================

--- Файл №382 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\actions\PacketActionsChange.java
--------------------
package mchorse.blockbuster.network.common.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordTimeline;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.actions.Action;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import java.util.ArrayList;
import java.util.List;

public class PacketActionsChange implements IMessage
{
    private String filename;
    private int fromTick = -1;
    private int index = -1;
    private List<List<Action>> actions;
    private List<List<Boolean>> mask;
    private Type type;

    public PacketActionsChange()
    {}

    /**
     * @param filename
     * @param from order does not matter - it will be sorted internally
     */
    public PacketActionsChange(String filename, int from, int index, Action action, Type type)
    {
        this.filename = filename;
        this.fromTick = from;
        this.index = index;

        List<List<Action>> actions = new ArrayList<>();
        actions.add(new ArrayList<>());
        actions.get(0).add(action);

        this.actions = actions;
        this.type = type;
    }

    public PacketActionsChange(String filename, int from, List<List<Action>> actions, Type type)
    {
        this.filename = filename;
        this.fromTick = from;
        this.actions = actions;
        this.type = type;
    }

    public PacketActionsChange(String filename, int tick, int index, List<List<Action>> actions, Type type)
    {
        this.filename = filename;
        this.fromTick = tick;
        this.index = index;
        this.actions = actions;
        this.type = type;
    }

    /**
     * A deletion package
     * @param filename
     * @param tick
     * @param deletionMask
     */
    public PacketActionsChange(String filename, int tick, List<List<Boolean>> deletionMask)
    {
        this(filename, tick, null, Type.DELETE);

        this.mask = deletionMask;
    }

    public boolean containsOneAction()
    {
        return this.actions != null && !this.actions.isEmpty() && this.actions.get(0) != null && !this.actions.get(0).isEmpty();
    }

    public int getIndex()
    {
        return this.index;
    }

    public int getFromTick()
    {
        return this.fromTick;
    }

    public List<List<Action>> getActions()
    {
        return this.actions;
    }

    public String getFilename()
    {
        return this.filename;
    }

    public Type getStatus()
    {
        return this.type;
    }

    public List<List<Boolean>> getMask()
    {
        return this.mask;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.filename = ByteBufUtils.readUTF8String(buf);
        this.fromTick = buf.readInt();
        this.index = buf.readInt();
        this.type = Type.values()[buf.readInt()];

        if (buf.readBoolean())
        {
            this.actions = new ArrayList<>();
            int size = buf.readInt();

            for (int i = 0; i < size; i++)
            {
                int count = buf.readByte();

                if (count != 0)
                {
                    List<Action> actions = new ArrayList<Action>();

                    for (int j = 0; j < count; j++)
                    {
                        Action action = ActionRegistry.fromByteBuf(buf);

                        if (action != null)
                        {
                            actions.add(action);
                        }
                    }

                    this.actions.add(actions);
                }
                else
                {
                    this.actions.add(null);
                }
            }
        }

        if (buf.readBoolean())
        {
            this.mask = new ArrayList<>();

            int size = buf.readInt();

            for (int i = 0; i < size; i++)
            {
                List<Boolean> maskFrame = new ArrayList<>();

                int count = buf.readByte();

                if (count != 0)
                {
                    for (int j = 0; j < count; j++)
                    {
                        maskFrame.add(buf.readBoolean());
                    }
                }
                else
                {
                    maskFrame.add(false);
                }

                this.mask.add(maskFrame);
            }
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeInt(this.fromTick);
        buf.writeInt(this.index);
        buf.writeInt(this.type.ordinal());
        buf.writeBoolean(this.actions != null);

        if (this.actions != null)
        {
            buf.writeInt(this.actions.size());

            for (List<Action> list : this.actions)
            {
                int count = list == null ? 0 : list.size();

                buf.writeByte(count);

                if (count != 0)
                {
                    for (Action action : list)
                    {
                        ActionRegistry.toByteBuf(action, buf);
                    }
                }
            }
        }

        buf.writeBoolean(this.mask != null);

        if (this.mask != null)
        {
            buf.writeInt(this.mask.size());

            for (List<Boolean> list : this.mask)
            {
                int count = list == null ? 0 : list.size();

                buf.writeByte(count);

                if (count != 0)
                {
                    for (Boolean bool : list)
                    {
                        buf.writeBoolean(bool);
                    }
                }
            }
        }
    }

    public enum Type
    {
        DELETE,
        ADD,
        EDIT
    }
}

==================================================

--- Файл №383 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\actions\PacketRequestAction.java
--------------------
package mchorse.blockbuster.network.common.recording.actions;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketRequestAction implements IMessage
{
    public String filename;
    public boolean open;

    public PacketRequestAction()
    {}

    public PacketRequestAction(String filename, boolean open)
    {
        this.filename = filename;
        this.open = open;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.filename = ByteBufUtils.readUTF8String(buf);
        this.open = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.filename);
        buf.writeBoolean(this.open);
    }
}

==================================================

--- Файл №384 ---
Путь: main\java\mchorse\blockbuster\network\common\recording\actions\PacketRequestActions.java
--------------------
package mchorse.blockbuster.network.common.recording.actions;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketRequestActions implements IMessage
{
    public PacketRequestActions()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №385 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketRequestScenes.java
--------------------
package mchorse.blockbuster.network.common.scene;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketRequestScenes implements IMessage
{
    public PacketRequestScenes()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №386 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketScene.java
--------------------
package mchorse.blockbuster.network.common.scene;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.recording.scene.SceneLocation;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public abstract class PacketScene implements IMessage
{
    public SceneLocation location = new SceneLocation();

    public PacketScene()
    {}

    public PacketScene(SceneLocation location)
    {
        this.location = location;
    }

    public Scene get(World world)
    {
        if (this.location.isScene())
        {
            return CommonProxy.scenes.get(this.location.getFilename(), world);
        }

        return null;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        if (buf.readBoolean())
        {
            this.location.fromByteBuf(buf);
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeBoolean(this.location != null);

        if (this.location != null)
        {
            this.location.toByteBuf(buf);
        }
    }
}

==================================================

--- Файл №387 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketSceneCast.java
--------------------
package mchorse.blockbuster.network.common.scene;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.scene.SceneLocation;

public class PacketSceneCast extends PacketScene
{
    public boolean open = true;

    public PacketSceneCast()
    {}

    public PacketSceneCast(SceneLocation location)
    {
        super(location);
    }

    public PacketSceneCast open(boolean open)
    {
        this.open = open;

        return this;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.open = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeBoolean(this.open);
    }
}

==================================================

--- Файл №388 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketSceneManage.java
--------------------
package mchorse.blockbuster.network.common.scene;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketSceneManage implements IMessage
{
    public static final int RENAME = 1;
    public static final int REMOVE = 2;
    public static final int DUPE = 3;

    public String source;
    public String destination;
    public int action;

    public PacketSceneManage()
    {}

    public PacketSceneManage(String source, String destination, int action)
    {
        this.source = source;
        this.destination = destination;
        this.action = action;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.source = ByteBufUtils.readUTF8String(buf);
        this.destination = ByteBufUtils.readUTF8String(buf);
        this.action = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.source);
        ByteBufUtils.writeUTF8String(buf, this.destination);
        buf.writeInt(this.action);
    }
}

==================================================

--- Файл №389 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketScenePause.java
--------------------
package mchorse.blockbuster.network.common.scene;

import mchorse.blockbuster.recording.scene.SceneLocation;

public class PacketScenePause extends PacketScene
{
    public PacketScenePause()
    {}

    public PacketScenePause(SceneLocation location)
    {
        super(location);
    }
}

==================================================

--- Файл №390 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketScenePlayback.java
--------------------
package mchorse.blockbuster.network.common.scene;

import mchorse.blockbuster.recording.scene.SceneLocation;

public class PacketScenePlayback extends PacketScene
{
    public PacketScenePlayback()
    {}

    public PacketScenePlayback(SceneLocation location)
    {
        super(location);
    }
}

==================================================

--- Файл №391 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketSceneRecord.java
--------------------
package mchorse.blockbuster.network.common.scene;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.scene.SceneLocation;
import net.minecraftforge.fml.common.network.ByteBufUtils;

public class PacketSceneRecord extends PacketScene
{
    public String record = "";
    public int offset;

    public PacketSceneRecord()
    {}

    public PacketSceneRecord(SceneLocation location, String record, int offset)
    {
        this(location, record);

        this.offset = offset;
    }

    public PacketSceneRecord(SceneLocation location, String record)
    {
        super(location);

        this.record = record;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.record = ByteBufUtils.readUTF8String(buf);
        this.offset = buf.readInt();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        ByteBufUtils.writeUTF8String(buf, this.record);
        buf.writeInt(this.offset);
    }
}

==================================================

--- Файл №392 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketSceneRequestCast.java
--------------------
package mchorse.blockbuster.network.common.scene;

import mchorse.blockbuster.recording.scene.SceneLocation;

public class PacketSceneRequestCast extends PacketScene
{
    public PacketSceneRequestCast()
    {}

    public PacketSceneRequestCast(SceneLocation location)
    {
        super(location);
    }
}


==================================================

--- Файл №393 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\PacketScenes.java
--------------------
package mchorse.blockbuster.network.common.scene;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import java.util.ArrayList;
import java.util.List;

public class PacketScenes implements IMessage
{
    public List<String> scenes = new ArrayList<String>();

    public PacketScenes()
    {}

    public PacketScenes(List<String> scenes)
    {
        this.scenes = scenes;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        for (int i = 0, c = buf.readInt(); i < c; i ++)
        {
            this.scenes.add(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.scenes.size());

        for (String scene : this.scenes)
        {
            ByteBufUtils.writeUTF8String(buf, scene);
        }
    }
}

==================================================

--- Файл №394 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\sync\PacketSceneGoto.java
--------------------
package mchorse.blockbuster.network.common.scene.sync;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.network.common.scene.PacketScene;
import mchorse.blockbuster.recording.scene.SceneLocation;

/**
 * Packet director go to
 *
 * This packet stores information about where user wants a director block to go
 * to (in terms of playback ticks).
 */
public class PacketSceneGoto extends PacketScene
{
    public int tick;
    public boolean actions;

    public PacketSceneGoto()
    {}

    public PacketSceneGoto(SceneLocation location, int tick, boolean actions)
    {
        super(location);

        this.tick = tick;
        this.actions = actions;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.tick = buf.readInt();
        this.actions = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeInt(this.tick);
        buf.writeBoolean(this.actions);
    }
}

==================================================

--- Файл №395 ---
Путь: main\java\mchorse\blockbuster\network\common\scene\sync\PacketScenePlay.java
--------------------
package mchorse.blockbuster.network.common.scene.sync;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.network.common.scene.PacketScene;
import mchorse.blockbuster.recording.scene.SceneLocation;

/**
 * Packet director play
 *
 * This packet stores information about whether to play, stop or pause the
 * director.
 */
public class PacketScenePlay extends PacketScene
{
    public static final byte STOP = 0;
    public static final byte PLAY = 1;
    public static final byte PAUSE = 2;
    public static final byte START = 3;
    public static final byte RESTART = 4;

    public byte state;
    public int tick;

    public PacketScenePlay()
    {}

    public PacketScenePlay(SceneLocation location, byte state, int tick)
    {
        super(location);

        this.state = state;
        this.tick = tick;
    }

    public boolean isStop()
    {
        return this.state == STOP;
    }

    public boolean isPlay()
    {
        return this.state == PLAY;
    }

    public boolean isPause()
    {
        return this.state == PAUSE;
    }

    public boolean isStart()
    {
        return this.state == START;
    }

    public boolean isRestart()
    {
        return this.state == RESTART;
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        super.toBytes(buf);

        buf.writeByte(this.state);
        buf.writeInt(this.tick);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        super.fromBytes(buf);

        this.state = buf.readByte();
        this.tick = buf.readInt();
    }
}

==================================================

--- Файл №396 ---
Путь: main\java\mchorse\blockbuster\network\common\structure\PacketStructure.java
--------------------
package mchorse.blockbuster.network.common.structure;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketStructure implements IMessage
{
    public String name = "";
    public NBTTagCompound tag;

    public PacketStructure()
    {}

    public PacketStructure(String name, NBTTagCompound tag)
    {
        this.name = name;
        this.tag = tag;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.name = ByteBufUtils.readUTF8String(buf);
        this.tag = NBTUtils.readInfiniteTag(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.name);
        ByteBufUtils.writeTag(buf, this.tag);
    }
}

==================================================

--- Файл №397 ---
Путь: main\java\mchorse\blockbuster\network\common\structure\PacketStructureList.java
--------------------
package mchorse.blockbuster.network.common.structure;

import java.util.ArrayList;
import java.util.List;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketStructureList implements IMessage
{
    public List<String> structures;

    public PacketStructureList()
    {
        this.structures = new ArrayList<String>();
    }

    public PacketStructureList(List<String> structures)
    {
        this.structures = structures;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.structures.clear();

        for (int i = 0, c = buf.readInt(); i < c; i++)
        {
            this.structures.add(ByteBufUtils.readUTF8String(buf));
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.structures.size());

        for (String str : this.structures)
        {
            ByteBufUtils.writeUTF8String(buf, str);
        }
    }
}

==================================================

--- Файл №398 ---
Путь: main\java\mchorse\blockbuster\network\common\structure\PacketStructureListRequest.java
--------------------
package mchorse.blockbuster.network.common.structure;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketStructureListRequest implements IMessage
{
    public PacketStructureListRequest()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №399 ---
Путь: main\java\mchorse\blockbuster\network\common\structure\PacketStructureRequest.java
--------------------
package mchorse.blockbuster.network.common.structure;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketStructureRequest implements IMessage
{
    public String name = "";

    public PacketStructureRequest()
    {}

    public PacketStructureRequest(String name)
    {
        this.name = name;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.name = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.name);
    }
}

==================================================

--- Файл №400 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerApplyFrame.java
--------------------
package mchorse.blockbuster.network.server;

import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.PacketApplyFrame;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.ForgeUtils;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerApplyFrame  extends ServerMessageHandler<PacketApplyFrame>
{
    @Override
    public void run(EntityPlayerMP player, PacketApplyFrame packet)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Entity entity = player.world.getEntityByID(packet.getEntityID());

        if (entity instanceof EntityLivingBase)
        {
            packet.getFrame().apply((EntityLivingBase) entity, true);

            /* Frame does not apply bodyYaw, EntityActor.updateDistance() does... TODO refactor this*/
            ((EntityLivingBase) entity).renderYawOffset = packet.getFrame().bodyYaw;

            Dispatcher.sendToAll(packet);
        }
    }
}


==================================================

--- Файл №401 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerDamageControlCheck.java
--------------------
package mchorse.blockbuster.network.server;

import java.util.Map;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.common.PacketDamageControlCheck;
import mchorse.blockbuster.recording.capturing.DamageControl;
import mchorse.blockbuster.recording.capturing.DamageControl.BlockEntry;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.text.TextComponentTranslation;

public class ServerHandlerDamageControlCheck extends ServerMessageHandler<PacketDamageControlCheck>
{
    @Override
    public void run(EntityPlayerMP player, PacketDamageControlCheck packet)
    {
        if (packet.pointPos != null && !player.world.isAirBlock(packet.pointPos))
        {
            Scene target = null;
            
            for (Map.Entry<Object, DamageControl> entry : CommonProxy.damage.damage.entrySet())
            {
                if (!(entry.getKey() instanceof Scene))
                {
                    continue;
                }
                
                DamageControl control = entry.getValue();
                
                for (BlockEntry block : control.blocks)
                {
                    if (block.pos.equals(packet.pointPos))
                    {
                        target = (Scene) entry.getKey();
                        break;
                    }
                }
                
                if (target != null)
                {
                    break;
                }
                
                double x = Math.abs(control.target.posX - (double) packet.pointPos.getX());
                double y = Math.abs(control.target.posY - (double) packet.pointPos.getY());
                double z = Math.abs(control.target.posZ - (double) packet.pointPos.getZ());
                
                if (x <= control.maxDistance && y <= control.maxDistance && z <= control.maxDistance)
                {
                    target = (Scene) entry.getKey();
                    break;
                }
            }
            
            if (target != null)
            {
                player.sendStatusMessage(new TextComponentTranslation(
                        "blockbuster.info.damage_control.message", target.getId()), true);
            }
        }
    }
}


==================================================

--- Файл №402 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerModifyActor.java
--------------------
package mchorse.blockbuster.network.server;

import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.common.PacketModifyActor;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayerMP;

/**
 * Server handler modify actor
 *
 * This handler is responsible for injecting all of the values from recieved
 * message into actor entity via special defined method.
 */
public class ServerHandlerModifyActor extends ServerMessageHandler<PacketModifyActor>
{
    @Override
    public void run(EntityPlayerMP player, PacketModifyActor message)
    {
        Entity entity = player.world.getEntityByID(message.id);

        if (entity instanceof EntityActor)
        {
            ((EntityActor) entity).modify(message.morph, message.invisible, true);
        }
    }
}

==================================================

--- Файл №403 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerModifyModelBlock.java
--------------------
package mchorse.blockbuster.network.server;

import mchorse.blockbuster.common.block.BlockModel;
import mchorse.blockbuster.common.tileentity.TileEntityModel;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketModifyModelBlock;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.network.NetworkRegistry.TargetPoint;

public class ServerHandlerModifyModelBlock extends ServerMessageHandler<PacketModifyModelBlock>
{
    @Override
    public void run(EntityPlayerMP player, PacketModifyModelBlock message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        BlockPos pos = message.pos;
        TileEntity tile = this.getTE(player, pos);

        if (tile instanceof TileEntityModel)
        {
            ((TileEntityModel) tile).copyData(message.model, false);

            //set the blockstate in the world - important for servers
            tile.getWorld().setBlockState(message.pos, tile.getWorld().getBlockState(message.pos).withProperty(BlockModel.LIGHT, message.model.getSettings().getLightValue()) , 2);

            Dispatcher.DISPATCHER.get().sendToDimension(message, player.dimension);
        }
    }
}

==================================================

--- Файл №404 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerPlaybackButton.java
--------------------
package mchorse.blockbuster.network.server;

import mchorse.blockbuster.common.item.ItemPlayback;
import mchorse.blockbuster.network.common.PacketPlaybackButton;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;

public class ServerHandlerPlaybackButton extends ServerMessageHandler<PacketPlaybackButton>
{
    @Override
    public void run(EntityPlayerMP player, PacketPlaybackButton message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        ItemStack stack = player.getHeldItemMainhand();

        if (!(stack.getItem() instanceof ItemPlayback))
        {
            stack = player.getHeldItemOffhand();
        }

        if (!(stack.getItem() instanceof ItemPlayback))
        {
            return;
        }

        NBTTagCompound compound = stack.getTagCompound();

        if (compound == null)
        {
            compound = new NBTTagCompound();
            stack.setTagCompound(compound);
        }

        compound.removeTag("CameraPlay");
        compound.removeTag("CameraProfile");
        compound.removeTag("Scene");

        if (message.location.isScene())
        {
            compound.setString("Scene", message.location.getFilename());
        }

        if (message.mode == 1)
        {
            compound.setBoolean("CameraPlay", true);
        }
        else if (message.mode == 2)
        {
            compound.setString("CameraProfile", message.profile);
        }
    }
}


==================================================

--- Файл №405 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerReloadModels.java
--------------------
package mchorse.blockbuster.network.server;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.network.common.PacketReloadModels;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerReloadModels extends ServerMessageHandler<PacketReloadModels>
{
    @Override
    public void run(EntityPlayerMP player, PacketReloadModels message)
    {
        if (player.canUseCommand(2, ""))
        {
            Blockbuster.reloadServerModels(message.force);
            Blockbuster.l10n.success(player, "model.reload");
        }
        else
        {
            Blockbuster.l10n.error(player, "model.reload");
        }
    }
}

==================================================

--- Файл №406 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerStructureListRequest.java
--------------------
package mchorse.blockbuster.network.server;

import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.structure.PacketStructureList;
import mchorse.blockbuster.network.common.structure.PacketStructureListRequest;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerStructureListRequest extends ServerMessageHandler<PacketStructureListRequest>
{
    @Override
    public void run(EntityPlayerMP player, PacketStructureListRequest message)
    {
        Dispatcher.sendTo(new PacketStructureList(ServerHandlerStructureRequest.getAllStructures()), player);
    }
}

==================================================

--- Файл №407 ---
Путь: main\java\mchorse\blockbuster\network\server\ServerHandlerStructureRequest.java
--------------------
package mchorse.blockbuster.network.server;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.structure.PacketStructure;
import mchorse.blockbuster.network.common.structure.PacketStructureRequest;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.WorldServer;
import net.minecraft.world.gen.structure.template.Template;
import net.minecraft.world.gen.structure.template.TemplateManager;
import net.minecraftforge.common.DimensionManager;

public class ServerHandlerStructureRequest extends ServerMessageHandler<PacketStructureRequest>
{
    public static List<String> getAllStructures()
    {
        List<String> structures = new ArrayList<String>();
        File files = getStructureFolder("");

        if (!files.isDirectory())
        {
            return structures;
        }

        for (File file : files.listFiles())
        {
            String name = file.getName();

            if (file.isFile() && name.endsWith(".nbt"))
            {
                structures.add(name.substring(0, name.lastIndexOf(".")));
            }
        }

        return structures;
    }

    public static File getStructureFolder(String name)
    {
        return new File(DimensionManager.getCurrentSaveRootDirectory(), "structures" + (name.isEmpty() ? "" : "/" + name + ".nbt"));
    }

    @Override
    public void run(EntityPlayerMP player, PacketStructureRequest message)
    {
        WorldServer world = player.getServerWorld();
        TemplateManager manager = world.getStructureTemplateManager();

        try
        {
            if (!message.name.isEmpty())
            {
                this.sendTemplate(player, message.name, manager.getTemplate(player.mcServer, new ResourceLocation(message.name)));

                return;
            }

            for (String struct : getAllStructures())
            {
                this.sendTemplate(player, struct, manager.getTemplate(player.mcServer, new ResourceLocation(struct)));
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Send the template to a player 
     */
    public void sendTemplate(EntityPlayerMP player, String key, Template template)
    {
        NBTTagCompound tag = new NBTTagCompound();

        template.writeToNBT(tag);
        Dispatcher.sendTo(new PacketStructure(key, tag), player);
    }
}

==================================================

--- Файл №408 ---
Путь: main\java\mchorse\blockbuster\network\server\gun\ServerHandlerGunInfo.java
--------------------
package mchorse.blockbuster.network.server.gun;

import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketGunInfo;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class ServerHandlerGunInfo extends ServerMessageHandler<PacketGunInfo>
{
    @Override
    public void run(EntityPlayerMP player, PacketGunInfo message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }
        
        ItemStack stack = player.getHeldItemMainhand();

        if (NBTUtils.saveGunProps(stack, message.tag))
        {
            IMessage packet = new PacketGunInfo(message.tag, player.getEntityId());
            Dispatcher.sendTo(packet, player);
            Dispatcher.sendToTracked(player, packet);
        }
    }
}

==================================================

--- Файл №409 ---
Путь: main\java\mchorse\blockbuster\network\server\gun\ServerHandlerGunInteract.java
--------------------
package mchorse.blockbuster.network.server.gun;

import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.guns.PacketGunInteract;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class ServerHandlerGunInteract extends ServerMessageHandler<PacketGunInteract>
{
    @Override
    public void run(EntityPlayerMP player, PacketGunInteract packet)
    {
        interactWithGun(player, player.world.getEntityByID(packet.id), packet.stack);
    }

    public static void interactWithGun(EntityPlayerMP player, Entity entity, ItemStack stack)
    {
        if (!(stack.getItem() instanceof ItemGun))
        {
            return;
        }

        ItemGun gun = (ItemGun) stack.getItem();
        GunProps props = NBTUtils.getGunProps(stack);

        if (props == null)
        {
            return;
        }

        EntityPlayer entityPlayer = entity instanceof EntityPlayer ? (EntityPlayer) entity : ((EntityActor) entity).fakePlayer;

        if (props.state == ItemGun.GunState.READY_TO_SHOOT && (entity instanceof EntityActor || props.storedShotDelay == 0))
        {
            if (player != null)
            {
                Dispatcher.sendTo(new PacketGunInteract(stack, entity.getEntityId()), player);
            }

            gun.shootIt(stack, entityPlayer, entityPlayer.world);
        }
    }
}

==================================================

--- Файл №410 ---
Путь: main\java\mchorse\blockbuster\network\server\gun\ServerHandlerGunReloading.java
--------------------
package mchorse.blockbuster.network.server.gun;

import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.network.common.guns.PacketGunReloading;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class ServerHandlerGunReloading extends ServerMessageHandler<PacketGunReloading>
{
    @Override
    public void run(EntityPlayerMP entityPlayerMP, PacketGunReloading packet)
    {
        ItemStack item = entityPlayerMP.getHeldItemMainhand();
        
        if (item.getItem() instanceof ItemGun)
        {
            ItemGun gun = (ItemGun) item.getItem();

            gun.reload(entityPlayerMP, item);
        }
    }
}

==================================================

--- Файл №411 ---
Путь: main\java\mchorse\blockbuster\network\server\gun\ServerHandlerZoomCommand.java
--------------------
package mchorse.blockbuster.network.server.gun;

import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.item.ItemGun;
import mchorse.blockbuster.network.common.guns.PacketZoomCommand;
import mchorse.blockbuster.utils.NBTUtils;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class ServerHandlerZoomCommand extends ServerMessageHandler<PacketZoomCommand>
{
    @Override
    public void run(EntityPlayerMP player, PacketZoomCommand message)
    {
        if (!(player.getHeldItemMainhand().getItem() instanceof ItemGun))
        {
            return;
        }

        Entity entity = player.world.getEntityByID(message.entity);
        GunProps props = NBTUtils.getGunProps(player.getHeldItemMainhand());

        if (props == null || !(entity instanceof EntityPlayer))
        {
            return;
        }

        if (message.zoomOn)
        {
            if (!props.zoomOnCommand.isEmpty())
            {
                player.getServer().commandManager.executeCommand(player, props.zoomOnCommand);
            }
        }
        else
        {
            if (!props.zoomOffCommand.isEmpty())
            {
                player.getServer().commandManager.executeCommand(player, props.zoomOffCommand);
            }
        }
    }
}

==================================================

--- Файл №412 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\ServerHandlerFramesChunk.java
--------------------
package mchorse.blockbuster.network.server.recording;

import java.io.IOException;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.network.common.recording.PacketFramesChunk;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.FrameChunk;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerFramesChunk extends ServerMessageHandler<PacketFramesChunk>
{
    @Override
    public void run(EntityPlayerMP player, PacketFramesChunk message)
    {
        Record serverRecord = CommonProxy.manager.records.get(message.filename);
        FrameChunk chunk = CommonProxy.manager.chunks.get(message.filename);

        if (serverRecord == null)
        {
            return;
        }

        if (chunk == null)
        {
            chunk = new FrameChunk(message.count, message.offset);

            CommonProxy.manager.chunks.put(message.filename, chunk);
        }

        chunk.add(message.index, message.frames);

        if (chunk.isFilled())
        {
            try
            {
                Recording.get(player).addRecording(message.filename, System.currentTimeMillis());

                serverRecord.frames = chunk.compile(serverRecord.frames);
                serverRecord.save(RecordUtils.replayFile(message.filename));
                serverRecord.fillMissingActions();

                CommonProxy.manager.chunks.remove(message.filename);
            }
            catch (IOException e)
            {
                e.printStackTrace();
            }
        }
    }
}

==================================================

--- Файл №413 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\ServerHandlerFramesOverwrite.java
--------------------
package mchorse.blockbuster.network.server.recording;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.PacketFramesOverwrite;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.network.mclib.client.ClientHandlerAnswer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

public class ServerHandlerFramesOverwrite extends ServerMessageHandler<PacketFramesOverwrite>
{
    /**
     * In case many people on a server want to overwrite the same record - avoid collision with packets.
     * The key identifies which record should have which ticks overwritten.
     * TODO If two people at the same time want to override the same ticks, this may be a problem.
     */
    private static Map<OverwriteIdentifier, List<Frame>> overwriteQueue = new HashMap<>();

    @Override
    public void run(EntityPlayerMP entityPlayerMP, PacketFramesOverwrite packet)
    {
        Record targetRecord;
        IKey answer = null;
        boolean status = false;

        if (packet.frames.isEmpty())
        {
            System.out.println("Received an empty chunk...");

            return;
        }

        try
        {
            targetRecord = CommonProxy.manager.get(packet.filename);

            if (targetRecord == null)
            {
                this.sendAnswer(packet, entityPlayerMP, IKey.format("blockbuster.error.recording.not_found", packet.filename), false);

                return;
            }
        }
        catch (Exception e)
        {
            this.sendAnswer(packet, entityPlayerMP, IKey.lang("blockbuster.gui.director.rotation_filter.record_save_error"), false);

            return;
        }

        OverwriteIdentifier key = null;

        /*
         * the constructor sorts from and to tick already.
         * It is important that from tick is always smaller than to tick, no matter what the client sends!
         */
        OverwriteIdentifier targetKey = new OverwriteIdentifier(packet.getFrom(), packet.getTo(), packet.filename);

        for (Map.Entry<OverwriteIdentifier, List<Frame>> entry : overwriteQueue.entrySet())
        {
            if (entry.getKey().equals(targetKey))
            {
                key = entry.getKey();

                break;
            }
        }

        if (key == null)
        {
            key = targetKey;

            overwriteQueue.put(key, new ArrayList<>());
        }

        List<Frame> frames = overwriteQueue.get(key);

        if (this.insertChunk(packet.frames, packet.getIndex(), frames))
        {
            if (frames.size() == (key.toTick - key.fromTick) + 1 && !frames.contains(null))
            {
                if (key.toTick >= targetRecord.frames.size())
                {
                    status = false;
                    answer = IKey.lang("blockbuster.gui.director.rotation_filter.record_save_error");

                    System.out.println("toTick " + key.toTick + " out of range of record frames size.");
                }
                else
                {
                    for (int i = key.fromTick; i <= key.toTick; i++)
                    {
                        targetRecord.frames.set(i, frames.get(i - key.fromTick));
                    }

                    try
                    {
                        RecordUtils.saveRecord(targetRecord);

                        status = true;
                        answer = IKey.lang("blockbuster.gui.director.rotation_filter.success");
                    }
                    catch (IOException e)
                    {
                        status = false;
                        answer = IKey.lang("blockbuster.gui.director.rotation_filter.record_save_error");

                        e.printStackTrace();
                    }
                }

                overwriteQueue.remove(key);
            }
        }
        else
        {
            status = false;
            answer = IKey.lang("blockbuster.gui.director.rotation_filter.frame_chunk_error");

            overwriteQueue.remove(key);
        }

        if (answer != null)
        {
            this.sendAnswer(packet, entityPlayerMP, answer, status);
        }
    }

    private void sendAnswer(PacketFramesOverwrite packet, EntityPlayerMP player, IKey message, boolean status)
    {
        if (packet.getCallbackID().isPresent())
        {
            ClientHandlerAnswer.sendAnswerTo(player, packet.getAnswer(new AbstractMap.SimpleEntry<>(message, status)));
        }
    }

    @SideOnly(Side.CLIENT)
    public static void sendFramesToServer(String filename, List<Frame> frames, int from, int to)
    {
        sendFramesToServer(filename, frames, from, to, null);
    }

    /**
     *
     * @param filename
     * @param frames
     * @param from
     * @param to
     * @param callback the callback that should be called when the answer from the server returns
     */
    @SideOnly(Side.CLIENT)
    public static void sendFramesToServer(String filename, List<Frame> frames, int from, int to,
                                          @Nullable Consumer<AbstractMap.SimpleEntry<IKey, Boolean>> callback)
    {
        int cap = 400;

        if (frames.size() <= cap)
        {
            if (callback != null)
            {
                ClientHandlerAnswer.requestServerAnswer(Dispatcher.DISPATCHER,
                        new PacketFramesOverwrite(from, to, 0, filename, frames), callback);
            }
            else
            {
                Dispatcher.sendToServer(new PacketFramesOverwrite(from, to, 0, filename, frames));
            }

            return;
        }

        List<Frame> chunk = new ArrayList<>();
        int chunkStart = 0;

        for (int i = 0; i < frames.size(); i++)
        {
            chunk.add(frames.get(i));

            if (chunk.size() == cap || i == frames.size() - 1)
            {
                if (callback != null)
                {
                    ClientHandlerAnswer.requestServerAnswer(Dispatcher.DISPATCHER, new PacketFramesOverwrite(from, to, chunkStart, filename, chunk), callback);
                }
                else
                {
                    Dispatcher.sendToServer(new PacketFramesOverwrite(from, to, chunkStart, filename, chunk));
                }

                chunk.clear();

                chunkStart += cap;
            }
        }
    }

    protected boolean insertChunk(List<Frame> chunk, int targetIndex, List<Frame> frames)
    {
        /*
         * in case packets got shuffled on the way to the server,
         * check how to insert the chunk properly
         */
        if (targetIndex > frames.size())
        {
            Frame[] nulls = new Frame[targetIndex - frames.size()];

            frames.addAll(Arrays.asList(nulls));
            frames.addAll(chunk);
        }
        else if (targetIndex == frames.size())
        {
            frames.addAll(chunk);
        }
        else
        {
            int i = targetIndex;

            while (i < frames.size() && i < targetIndex + chunk.size())
            {
                if (frames.get(i) != null)
                {
                    break;
                }

                i++;
            }

            /* if the part in frames only contains nulls insert chunk */
            if (i == targetIndex + chunk.size())
            {
                for (int j = targetIndex; j < targetIndex + chunk.size(); j++)
                {
                    frames.set(j, chunk.get(j - targetIndex));
                }
            }
            else
            {
                /* the chunk doesn't fit in the slot because there are non null values */
                return false;
            }
        }

        return true;
    }

    /**
     * Identifier which record should get the specified ticks overwritten.
     */
    private static class OverwriteIdentifier
    {
        /**
         * From tick to overwrite
         */
        private int fromTick;
        /**
         * To tick (inclusive) to overwrite to
         */
        private int toTick;
        private String filename;

        /**
         * Sorts from and to
         * @param from
         * @param to
         * @param filename
         */
        public OverwriteIdentifier(int from, int to, String filename)
        {
            this.fromTick = Math.min(from, to);
            this.toTick = Math.max(from, to);
            this.filename = filename;
        }

        @Override
        public boolean equals(Object obj)
        {
            if (obj instanceof OverwriteIdentifier)
            {
                OverwriteIdentifier framesOverwrite = (OverwriteIdentifier) obj;

                return framesOverwrite.filename.equals(this.filename)
                        && framesOverwrite.fromTick == this.fromTick
                        && framesOverwrite.toTick == this.toTick;
            }

            return false;
        }
    }
}


==================================================

--- Файл №414 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\ServerHandlerPlayback.java
--------------------
package mchorse.blockbuster.network.server.recording;

import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.common.recording.PacketPlayback;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerPlayback extends ServerMessageHandler<PacketPlayback>
{
    @Override
    public void run(EntityPlayerMP player, PacketPlayback message)
    {
        EntityActor actor = (EntityActor) player.world.getEntityByID(message.id);

        if (actor.playback != null)
        {
            actor.playback.playing = message.state;
        }
    }
}


==================================================

--- Файл №415 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\ServerHandlerRequestFrames.java
--------------------
package mchorse.blockbuster.network.server.recording;

import mchorse.blockbuster.network.common.recording.PacketRequestFrames;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestFrames extends ServerMessageHandler<PacketRequestFrames>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestFrames message)
    {
        RecordUtils.sendRequestedRecord(message.id, message.filename, player);
    }
}

==================================================

--- Файл №416 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\ServerHandlerRequestRecording.java
--------------------
package mchorse.blockbuster.network.server.recording;

import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.client.recording.ClientHandlerFramesLoad;
import mchorse.blockbuster.network.common.recording.PacketRequestRecording;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.util.function.Consumer;

public class ServerHandlerRequestRecording extends ServerMessageHandler<PacketRequestRecording>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestRecording message)
    {
        if (message.getCallbackID().isPresent())
        {
            RecordUtils.sendRecordTo(message.getFilename(), player, message.getCallbackID().get());
        }
        else
        {
            RecordUtils.sendRecordTo(message.getFilename(), player);
        }
    }

    /**
     * Request recording from server
     * @param filename
     * @param consumer the consumer that should be executed after the server has sent its answer
     */
    @SideOnly(Side.CLIENT)
    public static void requestRecording(String filename, @Nullable Consumer<Record> consumer)
    {
        if (consumer != null)
        {
            int id = ClientHandlerFramesLoad.registerConsumer(consumer);

            Dispatcher.sendToServer(new PacketRequestRecording(filename, id));
        }
        else
        {
            Dispatcher.sendToServer(new PacketRequestRecording(filename));
        }
    }

    /**
     * Request recording from server
     * @param filename
     */
    @SideOnly(Side.CLIENT)
    public static void requestRecording(String filename)
    {
        requestRecording(filename, null);
    }
}

==================================================

--- Файл №417 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\ServerHandlerUpdatePlayerData.java
--------------------
package mchorse.blockbuster.network.server.recording;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.common.recording.PacketUpdatePlayerData;
import mchorse.blockbuster.recording.MPMHelper;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.nbt.NBTTagCompound;

public class ServerHandlerUpdatePlayerData extends ServerMessageHandler<PacketUpdatePlayerData>
{
    @Override
    public void run(EntityPlayerMP player, PacketUpdatePlayerData message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Record record = null;

        try
        {
            record = CommonProxy.manager.get(message.record);
        }
        catch (Exception e)
        {}

        if (record == null)
        {
            Blockbuster.l10n.error(player, "record.not_exist", message.record);

            return;
        }

        NBTTagCompound tag = new NBTTagCompound();

        player.writeEntityToNBT(tag);
        record.playerData = tag;

        if (MPMHelper.isLoaded())
        {
            tag = MPMHelper.getMPMData(player);

            if (tag != null)
            {
                record.playerData.setTag("MPMData", tag);
            }
        }

        record.dirty = true;
        record.resetUnload();
    }
}

==================================================

--- Файл №418 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\actions\ServerHandlerActionsChange.java
--------------------
package mchorse.blockbuster.network.server.recording.actions;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.client.gui.dashboard.panels.recording_editor.GuiRecordTimeline.Selection;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.actions.PacketActionsChange;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

public class ServerHandlerActionsChange extends ServerMessageHandler<PacketActionsChange>
{
    @Override
    public void run(EntityPlayerMP player, PacketActionsChange message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Record record = null;

        try
        {
            record = CommonProxy.manager.get(message.getFilename());
        }
        catch (Exception e)
        {}

        if (record == null)
        {
            return;
        }

        if (message.getFromTick() >= 0)
        {
            switch (message.getStatus())
            {
                case DELETE:
                    record.removeActionsMask(message.getFromTick(), message.getMask());

                    break;
                case ADD:
                    if (message.getIndex() != -1)
                    {
                        if (message.containsOneAction())
                        {
                            record.addActionCollection(message.getFromTick(), message.getIndex(), message.getActions());
                        }
                    }
                    else
                    {
                        record.addActionCollection(message.getFromTick(), message.getActions());
                    }

                    break;
                case EDIT:
                    if (message.getIndex() != -1)
                    {
                        if (message.containsOneAction())
                        {
                            record.replaceAction(message.getFromTick(), message.getIndex(), message.getActions().get(0).get(0));
                        }
                    }

                    break;
            }

            try
            {
                RecordUtils.saveRecord(record, false, false);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }

    /**
     * Send a deletion package to the server
     */
    @SideOnly(Side.CLIENT)
    public static void deleteActions(Record record, int from, List<List<Boolean>> mask)
    {
        record.removeActionsMask(from, mask);
        Dispatcher.sendToServer(new PacketActionsChange(record.filename, from, mask));
    }

    /**
     * Send a package to the server to add the given actions at the given tick
     */
    @SideOnly(Side.CLIENT)
    public static void addActions(List<List<Action>> actions, Record record, int tick)
    {
        record.addActionCollection(tick, actions);
        Dispatcher.sendToServer(new PacketActionsChange(record.filename, tick, actions, PacketActionsChange.Type.ADD));
    }

    @SideOnly(Side.CLIENT)
    public static void addActions(List<List<Action>> actions, Record record, int tick, int index)
    {
        if (index == -1)
        {
            addActions(actions, record, tick);
        }
        else
        {
            record.addActionCollection(tick, index, actions);
            Dispatcher.sendToServer(new PacketActionsChange(record.filename, tick, index, actions, PacketActionsChange.Type.ADD));
        }
    }

    /**
     * Send a package to the server to add an action at a specific index
     * @param action
     * @param record
     * @param tick
     * @param index
     */
    @SideOnly(Side.CLIENT)
    public static void addAction(Action action, Record record, int tick, int index)
    {
        record.addAction(tick, index, action);
        Dispatcher.sendToServer(new PacketActionsChange(record.filename, tick, index, action, PacketActionsChange.Type.ADD));
    }

    @SideOnly(Side.CLIENT)
    public static void editAction(Action action, Record record, int tick, int index)
    {
        record.replaceAction(tick, index, action);
        Dispatcher.sendToServer(new PacketActionsChange(record.filename, tick, index, action, PacketActionsChange.Type.EDIT));
    }
}

==================================================

--- Файл №419 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\actions\ServerHandlerRequestAction.java
--------------------
package mchorse.blockbuster.network.server.recording.actions;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.actions.PacketActions;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestAction;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.network.ServerMessageHandler;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestAction extends ServerMessageHandler<PacketRequestAction>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestAction message)
    {
        Record record = null;

        try
        {
            record = CommonProxy.manager.get(message.filename);
        }
        catch (Exception e)
        {}

        if (record != null)
        {
            Dispatcher.sendTo(new PacketActions(message.filename, record.actions, message.open), player);
        }
    }
}

==================================================

--- Файл №420 ---
Путь: main\java\mchorse\blockbuster\network\server\recording\actions\ServerHandlerRequestActions.java
--------------------
package mchorse.blockbuster.network.server.recording.actions;

import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.actions.PacketActionList;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestActions;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestActions extends ServerMessageHandler<PacketRequestActions>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestActions message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Dispatcher.sendTo(new PacketActionList(RecordUtils.getReplays()), player);
    }
}

==================================================

--- Файл №421 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerRequestScenes.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.PacketRequestScenes;
import mchorse.blockbuster.network.common.scene.PacketScenes;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestScenes extends ServerMessageHandler<PacketRequestScenes>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestScenes message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Dispatcher.sendTo(new PacketScenes(CommonProxy.scenes.sceneFiles()), player);
    }
}

==================================================

--- Файл №422 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerSceneCast.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.network.common.scene.PacketSceneCast;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerSceneCast extends ServerMessageHandler<PacketSceneCast>
{
    @Override
    public void run(EntityPlayerMP player, PacketSceneCast message)
    {
        if (!OpHelper.isPlayerOp(player) || message.location.isEmpty())
        {
            return;
        }

        try
        {
            CommonProxy.scenes.save(message.location.getFilename(), message.location.getScene());
            Recording.get(player).setLastScene(message.location.getFilename());
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}

==================================================

--- Файл №423 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerSceneManage.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.commands.CommandRecord;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.PacketSceneManage;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;
import net.minecraft.command.CommandException;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.common.DimensionManager;

import java.io.IOException;

public class ServerHandlerSceneManage extends ServerMessageHandler<PacketSceneManage>
{
    @Override
    public void run(EntityPlayerMP player, PacketSceneManage message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        if (message.action == PacketSceneManage.RENAME && CommonProxy.scenes.rename(message.source, message.destination))
        {
            Dispatcher.sendTo(message, player);
        }
        else if (message.action == PacketSceneManage.REMOVE && CommonProxy.scenes.remove(message.source))
        {
            Dispatcher.sendTo(message, player);
        }
        else if (message.action == PacketSceneManage.DUPE)
        {
            Scene source = CommonProxy.scenes.get(message.source, player.getEntityWorld());

            Scene destinationDummy = new Scene();

            destinationDummy.copy(source);
            destinationDummy.setId(message.destination);
            destinationDummy.setupIds();
            destinationDummy.renamePrefix(source.getId(), destinationDummy.getId(), (id) -> id + "_copy");

            for(int i = 0; i<destinationDummy.replays.size(); i++)
            {
                Replay replaySource = source.replays.get(i);
                Replay replayDestination = destinationDummy.replays.get(i);

                int counter = 0;

                try
                {
                    Record record = CommandRecord.getRecord(replaySource.id).clone();

                    if (RecordUtils.isReplayExists(replayDestination.id))
                    {
                        continue;
                    }

                    /* This could potentially cause renaming problems like _1_2_3_4 indexes
                    while(RecordUtils.isReplayExists(replayDestination.id + ((counter != 0) ? "_"+Integer.toString(counter) : "")))
                    {
                        counter++;
                    }*/

                    record.filename = replayDestination.id + ((counter != 0) ? "_"+Integer.toString(counter) : "");
                    replayDestination.id = record.filename;

                    record.save(RecordUtils.replayFile(record.filename));

                    CommonProxy.manager.records.put(record.filename, record);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }

            Dispatcher.sendTo(message, player);
        }
    }
}

==================================================

--- Файл №424 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerScenePause.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.common.scene.PacketScenePause;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerScenePause extends ServerMessageHandler<PacketScenePause>
{
    @Override
    public void run(EntityPlayerMP player, PacketScenePause message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        if (CommonProxy.manager.recorders.containsKey(player))
        {
            if (CommonProxy.manager.cancel(player))
            {
                Blockbuster.l10n.info(player, "action.cancel");
            }
        }
        else
        {
            Scene scene = message.get(player.world);

            if (!scene.isPlaying())
            {
                scene.resume(-1);
            }
            else
            {
                scene.pause();
            }
        }
    }
}

==================================================

--- Файл №425 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerScenePlayback.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.common.scene.PacketScenePlayback;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerScenePlayback extends ServerMessageHandler<PacketScenePlayback>
{
    @Override
    public void run(EntityPlayerMP player, PacketScenePlayback message)
    {
        if (!OpHelper.isPlayerOp(player) || message.location.isEmpty())
        {
            return;
        }

        CommonProxy.scenes.toggle(message.location.getFilename(), player.world);
    }
}

==================================================

--- Файл №426 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerSceneRecord.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.common.scene.PacketSceneRecord;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerSceneRecord extends ServerMessageHandler<PacketSceneRecord>
{
    @Override
    public void run(EntityPlayerMP player, PacketSceneRecord message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        if (message.location.isScene())
        {
            CommonProxy.scenes.record(message.location.getFilename(), message.record, message.offset, player);
        }
        else
        {
            CommonProxy.manager.record(message.record, player, Mode.ACTIONS, true, true, message.offset, null);
        }
    }
}

==================================================

--- Файл №427 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\ServerHandlerSceneRequestCast.java
--------------------
package mchorse.blockbuster.network.server.scene;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.scene.PacketSceneCast;
import mchorse.blockbuster.network.common.scene.PacketSceneRequestCast;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.blockbuster.recording.scene.SceneLocation;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

/**
 * This handler is used to force request of the cast by the director.
 */
public class ServerHandlerSceneRequestCast extends ServerMessageHandler<PacketSceneRequestCast>
{
    @Override
    public void run(EntityPlayerMP player, PacketSceneRequestCast message)
    {
        if (!OpHelper.isPlayerOp(player) || message.location.isEmpty())
        {
            return;
        }

        try
        {
            Scene scene = CommonProxy.scenes.load(message.location.getFilename());

            Dispatcher.sendTo(new PacketSceneCast(new SceneLocation(scene)), player);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }
}

==================================================

--- Файл №428 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\sync\ServerHandlerSceneGoto.java
--------------------
package mchorse.blockbuster.network.server.scene.sync;

import mchorse.blockbuster.network.common.scene.sync.PacketSceneGoto;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerSceneGoto extends ServerMessageHandler<PacketSceneGoto>
{
    @Override
    public void run(EntityPlayerMP player, PacketSceneGoto message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Scene scene = message.get(player.world);

        if (scene != null)
        {
            scene.goTo(message.tick, message.actions);
        }
    }
}

==================================================

--- Файл №429 ---
Путь: main\java\mchorse\blockbuster\network\server\scene\sync\ServerHandlerScenePlay.java
--------------------
package mchorse.blockbuster.network.server.scene.sync;

import mchorse.blockbuster.network.common.scene.sync.PacketScenePlay;
import mchorse.blockbuster.recording.scene.Scene;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerScenePlay extends ServerMessageHandler<PacketScenePlay>
{
    @Override
    public void run(EntityPlayerMP player, PacketScenePlay message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Scene scene = message.get(player.world);

        if (message.isPlay())
        {
            if (!scene.playing)
            {
                scene.spawn(message.tick);
            }

            scene.resume(message.tick);
        }
        else if (message.isStop())
        {
            scene.stopPlayback(true);
        }
        else if (message.isPause())
        {
            scene.pause();
        }
        else if (message.isStart())
        {
            scene.spawn(message.tick);
        }
        else if (message.isRestart())
        {
            scene.reload(message.tick);
        }
    }
}

==================================================

--- Файл №430 ---
Путь: main\java\mchorse\blockbuster\recording\LTHelper.java
--------------------
package mchorse.blockbuster.recording;

import mchorse.blockbuster.recording.data.Frame;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.Vec3d;

import java.lang.reflect.Method;

/**
 * LittleTiles helper method
 *
 * This bad boy is responsible contacting LittleTile API (introduced in v1.5.0-pre199_31_mc1.12.2)
 * to allow opening the doors. Big thanks to CreativeMD for helping out with this issue!
 *
 * @link https://www.curseforge.com/minecraft/mc-mods/littletiles/files/2960578
 */
public class LTHelper
{
    private static Method method;
    private static boolean weTried;

    public static boolean playerRightClickServer(EntityPlayer player, Frame frame)
    {
        try
        {
            if (method == null && !weTried)
            {
                weTried = true;

                Class clazz = Class.forName("com.creativemd.littletiles.common.api.LittleTileAPI");

                method = clazz.getMethod("playerRightClickServer", EntityPlayer.class, Vec3d.class, Vec3d.class);
            }
        }
        catch (Exception e)
        {}

        if (method != null)
        {
            try
            {
                player.rotationPitch = frame.pitch;
                player.rotationYaw = frame.yaw;

                Vec3d pos = new Vec3d(frame.x, frame.y, frame.z);
                Vec3d look = player.getLookVec().scale(8);

                pos = pos.addVector(0, player.getEyeHeight(), 0);

                Object object = method.invoke(null, player, pos, pos.add(look));

                return object instanceof Boolean && ((Boolean) object).booleanValue();
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }

        return false;
    }
}

==================================================

--- Файл №431 ---
Путь: main\java\mchorse\blockbuster\recording\MPMHelper.java
--------------------
package mchorse.blockbuster.recording;

import java.lang.reflect.Method;

import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.Loader;

/**
 * MPM helper class
 * 
 * This class is responsible for setting and getting current MPM model data for 
 * given player. Reden (Charles) helped me to figure out this stuff.
 */
public class MPMHelper
{
    /* Reflection fields */
    public static Method get;
    public static Method set;
    public static Method getThing;

    /**
     * Checks whether MPM mod is loaded
     */
    public static boolean isLoaded()
    {
        return Loader.isModLoaded("moreplayermodels");
    }

    /**
     * Initiate method fields for later usage with get and set MPM data methods
     */
    public static void init()
    {
        try
        {
            Class clazz = Class.forName("noppes.mpm.ModelData");

            get = clazz.getMethod("writeToNBT");
            set = clazz.getMethod("readFromNBT", NBTTagCompound.class);
            getThing = clazz.getMethod("get", EntityPlayer.class);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Gets MPM data from given player
     */
    public static NBTTagCompound getMPMData(EntityPlayer entity)
    {
        if (get == null)
        {
            init();
        }

        if (get != null)
        {
            try
            {
                return (NBTTagCompound) get.invoke(getThing.invoke(null, entity));
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }

        return null;
    }

    /**
     * Sets MPM data on a given player
     */
    public static void setMPMData(EntityPlayer entity, NBTTagCompound tag)
    {
        if (set == null)
        {
            init();
        }

        if (set != null)
        {
            try
            {
                set.invoke(getThing.invoke(null, entity), tag);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }
}

==================================================

--- Файл №432 ---
Путь: main\java\mchorse\blockbuster\recording\package-info.java
--------------------
/**
 * <p>
 * This package used to be just a little bit refactored version of Mocap mod's
 * recording code, but since 1.4 update, this is no longer the same code it
 * used to be.
 * </p>
 *
 * <p>
 * Since I made enough changes to the source code, I think, I can count this
 * code fully as my own. In 1.4, I started from almost scratch: I removed
 * record and play threads and rewrote the recording and playback code from
 * scratch. That's what I remember, git history might disagree with me.
 * </p>
 *
 * <p>
 * However, I'm still going to honor EchebKeso and his Mocap mod, and going to
 * mention his name and/or his mod name, because he gave me a base start for
 * player recording. Thank you, EchebKeso :)
 * </p>
 *
 * @author mchorse
 *
 * @author EchebKeso
 * @link Minecraft Forum Post – http://www.minecraftforum.net/forums/mapping-and-modding/minecraft-mods/1445402-minecraft-motion-capture-mod-mocap-16-000
 * @link Source Code – https://github.com/EchebKeso/Mocap
 */

package mchorse.blockbuster.recording;

==================================================

--- Файл №433 ---
Путь: main\java\mchorse\blockbuster\recording\RecordManager.java
--------------------
package mchorse.blockbuster.recording;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketCaption;
import mchorse.blockbuster.network.common.recording.PacketPlayback;
import mchorse.blockbuster.network.common.recording.PacketPlayerRecording;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.DamageAction;
import mchorse.blockbuster.recording.data.FrameChunk;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.metamorph.api.MorphAPI;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.nbt.CompressedStreamTools;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * Record manager
 *
 * This class responsible is responsible for managing record recorders and
 * players for entity players and actors.
 */
public class RecordManager
{
    /**
     * Loaded records
     */
    public Map<String, Record> records = new HashMap<String, Record>();

    /**
     * Incomplete chunk frame only records (for recording big records)
     */
    public Map<String, FrameChunk> chunks = new HashMap<String, FrameChunk>();

    /**
     * Currently running record recorders (I have something to do about the
     * name)
     */
    public Map<EntityPlayer, RecordRecorder> recorders = new HashMap<EntityPlayer, RecordRecorder>();

    /**
     * Me: No, not {@link EntityPlayer}s, say record pla-yers, pla-yers...
     * Also me in 2020: What a cringe...
     */
    public Map<EntityLivingBase, RecordPlayer> players = new HashMap<EntityLivingBase, RecordPlayer>();

    /**
     * Scheduled recordings
     */
    public Map<EntityPlayer, ScheduledRecording> scheduled = new HashMap<EntityPlayer, ScheduledRecording>();

    /**
     * Get action list for given player
     */
    public List<Action> getActions(EntityPlayer player)
    {
        RecordRecorder recorder = this.recorders.get(player);

        return recorder == null ? null : recorder.actions;
    }

    public boolean record(String filename, EntityPlayer player, Mode mode, boolean teleportBack, boolean notify, Runnable runnable)
    {
        return this.record(filename, player, mode, teleportBack, notify, 0, runnable);
    }

    /**
     * Start recording given player to record with given filename
     */
    public boolean record(String filename, EntityPlayer player, Mode mode, boolean teleportBack, boolean notify, int offset, Runnable runnable)
    {
        Runnable proxy = () ->
        {
            if (offset > 0 && this.records.get(filename) != null && notify)
            {
                RecordPlayer recordPlayer = this.play(filename, player, Mode.ACTIONS, false);

                recordPlayer.tick = offset;
                EntityUtils.setRecordPlayer(player, recordPlayer.realPlayer());
            }

            if (runnable != null)
            {
                runnable.run();
            }
        };

        if (this.recorders.containsKey(player))
        {
            proxy.run();
        }

        if (filename.isEmpty() || this.halt(player, false, notify))
        {
            if (filename.isEmpty())
            {
                RecordUtils.broadcastError("recording.empty_filename");
            }

            return false;
        }

        for (RecordRecorder recorder : this.recorders.values())
        {
            if (recorder.record.filename.equals(filename))
            {
                RecordUtils.broadcastInfo("recording.recording", filename);

                return false;
            }
        }

        RecordRecorder recorder = new RecordRecorder(new Record(filename), mode, player, teleportBack);

        recorder.offset = offset;

        if (player.world.isRemote)
        {
            this.recorders.put(player, recorder);
        }
        else
        {
            this.setupPlayerData(recorder, player);
            CommonProxy.damage.addDamageControl(recorder, player);

            this.scheduled.put(player, new ScheduledRecording(recorder, player, proxy, (int) (Blockbuster.recordingCountdown.get() * 20), offset));
        }

        return true;
    }

    private void setupPlayerData(RecordRecorder recorder, EntityPlayer player)
    {
        NBTTagCompound tag = new NBTTagCompound();

        player.writeEntityToNBT(tag);
        recorder.record.playerData = tag;

        if (MPMHelper.isLoaded())
        {
            tag = MPMHelper.getMPMData(player);

            if (tag != null)
            {
                recorder.record.playerData.setTag("MPMData", tag);
            }
        }
    }

    /**
     * Stop recording given player
     */
    public boolean halt(EntityPlayer player, boolean hasDied, boolean notify)
    {
        return this.halt(player, hasDied, notify, false);
    }

    /**
     * Stop recording given player
     */
    public boolean halt(EntityPlayer player, boolean hasDied, boolean notify, boolean canceled)
    {
        /* Stop countdown */
        ScheduledRecording scheduled = this.scheduled.get(player);

        if (scheduled != null)
        {
            this.scheduled.remove(player);
            Dispatcher.sendTo(new PacketCaption(), (EntityPlayerMP) player);

            return true;
        }

        /* Stop the recording via command or whatever the source is */
        RecordRecorder recorder = this.recorders.get(player);

        if (recorder != null)
        {
            Record record = recorder.record;
            String filename = record.filename;

            if (!canceled && hasDied && !record.actions.isEmpty())
            {
                record.addAction(record.actions.size() - 1, new DamageAction(200.0F));
            }
            else
            {
                recorder.stop(player);
            }

            /* Remove action preview for previously recorded actions */
            RecordPlayer recordPlayer = this.players.get(player);

            if (recordPlayer != null && recordPlayer.realPlayer)
            {
                this.players.remove(player);

                EntityUtils.setRecordPlayer(player, null);
            }

            if (!canceled)
            {
                /* Apply old player recording */
                try
                {
                    Record oldRecord = this.get(filename);

                    recorder.applyOld(oldRecord);
                }
                catch (Exception e)
                {}

                this.records.put(filename, record);
            }

            this.recorders.remove(player);
            MorphAPI.demorph(player);

            if (notify)
            {
                CommonProxy.damage.restoreDamageControl(recorder, player.world);

                Dispatcher.sendTo(new PacketPlayerRecording(false, "", 0, canceled), (EntityPlayerMP) player);
            }

            return true;
        }

        return false;
    }

    /**
     * Version with default tick parameter
     */
    public RecordPlayer play(String filename, EntityLivingBase actor, Mode mode, boolean kill)
    {
        return this.play(filename, actor, mode, 0, kill);
    }

    /**
     * Start playback from given filename and given actor. You also have to
     * specify the mode of playback.
     */
    public RecordPlayer play(String filename, EntityLivingBase actor, Mode mode, int tick, boolean kill)
    {
        if (this.players.containsKey(actor))
        {
            return null;
        }

        try
        {
            Record record = this.get(filename);

            if (record.frames.size() == 0)
            {
                RecordUtils.broadcastError("recording.empty_record", filename);

                return null;
            }

            RecordPlayer playback = new RecordPlayer(record, mode, actor);

            playback.tick = tick;
            playback.kill = kill;
            playback.applyFrame(tick, actor, true);

            EntityUtils.setRecordPlayer(actor, playback);

            this.players.put(actor, playback);

            return playback;
        }
        catch (FileNotFoundException e)
        {
            RecordUtils.broadcastError("recording.not_recorded", filename);
        }
        catch (Exception e)
        {
            RecordUtils.broadcastError("recording.read", filename);
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Stop playback for the given record player
     */
    public void stop(RecordPlayer actor)
    {
        if (!this.players.containsKey(actor.actor))
        {
            return;
        }

        if (actor.actor.getHealth() > 0.0F)
        {
            if (actor.kill)
            {
                actor.actor.dismountRidingEntity();

                if (actor.realPlayer)
                {
                    if (actor.actor instanceof EntityPlayerMP)
                    {
                        Dispatcher.sendTo(new PacketPlayback(actor.actor.getEntityId(), false, actor.realPlayer, ""), (EntityPlayerMP) actor.actor);
                    }
                }
                else
                {
                    actor.actor.setDead();

                    if (actor.actor instanceof EntityPlayer)
                    {
                        actor.actor.world.getMinecraftServer().getPlayerList().playerLoggedOut((EntityPlayerMP) actor.actor);
                    }
                }
            }
            else
            {
                Dispatcher.sendToTracked(actor.actor, new PacketPlayback(actor.actor.getEntityId(), false, actor.realPlayer, ""));
            }
        }

        this.players.remove(actor.actor);
        EntityUtils.setRecordPlayer(actor.actor, null);
    }

    public boolean cancel(EntityPlayer player)
    {
        return this.halt(player, false, true, true);
    }

    /**
     * Reset the tracking manager data
     */
    public void reset()
    {
        for (Record record : this.records.values())
        {
            if (record.dirty)
            {
                try
                {
                    record.save(RecordUtils.replayFile(record.filename));
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }

        this.records.clear();
        this.chunks.clear();
        this.recorders.clear();
        this.players.clear();
    }

    /**
     * Abort the recording of action for given player
     */
    public void abort(EntityPlayer player)
    {
        if (this.recorders.containsKey(player))
        {
            RecordRecorder recorder = this.recorders.remove(player);

            RecordUtils.broadcastError("recording.logout", recorder.record.filename);
        }
    }

    /**
     * Get record by the filename
     *
     * If a record by the filename doesn't exist, then record manager tries to
     * load this record.
     */
    public Record get(String filename) throws Exception
    {
        Record record = this.records.get(filename);

        if (record == null)
        {
            File file = RecordUtils.replayFile(filename);

            record = new Record(filename);
            record.load(file);

            this.records.put(filename, record);
        }

        return record;
    }

    /**
     * Get record on the client side
     */
    @SideOnly(Side.CLIENT)
    public Record getClient(String filename)
    {
        Record record = this.records.get(filename);

        if (record == null)
        {
            try
            {
                InputStream stream = RecordUtils.getLocalReplay(filename);
                NBTTagCompound tag = CompressedStreamTools.readCompressed(stream);

                record = new Record(filename);
                record.load(tag);

                this.records.put(filename, record);
            }
            catch (Exception e)
            {}
        }

        return record;
    }

    /**
     * Unload old records and check scheduled actions
     */
    public void tick()
    {
        if (Blockbuster.recordUnload.get() && !this.records.isEmpty())
        {
            this.checkAndUnloadRecords();
        }

        if (!this.scheduled.isEmpty())
        {
            this.checkScheduled();
        }
    }

    /**
     * Check for any unloaded record and unload it if needed requirements are
     * met.
     */
    private void checkAndUnloadRecords()
    {
        Iterator<Map.Entry<String, Record>> iterator = this.records.entrySet().iterator();

        while (iterator.hasNext())
        {
            Record record = iterator.next().getValue();

            record.unload--;

            if (record.unload <= 0)
            {
                iterator.remove();
                RecordUtils.unloadRecord(record);

                try
                {
                    if (record.dirty)
                    {
                        record.save(RecordUtils.replayFile(record.filename));
                        record.dirty = false;
                    }
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Check for scheduled records and countdown them.
     */
    private void checkScheduled()
    {
        Iterator<ScheduledRecording> it = this.scheduled.values().iterator();

        while (it.hasNext())
        {
            ScheduledRecording record = it.next();

            if (record.countdown % 2 == 0)
            {
                IMessage message = new PacketCaption(new TextComponentTranslation("blockbuster.start_recording", record.recorder.record.filename, record.countdown / 20F));
                Dispatcher.sendTo(message, (EntityPlayerMP) record.player);
            }

            if (record.countdown <= 0)
            {
                record.run();
                this.recorders.put(record.player, record.recorder);
                Dispatcher.sendTo(new PacketPlayerRecording(true, record.recorder.record.filename, record.offset, false), (EntityPlayerMP) record.player);

                it.remove();

                continue;
            }

            record.countdown--;
        }
    }

    public void rename(String old, Record record)
    {
        RecordUtils.unloadRecord(record);

        this.records.remove(old);
        this.records.put(record.filename, record);

        for (String iter : RecordUtils.getReplayIterations(old))
        {
            File oldIter = new File(RecordUtils.replayFile(old).getAbsolutePath() + "~" + iter);

            oldIter.renameTo(new File(RecordUtils.replayFile(record.filename).getAbsolutePath() + "~" + iter));
        }

        RecordUtils.replayFile(old).delete();
    }
}

==================================================

--- Файл №434 ---
Путь: main\java\mchorse\blockbuster\recording\RecordPlayer.java
--------------------
package mchorse.blockbuster.recording;

import java.util.Queue;

import com.google.common.collect.Queues;

import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketActorPause;
import mchorse.blockbuster.network.common.recording.PacketPlayback;
import mchorse.blockbuster.network.common.recording.PacketSyncTick;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.EntityTracker;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.network.play.server.SPacketEntityTeleport;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.WorldServer;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * Record player class
 *
 * This thing is responsible for playing given record. It applies frames and
 * actions from the record instance on the given actor.
 */
public class RecordPlayer
{
    /**
     * Record from which this player is going to play
     */
    public Record record;

    /**
     * Play mode
     */
    public Mode mode;

    /**
     * Entity which is used by this record player to replay the action 
     */
    public EntityLivingBase actor;

    /**
     * Current tick
     */
    public int tick = 0;

    /**
     * Whether to kill an actor when player finished playing
     */
    public boolean kill = false;

    /**
     * Is this player is playing
     */
    public boolean playing = true;

    /**
     * Sync mode - pauses the playback once hit the end
     */
    public boolean sync = false;

    /**
     * It might be null
     */
    private Replay replay;

    public boolean realPlayer;

    public Queue<IMessage> unsentPackets = Queues.<IMessage>newArrayDeque();

    public boolean actorUpdated;

    public RecordPlayer(Record record, Mode mode, EntityLivingBase actor)
    {
        this.record = record;
        this.mode = mode;
        this.actor = actor;
    }

    public Replay getReplay()
    {
        return replay;
    }

    public void setReplay(Replay replay)
    {
        this.replay = replay;

        if (this.record != null)
        {
            this.record.setReplay(this.replay);
        }
    }

    public RecordPlayer realPlayer()
    {
        this.realPlayer = true;

        return this;
    }

    /**
     * Check if the record player is finished
     */
    public boolean isFinished()
    {
        boolean isFinished = this.record != null && this.tick - this.record.preDelay - this.record.postDelay >= this.record.getLength();

        if (isFinished && this.sync && this.playing)
        {
            this.pause();

            return false;
        }

        return isFinished;
    }

    /**
     * Get appropriate amount of real ticks (for accessing current 
     * action or something like this)
     */
    public int getTick()
    {
        return Math.max(0, this.record == null ? this.tick : this.tick - this.record.preDelay);
    }

    /**
     * Get current frame 
     */
    public Frame getCurrentFrame()
    {
        return this.record.getFrame(this.getTick());
    }

    /**
     * It should be called before world tick
     */
    public void playActions()
    {
        if (!this.playing || this.isFinished())
        {
            return;
        }

        if (this.record != null)
        {
            if (this.mode == Mode.ACTIONS || this.mode == Mode.BOTH) this.applyAction(this.tick, actor, false);

            this.record.resetUnload();
        }
    }

    public void next()
    {
        this.next(this.actor);
    }

    /**
     * Apply current frame and advance to the next one
     */
    public void next(EntityLivingBase actor)
    {
        if (this.record != null)
        {
            this.record.resetUnload();
        }

        if (!this.playing || this.isFinished())
        {
            return;
        }

        if (this.record != null)
        {
            if (this.mode == Mode.FRAMES || this.mode == Mode.BOTH) this.applyFrame(this.tick, actor, false);

            this.record.resetUnload();
        }

        /* Align the body with the head on spawn */
        if (this.tick == 0)
        {
            actor.renderYawOffset = actor.rotationYaw;
        }

        this.tick++;
        this.actorUpdated = true;
    }

    /**
     * Pause the playing actor
     */
    public void pause()
    {
        this.playing = false;
        this.actor.noClip = true;
        this.actor.setEntityInvulnerable(true);

        this.applyFrame(this.tick - 1, this.actor, true);

        if (this.actor.isServerWorld())
        {
            this.record.applyPreviousMorph(this.actor, this.replay, this.tick, Record.MorphType.PAUSE);

            this.sendToTracked(new PacketActorPause(this.actor.getEntityId(), true, this.tick));
        }
    }

    /**
     * Resume the paused actor
     */
    public void resume(int tick)
    {
        if (tick >= 0)
        {
            this.tick = tick;
        }

        this.playing = true;
        this.actor.noClip = false;

        if (!this.actor.world.isRemote && this.replay != null)
        {
            this.actor.setEntityInvulnerable(this.replay.invincible);
        }

        this.applyFrame(this.tick, this.actor, true);

        if (this.actor.isServerWorld())
        {
            this.record.applyPreviousMorph(this.actor, this.replay, tick, Record.MorphType.FORCE);

            this.sendToTracked(new PacketActorPause(this.actor.getEntityId(), false, this.tick));
        }
    }

    /**
     * Make an actor go to the given tick
     */
    public void goTo(int tick, boolean actions)
    {
        int preDelay = this.record.preDelay;
        int original = tick;

        if (tick > this.record.frames.size() + this.record.preDelay)
        {
            tick = this.record.frames.size() + this.record.preDelay - 1;
        }

        tick -= preDelay;

        int min = Math.min(this.tick - this.record.preDelay, tick);
        int max = Math.max(this.tick - this.record.preDelay, tick);

        if (actions)
        {
            for (int i = min; i < max; i++)
            {
                this.record.applyAction(i, this.actor);
            }
        }

        this.tick = original;
        this.record.resetUnload();
        this.record.applyFrame(this.playing ? tick : Math.max(0, tick - 1), this.actor, true, this.realPlayer);

        if (actions)
        {
            this.record.applyAction(tick, this.actor);

            if (this.replay != null)
            {
                this.record.applyPreviousMorph(this.actor, this.replay, tick, this.playing ? Record.MorphType.FORCE : Record.MorphType.PAUSE);
            }
        }

        if (this.actor.isServerWorld())
        {
            this.sendToTracked(new PacketActorPause(this.actor.getEntityId(), !this.playing, this.tick));
        }
    }

    /**
     * Start the playback, but with default tick argument
     */
    public void startPlaying(String filename, boolean kill)
    {
        this.startPlaying(filename, 0, kill);
    }

    /**
     * Start the playback, invoked by director block (more specifically by
     * DirectorTileEntity).
     */
    public void startPlaying(String filename, int tick, boolean kill)
    {
        this.tick = tick;
        this.kill = kill;
        this.sync = false;

        //TODO this should rather be in Replay.apply(EntityPlayer)
        // but there seems to be no way to then revert invulnerability based on Replay instance when recording stops
        if (!this.actor.world.isRemote && this.replay != null)
        {
            this.actor.setEntityInvulnerable(this.replay.invincible);
        }

        this.applyFrame(this.playing ? tick : tick - 1, this.actor, true);

        EntityUtils.setRecordPlayer(this.actor, this);

        this.sendToTracked(new PacketPlayback(this.actor.getEntityId(), true, this.realPlayer, filename, this.replay));

        if (this.realPlayer && this.actor instanceof EntityPlayerMP)
        {
            Dispatcher.sendTo(new PacketPlayback(this.actor.getEntityId(), true, this.realPlayer, filename, this.replay), (EntityPlayerMP) this.actor);
        }
    }

    /**
     * Stop playing
     */
    public void stopPlaying()
    {
        CommonProxy.manager.stop(this);

        this.actor.noClip = false;

        if (!this.actor.world.isRemote && this.replay != null && this.replay.invincible == true)
        {
            this.actor.setEntityInvulnerable(false);
        }
    }

    public void applyFrame(int tick, EntityLivingBase target, boolean force)
    {
        tick -= this.record.preDelay;

        if (tick < 0)
        {
            tick = 0;
        }
        else if (tick >= this.record.frames.size())
        {
            tick = this.record.frames.size() - 1;
        }

        this.record.applyFrame(tick, target, force, this.realPlayer);
    }

    public void applyAction(int tick, EntityLivingBase target, boolean safe)
    {
        this.record.applyAction(tick - this.record.preDelay, target, safe);
    }

    public void sendToTracked(IMessage packet)
    {
        if (this.actor.world.getEntityByID(this.actor.getEntityId()) != this.actor)
        {
            this.unsentPackets.add(packet);
        }
        else
        {
            Dispatcher.sendToTracked(this.actor, packet);
        }
    }

    public void checkAndSpawn()
    {
        /* Checks whether actor isn't already spawned in the world */
        if (this.actor.world.getEntityByID(this.actor.getEntityId()) != this.actor)
        {
            if (this.actor instanceof EntityActor)
            {
                if (!this.actor.isDead)
                {
                    this.actor.world.spawnEntity(this.actor);

                    EntityPlayer player = ((EntityActor) this.actor).fakePlayer;

                    player.posX = this.actor.posX;
                    player.posY = this.actor.posY;
                    player.posZ = this.actor.posZ;

                    this.actor.world.loadedEntityList.add(((EntityActor) this.actor).fakePlayer);
                }
            }
            else if (this.actor instanceof EntityPlayer)
            {
                if (this.record.playerData != null)
                {
                    if (!this.realPlayer)
                    {
                        this.actor.readEntityFromNBT(this.record.playerData);
                    }

                    if (MPMHelper.isLoaded() && this.record.playerData.hasKey("MPMData", NBT.TAG_COMPOUND))
                    {
                        MPMHelper.setMPMData((EntityPlayer) this.actor, this.record.playerData.getCompoundTag("MPMData"));
                    }
                }

                if (!this.realPlayer && !this.actor.isDead)
                {
                    this.actor.world.getMinecraftServer().getPlayerList().playerLoggedIn((EntityPlayerMP) this.actor);
                }
            }

            while (!this.unsentPackets.isEmpty())
            {
                Dispatcher.sendToTracked(this.actor, this.unsentPackets.poll());
            }
        }
    }
}

==================================================

--- Файл №435 ---
Путь: main\java\mchorse\blockbuster\recording\RecordRecorder.java
--------------------
package mchorse.blockbuster.recording;

import java.util.ArrayList;
import java.util.List;

import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.capturing.PlayerTracker;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.math.MathHelper;

/**
 * Record recorder class
 *
 * This thing is responsible for recording a record. It can record actions and
 * frames to the given recorder.
 *
 * Yeah, kinda funky naming, but it is the <s>not</s> best naming, eva!
 */
public class RecordRecorder
{
    /**
     * Initial record
     */
    public Record record;

    /**
     * List of actions which will be saved every time {@link #record(EntityPlayer)}
     * method is invoked.
     */
    public List<Action> actions = new ArrayList<Action>();

    /**
     * Recording mode (record actions, frames or both)
     */
    public Mode mode;

    /**
     * Current recording tick
     */
    public int tick = 0;

    /**
     * Recording offset
     */
    public int offset = 0;

    /**
     * Whether recorded player should be teleported back
     */
    public boolean teleportBack;

    /**
     * First frame (to restore the position)
     */
    private Frame first;

    /**
     * The offset of yaw between before and after {{@link net.minecraft.util.math.MathHelper.wrapDegrees(double)}
     */
    private float yawOffset;

    /**
     * Player tracker, this dude is responsible for tracking inventory slots,
     * swing progress and elytra flying updates
     */
    public PlayerTracker tracker;

    public RecordRecorder(Record record, Mode mode, EntityPlayer player, boolean teleportBack)
    {
        this.record = record;
        this.mode = mode;
        this.teleportBack = teleportBack;
        this.first = new Frame();
        this.first.fromPlayer(player);

        this.yawOffset = this.first.yaw - MathHelper.wrapDegrees(this.first.yaw);

        if (mode == Mode.ACTIONS || mode == Mode.BOTH)
        {
            this.tracker = new PlayerTracker(this);
        }
    }

    /**
     * Record frame from the player
     */
    public void record(EntityPlayer player)
    {
        boolean both = this.mode == Mode.BOTH;

        if (this.mode == Mode.FRAMES || both)
        {
            Frame frame = new Frame();

            frame.fromPlayer(player);
            frame.yaw -= this.yawOffset;
            frame.yawHead -= this.yawOffset;
            frame.bodyYaw -= this.yawOffset;
            frame.mountYaw -= this.yawOffset;

            this.record.frames.add(frame);
        }

        if (this.mode == Mode.ACTIONS || both)
        {
            this.tracker.track(player);

            List<Action> list = null;

            if (!this.actions.isEmpty())
            {
                list = new ArrayList<Action>();
                list.addAll(this.actions);

                this.actions.clear();
            }

            this.record.actions.add(list);
        }

        this.tick++;
    }

    public void stop(EntityPlayer player)
    {
        if (this.teleportBack && player instanceof EntityPlayerMP)
        {
            ((EntityPlayerMP) player).connection.setPlayerLocation(this.first.x, this.first.y, this.first.z, this.first.yaw, this.first.pitch);
        }
    }

    public void applyOld(Record oldRecord)
    {
        this.record.frames.addAll(oldRecord.frames);

        if (this.offset > 0)
        {
            List<List<Action>> actions = this.record.actions;
            int newSize = this.offset + actions.size();

            this.record.actions = oldRecord.actions;

            if (this.record.actions.size() < newSize)
            {
                while (this.record.actions.size() < newSize)
                {
                    this.record.actions.add(null);
                }
            }

            for (int i = 0; i < actions.size(); i++)
            {
                this.record.addActions(this.offset + i, actions.get(i));
            }
        }
    }
}

==================================================

--- Файл №436 ---
Путь: main\java\mchorse\blockbuster\recording\RecordUtils.java
--------------------
package mchorse.blockbuster.recording;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.capabilities.recording.IRecording;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.PacketApplyFrame;
import mchorse.blockbuster.network.common.recording.PacketFramesLoad;
import mchorse.blockbuster.network.common.recording.PacketRequestedFrames;
import mchorse.blockbuster.network.common.recording.PacketUnloadFrames;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Record;
import mchorse.mclib.utils.ForgeUtils;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraftforge.common.DimensionManager;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

/**
 * Utilities methods mostly to be used with recording code. Stuff like
 * broadcasting a message and sending records to players are located here.
 */
public class RecordUtils
{
    /**
     * String version of {@link #broadcastMessage(ITextComponent)}
     */
    public static void broadcastMessage(String message)
    {
        broadcastMessage(new TextComponentString(message));
    }

    /**
     * I18n formatting version of {@link #broadcastMessage(ITextComponent)}
     */
    public static void broadcastMessage(String string, Object... args)
    {
        broadcastMessage(new TextComponentTranslation(string, args));
    }

    /**
     * Send given message to everyone on the server, to everyone.
     *
     * Invoke this method only on the server side.
     */
    public static void broadcastMessage(ITextComponent message)
    {
        for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
        {
            player.sendMessage(message);
        }
    }

    /**
     * Send given error to everyone on the server, to everyone.
     *
     * Invoke this method only on the server side.
     */
    public static void broadcastError(String string, Object... objects)
    {
        for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
        {
            Blockbuster.l10n.error(player, string, objects);
        }
    }

    /**
     * Send given error to everyone on the server, to everyone.
     *
     * Invoke this method only on the server side.
     */
    public static void broadcastInfo(String string, Object... objects)
    {
        for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
        {
            Blockbuster.l10n.info(player, string, objects);
        }
    }

    /**
     * Checks whether player recording exists
     */
    public static boolean isReplayExists(String filename)
    {
        return replayFile(filename).exists() || CommonProxy.manager.records.containsKey(filename);
    }

    /**
     * Get path to replay file (located in current world save's folder)
     */
    public static File replayFile(String filename)
    {
        return Utils.serverFile("blockbuster/records", filename);
    }

    /**
     * This method gets a record that has been saved in the mod's jar file
     * @param filename
     * @return An {@link InputStream} object or null if no resource with this name is found
     */
    public static InputStream getLocalReplay(String filename)
    {
        return RecordUtils.class.getResourceAsStream("/assets/blockbuster/records/" + filename + ".dat");
    }

    /**
     * Get list of all available replays
     */
    public static List<String> getReplays()
    {
        return Utils.serverFiles("blockbuster/records");
    }

    /**
     * Get list of all available replays
     */
    public static List<String> getReplayIterations(String replay)
    {
        List<String> list = new ArrayList<String>();
        File replays = new File(DimensionManager.getCurrentSaveRootDirectory() + "/blockbuster/records");
        File[] files = replays.listFiles();

        if (files == null)
        {
            return list;
        }

        for (File file : files)
        {
            String name = file.getName();

            if (file.isFile() && name.startsWith(replay) && name.contains(".dat~"))
            {
                list.add(name.substring(name.indexOf("~") + 1));
            }
        }

        return list;
    }

    /**
     * Send record frames to given player from the server.
     * @param filename
     * @param player
     */
    public static void sendRecordTo(String filename, EntityPlayerMP player)
    {
        sendRecordTo(filename, player, -1);
    }

    /**
     * Send record frames to given player from the server.
     * @param filename
     * @param player
     * @param callbackID the id of the callback that should be executed on the client.
     *                   -1 if no callback was created or should be executed.
     */
    public static void sendRecordTo(String filename, EntityPlayerMP player, int callbackID)
    {
        if (!playerNeedsAction(filename, player))
        {
            PacketFramesLoad packet = callbackID == -1 ? new PacketFramesLoad(filename, PacketFramesLoad.State.NOCHANGES) :
                                      new PacketFramesLoad(filename, PacketFramesLoad.State.NOCHANGES, callbackID);

            Dispatcher.sendTo(packet, player);

            return;
        }

        RecordManager manager = CommonProxy.manager;
        Record record = manager.records.get(filename);

        if (record == null)
        {
            try
            {
                record = new Record(filename);
                record.load(replayFile(filename));

                manager.records.put(filename, record);
            }
            catch (FileNotFoundException e)
            {
                Blockbuster.l10n.error(player, "recording.not_found", filename);
                record = null;
            }
            catch (Exception e)
            {
                Blockbuster.l10n.error(player, "recording.read", filename);
                e.printStackTrace();
                record = null;
            }
        }

        if (record != null)
        {
            record.resetUnload();

            PacketFramesLoad packet = callbackID == -1 ? new PacketFramesLoad(filename, record.preDelay, record.postDelay, record.frames) :
                                      new PacketFramesLoad(filename, record.preDelay, record.postDelay, record.frames, callbackID);

            Dispatcher.sendTo(packet, player);
            System.out.println("Sent " + filename + " to " + player.getName());
        }
        else
        {
            PacketFramesLoad packet = callbackID == -1 ? new PacketFramesLoad(filename, PacketFramesLoad.State.ERROR) :
                                      new PacketFramesLoad(filename, PacketFramesLoad.State.ERROR, callbackID);

            Dispatcher.sendTo(packet, player);
        }
    }

    /**
     * Send requested frames (for actor) to given player (from the server)
     */
    public static void sendRequestedRecord(int id, String filename, EntityPlayerMP player)
    {
        Record record = CommonProxy.manager.records.get(filename);

        if (playerNeedsAction(filename, player) && record != null)
        {
            record.resetUnload();

            Dispatcher.sendTo(new PacketRequestedFrames(id, record.filename, record.preDelay, record.postDelay, record.frames), player);
            System.out.println("Sent " + filename + " to " + player.getName() + " with " + id);
        }
        else if (record == null)
        {
            Blockbuster.l10n.error(player, "recording.not_found", filename);
        }
    }

    /**
     * Checks whether given player needs a new action, meaning, he has an older
     * version of given named action or he doesn't have this action at all.
     */
    private static boolean playerNeedsAction(String filename, EntityPlayer player)
    {
        if (RecordUtils.getLocalReplay(filename) != null)
        {
            return false;
        }

        IRecording recording = Recording.get(player);

        if (recording.isFakePlayer())
        {
            return false;
        }

        boolean has = recording.hasRecording(filename);
        long time = replayFile(filename).lastModified();

        if (has && time > recording.recordingTimestamp(filename))
        {
            recording.updateRecordingTimestamp(filename, time);

            return true;
        }

        if (!has)
        {
            recording.addRecording(filename, time);
        }

        return !has;
    }

    /**
     * Unload given record. It will send to all players a packet to unload a
     * record.
     */
    public static void unloadRecord(Record record)
    {
        String filename = record.filename;

        for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
        {
             IRecording recording = Recording.get(player);

            if (recording.hasRecording(filename))
            {
                recording.removeRecording(filename);

                Dispatcher.sendTo(new PacketUnloadFrames(filename), player);
            }
        }
    }

    /* records are saved on the server side */

    public static void saveRecord(Record record) throws IOException
    {
        saveRecord(record, true);
    }

    public static void saveRecord(Record record, boolean unload) throws IOException
    {
        saveRecord(record, true, unload);
    }

    public static void saveRecord(Record record, boolean savePast, boolean unload) throws IOException
    {
        record.dirty = false;
        record.save(replayFile(record.filename), savePast);

        if (unload)
        {
            unloadRecord(record);
        }
    }

    public static void dirtyRecord(Record record)
    {
        record.dirty = true;

        unloadRecord(record);
    }

    /**
     * This method filters 360 degrees flips in the given frame list in the given rotation channel.
     * It does not modify the original list but returns a new list of frame copies.
     * @param frames the frames to filter
     * @param from from tick
     * @param to to tick (this tick will also be filtered)
     * @param channel the rotation channel of the frames to filter
     * @return the filtered frames. Returns an empty list if not enough frames are present to filter.
     */
    public static List<Frame> discontinuityEulerFilter(List<Frame> frames, int from, int to, Frame.RotationChannel channel)
    {
        List<Frame> filteredFrames = new ArrayList<>();

        if (to - from + 1 < 2) return filteredFrames;

        for (int i = from; i < frames.size() && i <= to; i++)
        {
            if (i == 0)
            {
                filteredFrames.add(frames.get(i));

                continue;
            }

            Frame filteredFrame = frames.get(i).copy();
            Frame prevFrame = frames.get(i - 1);

            if (i > from)
            {
                prevFrame = filteredFrames.get(i - from - 1);
            }

            switch (channel)
            {
                case BODY_YAW:
                    float prev = (float) Math.toRadians(prevFrame.bodyYaw);
                    float current = (float) Math.toRadians(frames.get(i).bodyYaw);
                    filteredFrame.bodyYaw = (float) Math.toDegrees(MathUtils.filterFlips(prev, current));

                    break;
                case HEAD_PITCH:
                    prev = (float) Math.toRadians(prevFrame.pitch);
                    current = (float) Math.toRadians(frames.get(i).pitch);
                    filteredFrame.pitch = (float) Math.toDegrees(MathUtils.filterFlips(prev, current));

                    break;
                case HEAD_YAW:
                    /* filter both yawHead and yaw... I hope that is correct, Minecraft is weird */
                    prev = (float) Math.toRadians(prevFrame.yawHead);
                    current = (float) Math.toRadians(frames.get(i).yawHead);
                    filteredFrame.yawHead = (float) Math.toDegrees(MathUtils.filterFlips(prev, current));

                    prev = (float) Math.toRadians(prevFrame.yaw);
                    current = (float) Math.toRadians(frames.get(i).yaw);
                    filteredFrame.yaw = (float) Math.toDegrees(MathUtils.filterFlips(prev, current));

                    break;
            }

            filteredFrames.add(filteredFrame);
        }

        return filteredFrames;
    }

    /**
     * This method applies a frame at the given tick on the given entity
     * and synchronises with all players depending on which side this method has been executed on
     * @param entity the entity where the frame should be applied
     * @param record the recording with the frames
     * @param tick the tick to apply
     */
    public static void applyFrameOnEntity(EntityLivingBase entity, Record record, int tick)
    {
        tick = MathUtils.clamp(tick, 0, record.frames.size() - 1);

        Frame frame = record.frames.get(tick);

        frame.apply(entity, true);

        /* Frame does not apply bodyYaw, EntityActor.updateDistance() does... TODO refactor this*/
        entity.renderYawOffset = frame.bodyYaw;

        PacketApplyFrame packet = new PacketApplyFrame(frame, entity.getEntityId());

        if (entity.world.isRemote)
        {
            /* send to server which will also sync it with all other players */
            Dispatcher.sendToServer(packet);
        }
        else
        {
            /* already on server - sync with all players */
            for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
            {
                Dispatcher.sendTo(packet, player);
            }
        }
    }
}

==================================================

--- Файл №437 ---
Путь: main\java\mchorse\blockbuster\recording\ScheduledRecording.java
--------------------
package mchorse.blockbuster.recording;

import net.minecraft.entity.player.EntityPlayer;

/**
 * Scheduled recorder class
 */
public class ScheduledRecording
{
    public RecordRecorder recorder;
    public EntityPlayer player;
    public Runnable runnable;
    public int countdown;
    public int offset;

    public ScheduledRecording(RecordRecorder recorder, EntityPlayer player, Runnable runnable, int countdown, int offset)
    {
        this.recorder = recorder;
        this.player = player;
        this.runnable = runnable;
        this.countdown = countdown;
        this.offset = offset;
    }

    public void run()
    {
        if (this.runnable != null)
        {
            this.runnable.run();
        }
    }
}


==================================================

--- Файл №438 ---
Путь: main\java\mchorse\blockbuster\recording\Utils.java
--------------------
package mchorse.blockbuster.recording;

import net.minecraftforge.common.DimensionManager;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class Utils
{
    /**
     * Get path to server file in given folder
     */
    public static File serverFile(String folder, String filename)
    {
        File file = new File(DimensionManager.getCurrentSaveRootDirectory() + "/" + folder);

        if (!file.exists())
        {
            file.mkdirs();
        }

        return new File(file, filename + ".dat");
    }

    /**
     * Get list of all available replays
     */
    public static List<String> serverFiles(String folder)
    {
        List<String> list = new ArrayList<String>();
        File replays = new File(DimensionManager.getCurrentSaveRootDirectory() + "/" + folder);
        File[] files = replays.listFiles();

        if (files == null)
        {
            return list;
        }

        for (File file : files)
        {
            String name = file.getName();

            if (file.isFile() && name.endsWith(".dat"))
            {
                int index = name.lastIndexOf(".");

                list.add(name.substring(0, index));
            }
        }

        return list;
    }
}

==================================================

--- Файл №439 ---
Путь: main\java\mchorse\blockbuster\recording\actions\Action.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.nbt.NBTTagCompound;

/**
 * Parent of all recording actions
 *
 * This class holds additional information about player's actions performed during
 * recording. Supports abstraction and stuffz.
 */
public abstract class Action
{
    /**
     * Apply action on an actor (shoot arrow, mount entity, break block, etc.)
     *
     * Some action doesn't necessarily should have apply method (that's why this
     * method is empty)
     */
    public void apply(EntityLivingBase actor)
    {}

    public void applyWithForce(EntityLivingBase actor)
    {
        this.apply(actor);
    }

    public void changeOrigin(double rotation, double newX, double newY, double newZ, double firstX, double firstY, double firstZ)
    {}

    public void flip(String axis, double coordinate)
    {}

    public void copyActor(EntityLivingBase actor, EntityPlayer player, Frame frame)
    {
        player.width = actor.width;
        player.height = actor.height;
        player.eyeHeight = actor.getEyeHeight();
        player.setEntityBoundingBox(actor.getEntityBoundingBox());

        player.posX = actor.posX;
        player.posY = actor.posY;
        player.posZ = actor.posZ;
        player.rotationYaw = frame.yaw;
        player.rotationPitch = frame.pitch;
        player.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, actor.getHeldItemMainhand());
        player.setItemStackToSlot(EntityEquipmentSlot.OFFHAND, actor.getHeldItemOffhand());
    }

    /**
     * Persist action from byte buffer. Used for sending the action 
     * over the network.
     */
    public void fromBuf(ByteBuf buf)
    {}

    /**
     * Persist action to byte buffer. Used for sending the action over 
     * the network.
     */
    public void toBuf(ByteBuf buf)
    {}

    /**
     * Persist action from NBT tag. Used for loading from the disk.
     */
    public void fromNBT(NBTTagCompound tag)
    {}

    /**
     * Persist action to NBT tag. Used for saving to the disk.
     */
    public void toNBT(NBTTagCompound tag)
    {}

    /**
     * Whether this action is safe. Safe action means that it doesn't 
     * modify the world, at max, only its user. 
     */
    public boolean isSafe()
    {
        return false;
    }
}

==================================================

--- Файл №440 ---
Путь: main\java\mchorse\blockbuster\recording\actions\ActionRegistry.java
--------------------
package mchorse.blockbuster.recording.actions;

import java.util.HashMap;
import java.util.Map;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.AttackAction;
import mchorse.blockbuster.recording.actions.BreakBlockAction;
import mchorse.blockbuster.recording.actions.BreakBlockAnimation;
import mchorse.blockbuster.recording.actions.ChatAction;
import mchorse.blockbuster.recording.actions.CommandAction;
import mchorse.blockbuster.recording.actions.DamageAction;
import mchorse.blockbuster.recording.actions.DropAction;
import mchorse.blockbuster.recording.actions.EquipAction;
import mchorse.blockbuster.recording.actions.InteractBlockAction;
import mchorse.blockbuster.recording.actions.ItemUseAction;
import mchorse.blockbuster.recording.actions.ItemUseBlockAction;
import mchorse.blockbuster.recording.actions.MorphAction;
import mchorse.blockbuster.recording.actions.MorphActionAction;
import mchorse.blockbuster.recording.actions.MountingAction;
import mchorse.blockbuster.recording.actions.PlaceBlockAction;
import mchorse.blockbuster.recording.actions.ShootArrowAction;
import mchorse.blockbuster.recording.actions.SwipeAction;

public class ActionRegistry
{
    /**
     * Bi-directional map between class and byte ID
     */
    public static final BiMap<Class<? extends Action>, Byte> CLASS_TO_ID = HashBiMap.create();

    /**
     * Bi-directional map  map of action types mapped to corresponding class
     */
    public static final BiMap<String, Class<? extends Action>> NAME_TO_CLASS = HashBiMap.create();

    /**
     * A mapping between string named to byte type of the fixture
     */
    public static final Map<String, Byte> NAME_TO_ID = new HashMap<String, Byte>();

    /**
     * Next available id 
     */
    private static byte NEXT_ID = 0;

    /**
     * Create an action from type
     */
    public static Action fromType(byte type) throws Exception
    {
        Class<? extends Action> clazz = CLASS_TO_ID.inverse().get(type);

        if (clazz == null)
        {
            throw new Exception("Action by type '" + type + "' wasn't found!");
        }

        return clazz.getConstructor().newInstance();
    }

    /**
     * Create an action from type
     */
    public static Action fromName(String name) throws Exception
    {
        Class<? extends Action> clazz = NAME_TO_CLASS.get(name);

        if (clazz == null)
        {
            throw new Exception("Action by type '" + name + "' wasn't found!");
        }

        return clazz.getConstructor().newInstance();
    }

    /**
     * Get type of the action 
     */
    public static byte getType(Action action)
    {
        if (action == null)
        {
            return -1;
        }

        Byte type = CLASS_TO_ID.get(action.getClass());

        return type == null ? -1 : type;
    }

    public static int getRegisterdActionCount()
    {
        return CLASS_TO_ID.size();
    }

    public static int getMaxID()
    {
        return NEXT_ID - 1;
    }

    /**
     * Write an action to byte buffer 
     */
    public static void toByteBuf(Action action, ByteBuf buffer)
    {
        byte type = getType(action);

        buffer.writeByte(type);

        if (action != null)
        {
            action.toBuf(buffer);
        }
    }

    /**
     * Create an action out of byte buffer
     */
    public static Action fromByteBuf(ByteBuf buffer)
    {
        byte type = buffer.readByte();

        if (type == -1)
        {
            return null;
        }

        try
        {
            Action action = fromType(type);

            action.fromBuf(buffer);

            return action;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    /**
     * Register given camera fixture
     */
    public static void register(String name, Class<? extends Action> clazz)
    {
        register(name, NEXT_ID, clazz);

        NEXT_ID++;
    }

    /**
     * Register given camera fixture
     */
    private static void register(String name, int id, Class<? extends Action> clazz)
    {
        if (CLASS_TO_ID.containsKey(clazz))
        {
            return;
        }

        CLASS_TO_ID.put(clazz, (byte) id);
        NAME_TO_ID.put(name, (byte) id);
        NAME_TO_CLASS.put(name, clazz);
    }

    static
    {
        /* Register Blockbuster actions */
        register("chat", 1, ChatAction.class);
        register("swipe", 2, SwipeAction.class);
        register("drop", 3, DropAction.class);
        register("equip", 4, EquipAction.class);
        register("shoot_arrow", 5, ShootArrowAction.class);
        register("place_block", 7, PlaceBlockAction.class);
        register("mounting", 8, MountingAction.class);
        register("interact_block", 9, InteractBlockAction.class);
        register("break_block", 10, BreakBlockAction.class);
        register("morph", 12, MorphAction.class);
        register("attack", 13, AttackAction.class);
        register("damage", 14, DamageAction.class);
        register("morph_action", 15, MorphActionAction.class);
        register("command", 16, CommandAction.class);
        register("break_animation", 17, BreakBlockAnimation.class);
        register("use_item", 18, ItemUseAction.class);
        register("use_item_block", 19, ItemUseBlockAction.class);
        register("use_gun", 20, ShootGunAction.class);
        register("hotbar_change", 21, HotbarChangeAction.class);

        /* Set next ID to max */
        NEXT_ID = 22;

        register("interact_entity", InteractEntityAction.class);
        register("close_container", CloseContainerAction.class);
    }
}

==================================================

--- Файл №441 ---
Путь: main\java\mchorse\blockbuster\recording\actions\AttackAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.utils.RayTracing;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;

/**
 * Attack action
 *
 * This action is responsible for attacking an entity in in front of the actor.
 */
public class AttackAction extends DamageAction
{
    public AttackAction()
    {
        this.damage = 2F;
    }

    public AttackAction(float damage)
    {
        super(damage);
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();

        if (frame == null) return;

        float yaw = actor.rotationYaw;
        float pitch = actor.rotationPitch;
        float yawHead = actor.rotationYawHead;

        actor.rotationYaw = frame.yaw;
        actor.rotationPitch = frame.pitch;
        actor.rotationYawHead = frame.yawHead;

        Entity target = RayTracing.getTargetEntity(actor, 5.0);

        actor.rotationYaw = yaw;
        actor.rotationPitch = pitch;
        actor.rotationYawHead = yawHead;

        if (target != null)
        {
            target.attackEntityFrom(DamageSource.causeMobDamage(actor), this.damage);

            AbstractMorph morph = mchorse.metamorph.api.EntityUtils.getMorph(actor);

            if (morph != null)
            {
                morph.attack(target, actor);
            }
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Damage"))
        {
            this.damage = tag.getFloat("Damage");
        }
    }
}

==================================================

--- Файл №442 ---
Путь: main\java\mchorse\blockbuster\recording\actions\BreakBlockAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.BlockPos;

/**
 * Breaking block action
 *
 * Actor breaks the block
 */
public class BreakBlockAction extends InteractBlockAction
{
    public boolean drop = false;

    public BreakBlockAction()
    {}

    public BreakBlockAction(BlockPos pos, boolean drop)
    {
        super(pos);
        this.drop = drop;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        actor.world.destroyBlock(this.pos, this.drop);
        actor.world.sendBlockBreakProgress(actor.getEntityId(), this.pos, -1);
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.drop = buf.readBoolean();
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeBoolean(this.drop);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.drop = tag.getBoolean("Drop");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        tag.setBoolean("Drop", this.drop);
    }
}


==================================================

--- Файл №443 ---
Путь: main\java\mchorse\blockbuster\recording\actions\BreakBlockAnimation.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.capturing.WorldEventListener;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.BlockPos;

/**
 * Breaking block animation
 *
 * This action is responsible for animating blocks which are about to be
 * broken. This action is recorded in the {@link WorldEventListener}.
 */
public class BreakBlockAnimation extends InteractBlockAction
{
    public int progress;

    public BreakBlockAnimation()
    {}

    public BreakBlockAnimation(BlockPos pos, int progress)
    {
        super(pos);
        this.progress = progress;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        actor.world.sendBlockBreakProgress(-1, this.pos, this.progress);
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.progress = buf.readInt();
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeInt(this.progress);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.progress = tag.getInteger("Progress");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        tag.setInteger("Progress", this.progress);
    }
}

==================================================

--- Файл №444 ---
Путь: main\java\mchorse\blockbuster\recording\actions\ChatAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.mclib.utils.TextUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * Chat action
 *
 * Sends chat message with some formatting.
 * See {@link ChatAction#apply(EntityLivingBase)} for more information.
 */
public class ChatAction extends Action
{
    public String message = "";

    public ChatAction()
    {}

    public ChatAction(String message)
    {
        this.message = message;
    }

    public String getMessage(EntityLivingBase actor)
    {
        String message = this.message;
        String prefix = Blockbuster.recordChatPrefix.get();

        if (!prefix.isEmpty())
        {
            message = prefix.replace("%NAME%", actor == null ? "Player" : actor.getName()) + message;
        }

        return TextUtils.processColoredText(message);
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        RecordUtils.broadcastMessage(this.getMessage(actor));
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.message = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        ByteBufUtils.writeUTF8String(buf, this.message);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.message = tag.getString("Message");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setString("Message", this.message);
    }
}

==================================================

--- Файл №445 ---
Путь: main\java\mchorse\blockbuster\recording\actions\CloseContainerAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import mchorse.blockbuster.common.entity.EntityActor;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;

public class CloseContainerAction extends Action
{
    @Override
    public void apply(EntityLivingBase actor)
    {
        EntityPlayer player = actor instanceof EntityActor ? ((EntityActor) actor).fakePlayer : (EntityPlayer) actor;

        if (!player.world.isRemote && player.openContainer != player.inventoryContainer)
        {
            player.closeScreen();
        }
    }
}


==================================================

--- Файл №446 ---
Путь: main\java\mchorse\blockbuster\recording\actions\CommandAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import net.minecraft.command.CommandHandler;
import net.minecraft.command.CommandResultStats.Type;
import net.minecraft.command.ICommandManager;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * Command action
 *
 * This class is responsible for executing commands.
 */
public class CommandAction extends Action
{
    /**
     * Command to be executed
     */
    public String command = "";

    public CommandAction()
    {}

    public CommandAction(String command)
    {
        this.command = command;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        if (!this.command.isEmpty())
        {
            MinecraftServer server = actor.world.getMinecraftServer();

            if (server != null)
            {
                ICommandManager manager = server.commandManager;

                manager.executeCommand(new CommandSender(actor), this.command);
            }
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.command = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        ByteBufUtils.writeUTF8String(buf, this.command);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.command = tag.getString("Command");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setString("Command", this.command);
    }

    /**
     * Command action's command sender
     *
     * This dude is responsible for providing {@link ICommandSender} for the
     * {@link CommandHandler}.
     */
    public static class CommandSender implements ICommandSender
    {
        public EntityLivingBase actor;

        public CommandSender(EntityLivingBase actor)
        {
            this.actor = actor;
        }

        @Override
        public String getName()
        {
            return "CommandAction";
        }

        @Override
        public ITextComponent getDisplayName()
        {
            return new TextComponentString("CommandAction");
        }

        @Override
        public void sendMessage(ITextComponent component)
        {}

        @Override
        public boolean canUseCommand(int permLevel, String commandName)
        {
            return true;
        }

        @Override
        public BlockPos getPosition()
        {
            return new BlockPos(this.actor);
        }

        @Override
        public Vec3d getPositionVector()
        {
            return new Vec3d(this.actor.posX, this.actor.posY, this.actor.posZ);
        }

        @Override
        public World getEntityWorld()
        {
            return this.actor.world;
        }

        @Override
        public Entity getCommandSenderEntity()
        {
            return this.actor;
        }

        @Override
        public boolean sendCommandFeedback()
        {
            return false;
        }

        @Override
        public void setCommandStat(Type type, int amount)
        {}

        @Override
        public MinecraftServer getServer()
        {
            return this.actor.world.getMinecraftServer();
        }
    }
}

==================================================

--- Файл №447 ---
Путь: main\java\mchorse\blockbuster\recording\actions\DamageAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.DamageSource;

/**
 * Damage action
 *
 * This action is responsible for dealing damage to the actor. Currently used
 * for killing the actor.
 */
public class DamageAction extends Action
{
    public float damage;

    public DamageAction()
    {}

    public DamageAction(float damage)
    {
        this.damage = damage;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        actor.attackEntityFrom(DamageSource.OUT_OF_WORLD, this.damage);
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.damage = buf.readFloat();
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeFloat(this.damage);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.damage = tag.getFloat("Damage");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setFloat("Damage", this.damage);
    }
}

==================================================

--- Файл №448 ---
Путь: main\java\mchorse\blockbuster\recording\actions\DropAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.item.EntityItem;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import java.util.Random;

/**
 * Item drop action
 *
 * Actor tosses held item away just like player when pressing "q" key
 */
public class DropAction extends Action
{
    public NBTTagCompound itemData;

    public DropAction()
    {
        this.itemData = new NBTTagCompound();
    }

    public DropAction(ItemStack item)
    {
        this();

        item.writeToNBT(this.itemData);
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        if (this.itemData == null)
        {
            return;
        }

        final float PI = 3.1415927F;

        Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();
        ItemStack items = new ItemStack(this.itemData);

        if (items == null || frame == null)
        {
            return;
        }

        EntityItem item = new EntityItem(actor.world, actor.posX, actor.posY - 0.3D + actor.getEyeHeight(), actor.posZ, items);
        Random rand = new Random();

        float f = 0.3F;
        float yaw = frame.yaw;
        float pitch = frame.pitch;

        item.motionX = (-MathHelper.sin(yaw / 180.0F * PI) * MathHelper.cos(pitch / 180.0F * PI) * f);
        item.motionZ = (MathHelper.cos(yaw / 180.0F * PI) * MathHelper.cos(pitch / 180.0F * PI) * f);
        item.motionY = (-MathHelper.sin(pitch / 180.0F * PI) * f + 0.1F);
        item.setPickupDelay(40);

        f = 0.02F;
        float f1 = rand.nextFloat() * PI * 2.0F * rand.nextFloat();

        item.motionX += Math.cos(f1) * f;
        item.motionY += (rand.nextFloat() - rand.nextFloat()) * 0.1F;
        item.motionZ += Math.sin(f1) * f;

        actor.world.spawnEntity(item);
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.itemData = NBTUtils.readInfiniteTag(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        ByteBufUtils.writeTag(buf, this.itemData);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.itemData = tag.getCompoundTag("Data");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setTag("Data", this.itemData);
    }
}

==================================================

--- Файл №449 ---
Путь: main\java\mchorse\blockbuster\recording\actions\EquipAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * Equip item action
 *
 * This action equips an item from replay to the actor, so he either equips the
 * item into one of the hands or in of the armor slots (shoes, leggins, chestplate,
 * or helmet)
 *
 * This action is also called to "de-equip" an item from equipment
 */
public class EquipAction extends Action
{
    public byte armorSlot;
    public NBTTagCompound itemData;
    private byte hotbarSlot = -1;

    public EquipAction()
    {
        this.itemData = new NBTTagCompound();
    }

    public EquipAction(byte armorSlot, ItemStack item)
    {
        this();
        this.armorSlot = armorSlot;

        if (item != null)
        {
            item.writeToNBT(this.itemData);
        }
    }

    public EquipAction(byte armorSlot, byte hotbarSlot, ItemStack item)
    {
        this(armorSlot, item);

        this.hotbarSlot = hotbarSlot;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        EntityEquipmentSlot slot = this.getSlotByIndex(this.armorSlot);

        if (slot == null)
        {
            return;
        }

        if (this.itemData == null)
        {
            this.updateCurrentItemIndex(actor, slot);

            actor.setItemStackToSlot(slot, ItemStack.EMPTY);
        }
        else
        {
            this.updateCurrentItemIndex(actor, slot);

            actor.setItemStackToSlot(slot, new ItemStack(this.itemData));
        }
    }

    /**
     * The currentItem index in the inventory can be delayed (client shows different current slot than what is on server).
     * The method {@link EntityLivingBase#setItemStackToSlot(EntityEquipmentSlot, ItemStack)}
     * sets the currentItem index to the provided itemStack for MAINHAND, this can screw up the inventory.
     */
    private void updateCurrentItemIndex(EntityLivingBase entity, EntityEquipmentSlot slot)
    {
        if (entity instanceof EntityPlayer && this.hotbarSlot != -1 && slot == EntityEquipmentSlot.MAINHAND)
        {
            ((EntityPlayer) entity).inventory.currentItem = this.hotbarSlot;
        }
    }

    private EntityEquipmentSlot getSlotByIndex(int index)
    {
        for (EntityEquipmentSlot slot : EntityEquipmentSlot.values())
        {
            if (slot.getSlotIndex() == index) return slot;
        }

        return null;
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.armorSlot = buf.readByte();
        this.hotbarSlot = buf.readByte();
        this.itemData = NBTUtils.readInfiniteTag(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);

        buf.writeByte(this.armorSlot);
        buf.writeByte(this.hotbarSlot);
        ByteBufUtils.writeTag(buf, this.itemData);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.armorSlot = tag.getByte("Slot");
        this.hotbarSlot = tag.hasKey("HotbarSlot") ? tag.getByte("HotbarSlot") : this.hotbarSlot;

        if (tag.hasKey("Data"))
        {
            this.itemData = tag.getCompoundTag("Data");
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setByte("Slot", this.armorSlot);

        if (this.hotbarSlot != -1)
        {
            tag.setByte("HotbarSlot", this.hotbarSlot);
        }

        if (this.itemData != null)
        {
            tag.setTag("Data", this.itemData);
        }
    }

    @Override
    public boolean isSafe()
    {
        return true;
    }
}

==================================================

--- Файл №450 ---
Путь: main\java\mchorse\blockbuster\recording\actions\HotbarChangeAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.NBTUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;

public class HotbarChangeAction extends Action
{
    private int slotToChange = -1;
    private NBTTagCompound newItemStack;

    public HotbarChangeAction()
    {
        this.newItemStack = new NBTTagCompound();
    }

    public HotbarChangeAction(int slotToChange, ItemStack newItemStack)
    {
        this();
        this.slotToChange = slotToChange;

        if (newItemStack != null)
        {
            this.newItemStack = newItemStack.writeToNBT(new NBTTagCompound());
        }
    }

    public int getSlot()
    {
        return this.slotToChange;
    }

    public void setSlot(int slot)
    {
        this.slotToChange = slot;
    }

    public ItemStack getItemStack()
    {
        return new ItemStack(this.newItemStack);
    }

    public void setItemStack(ItemStack itemStack)
    {
        if (itemStack != null)
        {
            this.newItemStack = itemStack.writeToNBT(new NBTTagCompound());
        }
    }

    @Override
    public void apply(EntityLivingBase entity)
    {
        if (entity instanceof EntityPlayer && this.slotToChange != -1)
        {
            EntityPlayer player = (EntityPlayer) entity;

            player.inventory.setInventorySlotContents(this.slotToChange, new ItemStack(this.newItemStack));
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.slotToChange = buf.readInt();
        this.newItemStack = NBTUtils.readInfiniteTag(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);

        buf.writeInt(this.slotToChange);
        ByteBufUtils.writeTag(buf, this.newItemStack);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.slotToChange = tag.hasKey("Slot") ? tag.getInteger("Slot") : this.slotToChange;

        if (tag.hasKey("ItemStack"))
        {
            this.newItemStack = tag.getCompoundTag("ItemStack");
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        if (this.slotToChange != -1)
        {
            tag.setInteger("Slot", this.slotToChange);
        }

        if (this.newItemStack != null)
        {
            tag.setTag("ItemStack", this.newItemStack);
        }
    }

    @Override
    public boolean isSafe()
    {
        return true;
    }
}


==================================================

--- Файл №451 ---
Путь: main\java\mchorse\blockbuster\recording\actions\InteractBlockAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import com.google.common.collect.ImmutableSet;
import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.block.BlockDirector;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.LTHelper;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumHand;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

import java.util.Set;

/**
 * Interact block action
 *
 * Makes actor interact with a block (press button, switch lever, open the door,
 * etc.)
 *
 * If there was CL4P-TP actor in this mod, this action would be called
 * IntergradeBlockAction :D
 */
public class InteractBlockAction extends Action
{
    public static final Set<ResourceLocation> BLACKLIST = ImmutableSet.of(
        new ResourceLocation("littletiles:blocklittletiles")
    );

    public BlockPos pos = BlockPos.ORIGIN;

    public InteractBlockAction()
    {}

    public InteractBlockAction(BlockPos pos)
    {
        this.pos = pos;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        IBlockState state = actor.world.getBlockState(this.pos);

        /* Black listed block */
        if (state.getBlock() instanceof BlockDirector)
        {
            return;
        }

        Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();
        EntityPlayer player = actor instanceof EntityActor ? ((EntityActor) actor).fakePlayer : (EntityPlayer) actor;

        if (frame == null) return;

        if (player != actor)
        {
            this.copyActor(actor, player, frame);
        }

        if (!LTHelper.playerRightClickServer(player, frame))
        {
            if (BLACKLIST.contains(state.getBlock().getRegistryName()))
            {
                return;
            }

            state.getBlock().onBlockActivated(actor.world, this.pos, state, player, EnumHand.MAIN_HAND, null, this.pos.getX(), this.pos.getY(), this.pos.getZ());
        }
    }

    @Override
    public void changeOrigin(double rotation, double newX, double newY, double newZ, double firstX, double firstY, double firstZ)
    {
        /* I don't like wasting variables */
        firstX = this.pos.getX() - firstX;
        firstY = this.pos.getY() - firstY;
        firstZ = this.pos.getZ() - firstZ;

        if (rotation != 0)
        {
            float cos = (float) Math.cos(rotation / 180 * Math.PI);
            float sin = (float) Math.sin(rotation / 180 * Math.PI);

            double xx = firstX * cos - firstZ * sin;
            double zz = firstX * sin + firstZ * cos;

            firstX = xx;
            firstZ = zz;
        }

        newX += firstX;
        newY += firstY;
        newZ += firstZ;

        this.pos = new BlockPos(newX, newY, newZ);
    }

    @Override
    public void flip(String axis, double coordinate)
    {
        if (axis.equals("x"))
        {
            double diff = coordinate - this.pos.getX();

            this.pos = new BlockPos(coordinate + diff, this.pos.getY(), this.pos.getZ());
        }
        else
        {
            double diff = coordinate - this.pos.getZ();

            this.pos = new BlockPos(this.pos.getX(), this.pos.getY(), coordinate + diff);
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.pos = new BlockPos(buf.readInt(), buf.readInt(), buf.readInt());
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeInt(this.pos.getX());
        buf.writeInt(this.pos.getY());
        buf.writeInt(this.pos.getZ());
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.pos = new BlockPos(tag.getInteger("X"), tag.getInteger("Y"), tag.getInteger("Z"));
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setInteger("X", this.pos.getX());
        tag.setInteger("Y", this.pos.getY());
        tag.setInteger("Z", this.pos.getZ());
    }
}

==================================================

--- Файл №452 ---
Путь: main\java\mchorse\blockbuster\recording\actions\InteractEntityAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.utils.RayTracing;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.EnumHand;

public class InteractEntityAction extends ItemUseAction
{
    public InteractEntityAction()
    {}

    public InteractEntityAction(EnumHand hand)
    {
        super(hand);
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();
        EntityPlayer player = actor instanceof EntityPlayer ? (EntityPlayer) actor : ((EntityActor) actor).fakePlayer;

        if (frame == null) return;

        float yaw = actor.rotationYaw;
        float pitch = actor.rotationPitch;
        float yawHead = actor.rotationYawHead;

        actor.rotationYaw = frame.yaw;
        actor.rotationPitch = frame.pitch;
        actor.rotationYawHead = frame.yawHead;

        Entity target = RayTracing.getTargetEntity(actor, 5.0);

        actor.rotationYaw = yaw;
        actor.rotationPitch = pitch;
        actor.rotationYawHead = yawHead;

        if (player != actor)
        {
            this.copyActor(actor, player, frame);
        }

        if (target != null)
        {
            player.interactOn(target, this.hand);
        }
    }
}

==================================================

--- Файл №453 ---
Путь: main\java\mchorse\blockbuster\recording\actions\ItemUseAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumHand;

/**
 * Item use action
 *
 * This action is responsible for using the item in actor's hand. This action
 * will right click the item, not will use it on the block.
 */
public class ItemUseAction extends Action
{
    public EnumHand hand = EnumHand.MAIN_HAND;

    public ItemUseAction()
    {}

    public ItemUseAction(EnumHand hand)
    {
        this.hand = hand;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        ItemStack item = actor.getHeldItem(this.hand);

        if (item != null)
        {
            Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();
            EntityPlayer player = actor instanceof EntityActor ? ((EntityActor) actor).fakePlayer : (EntityPlayer) actor;

            if (frame == null) return;

            player.width = actor.width;
            player.height = actor.height;
            player.eyeHeight = actor.getEyeHeight();
            player.setEntityBoundingBox(actor.getEntityBoundingBox());

            player.posX = actor.posX;
            player.posY = actor.posY;
            player.posZ = actor.posZ;
            player.rotationYaw = frame.yaw;
            player.rotationPitch = frame.pitch;
            player.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, actor.getHeldItemMainhand());
            player.setItemStackToSlot(EntityEquipmentSlot.OFFHAND, actor.getHeldItemOffhand());

            item.getItem().onItemRightClick(actor.world, player, this.hand);
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.hand = buf.readByte() == 0 ? EnumHand.MAIN_HAND : EnumHand.OFF_HAND;
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeByte((byte) (this.hand.equals(EnumHand.MAIN_HAND) ? 0 : 1));
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.hand = tag.getByte("Hand") == 0 ? EnumHand.MAIN_HAND : EnumHand.OFF_HAND;
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setByte("Hand", (byte) (this.hand.equals(EnumHand.MAIN_HAND) ? 0 : 1));
    }
}

==================================================

--- Файл №454 ---
Путь: main\java\mchorse\blockbuster\recording\actions\ItemUseBlockAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

public class ItemUseBlockAction extends ItemUseAction
{
    public BlockPos pos = BlockPos.ORIGIN;
    public EnumFacing facing = EnumFacing.UP;
    public float hitX;
    public float hitY;
    public float hitZ;

    public ItemUseBlockAction()
    {}

    public ItemUseBlockAction(BlockPos pos, EnumHand hand, EnumFacing facing)
    {
        super(hand);
        this.pos = pos;
        this.facing = facing;
    }

    public ItemUseBlockAction(BlockPos pos, EnumHand hand, EnumFacing facing, float hitX, float hitY, float hitZ)
    {
        this(pos, hand, facing);
        this.hitX = hitX;
        this.hitY = hitY;
        this.hitZ = hitZ;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        ItemStack item = actor.getHeldItem(this.hand);

        if (item != null)
        {
            Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();
            EntityPlayer player = actor instanceof EntityActor ? ((EntityActor) actor).fakePlayer : (EntityPlayer) actor;

            if (frame == null) return;

            player.width = actor.width;
            player.height = actor.height;
            player.eyeHeight = actor.getEyeHeight();
            player.setEntityBoundingBox(actor.getEntityBoundingBox());

            player.posX = actor.posX;
            player.posY = actor.posY;
            player.posZ = actor.posZ;
            player.rotationYaw = frame.yaw;
            player.rotationPitch = frame.pitch;
            player.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, actor.getHeldItemMainhand());
            player.setItemStackToSlot(EntityEquipmentSlot.OFFHAND, actor.getHeldItemOffhand());

            ItemStack stack = actor.getHeldItem(this.hand);

            int meta = stack.getMetadata();
            int size = stack.getCount();
            item.getItem().onItemUse(player, actor.world, this.pos, this.hand, this.facing, this.hitX, this.hitY, this.hitZ);
            stack.setItemDamage(meta);
            stack.setCount(size);
        }
    }

    @Override
    public void changeOrigin(double rotation, double newX, double newY, double newZ, double firstX, double firstY, double firstZ)
    {
        /* I don't like wasting variables */
        firstX = this.pos.getX() - firstX;
        firstX = this.pos.getY() - firstY;
        firstX = this.pos.getZ() - firstZ;

        if (rotation != 0)
        {
            Vec3d vec = new Vec3d(this.hitX, this.hitY, this.hitZ);

            vec = vec.rotateYaw((float) (rotation / 180 * Math.PI));

            this.hitX = (float) vec.x;
            this.hitY = (float) vec.y;
            this.hitZ = (float) vec.z;

            float cos = (float) Math.cos(rotation / 180 * Math.PI);
            float sin = (float) Math.sin(rotation / 180 * Math.PI);

            double xx = firstX * cos - firstZ * sin;
            double zz = firstX * sin + firstZ * cos;

            firstX = xx;
            firstZ = zz;
        }

        newX += firstX;
        newY += firstY;
        newZ += firstZ;

        this.pos = new BlockPos(newX, newY, newZ);
    }

    @Override
    public void flip(String axis, double coordinate)
    {
        if (axis.equals("x"))
        {
            double diff = coordinate - this.pos.getX();

            this.hitX = 1 - this.hitX;
            this.pos = new BlockPos(coordinate + diff, this.pos.getY(), this.pos.getZ());
        }
        else
        {
            double diff = coordinate - this.pos.getZ();

            this.hitZ = 1 - this.hitZ;
            this.pos = new BlockPos(this.pos.getX(), this.pos.getY(), coordinate + diff);
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);

        this.pos = new BlockPos(buf.readInt(), buf.readInt(), buf.readInt());
        this.facing = EnumFacing.values()[buf.readByte()];
        this.hitX = buf.readFloat();
        this.hitY = buf.readFloat();
        this.hitZ = buf.readFloat();
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);

        buf.writeInt(this.pos.getX());
        buf.writeInt(this.pos.getY());
        buf.writeInt(this.pos.getZ());
        buf.writeByte((byte) this.facing.ordinal());
        buf.writeFloat(this.hitX);
        buf.writeFloat(this.hitY);
        buf.writeFloat(this.hitZ);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.pos = new BlockPos(tag.getInteger("PosX"), tag.getInteger("PosY"), tag.getInteger("PosZ"));
        this.facing = EnumFacing.values()[tag.getByte("Facing")];
        this.hitX = tag.getFloat("HitX");
        this.hitY = tag.getFloat("HitY");
        this.hitZ = tag.getFloat("HitZ");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        tag.setInteger("PosX", this.pos.getX());
        tag.setInteger("PosY", this.pos.getY());
        tag.setInteger("PosZ", this.pos.getZ());
        tag.setByte("Facing", (byte) this.facing.ordinal());
        tag.setFloat("HitX", this.hitX);
        tag.setFloat("HitY", this.hitX);
        tag.setFloat("HitZ", this.hitX);
    }
}

==================================================

--- Файл №455 ---
Путь: main\java\mchorse\blockbuster\recording\actions\MorphAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;

/**
 * Morph action
 *
 * This action is responsible for changing the model and skin of actor during
 * the playback. This action is submitted when player morphs with Metamorph's
 * API.
 */
public class MorphAction extends Action
{
    public AbstractMorph morph;

    private boolean force;

    public MorphAction()
    {}

    public MorphAction(AbstractMorph morph)
    {
        this.morph = morph;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        AbstractMorph morph = MorphUtils.copy(this.morph);

        if (actor instanceof EntityPlayer)
        {
            MorphAPI.morph((EntityPlayer) actor, morph, true);
        }
        else if (actor instanceof EntityActor)
        {
            EntityActor act = (EntityActor) actor;

            act.morph(morph, false);

            if (!act.world.isRemote)
            {
                act.notifyPlayers();
            }
        }
    }

    @Override
    public void applyWithForce(EntityLivingBase actor)
    {
        AbstractMorph morph = MorphUtils.copy(this.morph);

        if (actor instanceof EntityPlayer)
        {
            MorphAPI.morph((EntityPlayer) actor, morph, true);
        }
        else if (actor instanceof EntityActor)
        {
            EntityActor act = (EntityActor) actor;

            act.morph(morph, true);

            if (!act.world.isRemote)
            {
                act.notifyPlayers();
            }
        }
    }

    public void applyWithOffset(EntityLivingBase actor, int offset, AbstractMorph previous, int previousOffset, boolean resume)
    {
        AbstractMorph morph = MorphUtils.copy(this.morph);

        /* Sorry, fake players can't be synced */
        if (actor instanceof EntityPlayer)
        {
            MorphAPI.morph((EntityPlayer) actor, morph, true);
        }
        else if (actor instanceof EntityActor)
        {
            EntityActor act = (EntityActor) actor;

            if (act.world.isRemote)
            {
                act.applyPause(MorphUtils.copy(morph), offset, MorphUtils.copy(previous), previousOffset, resume);
            }
            else
            {
                act.morphPause(morph, offset, previous, previousOffset, resume);
                act.notifyPlayers();
            }
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);

        this.morph = MorphUtils.morphFromBuf(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);

        MorphUtils.morphToBuf(buf, this.morph);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.morph = MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag("Morph"));
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        if (this.morph != null)
        {
            tag.setTag("Morph", this.morph.toNBT());
        }
    }

    @Override
    public boolean isSafe()
    {
        return true;
    }
}

==================================================

--- Файл №456 ---
Путь: main\java\mchorse\blockbuster\recording\actions\MorphActionAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;

/**
 * Morph's action action
 *
 * This method is responsible for executing morph's action, if it has one.
 */
public class MorphActionAction extends Action
{
    public MorphActionAction()
    {}

    @Override
    public void apply(EntityLivingBase actor)
    {
        AbstractMorph morph = mchorse.metamorph.api.EntityUtils.getMorph(actor);

        if (morph != null)
        {
            Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();

            if (frame == null) return;

            float yaw = actor.rotationYaw;
            float yawHead = actor.rotationYaw;
            float pitch = actor.rotationPitch;

            float prevYaw = actor.prevRotationYaw;
            float prevYawHead = actor.prevRotationYawHead;
            float prevPitch = actor.prevRotationPitch;

            actor.rotationYaw = actor.prevRotationYaw = frame.yaw;
            actor.rotationYawHead = actor.prevRotationYawHead = frame.yawHead;
            actor.rotationPitch = actor.prevRotationPitch = frame.pitch;

            morph.action(actor);

            actor.rotationYaw = yaw;
            actor.rotationYawHead = yawHead;
            actor.rotationPitch = pitch;

            actor.prevRotationYaw = prevYaw;
            actor.prevRotationYawHead = prevYawHead;
            actor.prevRotationPitch = prevPitch;
        }
    }
}

==================================================

--- Файл №457 ---
Путь: main\java\mchorse\blockbuster\recording\actions\MountingAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import java.util.UUID;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.mclib.utils.RayTracing;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;

/**
 * Mounting action
 *
 * This actor makes actor to mount or unmount an entity by UUID.
 * I should probably move from UUID to using a type of entity with given
 * radius (3-5 blocks).
 */
public class MountingAction extends Action
{
    /**
     * Default UUID 
     */
    public static final UUID DEFAULT = new UUID(0, 0);

    public UUID target = DEFAULT;
    public boolean isMounting;

    public MountingAction()
    {}

    public MountingAction(UUID target, boolean isMounting)
    {
        this.target = target;
        this.isMounting = isMounting;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        Entity mount = EntityUtils.entityByUUID(actor.world, this.target);

        if (mount == null)
        {
            Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();

            if (frame == null) return;

            float yaw = actor.rotationYaw;
            float pitch = actor.rotationPitch;
            float yawHead = actor.rotationYawHead;

            actor.rotationYaw = frame.yaw;
            actor.rotationPitch = frame.pitch;
            actor.rotationYawHead = frame.yawHead;

            mount = RayTracing.getTargetEntity(actor, 5.0);

            actor.rotationYaw = yaw;
            actor.rotationPitch = pitch;
            actor.rotationYawHead = yawHead;
        }

        if (mount == null && this.isMounting)
        {
            return;
        }

        if (this.isMounting)
        {
            actor.startRiding(mount);
        }
        else
        {
            actor.dismountRidingEntity();
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.target = new UUID(buf.readLong(), buf.readLong());
        this.isMounting = buf.readBoolean();
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeLong(this.target.getMostSignificantBits());
        buf.writeLong(this.target.getLeastSignificantBits());
        buf.writeBoolean(this.isMounting);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.target = new UUID(tag.getLong("Most"), tag.getLong("Least"));
        this.isMounting = tag.getBoolean("Mounting");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setLong("Most", this.target.getMostSignificantBits());
        tag.setLong("Least", this.target.getLeastSignificantBits());
        tag.setBoolean("Mounting", this.isMounting);
    }
}

==================================================

--- Файл №458 ---
Путь: main\java\mchorse\blockbuster\recording\actions\PlaceBlockAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import net.minecraft.block.Block;
import net.minecraft.block.SoundType;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * Guess what this action does
 *
 * Does exactly what you think, no less, no more.
 */
public class PlaceBlockAction extends InteractBlockAction
{
    public byte metadata;
    public String block = "";

    public PlaceBlockAction()
    {}

    public PlaceBlockAction(BlockPos pos, byte metadata, String block)
    {
        super(pos);
        this.metadata = metadata;
        this.block = block;
    }

    @SuppressWarnings("deprecation")
    @Override
    public void apply(EntityLivingBase actor)
    {
        Block block = Block.REGISTRY.getObject(new ResourceLocation(this.block));

        if (block != null)
        {
            IBlockState state = actor.world.getBlockState(this.pos);

            if (InteractBlockAction.BLACKLIST.contains(state.getBlock().getRegistryName()))
            {
                return;
            }

            state = block.getStateFromMeta(this.metadata);
            actor.world.setBlockState(this.pos, state);

            World world = actor.world;

            SoundType soundtype = world.getBlockState(pos).getBlock().getSoundType(world.getBlockState(pos), world, pos, null);
            world.playSound(null, pos, soundtype.getPlaceSound(), SoundCategory.BLOCKS, (soundtype.getVolume() + 1.0F) / 2.0F, soundtype.getPitch() * 0.8F);
        }
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.metadata = buf.readByte();
        this.block = ByteBufUtils.readUTF8String(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeByte(this.metadata);
        ByteBufUtils.writeUTF8String(buf, this.block);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);
        this.metadata = tag.getByte("Meta");
        this.block = tag.getString("Block");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);
        tag.setByte("Meta", this.metadata);
        tag.setString("Block", this.block);
    }
}

==================================================

--- Файл №459 ---
Путь: main\java\mchorse\blockbuster\recording\actions\ShootArrowAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.projectile.EntityTippedArrow;
import net.minecraft.item.ItemBow;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.world.World;

/**
 * Shoot arrow action
 *
 * This action shoots emulates arrow shooting. This would look confusing when
 * the actor lack of bow, he would be like freaking arrow mage or something.
 */
public class ShootArrowAction extends Action
{
    public int charge;

    public ShootArrowAction()
    {}

    public ShootArrowAction(int charge)
    {
        this.charge = charge;
    }

    /**
     * Some code in this method is borrowed from ItemBow, I guess, I don't
     * remember
     */
    @Override
    public void apply(EntityLivingBase actor)
    {
        World world = actor.world;
        Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();

        if (frame == null) return;

        EntityTippedArrow arrow = new EntityTippedArrow(world, actor);
        float f = ItemBow.getArrowVelocity(this.charge);

        arrow.shoot(actor, frame.pitch, frame.yaw, 0.0F, f * 3.0F, 1.0F);
        world.spawnEntity(arrow);
    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);
        this.charge = buf.readByte();
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);
        buf.writeByte(this.charge);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.charge = tag.getByte("Charge");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setByte("Charge", (byte) this.charge);
    }
}

==================================================

--- Файл №460 ---
Путь: main\java\mchorse\blockbuster\recording\actions\ShootGunAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.server.gun.ServerHandlerGunInteract;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.utils.EntityUtils;
import mchorse.blockbuster.utils.NBTUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * \* User: Evanechecssss
 * \* https://evanechecssss.github.io
 * \
 */
public class ShootGunAction extends Action
{
    private ItemStack stack;

    public ShootGunAction()
    {
        this(ItemStack.EMPTY);
    }

    public ShootGunAction(ItemStack stack)
    {
        this.stack = stack;
    }

    @Override
    public void apply(EntityLivingBase actor)
    {
        Frame frame = EntityUtils.getRecordPlayer(actor).getCurrentFrame();
        EntityPlayer player = actor instanceof EntityPlayer ? (EntityPlayer) actor : ((EntityActor) actor).fakePlayer;

        if (frame == null)
        {
            return;
        }

        if (player != null)
        {
            GunProps props = NBTUtils.getGunProps(this.stack);

            if (props != null)
            {
                player.width = actor.width;
                player.height = actor.height;
                player.eyeHeight = actor.getEyeHeight();
                player.setEntityBoundingBox(actor.getEntityBoundingBox());

                player.posX = actor.posX;
                player.posY = actor.posY;
                player.posZ = actor.posZ;
                player.rotationYaw = frame.yaw;
                player.rotationPitch = frame.pitch;
                player.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, actor.getHeldItemMainhand());
                player.setItemStackToSlot(EntityEquipmentSlot.OFFHAND, actor.getHeldItemOffhand());

                ServerHandlerGunInteract.interactWithGun(null, actor, this.stack);
            }
            else
            {
                Blockbuster.LOGGER.error("Null gun props");
            }
        }

    }

    @Override
    public void fromBuf(ByteBuf buf)
    {
        super.fromBuf(buf);

        this.stack = ByteBufUtils.readItemStack(buf);
    }

    @Override
    public void toBuf(ByteBuf buf)
    {
        super.toBuf(buf);

        ByteBufUtils.writeItemStack(buf, this.stack);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.stack = new ItemStack(tag.getCompoundTag("Stack"));
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        tag.setTag("Stack", this.stack.serializeNBT());
    }
}

==================================================

--- Файл №461 ---
Путь: main\java\mchorse\blockbuster\recording\actions\SwipeAction.java
--------------------
package mchorse.blockbuster.recording.actions;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.utils.EntityUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.init.SoundEvents;
import net.minecraft.network.play.server.SPacketAnimation;
import net.minecraft.util.EnumHand;

/**
 * Swipe action
 *
 * Swipes actor's hand.
 */
public class SwipeAction extends Action
{
    public SwipeAction()
    {}

    @Override
    public void apply(EntityLivingBase actor)
    {
        RecordPlayer player = EntityUtils.getRecordPlayer(actor);

        actor.swingArm(EnumHand.MAIN_HAND);

        /* Hack to swing the arm for the real player */
        if (player != null && player.realPlayer)
        {
            ((EntityPlayerMP) player.actor).connection.sendPacket(new SPacketAnimation(player.actor, 0));
        }

        if (Blockbuster.actorSwishSwipe.get())
        {
            actor.world.playSound(null, actor.posX, actor.posY, actor.posZ, SoundEvents.ENTITY_PLAYER_ATTACK_WEAK, actor.getSoundCategory(), 1.0F, 1.0F);
        }
    }

    @Override
    public boolean isSafe()
    {
        return true;
    }
}

==================================================

--- Файл №462 ---
Путь: main\java\mchorse\blockbuster\recording\capturing\ActionHandler.java
--------------------
package mchorse.blockbuster.recording.capturing;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.capabilities.recording.IRecording;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.SkinHandler;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer.GunEntry;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer.TEModel;
import mchorse.blockbuster.client.textures.GifTexture;
import mchorse.blockbuster.recording.RecordManager;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.RecordRecorder;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.AttackAction;
import mchorse.blockbuster.recording.actions.BreakBlockAction;
import mchorse.blockbuster.recording.actions.ChatAction;
import mchorse.blockbuster.recording.actions.CommandAction;
import mchorse.blockbuster.recording.actions.DropAction;
import mchorse.blockbuster.recording.actions.InteractBlockAction;
import mchorse.blockbuster.recording.actions.InteractEntityAction;
import mchorse.blockbuster.recording.actions.ItemUseAction;
import mchorse.blockbuster.recording.actions.ItemUseBlockAction;
import mchorse.blockbuster.recording.actions.MorphAction;
import mchorse.blockbuster.recording.actions.MorphActionAction;
import mchorse.blockbuster.recording.actions.MountingAction;
import mchorse.blockbuster.recording.actions.PlaceBlockAction;
import mchorse.blockbuster.recording.actions.ShootArrowAction;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.metamorph.api.events.MorphActionEvent;
import mchorse.metamorph.api.events.MorphEvent;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.RayTraceResult.Type;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.World;
import net.minecraft.world.WorldServer;
import net.minecraftforge.common.util.BlockSnapshot;
import net.minecraftforge.event.CommandEvent;
import net.minecraftforge.event.ServerChatEvent;
import net.minecraftforge.event.entity.EntityMountEvent;
import net.minecraftforge.event.entity.item.ItemTossEvent;
import net.minecraftforge.event.entity.player.ArrowLooseEvent;
import net.minecraftforge.event.entity.player.AttackEntityEvent;
import net.minecraftforge.event.entity.player.FillBucketEvent;
import net.minecraftforge.event.entity.player.PlayerInteractEvent;
import net.minecraftforge.event.entity.player.PlayerInteractEvent.RightClickBlock;
import net.minecraftforge.event.world.BlockEvent.BreakEvent;
import net.minecraftforge.event.world.BlockEvent.MultiPlaceEvent;
import net.minecraftforge.event.world.BlockEvent.PlaceEvent;
import net.minecraftforge.event.world.WorldEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent.PlayerLoggedOutEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.Phase;
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.ServerTickEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.WorldTickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.IOException;
import java.util.List;

/**
 * Event handler for recording purposes.
 *
 * This event handler listens to different events and then writes them to
 * the recording event list (which in turn are being written to the disk
 * by RecordThread).
 *
 * Taken from Mocap mod and rewritten.
 */
public class ActionHandler
{
    /**
     * Last TE was spotted during block breaking action (used for 
     * damage control of tile entities) 
     */
    public static TileEntity lastTE;

    /**
     * Adds a world event listener  
     */
    @SubscribeEvent
    public void onWorldLoad(WorldEvent.Load event)
    {
        World world = event.getWorld();

        if (!world.isRemote)
        {
            world.addEventListener(new WorldEventListener(world));
        }

        if (world instanceof WorldServer && ((WorldServer) world).provider.getDimension() == 0)
        {
            Blockbuster.reloadServerModels(true);
        }
    }

    @SubscribeEvent
    public void onItemUse(PlayerInteractEvent.RightClickItem event)
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new ItemUseAction(event.getHand()));
        }
    }

    @SubscribeEvent
    public void onItemUseBlock(PlayerInteractEvent.RightClickBlock event)
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            Vec3d hit = event.getHitVec();
            BlockPos pos = event.getPos();

            if (hit == null)
            {
                events.add(new ItemUseBlockAction(pos, event.getHand(), event.getFace()));
            }
            else
            {
                events.add(new ItemUseBlockAction(pos, event.getHand(), event.getFace(), (float) hit.x - pos.getX(), (float) hit.y - pos.getY(), (float) hit.z - pos.getZ()));
            }
        }
    }

    /**
     * Event listener for Action.BREAK_BLOCK
     */
    @SubscribeEvent
    public void onPlayerBreaksBlock(BreakEvent event)
    {
        EntityPlayer player = event.getPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new BreakBlockAction(event.getPos(), !player.isCreative()));
        }
    }

    /**
     * Event listener for Action.INTERACT_BLOCK (when player right clicks on
     * a block)
     */
    @SubscribeEvent
    public void onPlayerRightClickBlock(RightClickBlock event)
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new InteractBlockAction(event.getPos()));
        }
    }

    /**
     * Event listener for entity interact event
     */
    @SubscribeEvent
    public void onRightClickEntity(PlayerInteractEvent.EntityInteract event)
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new InteractEntityAction(event.getHand()));
        }
    }

    /**
     * Event listener for Action.PLACE_BLOCK
     */
    @SubscribeEvent
    public void onPlayerPlacesBlock(PlaceEvent event)
    {
        EntityPlayer player = event.getPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            IBlockState state = event.getPlacedBlock();
            Block block = state.getBlock();

            this.placeBlock(events, event.getPos(), block, state);
        }
    }

    /**
     * Another event listener for Action.PLACE_BLOCK
     */
    @SubscribeEvent
    public void onPlayerPlacesMultiBlock(MultiPlaceEvent event)
    {
        EntityPlayer player = event.getPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            List<BlockSnapshot> blocks = event.getReplacedBlockSnapshots();

            for (BlockSnapshot snapshot : blocks)
            {
                IBlockState state = snapshot.getCurrentBlock();
                Block block = state.getBlock();

                this.placeBlock(events, snapshot.getPos(), block, state);
            }
        }
    }

    /**
     * Event listener for Action.ATTACK
     */
    @SubscribeEvent
    public void onPlayerAttack(AttackEntityEvent event)
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null && !Blockbuster.recordAttackOnSwipe.get())
        {
            events.add(new AttackAction());
        }
    }

    /**
     * Event listener for bucket using. When you place water or lava with
     * bucket it doesn't considered place block action like with any other
     * types of blocks.
     *
     * So here's my hack for placing water and lava blocks.
     */
    @SubscribeEvent
    public void onPlayerUseBucket(FillBucketEvent event)
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);
        RayTraceResult target = event.getTarget();

        if (!player.world.isRemote && events != null && target != null && target.typeOfHit == Type.BLOCK)
        {
            Item bucket = event.getEmptyBucket().getItem();
            BlockPos pos = target.getBlockPos().offset(target.sideHit);

            if (bucket == Items.LAVA_BUCKET)
            {
                this.placeBlock(events, pos, Blocks.FLOWING_LAVA, 0);
            }
            else if (bucket == Items.WATER_BUCKET)
            {
                this.placeBlock(events, pos, Blocks.FLOWING_WATER, 0);
            }
        }
    }

    private void placeBlock(List<Action> events, BlockPos pos, Block block, IBlockState state)
    {
        this.placeBlock(events, pos, block, block.getMetaFromState(state));
    }

    /**
     * Place block in given event list
     */
    private void placeBlock(List<Action> events, BlockPos pos, Block block, int metadata)
    {
        ResourceLocation id = block.getRegistryName();

        events.add(new PlaceBlockAction(pos, (byte) metadata, id.toString()));
    }

    /**
     * Event listener for Action.MOUNTING (when player mounts other entity)
     */
    @SubscribeEvent
    public void onPlayerMountsSomething(EntityMountEvent event)
    {
        if (event.getEntityMounting() instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) event.getEntityMounting();
            List<Action> events = CommonProxy.manager.getActions(player);

            if (!player.world.isRemote && events != null)
            {
                events.add(new MountingAction(event.getEntityBeingMounted().getUniqueID(), event.isMounting()));
            }
        }
    }

    /**
     * Event listener for Action.SHOOT_ARROW
     */
    @SubscribeEvent
    public void onArrowLooseEvent(ArrowLooseEvent event) throws IOException
    {
        EntityPlayer player = event.getEntityPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new ShootArrowAction(event.getCharge()));
        }
    }

    /**
     * Event listener for Action.DROP (when player drops the item from his
     * inventory)
     */
    @SubscribeEvent
    public void onItemTossEvent(ItemTossEvent event) throws IOException
    {
        EntityPlayer player = event.getPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new DropAction(event.getEntityItem().getItem()));
        }
    }

    /**
     * Event listener for Action.CHAT (basically when the player enters
     * something in the chat)
     */
    @SubscribeEvent
    public void onServerChatEvent(ServerChatEvent event)
    {
        EntityPlayer player = event.getPlayer();
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new ChatAction(event.getMessage()));
        }
    }

    /**
     * Event listener for Action.COMMAND (basically when the player enters
     * a command in the chat). Adds an action only for server commands.
     */
    @SubscribeEvent
    public void onPlayerCommand(CommandEvent event)
    {
        if (!Blockbuster.recordCommands.get())
        {
            return;
        }

        ICommandSender sender = event.getSender();

        if (sender instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) sender;
            List<Action> events = CommonProxy.manager.getActions(player);

            if (!player.world.isRemote && events != null)
            {
                String command = "/" + event.getCommand().getName();

                for (String value : event.getParameters())
                {
                    command += " " + value;
                }

                events.add(new CommandAction(command));
            }
        }
    }

    /**
     * Event listener when player logs out. This listener aborts the recording
     * for given player (well, if he records, but that {@link RecordManager}'s
     * job to find out).
     */
    @SubscribeEvent
    public void onPlayerLogOut(PlayerLoggedOutEvent event)
    {
        EntityPlayer player = event.player;

        if (!player.world.isRemote)
        {
            CommonProxy.manager.abort(player);
        }
    }

    /**
     * Event listener for MORPH
     *
     * This is a new event listener for morphing. Before that, there was server
     * handler which was responsible for recoring MORPH action.
     */
    @SubscribeEvent
    public void onPlayerMorph(MorphEvent.Post event)
    {
        EntityPlayer player = event.player;
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null)
        {
            events.add(new MorphAction(event.morph));
        }
    }

    /**
     * Event listener for MORPH_ACTION
     *
     * This method will simply submit a {@link MorphActionAction} to the
     * event list, if action is valid.
     */
    @SubscribeEvent
    public void onPlayerMorphAction(MorphActionEvent event)
    {
        EntityPlayer player = event.player;
        List<Action> events = CommonProxy.manager.getActions(player);

        if (!player.world.isRemote && events != null && event.isValid())
        {
            events.add(new MorphActionAction());
        }
    }

    /**
     * Event listener for server tick event.
     *
     * This is probably not the optimal solution, but I'm not really sure how
     * to schedule things in Minecraft other way than timers and ticks.
     *
     * This method is responsible for scheduling record unloading and counting
     * down recording process.
     */
    @SubscribeEvent
    public void onServerTick(ServerTickEvent event)
    {
        if (event.phase == Phase.START)
        {
            return;
        }

        CommonProxy.manager.tick();
        CommonProxy.scenes.tick();
    }

    /**
     * Event listener for world tick event.
     * 
     * This stuff will be called between networking and world tick. 
     * I think it's a good time to spawn actors and execute unsafe actions. 
     * 
     * Because if actions to modify the world are performed while the actor 
     * is updating, they will be displayed to the client with a delay of 
     * 1 tick.
     */
    @SubscribeEvent
    public void onWorldServerTick(WorldTickEvent event)
    {
        if (event.phase == Phase.END || event.world.isRemote)
        {
            return;
        }

        CommonProxy.scenes.worldTick(event.world);
    }

    /**
     * This is going to record the player actions
     */
    @SubscribeEvent
    public void onPlayerTick(PlayerTickEvent event)
    {
        if (event.phase == Phase.START)
        {
            return;
        }

        EntityPlayer player = event.player;
        boolean server = !player.world.isRemote;

        if (server && CommonProxy.manager.recorders.containsKey(player))
        {
            RecordRecorder recorder = CommonProxy.manager.recorders.get(player);

            if (player.isDead)
            {
                CommonProxy.manager.halt(player, true, true);
                RecordUtils.broadcastInfo("recording.dead", recorder.record.filename);
            }
            else
            {
                recorder.record(player);
            }
        }

        IRecording recording = Recording.get(player);
        RecordPlayer record = recording.getRecordPlayer();

        if (record != null)
        {
            record.next();

            if (record.isFinished() && server)
            {
                record.stopPlaying();
            }
        }
    }
}

==================================================

--- Файл №463 ---
Путь: main\java\mchorse\blockbuster\recording\capturing\DamageControl.java
--------------------
package mchorse.blockbuster.recording.capturing;

import java.util.ArrayList;
import java.util.List;

import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;

/**
 * Damage control
 *
 * This class is responsible for storing damaged blocks and be able to restore
 * them in the world.
 */
public class DamageControl
{
    public List<BlockEntry> blocks = new ArrayList<BlockEntry>();
    public List<Entity> entities = new ArrayList<Entity>();
    public EntityLivingBase target;

    public int maxDistance;

    public DamageControl(EntityLivingBase target, int maxDistance)
    {
        this.target = target;
        this.maxDistance = maxDistance;
    }

    /**
     * Add a block to damage control repository
     *
     * This method is responsible for adding only these blocks which are
     * in the radius of allowed {@link #maxDistance} range. Max distance gets
     * set from the config property {@link mchorse.blockbuster.Blockbuster#damageControlDistance}.
     */
    public void addBlock(BlockPos pos, IBlockState state, World world)
    {
        double x = Math.abs(this.target.posX - pos.getX());
        double y = Math.abs(this.target.posY - pos.getY());
        double z = Math.abs(this.target.posZ - pos.getZ());

        if (x > this.maxDistance || y > this.maxDistance || z > this.maxDistance)
        {
            return;
        }

        for (BlockEntry entry : this.blocks)
        {
            if (entry.pos.getX() == pos.getX() && entry.pos.getY() == pos.getY() && entry.pos.getZ() == pos.getZ())
            {
                return;
            }
        }

        this.blocks.add(new BlockEntry(pos, state, ActionHandler.lastTE));
    }

    /**
     * Apply recorded damaged blocks back in the world
     */
    public void apply(World world)
    {
        for (BlockEntry entry : this.blocks)
        {
            world.setBlockState(entry.pos, entry.state);

            if (entry.te != null)
            {
                world.setTileEntity(entry.pos, TileEntity.create(world, entry.te));
            }
        }

        for (Entity entity : this.entities)
        {
            entity.setDead();
        }

        this.blocks.clear();
        this.entities.clear();
    }

    /**
     * Block entry in the damage control class
     *
     * This class holds information about destroyed block, such as it's state
     */
    public static class BlockEntry
    {
        public BlockPos pos;
        public IBlockState state;
        public NBTTagCompound te;

        public BlockEntry(BlockPos pos, IBlockState state, TileEntity te)
        {
            this.pos = pos;
            this.state = state;

            if (te != null)
            {
                this.te = te.writeToNBT(new NBTTagCompound());
            }
        }
    }
}

==================================================

--- Файл №464 ---
Путь: main\java\mchorse\blockbuster\recording\capturing\DamageControlManager.java
--------------------
package mchorse.blockbuster.recording.capturing;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;

import java.util.HashMap;
import java.util.Map;

/**
 * Damage control manager
 *
 * This person is responsible for managing damage control
 */
public class DamageControlManager
{
    /**
     * Damage control objects
     */
    public Map<Object, DamageControl> damage = new HashMap<Object, DamageControl>();

    public void reset()
    {
        this.damage.clear();
    }

    /**
     * Start observing damage made to terrain
     */
    public void addDamageControl(Object object, EntityLivingBase player)
    {
        if (Blockbuster.damageControl.get())
        {
            int dist = Blockbuster.damageControlDistance.get();

            this.damage.put(object, new DamageControl(player, dist));
        }
    }

    /**
     * Restore made damage
     */
    public void restoreDamageControl(Object object, World world)
    {
        DamageControl control = this.damage.remove(object);

        if (control != null)
        {
            control.apply(world);
        }
    }

    /**
     * Add an entity to track
     */
    public void addEntity(Entity entity)
    {
        for (DamageControl damage : this.damage.values())
        {
            damage.entities.add(entity);
        }
    }

    /**
     * Add a block to track
     */
    public void addBlock(BlockPos pos, IBlockState oldState, World worldIn)
    {
        for (DamageControl damage : CommonProxy.damage.damage.values())
        {
            damage.addBlock(new BlockPos(pos), oldState, worldIn);
        }
    }
}

==================================================

--- Файл №465 ---
Путь: main\java\mchorse\blockbuster\recording\capturing\FrameHandler.java
--------------------
package mchorse.blockbuster.recording.capturing;

import java.util.Objects;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.PacketDamageControlCheck;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.Phase;
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Frame handler
 *
 * This class is responsible for recording frames on the client side.
 */
@SideOnly(Side.CLIENT)
public class FrameHandler
{
    
    private BlockPos last = null;
    
    /**
     * This is going to record the player actions
     * and check DamageControl
     */
    @SubscribeEvent
    public void onPlayerTick(PlayerTickEvent event)
    {
        EntityPlayer player = event.player;

        if (event.phase == Phase.START)
        {
            return;
        }

        if (player.world.isRemote)
        {
            if (ClientProxy.manager.recorders.containsKey(player))
            {
                ClientProxy.manager.recorders.get(player).record(player);
            }

            if (Blockbuster.damageControlMessage.get() && !CameraHandler.isCameraEditorOpen())
            {
                if (Minecraft.getMinecraft().objectMouseOver != null)
                {
                    BlockPos pos = Minecraft.getMinecraft().objectMouseOver.getBlockPos();
                    
                    if (pos != null && !Objects.equals(last, pos))
                    {
                        Dispatcher.sendToServer(new PacketDamageControlCheck(pos));
                    }
                    
                    last = pos;
                }
                else
                {
                    last = null;
                }
            }
        }
    }
}

==================================================

--- Файл №466 ---
Путь: main\java\mchorse\blockbuster\recording\capturing\PlayerTracker.java
--------------------
package mchorse.blockbuster.recording.capturing;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.recording.RecordRecorder;
import mchorse.blockbuster.recording.actions.AttackAction;
import mchorse.blockbuster.recording.actions.CloseContainerAction;
import mchorse.blockbuster.recording.actions.EquipAction;
import mchorse.blockbuster.recording.actions.HotbarChangeAction;
import mchorse.blockbuster.recording.actions.SwipeAction;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.Container;
import net.minecraft.item.ItemStack;

import java.util.Arrays;
import java.util.List;

/**
 * Player tracker class
 *
 * This class tracks player's properties such as arm swing and player equipped
 * inventory. That's it.
 */
public class PlayerTracker
{
    /**
     * Record recorder to which tracked stuff are going to be added
     */
    public RecordRecorder recorder;

    /* Items to track */
    private ItemStack[] items = new ItemStack[6];
    private ItemStack[] hotbar = new ItemStack[9];
    /**
     * Runtime variable to track the complete hotbar for the fist frame
     */
    private boolean trackedHotbar = false;
    
    private Container container;

    public PlayerTracker(RecordRecorder recorder)
    {
        this.recorder = recorder;

        Arrays.fill(hotbar, ItemStack.EMPTY);
    }

    /**
     * Track player's properties like armor, hand held items and hand swing
     */
    public void track(EntityPlayer player)
    {
        this.trackSwing(player);
        this.trackHeldItem(player);
        this.trackHotBar(player);
        this.trackArmor(player);
        this.trackContainerClose(player);
    }

    /**
     * Track armor inventory
     */
    private void trackArmor(EntityPlayer player)
    {
        for (int i = 1; i < 5; i++)
        {
            this.trackItemToSlot(player.inventory.armorInventory.get(i - 1), i);
        }
    }

    /**
     * Track held items
     */
    private void trackHeldItem(EntityPlayer player)
    {
        ItemStack mainhand = player.getHeldItemMainhand();
        ItemStack offhand = player.getHeldItemOffhand();

        this.trackItemToSlot(mainhand, 0, player.inventory.currentItem);
        this.trackItemToSlot(offhand, 5);
    }

    private void trackHotBar(EntityPlayer player)
    {
        List<ItemStack> playerHotbar = player.inventory.mainInventory;

        for (int i = 0; i < playerHotbar.size() && i < this.hotbar.length; i++)
        {
            if (!ItemStack.areItemStacksEqual(this.hotbar[i], playerHotbar.get(i)) || !this.trackedHotbar)
            {
                this.recorder.actions.add(new HotbarChangeAction(i, playerHotbar.get(i).copy()));

                this.hotbar[i] = playerHotbar.get(i).copy();
            }
        }

        this.trackedHotbar = true;
    }

    /**
     * Track item to slot.
     *
     * This is a simple utility method that reduces number of lines for both
     * hands.
     */
    private boolean trackItemToSlot(ItemStack item, int slot)
    {
        return this.trackItemToSlot(item, slot, -1);
    }

    private boolean trackItemToSlot(ItemStack item, int slot, int hotbarslot)
    {
        if (!item.isEmpty())
        {
            if (item != this.items[slot])
            {
                this.items[slot] = item;
                this.recorder.actions.add((hotbarslot != -1) ? new EquipAction((byte) slot,(byte) hotbarslot, item) : new EquipAction((byte) slot, item));

                return true;
            }
        }
        else if (this.items[slot] != null)
        {
            this.items[slot] = null;
            this.recorder.actions.add((hotbarslot != -1) ? new EquipAction((byte) slot,(byte) hotbarslot, null) : new EquipAction((byte) slot, null));

            return true;
        }

        return false;
    }

    /**
     * Track the hand swing (like when you do the tap-tap with left-click)
     */
    private void trackSwing(EntityPlayer player)
    {
        /**
         * player.isPlayerSleeping() is necessary since for some reason when 
         * player is falling asleep, the isSwingInProgress is true, while 
         * player.swingProgress is equals to 0 which makes player swipe every 
         * tick in bed.
         * 
         * So gotta check that so it wouldn't look like Steve is beating his 
         * meat.
         */
        if (player.isSwingInProgress && player.swingProgress == 0 && !player.isPlayerSleeping())
        {
            this.recorder.actions.add(new SwipeAction());

            if (Blockbuster.recordAttackOnSwipe.get())
            {
                this.recorder.actions.add(new AttackAction());
            }
        }
    }

    /**
     * Track whether player has closed a container
     */
    private void trackContainerClose(EntityPlayer player)
    {
        if (container != null && player.openContainer == player.inventoryContainer && container != player.openContainer)
        {
            this.recorder.actions.add(new CloseContainerAction());
        }
        this.container = player.openContainer;
    }
}

==================================================

--- Файл №467 ---
Путь: main\java\mchorse\blockbuster\recording\capturing\WorldEventListener.java
--------------------
package mchorse.blockbuster.recording.capturing;

import java.util.List;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.common.block.BlockDirector;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.BreakBlockAnimation;
import net.minecraft.block.state.IBlockState;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.util.SoundCategory;
import net.minecraft.util.SoundEvent;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.IWorldEventListener;
import net.minecraft.world.World;

/**
 * Blockbuster's world event listener
 *
 * This dude is responsible only for adding breaking block animation during
 * player recording.
 */
public class WorldEventListener implements IWorldEventListener
{
    public World world;

    public static void setBlockState(World world, BlockPos pos, IBlockState newState, int flags)
    {
        if (Blockbuster.damageControl.get())
        {
            ActionHandler.lastTE = world.getTileEntity(pos);
        }
    }

    public WorldEventListener(World world)
    {
        this.world = world;
    }

    /**
     * Used by damage control
     */
    @Override
    public void notifyBlockUpdate(World worldIn, BlockPos pos, IBlockState oldState, IBlockState newState, int flags)
    {
        if (Blockbuster.damageControl.get())
        {
            if (oldState.getBlock() instanceof BlockDirector)
            {
                return;
            }
            else if (oldState.getBlock() == Blocks.PISTON_EXTENSION)
            {
                oldState = Blocks.AIR.getDefaultState();
            }

            CommonProxy.damage.addBlock(pos, oldState, worldIn);
        }
    }

    @Override
    public void notifyLightSet(BlockPos pos)
    {}

    @Override
    public void markBlockRangeForRenderUpdate(int x1, int y1, int z1, int x2, int y2, int z2)
    {}

    @Override
    public void playSoundToAllNearExcept(EntityPlayer player, SoundEvent soundIn, SoundCategory category, double x, double y, double z, float volume, float pitch)
    {}

    @Override
    public void playRecord(SoundEvent soundIn, BlockPos pos)
    {}

    @Override
    public void spawnParticle(int particleID, boolean ignoreRange, double xCoord, double yCoord, double zCoord, double xSpeed, double ySpeed, double zSpeed, int... parameters)
    {}

    @Override
    public void spawnParticle(int p_190570_1_, boolean p_190570_2_, boolean p_190570_3_, double p_190570_4_, double p_190570_6_, double p_190570_8_, double p_190570_10_, double p_190570_12_, double p_190570_14_, int... p_190570_16_)
    {}

    @Override
    public void onEntityAdded(Entity entity)
    {
        if (entity instanceof EntityActor || entity instanceof EntityPlayer)
        {
            return;
        }

        CommonProxy.damage.addEntity(entity);
    }

    @Override
    public void onEntityRemoved(Entity entityIn)
    {}

    @Override
    public void broadcastSound(int soundID, BlockPos pos, int data)
    {}

    @Override
    public void playEvent(EntityPlayer player, int type, BlockPos blockPosIn, int data)
    {}

    @Override
    public void sendBlockBreakProgress(int breakerId, BlockPos pos, int progress)
    {
        Entity breaker = this.world.getEntityByID(breakerId);

        if (breaker instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) breaker;
            List<Action> events = CommonProxy.manager.getActions(player);

            if (!player.world.isRemote && events != null)
            {
                events.add(new BreakBlockAnimation(pos, progress));
            }
        }
    }
}

==================================================

--- Файл №468 ---
Путь: main\java\mchorse\blockbuster\recording\data\Frame.java
--------------------
package mchorse.blockbuster.recording.data;

import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.scene.Replay;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.network.datasync.DataParameter;
import net.minecraft.util.EnumHand;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;

/**
 * Recording frame class
 *
 * This class stores state data about the player in the specific frame that was
 * captured.
 */
public class Frame
{
    public static DataParameter<Byte> FLAGS;

    /* Position */
    public double x;
    public double y;
    public double z;

    /* Rotation */
    public float yaw;
    public float yawHead;
    public float pitch;

    public boolean hasBodyYaw;
    public float bodyYaw;

    /* Mount's data */
    public float mountYaw;
    public float mountPitch;

    public boolean isMounted;

    /* Motion */
    public double motionX;
    public double motionY;
    public double motionZ;

    /* Fall distance */
    public float fallDistance;

    /* Entity flags */
    public boolean isAirBorne;
    public boolean isSneaking;
    public boolean isSprinting;
    public boolean onGround;
    public boolean flyingElytra;

    /* Client data */
    public float roll;

    /* Active hand */
    public int activeHands;

    private int hotbarSlot;
    private int foodLevel;
    private int totalExperience;

    /* Methods for retrieving/applying state data */

    /**
     * Set frame fields from player entity.
     */
    public void fromPlayer(EntityPlayer player)
    {
        Entity mount = player.isRiding() ? player.getRidingEntity() : player;

        /* Position and rotation */
        this.x = mount.posX;
        this.y = player.isRiding() && player.getRidingEntity().posY > player.posY ? player.posY : mount.posY;
        this.z = mount.posZ;

        this.yaw = player.rotationYaw;
        this.yawHead = player.rotationYawHead;
        this.pitch = player.rotationPitch;

        this.hasBodyYaw = true;
        this.bodyYaw = player.renderYawOffset;

        /* Mount information */
        this.isMounted = mount != player;

        if (this.isMounted)
        {
            this.mountYaw = mount.rotationYaw;
            this.mountPitch = mount.rotationPitch;
        }

        /* Motion and fall distance */
        this.motionX = mount.motionX;
        this.motionY = mount.motionY;
        this.motionZ = mount.motionZ;

        this.fallDistance = mount.fallDistance;

        /* States */
        this.isSprinting = mount.isSprinting();
        this.isSneaking = player.isSneaking();
        this.flyingElytra = player.isElytraFlying();

        this.isAirBorne = mount.isAirBorne;
        this.onGround = mount.onGround;

        /* Active hands */
        this.activeHands = player.isHandActive() ? (player.getActiveHand() == EnumHand.OFF_HAND ? 2 : 1) : 0;

        if (player.world.isRemote)
        {
            this.fromPlayerClient(player);
        }

        this.hotbarSlot = player.inventory.currentItem;
        this.foodLevel = player.getFoodStats().getFoodLevel();
        this.totalExperience = player.experienceTotal;
    }

    @SideOnly(Side.CLIENT)
    private void fromPlayerClient(EntityPlayer player)
    {
        EntityPlayerSP local = Minecraft.getMinecraft().player;

        if (player == local)
        {
            this.roll = CameraHandler.getRoll();
        }
    }

    /**
     * Apply frame properties on actor. Different actions will be made
     * depending on which side this method was invoked.
     *
     * Use second argument to force things to be cool.
     */
    public void apply(EntityLivingBase actor, boolean force)
    {
        this.apply(actor, null, force);
    }

    /**
     *
     * @param actor
     * @param replay the replay that is being used for this record - used for playback configuration
     * @param force
     */
    public void apply(EntityLivingBase actor, @Nullable Replay replay, boolean force)
    {
        boolean isRemote = actor.world.isRemote;

        Entity mount = actor.isRiding() ? actor.getRidingEntity() : actor;

        if (mount instanceof EntityActor)
        {
            mount = actor;
        }

        if (actor instanceof EntityActor)
        {
            EntityActor theActor = (EntityActor) actor;

            theActor.isMounted = this.isMounted;
            theActor.roll = this.roll;
        }

        /* This is most important part of the code that makes the recording
         * super smooth.
         *
         * By the way, this code is useful only on the client side, for more
         * reference see renderer classes (they use prev* and lastTick* stuff
         * for interpolation).
         */
        if (this.isMounted)
        {
            mount.prevRotationYaw = mount.rotationYaw;
            mount.prevRotationPitch = mount.rotationPitch;
        }

        actor.prevRotationYaw = actor.rotationYaw;
        actor.prevRotationPitch = actor.rotationPitch;
        actor.prevRotationYawHead = actor.rotationYawHead;

        /* Inject frame's values into actor */
        if (!isRemote || force)
        {
            mount.setPosition(this.x, this.y, this.z);
        }

        /* Rotation */
        if (isRemote || force)
        {
            if (this.isMounted)
            {
                mount.rotationYaw = this.mountYaw;
                mount.rotationPitch = this.mountPitch;

                if (actor == mount)
                {
                    actor.setPosition(this.x, this.y, this.z);
                }
            }

            actor.rotationYaw = this.yaw;
            actor.rotationPitch = this.pitch;
            actor.rotationYawHead = this.yawHead;
        }

        /* Motion and fall distance */
        mount.motionX = this.motionX;
        mount.motionY = this.motionY;
        mount.motionZ = this.motionZ;

        mount.fallDistance = this.fallDistance;

        /* Booleans */
        if (!isRemote || force)
        {
            mount.setSprinting(this.isSprinting);
            actor.setSneaking(this.isSneaking);

            this.setFlag(actor, 7, this.flyingElytra);
        }

        mount.isAirBorne = this.isAirBorne;
        mount.onGround = this.onGround;

        if (!isRemote)
        {
            if (this.activeHands > 0 && !actor.isHandActive())
            {
                actor.setActiveHand(this.activeHands == 1 ? EnumHand.MAIN_HAND : EnumHand.OFF_HAND);
            }
            else if (this.activeHands == 0 && actor.isHandActive())
            {
                actor.stopActiveHand();
            }
        }

        if (actor instanceof EntityPlayer)
        {
            EntityPlayer player = (EntityPlayer) actor;
            player.inventory.currentItem = this.hotbarSlot;

            if (replay != null && replay.playBackXPFood)
            {
                player.getFoodStats().setFoodLevel(this.foodLevel);
                player.addExperience(this.totalExperience - player.experienceTotal);
            }
        }
    }

    /**
     * Set entity flags... if only vanilla could expose that shit 
     */
    private void setFlag(EntityLivingBase actor, int i, boolean flag)
    {
        if (FLAGS == null)
        {
            Field field = null;

            for (Field f : Entity.class.getDeclaredFields())
            {
                int mod = f.getModifiers();
                Type type = f.getGenericType();

                if (Modifier.isProtected(mod) && Modifier.isStatic(mod) && Modifier.isFinal(mod) && f.getType() == DataParameter.class)
                {
                    field = f;
                    break;
                }
            }

            if (field != null)
            {
                try
                {
                    field.setAccessible(true);
                    FLAGS = (DataParameter<Byte>) field.get(null);
                }
                catch (Exception e)
                {}
            }
        }

        if (FLAGS != null)
        {
            byte flags = actor.getDataManager().get(FLAGS).byteValue();

            actor.getDataManager().set(FLAGS, (byte) (flag ? flags | (1 << i) : flags & ~(1 << i)));
        }
    }

    /**
     * Create a copy of this frame 
     */
    public Frame copy()
    {
        Frame frame = new Frame();

        frame.x = this.x;
        frame.y = this.y;
        frame.z = this.z;

        frame.yaw = this.yaw;
        frame.yawHead = this.yawHead;
        frame.pitch = this.pitch;

        frame.hasBodyYaw = this.hasBodyYaw;
        frame.bodyYaw = this.bodyYaw;

        frame.isMounted = this.isMounted;

        if (frame.isMounted)
        {
            frame.mountYaw = this.mountYaw;
            frame.mountPitch = this.mountPitch;
        }

        frame.motionX = this.motionX;
        frame.motionY = this.motionY;
        frame.motionZ = this.motionZ;

        frame.fallDistance = this.fallDistance;

        frame.isAirBorne = this.isAirBorne;
        frame.isSneaking = this.isSneaking;
        frame.isSprinting = this.isSprinting;
        frame.onGround = this.onGround;
        frame.flyingElytra = this.flyingElytra;

        frame.activeHands = this.activeHands;

        frame.roll = this.roll;

        frame.hotbarSlot = this.hotbarSlot;
        frame.foodLevel = this.foodLevel;
        frame.totalExperience = this.totalExperience;

        return frame;
    }

    /* Save/load frame instance */
    public void toBytes(ByteBuf buf)
    {
        buf.writeDouble(this.x);
        buf.writeDouble(this.y);
        buf.writeDouble(this.z);

        buf.writeFloat(this.yaw);
        buf.writeFloat(this.yawHead);
        buf.writeFloat(this.pitch);

        buf.writeBoolean(this.hasBodyYaw);

        if (this.hasBodyYaw)
        {
            buf.writeFloat(this.bodyYaw);
        }

        buf.writeBoolean(this.isMounted);

        if (this.isMounted)
        {
            buf.writeFloat(this.mountYaw);
            buf.writeFloat(this.mountPitch);
        }

        buf.writeFloat((float) this.motionX);
        buf.writeFloat((float) this.motionY);
        buf.writeFloat((float) this.motionZ);

        buf.writeFloat(this.fallDistance);

        buf.writeBoolean(this.isAirBorne);
        buf.writeBoolean(this.isSneaking);
        buf.writeBoolean(this.isSprinting);
        buf.writeBoolean(this.onGround);
        buf.writeBoolean(this.flyingElytra);

        buf.writeByte(this.activeHands);

        buf.writeFloat(this.roll);
        
        buf.writeInt(this.hotbarSlot);
        buf.writeInt(this.foodLevel);
        buf.writeInt(this.totalExperience);
    }

    public void fromBytes(ByteBuf buf)
    {
        this.x = buf.readDouble();
        this.y = buf.readDouble();
        this.z = buf.readDouble();

        this.yaw = buf.readFloat();
        this.yawHead = buf.readFloat();
        this.pitch = buf.readFloat();

        if (buf.readBoolean())
        {
            this.hasBodyYaw = true;
            this.bodyYaw = buf.readFloat();
        }

        this.isMounted = buf.readBoolean();

        if (this.isMounted)
        {
            this.mountYaw = buf.readFloat();
            this.mountPitch = buf.readFloat();
        }

        this.motionX = buf.readFloat();
        this.motionY = buf.readFloat();
        this.motionZ = buf.readFloat();

        this.fallDistance = buf.readFloat();

        this.isAirBorne = buf.readBoolean();
        this.isSneaking = buf.readBoolean();
        this.isSprinting = buf.readBoolean();
        this.onGround = buf.readBoolean();
        this.flyingElytra = buf.readBoolean();

        this.activeHands = buf.readByte();

        this.roll = buf.readFloat();
        this.hotbarSlot = buf.readInt();
        this.foodLevel = buf.readInt();
        this.totalExperience = buf.readInt();
    }

    /**
     * Write frame data to NBT tag. Used for saving the frame on the disk.
     *
     * This is probably going to be extracted in the future to support
     * compatibility, but I don't really know since writing the data happens
     * in one format, while reading is in different versions.
     */
    public void toNBT(NBTTagCompound tag)
    {
        tag.setDouble("X", this.x);
        tag.setDouble("Y", this.y);
        tag.setDouble("Z", this.z);

        tag.setFloat("MX", (float) this.motionX);
        tag.setFloat("MY", (float) this.motionX);
        tag.setFloat("MZ", (float) this.motionX);

        tag.setFloat("RX", this.yaw);
        tag.setFloat("RY", this.pitch);
        tag.setFloat("RZ", this.yawHead);

        if (this.hasBodyYaw)
        {
            tag.setFloat("RW", this.bodyYaw);
        }

        if (this.isMounted)
        {
            tag.setFloat("MRX", this.mountYaw);
            tag.setFloat("MRY", this.mountPitch);
        }

        tag.setFloat("Fall", this.fallDistance);

        tag.setBoolean("Airborne", this.isAirBorne);
        tag.setBoolean("Elytra", this.flyingElytra);
        tag.setBoolean("Sneaking", this.isSneaking);
        tag.setBoolean("Sprinting", this.isSprinting);
        tag.setBoolean("Ground", this.onGround);

        if (this.activeHands > 0)
        {
            tag.setByte("Hands", (byte) this.activeHands);
        }

        if (this.roll != 0)
        {
            tag.setFloat("Roll", this.roll);
        }

        tag.setInteger("HotbarSlot", this.hotbarSlot);
        tag.setInteger("FoodLevel", this.foodLevel);
        tag.setInteger("TotalExperience", this.totalExperience);
    }

    /**
     * Read frame data from NBT tag. Used for loading frame from disk.
     *
     * This is going to be extracted in the future to support compatibility.
     */
    public void fromNBT(NBTTagCompound tag)
    {
        this.x = tag.getDouble("X");
        this.y = tag.getDouble("Y");
        this.z = tag.getDouble("Z");

        this.motionX = tag.getFloat("MX");
        this.motionY = tag.getFloat("MY");
        this.motionZ = tag.getFloat("MZ");

        this.yaw = tag.getFloat("RX");
        this.pitch = tag.getFloat("RY");
        this.yawHead = tag.getFloat("RZ");

        if (tag.hasKey("RW"))
        {
            this.hasBodyYaw = true;
            this.bodyYaw = tag.getFloat("RW");
        }

        if (tag.hasKey("MRX") && tag.hasKey("MRY"))
        {
            this.isMounted = true;
            this.mountYaw = tag.getFloat("MRX");
            this.mountPitch = tag.getFloat("MRY");
        }

        this.fallDistance = tag.getFloat("Fall");

        this.isAirBorne = tag.getBoolean("Airborne");
        this.flyingElytra = tag.getBoolean("Elytra");
        this.isSneaking = tag.getBoolean("Sneaking");
        this.isSprinting = tag.getBoolean("Sprinting");
        this.onGround = tag.getBoolean("Ground");

        if (tag.hasKey("Hands"))
        {
            this.activeHands = tag.getByte("Hands");
        }

        if (tag.hasKey("Roll"))
        {
            this.roll = tag.getFloat("Roll");
        }

        this.hotbarSlot = tag.hasKey("HotbarSlot") ? tag.getInteger("HotbarSlot") : this.hotbarSlot;
        this.foodLevel = tag.hasKey("FoodLevel") ? tag.getInteger("FoodLevel") : this.foodLevel;
        this.totalExperience = tag.hasKey("TotalExperience") ? tag.getInteger("TotalExperience") : this.totalExperience;
    }

    public enum RotationChannel
    {
        HEAD_YAW,
        HEAD_PITCH,
        BODY_YAW
    }
}

==================================================

--- Файл №469 ---
Путь: main\java\mchorse\blockbuster\recording\data\FrameChunk.java
--------------------
package mchorse.blockbuster.recording.data;

import java.util.ArrayList;
import java.util.List;

/**
 * Frame chunk class
 *
 * This class is responsible for storing unfinished loading frames with
 * records from the client.
 */
public class FrameChunk
{
    /**
     * List of frame lists. The list to store them all...
     */
    public List<List<Frame>> frames;

    /**
     * How much chunks this chunk should store.
     */
    public int count;

    /**
     * Recording offset
     */
    public int offset;

    public FrameChunk(int count, int offset)
    {
        this.frames = new ArrayList<List<Frame>>(count);
        this.count = count;
        this.offset = offset;

        for (int i = 0; i < count; i++)
        {
            this.frames.add(null);
        }
    }

    /**
     * Does this chunked storage is fully filled
     */
    public boolean isFilled()
    {
        for (int i = 0; i < this.count; i++)
        {
            if (this.frames.get(i) == null)
            {
                return false;
            }
        }

        return true;
    }

    /**
     * Add chunked frames to the frames storage
     */
    public void add(int index, List<Frame> frames)
    {
        this.frames.set(index, frames);
    }

    /**
     * Compile all frames into one list
     */
    public List<Frame> compile(List<Frame> oldFrames)
    {
        List<Frame> output = new ArrayList<Frame>();

        if (this.offset > 0)
        {
            List<Frame> merged = new ArrayList<Frame>();

            for (List<Frame> frames : this.frames)
            {
                merged.addAll(frames);
            }

            int newSize = this.offset + merged.size();

            for (int i = 0, c = Math.max(newSize, oldFrames.size()); i < c; i++)
            {
                Frame frame;

                if (i < this.offset)
                {
                    frame = i < oldFrames.size() ? oldFrames.get(i) : merged.get(0).copy();
                }
                else if (i > newSize)
                {
                    frame = oldFrames.get(i);
                }
                else
                {
                    int index = i - this.offset;

                    frame =  index < merged.size() ? merged.get(index) : oldFrames.get(i);
                }

                output.add(frame);
            }
        }
        else
        {
            for (List<Frame> frames : this.frames)
            {
                output.addAll(frames);
            }
        }

        return output;
    }
}

==================================================

--- Файл №470 ---
Путь: main\java\mchorse\blockbuster\recording\data\Mode.java
--------------------
package mchorse.blockbuster.recording.data;

/**
 * Mode enumeration. This enumeration represents how to playback the
 * record. Not really sure if BOTH is going to be used at all, but ACTIONS
 * and FRAMES definitely would.
 */
public enum Mode
{
    ACTIONS, FRAMES, BOTH;
}

==================================================

--- Файл №471 ---
Путь: main\java\mchorse\blockbuster\recording\data\Record.java
--------------------
package mchorse.blockbuster.recording.data;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.actions.ActionRegistry;
import mchorse.blockbuster.recording.actions.MorphAction;
import mchorse.blockbuster.recording.actions.MountingAction;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.CompressedStreamTools;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.MovementInput;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.FilenameUtils;

import javax.annotation.Nullable;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * This class stores actions and frames states for a recording (to be played
 * back or while recording).
 *
 * There's two list arrays in this class, index in both of these arrays
 * represents the frame position (0 is first frame). Frames list is always
 * populated, but actions list will contain some nulls.
 */
public class Record
{
    public static final FoundAction ACTION = new FoundAction();
    public static final MorphAction MORPH = new MorphAction();

    /**
     * Signature of the recording. If the first short of the record file isn't
     * this file, then the
     */
    public static final short SIGNATURE = 148;

    /**
     * Filename of this record
     */
    public String filename;

    /**
     * Version of this record
     */
    public short version = SIGNATURE;

    /**
     * Pre-delay same thing as post-delay but less useful
     */
    public int preDelay = 0;

    /**
     * Post-delay allows actors to stay longer on the screen before 
     * whoosing into void
     */
    public int postDelay = 0;

    /**
     * Recorded actions.
     * The list contains every frame of the recording.
     * If no action is present at a frame, the frame will be null.
     */
    public List<List<Action>> actions = new ArrayList<List<Action>>();

    /**
     * Recorded frames
     */
    public List<Frame> frames = new ArrayList<Frame>();

    /**
     * Player data which was recorded when player started recording 
     */
    public NBTTagCompound playerData;

    /**
     * Unload timer. Used only on server side.
     */
    public int unload;

    /**
     * Whether this record has changed elements
     */
    public boolean dirty;

    /**
     * Can be null
     */
    private Replay replay;

    public Record(String filename)
    {
        this.filename = filename;
        this.resetUnload();
    }

    /**
     * Set this replay to the reference of the provided replay
     * @param replay
     */
    public void setReplay(Replay replay)
    {
        this.replay = replay;
    }

    public Replay getReplay()
    {
        return this.replay;
    }

    /**
     * Get the full length (including post and pre delays) of this record in frames/ticks
     */
    public int getFullLength()
    {
        return this.preDelay + this.getLength() + this.postDelay;
    }

    /**
     * Get the length of this record in frames/ticks
     */
    public int getLength()
    {
        return Math.max(this.actions.size(), this.frames.size());
    }

    /**
     * @return actions at the given tick. Can return null if nothing is present there.
     */
    public List<Action> getActions(int tick)
    {
        if (tick >= this.actions.size() || tick < 0)
        {
            return null;
        }

        return this.actions.get(tick);
    }

    /**
     * @param tick negative values are allowed as they will return null
     * @param index negative values are allowed as they will return null
     * @return action at the given tick and index.
     *         Returns null if none was found or if the tick or index are out of bounds.
     */
    public Action getAction(int tick, int index)
    {
        List<Action> actions = this.getActions(tick);

        if (actions != null && index >= 0 && index < actions.size())
        {
            return actions.get(index);
        }

        return null;
    }

    /**
     * If fromIndex0 and toIndex0 are both -1 every action at the frame in the range will be added.
     * @param fromTick0 from tick, inclusive
     * @param toTick0 to tick, inclusive
     * @param fromIndex0 from action index, inclusive. Can be -1 only together with toIndex0.
     * @param toIndex0 to action index, inclusive. Can be -1 only together with fromIndex0.
     * @return a new list containing the actions in the specified ranges. The list can contain null values.
     * @throws IndexOutOfBoundsException if fromTick < 0 || toTick > size of {@link #actions}
     */
    public List<List<Action>> getActions(int fromTick0, int toTick0, int fromIndex0, int toIndex0)
    {
        int fromIndex = Math.min(fromIndex0, toIndex0);
        int toIndex = Math.max(fromIndex0, toIndex0);
        int fromTick = Math.min(fromTick0, toTick0);
        int toTick = Math.max(fromTick0, toTick0);

        if (fromTick0 < 0 || toTick0 < 0 || ((fromIndex0 != -1 || toIndex0 != -1) && fromIndex0 < 0 && toIndex0 < 0)
            || toTick >= this.actions.size())
        {
            return new ArrayList<>();
        }

        List<List<Action>> actionRange = this.actions.subList(fromTick, toTick + 1);

        if (actionRange != null)
        {
            actionRange = new ArrayList<>(actionRange);

            for (int i = 0; i < actionRange.size(); i++)
            {
                List<Action> frame = actionRange.get(i);

                if (frame != null && !frame.isEmpty())
                {
                    if (fromIndex == -1 && toIndex == -1)
                    {
                        actionRange.set(i, new ArrayList<>(frame));
                    }
                    else if (fromIndex >= frame.size())
                    {
                        actionRange.set(i, null);
                    }
                    else
                    {
                        int i0 = MathUtils.clamp(fromIndex, 0, frame.size() - 1);
                        int i1 = MathUtils.clamp(toIndex + 1, 0, frame.size());

                        actionRange.set(i, new ArrayList<>(frame.subList(i0, i1)));
                    }
                }
                else
                {
                    actionRange.set(i, null);
                }
            }
        }

        return actionRange;
    }


    /**
     * @param fromTick0 from tick, inclusive
     * @param toTick0 to tick, inclusive
     * @return a new list containing the actions in the specified ranges. The list can contain null values.
     * @throws IndexOutOfBoundsException if fromTick < 0 || toTick > size of {@link #actions}
     */
    public List<List<Action>> getActions(int fromTick0, int toTick0)
    {
        return this.getActions(fromTick0, toTick0, -1, -1);
    }

    /**
     * @return convert the given action list into a boolean mask, which can be used for deletion.
     *         Returns an empty list if the specified tick is out of range.
     */
    public List<List<Boolean>> getActionsMask(int fromTick, List<List<Action>> actions)
    {
        if (fromTick < 0 || fromTick >= this.actions.size())
        {
            return new ArrayList<>();
        }

        List<List<Boolean>> mask = new ArrayList<>();

        for (int t = fromTick; t < this.actions.size() && t - fromTick < actions.size(); t++)
        {
            List<Boolean> maskFrame = new ArrayList<>();

            if (actions.get(t - fromTick) != null && this.actions.get(t) != null && !this.actions.get(t).isEmpty())
            {
                for (int a = 0; a < this.actions.get(t).size(); a++)
                {
                    maskFrame.add(actions.get(t - fromTick).contains(this.actions.get(t).get(a)));
                }
            }
            else
            {
                maskFrame.add(false);
            }

            mask.add(maskFrame);
        }

        return mask;
    }

    /**
     * @param tick
     * @param action
     * @return the index of the provided action at the provided tick.
     *         If nothing is found or if the tick is out of range or if the tick has no actions -1 will be returned.
     */
    public int getActionIndex(int tick, Action action)
    {
        if (tick < 0 || tick >= this.actions.size()
            || this.actions.get(tick) == null || this.actions.get(tick).isEmpty() || action == null)
        {
            return -1;
        }

        for (int a = 0; a < this.actions.get(tick).size(); a++)
        {
            if (this.actions.get(tick).get(a) == action)
            {
                return a;
            }
        }

        return -1;
    }

    /**
     * @param action
     * @return int array {tick, index} of the found action. If nothing was found the values will be -1
     */
    public int[] findAction(Action action)
    {
        if (action == null)
        {
            return new int[]{-1, -1};
        }

        for (int t = 0; t < this.actions.size(); t++)
        {
            int i = this.getActionIndex(t, action);

            if (i != -1) return new int[]{t, i};
        }

        return new int[]{-1, -1};
    }

    /**
     * Get frame on given tick 
     */
    public Frame getFrame(int tick)
    {
        if (tick >= this.frames.size() || tick < 0)
        {
            return null;
        }

        return this.frames.get(tick);
    }

    /**
     * Reset unloading timer
     */
    public void resetUnload()
    {
        this.unload = Blockbuster.recordUnloadTime.get();
    }

    public void applyFrame(int tick, EntityLivingBase actor, boolean force)
    {
        this.applyFrame(tick, actor, force, false);
    }

    /**
     * Apply a frame at given tick on the given actor. 
     */
    public void applyFrame(int tick, EntityLivingBase actor, boolean force, boolean realPlayer)
    {
        if (tick >= this.frames.size() || tick < 0)
        {
            return;
        }

        Frame frame = this.frames.get(tick);

        frame.apply(actor, this.replay, force);

        if (realPlayer)
        {
            actor.setLocationAndAngles(frame.x, frame.y, frame.z, frame.yaw, frame.pitch);
            actor.motionX = frame.motionX;
            actor.motionY = frame.motionY;
            actor.motionZ = frame.motionZ;

            actor.onGround = frame.onGround;

            if (frame.hasBodyYaw)
            {
                actor.renderYawOffset = frame.bodyYaw;
            }

            if (actor.world.isRemote)
            {
                this.applyClientMovement(actor, frame);
            }

            actor.setSneaking(frame.isSneaking);
            actor.setSprinting(frame.isSprinting);

            if (actor.world.isRemote)
            {
                this.applyFrameClient(actor, null, frame);
            }
        }

        if (actor.world.isRemote && Blockbuster.actorFixY.get())
        {
            actor.posY = frame.y;
        }

        Frame prev = this.frames.get(Math.max(0, tick - 1));

        if (realPlayer || !actor.world.isRemote)
        {
            actor.lastTickPosX = prev.x;
            actor.lastTickPosY = prev.y;
            actor.lastTickPosZ = prev.z;
            actor.prevPosX = prev.x;
            actor.prevPosY = prev.y;
            actor.prevPosZ = prev.z;

            actor.prevRotationYaw = prev.yaw;
            actor.prevRotationPitch = prev.pitch;
            actor.prevRotationYawHead = prev.yawHead;

            if (prev.hasBodyYaw)
            {
                actor.prevRenderYawOffset = prev.bodyYaw;
            }

            if (actor.world.isRemote)
            {
                this.applyFrameClient(actor, prev, frame);
            }
        }
        else if (actor instanceof EntityActor)
        {
            ((EntityActor) actor).prevRoll = prev.roll;
        }

        /* Override fall distance, apparently fallDistance gets reset
         * faster than RecordRecorder can record both onGround and
         * fallDistance being correct for player, so we just hack */
        actor.fallDistance = prev.fallDistance;

        if (tick < this.frames.size() - 1)
        {
            Frame next = this.frames.get(tick + 1);

            /* Walking sounds */
            if (actor instanceof EntityPlayer)
            {
                double dx = next.x - frame.x;
                double dy = next.y - frame.y;
                double dz = next.z - frame.z;

                actor.distanceWalkedModified = actor.distanceWalkedModified + MathHelper.sqrt(dx * dx + dz * dz) * 0.32F;
                actor.distanceWalkedOnStepModified = actor.distanceWalkedOnStepModified + MathHelper.sqrt(dx * dx + dy * dy + dz * dz) * 0.32F;
            }
        }
    }

    @SideOnly(Side.CLIENT)
    private void applyClientMovement(EntityLivingBase actor, Frame frame)
    {
        if (actor instanceof EntityPlayerSP)
        {
            MovementInput input = ((EntityPlayerSP) actor).movementInput;

            input.sneak = frame.isSneaking;
        }
    }

    @SideOnly(Side.CLIENT)
    private void applyFrameClient(EntityLivingBase actor, Frame prev, Frame frame)
    {
        EntityPlayerSP player = Minecraft.getMinecraft().player;

        if (actor == player)
        {
            CameraHandler.setRoll(prev == null ? frame.roll : prev.roll, frame.roll);
        }
    }

    public Frame getFrameSafe(int tick)
    {
        if (this.frames.isEmpty())
        {
            return null;
        }

        return this.frames.get(MathUtils.clamp(tick, 0, this.frames.size() - 1));
    }

    /**
     * Apply an action at the given tick on the given actor. Don't pass tick
     * value less than 0, otherwise you might experience game crash.
     */
    public void applyAction(int tick, EntityLivingBase actor)
    {
        this.applyAction(tick, actor, false);
    }

    /**
     * Apply an action at the given tick on the given actor. Don't pass tick
     * value less than 0, otherwise you might experience game crash.
     */
    public void applyAction(int tick, EntityLivingBase actor, boolean safe)
    {
        if (tick >= this.actions.size() || tick < 0)
        {
            return;
        }

        List<Action> actions = this.actions.get(tick);

        if (actions != null)
        {
            for (Action action : actions)
            {
                if (safe && !action.isSafe())
                {
                    continue;
                }

                try
                {
                    action.apply(actor);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Seek the nearest morph action
     */
    public FoundAction seekMorphAction(int tick, MorphAction last)
    {
        /* I hope it won't cause a lag...  */
        int threshold = 0;

        boolean canRet = last == null;

        while (tick >= threshold)
        {
            List<Action> actions = this.actions.get(tick);

            if (actions == null)
            {
                tick--;

                continue;
            }

            for (int i = actions.size() - 1; i >= 0; i--)
            {
                Action action = actions.get(i);

                if (!canRet && action == last)
                {
                    canRet = true;
                }
                else if (canRet && action instanceof MorphAction)
                {
                    ACTION.set(tick, (MorphAction) action);

                    return ACTION;
                }
            }

            tick--;
        }

        return null;
    }

    /**
     * Apply previous morph
     */
    public void applyPreviousMorph(EntityLivingBase actor, Replay replay, int tick, MorphType type)
    {
        boolean pause = type != MorphType.REGULAR && Blockbuster.recordPausePreview.get();
        AbstractMorph replayMorph = replay == null ? null : replay.morph;

        /* when the tick is at the end - do not apply replay's morph - stay at the last morph */
        if (tick >= this.actions.size()) return;

        FoundAction found = this.seekMorphAction(tick, null);

        if (found != null)
        {
            try
            {
                MorphAction action = found.action;

                if (pause && action.morph instanceof ISyncableMorph)
                {
                    int foundTick = found.tick;
                    int offset = tick - foundTick;

                    found = this.seekMorphAction(foundTick, action);
                    AbstractMorph previous = found == null ? replayMorph : found.action.morph;
                    int previousOffset = foundTick - (found == null ? 0 : found.tick);

                    action.applyWithOffset(actor, offset, previous, previousOffset, type == MorphType.FORCE);
                }
                else
                {
                    action.apply(actor);
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
        else if (replay != null)
        {
            if (pause && replay.morph != null)
            {
                MORPH.morph = replay.morph;
                MORPH.applyWithOffset(actor, tick, null, 0, type == MorphType.FORCE);
            }
            else if (type == MorphType.FORCE && replay.morph != null)
            {
                MORPH.morph = replay.morph;
                MORPH.applyWithForce(actor);
            }
            else
            {
                replay.apply(actor);
            }
        }
    }

    /**
     * Reset the actor based on this record
     */
    public void reset(EntityLivingBase actor)
    {
        if (actor.isRiding())
        {
            this.resetMount(actor);
        }

        if (actor.getHealth() > 0.0F)
        {
            this.applyFrame(0, actor, true);

            /* Reseting actor's state */
            actor.setSneaking(false);
            actor.setSprinting(false);
            actor.setItemStackToSlot(EntityEquipmentSlot.HEAD, ItemStack.EMPTY);
            actor.setItemStackToSlot(EntityEquipmentSlot.CHEST, ItemStack.EMPTY);
            actor.setItemStackToSlot(EntityEquipmentSlot.LEGS, ItemStack.EMPTY);
            actor.setItemStackToSlot(EntityEquipmentSlot.FEET, ItemStack.EMPTY);
            actor.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, ItemStack.EMPTY);
            actor.setItemStackToSlot(EntityEquipmentSlot.OFFHAND, ItemStack.EMPTY);
        }
    }

    /**
     * Reset actor's mount
     */
    protected void resetMount(EntityLivingBase actor)
    {
        int index = -1;

        /* Find at which tick player has mounted a vehicle */
        for (int i = 0, c = this.actions.size(); i < c; i++)
        {
            List<Action> actions = this.actions.get(i);

            if (actions == null)
            {
                continue;
            }

            for (Action action : actions)
            {
                if (action instanceof MountingAction)
                {
                    MountingAction act = (MountingAction) action;

                    if (act.isMounting)
                    {
                        index = i + 1;
                        break;
                    }
                }
            }
        }

        actor.dismountRidingEntity();

        if (index != -1)
        {
            Frame frame = this.frames.get(index);

            if (frame != null)
            {
                Entity mount = actor.getRidingEntity();

                if (mount != null && !(mount instanceof EntityActor))
                {
                    mount.setPositionAndRotation(frame.x, frame.y, frame.z, frame.yaw, frame.pitch);
                }
            }
        }
    }

    /**
     * Add an action to the record
     */
    public void addAction(int tick, Action action)
    {
        List<Action> actions = this.actions.get(tick);

        if (actions != null)
        {
            actions.add(action);
        }
        else
        {
            actions = new ArrayList<Action>();
            actions.add(action);

            this.actions.set(tick, actions);
        }
    }

    /**
     * Add an action to the recording at the specified tick and index.
     * If the index is greater than the frame's size at the specified tick,
     * the action will just be appended to the actions of the frame.
     * @param tick
     * @param index
     * @param action
     */
    public void addAction(int tick, int index, Action action)
    {
        List<Action> actions = this.actions.get(tick);

        if (actions != null)
        {
            if (index == -1 || index > actions.size())
            {
                actions.add(action);
            }
            else
            {
                actions.add(index, action);
            }
        }
        else
        {
            actions = new ArrayList<Action>();
            actions.add(action);

            this.actions.set(tick, actions);
        }
    }

    /**
     * Adds many ticks of actions beginning at the provided fromTick.
     * @param tick
     * @param actions
     */
    public void addActionCollection(int tick, List<List<Action>> actions)
    {
        this.addActionCollection(tick, -1, actions);
    }

    /**
     * Add an action collection beginning at the specified tick at the specified index.
     * If the index is -1, the actions at the frames will just be added on top.
     * @param tick
     * @param index can be -1
     * @param actions
     */
    public void addActionCollection(int tick, int index, List<List<Action>> actions)
    {
        if (index < -1 || tick < 0 || tick >= this.actions.size() || actions == null)
        {
            return;
        }

        for (int i = tick; i < this.actions.size() && i - tick < actions.size(); i++)
        {
            List<Action> frame = this.actions.get(i);
            List<Action> actionFrame = actions.get(i - tick) != null && !actions.get(i - tick).isEmpty() ? new ArrayList<>(actions.get(i - tick)) : null;

            if (frame == null)
            {
                this.actions.set(i, actionFrame);
            }
            else if (actionFrame != null)
            {
                if (index > frame.size() || index == -1)
                {
                    frame.addAll(actionFrame);
                }
                else
                {
                    frame.addAll(index, actionFrame);
                }
            }
        }
    }

    public void addActions(int tick, List<Action> actions)
    {
        if (tick < 0 || tick >= this.actions.size())
        {
            return;
        }

        List<Action> present = this.actions.get(tick);

        if (present == null)
        {
            this.actions.set(tick, actions);
        }
        else if (actions != null)
        {
            present.addAll(actions);
        }
    }

    /**
     * Remove an action at given tick and index 
     */
    public void removeAction(int tick, int index)
    {
        if (index == -1)
        {
            this.actions.set(tick, null);
        }
        else
        {
            List<Action> actions = this.actions.get(tick);

            if (index >= 0 && index < actions.size())
            {
                actions.remove(index);

                if (actions.isEmpty())
                {
                    this.actions.set(tick, null);
                }
            }
        }
    }

    public void removeActions(int fromTick, List<List<Action>> actions)
    {
        for (int tick = fromTick, c = 0; tick < this.actions.size() && c < actions.size(); tick++, c++)
        {
            if (this.actions.get(tick) != null && actions.get(c) != null)
            {
                this.actions.get(tick).removeAll(actions.get(c));
            }

            if (this.actions.get(tick) != null && this.actions.get(tick).isEmpty())
            {
                this.actions.set(tick, null);
            }
        }
    }

    /**
     * Remove actions based on the boolean mask provided.
     * @param fromTick
     * @param mask
     */
    public void removeActionsMask(int fromTick, List<List<Boolean>> mask)
    {
        for (int tick = fromTick, c = 0; tick < this.actions.size() && c < mask.size(); tick++, c++)
        {
            if (this.actions.get(tick) != null && mask.get(c) != null)
            {
                List<Action> remove = new ArrayList<>();

                for (int a = 0; a < this.actions.get(tick).size() && a < mask.get(c).size(); a++)
                {
                    if (mask.get(c).get(a))
                    {
                        remove.add(this.actions.get(tick).get(a));
                    }
                }

                this.actions.get(tick).removeAll(remove);
            }
        }
    }

    /**
     * Remove actions from tick and to tick inclusive and at every tick
     * remove from index to index inclusive.
     * If both index parameters are -1, all actions at the respective ticks will be deleted.
     * @param fromTick0
     * @param toTick0
     * @param fromIndex0
     * @param toIndex0
     */
    public void removeActions(int fromTick0, int toTick0, int fromIndex0, int toIndex0)
    {
        int fromIndex = Math.min(fromIndex0, toIndex0);
        int toIndex = Math.max(fromIndex0, toIndex0);
        int fromTick = Math.min(fromTick0, toTick0);
        int toTick = Math.max(fromTick0, toTick0);
        int frameCount = this.actions.size();

        if (fromIndex == -1 && toIndex == -1)
        {
            for (int tick = fromTick; tick <= toTick && tick < frameCount; tick++)
            {
                this.actions.set(tick, null);
            }
        }
        else
        {
            for (int tick = fromTick; tick <= toTick && tick < frameCount; tick++)
            {
                List<Action> actions = this.actions.get(tick);

                if (actions == null) continue;

                if (fromIndex != -1 && toIndex != -1)
                {
                    int max = toIndex;

                    while (fromIndex <= max && fromIndex < actions.size())
                    {
                        actions.remove(fromIndex);

                        max--;
                    }
                }
                else
                {
                    int index = fromIndex == -1 ? toIndex : fromIndex;

                    if (index < actions.size())
                    {
                        actions.remove(index);
                    }
                }

                if (actions.isEmpty())
                {
                    this.actions.set(tick, null);
                }
            }
        }
    }

    /**
     * Replace an action at given tick and index
     */
    public void replaceAction(int tick, int index, Action action)
    {
        if (tick < 0 || tick >= this.actions.size())
        {
            return;
        }

        List<Action> actions = this.actions.get(tick);

        if (actions == null || index < 0 || index >= actions.size())
        {
            this.addAction(tick, action);
        }
        else
        {
            actions.set(index, action);
        }
    }

    /**
     * Create a copy of this record
     */
    @Override
    public Record clone()
    {
        Record record = new Record(this.filename);

        record.version = this.version;
        record.preDelay = this.preDelay;
        record.postDelay = this.postDelay;

        for (Frame frame : this.frames)
        {
            record.frames.add(frame.copy());
        }

        for (List<Action> actions : this.actions)
        {
            if (actions == null || actions.isEmpty())
            {
                record.actions.add(null);
            }
            else
            {
                List<Action> newActions = new ArrayList<Action>();

                for (Action action : actions)
                {
                    try
                    {
                        NBTTagCompound tag = new NBTTagCompound();

                        action.toNBT(tag);

                        Action newAction = ActionRegistry.fromType(ActionRegistry.getType(action));

                        newAction.fromNBT(tag);
                        newActions.add(newAction);
                    }
                    catch (Exception e)
                    {
                        System.out.println("Failed to clone an action!");
                        e.printStackTrace();
                    }
                }

                record.actions.add(newActions);
            }
        }

        return record;
    }

    public void save(File file) throws IOException
    {
        this.save(file, true);
    }

    /**
     * Save a recording to given file.
     *
     * This method basically writes the signature of the current version,
     * and then saves all available frames and actions.
     */
    public void save(File file, boolean savePast) throws IOException
    {
        if (savePast && file.isFile())
        {
            this.savePastCopies(file);
        }

        NBTTagCompound compound = new NBTTagCompound();
        NBTTagList frames = new NBTTagList();

        /* Version of the recording */
        compound.setShort("Version", SIGNATURE);
        compound.setInteger("PreDelay", this.preDelay);
        compound.setInteger("PostDelay", this.postDelay);
        compound.setTag("Actions", this.createActionMap());

        if (this.playerData != null)
        {
            compound.setTag("PlayerData", this.playerData);
        }

        int c = this.frames.size();
        int d = this.actions.size() - this.frames.size();

        if (d < 0) d = 0;

        for (int i = 0; i < c; i++)
        {
            NBTTagCompound frameTag = new NBTTagCompound();

            Frame frame = this.frames.get(i);
            List<Action> actions = null;

            if (d + i <= this.actions.size() - 1)
            {
                actions = this.actions.get(d + i);
            }

            frame.toNBT(frameTag);

            if (actions != null)
            {
                NBTTagList actionsTag = new NBTTagList();

                for (Action action : actions)
                {
                    NBTTagCompound actionTag = new NBTTagCompound();

                    action.toNBT(actionTag);
                    actionTag.setByte("Type", ActionRegistry.CLASS_TO_ID.get(action.getClass()));
                    actionsTag.appendTag(actionTag);
                }

                frameTag.setTag("Action", actionsTag);
            }

            frames.appendTag(frameTag);
        }

        compound.setTag("Frames", frames);

        CompressedStreamTools.writeCompressed(compound, new FileOutputStream(file));
    }

    /**
     * This method removes the last file, and renames past versions of a recording files. 
     * This should save countless hours of work in case somebody accidentally overwrote 
     * a player recording.
     */
    private void savePastCopies(File file)
    {
        final int copies = 5;

        int counter = copies;
        String name = FilenameUtils.removeExtension(file.getName());

        while (counter >= 0 && file.exists())
        {
            File current = this.getPastFile(file, name, counter);

            if (current.exists()) 
            {
                if (counter == copies)
                {
                    current.delete();
                }
                else
                {
                    File previous = this.getPastFile(file, name, counter + 1);

                    current.renameTo(previous);
                }
            }

            counter--;
        }
    }

    /**
     * Get a path to the past copy of the file
     */
    private File getPastFile(File file, String name, int iteration)
    {
        return new File(file.getParentFile(), name + (iteration == 0 ? ".dat" : ".dat~" + iteration));
    }

    /**
     * Creates an action map between action name and an action type byte values
     * for compatibility
     */
    private NBTTagCompound createActionMap()
    {
        NBTTagCompound tag = new NBTTagCompound();

        for (Map.Entry<String, Byte> entry : ActionRegistry.NAME_TO_ID.entrySet())
        {
            tag.setString(entry.getValue().toString(), entry.getKey());
        }

        return tag;
    }

    /**
     * Read a recording from given file.
     *
     * This method basically checks if the given file has appropriate short
     * signature, and reads all frames and actions from the file.
     */
    public void load(File file) throws IOException
    {
        this.load(CompressedStreamTools.readCompressed(new FileInputStream(file)));
    }

    public void load(NBTTagCompound compound)
    {
        NBTTagCompound map = null;

        this.version = compound.getShort("Version");
        this.preDelay = compound.getInteger("PreDelay");
        this.postDelay = compound.getInteger("PostDelay");

        if (compound.hasKey("Actions", 10))
        {
            map = compound.getCompoundTag("Actions");
        }

        if (compound.hasKey("PlayerData", 10))
        {
            this.playerData = compound.getCompoundTag("PlayerData");
        }

        NBTTagList frames = (NBTTagList) compound.getTag("Frames");

        for (int i = 0, c = frames.tagCount(); i < c; i++)
        {
            NBTTagCompound frameTag = frames.getCompoundTagAt(i);
            NBTBase actionTag = frameTag.getTag("Action");
            Frame frame = new Frame();

            frame.fromNBT(frameTag);

            if (actionTag != null)
            {
                try
                {
                    List<Action> actions = new ArrayList<Action>();

                    if (actionTag instanceof NBTTagCompound)
                    {
                        Action action = this.actionFromNBT((NBTTagCompound) actionTag, map);

                        if (action != null)
                        {
                            actions.add(action);
                        }
                    }
                    else if (actionTag instanceof NBTTagList)
                    {
                        NBTTagList list = (NBTTagList) actionTag;

                        for (int ii = 0, cc = list.tagCount(); ii < cc; ii++)
                        {
                            Action action = this.actionFromNBT(list.getCompoundTagAt(ii), map);

                            if (action != null)
                            {
                                actions.add(action);
                            }
                        }
                    }

                    this.actions.add(actions);
                }
                catch (Exception e)
                {
                    System.out.println("Failed to load an action at frame " + i);
                    e.printStackTrace();
                }
            }
            else
            {
                this.actions.add(null);
            }

            this.frames.add(frame);
        }
    }

    private Action actionFromNBT(NBTTagCompound tag, NBTTagCompound map) throws Exception
    {
        byte type = tag.getByte("Type");
        Action action = null;

        if (map == null)
        {
            action = ActionRegistry.fromType(type);
        }
        else
        {
            String name = map.getString(String.valueOf(type));

            if (ActionRegistry.NAME_TO_CLASS.containsKey(name))
            {
                action = ActionRegistry.fromName(name);
            }
        }

        if (action != null)
        {
            action.fromNBT(tag);
        }

        return action;
    }

    public void reverse()
    {
        Collections.reverse(this.frames);
        Collections.reverse(this.actions);
    }

    public void fillMissingActions()
    {
        while (this.actions.size() < this.frames.size())
        {
            this.actions.add(null);
        }
    }

    public static class FoundAction
    {
        public int tick;
        public MorphAction action;

        public void set(int tick, MorphAction action)
        {
            this.tick = tick;
            this.action = action;
        }
    }

    public static enum MorphType
    {
        REGULAR, PAUSE, FORCE
    }
}

==================================================

--- Файл №472 ---
Путь: main\java\mchorse\blockbuster\recording\scene\Replay.java
--------------------
package mchorse.blockbuster.recording.scene;

import com.google.common.base.Objects;
import io.netty.buffer.ByteBuf;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.mclib.utils.TextUtils;
import mchorse.metamorph.api.MorphAPI;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.vanilla_pack.morphs.PlayerMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.SharedMonsterAttributes;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.SoundEvents;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;

/**
 * Replay domain object
 *
 * This class is responsible for storing, and persisting to different sources
 * (to NBT and ByteBuf) its content.
 */
public class Replay
{
    /* Meta data */
    public String id = "";
    public String name = "";
    public String target = "";
    public boolean invincible = false;
    public boolean enableBurning = true;
    public boolean teleportBack = true;
    /**
     * Whether the food and XP recording should be played back
     */
    public boolean playBackXPFood = false;

    /* Visual data */
    public AbstractMorph morph;
    public boolean invisible = false;
    public boolean enabled = true;
    public boolean fake = false;
    public float health = 20F;
    public boolean renderLast = false;
    public int foodLevel = 20;
    public int totalExperience = 0;

    public Replay()
    {}

    public Replay(String id)
    {
        this.id = id;
    }

    /**
     * Apply replay on an entity 
     */
    public void apply(EntityLivingBase entity)
    {
        if (entity instanceof EntityActor)
        {
            this.apply((EntityActor) entity);
        }
        else if (entity instanceof EntityPlayer)
        {
            if (!(this.morph instanceof PlayerMorph))
            {
                this.apply((EntityPlayer) entity);
            }
        }
    }

    /**
     * Apply replay on an actor
     */
    public void apply(EntityActor actor)
    {
        String name = TextUtils.processColoredText(this.name);

        actor.setCustomNameTag(name);
        actor.setEntityInvulnerable(this.invincible);
        actor.morph(mchorse.metamorph.api.MorphUtils.copy(this.morph), false);
        actor.invisible = this.invisible;
        actor.enableBurning = this.enableBurning;

        if (this.health > 20)
        {
            actor.getEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(this.health);
        }

        actor.setHealth(this.health);
        actor.renderLast = this.renderLast;
        actor.notifyPlayers();
    }

    /**
     * Apply replay on a player 
     */
    public void apply(EntityPlayer player)
    {
        MorphAPI.morph(player, mchorse.metamorph.api.MorphUtils.copy(this.morph), true);
        player.setHealth(this.health);
        player.getFoodStats().setFoodLevel(this.foodLevel);
        player.experienceTotal = 0;
        player.experience = 0;
        player.experienceLevel = 0;
        this.setExperienceWithoutSound(player, this.totalExperience);
    }

    private void setExperienceWithoutSound(EntityPlayer player, int amount)
    {
        /* copied from EntityPlayer.addExperience(int) and modified */
        player.addScore(amount);
        int i = Integer.MAX_VALUE - player.experienceTotal;

        if (amount > i)
        {
            amount = i;
        }

        player.experience += (float)amount / (float)player.xpBarCap();

        for (player.experienceTotal += amount; player.experience >= 1.0F; player.experience /= (float)player.xpBarCap())
        {
            player.experience = (player.experience - 1.0F) * (float)player.xpBarCap();

            player.experienceLevel += 1;
        }
    }

    /* to / from NBT */

    public void toNBT(NBTTagCompound tag)
    {
        tag.setString("Id", this.id);
        tag.setString("Name", this.name);
        tag.setString("Target", this.target);

        if (this.morph != null)
        {
            tag.setTag("Morph", this.morph.toNBT());
        }

        tag.setBoolean("Invincible", this.invincible);
        tag.setBoolean("Invisible", this.invisible);
        tag.setBoolean("EnableBurning", this.enableBurning);
        tag.setBoolean("Enabled", this.enabled);
        tag.setBoolean("Fake", this.fake);
        if (!this.teleportBack) tag.setBoolean("TP", this.teleportBack);
        if (this.health != 20) tag.setFloat("Health", this.health);
        if (this.foodLevel != 20) tag.setInteger("FoodLevel", this.foodLevel);
        if (this.totalExperience != 0) tag.setInteger("TotalExperience", this.totalExperience);
        if (this.renderLast) tag.setBoolean("RenderLast", this.renderLast);
        if (this.playBackXPFood) tag.setBoolean("PlaybackXPFoodLevel", this.playBackXPFood);
    }

    public void fromNBT(NBTTagCompound tag)
    {
        this.id = tag.getString("Id");
        this.name = tag.getString("Name");
        this.target = tag.getString("Target");
        this.morph = MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag("Morph"));
        this.invincible = tag.getBoolean("Invincible");
        this.invisible = tag.getBoolean("Invisible");
        this.enableBurning = tag.getBoolean("EnableBurning");
        this.fake = tag.getBoolean("Fake");
        this.foodLevel = tag.hasKey("FoodLevel") ? tag.getInteger("FoodLevel") : this.foodLevel;
        this.totalExperience = tag.hasKey("TotalExperience") ? tag.getInteger("TotalExperience") : this.totalExperience;

        if (tag.hasKey("Enabled")) this.enabled = tag.getBoolean("Enabled");
        if (tag.hasKey("TP")) this.teleportBack = tag.getBoolean("TP");
        if (tag.hasKey("Health")) this.health = tag.getFloat("Health");
        if (tag.hasKey("RenderLast")) this.renderLast = tag.getBoolean("RenderLast");
        if (tag.hasKey("PlaybackXPFoodLevel")) this.playBackXPFood = tag.getBoolean("PlaybackXPFoodLevel");
    }

    /* to / from ByteBuf */

    public void toBuf(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.id);
        ByteBufUtils.writeUTF8String(buf, this.name);
        ByteBufUtils.writeUTF8String(buf, this.target);
        MorphUtils.morphToBuf(buf, this.morph);

        buf.writeBoolean(this.invincible);
        buf.writeBoolean(this.invisible);
        buf.writeBoolean(this.enableBurning);
        buf.writeBoolean(this.enabled);
        buf.writeBoolean(this.fake);
        buf.writeBoolean(this.teleportBack);
        buf.writeBoolean(this.renderLast);
        buf.writeFloat(this.health);
        buf.writeInt(this.foodLevel);
        buf.writeInt(this.totalExperience);
        buf.writeBoolean(this.playBackXPFood);
    }

    public void fromBuf(ByteBuf buf)
    {
        this.id = ByteBufUtils.readUTF8String(buf);
        this.name = ByteBufUtils.readUTF8String(buf);
        this.target = ByteBufUtils.readUTF8String(buf);
        this.morph = MorphUtils.morphFromBuf(buf);

        this.invincible = buf.readBoolean();
        this.invisible = buf.readBoolean();
        this.enableBurning = buf.readBoolean();
        this.enabled = buf.readBoolean();
        this.fake = buf.readBoolean();
        this.teleportBack = buf.readBoolean();
        this.renderLast = buf.readBoolean();
        this.health = buf.readFloat();
        this.foodLevel = buf.readInt();
        this.totalExperience = buf.readInt();
        this.playBackXPFood = buf.readBoolean();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Replay)
        {
            Replay replay = (Replay) obj;

            return Objects.equal(replay.id, this.id)
                && Objects.equal(replay.name, this.name)
                && Objects.equal(replay.target, this.target)
                && replay.invincible == this.invincible
                && replay.invisible == this.invisible
                && replay.enableBurning == this.enableBurning
                && replay.renderLast == this.renderLast
                && Objects.equal(replay.morph, this.morph);
        }

        return super.equals(obj);
    }

    public Replay copy()
    {
        Replay replay = new Replay();

        replay.id = this.id;
        replay.name = this.name;
        replay.target = this.target;
        replay.morph = mchorse.metamorph.api.MorphUtils.copy(this.morph);

        replay.invincible = this.invincible;
        replay.invisible = this.invisible;
        replay.enableBurning = this.enableBurning;
        replay.enabled = this.enabled;
        replay.fake = this.fake;
        replay.teleportBack = this.teleportBack;
        replay.renderLast = this.renderLast;
        replay.health = this.health;
        replay.foodLevel = this.foodLevel;
        replay.totalExperience = this.totalExperience;
        replay.playBackXPFood = this.playBackXPFood;

        return replay;
    }
}

==================================================

--- Файл №473 ---
Путь: main\java\mchorse\blockbuster\recording\scene\Scene.java
--------------------
package mchorse.blockbuster.recording.scene;

import com.mojang.authlib.GameProfile;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.audio.AudioHandler;
import mchorse.blockbuster.audio.AudioState;
import mchorse.blockbuster.capabilities.recording.IRecording;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.RecordUtils;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.recording.scene.fake.FakeContext;
import mchorse.mclib.utils.LatencyTimer;
import mchorse.vanilla_pack.morphs.PlayerMorph;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.network.EnumPacketDirection;
import net.minecraft.network.NetHandlerPlayServer;
import net.minecraft.network.NetworkManager;
import net.minecraft.network.PacketBuffer;
import net.minecraft.network.play.client.CPacketClientSettings;
import net.minecraft.scoreboard.Team;
import net.minecraft.server.management.PlayerInteractionManager;
import net.minecraft.server.management.PlayerList;
import net.minecraft.util.EnumHandSide;
import net.minecraft.util.NonNullList;
import net.minecraft.world.World;
import net.minecraft.world.WorldServer;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import javax.annotation.Nullable;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Scene
 */
public class Scene
{
    public static long lastUpdate;

    /**
     * Pattern for finding numbered suffix
     */
    public static final Pattern NUMBERED_SUFFIX = Pattern.compile("_(\\d+)$");

    /**
     * Pattern for finding prefix
     */
    public static final Pattern PREFIX = Pattern.compile("^(.+)_([^_]+)$");

    /**
     * Pattern for finding indexes
     */
    public static final Pattern INDEXES = Pattern.compile("[^_]+");

    /**
     * Scene's id/filename
     */
    private String id = "";

    /**
     * List of replays
     */
    public List<Replay> replays = new ArrayList<Replay>();

    /**
     * Display title, used for client organization purposes
     */
    public String title = "";

    /**
     * Command which should be executed when director block starts
     * playing
     */
    public String startCommand = "";

    /**
     * Command which should be executed when director block stops
     * playing
     */
    public String stopCommand = "";

    /**
     * Whether director's playback is looping
     */
    public boolean loops;

    private AudioHandler audioHandler = new AudioHandler();

    /* Runtime properties */

    /**
     * Whether this scene is active
     */
    public boolean playing;

    /**
     * Map of currently playing actors
     */
    public Map<Replay, RecordPlayer> actors = new HashMap<Replay, RecordPlayer>();

    /**
     * Count of actors which were spawned (used to check whether actors
     * are still playing)
     */
    public int actorsCount = 0;

    /**
     * Director command sender
     */
    private ICommandSender sender;

    /**
     * This tick used for checking if actors still playing
     */
    private int tick = 0;

    /**
     * Whether this scene gets recorded
     */
    private boolean wasRecording;

    /**
     * Whether it's paused
     */
    private boolean paused;

    /**
     * World instance
     */
    private World world;

    /**
     * List that contains the players that have been chosen for first person playback in this scene
     * with their inventory before playback has been started
     */
    private List<PlayerState> targetPlayers = new ArrayList<>();

    /**
     *
     * @param player
     * @return true if the given player reference has been chosen for first person playback in one actor
     */
    public boolean isPlayerTargetPlayback(EntityPlayer player)
    {
        for (PlayerState state : this.targetPlayers)
        {
            if (state.getPlayer() == player)
            {
                return true;
            }
        }

        return false;
    }

    public List<EntityPlayer> getTargetPlaybackPlayers()
    {
        List<EntityPlayer> players = new ArrayList<>();

        for (PlayerState state : this.targetPlayers)
        {
            players.add(state.getPlayer());
        }

        return players;
    }

    public String getAudio()
    {
        return this.audioHandler.getAudioName();
    }

    public void setAudio(String audio)
    {
        this.audioHandler.setAudioName(audio);
    }

    /**
     * Audio shift
     */
    public int getAudioShift()
    {
        return this.audioHandler.getAudioShift();
    }

    public void setAudioShift(int audioShift)
    {
        this.audioHandler.setAudioShift(audioShift);
        /* update the audio on the server so the shift change is visible */
        if (this.world != null && !this.world.isRemote)
        {
            this.audioHandler.goTo(this.tick);
        }
    }

    public String getId()
    {
        return this.id;
    }

    public void setId(String id)
    {
        this.id = id;
    }

    public void setWorld(World world)
    {
        this.world = world;
    }

    public World getWorld()
    {
        return this.world;
    }

    public int getTick()
    {
        return this.tick;
    }

    public int getCurrentTick()
    {
        for (RecordPlayer player : this.actors.values())
        {
            if (!player.isFinished() && !player.actor.isDead)
            {
                return player.tick;
            }
        }

        return 0;
    }

    public AudioState getAudioState()
    {
        return this.audioHandler.getAudioState();
    }

    /**
     * Set director command sender
     */
    public void setSender(ICommandSender sender)
    {
        this.sender = sender;
    }

    /**
     * Get a replay by actor. Comparison is based on actor's UUID.
     */
    public Replay getByFile(String filename)
    {
        for (Replay replay : this.replays)
        {
            if (replay.id.equals(filename))
            {
                return replay;
            }
        }

        return null;
    }

    /**
     * Get maximum length of current director block
     */
    public int getMaxLength()
    {
        int max = 0;

        for (Replay replay : this.replays)
        {
            Record record = null;

            try
            {
                record = CommonProxy.manager.get(replay.id);
            }
            catch (Exception e)
            {}

            if (record != null)
            {
                max = Math.max(max, record.getFullLength());
            }
        }

        return max;
    }

    public void tick()
    {
        if (Blockbuster.debugPlaybackTicks.get())
        {
            this.logTicks();
        }

        for (RecordPlayer player : this.actors.values())
        {
            if (!player.realPlayer && player.actor instanceof EntityPlayer)
            {
                ((EntityPlayerMP) player.actor).onUpdateEntity();
            }
            else if (!player.actorUpdated)
            {
                player.next();
            }

            player.actorUpdated = false;
        }

        if (this.playing && !this.paused)
        {
            if (this.tick % 4 == 0 && !this.checkActors()) return;

            this.audioHandler.update();
            this.tick++;
        }
    }

    public void worldTick(World world)
    {
        for (RecordPlayer player : this.actors.values())
        {
            if (player.actor.world == world)
            {
                if (this.playing)
                {
                    player.checkAndSpawn();
                }

                player.playActions();
            }
        }
    }

    /**
     * Check whether collected actors are still playing
     */
    public boolean areActorsFinished()
    {
        int count = 0;

        for (Map.Entry<Replay, RecordPlayer> entry : this.actors.entrySet())
        {
            Replay replay = entry.getKey();
            RecordPlayer actor = entry.getValue();

            if (this.loops && actor.isFinished())
            {
                actor.record.reset(actor.actor);

                actor.startPlaying(replay.id, actor.kill);
                actor.record.applyAction(0, actor.actor);

                CommonProxy.manager.players.put(actor.actor, actor);
            }

            if ((actor.isFinished() && actor.playing) || actor.actor.isDead)
            {
                count++;
            }
        }

        return count == this.actorsCount;
    }

    /* Playback and editing */

    /**
     * Check whether actors are still playing, if they're stop the whole
     * thing
     * @return false if every actor is finished and the scene can be stopped.
     */
    public boolean checkActors()
    {
        /*
         * don't stop the entire scene when one actor is left and if that is the recording actor
         * If it would stop, delayed audio might not start.
         */
        if (this.areActorsFinished() && !this.loops && !this.wasRecording)
        {
            this.stopPlayback(false);

            return false;
        }

        return true;
    }

    /**
     * The same thing as play, but don't play the actor that is passed
     * in the arguments (because he might be recorded by the player)
     */
    public void startPlayback(int tick)
    {
        if (this.getWorld().isRemote || this.playing || this.replays.isEmpty())
        {
            return;
        }

        for (Replay replay : this.replays)
        {
            if (replay.id.isEmpty())
            {
                RecordUtils.broadcastError("director.empty_filename");

                return;
            }
        }

        this.collectActors(null);

        EntityLivingBase firstActor = null;

        for (Map.Entry<Replay, RecordPlayer> entry : this.actors.entrySet())
        {
            Replay replay = entry.getKey();
            RecordPlayer actor = entry.getValue();

            if (firstActor == null)
            {
                firstActor = actor.actor;
            }

            actor.startPlaying(replay.id, tick, !this.loops);
        }

        this.playing = true;
        this.sendCommand(this.startCommand);

        if (firstActor != null)
        {
            CommonProxy.damage.addDamageControl(this, firstActor);
        }

        this.audioHandler.startAudio(tick);

        this.wasRecording = false;
        this.paused = false;
        this.tick = tick;
    }

    /**
     * The same thing as play, but don't play the replay that is passed
     * in the arguments (because he might be recorded by the player)
     *
     * Used by recording code.
     */
    public void startPlayback(String exception, int tick)
    {
        if (this.getWorld().isRemote || this.playing)
        {
            return;
        }

        this.collectActors(this.getByFile(exception));

        for (Map.Entry<Replay, RecordPlayer> entry : this.actors.entrySet())
        {
            Replay replay = entry.getKey();
            RecordPlayer actor = entry.getValue();

            actor.startPlaying(replay.id, tick, true);
        }

        this.playing = true;
        this.sendCommand(this.startCommand);

        this.audioHandler.startAudio(tick);

        this.wasRecording = true;
        this.paused = false;
        this.tick = tick;
    }

    /**
     * Spawns actors at given tick in idle mode and pause the scene. This is pretty useful
     * for positioning cameras for exact positions.
     */
    public boolean spawn(int tick)
    {
        if (this.replays.isEmpty())
        {
            return false;
        }

        if (!this.actors.isEmpty())
        {
            this.stopPlayback(true);
        }

        for (Replay replay : this.replays)
        {
            if (replay.id.isEmpty())
            {
                RecordUtils.broadcastError("director.empty_filename");

                return false;
            }
        }

        this.collectActors(null);
        this.playing = true;
        this.paused = true;

        int j = 0;

        for (Map.Entry<Replay, RecordPlayer> entry : this.actors.entrySet())
        {
            Replay replay = entry.getKey();
            RecordPlayer actor = entry.getValue();

            if (j == 0 && actor.actor != null)
            {
                CommonProxy.damage.addDamageControl(this, actor.actor);
            }

            actor.playing = false;
            actor.startPlaying(replay.id, tick, true);
            actor.sync = true;
            actor.pause();

            for (int i = 0; i <= tick; i++)
            {
                actor.record.applyAction(i - actor.record.preDelay, actor.actor);
            }

            actor.record.applyPreviousMorph(actor.actor, replay, tick, Record.MorphType.PAUSE);

            j++;
        }

        this.audioHandler.pauseAudio(tick);
        this.tick = tick;

        return true;
    }

    /**
     * Force stop playback
     *
     * @param triggered - true if it was caused by something, and false if it just ended playing
     */
    public void stopPlayback(boolean triggered)
    {
        if (!triggered && !this.wasRecording || triggered)
        {
            this.wasRecording = false;
        }

        if (this.getWorld().isRemote || !this.playing)
        {
            return;
        }

        this.tick = 0;

        for (Map.Entry<Replay, RecordPlayer> entry : this.actors.entrySet())
        {
            RecordPlayer actor = entry.getValue();

            actor.kill = true;
            actor.stopPlaying();
        }

        CommonProxy.damage.restoreDamageControl(this, this.getWorld());

        this.targetPlayers.forEach((playerState) ->
        {
            playerState.resetPlayerState();
        });

        this.targetPlayers.clear();

        this.audioHandler.stopAudio();

        this.actors.clear();
        this.playing = false;
        this.sendCommand(this.stopCommand);
    }

    /**
     * Toggle scene's playback
     */
    public boolean togglePlayback()
    {
        if (this.playing)
        {
            this.stopPlayback(true);
        }
        else
        {
            this.startPlayback(0);
        }

        return this.playing;
    }

    /**
     * Collect actors.
     *
     * This method is responsible for collecting actors the ones that in the
     * world and also the ones that doesn't exist (they will be created and
     * spawned later on).
     */
    private void collectActors(Replay exception)
    {
        this.actors.clear();
        this.actorsCount = 0;

        for (Replay replay : this.replays)
        {
            if (replay == exception || !replay.enabled)
            {
                continue;
            }

            World world = this.getWorld();
            EntityLivingBase actor = null;
            boolean real = false;

            /* Locate the target player */
            if (!replay.target.isEmpty())
            {
                EntityPlayerMP player = this.getTargetPlayer(replay.target);

                if (player != null)
                {
                    if (!this.isPlayerTargetPlayback(player))
                    {
                        this.targetPlayers.add(new PlayerState(player));
                    }

                    actor = player;
                    real = true;
                }
            }

            if (actor == null && replay.fake)
            {
                GameProfile profile = new GameProfile(new UUID(0, this.actorsCount), replay.name.isEmpty() ? "Player" : replay.name);

                if (replay.morph instanceof PlayerMorph)
                {
                    profile = ((PlayerMorph) replay.morph).profile;
                }

                EntityPlayerMP player = new EntityPlayerMP(world.getMinecraftServer(), (WorldServer) world, profile, new PlayerInteractionManager(world));
                NetworkManager manager = new NetworkManager(EnumPacketDirection.SERVERBOUND);

                try
                {
                    manager.channelActive(new FakeContext());
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }

                IRecording recording = Recording.get(player);

                recording.setFakePlayer(true);

                /* There is no way to construct a CPacketClientSettings on the
                 * server side without using this hack, because the other constructor
                 * is available only on the client side...
                 */
                PacketBuffer buffer = new PacketBuffer(Unpooled.buffer(64));

                buffer.writeString("en_US");
                buffer.writeByte((byte) 10);
                buffer.writeEnumValue(EntityPlayer.EnumChatVisibility.FULL);
                buffer.writeBoolean(true);
                buffer.writeByte(127);
                buffer.writeEnumValue(EnumHandSide.RIGHT);

                CPacketClientSettings packet = new CPacketClientSettings();

                try
                {
                    packet.readPacketData(buffer);
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }

                /* Skins layers don't show up by default, for some
                 * reason, thus I have to manually set it myself */
                player.handleClientSettings(packet);
                player.connection = new NetHandlerPlayServer(world.getMinecraftServer(), manager, player);
                actor = player;
            }
            else if (actor == null)
            {
                EntityActor entity = new EntityActor(this.getWorld());

                entity.wasAttached = true;
                actor = entity;
            }

            RecordPlayer player = CommonProxy.manager.play(replay.id, actor, Mode.BOTH, 0, true);

            if (real)
            {
                player.realPlayer();
            }

            if (player != null)
            {
                player.setReplay(replay);

                this.actorsCount++;
                replay.apply(actor);
                this.actors.put(replay, player);
            }
        }

        if (Blockbuster.modelBlockResetOnPlayback.get())
        {
            lastUpdate = System.currentTimeMillis();
        }
    }

    /**
     * Get target player
     */
    private EntityPlayerMP getTargetPlayer(String target)
    {
        PlayerList list = this.world.getMinecraftServer().getPlayerList();

        if (target.equals("@r"))
        {
            /* Pick a random player */
            return list.getPlayers().get((int) (list.getPlayers().size() * Math.random()));
        }
        else if (target.startsWith("@"))
        {
            /* Pick the first player from given team */
            Team team = this.world.getScoreboard().getTeam(target.substring(1));

            if (team != null && !team.getMembershipCollection().isEmpty())
            {
                return list.getPlayerByUsername(team.getMembershipCollection().iterator().next());
            }
        }

        /* Get the player by username */
        return list.getPlayerByUsername(target);
    }

    public boolean isPlaying()
    {
        for (RecordPlayer player : this.actors.values())
        {
            if (player.playing)
            {
                return true;
            }
        }

        return false;
    }

    /**
     * Pause the director block playback (basically, pause all actors)
     */
    public void pause()
    {
        for (RecordPlayer actor : this.actors.values())
        {
            actor.pause();
        }

        this.audioHandler.pauseAudio();
        this.paused = true;
    }

    /**
     * Resume paused director block playback (basically, resume all actors)
     * @param tick the tick at which to resume playing. If -1 the scene will just play at the tick it was paused at.
     */
    public void resume(int tick)
    {
        if (tick >= 0)
        {
            this.tick = tick;
        }

        for (RecordPlayer player : this.actors.values())
        {
            player.resume(tick);
        }

        this.audioHandler.resume(this.tick);
        this.paused = false;
    }

    /**
     * Make actors go to the given tick
     */
    public void goTo(int tick, boolean actions)
    {
        this.tick = tick;

        for (Map.Entry<Replay, RecordPlayer> entry : this.actors.entrySet())
        {
            Replay replay = entry.getKey();

            if (tick == 0)
            {
                replay.apply(entry.getValue().actor);
            }

            entry.getValue().goTo(tick, actions);
        }

        this.audioHandler.goTo(tick);
    }

    /**
     * Reload actors
     */
    public void reload(int tick)
    {
        this.stopPlayback(true);
        this.spawn(tick);
    }

    /**
     * Duplicate
     */
    public boolean dupe(int index)
    {
        if (index < 0 || index >= this.replays.size())
        {
            return false;
        }

        Replay replay = this.replays.get(index).copy();

        replay.id = this.getNextSuffix(replay.id);
        this.replays.add(replay);

        return true;
    }

    /**
     * Return next base suffix, this fixes issue with getNextSuffix() when the
     * scene's name is "tia_6", and it returns "tia_1" instead of "tia_6_1"
     */
    public String getNextBaseSuffix(String filename)
    {
        if (filename.isEmpty())
        {
            return filename;
        }

        return this.getNextSuffix(filename + "_0");
    }

    public String getNextSuffix(String filename)
    {
        if (filename.isEmpty())
        {
            return filename;
        }

        Matcher matcher = NUMBERED_SUFFIX.matcher(filename);

        String prefix = filename;
        boolean found = matcher.find();
        int max = 0;

        if (found)
        {
            prefix = filename.substring(0, matcher.start());
        }

        for (Replay other : this.replays)
        {
            if (other.id.startsWith(prefix))
            {
                matcher = NUMBERED_SUFFIX.matcher(other.id);

                if (matcher.find() && other.id.substring(0, matcher.start()).equals(prefix))
                {
                    max = Math.max(max, Integer.parseInt(matcher.group(1)));
                }
            }
        }

        return prefix + "_" + (max + 1);
    }

    public void setupIds()
    {
        for (Replay replay : this.replays)
        {
            if (replay.id.isEmpty())
            {
                replay.id = this.getNextBaseSuffix(this.getId());
            }
        }
    }

    public void renamePrefix(String newPrefix)
    {
        this.renamePrefix(null, newPrefix, null);
    }

    public void renamePrefix(@Nullable String oldPrefix, String newPrefix, Function<String, String> process)
    {
        //default format <scene name>_<id>
        for (Replay replay : this.replays)
        {
            Matcher matcher = PREFIX.matcher(replay.id);

            /* test whether <scene name> is at the beginning
            *  and whether there are multiple indexes*/
            if (oldPrefix != null && replay.id.startsWith(oldPrefix+"_"))
            {
                String indexes = replay.id.substring(oldPrefix.length()+1); //length+1 to exclude "_"
                Matcher matcherIndexes = INDEXES.matcher(indexes);

                int counter = 0;

                while (matcherIndexes.find())
                {
                    counter++;
                }

                /* there are mutliple indexes seperated by _ */
                if (counter > 1)
                {
                    replay.id = newPrefix + "_" + indexes;

                    continue;
                }
            }

            if (matcher.find())
            {
                replay.id = newPrefix + "_" + matcher.group(2);
            }
            else if (process != null)
            {
                replay.id = process.apply(replay.id);
            }
        }
    }

    /**
     * Send a command
     */
    public void sendCommand(String command)
    {
        if (this.sender != null && !command.isEmpty())
        {
            this.getWorld().getMinecraftServer().commandManager.executeCommand(this.sender, command);
        }
    }

    /**
     * Log first actor's ticks (for debug purposes)
     */
    public void logTicks()
    {
        if (this.actors.isEmpty())
        {
            return;
        }

        RecordPlayer actor = this.actors.values().iterator().next();

        if (actor != null)
        {
            Blockbuster.LOGGER.info("Director tick: " + actor.getTick());
        }
    }

    /**
     * Sends the audio state to the player.
     * @param player
     */
    public void syncAudio(EntityPlayerMP player) {
        this.audioHandler.syncPlayer(player);
    }

    public void copy(Scene scene)
    {
        /* There is no need to copy itself, copying itself will lead to
         * lost of replay data as it clears its replays and then will have
         * nothing to copy over... */
        if (this == scene)
        {
            return;
        }

        this.replays.clear();

        scene.replays.forEach((element) ->
        {
            this.replays.add(element.copy());
        });

        this.loops = scene.loops;
        this.title = scene.title;
        this.startCommand = scene.startCommand;
        this.stopCommand = scene.stopCommand;

        this.audioHandler.copy(scene.audioHandler);
    }

    /* NBT methods */

    public void fromNBT(NBTTagCompound compound)
    {
        this.replays.clear();

        NBTTagList tagList = compound.getTagList("Actors", 10);

        for (int i = 0; i < tagList.tagCount(); i++)
        {
            Replay replay = new Replay();

            replay.fromNBT(tagList.getCompoundTagAt(i));
            this.replays.add(replay);
        }

        this.loops = compound.getBoolean("Loops");
        this.title = compound.getString("Title");
        this.startCommand = compound.getString("StartCommand");
        this.stopCommand = compound.getString("StopCommand");

        this.audioHandler.fromNBT(compound);
    }

    public void toNBT(NBTTagCompound compound)
    {
        NBTTagList tagList = new NBTTagList();

        for (int i = 0; i < this.replays.size(); i++)
        {
            NBTTagCompound tag = new NBTTagCompound();

            this.replays.get(i).toNBT(tag);
            tagList.appendTag(tag);
        }

        compound.setTag("Actors", tagList);
        compound.setBoolean("Loops", this.loops);
        compound.setString("Title", this.title);
        compound.setString("StartCommand", this.startCommand);
        compound.setString("StopCommand", this.stopCommand);

        this.audioHandler.toNBT(compound);
    }

    /* ByteBuf methods */

    public void fromBuf(ByteBuf buffer)
    {
        this.id = ByteBufUtils.readUTF8String(buffer);
        this.replays.clear();

        for (int i = 0, c = buffer.readInt(); i < c; i++)
        {
            Replay replay = new Replay();

            this.replays.add(replay);
            replay.fromBuf(buffer);
        }

        this.loops = buffer.readBoolean();
        this.title = ByteBufUtils.readUTF8String(buffer);
        this.startCommand = ByteBufUtils.readUTF8String(buffer);
        this.stopCommand = ByteBufUtils.readUTF8String(buffer);

        this.audioHandler.fromBytes(buffer);
    }

    public void toBuf(ByteBuf buffer)
    {
        ByteBufUtils.writeUTF8String(buffer, this.id);
        buffer.writeInt(this.replays.size());

        for (Replay replay : this.replays)
        {
            replay.toBuf(buffer);
        }

        buffer.writeBoolean(this.loops);
        ByteBufUtils.writeUTF8String(buffer, this.title);
        ByteBufUtils.writeUTF8String(buffer, this.startCommand);
        ByteBufUtils.writeUTF8String(buffer, this.stopCommand);

        this.audioHandler.toBytes(buffer);
    }

    /**
     * Class that stores an {@link EntityPlayer} and it's states like inventory etc.
     * This is used for scene first person playback, to reset those players to their
     * original state at the end of playback.
     */
    public class PlayerState
    {
        private EntityPlayer player;
        private NonNullList<ItemStack> mainInventory;
        private int experienceLevel;
        /**
         * The total amount of experience the player has. This also includes the amount of experience within their
         * Experience Bar.
         */
        private int experienceTotal;
        /** The current amount of experience the player has within their Experience Bar. */
        private float experience;
        private int foodLevel;

        public PlayerState(EntityPlayer player)
        {
            this.player = player;

            /* data structure used for mainInventory List in InventoryPlayer class */
            this.mainInventory = NonNullList.<ItemStack>withSize(36, ItemStack.EMPTY);

            for (int i = 0; i < this.mainInventory.size(); i++)
            {
                this.mainInventory.set(i, player.inventory.mainInventory.get(i).copy());
            }

            this.experience = player.experience;
            this.experienceLevel = player.experienceLevel;
            this.experienceTotal = player.experienceTotal;
            this.foodLevel = player.getFoodStats().getFoodLevel();
        }

        public EntityPlayer getPlayer()
        {
            return this.player;
        }

        /**
         * Resets the player's attributes stored by this state
         */
        public void resetPlayerState()
        {
            for (int i = 0; i < this.player.inventory.mainInventory.size(); i++)
            {
                this.player.inventory.mainInventory.set(i, this.mainInventory.get(i).copy());
            }

            this.player.experience = this.experience;
            this.player.experienceLevel = this.experienceLevel;
            this.player.experienceTotal = this.experienceTotal;
            this.player.getFoodStats().setFoodLevel(this.foodLevel);
        }
    }
}


==================================================

--- Файл №474 ---
Путь: main\java\mchorse\blockbuster\recording\scene\SceneLocation.java
--------------------
package mchorse.blockbuster.recording.scene;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import java.util.Objects;

/**
 * Scene location data class
 *
 * This bad boy allows to unify director blocks and scene identifier into one structure
 */
public class SceneLocation
{
    private Scene scene;
    private String filename;

    public SceneLocation()
    {}

    public SceneLocation(Scene scene)
    {
        this.scene = scene;
        this.filename = scene.getId();
    }

    public SceneLocation(String filename)
    {
        this.filename = filename;
    }

    public Scene getScene()
    {
        return this.scene;
    }

    public String getFilename()
    {
        return this.filename;
    }

    public int getType()
    {
        return this.isEmpty() ? 0 : 1;
    }

    public boolean isEmpty()
    {
        return !this.isScene();
    }

    public boolean isScene()
    {
        return this.filename != null && !this.filename.isEmpty();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof SceneLocation)
        {
            SceneLocation location = (SceneLocation) obj;

            if (this.getType() == location.getType())
            {
                return Objects.equals(this.filename, location.filename);
            }
        }

        return super.equals(obj);
    }

    public SceneLocation copyEmpty()
    {
        if (this.isScene())
        {
            return new SceneLocation(this.getFilename());
        }

        return new SceneLocation();
    }

    public void fromByteBuf(ByteBuf buf)
    {
        this.filename = null;

        if (buf.readBoolean())
        {
            this.filename = ByteBufUtils.readUTF8String(buf);
        }

        if (buf.readBoolean())
        {
            this.scene = this.isScene() ? new Scene() : null;

            if (this.scene != null)
            {
                this.scene.fromBuf(buf);
            }
        }
    }

    public void toByteBuf(ByteBuf buf)
    {
        buf.writeBoolean(this.filename != null);

        if (this.filename != null)
        {
            ByteBufUtils.writeUTF8String(buf, this.filename);
        }

        buf.writeBoolean(this.scene != null);

        if (this.scene != null)
        {
            this.scene.toBuf(buf);
        }
    }
}

==================================================

--- Файл №475 ---
Путь: main\java\mchorse\blockbuster\recording\scene\SceneManager.java
--------------------
package mchorse.blockbuster.recording.scene;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.CommonProxy;
import mchorse.blockbuster.recording.Utils;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.mclib.utils.Patterns;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.nbt.CompressedStreamTools;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.world.World;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.regex.Pattern;

/**
 * Scene manager
 *
 * This bro allows to manage scenes (those are something like remote director blocks).
 */
public class SceneManager
{
    /**
     * Currently loaded scenes
     */
    private Map<String, Scene> scenes = new ConcurrentHashMap<String, Scene>();

    private List<String> toRemove = new ArrayList<String>();
    private Map<String, Scene> toPut = new HashMap<String, Scene>();
    private boolean ticking;

    public Map<String, Scene> getScenes()
    {
        return new HashMap<>(this.scenes);
    }

    public static boolean isValidFilename(String filename)
    {
        return !filename.isEmpty() && Patterns.FILENAME.matcher(filename).matches();
    }

    /**
     * Reset scene manager
     */
    public void reset()
    {
        this.ticking = false;
        this.toRemove.clear();
        this.toPut.clear();

        this.scenes.clear();
    }

    /**
     * Spawn actors and execute unsafe actions
     */
    public void worldTick(World world)
    {
        for (Map.Entry<String, Scene> entry : this.scenes.entrySet())
        {
            Scene scene = entry.getValue();

            scene.worldTick(world);
        }
    }

    /**
     * Tick scenes
     */
    public void tick()
    {
        this.ticking = true;

        try
        {
            for (Map.Entry<String, Scene> entry : this.scenes.entrySet())
            {
                Scene scene = entry.getValue();

                scene.tick();

                if (!scene.playing)
                {
                    this.toRemove.add(entry.getKey());
                }
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        this.ticking = false;

        for (String scene : this.toRemove)
        {
            this.scenes.remove(scene);
        }

        this.scenes.putAll(this.toPut);

        this.toRemove.clear();
        this.toPut.clear();
    }

    /**
     * Play a scene
     */
    public boolean play(String filename, World world)
    {
        Scene scene = this.get(filename,world);

        if (scene == null)
        {
            return false;
        }

        scene.startPlayback(0);

        return true;
    }

    public void record(String filename, String record, EntityPlayerMP player)
    {
        this.record(filename, record, 0, player);
    }

    /**
     * Record the player
     */
    public void record(String filename, String record, int offset, EntityPlayerMP player)
    {
        final Scene scene = this.get(filename, player.world);

        if (scene != null)
        {
            scene.setWorld(player.world);

            final Replay replay = scene.getByFile(record);

            if (replay != null)
            {
                CommonProxy.manager.record(replay.id, player, Mode.ACTIONS, replay.teleportBack, true, offset, () ->
                {
                    if (!CommonProxy.manager.recorders.containsKey(player))
                    {
                        this.put(filename, scene);
                        scene.startPlayback(record, offset);
                    }
                    else
                    {
                        scene.stopPlayback(true);
                    }

                    replay.apply(player);
                });
            }
        }
    }

    /**
     * Toggle playback of a scene by given filename
     */
    public boolean toggle(String filename, World world)
    {
        Scene scene = this.scenes.get(filename);

        if (scene != null)
        {
            scene.stopPlayback(true);

            return false;
        }

        return this.play(filename, world);
    }

    /**
     * Get currently running or load a scene
     */
    public Scene get(String filename, World world)
    {
        Scene scene = this.scenes.get(filename);

        if (scene != null)
        {
            return scene;
        }

        try
        {
            scene = this.load(filename);

            if (scene != null)
            {
                scene.setWorld(world);
                scene.setSender(new SceneSender(scene));
                this.put(filename, scene);
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return scene;
    }

    /**
     * Load a scene by given filename
     */
    public Scene load(String filename) throws IOException
    {
        File file = sceneFile(filename);

        if (!file.isFile())
        {
            return null;
        }

        NBTTagCompound compound = CompressedStreamTools.readCompressed(new FileInputStream(file));
        Scene scene = new Scene();

        scene.setId(filename);
        scene.fromNBT(compound);

        return scene;
    }

    public void save(String filename, Scene scene) throws IOException
    {
        this.save(filename, scene, Blockbuster.sceneSaveUpdate.get());
    }

    /**
     * Save a scene by given filename
     */
    public void save(String filename, Scene scene, boolean reload) throws IOException
    {
        Scene present = this.scenes.get(scene.getId());

        if (reload && present != null)
        {
            present.copy(scene);
            present.reload(present.getCurrentTick());
        }

        File file = sceneFile(filename);
        NBTTagCompound compound = new NBTTagCompound();

        scene.toNBT(compound);

        CompressedStreamTools.writeCompressed(compound, new FileOutputStream(file));
    }

    /**
     * Rename a scene on the disk
     */
    public boolean rename(String from, String to)
    {
        File fromFile = sceneFile(from);
        File toFile = sceneFile(to);

        if (fromFile.isFile() && !toFile.exists())
        {
            return fromFile.renameTo(toFile);
        }

        return false;
    }

    /**
     * Remove a scene from the disk
     */
    public boolean remove(String filename)
    {
        File file = sceneFile(filename);

        if (file.exists())
        {
            return file.delete();
        }

        return false;
    }

    /**
     * Returns a file instance to the scene by given filename
     */
    private File sceneFile(String filename)
    {
        return Utils.serverFile("blockbuster/scenes", filename);
    }

    private void put(String filename, Scene scene)
    {
        (this.ticking ? this.toPut : this.scenes).put(filename, scene);
    }

    /**
     * Get all the NBT files in the scenes folder
     */
    public List<String> sceneFiles()
    {
        return Utils.serverFiles("blockbuster/scenes");
    }
}

==================================================

--- Файл №476 ---
Путь: main\java\mchorse\blockbuster\recording\scene\SceneSender.java
--------------------
package mchorse.blockbuster.recording.scene;

import net.minecraft.command.CommandResultStats;
import net.minecraft.command.ICommandSender;
import net.minecraft.entity.Entity;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.world.World;

public class SceneSender implements ICommandSender
{
    public Scene scene;

    public SceneSender(Scene scene)
    {
        this.scene = scene;
    }

    @Override
    public String getName() {
        return "SceneSender(" + this.scene.getId() + ")";
    }

    @Override
    public ITextComponent getDisplayName() {
        return new TextComponentString(this.getName());
    }

    @Override
    public void sendMessage(ITextComponent component)
    {}

    @Override
    public boolean canUseCommand(int permLevel, String commandName)
    {
        return true;
    }

    @Override
    public BlockPos getPosition()
    {
        return BlockPos.ORIGIN;
    }

    @Override
    public Vec3d getPositionVector()
    {
        return new Vec3d(this.getPosition());
    }

    @Override
    public World getEntityWorld()
    {
        return this.scene.getWorld();
    }

    @Override
    public Entity getCommandSenderEntity()
    {
        return null;
    }

    @Override
    public boolean sendCommandFeedback()
    {
        return false;
    }

    @Override
    public void setCommandStat(CommandResultStats.Type type, int amount)
    {}

    @Override
    public MinecraftServer getServer()
    {
        return this.scene.getWorld().getMinecraftServer();
    }
}

==================================================

--- Файл №477 ---
Путь: main\java\mchorse\blockbuster\recording\scene\fake\FakeChannel.java
--------------------
package mchorse.blockbuster.recording.scene.fake;

import java.net.SocketAddress;

import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelId;
import io.netty.channel.ChannelMetadata;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelProgressivePromise;
import io.netty.channel.ChannelPromise;
import io.netty.channel.EventLoop;
import io.netty.util.Attribute;
import io.netty.util.AttributeKey;
import net.minecraft.network.NetworkManager;
import net.minecraftforge.fml.common.network.handshake.NetworkDispatcher;
import net.minecraftforge.fml.common.network.NetworkRegistry;

public class FakeChannel implements Channel{
    
    private class FalseBool implements Attribute<Boolean>{
        public AttributeKey<Boolean> key() {return null;}
        public Boolean get() {return Boolean.valueOf(false);}
        public void set(Boolean value) {}
        public Boolean getAndSet(Boolean value) {return Boolean.valueOf(false);}
        public Boolean setIfAbsent(Boolean value) {return Boolean.valueOf(false);}
        public Boolean getAndRemove() {return Boolean.valueOf(false);}
        public boolean compareAndSet(Boolean oldValue, Boolean newValue) {return false;}
        public void remove(){}
    }
    
    @Override
    public <T> Attribute<T> attr(AttributeKey<T> key)
    {
        if (key == NetworkDispatcher.FML_DISPATCHER)
        {
            return (Attribute<T>) new FakeFMLAttribute();
        }

        if (key == NetworkManager.PROTOCOL_ATTRIBUTE_KEY)
        {
            return (Attribute<T>) new FakeProtocol();
        }
        
        if (key == NetworkRegistry.FML_MARKER) {
            return (Attribute<T>) new FalseBool();
        }
        
        return null;
    }

    @Override
    public int compareTo(Channel o)
    {
        return 0;
    }

    @Override
    public EventLoop eventLoop()
    {
        return null;
    }

    @Override
    public Channel parent()
    {
        return null;
    }

    @Override
    public ChannelConfig config()
    {
        return new FakeConfig();
    }

    @Override
    public boolean isOpen()
    {
        return false;
    }

    @Override
    public boolean isRegistered()
    {
        return false;
    }

    @Override
    public boolean isActive()
    {
        return false;
    }

    @Override
    public ChannelMetadata metadata()
    {
        return null;
    }

    @Override
    public SocketAddress localAddress()
    {
        return null;
    }

    @Override
    public SocketAddress remoteAddress()
    {
        return null;
    }

    @Override
    public ChannelFuture closeFuture()
    {
        return null;
    }

    @Override
    public boolean isWritable()
    {
        return false;
    }

    @Override
    public Unsafe unsafe()
    {
        return null;
    }

    @Override
    public ChannelPipeline pipeline()
    {
        return null;
    }

    @Override
    public ByteBufAllocator alloc()
    {
        return null;
    }

    @Override
    public ChannelPromise newPromise()
    {
        return null;
    }

    @Override
    public ChannelProgressivePromise newProgressivePromise()
    {
        return null;
    }

    @Override
    public ChannelFuture newSucceededFuture()
    {
        return null;
    }

    @Override
    public ChannelFuture newFailedFuture(Throwable cause)
    {
        return null;
    }

    @Override
    public ChannelPromise voidPromise()
    {
        return null;
    }

    @Override
    public ChannelFuture bind(SocketAddress localAddress)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)
    {
        return null;
    }

    @Override
    public ChannelFuture disconnect()
    {
        return null;
    }

    @Override
    public ChannelFuture close()
    {
        return null;
    }

    @Override
    public ChannelFuture deregister()
    {
        return null;
    }

    @Override
    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture disconnect(ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture close(ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture deregister(ChannelPromise promise)
    {
        return null;
    }

    @Override
    public Channel read()
    {
        return null;
    }

    @Override
    public ChannelFuture write(Object msg)
    {
        return null;
    }

    @Override
    public ChannelFuture write(Object msg, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public Channel flush()
    {
        return null;
    }

    @Override
    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture writeAndFlush(Object msg)
    {
        return null;
    }

    @Override
    public <T> boolean hasAttr(AttributeKey<T> key)
    {
        return false;
    }

    @Override
    public ChannelId id()
    {
        return null;
    }

    @Override
    public long bytesBeforeUnwritable()
    {
        return 0;
    }

    @Override
    public long bytesBeforeWritable()
    {
        return 0;
    }
}


==================================================

--- Файл №478 ---
Путь: main\java\mchorse\blockbuster\recording\scene\fake\FakeConfig.java
--------------------
package mchorse.blockbuster.recording.scene.fake;

import java.util.Map;

import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.ChannelConfig;
import io.netty.channel.ChannelOption;
import io.netty.channel.MessageSizeEstimator;
import io.netty.channel.RecvByteBufAllocator;
import io.netty.channel.WriteBufferWaterMark;

public class FakeConfig implements ChannelConfig
{
    @Override
    public Map<ChannelOption<?>, Object> getOptions()
    {
        return null;
    }

    @Override
    public boolean setOptions(Map<ChannelOption<?>, ?> options)
    {
        return false;
    }

    @Override
    public <T> T getOption(ChannelOption<T> option)
    {
        return null;
    }

    @Override
    public <T> boolean setOption(ChannelOption<T> option, T value)
    {
        return false;
    }

    @Override
    public int getConnectTimeoutMillis()
    {
        return 0;
    }

    @Override
    public ChannelConfig setConnectTimeoutMillis(int connectTimeoutMillis)
    {
        return null;
    }

    @Override
    public int getMaxMessagesPerRead()
    {
        return 0;
    }

    @Override
    public ChannelConfig setMaxMessagesPerRead(int maxMessagesPerRead)
    {
        return null;
    }

    @Override
    public int getWriteSpinCount()
    {
        return 0;
    }

    @Override
    public ChannelConfig setWriteSpinCount(int writeSpinCount)
    {
        return null;
    }

    @Override
    public ByteBufAllocator getAllocator()
    {
        return null;
    }

    @Override
    public ChannelConfig setAllocator(ByteBufAllocator allocator)
    {
        return null;
    }

    @Override
    public RecvByteBufAllocator getRecvByteBufAllocator()
    {
        return null;
    }

    @Override
    public ChannelConfig setRecvByteBufAllocator(RecvByteBufAllocator allocator)
    {
        return null;
    }

    @Override
    public boolean isAutoRead()
    {
        return false;
    }

    @Override
    public ChannelConfig setAutoRead(boolean autoRead)
    {
        return null;
    }

    @Override
    public boolean isAutoClose()
    {
        return false;
    }

    @Override
    public ChannelConfig setAutoClose(boolean autoClose)
    {
        return null;
    }

    @Override
    public int getWriteBufferHighWaterMark()
    {
        return 0;
    }

    @Override
    public ChannelConfig setWriteBufferHighWaterMark(int writeBufferHighWaterMark)
    {
        return null;
    }

    @Override
    public int getWriteBufferLowWaterMark()
    {
        return 0;
    }

    @Override
    public ChannelConfig setWriteBufferLowWaterMark(int writeBufferLowWaterMark)
    {
        return null;
    }

    @Override
    public MessageSizeEstimator getMessageSizeEstimator()
    {
        return null;
    }

    @Override
    public ChannelConfig setMessageSizeEstimator(MessageSizeEstimator estimator)
    {
        return null;
    }

    @Override
    public WriteBufferWaterMark getWriteBufferWaterMark()
    {
        return null;
    }

    @Override
    public ChannelConfig setWriteBufferWaterMark(WriteBufferWaterMark writeBufferWaterMark)
    {
        return null;
    }
}

==================================================

--- Файл №479 ---
Путь: main\java\mchorse\blockbuster\recording\scene\fake\FakeContext.java
--------------------
package mchorse.blockbuster.recording.scene.fake;

import java.net.SocketAddress;

import io.netty.buffer.ByteBufAllocator;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.ChannelProgressivePromise;
import io.netty.channel.ChannelPromise;
import io.netty.util.Attribute;
import io.netty.util.AttributeKey;
import io.netty.util.concurrent.EventExecutor;

public class FakeContext implements ChannelHandlerContext
{
    public Channel channel = new FakeChannel();

    @Override
    public <T> Attribute<T> attr(AttributeKey<T> key)
    {
        return null;
    }

    @Override
    public Channel channel()
    {
        return new FakeChannel();
    }

    @Override
    public EventExecutor executor()
    {
        return null;
    }

    @Override
    public String name()
    {
        return null;
    }

    @Override
    public ChannelHandler handler()
    {
        return null;
    }

    @Override
    public boolean isRemoved()
    {
        return false;
    }

    @Override
    public ChannelHandlerContext fireChannelRegistered()
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireChannelUnregistered()
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireChannelActive()
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireChannelInactive()
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireExceptionCaught(Throwable cause)
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireUserEventTriggered(Object event)
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireChannelRead(Object msg)
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireChannelReadComplete()
    {
        return null;
    }

    @Override
    public ChannelHandlerContext fireChannelWritabilityChanged()
    {
        return null;
    }

    @Override
    public ChannelFuture bind(SocketAddress localAddress)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)
    {
        return null;
    }

    @Override
    public ChannelFuture disconnect()
    {
        return null;
    }

    @Override
    public ChannelFuture close()
    {
        return null;
    }

    @Override
    public ChannelFuture deregister()
    {
        return null;
    }

    @Override
    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture disconnect(ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture close(ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture deregister(ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelHandlerContext read()
    {
        return null;
    }

    @Override
    public ChannelFuture write(Object msg)
    {
        return null;
    }

    @Override
    public ChannelFuture write(Object msg, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelHandlerContext flush()
    {
        return null;
    }

    @Override
    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)
    {
        return null;
    }

    @Override
    public ChannelFuture writeAndFlush(Object msg)
    {
        return null;
    }

    @Override
    public ChannelPipeline pipeline()
    {
        return null;
    }

    @Override
    public ByteBufAllocator alloc()
    {
        return null;
    }

    @Override
    public ChannelPromise newPromise()
    {
        return null;
    }

    @Override
    public ChannelProgressivePromise newProgressivePromise()
    {
        return null;
    }

    @Override
    public ChannelFuture newSucceededFuture()
    {
        return null;
    }

    @Override
    public ChannelFuture newFailedFuture(Throwable cause)
    {
        return null;
    }

    @Override
    public ChannelPromise voidPromise()
    {
        return null;
    }

    @Override
    public <T> boolean hasAttr(AttributeKey<T> key)
    {
        return false;
    }
}

==================================================

--- Файл №480 ---
Путь: main\java\mchorse\blockbuster\recording\scene\fake\FakeFMLAttribute.java
--------------------
package mchorse.blockbuster.recording.scene.fake;

import io.netty.util.Attribute;
import io.netty.util.AttributeKey;
import net.minecraftforge.fml.common.network.handshake.NetworkDispatcher;

public class FakeFMLAttribute implements Attribute<NetworkDispatcher>
{
    @Override
    public AttributeKey<NetworkDispatcher> key()
    {
        return null;
    }

    @Override
    public NetworkDispatcher get()
    {
        return null;
    }

    @Override
    public void set(NetworkDispatcher value)
    {}

    @Override
    public NetworkDispatcher getAndSet(NetworkDispatcher value)
    {
        return null;
    }

    @Override
    public NetworkDispatcher setIfAbsent(NetworkDispatcher value)
    {
        return null;
    }

    @Override
    public NetworkDispatcher getAndRemove()
    {
        return null;
    }

    @Override
    public boolean compareAndSet(NetworkDispatcher oldValue, NetworkDispatcher newValue)
    {
        return false;
    }

    @Override
    public void remove()
    {}
}

==================================================

--- Файл №481 ---
Путь: main\java\mchorse\blockbuster\recording\scene\fake\FakeProtocol.java
--------------------
package mchorse.blockbuster.recording.scene.fake;

import io.netty.util.Attribute;
import io.netty.util.AttributeKey;
import net.minecraft.network.EnumConnectionState;

public class FakeProtocol implements Attribute<EnumConnectionState>
{
    @Override
    public AttributeKey<EnumConnectionState> key()
    {
        return null;
    }

    @Override
    public EnumConnectionState get()
    {
        return null;
    }

    @Override
    public void set(EnumConnectionState value)
    {}

    @Override
    public EnumConnectionState getAndSet(EnumConnectionState value)
    {
        return null;
    }

    @Override
    public EnumConnectionState setIfAbsent(EnumConnectionState value)
    {
        return null;
    }

    @Override
    public EnumConnectionState getAndRemove()
    {
        return null;
    }

    @Override
    public boolean compareAndSet(EnumConnectionState oldValue, EnumConnectionState newValue)
    {
        return false;
    }

    @Override
    public void remove()
    {}
}

==================================================

--- Файл №482 ---
Путь: main\java\mchorse\blockbuster\utils\EntityTransformationUtils.java
--------------------
package mchorse.blockbuster.utils;

import net.minecraft.entity.Entity;

/**
 * This is a utils class to avoid reflection to get asm injected variables of entity class.
 */

public class EntityTransformationUtils
{
    /* LEAVE THE RETURN TYPES 0 or the core asm transformation will fail!*/

    public static double getPrevPrevPosX(Entity entity)
    {
        return 0;
    }

    public static double getPrevPrevPosY(Entity entity)
    {
        return 0;
    }

    public static double getPrevPrevPosZ(Entity entity)
    {
        return 0;
    }
}


==================================================

--- Файл №483 ---
Путь: main\java\mchorse\blockbuster\utils\EntityUtils.java
--------------------
package mchorse.blockbuster.utils;

import mchorse.blockbuster.aperture.CameraHandler;
import mchorse.blockbuster.capabilities.recording.IRecording;
import mchorse.blockbuster.capabilities.recording.Recording;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.world.World;

import java.util.UUID;

/**
 * Entity utilities
 *
 * Has some methods that relates to Minecraft entities.
 */
public class EntityUtils
{
    /**
     * Send status message. It's like chat, but it will be displayed 
     * over the hotbar and won't clutter the chat 
     */
    public static void sendStatusMessage(EntityPlayerMP player, ITextComponent message)
    {
        player.sendStatusMessage(message, true);
    }

    /**
     * Get string pose key for entity state.
     */
    public static String poseForEntity(EntityLivingBase entity)
    {
        if (entity.isRiding())
        {
            return "riding";
        }

        if (entity.isElytraFlying())
        {
            return "flying";
        }

        if (entity.isSneaking())
        {
            return "sneaking";
        }

        return "standing";
    }

    /**
     * Get record player 
     */
    public static RecordPlayer getRecordPlayer(EntityLivingBase entity)
    {
        if (entity instanceof EntityActor)
        {
            return ((EntityActor) entity).playback;
        }
        else if (entity instanceof EntityPlayer)
        {
            IRecording record = Recording.get((EntityPlayer) entity);

            return record.getRecordPlayer();
        }

        return null;
    }

    /**
     * Set record player 
     */
    public static void setRecordPlayer(EntityLivingBase entity, RecordPlayer playback)
    {
        if (entity instanceof EntityActor)
        {
            ((EntityActor) entity).playback = playback;
        }
        else if (entity instanceof EntityPlayer)
        {
            IRecording record = Recording.get((EntityPlayer) entity);

            record.setRecordPlayer(playback);
        }
    }

    /**
     * Simple method that decreases the need for writing additional
     * UUID.fromString line
     */
    public static Entity entityByUUID(World world, String id)
    {
        return entityByUUID(world, UUID.fromString(id));
    }

    /**
     * Get entity by UUID in the server world.
     *
     * Looked up on minecraft forge forum, I don't remember where's exactly...
     */
    public static Entity entityByUUID(World world, UUID target)
    {
        for (Entity entity : world.loadedEntityList)
        {
            if (entity.getUniqueID().equals(target))
            {
                return entity;
            }
        }

        return null;
    }

    public static float getRoll(Entity entity, float partialTicks)
    {
        if (entity instanceof EntityActor)
        {
            EntityActor actor = (EntityActor) entity;

            return Interpolations.lerp(actor.prevRoll, actor.roll, partialTicks);
        }
        else if (entity == Minecraft.getMinecraft().player)
        {
            return CameraHandler.getRoll(partialTicks);
        }

        return 0;
    }
}

==================================================

--- Файл №484 ---
Путь: main\java\mchorse\blockbuster\utils\ExpirableRunnable.java
--------------------
package mchorse.blockbuster.utils;

import mchorse.blockbuster.events.TickHandler;
import net.minecraft.world.World;

public class ExpirableRunnable implements TickHandler.IRunnable
{
    private boolean isDead;
    private int age;
    private int lifetime;

    public ExpirableRunnable(int lifetime)
    {
        this.lifetime = lifetime;
    }

    public void setLifetime(int lifetime)
    {
        this.lifetime = lifetime;
    }

    public int getLifetime()
    {
        return this.lifetime;
    }

    public int getAge()
    {
        return this.age;
    }

    @Override
    public void run()
    {
        if (this.age >= this.lifetime)
        {
            this.isDead = true;
        }

        this.age++;
    }

    @Override
    public boolean shouldRemove()
    {
        return this.isDead;
    }
}


==================================================

--- Файл №485 ---
Путь: main\java\mchorse\blockbuster\utils\NBTUtils.java
--------------------
package mchorse.blockbuster.utils;

import mchorse.blockbuster.common.GunProps;
import mchorse.blockbuster.common.item.ItemGun;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.BlockPos;

/**
 * NBT utilities
 *
 * This class provides different method for working with NBT
 */
public class NBTUtils
{
    public static boolean saveGunProps(ItemStack stack, NBTTagCompound tag)
    {
        if (!(stack.getItem() instanceof ItemGun))
        {
            return false;
        }

        if (!stack.hasTagCompound())
        {
            stack.setTagCompound(new NBTTagCompound());
        }

        if (stack.hasTagCompound())
        {
            stack.getTagCompound().setTag("Gun", tag);

            return true;
        }

        return false;
    }

    public static GunProps getGunProps(ItemStack stack)
    {
        if (!(stack.getItem() instanceof ItemGun))
        {
            return null;
        }

        if (stack.hasTagCompound())
        {
            NBTTagCompound tag = stack.getTagCompound();

            if (tag.hasKey("Gun"))
            {
                return new GunProps(tag.getCompoundTag("Gun"));
            }
        }

        return new GunProps();
    }

    /* BlockPos */

    /**
     * Save given {@link BlockPos} into {@link NBTTagCompound} tag
     */
    public static void saveBlockPos(String key, NBTTagCompound tag, BlockPos pos)
    {
        tag.setInteger(key + "X", pos.getX());
        tag.setInteger(key + "Y", pos.getY());
        tag.setInteger(key + "Z", pos.getZ());
    }

    /**
     * Get {@link BlockPos} position from {@link NBTTagCompound} tag
     */
    public static BlockPos getBlockPos(String key, NBTTagCompound tag)
    {
        String x = key + "X";
        String y = key + "Y";
        String z = key + "Z";

        if (tag == null || !tag.hasKey(x) || !tag.hasKey(y) || !tag.hasKey(z))
        {
            return null;
        }

        return new BlockPos(tag.getInteger(x), tag.getInteger(y), tag.getInteger(z));
    }
}

==================================================

--- Файл №486 ---
Путь: main\java\mchorse\blockbuster\utils\ResourcePackUtils.java
--------------------
package mchorse.blockbuster.utils;

import mchorse.blockbuster.Blockbuster;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.resources.AbstractResourcePack;
import net.minecraft.client.resources.FileResourcePack;
import net.minecraft.client.resources.FolderResourcePack;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.client.resources.IResourcePack;
import net.minecraft.client.resources.LegacyV2Adapter;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.client.FMLClientHandler;
import net.minecraftforge.fml.client.FMLFolderResourcePack;

import java.io.File;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.Set;
import java.util.function.Predicate;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class ResourcePackUtils
{
    public static List<ResourceLocation> getAllPictures(IResourceManager resourceManager)
    {
        List<IResourcePack> packs = getPacks();

        if (packs == null)
        {
            return Collections.emptyList();
        }

        List<ResourceLocation> locations = new ArrayList<ResourceLocation>();

        for (IResourcePack pack : packs)
        {
            if (!pack.getResourceDomains().contains(Blockbuster.MOD_ID))
            {
                continue;
            }

            locations.addAll(getLocations(pack, "", fileName -> fileName.endsWith(".png")));

            break;
        }

        return locations;
    }

    private static List<IResourcePack> getPacks()
    {
        try
        {
            Field field = FMLClientHandler.class.getDeclaredField("resourcePackList");
            field.setAccessible(true);

            return (List<IResourcePack>) field.get(FMLClientHandler.instance());
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    private static List<ResourceLocation> getLocations(IResourcePack pack, String folder, Predicate<String> predicate)
    {
        if (pack instanceof LegacyV2Adapter)
        {
            LegacyV2Adapter adapter = (LegacyV2Adapter) pack;
            Field packField = null;

            for (Field field : adapter.getClass().getDeclaredFields())
            {
                if (field.getType() == IResourcePack.class)
                {
                    packField = field;

                    break;
                }
            }

            if (packField != null)
            {
                packField.setAccessible(true);

                try
                {
                    return getLocations((IResourcePack) packField.get(adapter), folder, predicate);
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }

        List<ResourceLocation> locations = new ArrayList<ResourceLocation>();

        if (pack instanceof FolderResourcePack)
        {
            handleFolderResourcePack((FolderResourcePack) pack, folder, predicate, locations);
        }
        else if (pack instanceof FileResourcePack)
        {
            handleZipResourcePack((FileResourcePack) pack, folder, predicate, locations);
        }

        return locations;
    }

    /* Folder handling */

    private static void handleFolderResourcePack(FolderResourcePack folderPack, String folder, Predicate<String> predicate, List<ResourceLocation> locations)
    {
        Field fileField = null;

        for (Field field : AbstractResourcePack.class.getDeclaredFields())
        {
            if (field.getType() == File.class)
            {
                fileField = field;

                break;
            }
        }

        if (fileField != null)
        {
            fileField.setAccessible(true);

            try
            {
                File file = (File) fileField.get(folderPack);
                Set<String> domains = folderPack.getResourceDomains();

                if (folderPack instanceof FMLFolderResourcePack)
                {
                    domains.add(((FMLFolderResourcePack) folderPack).getFMLContainer().getModId());
                }

                if (!folder.isEmpty())
                {
                    folder += "/";
                }

                for (String domain : domains)
                {
                    String prefix = "assets/" + domain + "/" + folder;
                    File pathFile = new File(file, prefix);

                    enumerateFiles(folderPack, pathFile, predicate, locations, domain, folder);
                }
            }
            catch (IllegalAccessException e)
            {
                e.printStackTrace();
            }
        }
    }

    private static void enumerateFiles(FolderResourcePack folderPack, File parent, Predicate<String> predicate, List<ResourceLocation> locations, String domain, String prefix)
    {
        File[] files = parent.listFiles();

        if (files == null)
        {
            return;
        }

        for (File file : files)
        {
            if (file.isFile() && predicate.test(file.getName()))
            {
                locations.add(RLUtils.create(domain, prefix + file.getName()));
            }
            else if (file.isDirectory())
            {
                enumerateFiles(folderPack, file, predicate, locations, domain, prefix + file.getName() + "/");
            }
        }
    }

    /* Zip handling */

    private static void handleZipResourcePack(FileResourcePack filePack, String folder, Predicate<String> predicate, List<ResourceLocation> locations)
    {
        Field zipField = null;

        for (Field field : FileResourcePack.class.getDeclaredFields())
        {
            if (field.getType() == ZipFile.class)
            {
                zipField = field;

                break;
            }
        }

        if (zipField != null)
        {
            zipField.setAccessible(true);

            try
            {
                enumerateZipFile(filePack, folder, (ZipFile) zipField.get(filePack), predicate, locations);
            }
            catch (IllegalAccessException e)
            {}
        }
    }

    private static void enumerateZipFile(FileResourcePack filePack, String folder, ZipFile file, Predicate<String> predicate, List<ResourceLocation> locations)
    {
        Set<String> domains = filePack.getResourceDomains();
        Enumeration<? extends ZipEntry> it = file.entries();

        while (it.hasMoreElements())
        {
            String name = it.nextElement().getName();

            for (String domain : domains)
            {
                String assets = "assets/" + domain + "/";
                String path = assets + (folder.isEmpty() ? "" : folder + "/");

                if (name.startsWith(path) && predicate.test(name))
                {
                    locations.add(RLUtils.create(domain, name.substring(assets.length())));
                }
            }
        }
    }
}

==================================================

--- Файл №487 ---
Путь: main\java\mchorse\blockbuster\utils\TextureUtils.java
--------------------
package mchorse.blockbuster.utils;

import java.io.File;

public class TextureUtils
{
    public static File getFirstAvailableFile(File folder, String name)
    {
        File file = new File(folder, name + ".png");
        int index = 0;

        while (file.exists())
        {
            index += 1;
            file = new File(folder, name + index + ".png");
        }

        return file;
    }
}


==================================================

--- Файл №488 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\BBIcons.java
--------------------
package mchorse.blockbuster.utils.mclib;

import mchorse.mclib.client.gui.utils.Icon;
import net.minecraft.util.ResourceLocation;

public class BBIcons
{
    public static final ResourceLocation ICONS = new ResourceLocation("blockbuster", "textures/gui/icons.png");

    public static Icon YOUTUBE = new Icon(ICONS, 0, 0);
    public static Icon TWITTER = new Icon(ICONS, 16, 0);
    public static Icon CHICKEN = new Icon(ICONS, 32, 0);
    public static Icon HITBOX = new Icon(ICONS, 48, 0);
    public static Icon ARM1 = new Icon(ICONS, 64, 0);
    public static Icon LEGS1 = new Icon(ICONS, 80, 0);
    public static Icon NO_ITEMS = new Icon(ICONS, 96, 0);
    public static Icon ARM2 = new Icon(ICONS, 112, 0);
    public static Icon LEGS2 = new Icon(ICONS, 128, 0);
    public static Icon HELD_ITEMS = new Icon(ICONS, 144, 0);
    public static Icon BULLET = new Icon(ICONS, 160, 0);
    public static Icon PARTICLE = new Icon(ICONS, 176, 0);
    public static Icon SCENE = new Icon(ICONS, 192, 0);
    public static Icon EDITOR = new Icon(ICONS, 208, 0);
    public static Icon LOOKING = new Icon(ICONS, 224, 0);
}

==================================================

--- Файл №489 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\BlockbusterJarTree.java
--------------------
package mchorse.blockbuster.utils.mclib;

import mchorse.blockbuster.utils.ResourcePackUtils;
import mchorse.mclib.utils.files.FileTree;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;

import java.util.Comparator;
import java.util.List;

/**
 * Blockbuster jar file tree
 */
public class BlockbusterJarTree extends FileTree
{
    public BlockbusterJarTree()
    {
        this.root = new FolderEntry("blockbuster", null, null);

        List<ResourceLocation> allPictures = ResourcePackUtils.getAllPictures(Minecraft.getMinecraft().getResourceManager());

        allPictures.sort(Comparator.comparing(ResourceLocation::getResourcePath));

        for (ResourceLocation location : allPictures)
        {
            this.add(location);
        }

        this.recursiveSort(this.root);
    }

    private void recursiveSort(FolderEntry folder)
    {
        folder.getRawEntries().sort(FileTree.SORTER);

        for (AbstractEntry entry : folder.getRawEntries())
        {
            if (entry instanceof FolderEntry)
            {
                this.recursiveSort((FolderEntry) entry);
            }
        }
    }

    protected void add(ResourceLocation location)
    {
        String[] splits = location.getResourcePath().split("/");
        FolderEntry entry = this.root;

        main:
        for (int i = 0; i < splits.length - 1; i++)
        {
            for (AbstractEntry entryChild : entry.getRawEntries())
            {
                if (entry.isFolder() && entryChild.title.equals(splits[i]))
                {
                    entry = (FolderEntry) entryChild;

                    continue main;
                }
            }

            FolderEntry folder = new FolderEntry(splits[i], null, entry);

            this.addBackEntryTo(folder);
            entry.getRawEntries().add(folder);
            entry = folder;
        }

        FileEntry file = new FileEntry(splits[splits.length - 1] , null, location);

        entry.getRawEntries().add(file);
    }

    private void addBackEntryTo(FolderEntry entry)
    {
        entry.getRawEntries().sort(FileTree.SORTER);

        FileTree.addBackEntry(entry);
    }
}

==================================================

--- Файл №490 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\BlockbusterResourceTransformer.java
--------------------
package mchorse.blockbuster.utils.mclib;

import mchorse.mclib.utils.resources.IResourceTransformer;
import org.apache.commons.lang3.StringUtils;

import java.util.StringJoiner;

public class BlockbusterResourceTransformer implements IResourceTransformer
{
    public static final String DOMAIN = "b.a";
    public static final String OLD_DOMAIN = "blockbuster.actors";

    @Override
    public String transformDomain(String domain, String path)
    {
        if (domain.equals(OLD_DOMAIN))
        {
            domain = DOMAIN;
        }

        return domain;
    }

    @Override
    public String transformPath(String domain, String path)
    {
        /* Fix old fashion model/skin resource locations */
        if (domain.equals(DOMAIN) || domain.equals(OLD_DOMAIN))
        {
            path = this.fixPath(path);
        }

        return path;
    }

    @Override
    public String transform(String location)
    {
        if (location.startsWith(OLD_DOMAIN + ":"))
        {
            location = DOMAIN + location.substring(OLD_DOMAIN.length());
        }

        if (location.startsWith(DOMAIN + ":") && StringUtils.countMatches(location, "/") == 1)
        {
            int index = location.indexOf(":");

            String domain = location.substring(0, index + 1);
            String path = this.fixPath(location.substring(index + 1));

            location = domain + path;
        }

        return location;
    }

    private String fixPath(String path)
    {
        if (path.indexOf(".") != -1)
        {
            return path;
        }

        String[] splits = path.split("/");

        if (splits.length != 2)
        {
            return path;
        }

        return splits[0] + "/skins/" + splits[1] + ".png";
    }
}

==================================================

--- Файл №491 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\BlockbusterTree.java
--------------------
package mchorse.blockbuster.utils.mclib;

import java.io.File;

import mchorse.mclib.utils.files.FileTree;
import mchorse.mclib.utils.files.entries.FolderImageEntry;

/**
 * Blockbuster custom model system's file tree
 * 
 * This bad boy looks through the models' skins folder and recursively 
 * collects all the stuff.  
 */
public class BlockbusterTree extends FileTree
{
    public BlockbusterTree(File folder)
    {
        this.root = new FolderImageEntry("b.a", folder, null);
    }
}

==================================================

--- Файл №492 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\GifFolder.java
--------------------
package mchorse.blockbuster.utils.mclib;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import at.dhyan.open_imaging.GifDecoder;
import at.dhyan.open_imaging.GifDecoder.GifImage;

public class GifFolder extends File
{
    public static Map<String, Long> lastModified = new HashMap<String, Long>();
    public static Map<String, GifImage> cache = new HashMap<String, GifImage>();

    private static final long serialVersionUID = 3058345951609134509L;

    public GifImage gif;

    public GifFolder(String pathname)
    {
        super(pathname);

        String path = this.getPath();
        Long last = lastModified.get(path);

        if (last != null && last <= this.lastModified())
        {
            this.gif = cache.get(path);
        }
        else
        {
            try
            {
                InputStream in = new FileInputStream(pathname);

                this.gif = GifDecoder.read(in);

                in.close();
                cache.put(path, this.gif);
                lastModified.put(path, this.lastModified());
            }
            catch (IOException e)
            {
                this.gif = null;
                cache.remove(path);
                lastModified.remove(path);
            }
        }
    }

    @Override
    public String getName()
    {
        return super.getName() + ">";
    }

    @Override
    public String getPath()
    {
        return super.getPath() + ">";
    }

    public String getFilePath()
    {
        return super.getPath();
    }

    @Override
    public boolean isDirectory()
    {
        return true;
    }

    @Override
    public boolean isFile()
    {
        return false;
    }

    @Override
    public File[] listFiles()
    {
        List<File> list = new ArrayList<File>();

        for (int i = 0; i < this.gif.getFrameCount(); i++)
        {
            list.add(new GifFrameFile(this.getPath() + "/frame" + i + ".png"));
        }

        return list.toArray(new File[0]);
    }

    @Override
    public boolean exists()
    {
        return this.gif != null;
    }
}


==================================================

--- Файл №493 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\GifFrameFile.java
--------------------
package mchorse.blockbuster.utils.mclib;

import java.io.File;
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class GifFrameFile extends File
{
    private static final long serialVersionUID = -3183927604124452726L;
    private static final Pattern match = Pattern.compile("\\.gif>\\/frame(\\d+)\\.png$");

    public GifFolder parent;
    public int index;

    public GifFrameFile(String pathname)
    {
        super(pathname.substring(0, pathname.indexOf(".gif>/") + 4));

        this.init(pathname);
    }

    public GifFrameFile(File parent, String child)
    {
        super(parent, child.substring(0, child.indexOf(".gif>/") + 4));

        this.init(child);
    }

    private void init(String pathname)
    {
        this.parent = new GifFolder(super.getPath());
        this.index = -1;

        if (this.parent.exists())
        {
            Matcher matcher = match.matcher(pathname);

            if (matcher.find())
            {
                int index = Integer.parseInt(matcher.group(1));

                if (index < this.parent.gif.getFrameCount())
                {
                    this.index = index;
                }
            }
        }
    }

    @Override
    public String getName()
    {
        return "frame" + this.index + ".png";
    }

    @Override
    public String getParent()
    {
        return super.getPath();
    }

    @Override
    public File getParentFile()
    {
        return this.parent;
    }

    @Override
    public boolean isDirectory()
    {
        return false;
    }

    @Override
    public boolean isFile()
    {
        return true;
    }

    @Override
    public boolean exists()
    {
        return this.index != -1;
    }
}


==================================================

--- Файл №494 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\ImageFolder.java
--------------------
package mchorse.blockbuster.utils.mclib;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class ImageFolder extends File
{
    private static final long serialVersionUID = 2087807134801481836L;

    public ImageFolder(String pathname)
    {
        super(pathname);
    }

    public ImageFolder(File parent, String child)
    {
        super(parent, child);
    }

    @Override
    public File[] listFiles()
    {
        return this.processFiles(super.listFiles());
    }

    private File[] processFiles(File[] files)
    {
        List<File> list = new ArrayList<File>();

        for (File file : files)
        {
            if (file.isFile())
            {
                if (file.getName().toLowerCase().endsWith(".gif"))
                {
                    File gif = new GifFolder(file.getPath());

                    if (gif.exists())
                    {
                        list.add(gif);
                    }
                }

                list.add(file);
            }
            else if (file.isDirectory())
            {
                list.add(new ImageFolder(file.getPath()));
            }
        }

        return list.toArray(new File[0]);
    }
}


==================================================

--- Файл №495 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\ValueAudioButtons.java
--------------------
package mchorse.blockbuster.utils.mclib;

import mchorse.blockbuster.ClientProxy;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.config.values.ValueGUI;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueAudioButtons extends ValueGUI
{
    public ValueAudioButtons(String id)
    {
        super(id);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel config)
    {
        GuiButtonElement resetAudio = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.reset_audio"), (button) -> ClientProxy.audio.reset());
        GuiButtonElement openAudio = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.open_audio"), (button) -> GuiUtils.openFolder(ClientProxy.audio.folder.getAbsolutePath()));

        return Arrays.asList(Elements.row(mc, 5, 0, 20, resetAudio, openAudio));
    }
}

==================================================

--- Файл №496 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\ValueMainButtons.java
--------------------
package mchorse.blockbuster.utils.mclib;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.config.values.ValueGUI;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.util.Arrays;
import java.util.List;

public class ValueMainButtons extends ValueGUI
{
    public ValueMainButtons(String id)
    {
        super(id);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel config)
    {
        GuiButtonElement wiki = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.wiki"), (button) -> GuiUtils.openWebLink(Blockbuster.WIKI_URL()));
        GuiButtonElement discord = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.discord"), (button) -> GuiUtils.openWebLink(Blockbuster.DISCORD_URL()));
        GuiButtonElement tutorial = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.tutorial"), (button) -> GuiUtils.openWebLink(Blockbuster.TUTORIAL_URL()));
        GuiButtonElement models = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.models"), (button) -> GuiUtils.openFolder(new File(ClientProxy.configFile, "models").getAbsolutePath()));
        GuiButtonElement skins = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.main.skins"), (button) -> GuiUtils.openFolder(ClientProxy.skinsFolder.getAbsolutePath()));
        GuiIconElement youtube = new GuiIconElement(mc, BBIcons.YOUTUBE, (button) -> GuiUtils.openWebLink(Blockbuster.CHANNEL_URL()));
        GuiIconElement twitter = new GuiIconElement(mc, BBIcons.TWITTER, (button) -> GuiUtils.openWebLink(Blockbuster.TWITTER_URL()));

        GuiElement first = Elements.row(mc, 5, 0, 20, models, skins);
        GuiElement second = Elements.row(mc, 5, 0, 20, tutorial, wiki);
        GuiElement third = Elements.row(mc, 5, 0, 20, discord, twitter, youtube);

        return Arrays.asList(first, second, third);
    }
}

==================================================

--- Файл №497 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\coremod\ClassMethodTransformer.java
--------------------
package mchorse.blockbuster.utils.mclib.coremod;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.Iterator;

public abstract class ClassMethodTransformer extends ClassTransformer
{
    public String mcp = "";
    public String mcpSign = "";
    public String notch = "";
    public String notchSign = "";

    public ClassMethodTransformer setMcp(String name, String signature)
    {
        this.mcp = name;
        this.mcpSign = signature;

        return this;
    }

    public ClassMethodTransformer setNotch(String name, String signature)
    {
        this.notch = name;
        this.notchSign = signature;

        return this;
    }

    @Override
    public void process(String name, ClassNode node)
    {
        Iterator<MethodNode> methods = node.methods.iterator();

        while (methods.hasNext())
        {
            MethodNode method = methods.next();
            String methodName = this.checkName(method);

            if (methodName != null)
            {
                this.processMethod(methodName, method);
            }
        }
    }

    protected String checkName(MethodNode method)
    {
        return this.checkName(method, this.notch, this.notchSign, this.mcp, this.mcpSign);
    }

    public abstract void processMethod(String name, MethodNode method);
}

==================================================

--- Файл №498 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\coremod\ClassTransformer.java
--------------------
package mchorse.blockbuster.utils.mclib.coremod;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.MethodNode;

public abstract class ClassTransformer
{
    public byte[] transform(String name, byte[] bytes)
    {
        ClassNode classNode = new ClassNode();
        ClassReader classReader = new ClassReader(bytes);

        classReader.accept(classNode, 0);

        this.process(name, classNode);

        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);

        classNode.accept(writer);

        return writer.toByteArray();
    }

    protected String checkName(MethodNode method, String notch, String notchSign, String mcp, String mcpSign)
    {
        if (CoreClassTransformer.obfuscated)
        {
            return method.name.equals(notch) && method.desc.equals(notchSign) ? notch : null;
        }

        return method.name.equals(mcp) && method.desc.equals(mcpSign) ? mcp : null;
    }

    protected LabelNode getFirstLabel(MethodNode method)
    {
        AbstractInsnNode node = method.instructions.getFirst();

        while (node != null)
        {
            if (node instanceof LabelNode)
            {
                return (LabelNode) node;
            }

            node = node.getNext();
        }

        return null;
    }

    public abstract void process(String name, ClassNode node);
}

==================================================

--- Файл №499 ---
Путь: main\java\mchorse\blockbuster\utils\mclib\coremod\CoreClassTransformer.java
--------------------
package mchorse.blockbuster.utils.mclib.coremod;

import net.minecraft.launchwrapper.IClassTransformer;

public abstract class CoreClassTransformer implements IClassTransformer
{
    public static boolean obfuscated = false;

    public static boolean checkName(String name, String notch, String mcp)
    {
        if (name.equals(mcp) || name.equals(notch))
        {
            obfuscated = name.equals(notch);

            return true;
        }

        return false;
    }

    public static String get(String notch, String mcp)
    {
        return obfuscated ? notch : mcp;
    }
}

==================================================

--- Файл №500 ---
Путь: main\java\mchorse\blockbuster_pack\BlockbusterFactory.java
--------------------
package mchorse.blockbuster_pack;

import mchorse.blockbuster.api.ModelHandler;
import mchorse.blockbuster_pack.client.gui.*;
import mchorse.blockbuster_pack.morphs.*;
import mchorse.metamorph.api.IMorphFactory;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;

import java.util.List;

/**
 * Blockbuster morph factory
 *
 * This factory is responsible for adding all custom modeled morphs provided by
 * a user (in his config folder), the server (in world save's blockbuster
 * folder) or added by API (steve, alex and fred).
 */
public class BlockbusterFactory implements IMorphFactory
{
    public ModelHandler models;
    public BlockbusterSection section;

    @Override
    public void register(MorphManager manager)
    {
        manager.list.register(this.section = new BlockbusterSection("blockbuster"));
    }

    @Override
    public void registerMorphEditors(Minecraft mc, List<GuiAbstractMorph> editors)
    {
        editors.add(new GuiCustomMorph(mc));
        editors.add(new GuiImageMorph(mc));
        editors.add(new GuiSequencerMorph(mc));
        editors.add(new GuiRecordMorph(mc));
        editors.add(new GuiStructureMorph(mc));
        editors.add(new GuiParticleMorph(mc));
        editors.add(new GuiSnowstormMorph(mc));
        editors.add(new GuiTrackerMorph(mc));
        editors.add(new GuiLightMorph(mc));
        editors.add(new GuiBetterLightsMorph(mc));
    }

    @Override
    public AbstractMorph getMorphFromNBT(NBTTagCompound tag)
    {
        String name = tag.getString("Name");
        AbstractMorph morph;
        name = name.substring(name.indexOf(".") + 1);

        /* Utility */
        if (name.equals("image"))
        {
            morph = new ImageMorph();
        }
        else if (name.equals("sequencer"))
        {
            morph = new SequencerMorph();
        }
        else if (name.equals("record"))
        {
            morph = new RecordMorph();
        }
        else if (name.equals("structure"))
        {
            morph = new StructureMorph();
        }
        else if (name.equals("particle"))
        {
            morph = new ParticleMorph();
        }
        else if (name.equals("snowstorm"))
        {
            morph = new SnowstormMorph();
        }
        else if (name.equals("tracker"))
        {
            morph = new TrackerMorph();
        }
        else if (name.equals("light"))
        {
            morph = new LightMorph();
        }
        else if (name.equals("betterLights"))
        {
            morph = new BetterLightsMorph();
        }
        else
        {
            /* Custom model morphs */
            CustomMorph custom = new CustomMorph();

            custom.model = this.models.models.get(name);
            morph = custom;
        }

        morph.fromNBT(tag);

        return morph;
    }

    @Override
    public boolean hasMorph(String morph)
    {
        return morph.startsWith("blockbuster.") || morph.equals("sequencer") || morph.equals("structure") || morph.equals("particle") || morph.equals("snowstorm") || morph.equals("tracker") || morph.equals("light") || morph.equals("betterLights");
    }
}

==================================================

--- Файл №501 ---
Путь: main\java\mchorse\blockbuster_pack\BlockbusterSection.java
--------------------
package mchorse.blockbuster_pack;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.structure.PacketStructureListRequest;
import mchorse.blockbuster_pack.morphs.*;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.vanilla_pack.morphs.BlockMorph;
import mchorse.vanilla_pack.morphs.ItemMorph;
import mchorse.vanilla_pack.morphs.LabelMorph;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.FilenameUtils;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class BlockbusterSection extends MorphSection
{
    public MorphCategory extra;
    public MorphCategory structures;
    public Map<String, MorphCategory> models = new HashMap<String, MorphCategory>();

    private boolean alex;
    private boolean steve;
    private SequencerMorph sequencer;

    public BlockbusterSection(String title)
    {
        super(title);

        this.extra = new MorphCategory(this, "blockbuster_extra");
        this.structures = new MorphCategory(this, "blockbuster_structures");

        /* Adding some default morphs which don't need to get reloaded */
        ImageMorph image = new ImageMorph();
        SnowstormMorph snow = new SnowstormMorph();
        SequencerMorph sequencer = new SequencerMorph();

        image.texture = RLUtils.create("b.a:image/skins/default.png");
        snow.setScheme("default_rain");

        this.extra.add(image);
        this.extra.add(new ParticleMorph());
        this.extra.add(this.sequencer = sequencer);
        this.extra.add(new RecordMorph());
        this.extra.add(snow);

        /* By popular demand */
        this.extra.add(new ItemMorph());
        this.extra.add(new LabelMorph());
        this.extra.add(new BlockMorph());

        this.addFromNBT("{DisplayName:\"McHorse\",Skin:\"blockbuster:textures/entity/mchorse/skin.png\",BodyParts:[{Limb:\"head\",Morph:{Name:\"blockbuster.mchorse/head\"}}],Name:\"blockbuster.fred_3d\"}");
        
        this.extra.add(new TrackerMorph());
        this.extra.add(new LightMorph());
        this.extra.add(new BetterLightsMorph());
    }

    private void addFromNBT(String nbt)
    {
        try
        {
            NBTTagCompound tag = JsonToNBT.getTagFromJson(nbt);
            CustomMorph morph = new CustomMorph();

            morph.fromNBT(tag);
            this.extra.add(morph);
        }
        catch (Exception e)
        {}
    }

    public void addStructure(String name, boolean sort)
    {
        StructureMorph morph = new StructureMorph();

        morph.structure = name;
        this.structures.add(morph);

        if (sort)
        {
            this.structures.sort();
        }
    }

    public void addStructures(List<String> structures)
    {
        this.structures.clear();

        for (String name : structures)
        {
            this.addStructure(name, false);
        }

        this.structures.sort();
    }

    public void removeStructure(String name)
    {
        Iterator<AbstractMorph> it = this.structures.getMorphs().iterator();

        while (it.hasNext())
        {
            AbstractMorph morph = it.next();

            if (((StructureMorph) morph).structure.equals(name))
            {
                it.remove();
            }
        }
    }

    public void add(String key, Model model, boolean isRemote)
    {
        String path = this.getCategoryId(key);
        MorphCategory category = this.models.get(path);

        if (category == null)
        {
            category = new BlockbusterCategory(this, "blockbuster_models", path);
            this.models.put(path, category);
            this.categories.add(category);
        }

        for (AbstractMorph morph : category.getMorphs())
        {
            if (morph instanceof CustomMorph && ((CustomMorph) morph).getKey().equals(key))
            {
                return;
            }
        }

        CustomMorph morph = new CustomMorph();

        morph.name = "blockbuster." + key;
        morph.model = model;

        if (isRemote)
        {
            morph.skin = this.getSkin(key, model);
        }

        category.add(morph);
        category.sort();

        /* Really terrible hack to add sequences */
        this.alex = this.alex || key.equals("alex");
        this.steve = this.steve || key.equals("fred");

        if (this.steve && this.alex && this.sequencer.morphs.isEmpty())
        {
            CustomMorph alex = new CustomMorph();
            CustomMorph fred = new CustomMorph();

            alex.name = "blockbuster.alex";
            alex.updateModel(true);
            fred.name = "blockbuster.fred";
            fred.updateModel(true);

            this.sequencer.morphs.add(new SequencerMorph.SequenceEntry(alex));
            this.sequencer.morphs.add(new SequencerMorph.SequenceEntry(fred));
        }
    }

    /**
     * Get the first skin which can be found
     */
    @SideOnly(Side.CLIENT)
    private ResourceLocation getSkin(String key, Model model)
    {
        if (model.defaultTexture != null)
        {
            return null;
        }

        FolderEntry folder = ClientProxy.tree.getByPath(key + "/skins", null);

        if (folder != null)
        {
            for (AbstractEntry skinEntry : folder.getEntries())
            {
                if (skinEntry instanceof FileEntry)
                {
                    return ((FileEntry) skinEntry).resource;
                }
            }
        }

        folder = ClientProxy.tree.getByPath(model.skins + "/skins", null);

        if (folder != null)
        {
            for (AbstractEntry skinEntry : folder.getEntries())
            {
                if (skinEntry instanceof FileEntry)
                {
                    return  ((FileEntry) skinEntry).resource;
                }
            }
        }

        return null;
    }

    public void remove(String key)
    {
        String path = this.getCategoryId(key);
        String name = "blockbuster." + key;
        MorphCategory category = this.models.get(path);
        List<AbstractMorph> morphs = new ArrayList<AbstractMorph>();

        for (AbstractMorph m : category.getMorphs())
        {
            if (m.name.equals(name))
            {
                morphs.add(m);
            }
        }

        for (AbstractMorph morph : morphs)
        {
            category.remove(morph);
        }
    }

    private String getCategoryId(String key)
    {
        if (key.contains("/"))
        {
            key = FilenameUtils.getPath(key);

            return key.substring(0, key.length() - 1);
        }

        return "";
    }

    @Override
    public void update(World world)
    {
        /* Reload models and skin */
        Blockbuster.proxy.loadModels(false);
        Blockbuster.proxy.particles.reload();
        Dispatcher.sendToServer(new PacketStructureListRequest());

        this.categories.clear();
        this.add(this.extra);
        this.add(this.structures);

        /* Add models categories */
        for (MorphCategory category : this.models.values())
        {
            this.add(category);
        }
    }

    @Override
    public void reset()
    {
        this.structures.clear();
    }

    public static class BlockbusterCategory extends MorphCategory
    {
        public String subtitle;

        public BlockbusterCategory(MorphSection parent, String title, String subtitle)
        {
            super(parent, title);

            this.subtitle = subtitle;
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getTitle()
        {
            if (!this.subtitle.isEmpty())
            {
                return super.getTitle() + " (" + this.subtitle + ")";
            }

            return super.getTitle();
        }
    }
}

==================================================

--- Файл №502 ---
Путь: main\java\mchorse\blockbuster_pack\MetamorphHandler.java
--------------------
package mchorse.blockbuster_pack;

import mchorse.metamorph.api.events.RegisterBlacklistEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

public class MetamorphHandler
{
    @SubscribeEvent
    public void onBlacklistReload(RegisterBlacklistEvent event)
    {
        event.blacklist.add("blockbuster:actor");
    }
}

==================================================

--- Файл №503 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiBetterLightsMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import dz.betterlights.lighting.lightcasters.LightCaster;
import dz.betterlights.lighting.lightcasters.features.ILightConfig;
import dz.betterlights.utils.BetterLightsConstants;
import dz.betterlights.utils.ConfigProperty;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster_pack.morphs.BetterLightsMorph;
import mchorse.blockbuster_pack.morphs.BetterLightsMorphTemplate;
import mchorse.blockbuster_pack.morphs.LightMorph;
import mchorse.mclib.client.gui.framework.elements.GuiCollapseSection;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.modals.GuiMessageModal;
import mchorse.mclib.client.gui.framework.elements.modals.GuiModal;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.*;
import mchorse.mclib.utils.BetterLightsHelper;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Direction;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAnimation;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.common.Optional;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Vector3f;
import java.lang.reflect.Field;
import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import static dz.betterlights.utils.ConfigProperty.EnumPropertyType.COLOR_PICKER;

@SideOnly(Side.CLIENT)
public class GuiBetterLightsMorph extends GuiAbstractMorph<BetterLightsMorph>
{
    public GuiBetterLightsMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = new GuiBetterLightsMorphPanel(mc, this);
        this.registerPanel(this.defaultPanel, IKey.lang("blockbuster.gui.betterlights_morph.name"), Icons.GEAR);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof BetterLightsMorph;
    }

    public static class GuiBetterLightsMorphPanel extends GuiMorphPanel<BetterLightsMorph, GuiBetterLightsMorph>
    {
        private GuiAnimation animation;
        /**
         * List of consumers used to apply the morph's values to the UI elements.
         * The lambda expressions will contain the reference to the respective UI element, since they
         * are dynamically generated.
         */
        private final List<Consumer<BetterLightsMorph>> apply = new ArrayList<>();
        private GuiToggleElement enableAlways;

        public GuiBetterLightsMorphPanel(Minecraft mc, GuiBetterLightsMorph editor)
        {
            super(mc, editor);

            this.animation = new GuiAnimation(mc, true);
            this.animation.flex().column(0).padding(0);
            this.animation.ignored.removeFromParent();
            this.animation.interpolations.removeFromParent();
            this.enableAlways = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.betterlights_morph.enable_always"),
                    (b) -> this.morph.setEnableAlways(b.isToggled()));

            GuiElement left = new GuiElement(mc);
            left.flex().relative(this)
                    .x(0F)
                    .w(200)
                    .h(1F)
                    .column(0)
                    .vertical().stretch().padding(10);

            GuiElement sponsors = Elements.label(IKey.lang("blockbuster.gui.betterlights_morph.sponsored_title"));
            sponsors.tooltip(IKey.comp(IKey.lang("blockbuster.gui.betterlights_morph.sponsored_tooltip"),
                    IKey.str("\n\nMarlon\nHerr Bergmann\nAreon Pictures\nJunder\nPhoenixMedia\nLouis Angerer\nGewenzsko\nKatzen48")));

            left.add(sponsors);

            this.add(left);

            if (BetterLightsHelper.isBetterLightsLoaded())
            {
                GuiScrollElement scroll = new GuiScrollElement(mc);

                scroll.flex().relative(this)
                        .x(1F)
                        .w(200)
                        .h(1F)
                        .anchorX(1F)
                        .column(5)
                        .vertical().stretch().scroll().padding(10);

                scroll.add(this.enableAlways, this.animation);

                this.generateUITree(scroll, BetterLightsMorph.BetterLightsProperties.valueTree);
                this.add(scroll, this.animation.interpolations);
            }
            else
            {
                GuiModal modal = new GuiBetterLightsMessage(this.mc, IKey.lang("blockbuster.gui.betterlights_morph.not_installed_message"));
                modal.flex().relative(this)
                        .x(0.5F)
                        .y(0.5F)
                        .anchorX(0.5F)
                        .anchorY(0.5F)
                        .w(128)
                        .h(128);
                this.add(modal);
            }
        }

        private void generateUITree(GuiElement parentElement, Value value)
        {
            for (Value subValue : value.getSubValues())
            {
                String path = subValue.getPath();
                String langPath = "blockbuster.gui.betterlights_morph.options." + path.toLowerCase().replace(" ", "_");

                if (subValue instanceof ValueBoolean)
                {
                    this.addToggleElement(parentElement, path, langPath);
                }
                else if (subValue instanceof GenericNumberValue)
                {
                    this.addTrackpad(parentElement, (GenericNumberValue<?>) subValue, path, langPath);
                }
                else if (subValue instanceof ValueColor)
                {
                    this.addColor(parentElement, path, langPath);
                }

                if (subValue.getSubValues().size() != 0)
                {
                    GuiCollapseSection section = new GuiCollapseSection(this.mc, IKey.lang(langPath + ".title"));
                    section.setCollapsed(true);
                    parentElement.add(section);
                    this.generateUITree(section, subValue);
                }
            }
        }

        /**
         * @param parentElement
         * @param path the path of the value this element edits
         */
        private void addColor(GuiElement parentElement, final String path, final String langPath)
        {
            GuiColorElement color = new GuiColorElement(this.mc,
                    (value) -> this.morph.getValueManager().getValue(path).ifPresent(v -> v.setValue(new Color(value))))
                    .direction(Direction.TOP);
            color.picker.editAlpha();
            color.tooltip(IKey.lang(langPath));

            parentElement.add(color);

            this.apply.add((morph) ->
                    morph.getValueManager().getValue(path)
                            .ifPresent(v -> color.picker.setColor(((Color) v.get()).getRGBAColor())));
        }

        private void addTrackpad(GuiElement parentElement, GenericNumberValue<?> numberValue, final String path, final String langPath)
        {
            GuiTrackpadElement trackpad = new GuiTrackpadElement(this.mc,
                    (value) -> this.morph.getValueManager().getValue(path).ifPresent((v) -> v.setValue(value.floatValue())));
            trackpad.tooltip(IKey.lang(langPath + "_tooltip"));
            trackpad.limit(numberValue.getMin().doubleValue(), numberValue.getMax().doubleValue());

            boolean isInteger = numberValue.isInteger();
            if (isInteger) trackpad.integer();

            parentElement.add(trackpad);

            this.apply.add((morph) ->
                    morph.getValueManager().getValue(path)
                            .ifPresent(genericBaseValue ->
                            {
                                if (!(genericBaseValue instanceof GenericNumberValue)) return;
                                GenericNumberValue<?> numberValue0 = (GenericNumberValue<?>) genericBaseValue;
                                trackpad.setValue(isInteger ? numberValue0.get().longValue() : numberValue0.get().doubleValue());
                            }));
        }

        /**
         *
         * @param parentElement
         * @param path the path of the value this element edits
         */
        private void addToggleElement(GuiElement parentElement, final String path, final String langPath)
        {
            GuiToggleElement toggleElement = new GuiToggleElement(this.mc, IKey.lang(langPath),
                    v -> this.morph.getValueManager().getValue(path)
                            .ifPresent((value) -> value.setValue(v.isToggled())));

            parentElement.add(toggleElement);

            this.apply.add((morph) ->
                morph.getValueManager().getValue(path)
                        .ifPresent(genericBaseValue -> toggleElement.toggled((Boolean) genericBaseValue.get())));
        }

        @Override
        public void fillData(BetterLightsMorph morph)
        {
            super.fillData(morph);

            this.animation.fill(morph.getAnimation());
            this.apply.forEach(consumer -> consumer.accept(morph));
            this.enableAlways.toggled(morph.isEnableAlways());
        }
    }

    public static class GuiBetterLightsMessage extends GuiModal
    {
        public GuiBetterLightsMessage(Minecraft mc, IKey label) {
            super(mc, label);

            GuiButtonElement button = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.betterlights_morph.mod_page_button"),
                    (b) -> GuiUtils.openWebLink(BetterLightsConstants.PATREON_URL));

            this.bar.add(button);
        }
    }
}


==================================================

--- Файл №504 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiCustomBodyPartEditor.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.GuiBodyPartEditor;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiCustomBodyPartEditor extends GuiBodyPartEditor implements ILimbSelector
{
    public GuiCustomBodyPartEditor(Minecraft mc, GuiAbstractMorph editor)
    {
        super(mc, editor);
    }

    @Override
    protected void setPart(BodyPart part)
    {
        super.setPart(part);

        if (part != null)
        {
            GuiCustomMorph parent = (GuiCustomMorph) this.editor;

            parent.bbRenderer.limb = parent.morph.model.limbs.get(part.limb);
        }
    }

    @Override
    protected void pickLimb(String limbName)
    {
        GuiCustomMorph parent = (GuiCustomMorph) this.editor;

        super.pickLimb(limbName);
        parent.bbRenderer.limb = parent.morph.model.limbs.get(limbName);
    }

    @Override
    public void setLimb(String limb)
    {
        try
        {
            this.pickLimb(limb);
            this.limbs.setCurrent(limb);
        }
        catch (Exception e) {}
    }
}

==================================================

--- Файл №505 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiCustomMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.formats.obj.OBJMaterial;
import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiBBModelRenderer;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster_pack.client.render.layers.LayerBodyPart;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDrawable;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@SideOnly(Side.CLIENT)
public class GuiCustomMorph extends GuiAbstractMorph<CustomMorph>
{
    public GuiPosePanel poseEditor;
    public GuiCustomBodyPartEditor bodyPart;
    public GuiMaterialsPanel materials;
    public GuiModelRendererBodyPart bbRenderer;

    public static void addSkins(AbstractMorph morph, List<Label<NBTTagCompound>> list, String name, FolderEntry entry)
    {
        if (entry == null)
        {
            return;
        }

        for (AbstractEntry childEntry : entry.getEntries())
        {
            if (childEntry instanceof FileEntry)
            {
                ResourceLocation location = ((FileEntry) childEntry).resource;
                String label = location.getResourcePath();
                int index = label.indexOf("/skins/");

                if (index != -1)
                {
                    label = label.substring(index + 7);
                }

                addPreset(morph, list, name, label, location);
            }
            else if (childEntry instanceof FolderEntry)
            {
                FolderEntry childFolder = (FolderEntry) childEntry;

                if (!childFolder.isTop())
                {
                    addSkins(morph, list, name, childFolder);
                }
            }
        }
    }

    public static void addPreset(AbstractMorph morph, List<Label<NBTTagCompound>> list, String name, String label, ResourceLocation skin)
    {
        try
        {
            NBTTagCompound tag = morph.toNBT();

            tag.setString(name, skin.toString());
            list.add(new Label<>(IKey.str(label), tag));
        }
        catch (Exception e)
        {}
    }

    public GuiCustomMorph(Minecraft mc)
    {
        super(mc);

        /* Nice shadow on bottom */
        this.prepend(new GuiDrawable((n) ->
        {
            this.drawGradientRect(0, this.area.ey() - 30, this.area.w, this.area.ey(), 0, ColorUtils.HALF_BLACK);
        }));

        /* Morph panels */
        this.poseEditor = new GuiPosePanel(mc, this);
        this.bodyPart = new GuiCustomBodyPartEditor(mc, this);
        this.materials = new GuiMaterialsPanel(mc, this);

        this.defaultPanel = this.poseEditor;
        this.registerPanel(this.materials, IKey.lang("blockbuster.gui.builder.materials"), Icons.MATERIAL);
        this.registerPanel(this.bodyPart, IKey.lang("blockbuster.gui.builder.body_part"), Icons.LIMB);
        this.registerPanel(this.poseEditor, IKey.lang("blockbuster.gui.builder.pose_editor"), Icons.POSE);

        this.keys().register(IKey.lang("blockbuster.gui.builder.pick_skin"), Keyboard.KEY_P, () ->
        {
            this.setPanel(this.materials);

            if (!this.materials.picker.hasParent())
            {
                this.materials.skin.clickItself(GuiBase.getCurrent());
            }
        }).held(Keyboard.KEY_LSHIFT);

        this.keys().register(IKey.lang("blockbuster.gui.builder.pick_texture"), Keyboard.KEY_E, () ->
        {
            this.setPanel(this.materials);

            if (!this.materials.picker.hasParent())
            {
                this.materials.texture.clickItself(GuiBase.getCurrent());
            }
        }).held(Keyboard.KEY_LSHIFT);
    }

    @Override
    protected GuiModelRenderer createMorphRenderer(Minecraft mc)
    {
        this.bbRenderer = new GuiModelRendererBodyPart(Minecraft.getMinecraft());
        this.bbRenderer.looking = false;
        this.bbRenderer.origin = true;
        this.bbRenderer.picker((limb) ->
        {
            if (this.view.delegate instanceof ILimbSelector)
            {
                ((ILimbSelector) this.view.delegate).setLimb(limb);
            }
        });

        return this.bbRenderer;
    }

    @Override
    protected void setupRenderer(CustomMorph morph)
    {
        super.setupRenderer(morph);

        ModelPose pose = morph.getCurrentPose();

        if (pose != null)
        {
            this.bbRenderer.setScale(1.25F + pose.size[0]);
            this.bbRenderer.setPosition(0, pose.size[1] / 2F, 0);
        }
    }

    @Override
    public void setPanel(GuiMorphPanel panel)
    {
        this.bbRenderer.limb = null;
        this.updateModelRenderer();

        super.setPanel(panel);
    }

    /**
     * This editor can only edit if the morph has a model 
     */
    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof CustomMorph && ((CustomMorph) morph).model != null;
    }

    @Override
    public void startEdit(CustomMorph morph)
    {
        morph.parts.reinitBodyParts();
        this.bodyPart.setLimbs(morph.model.limbs.keySet());

        this.bbRenderer.morph = morph;
        this.bbRenderer.limb = null;

        super.startEdit(morph);

        this.updateModelRenderer();
    }

    @Override
    public List<Label<NBTTagCompound>> getPresets(CustomMorph morph)
    {
        List<Label<NBTTagCompound>> list = new ArrayList<Label<NBTTagCompound>>();
        String key = morph.getKey();

        /* Add presets that are part of JSON file */
        if (morph instanceof CustomMorph)
        {
            if (morph.model != null && !morph.model.presets.isEmpty())
            {
                for (Map.Entry<String, String> preset : morph.model.presets.entrySet())
                {
                    NBTTagCompound tag = null;

                    try
                    {
                        tag = JsonToNBT.getTagFromJson(preset.getValue());
                    }
                    catch (Exception e)
                    {}

                    if (tag != null)
                    {
                        NBTTagCompound morphTag = morph.toNBT();

                        morphTag.merge(tag);
                        list.add(new Label<NBTTagCompound>(IKey.str(preset.getKey()), morphTag));
                    }
                }
            }
        }

        addSkins(morph, list, "Skin", ClientProxy.tree.getByPath(key + "/skins", null));
        addSkins(morph, list, "Skin", ClientProxy.tree.getByPath(morph.model.skins + "/skins", null));

        return list;
    }

    public void updateModelRenderer()
    {
        CustomMorph custom = this.morph;

        this.bbRenderer.materials = custom.materials;
        this.bbRenderer.model = ModelCustom.MODELS.get(custom.getKey());
        this.bbRenderer.texture = custom.skin == null ? custom.model.defaultTexture : custom.skin;
        this.bbRenderer.setPose(custom.getCurrentPose());
    }

    /**
     * Custom model morph panel which allows editing custom textures 
     * for materials of the custom model morph 
     */
    public static class GuiMaterialsPanel extends GuiMorphPanel<CustomMorph, GuiCustomMorph>
    {
        /* Materials */
        public GuiButtonElement skin;
        public GuiButtonElement texture;
        public GuiStringListElement materials;
        public GuiTexturePicker picker;
        public GuiToggleElement keying;

        public GuiMaterialsPanel(Minecraft mc, GuiCustomMorph editor)
        {
            super(mc, editor);

            Consumer<ResourceLocation> skin = (rl) ->
            {
                this.morph.skin = RLUtils.clone(rl);
                this.editor.updateModelRenderer();
            };

            Consumer<ResourceLocation> material = this::setCurrentMaterialRL;

            /* Materials view */
            this.skin = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.builder.pick_skin"), (b) ->
            {
                this.picker.refresh();
                this.picker.fill(this.morph.skin);
                this.picker.callback = skin;
                this.add(this.picker);
                this.picker.resize();
            });
            this.texture = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.builder.pick_texture"), (b) ->
            {
                ResourceLocation location = this.morph.materials.get(this.materials.getCurrentFirst());

                this.picker.refresh();
                this.picker.fill(location);
                this.picker.callback = material;
                this.add(this.picker);
                this.picker.resize();
            });
            this.materials = new GuiStringListElement(mc, (str) -> this.materials.setCurrent(str.get(0)));
            this.materials.background();
            this.keying = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.image.keying"), false, (b) -> this.morph.keying = b.isToggled());
            this.keying.tooltip(IKey.lang("blockbuster.gui.image.keying_tooltip"), Direction.TOP);
            this.picker = new GuiTexturePicker(mc, skin);

            this.skin.flex().relative(this).set(10, 10, 110, 20);
            this.texture.flex().relative(this.skin).set(0, 25, 110, 20);
            this.materials.flex().relative(this.texture).set(0, 25, 110, 0).hTo(this.keying.flex(), -5);
            this.keying.flex().relative(this).x(10).w(110).y(1F, -24);
            this.picker.flex().relative(this).wh(1F, 1F);

            this.add(this.skin, this.texture, this.keying, this.materials);
        }

        private void setCurrentMaterialRL(ResourceLocation rl)
        {
            String key = this.materials.getCurrentFirst();

            if (rl == null)
            {
                this.morph.materials.remove(key);
            }
            else
            {
                this.morph.materials.put(key, rl);
            }

            this.editor.updateModelRenderer();
        }

        @Override
        public void fillData(CustomMorph morph)
        {
            super.fillData(morph);

            this.materials.clear();

            for (Map.Entry<String, OBJMaterial> entry : morph.model.materials.entrySet())
            {
                if (entry.getValue().useTexture)
                {
                    this.materials.add(entry.getKey());
                }
            }

            this.materials.sort();
            this.picker.removeFromParent();

            boolean noMaterials = this.materials.getList().isEmpty();

            if (!noMaterials)
            {
                this.materials.setIndex(0);
            }

            this.materials.setVisible(!noMaterials);
            this.texture.setVisible(!noMaterials);
            this.keying.toggled(morph.keying);
        }

        @Override
        public void finishEditing()
        {
            this.picker.close();

            super.finishEditing();
        }

        @Override
        public void draw(GuiContext context)
        {
            if (this.materials.isVisible())
            {
                this.font.drawStringWithShadow(I18n.format("blockbuster.gui.builder.obj_materials"), this.materials.area.x, this.materials.area.y - 12, 0xffffff);
            }

            super.draw(context);
        }
    }

    /**
     * Model renderer, but it also renders body parts 
     */
    public static class GuiModelRendererBodyPart extends GuiBBModelRenderer
    {
        public CustomMorph morph;

        public GuiModelRendererBodyPart(Minecraft mc)
        {
            super(mc);
        }

        @Override
        protected float getScale()
        {
            return this.morph == null ? 1F : this.morph.scale;
        }

        @Override
        protected void renderModel(EntityLivingBase dummy, float headYaw, float headPitch, int timer, int yaw, int pitch, float partialTicks, float factor)
        {
            super.renderModel(dummy, headYaw, headPitch, timer, yaw, pitch, partialTicks, factor);

            LayerBodyPart.renderBodyParts(dummy, this.morph, this.model, 0, 0, partialTicks, dummy.ticksExisted + partialTicks, headYaw, headPitch, factor);
        }
    }

    public static class GuiShapeKeyListElement extends GuiListElement<ShapeKey>
    {
        public GuiShapeKeyListElement(Minecraft mc, Consumer<List<ShapeKey>> callback)
        {
            super(mc, callback);

            this.scroll.scrollItemSize = 16;
        }

        protected String elementToString(ShapeKey element)
        {
            return element.name;
        }
    }
}

==================================================

--- Файл №506 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiImageMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.aperture.client.gui.GuiMinemaPanel;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiPoseTransformations;
import mchorse.blockbuster.client.particles.components.appearance.CameraFacing;
import mchorse.blockbuster_pack.morphs.ImageMorph;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.RenderingUtils;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAnimation;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.lang3.ArrayUtils;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.List;

@SideOnly(Side.CLIENT)
public class GuiImageMorph extends GuiAbstractMorph<ImageMorph>
{
    public GuiImageMorphPanel general;

    public GuiImageMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.general = new GuiImageMorphPanel(mc, this);
        this.registerPanel(this.general, IKey.lang("blockbuster.morph.image"), Icons.GEAR);

        this.keys().register(IKey.lang("blockbuster.gui.builder.pick_texture"), Keyboard.KEY_E, () ->
        {
            if (!this.general.picker.hasParent())
            {
                this.general.texture.clickItself(GuiBase.getCurrent());
            }
        }).held(Keyboard.KEY_LSHIFT);
    }

    @Override
    protected GuiModelRenderer createMorphRenderer(Minecraft mc)
    {
        return new GuiMorphRenderer(mc)
        {
            @Override
            protected void drawUserModel(GuiContext context)
            {
                if (this.morph != null) {
                    MorphUtils.render(this.morph, this.entity, 0.0D, 0.0D, 0.0D, 0, context.partialTicks);
                }
            }
        };
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof ImageMorph;
    }

    @Override
    public List<Label<NBTTagCompound>> getPresets(ImageMorph morph)
    {
        List<Label<NBTTagCompound>> list = new ArrayList<Label<NBTTagCompound>>();

        GuiCustomMorph.addSkins(morph, list, "Texture", ClientProxy.tree.getByPath("image/skins", null));

        return list;
    }

    public static class GuiImageMorphPanel extends GuiMorphPanel<ImageMorph, GuiImageMorph>
    {
        public static final RenderingUtils.Facing[] SORTED_FACING_MODES = {RenderingUtils.Facing.ROTATE_XYZ, RenderingUtils.Facing.ROTATE_Y, RenderingUtils.Facing.LOOKAT_XYZ, RenderingUtils.Facing.LOOKAT_Y};

        public GuiPoseTransformations pose;

        public GuiTexturePicker picker;
        public GuiButtonElement texture;
        public GuiTrackpadElement scale;
        public GuiToggleElement shaded;
        public GuiToggleElement lighting;
        public GuiToggleElement billboard;
        public GuiToggleElement removeParentScaleRotation;
        public GuiLabel facingModeLabel;
        public GuiCirculateElement facingMode;

        public GuiTrackpadElement left;
        public GuiTrackpadElement right;
        public GuiTrackpadElement top;
        public GuiTrackpadElement bottom;
        public GuiToggleElement resizeCrop;
        public GuiColorElement color;

        public GuiTrackpadElement offsetX;
        public GuiTrackpadElement offsetY;
        public GuiTrackpadElement rotation;
        public GuiToggleElement keying;
        public GuiToggleElement thickness;
        public GuiToggleElement shadow;

        public GuiAnimation animation;

        public GuiImageMorphPanel(Minecraft mc, GuiImageMorph editor)
        {
            super(mc, editor);

            this.pose = new GuiPoseTransformations(mc);
            this.pose.flex().relative(this.area).set(0, 0, 256, 70).x(0.5F, -128).y(1, -75);
            this.texture = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.builder.pick_texture"), (b) ->
            {
                this.picker.refresh();
                this.picker.fill(this.morph.texture);

                this.add(this.picker);
                this.picker.resize();
            });

            this.shaded = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.shading"), false, (b) -> this.morph.shaded = b.isToggled());
            this.lighting = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.me.limbs.lighting"), false, (b) -> this.morph.lighting = b.isToggled());
            this.billboard = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.billboard"), false, (b) ->
            {
                this.morph.billboard = b.isToggled();

                if (b.isToggled())
                {
                    this.morph.removeParentScaleRotation = true;

                    this.removeParentScaleRotation.toggled(true);
                }
            });
            this.picker = new GuiTexturePicker(mc, (rl) -> this.morph.texture = rl);
            this.removeParentScaleRotation = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.image.remove_parent_space_effects"), false, (b) -> this.morph.removeParentScaleRotation = b.isToggled());
            this.removeParentScaleRotation.tooltip(IKey.lang("blockbuster.gui.image.remove_parent_space_effects_tooltip"));

            this.facingMode = new GuiCirculateElement(mc, (b) ->
            {
                this.morph.facing = SORTED_FACING_MODES[this.facingMode.getValue()];
            });
            this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.rotate_xyz"));
            this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.rotate_y"));
            this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_xyz"));
            this.facingMode.addLabel(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.lookat_y"));
            this.facingModeLabel = Elements.label(IKey.lang("blockbuster.gui.snowstorm.appearance.camera_facing.label"), 20).anchor(0, 0.5F);

            this.left = new GuiTrackpadElement(mc, (value) -> this.morph.crop.x = value.intValue());
            this.left.tooltip(IKey.lang("blockbuster.gui.image.left"));
            this.left.integer();
            this.right = new GuiTrackpadElement(mc, (value) -> this.morph.crop.z = value.intValue());
            this.right.tooltip(IKey.lang("blockbuster.gui.image.right"));
            this.right.integer();
            this.top = new GuiTrackpadElement(mc, (value) -> this.morph.crop.y = value.intValue());
            this.top.tooltip(IKey.lang("blockbuster.gui.image.top"));
            this.top.integer();
            this.bottom = new GuiTrackpadElement(mc, (value) -> this.morph.crop.w = value.intValue());
            this.bottom.tooltip(IKey.lang("blockbuster.gui.image.bottom"));
            this.bottom.integer();
            this.resizeCrop = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.image.resize_crop"), false, (b) -> this.morph.resizeCrop = b.isToggled());
            this.color = new GuiColorElement(mc, (value) -> this.morph.color = value).direction(Direction.TOP);
            this.color.picker.editAlpha();

            this.offsetX = new GuiTrackpadElement(mc, (value) -> this.morph.offsetX = value.floatValue());
            this.offsetX.tooltip(IKey.lang("blockbuster.gui.image.offset_x"));
            this.offsetY = new GuiTrackpadElement(mc, (value) -> this.morph.offsetY = value.floatValue());
            this.offsetY.tooltip(IKey.lang("blockbuster.gui.image.offset_y"));
            this.rotation = new GuiTrackpadElement(mc, (value) -> this.morph.rotation = value.floatValue());
            this.rotation.tooltip(IKey.lang("blockbuster.gui.image.rotation"));
            this.keying = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.image.keying"), false, (b) -> this.morph.keying = b.isToggled());
            this.keying.tooltip(IKey.lang("blockbuster.gui.image.keying_tooltip"), Direction.TOP);
            this.thickness = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.image.thickness"), false, (b) -> this.morph.thickness = b.isToggled());
            this.thickness.tooltip(IKey.lang("blockbuster.gui.image.thickness_tooltip"), Direction.TOP);
            this.shadow = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.image.shadow"), false, (b) -> this.morph.shadow = b.isToggled());
            this.shadow.tooltip(IKey.lang("blockbuster.gui.image.shadow_tooltip"), Direction.TOP);

            this.picker.flex().relative(this.area).wh(1F, 1F);

            GuiScrollElement column = new GuiScrollElement(mc);

            column.scroll.opposite = true;
            column.flex().relative(this).w(150).h(1F).column(5).vertical().stretch().scroll().height(20).padding(10);
            column.add(this.texture, this.scale, this.shaded, this.lighting, this.billboard, this.removeParentScaleRotation, this.facingModeLabel, this.facingMode, Elements.label(IKey.lang("blockbuster.gui.image.crop")));
            column.add(this.left, this.right, this.top, this.bottom, this.resizeCrop, this.color, this.offsetX, this.offsetY, this.rotation, this.keying, this.thickness, this.shadow);

            this.animation = new GuiAnimation(mc, true);
            this.animation.flex().relative(this).x(1F, -130).w(130);

            this.add(this.pose, column, this.animation);
        }

        @Override
        public void fillData(ImageMorph morph)
        {
            super.fillData(morph);

            this.picker.removeFromParent();

            this.pose.set(morph.pose);
            this.shaded.toggled(morph.shaded);
            this.lighting.toggled(morph.lighting);
            this.billboard.toggled(morph.billboard);
            this.removeParentScaleRotation.toggled(morph.removeParentScaleRotation);
            this.facingMode.setValue(ArrayUtils.indexOf(SORTED_FACING_MODES, this.morph.facing));

            this.left.setValue(morph.crop.x);
            this.right.setValue(morph.crop.z);
            this.top.setValue(morph.crop.y);
            this.bottom.setValue(morph.crop.w);
            this.resizeCrop.toggled(morph.resizeCrop);

            this.color.picker.setColor(morph.color);
            this.offsetX.setValue(morph.offsetX);
            this.offsetY.setValue(morph.offsetY);
            this.keying.toggled(morph.keying);
            this.thickness.toggled(morph.thickness);
            this.shadow.toggled(morph.shadow);

            this.animation.fill(morph.animation);
        }

        @Override
        public void finishEditing()
        {
            this.picker.close();

            super.finishEditing();
        }

        @Override
        public void draw(GuiContext context)
        {
            this.mc.renderEngine.bindTexture(this.morph.texture);
            int w = this.morph.getWidth();
            int h = this.morph.getHeight();
            String label = I18n.format("blockbuster.gui.image.dimensions", w, h);

            this.font.drawStringWithShadow(label, this.area.x(0.5F, this.font.getStringWidth(label)), this.area.y + 16, 0xaaaaaa);

            super.draw(context);
        }
    }
}

==================================================

--- Файл №507 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiLightMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster_pack.morphs.LightMorph;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAnimation;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiLightMorph extends GuiAbstractMorph<LightMorph>
{
    public GuiLightMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = new GuiLightMorph.GuiLightMorphPanel(mc, this);
        this.registerPanel(this.defaultPanel, IKey.lang("blockbuster.gui.light_morph.name"), Icons.GEAR);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof LightMorph;
    }

    public static class GuiLightMorphPanel extends GuiMorphPanel<LightMorph, GuiLightMorph>
    {
        private GuiTrackpadElement lightValue;
        private GuiAnimation animation;

        public GuiLightMorphPanel(Minecraft mc, GuiLightMorph editor)
        {
            super(mc, editor);

            this.animation = new GuiAnimation(mc, true);

            this.animation.flex().relative(this).x(1F, -130).w(130);
            this.animation.ignored.removeFromParent();

            this.lightValue = new GuiTrackpadElement(mc, (value) -> this.morph.setLightValue(value.intValue()));

            this.lightValue.integer().limit(0,15).tooltip(IKey.lang("blockbuster.gui.light_morph.light_value_tooltip"));

            GuiLabel lightLabel = Elements.label(IKey.lang("blockbuster.gui.light_morph.light_value"));

            GuiElement lightElements = Elements.column(mc, 3, 10, lightLabel, this.lightValue);
            lightElements.flex().relative(this.area).x(0.0F, 0).w(130);

            this.add(this.animation, lightElements);
        }

        @Override
        public void fillData(LightMorph morph)
        {
            super.fillData(morph);

            this.lightValue.setValue(morph.getLightValue());
            this.animation.fill(morph.getAnimation());
        }
    }
}


==================================================

--- Файл №508 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiParticleMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.blockbuster_pack.morphs.ParticleMorph;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.util.EnumParticleTypes;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;

@SideOnly(Side.CLIENT)
public class GuiParticleMorph extends GuiAbstractMorph<ParticleMorph>
{
    public GuiParticleMorphGeneralPanel general;
    public GuiParticleMorphMorphPanel panel;

    public GuiParticleMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.general = new GuiParticleMorphGeneralPanel(mc, this);
        this.panel = new GuiParticleMorphMorphPanel(mc, this);

        this.registerPanel(this.general, IKey.lang("blockbuster.gui.particle.tooltip"), BBIcons.PARTICLE);
        this.registerPanel(this.panel, IKey.lang("blockbuster.gui.particle.morph"), Icons.POSE);

        this.renderer.setVisible(false);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof ParticleMorph;
    }

    public static class GuiParticleMorphGeneralPanel extends GuiMorphPanel<ParticleMorph, GuiParticleMorph>
    {
        public GuiCirculateElement mode;
        public GuiTrackpadElement frequency;
        public GuiTrackpadElement duration;
        public GuiTrackpadElement delay;
        public GuiTrackpadElement cap;

        public GuiButtonElement pickParticle;
        public GuiStringListElement type;
        public GuiTrackpadElement x;
        public GuiTrackpadElement y;
        public GuiTrackpadElement z;
        public GuiTrackpadElement dx;
        public GuiTrackpadElement dy;
        public GuiTrackpadElement dz;
        public GuiTrackpadElement speed;
        public GuiTrackpadElement count;
        public GuiToggleElement localRotation;
        public GuiTextElement args;

        public GuiParticleMorphGeneralPanel(Minecraft mc, GuiParticleMorph editor)
        {
            super(mc, editor);

            this.mode = new GuiCirculateElement(mc, (b) ->
            {
                this.morph.mode = ParticleMorph.ParticleMode.values()[this.mode.getValue()];
            });
            this.mode.addLabel(IKey.lang("blockbuster.gui.particle.types.vanilla"));
            this.mode.addLabel(IKey.lang("blockbuster.gui.particle.types.morph"));

            this.mode.tooltip(IKey.lang("blockbuster.gui.particle.type"));
            this.frequency = new GuiTrackpadElement(mc, (value) -> this.morph.frequency = value.intValue());
            this.frequency.tooltip(IKey.lang("blockbuster.gui.particle.frequency"));
            this.frequency.limit(1, Integer.MAX_VALUE, true);
            this.duration = new GuiTrackpadElement(mc, (value) -> this.morph.duration = value.intValue());
            this.duration.tooltip(IKey.lang("blockbuster.gui.sequencer.duration"));
            this.duration.limit(-1, Integer.MAX_VALUE, true);
            this.delay = new GuiTrackpadElement(mc, (value) -> this.morph.delay = value.intValue());
            this.delay.tooltip(IKey.lang("blockbuster.gui.gun.delay"));
            this.delay.limit(0, Integer.MAX_VALUE, true);
            this.cap = new GuiTrackpadElement(mc, (value) -> this.morph.cap = value.intValue());
            this.cap.tooltip(IKey.lang("blockbuster.gui.particle.cap"));
            this.cap.limit(0, Integer.MAX_VALUE, true);

            this.pickParticle = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.particle.particle"), (b) -> this.type.toggleVisible());
            this.type = new GuiStringListElement(mc, (value) ->
            {
                this.morph.vanillaType = EnumParticleTypes.getByName(value.get(0));
            });
            this.type.background();

            for (EnumParticleTypes type : EnumParticleTypes.values())
            {
                this.type.add(type.getParticleName());
            }

            this.type.sort();

            this.x = new GuiTrackpadElement(mc, (value) -> this.morph.vanillaX = value);
            this.x.tooltip(IKey.lang("blockbuster.gui.model_block.x"));
            this.y = new GuiTrackpadElement(mc, (value) -> this.morph.vanillaY = value);
            this.y.tooltip(IKey.lang("blockbuster.gui.model_block.y"));
            this.z = new GuiTrackpadElement(mc, (value) -> this.morph.vanillaZ = value);
            this.z.tooltip(IKey.lang("blockbuster.gui.model_block.z"));
            this.dx = new GuiTrackpadElement(mc, (value) -> this.morph.vanillaDX = value);
            this.dx.tooltip(IKey.lang("blockbuster.gui.particle.dx"));
            this.dy = new GuiTrackpadElement(mc, (value) -> this.morph.vanillaDY = value);
            this.dy.tooltip(IKey.lang("blockbuster.gui.particle.dy"));
            this.dz = new GuiTrackpadElement(mc, (value) -> this.morph.vanillaDZ = value);
            this.dz.tooltip(IKey.lang("blockbuster.gui.particle.dz"));
            this.speed = new GuiTrackpadElement(mc, (value) -> this.morph.speed = value);
            this.speed.tooltip(IKey.lang("blockbuster.gui.particle.speed"));
            this.localRotation = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.particle.local_rotation"), (b) -> this.morph.localRotation = b.isToggled());
            this.localRotation.tooltip(IKey.lang("blockbuster.gui.particle.local_rotation_tooltip"));
            this.count = new GuiTrackpadElement(mc, (value) -> this.morph.count = value.intValue());
            this.count.tooltip(IKey.lang("blockbuster.gui.particle.count"));
            this.count.limit(1, Integer.MAX_VALUE, true);
            this.args = new GuiTextElement(mc, (value) ->
            {
                String[] splits = value.split(",");
                List<Integer> integerList = new ArrayList<Integer>();

                for (String split : splits)
                {
                    try
                    {
                        integerList.add(Integer.parseInt(split.trim()));
                    }
                    catch (Exception e) {}
                }

                int[] array = new int[integerList.size()];
                int i = 0;

                for (Integer integer : integerList)
                {
                    array[i ++] = integer;
                }

                this.morph.arguments = array;
            });

            this.type.flex().relative(this.pickParticle).set(0, 20, 0, 80).w(1F);

            GuiElement element = new GuiElement(mc);

            element.flex().relative(this).wh(1F, 1F).column(5).width(110).padding(10).height(20);
            element.add(this.mode, this.pickParticle);
            element.add(Elements.label(IKey.lang("blockbuster.gui.particle.emission")).marginTop(12), this.frequency, this.duration, this.delay, this.cap, this.speed, this.count);
            element.add(Elements.label(IKey.lang("blockbuster.gui.particle.vanilla")).marginTop(12), this.x, this.y, this.z);
            element.add(Elements.label(IKey.lang("blockbuster.gui.particle.common")).marginTop(12), this.dx, this.dy, this.dz);
            element.add(Elements.label(IKey.lang("blockbuster.gui.particle.args")).marginTop(12), this.args, this.localRotation);

            this.add(element, this.type);
        }

        @Override
        public void fillData(ParticleMorph morph)
        {
            super.fillData(morph);

            this.mode.setValue(morph.mode == ParticleMorph.ParticleMode.MORPH ? 1 : 0);
            this.frequency.setValue(morph.frequency);
            this.duration.setValue(morph.duration);
            this.delay.setValue(morph.delay);
            this.cap.setValue(morph.cap);

            this.type.setVisible(false);
            this.type.setCurrentScroll(morph.vanillaType == null ? "" : morph.vanillaType.getParticleName());
            this.x.setValue((float) morph.vanillaX);
            this.y.setValue((float) morph.vanillaY);
            this.z.setValue((float) morph.vanillaZ);
            this.dx.setValue((float) morph.vanillaDX);
            this.dy.setValue((float) morph.vanillaDY);
            this.dz.setValue((float) morph.vanillaDZ);
            this.speed.setValue((float) morph.speed);
            this.localRotation.toggled(morph.localRotation);
            this.count.setValue(morph.count);

            StringJoiner joiner = new StringJoiner(", ");

            for (int value : morph.arguments)
            {
                joiner.add(String.valueOf(value));
            }

            this.args.setText(joiner.toString());
        }
    }

    public static class GuiParticleMorphMorphPanel extends GuiMorphPanel<ParticleMorph, GuiParticleMorph>
    {
        public GuiNestedEdit pickMorph;
        public GuiButtonElement pickType;
        public GuiStringListElement type;
        public GuiToggleElement yaw;
        public GuiToggleElement pitch;
        public GuiToggleElement sequencer;
        public GuiToggleElement random;
        public GuiTrackpadElement fade;
        public GuiTrackpadElement lifeSpan;
        public GuiTrackpadElement maximum;

        public GuiParticleMorphMorphPanel(Minecraft mc, GuiParticleMorph editor)
        {
            super(mc, editor);

            this.pickMorph = new GuiNestedEdit(mc, (editing) ->
            {
                ParticleMorph particle = this.morph;

                this.editor.morphs.nestEdit(particle.morph, editing, (morph) ->
                {
                    particle.morph = MorphUtils.copy(morph);
                });
            });

            this.pickType = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.particle.pick_type"), (b) -> this.type.toggleVisible());
            this.pickType.tooltip(IKey.lang("blockbuster.gui.particle.pick_type_tooltip"), Direction.RIGHT);

            this.type = new GuiStringListElement(mc, (value) ->
            {
                this.morph.movementType = ParticleMorph.MorphParticle.MovementType.getType(value.get(0));
            });

            for (ParticleMorph.MorphParticle.MovementType type : ParticleMorph.MorphParticle.MovementType.values())
            {
                this.type.add(type.id);
            }

            this.type.sort();
            this.type.background();

            this.yaw = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.yaw"), false, (b) -> this.morph.yaw = this.yaw.isToggled());
            this.pitch = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.pitch"), false, (b) -> this.morph.pitch = this.pitch.isToggled());
            this.sequencer = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.sequencer"), false, (b) -> this.morph.sequencer = this.sequencer.isToggled());
            this.random = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.gun.random"), false, (b) -> this.morph.random = this.random.isToggled());
            this.fade = new GuiTrackpadElement(mc, (value) -> this.morph.fade = value.intValue());
            this.fade.tooltip(IKey.lang("blockbuster.gui.particle.fade"));
            this.fade.limit(0, Integer.MAX_VALUE, true);
            this.lifeSpan = new GuiTrackpadElement(mc, (value) -> this.morph.lifeSpan = value.intValue());
            this.lifeSpan.tooltip(IKey.lang("blockbuster.gui.gun.life_span"));
            this.lifeSpan.limit(0, Integer.MAX_VALUE, true);
            this.maximum = new GuiTrackpadElement(mc, (value) -> this.morph.maximum = value.intValue());
            this.maximum.tooltip(IKey.lang("blockbuster.gui.particle.maximum"));
            this.maximum.limit(1, Integer.MAX_VALUE, true);

            this.type.flex().relative(this.pickType).set(0, 20, 0, 80).w(1F);

            GuiElement element = new GuiElement(mc);

            element.flex().relative(this).wh(1F, 1F).column(5).width(110).padding(10).height(20);
            element.add(Elements.label(IKey.lang("blockbuster.gui.particle.morph")), this.pickMorph, this.pickType, this.fade, this.lifeSpan, this.maximum, this.yaw, this.pitch, this.sequencer, this.random);

            this.add(element, this.type);
        }

        @Override
        public void fillData(ParticleMorph morph)
        {
            super.fillData(morph);

            this.type.setVisible(false);
            this.type.setCurrentScroll(morph.movementType.id);
            this.yaw.toggled(morph.yaw);
            this.pitch.toggled(morph.pitch);
            this.sequencer.toggled(morph.sequencer);
            this.random.toggled(morph.random);
            this.fade.setValue(morph.fade);
            this.lifeSpan.setValue(morph.lifeSpan);
            this.maximum.setValue(morph.maximum);
        }
    }
}

==================================================

--- Файл №509 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiPosePanel.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import java.util.List;
import java.util.function.BiConsumer;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.tabs.GuiModelPoses;
import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiPoseTransformations;
import mchorse.blockbuster.client.gui.utils.GuiShapeKeysEditor;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.blockbuster_pack.morphs.CustomMorph.LimbProperties;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.metamorph.client.gui.editor.GuiAnimation;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiPosePanel extends GuiMorphPanel<CustomMorph, GuiCustomMorph> implements ILimbSelector
{
    /* Custom pose editor */
    public GuiButtonElement reset;
    public GuiButtonElement create;
    public GuiStringListElement list;
    public GuiToggleElement absoluteBrightness;
    public GuiTrackpadElement glow;
    public GuiColorElement color;
    public GuiToggleElement fixed;
    public GuiToggleElement poseOnSneak;
    public GuiPoseTransformations transforms;

    public GuiAnimation animation;
    public GuiShapeKeysEditor shapeKeys;

    /* General options */
    public GuiStringListElement models;
    public GuiButtonElement model;
    public GuiTrackpadElement scale;
    public GuiTrackpadElement scaleGui;
    
    public LimbProperties currentLimbProp;

    public GuiPosePanel(Minecraft mc, GuiCustomMorph editor)
    {
        super(mc, editor);

        /* Custom pose editor */
        this.reset = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.morphs.reset"), (b) ->
        {
            if (this.morph.customPose == null)
            {
                this.morph.currentPose = "";
                this.list.setIndex(-1);
            }
            else
            {
                this.editor.morph.customPose = null;
                this.editor.bbRenderer.limb = null;
                this.updateList();
                this.updateElements();
            }

            this.editor.updateModelRenderer();
        });
        this.reset.flex().relative(this).xy(10, 10).w(110);

        this.create = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.morphs.create"), (b) ->
        {
            if (this.morph.customPose == null)
            {
                this.morph.customPose = this.morph.convertProp(this.morph.getPose(this.mc.player, 0).copy());
            }

            this.updateList();
            this.updateElements();
            this.editor.updateModelRenderer();
        });
        this.create.flex().relative(this.reset).y(25).w(110);

        this.poseOnSneak = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.builder.pose_sneak"), false, (b) ->
        {
            this.morph.currentPoseOnSneak = this.poseOnSneak.isToggled();
            this.editor.updateModelRenderer();
        });
        this.poseOnSneak.flex().relative(this).x(10).y(1F, -24).w(110);

        this.list = new GuiStringListElement(mc, (str) ->
        {
            if (this.morph.customPose == null)
            {
                this.morph.currentPose = str.get(0);
                this.editor.updateModelRenderer();
            }
            else
            {
                this.setLimb(str.get(0));
            }
        });
        this.list.background();
        this.list.flex().xy(0, 40).w(110).hTo(this.poseOnSneak.area, -5);
        this.list.context(this::limbContextMenu);

        this.transforms = new GuiPoseTransformations(mc);
        this.transforms.flex().relative(this.area).set(0, 0, 256, 70).x(0.5F, -128).y(1, -75);

        this.animation = new GuiAnimation(mc, true);
        this.animation.flex().relative(this).x(1F, -130).w(130);
        this.animation.interpolations.removeFromParent();

        /* General options */
        this.model = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.builder.pick_model"), (b) -> this.models.toggleVisible());
        this.scale = new GuiTrackpadElement(mc, (value) ->
        {
            this.morph.scale = value.floatValue();
        });
        this.scale.tooltip(IKey.lang("blockbuster.gui.me.options.scale"));
        this.scaleGui = new GuiTrackpadElement(mc, (value) ->
        {
            this.morph.scaleGui = value.floatValue();
        });
        this.scaleGui.tooltip(IKey.lang("blockbuster.gui.me.options.scale_gui"));

        this.models = new GuiStringListElement(mc, (string) ->
        {
            this.morph.changeModel(string.get(0));
            this.editor.updateModelRenderer();
            this.editor.poseEditor.fillData(this.morph);
            this.editor.bodyPart.setLimbs(this.morph.model.limbs.keySet());
        });
        this.models.background();
        this.models.flex().relative(this.model).w(1F).h(96).anchorY(1F);

        GuiElement options = new GuiElement(mc);

        options.flex().relative(this).x(1F, -130).y(1F).w(130).anchorY(1F).column(5).vertical().stretch().height(20).padding(10);
        options.add(this.model, this.scale, this.scaleGui);

        this.fixed = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.builder.limb.fixed"), (b) ->
        {
            this.currentLimbProp.fixed = this.fixed.isToggled() ? 1F : 0F;
        });
        this.fixed.flex().relative(this.model).x(0F).y(0F, -20).w(1F);

        this.color = new GuiColorElement(mc, (color) ->
        {
            this.currentLimbProp.color.set(color);
        }).direction(Direction.LEFT);
        this.color.flex().relative(this.fixed).x(0F).y(0F, -25).w(1F).h(20);
        this.color.picker.editAlpha();
        this.color.tooltip(IKey.lang("blockbuster.gui.builder.limb.color"));

        this.glow = new GuiTrackpadElement(mc, (value) ->
        {
            this.currentLimbProp.glow = value.floatValue();
        }).limit(0, 1).values(0.01, 0.001, 0.1);
        this.glow.flex().relative(this.color).x(0F).y(0F, -30).w(1F);
        this.glow.tooltip(IKey.lang("blockbuster.gui.builder.limb.glow"));

        this.absoluteBrightness = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.builder.limb.absolute_brighness"), (b) ->
        {
            this.currentLimbProp.absoluteBrightness = this.absoluteBrightness.isToggled();
        });
        this.absoluteBrightness.flex().relative(this.glow).x(0F).y(0F, -30).w(1F);

        GuiSimpleContextMenu abMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        GuiSimpleContextMenu glowMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        GuiSimpleContextMenu colorMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        GuiSimpleContextMenu fixateMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());

        abMenu.action(IKey.lang("blockbuster.gui.builder.context.children"), this.applyToChildren((p, c) -> c.absoluteBrightness = p.absoluteBrightness));
        glowMenu.action(IKey.lang("blockbuster.gui.builder.context.children"), this.applyToChildren((p, c) -> c.glow = p.glow));
        colorMenu.action(IKey.lang("blockbuster.gui.builder.context.children"), this.applyToChildren((p, c) -> c.color.copy(p.color)));
        fixateMenu.action(IKey.lang("blockbuster.gui.builder.context.children"), this.applyToChildren((p, c) -> c.fixed = p.fixed));

        this.absoluteBrightness.context(() -> abMenu);
        this.glow.context(() -> glowMenu);
        this.color.context(() -> colorMenu);
        this.fixed.context(() -> fixateMenu);

        this.shapeKeys = new GuiShapeKeysEditor(mc, () -> this.morph.model);
        this.shapeKeys.flex().relative(this.poseOnSneak).y(-125).w(1F).h(120);

        this.add(this.reset, this.create, this.poseOnSneak, this.shapeKeys, this.list, this.animation, options, this.fixed, this.color, this.glow, this.absoluteBrightness, this.transforms, this.models, this.animation.interpolations);
    }

    private GuiContextMenu limbContextMenu()
    {
        if (this.morph.customPose == null)
        {
            return null;
        }

        return GuiModelPoses.createCopyPasteMenu(this::copyPose, this::pastePose);
    }

    private void copyPose()
    {
        GuiScreen.setClipboardString(this.morph.customPose.toNBT(new NBTTagCompound()).toString());
    }

    private void pastePose(ModelPose pose)
    {
        ModelPose currentPose = this.morph.model.getPose(this.morph.currentPose);

        this.morph.customPose.copy(pose);
        this.transforms.set(this.transforms.trans, currentPose == null ? null : currentPose.limbs.get(this.list.getCurrentFirst()));
        this.updateShapeKeys();
    }

    private Runnable applyToChildren(BiConsumer<LimbProperties, LimbProperties> apply)
    {
        return () ->
        {
            String bone = this.list.getCurrentFirst();
            LimbProperties anim = (LimbProperties) this.morph.customPose.limbs.get(bone);
            List<String> children = this.morph.model.getChildren(bone);

            for (String child : children)
            {
                LimbProperties childAnim = (LimbProperties) this.morph.customPose.limbs.get(child);

                apply.accept(anim, childAnim);
            }
        };
    }

    private void updateShapeKeys()
    {
        this.shapeKeys.setVisible(!morph.model.shapes.isEmpty() && this.morph.customPose != null);

        if (this.shapeKeys.isVisible())
        {
            this.shapeKeys.fillData(this.morph.getCurrentPose().shapes);
            this.list.flex().xy(0, 40).w(110).hTo(this.shapeKeys.area, -10);
        }
        else
        {
            this.list.flex().xy(0, 40).w(110).hTo(this.poseOnSneak.area, -5);
        }

        this.resize();
    }

    @Override
    public void setLimb(String limbName)
    {
        if (this.morph.customPose == null)
        {
            return;
        }

        ModelLimb limb = this.morph.model.limbs.get(limbName);
        ModelPose pose = this.morph.model.getPose(this.morph.currentPose);

        this.editor.bbRenderer.limb = limb;
        this.list.setCurrent(limbName);
        this.currentLimbProp = (LimbProperties) this.morph.customPose.limbs.get(limbName);
        this.transforms.set(this.currentLimbProp, pose == null ? null : pose.limbs.get(limbName));
        this.absoluteBrightness.toggled(this.currentLimbProp.absoluteBrightness);
        this.glow.setValue(this.currentLimbProp.glow);
        this.color.picker.setColor(this.currentLimbProp.color.getRGBAColor());
        this.fixed.toggled(this.currentLimbProp.fixed != 0F);
    }

    @Override
    public void fillData(CustomMorph morph)
    {
        super.fillData(morph);

        this.updateList();
        this.updateElements();

        this.poseOnSneak.toggled(morph.currentPoseOnSneak);
        this.animation.fill(morph.animation);

        this.scale.setValue(morph.scale);
        this.scaleGui.setValue(morph.scaleGui);

        this.models.setVisible(false);
        this.models.clear();
        this.models.add(Blockbuster.proxy.models.models.keySet());
        this.models.sort();
        this.models.setCurrentScroll(morph.getKey());
    }

    @Override
    public void startEditing()
    {
        super.startEditing();

        this.updateList();
        this.updateElements();
    }

    private void updateElements()
    {
        this.create.setVisible(this.morph.customPose == null);
        this.transforms.setVisible(this.morph.customPose != null);
        this.list.flex().relative(this.morph.customPose == null ? this.create : this.reset);
        this.list.resize();
        this.absoluteBrightness.setVisible(this.morph.customPose != null);
        this.glow.setVisible(this.morph.customPose != null);
        this.color.setVisible(this.morph.customPose != null);
        this.fixed.setVisible(this.morph.customPose != null);

        this.updateShapeKeys();
    }

    private void updateList()
    {
        String current;

        this.list.clear();

        if (this.morph.customPose == null)
        {
            current = this.morph.currentPose;
            this.list.add(this.morph.model.poses.keySet());
            this.list.sort();
        }
        else
        {
            this.list.add(this.morph.model.limbs.keySet());
            this.list.sort();
            this.list.setIndex(0);
            current = this.list.getCurrentFirst();

            if (!this.list.isDeselected())
            {
                this.setLimb(this.list.getCurrentFirst());
            }
        }

        this.list.setCurrent(current);
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.morph.customPose == null)
        {
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.builder.pose"), this.list.area.x, this.list.area.y - 12, 0xffffff);
        }
        else
        {
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.builder.limbs"), this.list.area.x, this.list.area.y - 12, 0xffffff);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №510 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiRecordMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster_pack.morphs.RecordMorph;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringSearchListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphs;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiRecordMorph extends GuiAbstractMorph<RecordMorph>
{
    public GuiRecordMorphPanel general;

    public GuiRecordMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.general = new GuiRecordMorphPanel(mc, this);
        this.registerPanel(this.general, IKey.lang("blockbuster.morph.record"), Icons.GEAR);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof RecordMorph;
    }

    @SideOnly(Side.CLIENT)
    public static class GuiRecordMorphPanel extends GuiMorphPanel<RecordMorph, GuiRecordMorph>
    {
        private GuiStringSearchListElement records;
        private GuiNestedEdit pick;
        private GuiToggleElement loop;
        private GuiTrackpadElement randomSkip;

        public GuiRecordMorphPanel(Minecraft mc, GuiRecordMorph editor)
        {
            super(mc, editor);

            this.records = new GuiStringSearchListElement(mc, (str) -> this.morph.setRecord(str.get(0)));
            this.records.list.background();
            this.pick = new GuiNestedEdit(mc, (editing) ->
            {
                RecordMorph record = this.morph;

                this.editor.morphs.nestEdit(record.initial, editing, (morph) ->
                {
                    record.initial = MorphUtils.copy(morph);
                    ((GuiMorphRenderer) this.editor.renderer).morph = record.initial;
                });
            });
            this.loop = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.director.loops"), true, (b) ->
            {
                this.morph.loop = this.loop.isToggled();
            });
            this.randomSkip = new GuiTrackpadElement(mc, (value) -> this.morph.randomSkip = value.intValue());
            this.randomSkip.tooltip(IKey.lang("blockbuster.gui.record_morph.random_skip"));
            this.randomSkip.limit(0, Integer.MAX_VALUE, true);

            GuiElement element = new GuiElement(mc);

            element.flex().relative(this).y(1F).w(130).anchorY(1F).column(5).stretch().vertical().height(20).padding(10);
            element.add(this.pick, this.loop, this.randomSkip);

            this.records.flex().relative(this).set(10, 25, 110, 20).hTo(element.flex());

            this.add(element, this.records);
        }

        @Override
        public void fillData(RecordMorph morph)
        {
            super.fillData(morph);

            this.records.list.clear();

            if (ClientProxy.panels.recordingEditorPanel != null)
            {
                this.records.list.add(ClientProxy.panels.recordingEditorPanel.records.records.list.getList());
                this.records.filter("", true);
            }

            this.records.list.setCurrent(morph.record);
            this.loop.toggled(morph.loop);
            this.randomSkip.setValue(morph.randomSkip);

            ((GuiMorphRenderer) this.editor.renderer).morph = morph.initial;

            this.records.resize();
        }

        @Override
        public void draw(GuiContext context)
        {
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.director.id"), this.records.area.x, this.records.area.y - 12, 0xcccccc);
            super.draw(context);
        }
    }
}

==================================================

--- Файл №511 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiSequencerMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.gui.GuiImmersiveMorphMenu;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster_pack.morphs.SequencerMorph;
import mchorse.blockbuster_pack.morphs.SequencerMorph.SequenceEntry;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.tooltips.LabelTooltip;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.MathUtils;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList;
import mchorse.metamorph.client.gui.creative.GuiCreativeMorphsList.OnionSkin;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import mchorse.metamorph.client.gui.creative.GuiNestedEdit;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;

@SideOnly(Side.CLIENT)
public class GuiSequencerMorph extends GuiAbstractMorph<SequencerMorph>
{
    public GuiSequencerMorphPanel general;

    public GuiSequencerMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.general = new GuiSequencerMorphPanel(mc, this);
        this.registerPanel(this.general, IKey.lang("blockbuster.morph.sequencer"), Icons.GEAR);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof SequencerMorph;
    }

    @Override
    protected GuiModelRenderer createMorphRenderer(Minecraft mc)
    {
        return new GuiSequencerMorphRenderer(mc);
    }

    @Override
    public int getCurrentTick()
    {
        return this.general.getCurrentTick();
    }

    /**
     * Sequencer morph panel 
     */
    public static class GuiSequencerMorphPanel extends GuiMorphPanel<SequencerMorph, GuiSequencerMorph>
    {
        public GuiElement elements;
        public GuiElement elementsTop;

        private GuiListElement<SequenceEntry> list;
        private GuiButtonElement addPart;
        private GuiButtonElement removePart;

        private GuiTrackpadElement loop;
        private GuiTrackpadElement offsetX;
        private GuiTrackpadElement offsetY;
        private GuiTrackpadElement offsetZ;
        private GuiTrackpadElement offsetCount;
        
        private GuiNestedEdit pick;
        private GuiTrackpadElement duration;
        private GuiTrackpadElement random;
        private GuiToggleElement setDuration;
        private GuiToggleElement endPoint;
        private GuiToggleElement reverse;
        private GuiToggleElement randomOrder;
        private GuiToggleElement trulyRandomOrder;
        private GuiToggleElement keepProgress;

        public SequenceEntry entry;

        /* Playback preview */
        public GuiTrackpadElement preview;
        public GuiIconElement plause;
        public GuiIconElement stop;
        public GuiElement previewBar;

        public GuiButtonElement generateMorph;

        /* Onion skins */
        public GuiTrackpadElement prevSkins;
        public GuiColorElement prevColor;
        public GuiTrackpadElement nextSkins;
        public GuiColorElement nextColor;
        public GuiColorElement loopColor;

        public GuiSequencerMorphRenderer previewRenderer;

        private boolean isFrameSkin;
        private Vec3d offsetSkinPos;
        private OnionSkin offsetSkin;

        public GuiSequencerMorphPanel(Minecraft mc, GuiSequencerMorph editor)
        {
            super(mc, editor);

            this.elements = new GuiElement(mc);
            this.elements.flex().relative(this).xy(1F, 1F).w(130).anchor(1F, 1F).column(5).vertical().stretch().padding(10);

            this.elementsTop = new GuiElement(mc);
            this.elementsTop.flex().relative(this).xy(1F, 0F).w(130).anchor(1F, 0F).column(5).vertical().stretch().padding(10);

            this.list = new GuiSequenceEntryList(mc, (entry) -> 
            {
                this.select(entry.get(0));
                
                this.stopPlayback();
            });
            this.list.sorting().background();
            this.addPart = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.add"), (b) ->
            {
                SequenceEntry current = this.list.getCurrentFirst();
                SequenceEntry entry = new SequenceEntry(current == null ? null : MorphUtils.copy(current.morph));

                if (current != null)
                {
                    entry.duration = current.duration;
                    entry.random = current.random;
                }

                if (GuiScreen.isCtrlKeyDown())
                {
                    this.list.getList().add(this.list.getIndex() + 1, entry);
                    this.list.setIndex(this.list.getIndex() + 1);
                }
                else
                {
                    this.list.getList().add(entry);
                    this.list.setIndex(this.list.getList().size() - 1);
                }

                this.select(entry);
                this.list.update();

                this.stopPlayback();
            });
            this.addPart.tooltip(IKey.lang("blockbuster.gui.sequencer.add_part_tooltip"));

            this.removePart = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.remove"), (b) ->
            {
                if (!this.list.isDeselected())
                {
                    int index = this.list.getIndex();

                    this.list.getList().remove(index);
                    this.list.setIndex(index - 1);

                    this.select(this.list.getCurrentFirst());
                    this.list.update();

                    this.stopPlayback();
                }
            });
            
            this.loop = new GuiTrackpadElement(mc, (value) -> 
            {
                this.morph.loop = value.intValue();
                this.stopPlayback();
            });
            this.loop.tooltip(IKey.lang("blockbuster.gui.sequencer.loop_tooltip"));
            this.loop.integer().limit(0);

            this.offsetX = new GuiTrackpadElement(mc, (value) -> 
            {
                this.morph.offset[0] = value.floatValue();
                this.stopPlayback();
                this.updateOnionSkins();
            });
            this.offsetX.tooltip(IKey.lang("mclib.gui.transforms.x"));

            this.offsetY = new GuiTrackpadElement(mc, (value) -> 
            {
                this.morph.offset[1] = value.floatValue();
                this.stopPlayback();
                this.updateOnionSkins();
            });
            this.offsetY.tooltip(IKey.lang("mclib.gui.transforms.y"));

            this.offsetZ = new GuiTrackpadElement(mc, (value) -> 
            {
                this.morph.offset[2] = value.floatValue();
                this.stopPlayback();
                this.updateOnionSkins();
            });
            this.offsetZ.tooltip(IKey.lang("mclib.gui.transforms.z"));

            this.offsetCount = new GuiTrackpadElement(mc, (value) -> 
            {
                this.morph.offsetCount = value.intValue();
                this.stopPlayback();
                this.updateOnionSkins();
            });
            this.offsetCount.tooltip(IKey.lang("blockbuster.gui.sequencer.loop_offset_count"));
            this.offsetCount.integer().limit(0);

            this.pick = new GuiNestedEdit(mc, (editing) ->
            {
                if (this.entry == null)
                {
                    return;
                }

                SequenceEntry entry = this.entry;

                if (entry.morph instanceof SequencerMorph)
                {
                    this.editor.morphs.onionSkins.clear();
                }

                this.editor.morphs.nestEdit(entry.morph, editing, true, (morph) ->
                {
                    entry.morph = MorphUtils.copy(morph);
                });
            });

            this.duration = new GuiTrackpadElement(mc, (value) ->
            {
                if (this.entry != null)
                {
                    this.morph.current = -1;
                    this.morph.timer = 0;
                    this.morph.duration = 0;
                    this.morph.loopCount = 0;
                    this.morph.lastUpdate = 0;

                    this.entry.duration = value.floatValue();
                    this.stopPlayback();
                    this.updateOnionSkins();
                }
            });
            this.duration.tooltip(IKey.lang("blockbuster.gui.sequencer.duration"));
            this.duration.limit(0, Float.MAX_VALUE);

            this.random = new GuiTrackpadElement(mc, (value) ->
            {
                if (this.entry != null)
                {
                    this.morph.current = -1;
                    this.morph.timer = 0;
                    this.morph.duration = 0;
                    this.morph.loopCount = 0;
                    this.morph.lastUpdate = 0;

                    this.entry.random = value.floatValue();
                    this.stopPlayback();
                    this.updateOnionSkins();
                }
            });
            this.random.tooltip(IKey.lang("blockbuster.gui.sequencer.random"));
            this.random.limit(0, Float.MAX_VALUE);
            this.setDuration = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.sequencer.set_duration"), (b) -> this.entry.setDuration = b.isToggled());
            this.setDuration.tooltip(IKey.lang("blockbuster.gui.sequencer.set_duration_tooltip"), Direction.TOP);

            this.endPoint = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.sequencer.end_point"), (b) -> this.entry.endPoint = b.isToggled());
            this.endPoint.tooltip(IKey.lang("blockbuster.gui.sequencer.end_point_tooltip"), Direction.TOP);

            this.reverse = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.sequencer.reverse"), false, (b) ->
            {
                this.morph.reverse = b.isToggled();
                this.stopPlayback();
                this.updateOnionSkins();
            });

            this.randomOrder = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.sequencer.random_order"), false, (b) ->
            {
                this.morph.isRandom = b.isToggled();
                this.stopPlayback();
                this.updatePreviewBar();
                this.updateOnionSkins();
            });

            this.trulyRandomOrder = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.sequencer.truly_random_order"), false, (b) ->
            {
                this.morph.isTrulyRandom = b.isToggled();
                this.stopPlayback();
                this.updatePreviewBar();
            });

            this.keepProgress = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.sequencer.keep_progress"), false, (b) -> this.morph.keepProgress = b.isToggled());

            this.addPart.flex().relative(this.area).set(10, 10, 50, 20);
            this.removePart.flex().relative(this.addPart.resizer()).set(55, 0, 50, 20);
            this.list.flex().relative(this.area).set(10, 50, 105, 0).hTo(this.reverse.area, -5);
            this.keepProgress.flex().relative(this).x(10).y(1F, -24).w(105);
            this.randomOrder.flex().relative(this.keepProgress).y(-1F, -5).w(1F);
            this.trulyRandomOrder.flex().relative(this.randomOrder).y(-1F, -5).w(1F);
            this.reverse.flex().relative(this.trulyRandomOrder).y(-1F, -5).w(1F);

            /* Playback preview code */
            this.preview = new GuiTrackpadElement(mc, (value) -> this.previewTick(value.floatValue()));
            this.preview.limit(0).metric().tooltip(IKey.lang("blockbuster.gui.sequencer.preview_tick"));
            this.plause = new GuiIconElement(mc, Icons.PLAY, (b) -> this.togglePlay());
            this.plause.tooltip(IKey.lang("blockbuster.gui.sequencer.keys.toggle")).flex().wh(16, 20);
            this.stop = new GuiIconElement(mc, Icons.STOP, (b) -> this.stopPlayback());
            this.stop.tooltip(IKey.lang("blockbuster.gui.sequencer.keys.stop")).flex().wh(16, 20);

            this.previewBar = new GuiElement(mc);

            this.previewBar.flex().relative(this).x(130).y(10).wTo(this.elementsTop.flex()).h(20).row(5).preferred(1);
            this.previewBar.add(this.plause, this.preview, this.stop);

            this.generateMorph = new GuiButtonElement(mc, IKey.lang("blockbuster.gui.sequencer.generate_morph"), (element) ->
            {
                SequencerMorph previewer = GuiSequencerMorphRenderer.PREVIEWER;
                AbstractMorph morph = previewer.getMorph();

                if (morph instanceof IMorphGenerator)
                {
                    float progress = this.previewRenderer.partialTicks + previewer.timer - previewer.lastDuration;
                    float duration = previewer.duration - previewer.lastDuration;
                    float partialTicks;

                    if (previewer.morphSetDuration)
                    {
                        if (duration > 0)
                        {
                            partialTicks = progress * (float) Math.ceil(duration) / duration;
                            partialTicks -= (int) partialTicks;
                        }
                        else
                        {
                            partialTicks = 1;
                        }
                    }
                    else
                    {
                        partialTicks = progress - (int) progress;
                    }

                    morph = ((IMorphGenerator) morph).genCurrentMorph(partialTicks);
                    this.setMorphDuration(morph, (int) Math.min(progress, duration));

                    SequenceEntry entry = new SequenceEntry(morph);
                    entry.duration = Math.min(progress, duration);
                    entry.setDuration = true;

                    this.list.getList().add(entry);
                    this.list.setIndex(this.list.getList().size() - 1);

                    this.select(entry);
                    this.list.update();

                    this.stopPlayback();
                }
            });
            this.generateMorph.flex().relative(this).x(0.5F).y(1.0F, -20).wh(100, 30).anchor(0.5F, 1.0F);
            this.generateMorph.tooltip(IKey.lang("blockbuster.gui.sequencer.generate_morph_tooltip"));

            this.prevSkins = new GuiTrackpadElement(mc, Blockbuster.seqOnionSkinPrev, (value) -> this.updateOnionSkins()).limit(0, 10, true);
            this.prevSkins.tooltip(IKey.lang(Blockbuster.seqOnionSkinPrev.getLabelKey()));

            this.prevColor = new GuiColorElement(mc, Blockbuster.seqOnionSkinPrevColor, (value) -> this.updateOnionSkins()).noLabel();
            this.prevColor.tooltip(IKey.lang(Blockbuster.seqOnionSkinPrevColor.getLabelKey()));

            this.nextSkins = new GuiTrackpadElement(mc, Blockbuster.seqOnionSkinNext, (value) -> this.updateOnionSkins()).limit(0, 10, true);
            this.nextSkins.tooltip(IKey.lang(Blockbuster.seqOnionSkinNext.getLabelKey()));

            this.nextColor = new GuiColorElement(mc, Blockbuster.seqOnionSkinNextColor, (value) -> this.updateOnionSkins()).noLabel();
            this.nextColor.tooltip(IKey.lang(Blockbuster.seqOnionSkinNextColor.getLabelKey()));

            this.loopColor = new GuiColorElement(mc, Blockbuster.seqOnionSkinLoopColor, (value) -> this.updateOnionSkins()).noLabel();
            this.loopColor.tooltip(IKey.lang(Blockbuster.seqOnionSkinLoopColor.getLabelKey()));

            this.elements.add(this.pick, this.duration, this.random, this.setDuration, this.endPoint);
            this.elementsTop.add(Elements.label(IKey.lang("blockbuster.config.onion_skin.title")), this.combinElements(this.prevSkins, this.prevColor), this.combinElements(this.nextSkins, this.nextColor), 
                    Elements.label(IKey.lang("blockbuster.gui.sequencer.loop")), this.loop, Elements.label(IKey.lang("blockbuster.gui.sequencer.loop_offset")), this.offsetX, this.offsetY, this.offsetZ, this.combinElements(this.offsetCount, this.loopColor));
            this.add(this.addPart, this.removePart, this.keepProgress, this.randomOrder, this.trulyRandomOrder, this.reverse, this.list, this.elements, this.elementsTop, this.previewBar, this.generateMorph);

            this.keys().register(((LabelTooltip) this.plause.tooltip).label, Keyboard.KEY_SPACE, () -> this.plause.clickItself(GuiBase.getCurrent()))
                .held(Keyboard.KEY_LSHIFT)
                .category(GuiAbstractMorph.KEY_CATEGORY);
            this.keys().register(((LabelTooltip) this.stop.tooltip).label, Keyboard.KEY_SPACE, () -> this.stop.clickItself(GuiBase.getCurrent()))
                .held(Keyboard.KEY_LMENU)
                .category(GuiAbstractMorph.KEY_CATEGORY);

            this.previewRenderer = (GuiSequencerMorphRenderer) editor.renderer; 
        }

        private void select(SequenceEntry entry)
        {
            this.entry = entry;

            if (entry != null)
            {
                this.pick.setMorph(entry.morph);
                this.duration.setValue(entry.duration);
                this.random.setValue(entry.random);
                this.setDuration.toggled(entry.setDuration);
                this.endPoint.toggled(entry.endPoint);

                ((GuiMorphRenderer) this.editor.renderer).morph = entry.morph;

                if (entry.morph instanceof IAnimationProvider)
                {
                    ((IAnimationProvider) entry.morph).getAnimation().reset();
                }
            }
            else
            {
                ((GuiMorphRenderer) this.editor.renderer).morph = null;
            }

            this.elements.setVisible(entry != null);
            this.updateOnionSkins();
        }

        /* Playback preview */

        private void previewTick(float ticks)
        {
            this.previewRenderer.tick = (int) ticks;
            this.previewRenderer.partialTicks = ticks - this.previewRenderer.tick;

            if (this.previewRenderer.playing)
            {
                this.togglePlay();
            }

            this.updatePreviewMorph();
        }

        private void togglePlay()
        {
            this.previewRenderer.playing = !this.previewRenderer.playing;

            

            this.updatePlauseButton();
            this.updatePreviewMorph();
        }

        private void updatePlauseButton()
        {
            this.plause.both(this.previewRenderer.playing ? Icons.PAUSE : Icons.PLAY);
        }

        private void stopPlayback()
        {
            this.previewRenderer.tick = 0;
            this.previewRenderer.partialTicks = 0F;
            this.previewRenderer.playing = false;
            this.updatePlauseButton();
            this.preview.setValue(0);

            if (this.previewRenderer.morph == GuiSequencerMorphRenderer.PREVIEWER)
            {
                this.list.setIndex(0);
                this.select(this.list.getCurrentFirst());
            }
        }

        private void updatePreviewMorph()
        {
            if (this.entry != null)
            {
                this.list.setIndex(-1);
                this.select(null);
            }
            
            if (this.previewRenderer.morph != GuiSequencerMorphRenderer.PREVIEWER)
            {
                GuiSequencerMorphRenderer.PREVIEWER.reset();
                GuiSequencerMorphRenderer.PREVIEWER.copy(this.morph);
                this.previewRenderer.morph = GuiSequencerMorphRenderer.PREVIEWER;
            }

            GuiSequencerMorphRenderer.PREVIEWER.pause(null, this.previewRenderer.tick);
            GuiSequencerMorphRenderer.PREVIEWER.resume();
        }
        
        private void updatePreviewBar()
        {
            boolean visible = !this.morph.isRandom || !this.morph.isTrulyRandom;
            
            this.previewBar.setVisible(visible);
            this.plause.setEnabled(visible);
            this.stop.setEnabled(visible);
        }

        private void resetPlayback()
        {
            this.stopPlayback();
            this.updatePreviewMorph();
        }

        @Override
        public void fillData(SequencerMorph morph)
        {
            super.fillData(morph);

            this.resetPlayback();

            this.list.setList(morph.morphs);
            this.list.setIndex(0);
            this.select(this.list.getCurrentFirst());

            this.reverse.toggled(morph.reverse);
            this.randomOrder.toggled(morph.isRandom);
            this.trulyRandomOrder.toggled(morph.isTrulyRandom);
            this.keepProgress.toggled(morph.keepProgress);

            this.loop.setValue(morph.loop);
            this.offsetX.setValue(morph.offset[0]);
            this.offsetY.setValue(morph.offset[1]);
            this.offsetZ.setValue(morph.offset[2]);
            this.offsetCount.setValue(morph.offsetCount);

            this.updatePreviewBar();
        }

        @Override
        public void startEditing()
        {
            this.updateOnionSkins();
        }

        @Override
        public void draw(GuiContext context)
        {
            this.updateLogic(context);
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.sequencer.morphs"), this.list.area.x, this.list.area.y - 12, 0xffffff);

            super.draw(context);
        }

        private void updateLogic(GuiContext context)
        {
            double tick = this.previewRenderer.tick + this.previewRenderer.partialTicks;

            if (Math.abs(this.preview.value - tick) > 0.01D)
            {
                this.preview.setValue(tick);
            }

            boolean canGenerate = false;

            if (this.previewRenderer.morph == GuiSequencerMorphRenderer.PREVIEWER && !this.previewRenderer.playing)
            {
                AbstractMorph morph = GuiSequencerMorphRenderer.PREVIEWER.getMorph();

                if (morph instanceof IMorphGenerator)
                {
                    canGenerate = ((IMorphGenerator) morph).canGenerate();
                }
            }

            this.generateMorph.setVisible(canGenerate);

            GuiCreativeMorphsList editor = this.editor.morphs;

            if (editor instanceof GuiImmersiveMorphMenu && ((GuiImmersiveMorphMenu) editor).getFrame(0) != null)
            {
                if (!this.isFrameSkin)
                {
                    this.updateOnionSkins();
                }
            }
            else
            {
                for (OnionSkin skin : editor.onionSkins)
                {
                    if (this.previewRenderer.customEntity)
                    {
                        skin.pitch = this.previewRenderer.entityPitch;
                        skin.yawHead = this.previewRenderer.entityYawHead;
                        skin.yawBody = this.previewRenderer.entityYawBody;
                    }
                    else
                    {
                        skin.pitch = 0F;
                        skin.yawHead = 0F;
                        skin.yawBody = 0F;
                    }

                    if (skin == this.offsetSkin)
                    {
                        Vec3d pos = this.offsetSkinPos.rotateYaw((float) -Math.toRadians(skin.yawBody));

                        skin.offset.set(pos.x, pos.y, pos.z);
                    }
                }
            }
        }

        public void setMorphDuration(AbstractMorph morph, int duration)
        {
            if (morph instanceof IAnimationProvider)
            {
                Animation animation = ((IAnimationProvider) morph).getAnimation();

                animation.duration = duration;
                animation.reset();
            }
            
            if (morph instanceof IBodyPartProvider)
            {
                for (BodyPart part : ((IBodyPartProvider) morph).getBodyPart().parts)
                {
                    this.setMorphDuration(part.morph.get(), duration);
                }
            }
        }

        public int getCurrentTick()
        {
            if (this.previewRenderer.morph == GuiSequencerMorphRenderer.PREVIEWER)
            {
                return this.previewRenderer.tick;
            }
            else
            {
                return this.morph.getTickAt(this.list.getIndex());
            }
        }

        private GuiElement combinElements(GuiTrackpadElement trackpad, GuiColorElement color)
        {
            GuiElement element = new GuiElement(this.mc);
            element.flex().relative(trackpad).h(1F);
            element.add(color, trackpad);

            trackpad.flex().relative(element).xy(0F, 0F).wTo(color.area);
            color.flex().relative(element).anchorX(1F).xy(1F, 0F).w(() -> (float) color.flex().getH()).h(1F);

            return element;
        }

        public void updateOnionSkins()
        {
            this.isFrameSkin = false;

            List<OnionSkin> skins = this.editor.morphs.onionSkins;

            skins.clear();

            if (this.list.isDeselected() || this.morph.isRandom)
            {
                return;
            }

            Map<OnionSkin, Integer> tickMap = new HashMap<OnionSkin, Integer>();
            Color prevColor = this.prevColor.picker.color;
            Color nextColor = this.nextColor.picker.color;
            Color loopColor = this.loopColor.picker.color;

            float pitch = this.previewRenderer.customEntity ? this.previewRenderer.entityPitch : 0;
            float yawHead = this.previewRenderer.customEntity ? this.previewRenderer.entityYawHead : 0;
            float yawBody = this.previewRenderer.customEntity ? this.previewRenderer.entityYawBody : 0;

            int sign = this.morph.reverse ? -1 : 1;

            for (int i = 1; i <= this.prevSkins.value; i++)
            {
                int index = this.list.getIndex() - sign * i;

                if (index < 0 || index >= this.list.getList().size())
                {
                    break;
                }

                SequenceEntry entry = this.list.getList().get(index);

                if (entry.morph != null)
                {
                    float factor = 1F - (i - 1) / (float) this.prevSkins.value;
                    OnionSkin skin = new OnionSkin()
                            .morph(entry.morph.copy())
                            .color(prevColor.r, prevColor.g, prevColor.b, prevColor.a * factor)
                            .offset(0, 0, 0, pitch, yawHead, yawBody);

                    if (entry.morph instanceof IAnimationProvider)
                    {
                        MorphUtils.pause(skin.morph, null, 0);
                    }
                    else
                    {
                        MorphUtils.pause(skin.morph, null, (int) entry.duration);
                    }

                    skins.add(skin);
                    tickMap.put(skin, this.morph.getTickAt(index));
                }
            }

            for (int i = 1; i <= this.nextSkins.value; i++)
            {
                int index = this.list.getIndex() + sign * i;

                if (index < 0 || index >= this.list.getList().size())
                {
                    break;
                }

                SequenceEntry entry = this.list.getList().get(index);

                if (entry.morph != null)
                {
                    float factor = 1F - (i - 1) / (float) this.nextSkins.value;
                    OnionSkin skin = new OnionSkin()
                            .morph(entry.morph.copy())
                            .color(nextColor.r, nextColor.g, nextColor.b, nextColor.a * factor)
                            .offset(0, 0, 0, pitch, yawHead, yawBody);

                    if (entry.morph instanceof IAnimationProvider)
                    {
                        MorphUtils.pause(skin.morph, null, 0);
                    }
                    else
                    {
                        MorphUtils.pause(skin.morph, null, (int) entry.duration);
                    }

                    skins.add(skin);
                    tickMap.put(skin, this.morph.getTickAt(index));
                }
            }

            GuiImmersiveMorphMenu menu = null;
            Frame current = null;

            if (this.editor.morphs instanceof GuiImmersiveMorphMenu)
            {
                menu = (GuiImmersiveMorphMenu) this.editor.morphs;
                current = menu.getFrame(this.getCurrentTick());
                this.isFrameSkin = current != null;
            }

            if (this.offsetCount.value > 0)
            {
                double baseMul = 0.0625 * (this.morph.reverse ? -1 : 1);
                SequenceEntry entry = this.list.getList().get(this.morph.reverse ? this.list.getList().size() - 1 : 0);
                OnionSkin skin = new OnionSkin()
                        .morph(entry.morph.copy())
                        .color(loopColor.r, loopColor.g, loopColor.b, loopColor.a)
                        .offset(this.offsetX.value * baseMul, this.offsetY.value * baseMul, this.offsetZ.value * baseMul, pitch, yawHead, yawBody);

                MorphUtils.pause(skin.morph, null, 0);
                skins.add(skin);
                tickMap.put(skin, (int) this.morph.getDuration());

                this.offsetSkin = skin;
                this.offsetSkinPos = new Vec3d(skin.offset.x, skin.offset.y, skin.offset.z);

                if (!this.isFrameSkin)
                {
                    Vec3d pos = this.offsetSkinPos.rotateYaw((float) -Math.toRadians(skin.yawBody));

                    skin.offset.set(pos.x, pos.y, pos.z);
                }
            }
            else
            {
                this.offsetSkin = null;
            }

            if (current != null)
            {
                boolean hasBodyYaw = current.hasBodyYaw;

                for (OnionSkin skin : skins)
                {
                    Frame skinFrame = menu.getFrame(tickMap.get(skin));
                    Vec3d pos = new Vec3d(skin.offset.x, skin.offset.y, skin.offset.z);

                    pos = pos.rotateYaw((float) -Math.toRadians(hasBodyYaw ? skinFrame.bodyYaw : skinFrame.yaw));
                    pos = pos.add(new Vec3d(skinFrame.x - current.x, skinFrame.y - current.y, skinFrame.z - current.z));
                    pos = pos.rotateYaw((float) Math.toRadians(current.yaw));
                    skin.offset(pos.x, pos.y, pos.z, skinFrame.pitch, skinFrame.yawHead - current.yawHead, hasBodyYaw ? skinFrame.bodyYaw - current.bodyYaw : skinFrame.yawHead - current.yawHead);
                }
            }
        }

        @Override
        public void fromNBT(NBTTagCompound tag)
        {
            super.fromNBT(tag);

            this.list.setIndex(tag.getInteger("Index"));

            SequenceEntry entry = this.list.getCurrentFirst();

            if (entry != null)
            {
                this.select(entry);
            }
        }

        @Override
        public NBTTagCompound toNBT()
        {
            NBTTagCompound tag = super.toNBT();

            tag.setInteger("Index", this.list.getIndex());

            return tag;
        }
    }

    /**
     * List that shows up the sequencer entries 
     */
    public static class GuiSequenceEntryList extends GuiListElement<SequenceEntry>
    {
        public static IKey ticks = IKey.lang("blockbuster.gui.sequencer.ticks");

        public GuiSequenceEntryList(Minecraft mc, Consumer<List<SequenceEntry>> callback)
        {
            super(mc, callback);

            this.scroll.scrollItemSize = 24;
        }

        @Override
        protected void drawElementPart(SequenceEntry element, int i, int x, int y, boolean hover, boolean selected)
        {
            GuiContext context = GuiBase.getCurrent();

            if (element.morph != null)
            {
                GuiDraw.scissor(x, y, this.scroll.w, this.scroll.scrollItemSize, context);
                element.morph.renderOnScreen(this.mc.player, x + this.scroll.w - 16, y + 30, 20, 1);
                GuiDraw.unscissor(context);
            }

            super.drawElementPart(element, i, x, y, hover, selected);
        }

        @Override
        protected String elementToString(SequenceEntry element)
        {
            int index = getIndexByElement(element);
            String title = String.format("%3d | ", new Object[] { Integer.valueOf(index + 1) }) + element.duration + " " + ticks.get();

            if (element.morph == null)
            {
                title += " " + I18n.format("blockbuster.gui.sequencer.no_morph");
            }

            return title;
        }

        private int getIndexByElement(SequencerMorph.SequenceEntry element)
        {
            for (int i = 0; i < this.list.size(); i++)
            {
                if (this.list.get(i) == element) return i;
            }
            return this.list.indexOf(element);
        }
    }

    /**
     * Sequencer Morph Renderer
     */
    public static class GuiSequencerMorphRenderer extends GuiMorphRenderer
    {
        public static final SequencerMorph PREVIEWER = new SequencerMorph();

        public boolean playing;

        public int tick;
        public float partialTicks;
        public float lastTicks;

        public GuiSequencerMorphRenderer(Minecraft mc)
        {
            super(mc);
        }

        @Override
        protected void drawUserModel(GuiContext context)
        {
            this.doRender(context, this.entity, 0.0D, 0.0D, 0.0D);
        }

        public void doRender(GuiContext context, EntityLivingBase entity, double x, double y, double z)
        {
            if (this.morph == null)
            {
                return;
            }

            float current = context.tick + context.partialTicks;

            if (this.morph == PREVIEWER && this.playing)
            {
                float ticks = this.tick + this.partialTicks;
                float delta = MathUtils.clamp(current - this.lastTicks, 0.0F, 10.0F);

                ticks += delta;
                delta = (int) ticks - this.tick;

                this.tick = (int) ticks;
                this.partialTicks = ticks - this.tick;

                if (delta > 0)
                {
                    PREVIEWER.pause(null, this.tick);
                    PREVIEWER.resume();
                }
            }

            MorphUtils.render(this.morph, entity, x, y, z, this.yaw, this.partialTicks);

            this.lastTicks = current;
        }
    }
}

==================================================

--- Файл №512 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiSnowstormMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.blockbuster_pack.morphs.SnowstormMorph;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.Variable;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.NBTTagCompound;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GuiSnowstormMorph extends GuiAbstractMorph<SnowstormMorph>
{
    public GuiSnowstormMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = new GuiSnowstormVariablesMorphPanel(mc, this);
        this.registerPanel(this.defaultPanel, IKey.lang("blockbuster.gui.snowstorm.variables"), BBIcons.PARTICLE);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof SnowstormMorph;
    }

    @Override
    public List<Label<NBTTagCompound>> getPresets(SnowstormMorph morph)
    {
        List<Label<NBTTagCompound>> labels = new ArrayList<Label<NBTTagCompound>>();

        for (String preset : Blockbuster.proxy.particles.presets.keySet())
        {
            NBTTagCompound tag = new NBTTagCompound();

            tag.setString("Scheme", preset);
            this.addPreset(morph, labels, preset, tag);
        }

        return labels;
    }

    public static class GuiSnowstormVariablesMorphPanel extends GuiMorphPanel<SnowstormMorph, GuiSnowstormMorph>
    {
        public GuiStringListElement variables;
        public GuiTextElement expression;

        private String variable;

        public GuiSnowstormVariablesMorphPanel(Minecraft mc, GuiSnowstormMorph editor)
        {
            super(mc, editor);

            this.variables = new GuiStringListElement(mc, (list) -> this.pickVariable(list.get(0)));
            this.variables.background();
            this.expression = new GuiTextElement(mc, 1000, this::replaceVariable);

            this.variables.flex().relative(this).xy(10, 22).w(110).hTo(this.expression.area, -17);
            this.expression.flex().relative(this).x(10).y(1F, -30).w(1F, -20).h(20);

            this.add(this.expression, this.variables);
        }

        @Override
        public void fillData(SnowstormMorph morph)
        {
            super.fillData(morph);

            Set<String> keys = new HashSet<String>();
            BedrockScheme scheme = this.morph.getEmitter().scheme;

            for (String key : this.morph.variables.keySet())
            {
                if (scheme != null && !scheme.parser.variables.containsKey(key))
                {
                    keys.add(key);
                }
            }

            for (String key : keys)
            {
                this.morph.variables.remove(key);
            }

            this.variables.clear();

            if (scheme != null)
            {
                this.variables.add(scheme.parser.variables.keySet());
                this.variables.sort();
            }

            String first = this.variables.getList().isEmpty() ? "" : this.variables.getList().get(0);

            this.pickVariable(first);
            this.expression.setEnabled(!first.isEmpty());
            this.variables.setCurrent(first);
        }

        private void pickVariable(String variable)
        {
            this.variable = variable;

            String expression = this.morph.variables.get(variable);

            this.expression.setEnabled(true);
            this.expression.setText(expression == null ? "" : expression);
        }

        private void replaceVariable(String expression)
        {
            if (this.variable.isEmpty())
            {
                return;
            }

            this.morph.replaceVariable(this.variable, expression);
        }

        @Override
        public void draw(GuiContext context)
        {
            super.draw(context);

            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.snowstorm.variables"), this.variables.area.x, this.variables.area.y - 12, 0xffffff);
            this.font.drawStringWithShadow(I18n.format("blockbuster.gui.snowstorm.expression"), this.expression.area.x, this.expression.area.y - 12, 0xffffff);
        }
    }
}

==================================================

--- Файл №513 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiStructureMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import mchorse.blockbuster.client.gui.dashboard.panels.model_editor.utils.GuiPoseTransformations;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiSearchListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAnimation;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.biome.Biome;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;

public class GuiStructureMorph extends GuiAbstractMorph<StructureMorph>
{
    private static IKey ANCHOR_POINT = IKey.lang("blockbuster.gui.structure_morph.anchor");

    public GuiStructureMorphPanel general;

    public GuiStructureMorph(Minecraft mc)
    {
        super(mc);

        this.defaultPanel = this.general = new GuiStructureMorphPanel(mc, this);
        this.registerPanel(this.general, IKey.lang("blockbuster.morph.structure"), Icons.GEAR);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof StructureMorph;
    }

    public static class GuiStructureMorphPanel extends GuiMorphPanel<StructureMorph, GuiStructureMorph>
    {
        public GuiPoseTransformations pose;
        public GuiAnimation animation;
        public GuiToggleElement lighting;
        public GuiSearchBiomeList biomes;
        public GuiTrackpadElement anchorX;
        public GuiTrackpadElement anchorY;
        public GuiTrackpadElement anchorZ;

        public GuiStructureMorphPanel(Minecraft mc, GuiStructureMorph editor)
        {
            super(mc, editor);

            this.pose = new GuiPoseTransformations(mc);
            this.pose.flex().relative(this.area).set(0, 0, 256, 70).x(0.5F, -128).y(1, -75);

            this.animation = new GuiAnimation(mc, true);
            this.animation.flex().relative(this).x(1F, -130).w(130);

            this.lighting = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.structure_morph.lighting"), (b) -> this.morph.lighting = b.isToggled());
            this.lighting.flex().relative(this).x(1F, -10).y(1F, -10).w(110).anchor(1F, 1F);
            this.anchorX = new GuiTrackpadElement(mc, (v) -> this.morph.anchorX = v.floatValue());
            this.anchorY = new GuiTrackpadElement(mc, (v) -> this.morph.anchorY = v.floatValue());
            this.anchorZ = new GuiTrackpadElement(mc, (v) -> this.morph.anchorZ = v.floatValue());
            this.anchorX.flex().relative(this.anchorY).y(-5).w(1F).anchorY(1);
            this.anchorY.flex().relative(this.anchorZ).y(-5).w(1F).anchorY(1);
            this.anchorZ.flex().relative(this.lighting).y(-5).w(1F).anchorY(1);
            
            this.biomes = new GuiSearchBiomeList(mc, this::accept);
            this.biomes.list.sort();
            this.biomes.flex().relative(this).x(0F).w(150).h(1F).anchorX(0F);
            this.biomes.list.background(0x80000000);
            this.biomes.resize();
            this.biomes.list.scroll.scrollSpeed = 15;

            this.add(this.pose, this.animation, this.lighting, this.anchorZ, this.anchorY, this.anchorX, this.biomes);
        }

        @Override
        public void fillData(StructureMorph morph)
        {
            super.fillData(morph);

            this.pose.set(morph.pose);
            this.animation.fill(morph.animation);
            this.lighting.toggled(morph.lighting);
            this.biomes.filter("", true);
            this.biomes.list.setCurrent(morph.biome);
            this.anchorX.setValue(morph.anchorX);
            this.anchorY.setValue(morph.anchorY);
            this.anchorZ.setValue(morph.anchorZ);
        }

        private void accept(List<ResourceLocation> sel)
        {
            this.morph.biome = sel.get(0);
        }

        @Override
        public void draw(GuiContext context)
        {
            this.font.drawStringWithShadow(ANCHOR_POINT.get(), this.anchorX.area.x, this.anchorX.area.y - 12, 0xffffff);

            super.draw(context);
        }
    }
    
    public static class GuiSearchBiomeList extends GuiSearchListElement<ResourceLocation>
    {
        public GuiSearchBiomeList(Minecraft mc, Consumer<List<ResourceLocation>> callback)
        {
            super(mc, callback);
        }

        @Override
        protected GuiListElement<ResourceLocation> createList(Minecraft mc, Consumer<List<ResourceLocation>> callback)
        {
            return new GuiBiomeList(mc, callback);
        }
    }
    
    public static class GuiBiomeList extends GuiListElement<ResourceLocation>
    {

        public GuiBiomeList(Minecraft mc, Consumer<List<ResourceLocation>> callback)
        {
            super(mc, callback);
            for (ResourceLocation location : Biome.REGISTRY.getKeys())
            {
                this.add(location);
            }
        }
        
        @Override
        protected boolean sortElements()
        {
            Collections.<ResourceLocation>sort(this.list, Comparator.comparing(this::elementToString));

            return true;
        }

        @Override
        protected String elementToString(ResourceLocation element)
        {
            return Biome.REGISTRY.getObject(element).getBiomeName();
        }
    }
}


==================================================

--- Файл №514 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\GuiTrackerMorph.java
--------------------
package mchorse.blockbuster_pack.client.gui;

import java.util.List;

import com.google.common.collect.ImmutableList;

import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.blockbuster_pack.client.gui.trackers.GuiBaseTracker;
import mchorse.blockbuster_pack.morphs.TrackerMorph;
import mchorse.blockbuster_pack.trackers.MorphTracker;
import mchorse.blockbuster_pack.trackers.BaseTracker;
import mchorse.blockbuster_pack.trackers.TrackerRegistry;
import mchorse.mclib.client.gui.framework.elements.GuiDelegateElement;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;

public class GuiTrackerMorph extends GuiAbstractMorph<TrackerMorph>
{
    public GuiTrackerMorph(Minecraft mc)
    {
        super(mc);

        this.registerPanel(this.defaultPanel = new GuiTrackerMorphPanel(mc, this), IKey.lang("metamorph.gui.edit"), BBIcons.EDITOR);
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof TrackerMorph;
    }

    public static class GuiTrackerMorphPanel extends GuiMorphPanel<TrackerMorph, GuiTrackerMorph>
    {
        public GuiCirculateElement type;
        public GuiToggleElement hidden;
        public GuiDelegateElement<GuiBaseTracker> trackerPanel;

        private List<String> trackers;

        public GuiTrackerMorphPanel(Minecraft mc, GuiTrackerMorph editor)
        {
            super(mc, editor);

            GuiLabel typeTitle = Elements.label(IKey.lang("blockbuster.gui.tracker_morph.type.title"));
//            typeTitle.flex().relative(this).xy(10, 10);

            this.type = new GuiCirculateElement(mc, (element) ->
            {
                BaseTracker tracker = this.morph.tracker;
                Class<? extends BaseTracker> clazz = TrackerRegistry.ID_TO_CLASS.get(this.trackers.get(element.getValue()));

                if (clazz != null)
                {
                    try
                    {
                        this.morph.tracker = clazz.newInstance();
                        this.morph.tracker.copy(tracker);
                    }
                    catch (InstantiationException | IllegalAccessException e)
                    {
                        e.printStackTrace();
                    }
                }

                this.updateTracker();
            });
//            this.type.flex().relative(typeTitle).w(150).x(0F).y(1F, 5).anchor(0F, 0F);

            this.trackers = ImmutableList.copyOf(TrackerRegistry.ID_TO_CLASS.keySet());

            for (String tracker : this.trackers)
            {
                this.type.addLabel(IKey.lang("blockbuster.gui.tracker_morph.type." + tracker));
            }

            //this.type.addLabel(IKey.EMPTY);

            this.hidden = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.tracker_morph.hidden"), element ->
            {
                this.morph.hidden = element.isToggled();
            });
//            this.hidden.flex().relative(this.type).w(150).x(0F).y(1F, 10).anchor(0F, 0F);

            GuiElement elements = Elements.column(mc, 10, 10, Elements.label(IKey.lang("blockbuster.gui.tracker_morph.type.title")), this.type, this.hidden);
            elements.flex().relative(this).xy(0, 0).w(170);

            this.trackerPanel = new GuiDelegateElement<GuiBaseTracker>(mc, null);
            this.trackerPanel.flex().relative(elements).x(0).y(1F).wTo(this.area, 1F).hTo(this.area, 1F);

            this.add(elements, this.trackerPanel);
        }

        @Override
        public void fillData(TrackerMorph morph)
        {
            super.fillData(morph);

            this.hidden.toggled(morph.hidden);
            this.updateTracker();
        }

        private void updateTracker()
        {
            this.trackerPanel.setDelegate(null);
            this.type.setValue(0);

            if (this.morph.tracker == null)
            {
                this.morph.tracker = new MorphTracker();
            }

            this.type.setValue(this.trackers.indexOf(TrackerRegistry.CLASS_TO_ID.get(this.morph.tracker.getClass())));
            this.trackerPanel.setDelegate(TrackerRegistry.CLIENT.get(this.morph.tracker.getClass()));

            if (this.trackerPanel.delegate != null)
            {
                this.trackerPanel.delegate.fill(this.morph.tracker);
            }
        }
    }
}


==================================================

--- Файл №515 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\ILimbSelector.java
--------------------
package mchorse.blockbuster_pack.client.gui;

public interface ILimbSelector
{
    public void setLimb(String limb);
}


==================================================

--- Файл №516 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\trackers\GuiBaseTracker.java
--------------------
package mchorse.blockbuster_pack.client.gui.trackers;

import mchorse.blockbuster_pack.trackers.BaseTracker;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiBaseTracker<T extends BaseTracker> extends GuiElement
{
    public GuiTextElement name;

    public T tracker;

    public GuiBaseTracker(Minecraft mc)
    {
        super(mc);

        GuiLabel labelTitle = Elements.label(IKey.lang("blockbuster.gui.tracker_morph.label.title"));
        labelTitle.flex().relative(this).xy(10, 0);

        this.name = new GuiTextElement(mc, str -> this.tracker.name = str);
        this.name.flex().relative(labelTitle).w(150).x(0F).y(1F, 5).anchor(0F, 0F);

        this.add(labelTitle, this.name);
    }

    public void fill(T tracker)
    {
        this.tracker = tracker;

        this.name.setText(tracker.name);
    }
}


==================================================

--- Файл №517 ---
Путь: main\java\mchorse\blockbuster_pack\client\gui\trackers\GuiMorphTracking.java
--------------------
package mchorse.blockbuster_pack.client.gui.trackers;

import mchorse.blockbuster_pack.trackers.MorphTracker;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

public class GuiMorphTracking extends GuiBaseTracker<MorphTracker>
{
    public GuiToggleElement combineTracking;

    public GuiMorphTracking(Minecraft mc)
    {
        super(mc);

        this.combineTracking = new GuiToggleElement(mc, IKey.lang("blockbuster.gui.tracker_morph.aperture_tracker.combine_tracking"), (toggle) ->
        {
            this.tracker.setCombineTracking(toggle.isToggled());
        });
        this.combineTracking.flex().relative(name).w(150).x(0F).y(1F, 5).anchor(0F, 0F);
        this.combineTracking.tooltip(IKey.lang("blockbuster.gui.tracker_morph.aperture_tracker.combine_tracking_tooltip"));

        this.add(this.combineTracking);
    }

    @Override
    public void fill(MorphTracker tracker)
    {
        super.fill(tracker);

        this.combineTracking.toggled(tracker.getCombineTracking());
    }
}


==================================================

--- Файл №518 ---
Путь: main\java\mchorse\blockbuster_pack\client\model\ModelElytra.java
--------------------
package mchorse.blockbuster_pack.client.model;

import mchorse.blockbuster.common.entity.EntityActor;
import net.minecraft.client.entity.AbstractClientPlayer;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Model elytra
 *
 * Copied code of elytra from Minecraft's code to support actor's elytra
 * animation.
 */
@SideOnly(Side.CLIENT)
public class ModelElytra extends ModelBase
{
    private final ModelRenderer rightWing;
    private final ModelRenderer leftWing = new ModelRenderer(this, 22, 0);

    public ModelElytra()
    {
        this.leftWing.addBox(-10.0F, 0.0F, 0.0F, 10, 20, 2, 1.0F);
        this.rightWing = new ModelRenderer(this, 22, 0);
        this.rightWing.mirror = true;
        this.rightWing.addBox(0.0F, 0.0F, 0.0F, 10, 20, 2, 1.0F);
    }

    /**
     * Sets the models various rotation angles then renders the model.
     */
    @Override
    public void render(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        GlStateManager.disableRescaleNormal();
        GlStateManager.disableCull();
        this.leftWing.render(scale);
        this.rightWing.render(scale);
    }

    /**
     * Sets the model's various rotation angles. For bipeds, par1 and par2 are used for animating the movement of arms
     * and legs, where par1 represents the time(so that arms and legs swing back and forth) and par2 represents how
     * "far" arms and legs can swing at most.
     */
    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);
        float f = 0.2617994F;
        float f1 = -0.2617994F;
        float f2 = 0.0F;
        float f3 = 0.0F;

        if (entityIn instanceof EntityLivingBase && ((EntityLivingBase) entityIn).isElytraFlying())
        {
            float f4 = 1.0F;

            if (entityIn.motionY < 0.0D)
            {
                Vec3d vec3d = (new Vec3d(entityIn.motionX, entityIn.motionY, entityIn.motionZ)).normalize();
                f4 = 1.0F - (float) Math.pow(-vec3d.y, 1.5D);
            }

            f = f4 * 0.34906584F + (1.0F - f4) * f;
            f1 = f4 * -((float) Math.PI / 2F) + (1.0F - f4) * f1;
        }
        else if (entityIn.isSneaking())
        {
            f = ((float) Math.PI * 2F / 9F);
            f1 = -((float) Math.PI / 4F);
            f2 = 3.0F;
            f3 = 0.08726646F;
        }

        this.leftWing.rotationPointX = 5.0F;
        this.leftWing.rotationPointY = f2;

        if (entityIn instanceof AbstractClientPlayer)
        {
            AbstractClientPlayer player = (AbstractClientPlayer) entityIn;
            player.rotateElytraX = (float) (player.rotateElytraX + (f - player.rotateElytraX) * 0.1D);
            player.rotateElytraY = (float) (player.rotateElytraY + (f3 - player.rotateElytraY) * 0.1D);
            player.rotateElytraZ = (float) (player.rotateElytraZ + (f1 - player.rotateElytraZ) * 0.1D);
            this.leftWing.rotateAngleX = player.rotateElytraX;
            this.leftWing.rotateAngleY = player.rotateElytraY;
            this.leftWing.rotateAngleZ = player.rotateElytraZ;
        }
        else if (entityIn instanceof EntityActor)
        {
            EntityActor actor = (EntityActor) entityIn;
            actor.rotateElytraX = (float) (actor.rotateElytraX + (f - actor.rotateElytraX) * 0.1D);
            actor.rotateElytraY = (float) (actor.rotateElytraY + (f3 - actor.rotateElytraY) * 0.1D);
            actor.rotateElytraZ = (float) (actor.rotateElytraZ + (f1 - actor.rotateElytraZ) * 0.1D);
            this.leftWing.rotateAngleX = actor.rotateElytraX;
            this.leftWing.rotateAngleY = actor.rotateElytraY;
            this.leftWing.rotateAngleZ = actor.rotateElytraZ;
        }
        else
        {
            this.leftWing.rotateAngleX = f;
            this.leftWing.rotateAngleZ = f1;
            this.leftWing.rotateAngleY = f3;
        }

        this.rightWing.rotationPointX = -this.leftWing.rotationPointX;
        this.rightWing.rotateAngleY = -this.leftWing.rotateAngleY;
        this.rightWing.rotationPointY = this.leftWing.rotationPointY;
        this.rightWing.rotateAngleX = this.leftWing.rotateAngleX;
        this.rightWing.rotateAngleZ = -this.leftWing.rotateAngleZ;
    }

    /**
     * Used for easily adding entity-dependent animations. The second and third float params here are the same second
     * and third as in the setRotationAngles method.
     */
    @Override
    public void setLivingAnimations(EntityLivingBase entitylivingbaseIn, float p_78086_2_, float p_78086_3_, float partialTickTime)
    {
        super.setLivingAnimations(entitylivingbaseIn, p_78086_2_, p_78086_3_, partialTickTime);
    }
}

==================================================

--- Файл №519 ---
Путь: main\java\mchorse\blockbuster_pack\client\render\RenderCustomActor.java
--------------------
package mchorse.blockbuster_pack.client.render;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.blockbuster.client.render.layer.LayerHeldItem;
import mchorse.blockbuster_pack.client.render.layers.LayerActorArmor;
import mchorse.blockbuster_pack.client.render.layers.LayerBodyPart;
import mchorse.blockbuster_pack.client.render.layers.LayerCustomHead;
import mchorse.blockbuster_pack.client.render.layers.LayerElytra;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.ResourceLocation;

/**
 * Overriden {@link RenderCustomModel} to support {@link CustomMorph}'s skin
 * property.
 */
public class RenderCustomActor extends RenderCustomModel
{
    public RenderCustomActor(RenderManager renderManagerIn, ModelBase modelBaseIn, float shadowSizeIn)
    {
        super(renderManagerIn, modelBaseIn, shadowSizeIn);

        this.addLayer(new LayerElytra(this));
        this.addLayer(new LayerBodyPart(this));
        this.addLayer(new LayerActorArmor(this));
        this.addLayer(new LayerCustomHead(this));
        this.addLayer(new LayerHeldItem(this));
    }

    /**
     * Get entity's texture
     *
     * The thing which is going on here, is that we're going to check, whether
     * given entity has a morph, and if it does, we're going to use its skin
     */
    @Override
    protected ResourceLocation getEntityTexture(EntityLivingBase entity)
    {
        AbstractMorph morph = this.current;

        if (morph != null && morph instanceof CustomMorph)
        {
            ResourceLocation skin = ((CustomMorph) morph).skin;

            if (skin != null)
            {
                return skin;
            }
        }

        return super.getEntityTexture(entity);
    }

    /**
     * Can the nametag be rendered by this entity
     *
     * This method is also takes in account the config option for making actor
     * nametags visible always.
     */
    @Override
    protected boolean canRenderName(EntityLivingBase entity)
    {
        return entity.hasCustomName() && (Blockbuster.actorAlwaysRenderNames.get() || (Minecraft.isGuiEnabled() && entity == this.renderManager.pointedEntity));
    }
}

==================================================

--- Файл №520 ---
Путь: main\java\mchorse\blockbuster_pack\client\render\layers\LayerActorArmor.java
--------------------
package mchorse.blockbuster_pack.client.render.layers;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelLimb.ArmorSlot;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.model.ModelBiped;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.layers.LayerArmorBase;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemArmor;
import net.minecraft.item.ItemStack;
import org.lwjgl.opengl.GL11;

/**
 * Actor's armor layer
 *
 * This is a temporary fix for the armor. In next
 */
public class LayerActorArmor extends LayerArmorBase<ModelBiped>
{
    private RenderLivingBase<EntityLivingBase> renderer;

    public LayerActorArmor(RenderLivingBase<EntityLivingBase> renderer)
    {
        super(renderer);
        this.renderer = renderer;
    }

    @Override
    protected void initArmor()
    {
        this.modelArmor = new ModelBiped(1);
        this.modelLeggings = new ModelBiped(0.5F);
    }

    @Override
    public void doRenderLayer(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        ModelBase base = this.renderer.getMainModel();

        if (base instanceof ModelCustom)
        {
            ModelCustom model = (ModelCustom) base;

            for (ModelCustomRenderer limb : model.armor)
            {
                ItemStack stack = entity.getItemStackFromSlot(limb.limb.slot.slot);

                if (stack != null && stack.getItem() instanceof ItemArmor)
                {
                    ItemArmor item = (ItemArmor) stack.getItem();

                    if (item.getEquipmentSlot() == limb.limb.slot.slot)
                    {
                        this.renderArmorSlot(entity, stack, item, limb, limb.limb.slot.slot, partialTicks, scale);
                    }
                }
            }
        }
    }

    private void renderArmorSlot(EntityLivingBase entity, ItemStack stack, ItemArmor item, ModelCustomRenderer limb, EntityEquipmentSlot slot, float partialTicks, float scale)
    {
        ModelBiped model = this.getModelFromSlot(slot);
        model = this.getArmorModelHook(entity, stack, slot, model);

        if (model == null)
        {
            return;
        }

        GlStateManager.pushMatrix();

        model.setModelAttributes(this.renderer.getMainModel());
        this.renderer.bindTexture(this.getArmorResource(entity, stack, slot, null));
        limb.postRender(scale);

        ModelRenderer renderer = this.setModelSlotVisible(model, limb.limb, limb.limb.slot);

        if (renderer != null)
        {
            GlStateManager.enableRescaleNormal();

            if (item.hasOverlay(stack))
            {
                int i = item.getColor(stack);
                float r = (float) (i >> 16 & 255) / 255F;
                float g = (float) (i >> 8 & 255) / 255F;
                float b = (float) (i & 255) / 255F;

                GlStateManager.color(r, g, b, 1);
                renderer.render(scale);
                this.renderer.bindTexture(this.getArmorResource(entity, stack, slot, "overlay"));
            }

            GlStateManager.color(1, 1, 1, 1);
            renderer.render(scale);

            GlStateManager.disableRescaleNormal();

            if (stack.hasEffect())
            {
                this.renderMyEnchantedGlint(this.renderer, entity, renderer, partialTicks, scale);
            }
        }

        GlStateManager.popMatrix();
    }

    private void renderMyEnchantedGlint(RenderLivingBase<?> layer, EntityLivingBase entity, ModelRenderer renderer, float partialTicks, float p_188364_9_)
    {
        float timer = entity.ticksExisted + partialTicks;

        layer.bindTexture(ENCHANTED_ITEM_GLINT_RES);
        Minecraft.getMinecraft().entityRenderer.setupFogColor(true);

        GlStateManager.enableBlend();
        GlStateManager.depthFunc(GL11.GL_EQUAL);
        GlStateManager.depthMask(false);
        GlStateManager.color(0.5F, 0.5F, 0.5F, 1.0F);

        for (int iter = 0; iter < 2; ++iter)
        {
            GlStateManager.disableLighting();
            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_COLOR, GlStateManager.DestFactor.ONE);
            GlStateManager.color(0.38F, 0.19F, 0.608F, 1.0F);
            GlStateManager.matrixMode(5890);
            GlStateManager.loadIdentity();
            GlStateManager.scale(0.33333334F, 0.33333334F, 0.33333334F);
            GlStateManager.rotate(30.0F - iter * 60.0F, 0.0F, 0.0F, 1.0F);
            GlStateManager.translate(0.0F, timer * (0.001F + iter * 0.003F) * 20.0F, 0.0F);
            GlStateManager.matrixMode(5888);
            renderer.render(p_188364_9_);
            GlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        }

        GlStateManager.matrixMode(5890);
        GlStateManager.loadIdentity();
        GlStateManager.matrixMode(5888);
        GlStateManager.enableLighting();
        GlStateManager.depthMask(true);
        GlStateManager.depthFunc(GL11.GL_LEQUAL);
        GlStateManager.disableBlend();

        Minecraft.getMinecraft().entityRenderer.setupFogColor(false);
    }

    protected ModelRenderer setModelSlotVisible(ModelBiped model, ModelLimb limb, ArmorSlot slot)
    {
        model.bipedBody.setRotationPoint(0, 0, 0);
        model.bipedHead.setRotationPoint(0, 0, 0);
        model.bipedHeadwear.setRotationPoint(0, 0, 0);
        model.bipedLeftArm.setRotationPoint(-0.1F, 0, 0);
        model.bipedRightArm.setRotationPoint(0.1F, 0, 0);
        model.bipedLeftLeg.setRotationPoint(0, 0, 0);
        model.bipedRightLeg.setRotationPoint(0, 0, 0);

        model.setVisible(false);

        int w = limb.size[0];
        int h = limb.size[1];
        int d = limb.size[2];

        float ww = w / 8F;
        float hh = h / 8F;
        float dd = d / 8F;

        float offsetX = limb.anchor[0] * ww / 2;
        float offsetY = limb.anchor[1] * hh / 2;
        float offsetZ = limb.anchor[2] * dd / 2;

        GlStateManager.translate(-ww / 4 + offsetX, hh / 4 - offsetY, dd / 4 - offsetZ);

        if (slot == ArmorSlot.HEAD)
        {
            GlStateManager.scale(w / 8F, h / 8F, d / 8F);
            model.bipedHead.showModel = true;
            model.bipedHead.setRotationPoint(0, 4, 0);

            return model.bipedHead;
        }
        else if (slot == ArmorSlot.CHEST)
        {
            GlStateManager.scale(w / 8F, h / 12F, d / 4F);
            model.bipedBody.showModel = true;
            model.bipedBody.setRotationPoint(0, -6, 0);

            return model.bipedBody;
        }
        else if (slot == ArmorSlot.LEFT_SHOULDER)
        {
            GlStateManager.scale(w / 4F, h / 12F, d / 4F);
            model.bipedLeftArm.showModel = true;
            model.bipedLeftArm.setRotationPoint(-1, -4, 0);

            return model.bipedLeftArm;
        }
        else if (slot == ArmorSlot.RIGHT_SHOULDER)
        {
            GlStateManager.scale(w / 4F, h / 12F, d / 4F);
            model.bipedRightArm.showModel = true;
            model.bipedRightArm.setRotationPoint(1, -4, 0);

            return model.bipedRightArm;
        }
        else if (slot == ArmorSlot.LEGGINGS)
        {
            GlStateManager.scale(w / 8F, h / 12F, d / 4F);
            model.bipedBody.showModel = true;
            model.bipedBody.setRotationPoint(0, -6, 0);

            return model.bipedBody;
        }
        else if (slot == ArmorSlot.LEFT_LEG)
        {
            GlStateManager.scale(w / 4F, h / 12F, d / 4F);
            model.bipedLeftLeg.showModel = true;
            model.bipedLeftLeg.setRotationPoint(0, -6, 0);

            return model.bipedLeftLeg;
        }
        else if (slot == ArmorSlot.RIGHT_LEG)
        {
            GlStateManager.scale(w / 4F, h / 12F, d / 4F);
            model.bipedRightLeg.showModel = true;
            model.bipedRightLeg.setRotationPoint(0, -6, 0);

            return model.bipedRightLeg;
        }
        else if (slot == ArmorSlot.LEFT_FOOT)
        {
            GlStateManager.scale(w / 4F, h / 12F, d / 4F);
            model.bipedLeftLeg.showModel = true;
            model.bipedLeftLeg.setRotationPoint(0, -6, 0);

            return model.bipedLeftLeg;
        }
        else if (slot == ArmorSlot.RIGHT_FOOT)
        {
            GlStateManager.scale(w / 4F, h / 12F, d / 4F);
            model.bipedRightLeg.showModel = true;
            model.bipedRightLeg.setRotationPoint(0, -6, 0);

            return model.bipedRightLeg;
        }

        return null;
    }

    @Override
    protected void setModelSlotVisible(ModelBiped p_188359_1_, EntityEquipmentSlot slotIn)
    {}

    @Override
    protected ModelBiped getArmorModelHook(net.minecraft.entity.EntityLivingBase entity, net.minecraft.item.ItemStack itemStack, EntityEquipmentSlot slot, ModelBiped model)
    {
        return net.minecraftforge.client.ForgeHooksClient.getArmorModel(entity, itemStack, slot, model);
    }
}

==================================================

--- Файл №521 ---
Путь: main\java\mchorse\blockbuster_pack\client\render\layers\LayerBodyPart.java
--------------------
package mchorse.blockbuster_pack.client.render.layers;

import org.lwjgl.opengl.GL11;

import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.blockbuster_pack.morphs.CustomMorph;
import mchorse.metamorph.bodypart.BodyPart;
import net.minecraft.client.renderer.entity.layers.LayerRenderer;
import net.minecraft.entity.EntityLivingBase;

/**
 * Layer body part
 * 
 * This bad boy is responsible for rendering body-parts on the model. 
 * This should look very cool! 
 */
public class LayerBodyPart implements LayerRenderer<EntityLivingBase>
{
    private RenderCustomModel renderer;

    public LayerBodyPart(RenderCustomModel renderer)
    {
        this.renderer = renderer;
    }

    @Override
    public void doRenderLayer(EntityLivingBase entitylivingbaseIn, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        CustomMorph morph = this.renderer.current;

        if (morph == null)
        {
            return;
        }

        ModelCustom model = (ModelCustom) this.renderer.getMainModel();

        renderBodyParts(entitylivingbaseIn, morph, model, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale);

        this.renderer.current = morph;
        this.renderer.setupModel(entitylivingbaseIn, partialTicks);
    }

    public static void renderBodyParts(EntityLivingBase target, CustomMorph morph, ModelCustom model, float partialTicks, float scale)
    {
        renderBodyParts(target, morph, model, 0, 0, partialTicks, 0, 0, 0, scale);
    }

    public static void renderBodyParts(EntityLivingBase target, CustomMorph morph, ModelCustom model, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        ModelPose pose = model.pose;
        float swingProgress = model.swingProgress;

        for (BodyPart part : morph.parts.parts)
        {
            for (ModelCustomRenderer limb : model.limbs)
            {
                if (limb.limb.name.equals(part.limb))
                {
                    GL11.glPushMatrix();
                    limb.postRender(scale);
                    part.render(morph, target, partialTicks);
                    GL11.glPopMatrix();

                    break;
                }
            }

            /* Restore back properties */
            model.swingProgress = swingProgress;
            model.pose = pose;
            model.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, target);

            /* No point to render here since if a limb wasn't found 
             * then it wouldn't be transformed correctly */
        }
    }

    @Override
    public boolean shouldCombineTextures()
    {
        return false;
    }
}

==================================================

--- Файл №522 ---
Путь: main\java\mchorse\blockbuster_pack\client\render\layers\LayerCustomHead.java
--------------------
package mchorse.blockbuster_pack.client.render.layers;

import java.util.UUID;

import com.mojang.authlib.GameProfile;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelLimb.ArmorSlot;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.render.RenderCustomModel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.client.renderer.entity.layers.LayerRenderer;
import net.minecraft.client.renderer.tileentity.TileEntitySkullRenderer;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.Items;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.Item;
import net.minecraft.item.ItemArmor;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTUtil;
import net.minecraft.tileentity.TileEntitySkull;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.StringUtils;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Custom head layer
 */
@SideOnly(Side.CLIENT)
public class LayerCustomHead implements LayerRenderer<EntityLivingBase>
{
    public RenderCustomModel render;

    public LayerCustomHead(RenderCustomModel render)
    {
        this.render = render;
    }

    /**
     * Render the layer
     *
     * This method is responsible for rendering either skull with 
     * player's name or an item (i.e. block or something) on custom 
     * model's head.
     */
    @Override
    public void doRenderLayer(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        ItemStack stack = entity.getItemStackFromSlot(EntityEquipmentSlot.HEAD);
        ModelBase base = this.render.getMainModel();

        if (base instanceof ModelCustom && stack != null && stack.getItem() != null)
        {
            ModelCustom model = (ModelCustom) base;

            for (ModelCustomRenderer limb : model.armor)
            {
                if (limb.limb.slot != ArmorSlot.HEAD)
                {
                    continue;
                }

                GlStateManager.pushMatrix();

                limb.postRender(scale);
                base.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, entity);

                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
                this.renderItem(entity, stack, limb.limb, limbSwing);
                GlStateManager.popMatrix();
            }
        }
    }

    /**
     * This code is taken from
     * {@link net.minecraft.client.renderer.entity.layers.LayerCustomHead} 
     * in order to make blocks rendering available for usage. 
     */
    protected void renderItem(EntityLivingBase entity, ItemStack stack, ModelLimb limb, float limbSwing)
    {
        Item item = stack.getItem();
        Minecraft mc = Minecraft.getMinecraft();

        float w = limb.size[0] / 8F;
        float h = limb.size[1] / 8F;
        float d = limb.size[2] / 8F;

        float offsetX = limb.anchor[0] * w / 2;
        float offsetY = limb.anchor[1] * h / 2;
        float offsetZ = limb.anchor[2] * d / 2;

        /* Player skull rendering */
        if (item == Items.SKULL)
        {
            /* Limb */
            GlStateManager.translate(-w / 4 + offsetX, h / 2 - offsetY, d / 4 - offsetZ);
            GlStateManager.scale(1.1875F * w, -1.1875F * h, -1.1875F * d);

            GameProfile gameprofile = null;

            if (stack.hasTagCompound())
            {
                NBTTagCompound nbttagcompound = stack.getTagCompound();

                if (nbttagcompound.hasKey("SkullOwner", 10))
                {
                    gameprofile = NBTUtil.readGameProfileFromNBT(nbttagcompound.getCompoundTag("SkullOwner"));
                }
                else if (nbttagcompound.hasKey("SkullOwner", 8))
                {
                    String s = nbttagcompound.getString("SkullOwner");

                    if (!StringUtils.isNullOrEmpty(s))
                    {
                        gameprofile = TileEntitySkull.updateGameprofile(new GameProfile((UUID) null, s));
                        nbttagcompound.setTag("SkullOwner", NBTUtil.writeGameProfile(new NBTTagCompound(), gameprofile));
                    }
                }
            }

            TileEntitySkullRenderer.instance.renderSkull(-0.5F, 0.0F, -0.5F, EnumFacing.UP, 180.0F, stack.getMetadata(), gameprofile, -1, limbSwing);
        }
        else if (!(item instanceof ItemArmor) || ((ItemArmor) item).getEquipmentSlot() != EntityEquipmentSlot.HEAD)
        {
            /* Custom block rendering */
            GlStateManager.translate(-w / 4 + offsetX, h / 4 - offsetY, d / 4 - offsetZ);
            GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
            GlStateManager.scale(0.625F * w, -0.625F * h, -0.625F * d);

            mc.getItemRenderer().renderItem(entity, stack, ItemCameraTransforms.TransformType.HEAD);
        }
    }

    @Override
    public boolean shouldCombineTextures()
    {
        return false;
    }
}

==================================================

--- Файл №523 ---
Путь: main\java\mchorse\blockbuster_pack\client\render\layers\LayerElytra.java
--------------------
package mchorse.blockbuster_pack.client.render.layers;

import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelLimb.ArmorSlot;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster_pack.client.model.ModelElytra;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.layers.LayerArmorBase;
import net.minecraft.client.renderer.entity.layers.LayerRenderer;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.Items;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Fully copy-paste of LayerElytra from net.minecraft.client.render.layers
 */
@SideOnly(Side.CLIENT)
public class LayerElytra implements LayerRenderer<EntityLivingBase>
{
    /**
     * Texture of elytra located in minecraft's assets package
     */
    private static final ResourceLocation TEXTURE_ELYTRA = new ResourceLocation("textures/entity/elytra.png");

    private final ModelElytra modelElytra = new ModelElytra();
    private final RenderLivingBase<?> renderPlayer;

    public LayerElytra(RenderLivingBase<?> render)
    {
        this.renderPlayer = render;
    }

    @Override
    public void doRenderLayer(EntityLivingBase entity, float limbSwing, float limbSwingAmount, float partialTicks, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        ItemStack itemstack = entity.getItemStackFromSlot(EntityEquipmentSlot.CHEST);

        if (itemstack != null && itemstack.getItem() == Items.ELYTRA)
        {
            ModelBase base = this.renderPlayer.getMainModel();

            if (!(base instanceof ModelCustom))
            {
                return;
            }

            ModelCustom model = (ModelCustom) base;

            for (ModelCustomRenderer renderer : model.armor)
            {
                ModelLimb limb = renderer.limb;

                if (limb.slot != ArmorSlot.CHEST)
                {
                    continue;
                }

                int w = limb.size[0];
                int h = limb.size[1];
                int d = limb.size[2];

                float ww = w / 8F;
                float hh = h / 8F;
                float dd = d / 8F;

                float offsetX = limb.anchor[0] * ww / 2;
                float offsetY = limb.anchor[1] * hh / 2;
                float offsetZ = limb.anchor[2] * dd / 2;

                this.renderPlayer.bindTexture(TEXTURE_ELYTRA);

                GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
                GlStateManager.pushMatrix();

                renderer.postRender(scale);
                GlStateManager.translate(-ww / 4 + offsetX, hh / 4 - offsetY, dd / 4 - offsetZ);
                GlStateManager.scale(w / 8F, h / 12F, d / 4F);
                GlStateManager.translate(0.0F, -0.125F * 2.75F, 0.125F);
                this.modelElytra.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, entity);
                this.modelElytra.render(entity, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);

                if (itemstack.isItemEnchanted())
                {
                    LayerArmorBase.renderEnchantedGlint(this.renderPlayer, entity, this.modelElytra, limbSwing, limbSwingAmount, partialTicks, ageInTicks, netHeadYaw, headPitch, scale);
                }

                GlStateManager.popMatrix();
            }
        }
    }

    @Override
    public boolean shouldCombineTextures()
    {
        return false;
    }
}

==================================================

--- Файл №524 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\BetterLightsMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import dz.betterlights.BetterLightsMod;
import dz.betterlights.lighting.lightcasters.LightCaster;
import dz.betterlights.lighting.lightcasters.StaticLightCaster;
import dz.betterlights.lighting.lightcasters.features.ILightConfig;
import dz.betterlights.utils.BetterLightsConstants;
import dz.betterlights.utils.ConfigProperty;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.render.tileentity.TileEntityGunItemStackRenderer;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer;
import mchorse.blockbuster.events.TickHandler;
import mchorse.blockbuster.utils.ExpirableRunnable;
import mchorse.blockbuster_pack.trackers.ApertureCamera;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.render.VertexBuilder;
import mchorse.mclib.config.values.*;
import mchorse.mclib.utils.*;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.Optional;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.joml.Matrix3d;
import org.lwjgl.opengl.GL11;

import javax.annotation.Nullable;
import javax.vecmath.Matrix4d;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import java.lang.reflect.Field;
import java.util.*;
import java.util.function.Consumer;

import static dz.betterlights.utils.ConfigProperty.EnumPropertyType.COLOR_PICKER;

public class BetterLightsMorph extends BetterLightsMorphTemplate implements IAnimationProvider, ISyncableMorph, IMorphGenerator {
    private BetterLightsRunnable dummy;
    /**
     * Cast this to LightCaster
     * Type is Object as the BetterLights dependency is optional.
     */
    private Object lightCaster;
    private final Vector3d position = new Vector3d();
    private final Vector3d prevPosition = new Vector3d();
    private final Matrix4d rotation = new Matrix4d();
    /**
     * Helper variable to detect a render cycle and store if the morph was rendered in hands, gui etc.
     * true when the last update tick happened. Is set to false when a render cycle starts.
     */
    private boolean updateTick = false;
    private boolean renderedInHand = false;
    private boolean renderedItemGui = false;
    private boolean enableAlways = false;
    /**
     * The values influenced by animation and other dynamic stuff.
     * These are the final values that are set to the {@link #lightCaster}
     */
    private final BetterLightsProperties properties = new BetterLightsProperties();
    private BetterLightsAnimation animation = new BetterLightsAnimation();
    /**
     * The values of this morph set by GUI and serialization
     */
    private final ValueSerializer values = new ValueSerializer();
    /**
     * Cached so in case the mod is not loaded the old nbt will be serialized so no data is lost.
     */
    private NBTTagCompound nbt;

    public BetterLightsMorph() {
        super();
        this.name = "betterLights";
        this.values.copy(BetterLightsProperties.TEMPLATE);
    }

    public ValueSerializer getValueManager()
    {
        return this.values;
    }

    public boolean isEnableAlways() {
        return this.enableAlways;
    }

    public void setEnableAlways(boolean enableAlways) {
        this.enableAlways = enableAlways;
    }

    public boolean isMorphEnabled() {
        return Blockbuster.enableBetterLights.get() || this.enableAlways;
    }

    @Optional.Method(modid = BetterLightsConstants.ID)
    public LightCaster getLightcaster()
    {
        /*
         * keep a lightcaster instance no matter what the blockbuster config enable setting is.
         * if the config is disabled, the dummy entity will die out and remove the lightcaster from betterlights.
         * We need a lightcaster instance to render the spotlight cone.
         */
        if (this.lightCaster == null) {
            LightCaster lightCaster = new StaticLightCaster();
            lightCaster.setPermanent(true);

            this.lightCaster = lightCaster;
        }

        return (LightCaster) this.lightCaster;
    }

    @Override
    @Optional.Method(modid = BetterLightsConstants.ID)
    public void update(EntityLivingBase target)
    {
        this.updateTick = true;
        if (target.world.isRemote && (!this.renderedItemGui || this.renderedInHand) && this.isMorphEnabled())
        {
            /* bruh this is for everything else except immersive editor as it does not update and creates a new instance wtf */
            this.createDummyEntitiy(target);
            this.dummy.setLifetime(this.dummy.getAge() + 1);
        }

        this.animation.update();

        super.update(target);
    }

    @SideOnly(Side.CLIENT)
    private void updateAnimation(float partialTicks)
    {
        this.properties.from(this);

        if (this.animation.isInProgress())
        {
            this.animation.apply(this.properties, partialTicks);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    @Optional.Method(modid = BetterLightsConstants.ID)
    protected void createDummyEntitiy()
    {
        this.createDummyEntitiy(null);
    }

    @Override
    @SideOnly(Side.CLIENT)
    @Optional.Method(modid = BetterLightsConstants.ID)
    protected void createDummyEntitiy(@Nullable EntityLivingBase target)
    {
        if ((this.dummy == null || this.dummy.shouldRemove()) && this.isMorphEnabled())
        {
            /*
             * if the rendered position is 0, it is likely that the morph has not been rendered yet
             * and the target entity position is far away from 0, if the dummy entity is set to 0 it will have update issues
             * because it is out of range, so set it to the target entity position for the start.
             */
            if (this.position.equals(new Vector3d(0, 0, 0)) && target != null)
            {
                this.position.set(target.posX, target.posY, target.posZ);
                this.prevPosition.set(target.posX, target.posY, target.posZ);
            }

            this.dummy = new BetterLightsRunnable(Minecraft.getMinecraft().world, this.getLightcaster(), 0);

            this.updateLightcaster();
            this.addToWorld();
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    @Optional.Method(modid = BetterLightsConstants.ID)
    protected void addToWorld() {
        Blockbuster.proxy.tickHandler.addRunnable(TickHandler.WorldClientTickEvent.class, Side.CLIENT, TickEvent.Phase.START, this.dummy);
        BetterLightsMod.getLightManager().addTemporaryLightCaster(Minecraft.getMinecraft().world, this.getLightcaster(), false);
    }

    @Override
    @Optional.Method(modid = BetterLightsConstants.ID)
    protected void updateLightcaster()
    {
        BetterLightsProperties.APPLY.forEach((consumer) -> consumer.accept(this));
        this.getLightcaster().pos((float) this.position.x, (float) this.position.y, (float) this.position.z);
    }

    @Override
    public void renderOnScreen(EntityPlayer entityPlayer, int x, int y, float scale, float alpha) {
        float partial = Minecraft.getMinecraft().getRenderPartialTicks();
        this.updateAnimation(partial);

        GL11.glPushMatrix();
        GL11.glTranslatef(x, y - scale / 2, 0);
        GL11.glScalef(1.35F, -1.35F, 1.35F);

        RenderingUtils.renderImage(new ResourceLocation(Blockbuster.MOD_ID, "textures/spotlight.png"), scale);

        /* we can't use lightcaster here because we also want to render when the mod is not loaded */
        java.util.Optional<GenericBaseValue<?>> oValue = this.properties.values.getValue("Color");

        if (oValue.isPresent())
        {
            Color color = ((ValueColor) oValue.get()).get();

            RenderingUtils.renderImage(new ResourceLocation(Blockbuster.MOD_ID, "textures/spotlight_light.png"), scale, color);
        }

        GL11.glPopMatrix();
    }

    @Override
    @Optional.Method(modid = BetterLightsConstants.ID)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks) {
        /*
         * ApertureCamera is the tracker modifier and it
         * renders morphs again which causes transformations to be messed up
         */
        if (OptifineHelper.isOptifineShadowPass() || ApertureCamera.enable)
        {
            return;
        }

        this.updateAnimation(partialTicks);

        EntityLivingBase lastItemHolder = RenderingHandler.getLastItemHolder();
        ItemCameraTransforms.TransformType itemTransformType = RenderingHandler.itemTransformType;

        boolean renderedInHands = lastItemHolder != null && (itemTransformType == ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND || itemTransformType == ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND);
        boolean renderedInThirdPerson = lastItemHolder != null && (itemTransformType == ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND || itemTransformType == ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND);
        boolean itemRendering = TileEntityModelItemStackRenderer.isRendering() || TileEntityGunItemStackRenderer.isRendering();

        /* begin of a new rendering cycle */
        if (this.updateTick)
        {
            this.renderedInHand = false;
            this.renderedItemGui = false;
            this.updateTick = false;
        }

        /* set the rendering variables once per render cycle */
        if (renderedInHands || renderedInThirdPerson) this.renderedInHand = true;
        if (itemTransformType == ItemCameraTransforms.TransformType.GUI && itemRendering) this.renderedItemGui = true;

        GlStateManager.pushMatrix();
        GL11.glTranslated(x, y, z);

        Matrix4d[] transformation = MatrixUtils.getTransformation();
        transformation[1].transpose();
        this.rotation.set(transformation[1]);
        /* rendered not in first person */
        if (renderedInThirdPerson || lastItemHolder == null && (!itemRendering || itemTransformType == ItemCameraTransforms.TransformType.GROUND))
        {
            this.position.x = (float) transformation[0].m03;
            this.position.y = (float) transformation[0].m13;
            this.position.z = (float) transformation[0].m23;

        }
        /* for rendering in first person */
        else if (renderedInHands)
        {
            this.position.x = (float) Interpolations.lerp(lastItemHolder.prevPosX, lastItemHolder.posX, partialTicks);
            this.position.y = (float) Interpolations.lerp(lastItemHolder.prevPosY, lastItemHolder.posY, partialTicks) + lastItemHolder.getEyeHeight();
            this.position.z = (float) Interpolations.lerp(lastItemHolder.prevPosZ, lastItemHolder.posZ, partialTicks);

            double offsetZ = lastItemHolder.getEntityBoundingBox().maxZ - lastItemHolder.getEntityBoundingBox().minZ;
            Vector3d offset = new Vector3d(0, 0, offsetZ);
            this.rotation.transform(offset);
            this.position.add(offset);
        }

        /* for immersive editor as it does not call update method -> update age here */
        if (GuiModelRenderer.isRendering() && this.isMorphEnabled()) {
            this.createDummyEntitiy(entity);
            this.dummy.setLifetime(this.dummy.getAge() + 2);
        }

        this.updateLightcaster();

        if ((Minecraft.getMinecraft().gameSettings.showDebugInfo || GuiModelRenderer.isRendering()) && this.lightCaster != null)
        {
            this.renderSpotlightCone(2);
        }

        this.prevPosition.set(this.position);

        GlStateManager.popMatrix();
    }

    @Optional.Method(modid = BetterLightsConstants.ID)
    protected void renderSpotlightCone(int lineThickness)
    {
        float outerRadius = this.getLightcaster().getDistance() * (float) Math.tan(Math.toRadians(this.getLightcaster().getOuterAngle()));
        float innerRadius = Math.min(outerRadius, this.getLightcaster().getDistance() * (float) Math.tan(Math.toRadians(this.getLightcaster().getInnerAngle())));
        /*
         * can't retrieve the direction value from the lightcaster instance, as those are transformed by the morph's rotation
         * and therefore not suitable for getting the rotation for rendering a cone in the UI
         */
        GenericNumberValue<?> x = (GenericNumberValue<?>) this.properties.values.getValue("DirectionX")
                .flatMap((v) -> java.util.Optional.ofNullable(v instanceof GenericNumberValue<?> ? v : null))
                .orElse((GenericBaseValue) new ValueDouble("", 0));
        GenericNumberValue<?> y = (GenericNumberValue<?>) this.properties.values.getValue("DirectionY")
                .flatMap((v) -> java.util.Optional.ofNullable(v instanceof GenericNumberValue<?> ? v : null))
                .orElse((GenericBaseValue) new ValueDouble("", 0));
        GenericNumberValue<?> z = (GenericNumberValue<?>) this.properties.values.getValue("DirectionZ")
                .flatMap((v) -> java.util.Optional.ofNullable(v instanceof GenericNumberValue<?> ? v : null))
                .orElse((GenericBaseValue) new ValueDouble("", 1));

        org.joml.Vector3d direction = new org.joml.Vector3d(x.get().doubleValue(), y.get().doubleValue(), z.get().doubleValue());
        Vector3d directionNorm = new Vector3d(0, 0, this.getLightcaster().getDistance());
        org.joml.Vector3d rot = new Matrix3d().rotateTowards(direction, new org.joml.Vector3d(0, 0,1))
                .getEulerAnglesXYZ(new org.joml.Vector3d());
        Color color = new Color(this.getLightcaster().getColor().x, this.getLightcaster().getColor().y, this.getLightcaster().getColor().z);

        GlStateManager.pushMatrix();
        GlStateManager.rotate((float) Math.toDegrees(rot.x), 1, 0, 0);
        GlStateManager.rotate((float) Math.toDegrees(rot.y), 0, 1, 0);
        GlStateManager.rotate((float) Math.toDegrees(rot.z), 0, 0, 1);

        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, 240);
        GlStateManager.disableLighting();
        GlStateManager.disableTexture2D();
        if (GuiModelRenderer.isRendering()) GlStateManager.disableDepth();
        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);

        BufferBuilder builder = Tessellator.getInstance().getBuffer();

        RenderingUtils.renderCircle(directionNorm, directionNorm, outerRadius, 32, color, lineThickness);
        RenderingUtils.renderCircleDotted(directionNorm, directionNorm, innerRadius, 32, color, lineThickness, 1);

        builder.begin(GL11.GL_LINE_STRIP, VertexBuilder.getFormat(true, false, false, false));
        GL11.glLineWidth(lineThickness);

        builder.pos(0,0,0).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(outerRadius, 0, this.getLightcaster().getDistance()).color(color.r, color.g, color.b, color.a).endVertex();

        builder.pos(0,0,0).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(-outerRadius, 0, this.getLightcaster().getDistance()).color(color.r, color.g, color.b, color.a).endVertex();

        builder.pos(0,0,0).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(0, outerRadius, this.getLightcaster().getDistance()).color(color.r, color.g, color.b, color.a).endVertex();

        builder.pos(0,0,0).color(color.r, color.g, color.b, color.a).endVertex();
        builder.pos(0, -outerRadius, this.getLightcaster().getDistance()).color(color.r, color.g, color.b, color.a).endVertex();

        Tessellator.getInstance().draw();
        GlStateManager.enableTexture2D();
        GlStateManager.popMatrix();

        if (GuiModelRenderer.isRendering()) GlStateManager.enableDepth();
    }

    /**
     * @return true, as BetterLightsMorph needs the entity in the bodypart to create a dummy entity with the correct position.
     */
    @Override
    public boolean useTargetDefault()
    {
        return true;
    }

    @Override
    public AbstractMorph create()
    {
        return new BetterLightsMorph();
    }

    @Override
    public float getWidth(EntityLivingBase entityLivingBase)
    {
        return 0;
    }

    @Override
    public float getHeight(EntityLivingBase entityLivingBase)
    {
        return 0;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.nbt = tag.copy();

        this.values.fromNBT(tag);

        if (tag.hasKey("Animation"))
        {
            this.animation.fromNBT(tag.getCompoundTag("Animation"));
        }

        if (tag.hasKey("EnableAlways")) {
            this.enableAlways = tag.getBoolean("EnableAlways");
        }
    }

    /**
     * Setting this method to optional guarantees, that saved NBT will not be lost when BetterLights mod is not loaded.
     */
    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (BetterLightsHelper.isBetterLightsLoaded())
        {
            this.values.toNBT(tag);

            NBTTagCompound animation = this.animation.toNBT();

            if (!animation.hasNoTags())
            {
                tag.setTag("Animation", animation);
            }

            /*
             * Minecraft has a mechanism that prevents new ItemStack instances when the NBT is equal
             * Adding a random UUID will force a new ItemStack instance.
             */
            tag.setString("UUID", UUID.randomUUID().toString());
        }
        else if (this.nbt != null)
        {
            /* store the nbt tags again that were read in the beginning to avoid data loss */
            for (String key : this.nbt.getKeySet())
            {
                tag.setTag(key, this.nbt.getTag(key));
            }
        }

        if (this.enableAlways) tag.setBoolean("EnableAlways", this.enableAlways);
    }

    @Override
    public boolean canMerge(AbstractMorph morph0)
    {
        if (morph0 instanceof BetterLightsMorph)
        {
            BetterLightsMorph morph = (BetterLightsMorph) morph0;

            this.mergeBasic(morph0);

            if (!morph.animation.ignored)
            {
                if (this.animation.isInProgress())
                {
                    BetterLightsProperties newLast = new BetterLightsProperties();

                    newLast.from(this);

                    this.animation.apply(newLast, 0);

                    this.animation.last = newLast;
                }
                else
                {
                    this.animation.last = new BetterLightsProperties();

                    this.animation.last.from(this);
                }

                this.animation.merge(this, morph);
                this.copy(morph);
                this.animation.progress = 0;
            }
            else
            {
                this.animation.ignored = true;
            }

            return true;
        }

        return super.canMerge(morph0);
    }

    @Override
    public Animation getAnimation() {
        return this.animation;
    }

    @Override
    public boolean canGenerate() {
        return this.animation.isInProgress();
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks) {
        BetterLightsMorph morph = (BetterLightsMorph) this.copy();

        morph.properties.from(this);
        morph.animation.last = new BetterLightsProperties();
        morph.animation.last.from(this);

        morph.animation.apply(morph.properties, partialTicks);

        morph.animation.duration = this.animation.progress;

        return morph;
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        if (previous instanceof BetterLightsMorph)
        {
            BetterLightsMorph morph = (BetterLightsMorph) previous;

            if (morph.animation.isInProgress())
            {
                BetterLightsProperties newLast = new BetterLightsProperties();

                newLast.from(morph);
                morph.animation.apply(newLast, 1);

                this.animation.last = newLast;
            }
            else
            {
                this.animation.last = new BetterLightsProperties();

                this.animation.last.from(morph);
            }
        }
    }

    @Override
    public boolean isPaused() {
        return this.animation.paused;
    }

    @Override
    public void reset()
    {
        super.reset();

        this.animation.reset();
    }

    @Override
    public boolean equals(Object object)
    {
        boolean result = super.equals(object);

        if (object instanceof BetterLightsMorph)
        {
            BetterLightsMorph morph = (BetterLightsMorph) object;

            result = result && this.values.equalsValues(morph.values);
            result = result && Objects.equals(morph.animation, this.animation);
            result = result && this.enableAlways == morph.enableAlways;

            return result;
        }

        return result;
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof BetterLightsMorph)
        {
            BetterLightsMorph morph = (BetterLightsMorph) from;

            if (morph.nbt != null) this.nbt = morph.nbt.copy();
            this.values.copyValues(morph.values);
            this.animation.copy(morph.animation);
            this.animation.reset();
            this.enableAlways = morph.enableAlways;
        }
    }

    public static class BetterLightsAnimation extends Animation
    {
        public BetterLightsProperties last;

        public void merge(BetterLightsMorph last, BetterLightsMorph next)
        {
            this.merge(next.animation);

            if (this.last == null)
            {
                this.last = new BetterLightsProperties();
            }

            this.last.from(last);
        }

        public void apply(BetterLightsProperties properties, float partialTicks)
        {
            if (this.last == null)
            {
                return;
            }

            float factor = this.getFactor(partialTicks);

            properties.values.interpolateFrom(this.interp, this.last.values, factor);
        }
    }

    public static class BetterLightsProperties
    {
        /**
         * The value tree of the BetterLights Lightcaster.
         * Useful to generate other things with better handling of paths and nesting
         */
        public final static Value valueTree = new Value("");
        /**
         * Generate the values once with reflection and store them here
         * Nested values will be stored directly here, the tree is flattened.
         */
        private final static ValueSerializer TEMPLATE = new ValueSerializer();
        /**
         * Functional programming, wohooo :3, here we store functions to apply a value to the lightcaster of the BetterLightsMorph
         * This is especially needed as some values may need some conversion or special handling
         * like rotating the direction vector with the morph's rotation.
         * The Consumer uses {@link #properties} and the stored value path in the Consumer to apply the values
         * to the lightcaster.
         */
        private final static List<Consumer<BetterLightsMorph>> APPLY = new ArrayList<>();
        private final ValueSerializer values = new ValueSerializer();

        static
        {
            try
            {
                Class.forName("dz.betterlights.lighting.lightcasters.LightCaster");
                generate();
            }
            catch (Exception e) { }
        }

        /**
         * Generate the {@link #valueTree} from the LightCaster class.
         */
        @Optional.Method(modid = BetterLightsConstants.ID)
        private static void generate()
        {
            StaticLightCaster lightCaster = new StaticLightCaster();
            lightCaster.direction(0, 0, 1F);
            lightCaster.color(1F, 0.905F, 0.584F);

            generateValuesTemplate(LightCaster.class, null, valueTree, lightCaster);
        }

        /**
         * This generates the values in {@link #TEMPLATE} based on the LightCaster class.
         * Nested config properties will still be put into the {@link #TEMPLATE} directly,
         * i.e. the tree of config values will be flattened.
         * @param clazz the class to generate the values off.
         * @param parentField for nested config properties we need to build a tree of fields.
         * @param parent with this we generate new value paths for values that are nested in the lightcaster in sub configs.
         * @param defaultLightCaster contains the defautlValues.
         */
        @Optional.Method(modid = BetterLightsConstants.ID)
        private static void generateValuesTemplate(Class<?> clazz, @Nullable FieldHierarchy parentField, Value parent, LightCaster defaultLightCaster)
        {
            /* LightConfig interface has boolean methods for enabled that need to be called */
            if (ILightConfig.class.isAssignableFrom(clazz))
            {
                boolean defaultValue;
                if (parentField == null)
                {
                    defaultValue = defaultLightCaster.isEnabled();
                }
                else
                {
                    Object value = parentField.getValue(defaultLightCaster);
                    if (value == null) return;
                    defaultValue = ((ILightConfig<?>) value).isEnabled();
                }

                ValueBoolean vb = new ValueBoolean("Enabled", defaultValue);
                parent.addSubValue(vb);

                TEMPLATE.registerValue(vb).serializeNBT(vb.getPath(), true);

                APPLY.add((morph) ->
                {
                    LightCaster lightCaster = morph.getLightcaster();

                    morph.properties.values.getValue(vb.getPath()).ifPresent(genericBaseValue ->
                    {
                        Boolean bool = (Boolean) genericBaseValue.get();
                        if (parentField == null)
                        {
                            lightCaster.setEnabled(bool);
                        }
                        else
                        {
                            Object value = parentField.getValue(lightCaster);
                            if (value == null) return;
                            ((ILightConfig<?>) value).setEnabled(bool);
                        }
                    });
                });
            }

            for (Field field : clazz.getDeclaredFields())
            {
                FieldHierarchy fieldSetter = new FieldHierarchy(field);
                if (parentField != null) fieldSetter.parent = parentField;

                field.setAccessible(true);
                ConfigProperty configProperty = field.getAnnotation(ConfigProperty.class);

                /* position is special as it will be controlled by the rendered position and not by the morph itself */
                if(configProperty == null || configProperty.name().equals("Position")) continue;

                String name = configProperty.name();

                if (field.getType().equals(float.class))
                {
                    float defaultValue = 0F;

                    if (configProperty.defaultValue().isEmpty())
                    {
                        Object value = fieldSetter.getValue(defaultLightCaster);
                        defaultValue = value == null ? 0 : (float) value;
                    }
                    else
                    {
                        try
                        {
                            defaultValue = Float.parseFloat(configProperty.defaultValue());
                        }
                        catch (NumberFormatException e)
                        {
                            e.printStackTrace();
                        }
                    }

                    ValueFloat vf = new ValueFloat(name, defaultValue, configProperty.min(), configProperty.max());
                    parent.addSubValue(vf);
                    registerBasicValue(vf, fieldSetter);
                }
                else if (field.getType().equals(int.class))
                {
                    int defaultValue = 0;

                    if (configProperty.defaultValue().isEmpty())
                    {
                        Object value = fieldSetter.getValue(defaultLightCaster);
                        defaultValue = value == null ? 0 : (int) value;
                    }
                    else
                    {
                        try
                        {
                            defaultValue = Integer.parseInt(configProperty.defaultValue());
                        }
                        catch (NumberFormatException e)
                        {
                            e.printStackTrace();
                        }
                    }

                    ValueInt vf = new ValueInt(name, defaultValue, (int) configProperty.min(), (int) configProperty.max());
                    parent.addSubValue(vf);
                    registerBasicValue(vf, fieldSetter);
                }
                else if (field.getType().equals(com.jme3.math.Vector3f.class))
                {
                    Object value = fieldSetter.getValue(defaultLightCaster);
                    com.jme3.math.Vector3f defaultValue = value == null ? new com.jme3.math.Vector3f() : (com.jme3.math.Vector3f) value;

                    /* colors are usually stored as int in BB */
                    if (configProperty.type().equals(COLOR_PICKER))
                    {
                        ValueColor vc = new ValueColor(name, new Color(defaultValue.x, defaultValue.y, defaultValue.z));
                        parent.addSubValue(vc);
                        TEMPLATE.registerValue(vc).serializeNBT(vc.getPath(), true);

                        APPLY.add((morph) ->
                        {
                            LightCaster lightCaster = morph.getLightcaster();

                            morph.properties.values.getValue(vc.getPath()).ifPresent(genericBaseValue -> {
                                Color c = (Color) genericBaseValue.get();
                                fieldSetter.setField(lightCaster, new com.jme3.math.Vector3f(c.r, c.g, c.b));
                            });
                        });
                    }
                    else
                    {
                        ValueFloat vfx = new ValueFloat(name + "X", defaultValue.x);
                        ValueFloat vfy = new ValueFloat(name + "Y", defaultValue.y);
                        ValueFloat vfz = new ValueFloat(name + "Z", defaultValue.z);

                        parent.addSubValue(vfx);
                        parent.addSubValue(vfy);
                        parent.addSubValue(vfz);

                        TEMPLATE.registerValue(vfx).serializeNBT(vfx.getPath(), true);
                        TEMPLATE.registerValue(vfy).serializeNBT(vfy.getPath(), true);
                        TEMPLATE.registerValue(vfz).serializeNBT(vfz.getPath(), true);

                        APPLY.add((morph) ->
                        {
                            LightCaster lightCaster = morph.getLightcaster();

                            java.util.Optional<GenericBaseValue<?>> vx = morph.properties.values.getValue(vfx.getPath());
                            java.util.Optional<GenericBaseValue<?>> vy = morph.properties.values.getValue(vfy.getPath());
                            java.util.Optional<GenericBaseValue<?>> vz = morph.properties.values.getValue(vfz.getPath());

                            if (!vx.isPresent() || !vy.isPresent() || !vz.isPresent()) return;

                            Vector3f vec = new Vector3f(
                                    (Float) vx.get().get(),
                                    (Float) vy.get().get(),
                                    (Float) vz.get().get());

                            if (name.equals("Direction"))
                            {
                                morph.rotation.transform(vec);
                            }

                            fieldSetter.setField(lightCaster, new com.jme3.math.Vector3f(vec.x, vec.y, vec.z));
                        });
                    }
                }
                else if (field.getType().equals(boolean.class))
                {
                    boolean defaultValue;

                    if (configProperty.defaultValue().isEmpty())
                    {
                        Object value = fieldSetter.getValue(defaultLightCaster);
                        defaultValue = value != null && (boolean) value;
                    }
                    else
                    {
                        defaultValue = Boolean.parseBoolean(configProperty.defaultValue());
                    }

                    ValueBoolean vb = new ValueBoolean(name, defaultValue);
                    parent.addSubValue(vb);
                    registerBasicValue(vb, fieldSetter);
                }
                else if (ILightConfig.class.isAssignableFrom(field.getType()))
                {
                    Value subCategory = new Value(configProperty.name());
                    parent.addSubValue(subCategory);
                    generateValuesTemplate(field.getType(), fieldSetter, subCategory, defaultLightCaster);
                }
            }
        }

        private static void registerBasicValue(GenericBaseValue<?> value, FieldHierarchy fieldSetter)
        {
            TEMPLATE.registerValue(value)
                    .serializeNBT(value.getPath(), true);

            APPLY.add((morph) ->
            {
                LightCaster lightCaster = morph.getLightcaster();

                morph.properties.values.getValue(value.getPath())
                        .ifPresent(genericBaseValue -> fieldSetter.setField(lightCaster, genericBaseValue.get()));
            });
        }

        public BetterLightsProperties()
        {
            /* deep copy of the template */
            this.values.copy(TEMPLATE);
        }

        public void from(BetterLightsMorph from)
        {
            this.values.copyValues(from.values);
        }
    }

    /**
     * We need this because we only have direct access to the LightCaster instance,
     * this way we can get the instances of fields nested inside the root LightCaster instance.
     */
    private static class FieldHierarchy
    {
        private Field field;
        private FieldHierarchy parent;

        public FieldHierarchy(Field field)
        {
            this.field = field;
            this.field.setAccessible(true);
        }

        public FieldHierarchy(FieldHierarchy parent, Field field)
        {
            this.field = field;
            this.field.setAccessible(true);
            this.parent = parent;
        }

        private Object getFieldHolder(Object root)
        {
            if (this.parent != null)
            {
                return this.parent.getValue(root);
            }
            else
            {
                return root;
            }
        }

        private Object getValue(Object root)
        {
            try
            {
                if (this.parent != null)
                {
                    return this.field.get(this.parent.getValue(root));
                }

                return this.field.get(root);
            }
            catch (IllegalAccessException e)
            {
                e.printStackTrace();
            }

            return null;
        }

        public void setField(Object root, Object value)
        {
            Object fieldHolder;
            if ((fieldHolder = this.getFieldHolder(root)) != null)
            {
                try
                {
                    this.field.set(fieldHolder, value);
                }
                catch (IllegalAccessException e)
                {
                    e.printStackTrace();
                }
            }
        }
    }

    public static class BetterLightsRunnable extends ExpirableRunnable
    {
        private final Object lightcaster;
        private final World world;

        public BetterLightsRunnable(World world, Object lightCaster, int lifetime)
        {
            super(lifetime);

            this.lightcaster = lightCaster;
            this.world = world;
        }

        @Override
        @Optional.Method(modid = BetterLightsConstants.ID)
        public void run()
        {
            super.run();

            if (this.lightcaster == null) return;

            if (this.shouldRemove())
            {
                BetterLightsMod.getLightManager().removeLightCaster(this.world, (LightCaster) this.lightcaster, false);
            }
        }
    }
}


==================================================

--- Файл №525 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\BetterLightsMorphTemplate.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;

import javax.annotation.Nullable;

/**
 * Declare the optional methods here, so they don't cause NoSuchMethod Exceptions when the mod is not loaded
 */
public abstract class BetterLightsMorphTemplate extends AbstractMorph {
    protected void createDummyEntitiy() { }

    protected void createDummyEntitiy(@Nullable EntityLivingBase target) { }

    protected void addToWorld() { }

    protected void updateLightcaster() {}

    @Override
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks) {}
}


==================================================

--- Файл №526 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\CustomMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import com.google.common.base.Objects;
import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.api.ModelHandler;
import mchorse.blockbuster.api.ModelLimb;
import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.api.formats.obj.ShapeKey;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.render.RenderCustomModel;
import mchorse.blockbuster.common.OrientedBB;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster_pack.client.render.layers.LayerBodyPart;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.NBTUtils;
import mchorse.mclib.utils.RenderingUtils;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.EntityUtils;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.BodyPartManager;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.EntityRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.EnumHand;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Custom morph
 *
 * This is a morph which allows players to use Blockbuster's custom 
 * models as morphs.
 */
public class CustomMorph extends AbstractMorph implements IBodyPartProvider, IAnimationProvider, ISyncableMorph, IMorphGenerator
{
    private static boolean renderingOnScreen;
    /**
     * OrientedBoundingBoxes List by limbs
     */
    public Map<ModelLimb, List<OrientedBB>> orientedBBlimbs;
    
    /**
     * Morph's model
     */
    public Model model;

    /**
     * Current pose 
     */
    protected ModelPose pose;

    /**
     * Current custom pose
     */
    public String currentPose = "";

    /**
     * Apply current pose on sneaking
     */
    public boolean currentPoseOnSneak = false;

    /**
     * Skin for custom morph
     */
    public ResourceLocation skin;

    /**
     * Custom pose 
     */
    public ModelProperties customPose = null;

    /**
     * Map of textures designated to specific OBJ materials 
     */
    public Map<String, ResourceLocation> materials = new HashMap<String, ResourceLocation>();

    /**
     * Scale of this model
     */
    public float scale = 1F;

    /**
     * Scale of this model in morph GUIs
     */
    public float scaleGui = 1F;

    /**
     * Whether this image morph should cut out background color
     */
    public boolean keying;

    /**
     * Animation details
     */
    public PoseAnimation animation = new PoseAnimation();

    /**
     * Body part manager 
     */
    public BodyPartManager parts = new BodyPartManager();

    /**
     * Cached key value 
     */
    private String key;

    private long lastUpdate;

    /* Cape variables */
    public double prevCapeX;
    public double prevCapeY;
    public double prevCapeZ;
    public double capeX;
    public double capeY;
    public double capeZ;

    /**
     * Make hands true!
     */
    public CustomMorph()
    {
        super();

        this.getSettings().hands = true;
    }

    public static boolean isRenderingOnScreen()
    {
        return renderingOnScreen;
    }
    
    /**
     * This method fills the obbsLimb Map with data from the model blueprint.
     * @param force if true it ignores that orientedBBlimbs might already be filled
     */
    public void fillObbs(boolean force)
    {
        if(this.orientedBBlimbs == null || force)
        {
            this.orientedBBlimbs = new HashMap<>();

            if (this.model != null)
            {
                for(ModelLimb limb : this.model.limbs.values())
                {
                    List<OrientedBB> newObbs = new ArrayList<>();

                    for(OrientedBB obb : limb.obbs)
                    {
                        newObbs.add(obb.clone());
                    }

                    this.orientedBBlimbs.put(limb, newObbs);
                }
            }
        }
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        while (previous instanceof IMorphProvider)
        {
            previous = ((IMorphProvider) previous).getMorph();
        }

        if (previous instanceof CustomMorph)
        {
            CustomMorph custom = (CustomMorph) previous;
            ModelPose pose = custom.getCurrentPose();

            if (!this.animation.ignored)
            {
                if (custom.animation.isInProgress() && pose != null)
                {
                    this.animation.last = this.convertProp(custom.animation.calculatePose(pose, 1).copy());
                }
                else
                {
                    this.animation.last = this.convertProp(pose);
                }
            }
            else if (custom.customPose != null)
            {
                this.customPose = custom.customPose;
            }
            else if (!custom.currentPose.isEmpty())
            {
                this.customPose = null;
                this.currentPose = custom.currentPose;
            }

            if (pose != null)
            {
                this.animation.mergeShape(pose.shapes);
            }
        }

        this.parts.pause(previous, offset);
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
    }

    @Override
    public Animation getAnimation()
    {
        return this.animation;
    }

    @Override
    public boolean canGenerate()
    {
        return this.animation.isInProgress();
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks)
    {
        CustomMorph morph = (CustomMorph) this.copy();

        if (this.getCurrentPose() != null)
        {
            morph.customPose = this.convertProp(this.animation.calculatePose(this.getCurrentPose(), partialTicks));
            morph.customPose.shapes.clear();
            morph.customPose.shapes.addAll(this.getShapesForRendering(partialTicks));
        }

        morph.animation.duration = this.animation.progress;

        morph.parts.parts.clear();

        for (BodyPart part : this.parts.parts)
        {
            morph.parts.parts.add(part.genCurrentBodyPart(this, partialTicks));
        }

        return morph;
    }

    public List<ShapeKey> getShapesForRendering(float partialTick)
    {
        if (this.model.shapes.isEmpty())
        {
            return this.getCurrentPose().shapes;
        }

        if (this.animation.isInProgress())
        {
            return this.animation.calculateShapes(this, partialTick);
        }

        return this.getCurrentPose().shapes;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        if (this.model != null)
        {
            return this.model.name;
        }

        return super.getSubclassDisplayName();
    }

    public void changeModel(String model)
    {
        if (Blockbuster.proxy.models.models.get(model) == null)
        {
            return;
        }

        this.name = "blockbuster." + model;
        this.key = null;
        this.model = Blockbuster.proxy.models.models.get(model);
        
        fillObbs(true);

        if (this.customPose != null)
        {
            this.customPose.updateLimbs(this.model, false);
        }
    }

    @Override
    public BodyPartManager getBodyPart()
    {
        return this.parts;
    }

    /**
     * Get a pose for rendering
     */
    public ModelPose getPose(EntityLivingBase target, float partialTicks)
    {
        return this.getPose(target, false, partialTicks);
    }

    /**
     * Get a pose for rendering
     */
    public ModelPose getPose(EntityLivingBase target, boolean ignoreCustom, float partialTicks)
    {
        ModelPose pose = this.getCurrentPose(target, ignoreCustom);

        if (this.animation.isInProgress() && pose != null)
        {
            return this.animation.calculatePose(pose, partialTicks);
        }

        return pose;
    }

    private ModelPose getCurrentPose(EntityLivingBase target, boolean ignoreCustom)
    {
        if (this.customPose != null && !ignoreCustom)
        {
            if (this.currentPoseOnSneak && target.isSneaking() || !this.currentPoseOnSneak)
            {
                return this.customPose;
            }
        }

        String poseName = EntityUtils.getPose(target, this.currentPose, this.currentPoseOnSneak);

        if (target instanceof EntityActor)
        {
            poseName = ((EntityActor) target).isMounted ? "riding" : poseName;
        }

        return this.model == null ? null : this.model.getPose(poseName);
    }

    public ModelPose getCurrentPose()
    {
        return this.customPose != null ? this.customPose : (this.model == null ? null : this.model.getPose(this.currentPose));
    }

    public String getKey()
    {
        if (this.key == null)
        {
            this.key = this.name.replaceAll("^blockbuster\\.", "");
        }

        return this.key;
    }

    public void updateModel()
    {
        this.updateModel(false);
    }

    public void updateModel(boolean force)
    {
        if (this.lastUpdate < ModelHandler.lastUpdate || force)
        {
            this.lastUpdate = ModelHandler.lastUpdate;
            this.model = Blockbuster.proxy.models.models.get(this.getKey());

            fillObbs(true);

            if (this.customPose != null)
            {
                this.customPose.updateLimbs(this.model, false);
            }
        }
    }

    /**
     * Render actor morph on the screen
     *
     * This method overrides parent class method to take in account current
     * morph's skin.
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        renderingOnScreen = true;

        if(this.model != null)
        {
            fillObbs(false);
        }
        
        this.updateModel();

        ModelCustom model = ModelCustom.MODELS.get(this.getKey());

        if (model != null && this.model != null)
        {
            Model data = model.model;

            if (data != null && (data.defaultTexture != null || data.providesMtl || this.skin != null))
            {
                this.parts.initBodyParts();

                model.materials = this.materials;
                model.pose = this.getPose(player, Minecraft.getMinecraft().getRenderPartialTicks());
                model.swingProgress = 0;

                ResourceLocation texture = this.skin == null ? data.defaultTexture : this.skin;
                RenderCustomModel.bindLastTexture(texture);

                this.drawModel(model, player, x, y, scale * data.scaleGui * this.scaleGui, alpha);
            }
        }
        else
        {
            FontRenderer font = Minecraft.getMinecraft().fontRenderer;
            int width = font.getStringWidth(this.name);
            String error = I18n.format("blockbuster.morph_error");

            font.drawStringWithShadow(error, x - font.getStringWidth(error) / 2, y - (int) (font.FONT_HEIGHT * 2.5), 0xff2222);
            font.drawStringWithShadow(this.name, x - width / 2, y - font.FONT_HEIGHT, 0xffffff);
        }

        renderingOnScreen = false;
    }

    /**
     * Draw a {@link ModelBase} without using the {@link RenderManager} (which 
     * adds a lot of useless transformations and stuff to the screen rendering).
     */
    @SideOnly(Side.CLIENT)
    private void drawModel(ModelCustom model, EntityPlayer player, int x, int y, float scale, float alpha)
    {
        float factor = 0.0625F;

        GlStateManager.enableColorMaterial();
        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, 50.0F);
        GlStateManager.scale((-scale), scale, scale);
        GlStateManager.rotate(45.0F, -1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(45.0F, 0.0F, -1.0F, 0.0F);
        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
        GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);

        RenderHelper.enableStandardItemLighting();

        GlStateManager.pushMatrix();
        GlStateManager.disableCull();

        GlStateManager.enableRescaleNormal();
        GlStateManager.scale(-1.0F, -1.0F, 1.0F);
        GlStateManager.translate(0.0F, -1.501F, 0.0F);

        GlStateManager.enableAlpha();

        model.setLivingAnimations(player, 0, 0, 0);
        model.setRotationAngles(0, 0, player.ticksExisted, 0, 0, factor, player);

        GlStateManager.enableDepth();
        GlStateManager.color(1.0F, 1.0F, 1.0F, alpha);

        model.render(player, 0, 0, 0, 0, 0, factor);
        LayerBodyPart.renderBodyParts(player, this, model, 0F, factor);

        GlStateManager.disableDepth();

        GlStateManager.disableRescaleNormal();
        GlStateManager.disableAlpha();
        GlStateManager.popMatrix();

        GlStateManager.popMatrix();

        RenderHelper.disableStandardItemLighting();

        GlStateManager.disableRescaleNormal();
        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public boolean renderHand(EntityPlayer player, EnumHand hand)
    {
        this.updateModel();

        RenderCustomModel renderer = ClientProxy.actorRenderer;

        /* This */
        renderer.current = this;
        renderer.setupModel(player, Minecraft.getMinecraft().getRenderPartialTicks());

        if (renderer.getMainModel() == null)
        {
            return false;
        }

        ResourceLocation location = this.skin != null ? this.skin : (this.model != null ? this.model.defaultTexture : null);

        if (location != null)
        {
            renderer.bindTexture(location);
        }

        if (hand.equals(EnumHand.MAIN_HAND))
        {
            renderer.renderRightArm(player);
        }
        else
        {
            renderer.renderLeftArm(player);
        }

        return true;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        if(this.model != null)
        {
            fillObbs(false);
        }
        
        this.updateModel();

        if (this.model != null)
        {
            this.parts.initBodyParts();

            RenderCustomModel render = ClientProxy.actorRenderer;

            render.current = this;
            render.doRender(entity, x, y, z, entityYaw, partialTicks);
        }
        else
        {
            Minecraft mc = Minecraft.getMinecraft();
            FontRenderer font = mc.fontRenderer;
            RenderManager manager = mc.getRenderManager();

            if (Blockbuster.modelBlockRenderMissingName.get() || mc.gameSettings.showDebugInfo)
            {
                RenderingUtils.glRevertRotationScale();

                EntityRenderer.drawNameplate(font, this.getKey(), (float) x, (float) y + 1, (float) z, 0, manager.playerViewY, manager.playerViewX, mc.gameSettings.thirdPersonView == 2, entity.isSneaking());
            }
        }
    }

    /**
     * Update the player based on its morph abilities and properties. This 
     * method also responsible for updating AABB size. 
     */
    @Override
    public void update(EntityLivingBase target)
    {
        this.updateModel();
        this.animation.update();
        this.parts.updateBodyLimbs(this, target);

        super.update(target);

        if (target.world.isRemote)
        {
            this.updateCapeVariables(target);
        }
    }

    @SideOnly(Side.CLIENT)
    private void updateCapeVariables(EntityLivingBase target)
    {
        this.prevCapeX = this.capeX;
        this.prevCapeY = this.capeY;
        this.prevCapeZ = this.capeZ;

        double dX = target.posX - this.capeX;
        double dY = target.posY - this.capeY;
        double dZ = target.posZ - this.capeZ;
        double multiplier = 0.25D;

        if (Math.abs(dX) > 10)
        {
            this.capeX = target.posX;
            this.prevCapeX = this.capeX;
        }

        if (Math.abs(dY) > 10)
        {
            this.capeY = target.posY;
            this.prevCapeY = this.capeY;
        }

        if (Math.abs(dZ) > 10)
        {
            this.capeZ = target.posZ;
            this.prevCapeZ = this.capeZ;
        }

        this.capeX += dX * multiplier;
        this.capeY += dY * multiplier;
        this.capeZ += dZ * multiplier;
    }

    @Override
    protected void updateUserHitbox(EntityLivingBase target)
    {
        this.pose = this.getPose(target, 0);

        if (this.pose != null)
        {
            float[] pose = this.pose.size;

            this.updateSize(target, pose[0] * this.scale, pose[1] * this.scale);
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return (this.pose != null ? this.pose.size[0] : 0.6F) * this.scale;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return (this.pose != null ? this.pose.size[1] : 1.8F) * this.scale;
    }

    /**
     * Check whether given object equals to this object
     *
     * This method is responsible for checking whether other {@link CustomMorph}
     * has the same skin as this morph. This method plays very big role in
     * morphing and morph acquiring.
     */
    @Override
    public boolean equals(Object object)
    {
        boolean result = super.equals(object);

        if (object instanceof CustomMorph)
        {
            CustomMorph morph = (CustomMorph) object;

            result = result && Objects.equal(this.currentPose, morph.currentPose);
            result = result && Objects.equal(this.skin, morph.skin);
            result = result && Objects.equal(this.customPose, morph.customPose);
            result = result && this.currentPoseOnSneak == morph.currentPoseOnSneak;
            result = result && this.scale == morph.scale;
            result = result && this.scaleGui == morph.scaleGui;
            result = result && this.materials.equals(morph.materials);
            result = result && this.parts.equals(morph.parts);
            result = result && this.keying == morph.keying;
            result = result && this.animation.equals(morph.animation);

            return result;
        }

        return result;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof CustomMorph)
        {
            CustomMorph custom = (CustomMorph) morph;

            this.mergeBasic(morph);

            /* Don't suddenly end the animation in progress, interpolate */
            if (!custom.animation.ignored)
            {
                /* If the last pose is null, it might case a first cycle freeze.
                 * this should fix it. */
                ModelPose pose = this.getCurrentPose();

                if (this.animation.isInProgress() && pose != null)
                {
                    this.animation.last = this.convertProp(this.animation.calculatePose(pose, 0).copy());
                }
                else
                {
                    this.animation.last = this.convertProp(pose);
                }
                
                this.currentPose = custom.currentPose;
                this.customPose = custom.customPose == null ? null : custom.customPose.copy();
                this.animation.merge(custom.animation);

                if (pose != null)
                {
                    this.animation.mergeShape(pose.shapes);
                }
            }
            else
            {
                this.animation.ignored = true;
            }

            this.key = null;
            this.name = custom.name;
            this.skin = RLUtils.clone(custom.skin);
            this.currentPoseOnSneak = custom.currentPoseOnSneak;
            this.scale = custom.scale;
            this.scaleGui = custom.scaleGui;
            this.materials.clear();

            for (Map.Entry<String, ResourceLocation> entry : custom.materials.entrySet())
            {
                this.materials.put(entry.getKey(), RLUtils.clone(entry.getValue()));
            }

            this.parts.merge(custom.parts);
            this.model = custom.model;

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public void afterMerge(AbstractMorph morph)
    {
        super.afterMerge(morph);

        while (morph instanceof IMorphProvider)
        {
            morph = ((IMorphProvider) morph).getMorph();
        }

        if (morph instanceof IBodyPartProvider)
        {
            this.recursiveAfterMerge(this, (IBodyPartProvider) morph);
        }

        if (morph instanceof CustomMorph)
        {
            this.copyPoseForAnimation(this, (CustomMorph) morph);
        }
    }

    private void recursiveAfterMerge(IBodyPartProvider target, IBodyPartProvider destination)
    {
        for (int i = 0, c = target.getBodyPart().parts.size(); i < c; i++)
        {
            if (i >= destination.getBodyPart().parts.size())
            {
                break;
            }

            AbstractMorph a = target.getBodyPart().parts.get(i).morph.get();
            AbstractMorph b = destination.getBodyPart().parts.get(i).morph.get();

            if (a != null)
            {
                a.afterMerge(b);
            }
        }
    }

    private void copyPoseForAnimation(CustomMorph target, CustomMorph destination)
    {
        /* If the last pose is null, it might case a first cycle freeze.
         * this should fix it. */
        ModelPose pose = destination.getCurrentPose();

        target.animation.progress = 0;

        if (destination.animation.isInProgress() && pose != null)
        {
            target.animation.last = this.convertProp(destination.animation.calculatePose(pose, 0).copy());
        }
        else
        {
            target.animation.last = this.convertProp(pose);
        }
    }

    @Override
    public void reset()
    {
        super.reset();

        this.key = null;
        this.parts.reset();
        this.animation.reset();
        this.scale = this.scaleGui = 1F;
    }

    @Override
    public AbstractMorph create()
    {
        return new CustomMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof CustomMorph)
        {
            CustomMorph morph = (CustomMorph) from;

            this.skin = RLUtils.clone(morph.skin);

            this.currentPose = morph.currentPose;
            this.currentPoseOnSneak = morph.currentPoseOnSneak;
            this.scale = morph.scale;
            this.scaleGui = morph.scaleGui;
            this.keying = morph.keying;

            if (morph.customPose != null)
            {
                this.customPose = morph.customPose.copy();
            }

            if (!morph.materials.isEmpty())
            {
                this.materials.clear();

                for (Map.Entry<String, ResourceLocation> entry : morph.materials.entrySet())
                {
                    this.materials.put(entry.getKey(), RLUtils.clone(entry.getValue()));
                }
            }

            this.model = morph.model;
            this.parts.copy(morph.parts);
            this.animation.copy(morph.animation);
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.skin != null)
        {
            tag.setTag("Skin", RLUtils.writeNbt(this.skin));
        }

        if (!this.currentPose.isEmpty()) tag.setString("Pose", this.currentPose);
        if (this.currentPoseOnSneak) tag.setBoolean("Sneak", this.currentPoseOnSneak);
        if (this.scale != 1F) tag.setFloat("Scale", this.scale);
        if (this.scaleGui != 1F) tag.setFloat("ScaleGUI", this.scaleGui);
        if (this.keying) tag.setBoolean("Keying", this.keying);

        if (this.customPose != null)
        {
            tag.setTag("CustomPose", this.customPose.toNBT(new NBTTagCompound()));
        }

        if (!this.materials.isEmpty())
        {
            NBTTagCompound materials = new NBTTagCompound();

            for (Map.Entry<String, ResourceLocation> entry : this.materials.entrySet())
            {
                materials.setTag(entry.getKey(), RLUtils.writeNbt(entry.getValue()));
            }

            tag.setTag("Materials", materials);
        }

        NBTTagList bodyParts = this.parts.toNBT();

        if (bodyParts != null)
        {
            tag.setTag("BodyParts", bodyParts);
        }

        NBTTagCompound animation = this.animation.toNBT();

        if (!animation.hasNoTags())
        {
            tag.setTag("Animation", animation);
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        String name = this.name;

        super.fromNBT(tag);

        /* Replace the current model */
        if (!name.equals(this.name))
        {
            Model model = Blockbuster.proxy.models.models.get(this.getKey());

            this.model = model == null ? this.model : model;
        }

        if (tag.hasKey("Skin"))
        {
            this.skin = RLUtils.create(tag.getTag("Skin"));
        }

        this.currentPose = tag.getString("Pose");
        this.currentPoseOnSneak = tag.getBoolean("Sneak");
        if (tag.hasKey("Scale", NBT.TAG_ANY_NUMERIC)) this.scale = tag.getFloat("Scale");
        if (tag.hasKey("ScaleGUI", NBT.TAG_ANY_NUMERIC)) this.scaleGui = tag.getFloat("ScaleGUI");
        if (tag.hasKey("Keying")) this.keying = tag.getBoolean("Keying");

        if (tag.hasKey("CustomPose", 10))
        {
            this.customPose = new ModelProperties();
            this.customPose.fromNBT(tag.getCompoundTag("CustomPose"));
        }

        if (tag.hasKey("Materials", 10))
        {
            NBTTagCompound materials = tag.getCompoundTag("Materials");

            this.materials.clear();

            for (String key : materials.getKeySet())
            {
                this.materials.put(key, RLUtils.create(materials.getTag(key)));
            }
        }

        if (tag.hasKey("BodyParts", 9))
        {
            this.parts.fromNBT(tag.getTagList("BodyParts", 10));
        }

        if (tag.hasKey("Animation"))
        {
            this.animation.fromNBT(tag.getCompoundTag("Animation"));
        }
    }

    public ModelProperties convertProp(ModelPose pose)
    {
        if (pose == null || pose instanceof ModelProperties)
        {
            return (ModelProperties) pose;
        }

        NBTTagCompound tag = pose.toNBT(new NBTTagCompound());

        ModelProperties props = new ModelProperties();

        props.fromNBT(tag);

        if (this.model != null)
        {
            props.updateLimbs(this.model, true);
        }

        return props;
    }

    /**
     * Animation details 
     */
    public static class PoseAnimation extends Animation
    {
        public Map<String, LimbProperties> lastProps;
        public List<ShapeKey> lastShapes = new ArrayList<ShapeKey>();
        public ModelProperties last;
        public ModelProperties pose = new ModelProperties();

        private List<ShapeKey> temporaryShapes = new ArrayList<ShapeKey>();

        @Override
        public void merge(Animation animation)
        {
            super.merge(animation);
            this.pose.limbs.clear();
        }

        public void mergeShape(List<ShapeKey> shapes)
        {
            this.lastShapes.clear();
            this.lastShapes.addAll(shapes);
        }

        public List<ShapeKey> calculateShapes(CustomMorph morph, float partialTicks)
        {
            float factor = this.getFactor(partialTicks);

            this.temporaryShapes.clear();

            for (ShapeKey key : morph.getCurrentPose().shapes)
            {
                ShapeKey last = null;

                for (ShapeKey previous : this.lastShapes)
                {
                    if (previous.name.equals(key.name))
                    {
                        last = previous;

                        break;
                    }
                }

                this.temporaryShapes.add(new ShapeKey(key.name, this.interp.interpolate(last == null ? 0 : last.value, key.value, factor), key.relative));
            }

            for (ShapeKey key : this.lastShapes)
            {
                ShapeKey last = null;

                for (ShapeKey previous : this.temporaryShapes)
                {
                    if (previous.name.equals(key.name))
                    {
                        last = previous;

                        break;
                    }
                }

                if (last == null)
                {
                    this.temporaryShapes.add(new ShapeKey(key.name, this.interp.interpolate(key.value, 0, factor), key.relative));
                }
            }

            return this.temporaryShapes;
        }

        @Override
        public boolean isInProgress()
        {
            return super.isInProgress() && this.last != null;
        }

        public ModelPose calculatePose(ModelPose current, float partialTicks)
        {
            float factor = this.getFactor(partialTicks);

            for (Map.Entry<String, ModelTransform> entry : current.limbs.entrySet())
            {
                String key = entry.getKey();
                ModelTransform trans = this.pose.limbs.get(key);
                ModelTransform last = this.last.limbs.get(key);

                if (last == null)
                {
                    continue;
                }

                if (trans == null)
                {
                    trans = new LimbProperties();
                    this.pose.limbs.put(key, trans);
                }

                trans.interpolate(last, entry.getValue(), factor, this.interp);
            }

            for (int i = 0; i < this.pose.size.length; i++)
            {
                this.pose.size[i] = this.interp.interpolate(this.last.size[i], current.size[i], factor);
            }

            return this.pose;
        }
    }

    public static class LimbProperties extends ModelTransform
    {
        public float fixed = 0F;
        public float glow = 0F;
        public Color color = new Color(1F, 1F, 1F, 1F);

        public boolean absoluteBrightness = false;

        @Override
        public boolean isDefault()
        {
            return false;
        }

        @Override
        public void copy(ModelTransform transform)
        {
            super.copy(transform);

            if (transform instanceof LimbProperties)
            {
                LimbProperties prop = (LimbProperties) transform;

                this.fixed = prop.fixed;
                this.glow = prop.glow;
                this.color.copy(prop.color);

                this.absoluteBrightness = prop.absoluteBrightness;
            }
        }

        @Override
        public boolean equals(Object obj)
        {
            if (obj instanceof LimbProperties)
            {
                LimbProperties prop = (LimbProperties) obj;

                return super.equals(obj) &&
                        this.fixed == prop.fixed &&
                        Math.abs(this.glow - prop.glow) < 0.0001f &&
                        this.color.equals(prop.color) &&
                        this.absoluteBrightness == prop.absoluteBrightness;
            }

            return false;
        }

        @Override
        public LimbProperties clone()
        {
            LimbProperties b = new LimbProperties();

            b.copy(this);

            return b;
        }

        @Override
        public void fromNBT(NBTTagCompound tag)
        {
            super.fromNBT(tag);

            if (tag.hasKey("F", NBT.TAG_BYTE)) this.fixed = tag.getBoolean("F") ? 1F : 0F;
            if (tag.hasKey("G", NBT.TAG_FLOAT)) this.glow = tag.getFloat("G");
            if (tag.hasKey("C", NBT.TAG_INT)) this.color.set(tag.getInteger("C"));
            if (tag.hasKey("AB", NBT.TAG_BYTE)) this.absoluteBrightness = tag.getBoolean("AB");
        }

        @Override
        public NBTTagCompound toNBT()
        {
            NBTTagCompound tag = new NBTTagCompound();

            if (!this.isDefault())
            {
                if (!equalFloatArray(DEFAULT.translate, this.translate)) tag.setTag("P", NBTUtils.writeFloatList(new NBTTagList(), this.translate));
                if (!equalFloatArray(DEFAULT.scale, this.scale)) tag.setTag("S", NBTUtils.writeFloatList(new NBTTagList(), this.scale));
                if (!equalFloatArray(DEFAULT.rotate, this.rotate)) tag.setTag("R", NBTUtils.writeFloatList(new NBTTagList(), this.rotate));
                if (this.fixed != 0F) tag.setBoolean("F", true);
                if (this.glow > 0.0001F) tag.setFloat("G", this.glow);
                if (this.color.getRGBAColor() != 0xFFFFFFFF) tag.setInteger("C", this.color.getRGBAColor());
                if (this.absoluteBrightness) tag.setBoolean("AB", this.absoluteBrightness);
            }

            return tag;
        }

        @Override
        public void interpolate(ModelTransform a, ModelTransform b, float x, Interpolation interp)
        {
            super.interpolate(a, b, x, interp);

            float fixed = 0F;
            float glow = 0F;
            float cr, cg, cb, ca;

            cr = cg = cb = ca = 1F;

            if (a instanceof LimbProperties)
            {
                LimbProperties l = (LimbProperties) a;

                fixed = l.fixed;
                glow = l.glow;
                cr = l.color.r;
                cg = l.color.g;
                cb = l.color.b;
                ca = l.color.a;
            }

            if (b instanceof LimbProperties)
            {
                LimbProperties l = (LimbProperties) b;

                fixed = interp.interpolate(fixed, l.fixed, x);
                glow = interp.interpolate(glow, l.glow, x);
                cr = interp.interpolate(cr, l.color.r, x);
                cg = interp.interpolate(cg, l.color.g, x);
                cb = interp.interpolate(cb, l.color.b, x);
                ca = interp.interpolate(ca, l.color.a, x);

                this.absoluteBrightness = l.absoluteBrightness;
            }
            else
            {
                fixed = interp.interpolate(fixed, 0F, x);
                glow = interp.interpolate(glow, 0F, x);
                cr = interp.interpolate(cr, 1F, x);
                cg = interp.interpolate(cg, 1F, x);
                cb = interp.interpolate(cb, 1F, x);
                ca = interp.interpolate(ca, 1F, x);

                this.absoluteBrightness = false;
            }

            this.fixed = fixed;
            this.glow = glow;
            this.color.set(cr, cg, cb, ca);
        }

        public void applyGlow(float lastX, float lastY)
        {
            if (this.absoluteBrightness)
            {
                lastX = 0F;
            }

            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, Interpolation.LINEAR.interpolate(lastX, 240, this.glow), lastY);
        }
    }

    public static class ModelProperties extends ModelPose
    {
        @Override
        public ModelProperties copy()
        {
            ModelProperties b = new ModelProperties();

            b.size = new float[] {this.size[0], this.size[1], this.size[2]};

            for (Map.Entry<String, ModelTransform> entry : this.limbs.entrySet())
            {
                b.limbs.put(entry.getKey(), entry.getValue().clone());
            }

            for (ShapeKey key : this.shapes)
            {
                b.shapes.add(key.copy());
            }

            return b;
        }

        public void updateLimbs(Model model, boolean override)
        {
            if (model == null)
            {
                return;
            }

            for (Map.Entry<String, ModelLimb> entry : model.limbs.entrySet())
            {
                ModelLimb limb = entry.getValue();
                LimbProperties prop = (LimbProperties) this.limbs.get(entry.getKey());
                boolean newProp = false;

                if (prop == null)
                {
                    prop = new LimbProperties();
                    newProp = true;

                    this.limbs.put(entry.getKey(), prop);
                }

                if (newProp || override)
                {
                    prop.color.set(limb.color[0], limb.color[1], limb.color[2], limb.opacity);
                    prop.glow = limb.lighting ? 0.0f : 1.0f;
                }
            }
        }

        @Override
        public void fillInMissing(ModelPose pose)
        {
            for (Map.Entry<String, ModelTransform> entry : pose.limbs.entrySet())
            {
                String key = entry.getKey();

                if (!this.limbs.containsKey(key))
                {
                    LimbProperties limb = new LimbProperties();
                    limb.copy(entry.getValue());
                    this.limbs.put(key, limb);
                }
            }
        }

        @Override
        public void fromNBT(NBTTagCompound tag)
        {
            if (tag.hasKey("Size", Constants.NBT.TAG_LIST))
            {
                NBTTagList list = tag.getTagList("Size", 5);

                if (list.tagCount() >= 3)
                {
                    NBTUtils.readFloatList(list, this.size);
                }
            }

            if (tag.hasKey("Poses", Constants.NBT.TAG_COMPOUND))
            {
                this.limbs.clear();

                NBTTagCompound poses = tag.getCompoundTag("Poses");

                for (String key : poses.getKeySet())
                {
                    ModelTransform trans = new LimbProperties();

                    trans.fromNBT(poses.getCompoundTag(key));
                    this.limbs.put(key, trans);
                }
            }

            if (tag.hasKey("Shapes"))
            {
                NBTTagList shapes = tag.getTagList("Shapes", Constants.NBT.TAG_COMPOUND);

                this.shapes.clear();

                for (int i = 0; i < shapes.tagCount(); i++)
                {
                    NBTTagCompound key = shapes.getCompoundTagAt(i);

                    if (key.hasKey("Name") && key.hasKey("Value"))
                    {
                        ShapeKey shapeKey = new ShapeKey();

                        shapeKey.fromNBT(key);
                        this.shapes.add(shapeKey);
                    }
                }
            }
        }
    }
}

==================================================

--- Файл №527 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\ImageMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.client.textures.GifTexture;
import mchorse.mclib.client.render.VertexBuilder;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.RenderingUtils;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import mchorse.vanilla_pack.render.CachedExtrusion;
import mchorse.vanilla_pack.render.ItemExtruder;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL14;

import javax.vecmath.Matrix4d;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4d;
import javax.vecmath.Vector4f;
import java.util.Objects;

/**
 * Image morph 
 * 
 * This bad boy is basically replacement for Imaginary
 */
public class ImageMorph extends AbstractMorph implements IAnimationProvider, ISyncableMorph, IMorphGenerator
{
    public static final Matrix4f matrix = new Matrix4f();

    public static final Vector4d pos = new Vector4d();
    public static final Vector4d uv = new Vector4d();
    public static final Vector4d finalUv = new Vector4d();

    /**
     * Image morph's texture 
     */
    public ResourceLocation texture;

    /**
     * Whether an image morph gets shaded 
     */
    public boolean shaded = true;

    /**
     * Whether an image morph is affected by light map 
     */
    public boolean lighting = true;

    /**
     * Whether an image morph should be always look at the player
     */
    public boolean billboard = false;

    /**
     * Whether to remove the scale and rotation of the parent space
     */
    public boolean removeParentScaleRotation = false;

    public RenderingUtils.Facing facing = RenderingUtils.Facing.ROTATE_XYZ;

    /**
     * Area to crop (x = left, z = right, y = top, w = bottom)
     */
    public Vector4f crop = new Vector4f();

    /**
     * Whether this image morph resizes cropped area
     */
    public boolean resizeCrop;

    /**
     * Color filter for the image morph
     */
    public int color = 0xffffffff;

    /**
     * UV horizontal shift
     */
    public float offsetX;

    /**
     * UV vertical shift
     */
    public float offsetY;

    /**
     * Rotation around Z axis
     */
    public float rotation;

    /**
     * TSR for image morph
     */
    public ModelTransform pose = new ModelTransform();

    /**
     * Whether this image morph should cut out background color
     */
    public boolean keying;

    /**
     * Weather it should have 3d effect (thickness)
     */
    public boolean thickness;

    /**
     * Whether Optifine's shadow should be disabled
     */
    public boolean shadow = true;

    public ImageAnimation animation = new ImageAnimation();
    public ImageProperties image = new ImageProperties();

    public ImageMorph()
    {
        super();

        this.name = "blockbuster.image";
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        if (previous instanceof ImageMorph)
        {
            ImageMorph image = (ImageMorph) previous;

            this.animation.last = new ImageMorph.ImageProperties();
            this.animation.last.from(image);
        }
        else
        {
            this.animation.last = new ImageMorph.ImageProperties();
            this.animation.last.from(this);
        }
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
    }

    @Override
    public Animation getAnimation()
    {
        return this.animation;
    }

    @Override
    public boolean canGenerate()
    {
        return this.animation.isInProgress();
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks)
    {
        ImageMorph morph = (ImageMorph) this.copy();

        morph.image.from(this);
        this.animation.apply(morph.image, partialTicks);

        morph.color = morph.image.color.getRGBAColor();
        morph.crop.set(morph.image.crop);
        morph.pose.copy(morph.image.pose);
        morph.offsetX = morph.image.x;
        morph.offsetY = morph.image.y;
        morph.rotation = morph.image.rotation;

        morph.animation.duration = this.animation.progress;

        return morph;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return I18n.format("blockbuster.morph.image");
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        if (this.texture == null)
        {
            return;
        }

        float partial = Minecraft.getMinecraft().getRenderPartialTicks();

        this.updateAnimation(partial);

        GL11.glPushMatrix();
        GL11.glTranslatef(x, y - scale / 2, 0);
        GL11.glScalef(-1.5F, 1.5F, 1.5F);

        this.renderPicture(scale, player.ticksExisted, partial);

        GL11.glPopMatrix();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        if (!this.shadow && ReflectionUtils.isOptifineShadowPass())
        {
            return;
        }

        if (this.texture == null)
        {
            return;
        }

        this.updateAnimation(partialTicks);

        float lastBrightnessX = OpenGlHelper.lastBrightnessX;
        float lastBrightnessY = OpenGlHelper.lastBrightnessY;
        boolean defaultPose = this.image.pose.isDefault();

        GlStateManager.enableRescaleNormal();

        if (!this.shaded)
        {
            RenderHelper.disableStandardItemLighting();
        }

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240, 240);
        }

        GL11.glPushMatrix();
        GL11.glTranslated(x, y, z);

        if (!defaultPose)
        {
            this.image.pose.applyTranslate();
        }

        Matrix4d[] transformation = MatrixUtils.getTransformation();
        Matrix4d translation = transformation[0];

        if (this.removeParentScaleRotation)
        {
            RenderingUtils.glRevertRotationScale();
        }

        if (this.billboard)
        {
            RenderingUtils.glFacingRotation(this.facing, new Vector3f((float) translation.m03, (float) translation.m13, (float) translation.m23));

            GL11.glRotatef(180.0F, 0.0F, 0.0F, 1.0F);
        }

        if (!defaultPose)
        {
            this.image.pose.applyRotate();
        }

        if (!this.billboard)
        {
            float entityPitch = entity.prevRotationPitch + (entity.rotationPitch - entity.prevRotationPitch) * partialTicks;

            GL11.glRotatef(180.0F - entityYaw, 0.0F, 1.0F, 0.0F);
            GL11.glRotatef(180.0F - entityPitch, 1.0F, 0.0F, 0.0F);
        }

        if (!defaultPose)
        {
            this.image.pose.applyScale();
        }

        this.renderPicture(1F, entity.ticksExisted, partialTicks);

        GL11.glPopMatrix();

        if (!this.shaded)
        {
            GlStateManager.enableLighting();
            GlStateManager.enableLight(0);
            GlStateManager.enableLight(1);
            GlStateManager.enableColorMaterial();
        }

        if (!this.lighting)
        {
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastBrightnessX, lastBrightnessY);
        }

        GlStateManager.disableRescaleNormal();
    }

    @SideOnly(Side.CLIENT)
    private void updateAnimation(float partialTicks)
    {
        if (this.animation.isInProgress())
        {
            this.image.from(this);
            this.animation.apply(this.image, partialTicks);
        }
        else
        {
            this.image.from(this);
        }
    }

    private void renderPicture(float scale, int ticks, float partialTicks)
    {
        GifTexture.bindTexture(this.texture, ticks, partialTicks);

        float w = this.getWidth();
        float h = this.getHeight();
        float ow = w;
        float oh = h;

        /* x = u1, y = u2, z = v1, w = v2 */
        uv.x = this.image.crop.x / (double) w;
        uv.y = 1.0F - this.image.crop.z / (double) w;
        uv.z = this.image.crop.y / (double) h;
        uv.w = 1.0F - this.image.crop.w / (double) h;

        finalUv.set(uv);

        if (this.resizeCrop)
        {
            finalUv.set(0F, 1F, 0F, 1F);

            w = w - this.image.crop.x - this.image.crop.z;
            h = h - this.image.crop.y - this.image.crop.w;
        }

        double ratioX = w > h ? h / (double) w : 1D;
        double ratioY = h > w ? w / (double) h : 1D;

        pos.set(-(finalUv.x - 0.5) * ratioY, -(finalUv.y - 0.5) * ratioY, (finalUv.z - 0.5) * ratioX, (finalUv.w - 0.5) * ratioX);
        pos.scale(scale);

        boolean isCulling = GL11.glIsEnabled(GL11.GL_CULL_FACE);

        GlStateManager.alphaFunc(GL11.GL_GREATER, 0);
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();

        if (ReflectionUtils.isOptifineShadowPass())
        {
            GlStateManager.disableCull();
        }
        else
        {
            GlStateManager.enableCull();
        }

        if (this.keying)
        {
            GlStateManager.glBlendEquation(GL14.GL_FUNC_REVERSE_SUBTRACT);
            GlStateManager.blendFunc(GL11.GL_ZERO, GL11.GL_ZERO);
        }
        else
        {
            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
        }

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();
        GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);

        boolean textureMatrix = this.image.x != 0 || this.image.y != 0 || this.image.rotation != 0;

        if (textureMatrix)
        {
            GlStateManager.matrixMode(GL11.GL_TEXTURE);
            GlStateManager.loadIdentity();
            GlStateManager.translate(0.5F, 0.5F, 0);
            GlStateManager.translate(this.image.x / ow, this.image.y / oh, 0);
            GlStateManager.rotate(this.image.rotation, 0, 0, 1);
            GlStateManager.translate(-0.5F, -0.5F, 0);
            GlStateManager.matrixMode(GL11.GL_MODELVIEW);
        }

        if (!this.thickness) {
            buffer.begin(GL11.GL_QUADS, VertexBuilder.getFormat(true, true, false, true));

            Color color = this.image.color;

            /* By default the pos is (0.5, -0.5, -0.5, 0.5)  */

            /* Frontface */
            buffer.pos(pos.x, pos.z, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.x, uv.z).normal(0.0F, 0.0F, 1.0F).endVertex();
            buffer.pos(pos.x, pos.w, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.x, uv.w).normal(0.0F, 0.0F, 1.0F).endVertex();
            buffer.pos(pos.y, pos.w, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.y, uv.w).normal(0.0F, 0.0F, 1.0F).endVertex();
            buffer.pos(pos.y, pos.z, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.y, uv.z).normal(0.0F, 0.0F, 1.0F).endVertex();

            /* Backface */
            buffer.pos(pos.x, pos.z, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.x, uv.z).normal(0.0F, 0.0F, -1.0F).endVertex();
            buffer.pos(pos.y, pos.z, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.y, uv.z).normal(0.0F, 0.0F, -1.0F).endVertex();
            buffer.pos(pos.y, pos.w, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.y, uv.w).normal(0.0F, 0.0F, -1.0F).endVertex();
            buffer.pos(pos.x, pos.w, 0.0F).color(color.r, color.g, color.b, color.a).tex(uv.x, uv.w).normal(0.0F, 0.0F, -1.0F).endVertex();

            tessellator.draw();
        }
        else
        {
            CachedExtrusion extrusion = ItemExtruder.extrude(this.texture);

            if (extrusion != null)
            {
                GlStateManager.rotate(180, 0, 0, 1);
                extrusion.render();
            }
        }

        if (textureMatrix)
        {
            GlStateManager.matrixMode(GL11.GL_TEXTURE);
            GlStateManager.loadIdentity();
            GlStateManager.matrixMode(GL11.GL_MODELVIEW);
        }

        if (this.keying)
        {
            GlStateManager.glBlendEquation(GL14.GL_FUNC_ADD);
            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
        }

        if (isCulling)
        {
            GlStateManager.enableCull();
        }
        else
        {
            GlStateManager.disableCull();
        }

        GlStateManager.disableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
    }

    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        this.animation.update();
    }

    public int getWidth()
    {
        return GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
    }

    public int getHeight()
    {
        return GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);
    }

    @Override
    public AbstractMorph create()
    {
        return new ImageMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof ImageMorph)
        {
            ImageMorph morph = (ImageMorph) from;

            this.texture = RLUtils.clone(morph.texture);
            this.shaded = morph.shaded;
            this.lighting = morph.lighting;
            this.billboard = morph.billboard;
            this.removeParentScaleRotation = morph.removeParentScaleRotation;
            this.facing = morph.facing;
            this.crop.set(morph.crop);
            this.resizeCrop = morph.resizeCrop;
            this.color = morph.color;
            this.offsetX = morph.offsetX;
            this.offsetY = morph.offsetY;
            this.rotation = morph.rotation;
            this.pose.copy(morph.pose);
            this.keying = morph.keying;
            this.thickness = morph.thickness;
            this.shadow = morph.shadow;
            this.animation.copy(morph.animation);
            this.animation.reset();
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof ImageMorph)
        {
            ImageMorph image = (ImageMorph) obj;

            result = result && Objects.equals(image.texture, this.texture);
            result = result && image.shaded == this.shaded;
            result = result && image.lighting == this.lighting;
            result = result && image.billboard == this.billboard;
            result = result && image.removeParentScaleRotation == this.removeParentScaleRotation;
            result = result && image.facing == this.facing;
            result = result && image.crop.equals(this.crop);
            result = result && image.resizeCrop == this.resizeCrop;
            result = result && image.color == this.color;
            result = result && image.offsetX == this.offsetX;
            result = result && image.offsetY == this.offsetY;
            result = result && image.rotation == this.rotation;
            result = result && Objects.equals(image.pose, this.pose);
            result = result && image.keying == this.keying;
            result = result && image.thickness == this.thickness;
            result = result && image.shadow == this.shadow;
            result = result && Objects.equals(image.animation, this.animation);
        }

        return result;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof ImageMorph)
        {
            ImageMorph image = (ImageMorph) morph;

            this.mergeBasic(morph);

            if (!image.animation.ignored)
            {
                this.animation.merge(this, image);
                this.copy(image);
                this.animation.progress = 0;
            }

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return 0;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return 0;
    }

    @Override
    public void reset()
    {
        super.reset();

        this.animation.reset();
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.texture != null) tag.setTag("Texture", RLUtils.writeNbt(this.texture));
        if (this.shaded == false) tag.setBoolean("Shaded", this.shaded);
        if (this.lighting == false) tag.setBoolean("Lighting", this.lighting);
        if (this.billboard == true) tag.setBoolean("Billboard", this.billboard);
        if (this.removeParentScaleRotation == true) tag.setBoolean("RemoveParentSpace", this.removeParentScaleRotation);
        if (this.facing != RenderingUtils.Facing.ROTATE_XYZ) tag.setString("FacingMode", this.facing.id);
        if (this.crop.x != 0) tag.setInteger("Left", (int) this.crop.x);
        if (this.crop.z != 0) tag.setInteger("Right", (int) this.crop.z);
        if (this.crop.y != 0) tag.setInteger("Top", (int) this.crop.y);
        if (this.crop.w != 0) tag.setInteger("Bottom", (int) this.crop.w);
        if (this.resizeCrop) tag.setBoolean("ResizeCrop", this.resizeCrop);
        if (this.color != 0xffffffff) tag.setInteger("Color", this.color);
        if (this.offsetX != 0) tag.setFloat("OffsetX", this.offsetX);
        if (this.offsetY != 0) tag.setFloat("OffsetY", this.offsetY);
        if (this.rotation != 0) tag.setFloat("Rotation", this.rotation);
        if (!this.pose.isDefault()) tag.setTag("Pose", this.pose.toNBT());
        if (this.keying) tag.setBoolean("Keying", this.keying);
        if (this.thickness) tag.setBoolean("Thickness", this.thickness);
        if (!this.shadow) tag.setBoolean("Shadow", this.shadow);

        NBTTagCompound animation = this.animation.toNBT();

        if (!animation.hasNoTags())
        {
            tag.setTag("Animation", animation);
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Texture")) this.texture = RLUtils.create(tag.getTag("Texture"));
        if (tag.hasKey("Shaded")) this.shaded = tag.getBoolean("Shaded");
        if (tag.hasKey("Lighting")) this.lighting = tag.getBoolean("Lighting");
        if (tag.hasKey("Billboard")) this.billboard = tag.getBoolean("Billboard");
        if (tag.hasKey("RemoveParentSpace")) this.removeParentScaleRotation = tag.getBoolean("RemoveParentSpace");
        if (tag.hasKey("FacingMode"))
        {
            RenderingUtils.Facing facing = RenderingUtils.Facing.fromString(tag.getString("FacingMode"));
            this.facing = facing != null ? facing : RenderingUtils.Facing.ROTATE_XYZ;
        }
        if (tag.hasKey("Left")) this.crop.x = tag.getInteger("Left");
        if (tag.hasKey("Right")) this.crop.z = tag.getInteger("Right");
        if (tag.hasKey("Top")) this.crop.y = tag.getInteger("Top");
        if (tag.hasKey("Bottom")) this.crop.w = tag.getInteger("Bottom");
        if (tag.hasKey("ResizeCrop")) this.resizeCrop = tag.getBoolean("ResizeCrop");
        if (tag.hasKey("Color")) this.color = tag.getInteger("Color");
        if (tag.hasKey("OffsetX")) this.offsetX = tag.getFloat("OffsetX");
        if (tag.hasKey("OffsetY")) this.offsetY = tag.getFloat("OffsetY");
        if (tag.hasKey("Rotation")) this.rotation = tag.getFloat("Rotation");
        if (tag.hasKey("Animation")) this.animation.fromNBT(tag.getCompoundTag("Animation"));
        if (tag.hasKey("Pose")) this.pose.fromNBT(tag.getCompoundTag("Pose"));
        if (tag.hasKey("Keying")) this.keying = tag.getBoolean("Keying");
        if (tag.hasKey("Thickness")) this.thickness = tag.getBoolean("Thickness");
        if (tag.hasKey("Shadow")) this.shadow = tag.getBoolean("Shadow");

        if (tag.hasKey("Scale"))
        {
            float scale = tag.getFloat("Scale");

            this.pose.scale[0] = scale;
            this.pose.scale[1] = scale;
            this.pose.scale[2] = scale;
        }
    }

    public static class ImageAnimation extends Animation
    {
        public ImageProperties last;

        public void merge(ImageMorph last, ImageMorph next)
        {
            this.merge(next.animation);

            if (this.last == null)
            {
                this.last = new ImageProperties();
            }

            this.last.from(last);
        }

        public void apply(ImageProperties properties, float partialTicks)
        {
            if (this.last == null)
            {
                return;
            }

            float factor = this.getFactor(partialTicks);

            properties.color.r = this.interp.interpolate(this.last.color.r, properties.color.r, factor);
            properties.color.g = this.interp.interpolate(this.last.color.g, properties.color.g, factor);
            properties.color.b = this.interp.interpolate(this.last.color.b, properties.color.b, factor);
            properties.color.a = this.interp.interpolate(this.last.color.a, properties.color.a, factor);
            properties.crop.x = (int) this.interp.interpolate(this.last.crop.x, properties.crop.x, factor);
            properties.crop.y = (int) this.interp.interpolate(this.last.crop.y, properties.crop.y, factor);
            properties.crop.z = (int) this.interp.interpolate(this.last.crop.z, properties.crop.z, factor);
            properties.crop.w = (int) this.interp.interpolate(this.last.crop.w, properties.crop.w, factor);
            properties.pose.interpolate(this.last.pose, properties.pose, factor, this.interp);
            properties.x = this.interp.interpolate(this.last.x, properties.x, factor);
            properties.y = this.interp.interpolate(this.last.y, properties.y, factor);
            properties.rotation = this.interp.interpolate(this.last.rotation, properties.rotation, factor);
        }
    }

    public static class ImageProperties
    {
        public Color color = new Color();
        public Vector4f crop = new Vector4f();
        public ModelTransform pose = new ModelTransform();
        public float x;
        public float y;
        public float rotation;

        public void from(ImageMorph morph)
        {
            this.color.set(morph.color, true);
            this.crop.set(morph.crop);
            this.pose.copy(morph.pose);
            this.x = morph.offsetX;
            this.y = morph.offsetY;
            this.rotation = morph.rotation;
        }
    }
}

==================================================

--- Файл №528 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\LightMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.render.tileentity.TileEntityModelItemStackRenderer;
import mchorse.blockbuster.client.textures.GifTexture;
import mchorse.blockbuster.common.block.BlockModel;
import mchorse.blockbuster.common.entity.ExpirableDummyEntity;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.render.VertexBuilder;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.OptifineHelper;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.RenderingUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.block.model.ItemCameraTransforms;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix4d;
import javax.vecmath.Vector3f;

import java.util.Objects;
import java.util.UUID;

public class LightMorph extends AbstractMorph implements IAnimationProvider, ISyncableMorph, IMorphGenerator
{
    private LightAnimation animation = new LightAnimation();
    private LightProperties lightProperties = new LightProperties(15);
    private int light = 15;
    private ExpirableDummyEntity dummy;
    private Vector3f position = new Vector3f();
    private Vector3f prevPosition = new Vector3f();
    private boolean renderedOnScreen;
    private boolean renderedInEditor;
    /**
     * Inventory and hand instance are the same
     * use this to test out if the morph is only rendering in the inventory
     */
    private State state = State.CANUPDATE;

    /** The age of the dummy entity when this morph last rendered */
    private int lastRenderAge;

    public LightMorph()
    {
        super();

        this.name = "light";
    }

    public void setLightValue(int light)
    {
        this.light = MathUtils.clamp(light, 0, 15);
    }

    public int getLightValue()
    {
        return this.light;
    }

    @Override
    public Animation getAnimation()
    {
        return this.animation;
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
    }

    @Override
    public boolean canGenerate()
    {
        return this.animation.isInProgress();
    }

    @Override
    public void update(EntityLivingBase target)
    {
        if (target.world.isRemote && !this.renderedOnScreen && !this.renderedInEditor)
        {
            if (this.position.equals(new Vector3f(0, 0, 0)))
            {
                this.addDummyEntityToWorld(target);
            }
            else
            {
                this.addDummyEntityToWorld();
            }

            this.state = State.NOUPDATE;
        }

        this.animation.update();

        super.update(target);
    }

    @SideOnly(Side.CLIENT)
    private void updateDummyEntity()
    {
        if (this.dummy == null || this.state != State.CANUPDATE)
        {
            return;
        }

        this.dummy.setLifetime(this.dummy.getAge() + Math.abs(this.dummy.getAge() - this.lastRenderAge) + 2);

        this.updateDummyEntityPosition();

        this.dummy.setItemStackToSlot(EntityEquipmentSlot.MAINHAND, BlockModel.getItemStack(this.lightProperties.lightValue));

        this.prevPosition.set(this.position);
    }

    @SideOnly(Side.CLIENT)
    private void addDummyEntityToWorld()
    {
        this.addDummyEntityToWorld(null);
    }

    @SideOnly(Side.CLIENT)
    private void addDummyEntityToWorld(EntityLivingBase target)
    {
        if ((this.dummy == null || this.dummy.isDead) && this.state == State.CANUPDATE)
        {
            this.dummy = new ExpirableDummyEntity(Minecraft.getMinecraft().world, 1);

            this.updateDummyEntityPosition();

            if (target != null)
            {
                this.dummy.setPosition(target.posX, target.posY, target.posZ);
            }

            if (mchorse.mclib.events.RenderingHandler.isMinecraftRendering())
            {
                RenderingHandler.registerRenderLastEvent(() -> Minecraft.getMinecraft().world.addEntityToWorld(this.dummy.getEntityId(), this.dummy));
            }
            else
            {
                Minecraft.getMinecraft().world.addEntityToWorld(this.dummy.getEntityId(), this.dummy);
            }
        }
    }

    private void updateDummyEntityPosition()
    {
        this.dummy.prevPosX = this.prevPosition.x;
        this.dummy.prevPosY = this.prevPosition.y;
        this.dummy.prevPosZ = this.prevPosition.z;
        this.dummy.lastTickPosX = this.prevPosition.x;
        this.dummy.lastTickPosY = this.prevPosition.y;
        this.dummy.lastTickPosZ = this.prevPosition.z;

        this.dummy.setPosition(this.position.x, this.position.y, this.position.z);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer entityPlayer, int x, int y, float scale, float alpha)
    {
        float partial = Minecraft.getMinecraft().getRenderPartialTicks();

        this.updateAnimation(partial);

        GL11.glPushMatrix();
        GL11.glTranslatef(x, y - scale / 2, 0);
        GL11.glScalef(1.5F, -1.5F, 1.5F);

        this.renderPictureTexture(new ResourceLocation(Blockbuster.MOD_ID, "textures/light_bulb.png"), scale, partial);

        GL11.glPopMatrix();

        this.renderedOnScreen = true;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase target, double x, double y, double z, float entityYaw, float partialTicks)
    {
        if (OptifineHelper.isOptifineShadowPass())
        {
            return;
        }

        EntityLivingBase lastItemHolder = RenderingHandler.getLastItemHolder();
        ItemCameraTransforms.TransformType itemTransformType = RenderingHandler.itemTransformType;

        this.renderedOnScreen = false;
        boolean renderedInHands = lastItemHolder != null && (itemTransformType == ItemCameraTransforms.TransformType.FIRST_PERSON_LEFT_HAND || itemTransformType == ItemCameraTransforms.TransformType.FIRST_PERSON_RIGHT_HAND);
        boolean renderedInThirdPerson = lastItemHolder != null && (itemTransformType == ItemCameraTransforms.TransformType.THIRD_PERSON_LEFT_HAND || itemTransformType == ItemCameraTransforms.TransformType.THIRD_PERSON_RIGHT_HAND);

        if (renderedInHands || renderedInThirdPerson
                || itemTransformType == ItemCameraTransforms.TransformType.GROUND || !TileEntityModelItemStackRenderer.isRendering())
        {
            this.state = State.CANUPDATE;
        }

        GlStateManager.pushMatrix();
        GL11.glTranslated(x, y, z);

        this.updateAnimation(partialTicks);

        if (renderedInThirdPerson || lastItemHolder == null && (!TileEntityModelItemStackRenderer.isRendering() || itemTransformType == ItemCameraTransforms.TransformType.GROUND))
        {
            Matrix4d[] transformation = MatrixUtils.getTransformation();

            Matrix4d translation = transformation[0];

            this.position.x = (float) translation.m03;
            this.position.y = (float) translation.m13;
            this.position.z = (float) translation.m23;
        }
        else if (renderedInHands)
        {
            this.position.x = (float) Interpolations.lerp(lastItemHolder.prevPosX, lastItemHolder.posX, partialTicks);
            this.position.y = (float) Interpolations.lerp(lastItemHolder.prevPosY, lastItemHolder.posY, partialTicks) + lastItemHolder.getEyeHeight() - 0.15F;
            this.position.z = (float) Interpolations.lerp(lastItemHolder.prevPosZ, lastItemHolder.posZ, partialTicks);
        }

        if (Minecraft.getMinecraft().gameSettings.showDebugInfo || GuiModelRenderer.isRendering())
        {
            GlStateManager.pushMatrix();

            RenderingUtils.glRevertRotationScale();

            this.renderPicture(partialTicks);

            GlStateManager.popMatrix();
        }

        if (GuiModelRenderer.isRendering())
        {
            this.addDummyEntityToWorld();

            this.renderedInEditor = true;
        }
        else
        {
            this.renderedInEditor = false;
        }

        if (!CustomMorph.isRenderingOnScreen())
        {
            this.updateDummyEntity();
        }

        this.lastRenderAge = (this.dummy != null) ? this.dummy.getAge() : 0;

        GlStateManager.popMatrix();
    }

    @SideOnly(Side.CLIENT)
    private void renderPicture(float partialTicks)
    {
        float lastBrightnessX = OpenGlHelper.lastBrightnessX;
        float lastBrightnessY = OpenGlHelper.lastBrightnessY;

        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, Interpolation.LINEAR.interpolate(lastBrightnessX, 240, this.lightProperties.lightValue / 15F), lastBrightnessY);

        GlStateManager.enableRescaleNormal();

        GL11.glPushMatrix();

        RenderingUtils.glFacingRotation(RenderingUtils.Facing.ROTATE_XYZ, this.position);

        GlStateManager.scale(0.5F, 0.5F, 0.5F);

        GlStateManager.disableDepth();
        GlStateManager.disableLighting();

        this.renderPictureTexture(new ResourceLocation(Blockbuster.MOD_ID, "textures/light_bulb" + this.lightProperties.lightValue + ".png"), 1, partialTicks);

        GL11.glPopMatrix();

        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastBrightnessX, lastBrightnessY);

        GlStateManager.disableRescaleNormal();
        GlStateManager.enableDepth();
        GlStateManager.enableLighting();
    }

    @SideOnly(Side.CLIENT)
    private void renderPictureTexture(ResourceLocation image, float scale, float partialTicks)
    {
        GifTexture.bindTexture(image, 0, partialTicks);

        boolean isCulling = GL11.glIsEnabled(GL11.GL_CULL_FACE);

        GlStateManager.alphaFunc(GL11.GL_GREATER, 0);
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();

        if (ReflectionUtils.isOptifineShadowPass())
        {
            GlStateManager.disableCull();
        }
        else
        {
            GlStateManager.enableCull();
        }

        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        GlStateManager.color(1, 1, 1, 1);

        buffer.begin(GL11.GL_QUADS, VertexBuilder.getFormat(false, true, false, true));

        int perspective = Minecraft.getMinecraft().gameSettings.thirdPersonView;
        float width = scale * (perspective == 2 ? -1 : 1) * 0.5F;
        float height = scale * 0.5F;

        /* Frontface */
        buffer.pos(-width, height, 0.0F).tex(0, 0).normal(0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(-width, -height, 0.0F).tex(0, 1).normal(0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(width, -height, 0.0F).tex(1, 1).normal(0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(width, height, 0.0F).tex(1, 0).normal(0.0F, 0.0F, 1.0F).endVertex();

        buffer.pos(width,height, 0.0F).tex(1, 0).normal(0.0F, 0.0F, -1.0F).endVertex();
        buffer.pos(width, -height, 0.0F).tex(1, 1).normal(0.0F, 0.0F, -1.0F).endVertex();
        buffer.pos(-width, -height, 0.0F).tex(0, 1).normal(0.0F, 0.0F, -1.0F).endVertex();
        buffer.pos(-width, height, 0.0F).tex(0, 0).normal(0.0F, 0.0F, -1.0F).endVertex();

        tessellator.draw();

        if (isCulling)
        {
            GlStateManager.enableCull();
        }
        else
        {
            GlStateManager.disableCull();
        }

        GlStateManager.disableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        if (previous instanceof LightMorph)
        {
            LightMorph lightMorph = (LightMorph) previous;

            if (lightMorph.animation.isInProgress())
            {
                LightProperties newLast = new LightProperties();

                newLast.from(lightMorph);

                lightMorph.animation.apply(newLast, 1);

                this.animation.last = newLast;
            }
            else
            {
                this.animation.last = new LightProperties();

                this.animation.last.from(lightMorph);
            }
        }
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks)
    {
        LightMorph morph = (LightMorph) this.copy();

        morph.lightProperties.from(this);
        morph.animation.last = new LightProperties(this.animation.last.lightValue);

        morph.animation.apply(morph.lightProperties, partialTicks);

        morph.animation.duration = this.animation.progress;

        return morph;
    }

    @SideOnly(Side.CLIENT)
    private void updateAnimation(float partialTicks)
    {
        if (this.animation.isInProgress())
        {
            this.lightProperties.from(this);
            this.animation.apply(this.lightProperties, partialTicks);
        }
        else
        {
            this.lightProperties.from(this);
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new LightMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof LightMorph)
        {
            LightMorph lightMorph = (LightMorph) from;

            this.light = lightMorph.light;
            this.animation.copy(lightMorph.animation);
            this.animation.reset();
        }
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof LightMorph)
        {
            LightMorph lightMorph = (LightMorph) morph;

            this.mergeBasic(morph);

            /* animating in sequencer made the entity expire - this seems to fix it */
            if (this.dummy != null)
            {
                this.dummy.setLifetime(this.dummy.getAge() + 1);
            }

            /* light morph animation.ignored GUI is disabled because it doesn't make sense now */
            if (!lightMorph.animation.ignored)
            {
                if (this.animation.isInProgress())
                {
                    LightProperties newLast = new LightProperties();

                    newLast.from(this);

                    this.animation.apply(newLast, 0);

                    this.animation.last = newLast;
                }
                else
                {
                    this.animation.last = new LightProperties();

                    this.animation.last.from(this);
                }

                this.animation.merge(this, lightMorph);
                this.light = lightMorph.light;
                this.animation.progress = 0;
            }
            else
            {
                this.animation.ignored = true;
            }

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public boolean equals(Object object)
    {
        boolean result = super.equals(object);

        if (object instanceof LightMorph)
        {
            LightMorph morph = (LightMorph) object;

            result = result && Objects.equals(this.light, morph.light);
            result = result && Objects.equals(morph.animation, this.animation);

            return result;
        }

        return result;
    }

    @Override
    public void reset()
    {
        super.reset();

        this.animation.reset();
    }

    @Override
    public float getWidth(EntityLivingBase entityLivingBase)
    {
        return 0;
    }

    @Override
    public float getHeight(EntityLivingBase entityLivingBase)
    {
        return 0;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("LightValue"))
        {
            this.light = tag.getInteger("LightValue");
        }
        if (tag.hasKey("Animation"))
        {
            this.animation.fromNBT(tag.getCompoundTag("Animation"));
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.light != 15)
        {
            tag.setInteger("LightValue", this.light);
        }

        NBTTagCompound animation = this.animation.toNBT();

        if (!animation.hasNoTags())
        {
            tag.setTag("Animation", animation);
        }

        /*
         * Minecraft has a mechanism that prevents new ItemStack instances when the NBT is equal
         * Adding a random UUID will force a new ItemStack instance.
         */
        tag.setString("UUID", UUID.randomUUID().toString());
    }

    public static class LightAnimation extends Animation
    {
        public LightProperties last;

        public void merge(LightMorph last, LightMorph next)
        {
            this.merge(next.animation);

            if (this.last == null)
            {
                this.last = new LightProperties();

                this.last.from(last);
            }
        }

        public void apply(LightProperties properties, float partialTicks)
        {
            if (this.last == null)
            {
                return;
            }

            float factor = this.getFactor(partialTicks);

            properties.lightValue = MathUtils.clamp(Math.round(this.interp.interpolate(this.last.lightValue, properties.lightValue, factor)), 0, 15);
        }
    }

    public static class LightProperties
    {
        private int lightValue;

        public LightProperties()
        {}

        public LightProperties(int lightValue)
        {
            this.lightValue = lightValue;
        }

        public void from(LightMorph morph)
        {
            this.lightValue = morph.light;
        }
    }

    /**
     * The state used in rendering to identify when to update the entity
     */
    private enum State
    {
        CANUPDATE,
        NOUPDATE
    }
}


==================================================

--- Файл №529 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\ParticleMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.EnumParticleTypes;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix3f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Random;

public class ParticleMorph extends AbstractMorph
{
    private static final ResourceLocation PARTICLE_TEXTURES = new ResourceLocation("textures/particle/particles.png");
    private static final int[] EMPTY_ARGS = {};

    /* Common arguments */
    public ParticleMode mode = ParticleMode.VANILLA;
    public int frequency = 2;
    public int duration = -1;
    public int delay = 0;
    public int cap = 2500;

    /* Vanilla parameters */
    public EnumParticleTypes vanillaType = EnumParticleTypes.EXPLOSION_NORMAL;
    public double vanillaX;
    public double vanillaY;
    public double vanillaZ;
    public double vanillaDX = 0.1;
    public double vanillaDY = 0.1;
    public double vanillaDZ = 0.1;
    public double speed = 0.1;
    public int count = 10;
    public boolean localRotation = true;
    public int[] arguments = EMPTY_ARGS;

    /* Morph parameters */
    public AbstractMorph morph;
    public MorphParticle.MovementType movementType = MorphParticle.MovementType.OUT;
    public boolean yaw = true;
    public boolean pitch = true;
    public boolean sequencer;
    public boolean random;
    public int fade = 10;
    public int lifeSpan = 50;
    public int maximum = 25;

    /* Runtime fields */
    private Vector3d lastGlobal = new Vector3d();
    private Matrix3f lastRotation = new Matrix3f();
    private int tick;
    private List<MorphParticle> morphParticles = new ArrayList<>();
    private int morphIndex;
    public Random rand = new Random();

    public ParticleMorph()
    {
        super();

        this.name = "particle";
    }

    public AbstractMorph getMorph()
    {
        AbstractMorph morph = this.morph;

        if (this.sequencer && morph instanceof SequencerMorph)
        {
            SequencerMorph seq = ((SequencerMorph) morph);

            morph = this.random ? seq.getRandom() : seq.get(this.morphIndex ++ % seq.morphs.size());
        }

        return MorphUtils.copy(morph.copy());
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return I18n.format("blockbuster.morph.particle");
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        Minecraft.getMinecraft().getTextureManager().bindTexture(PARTICLE_TEXTURES);

        double factor = System.currentTimeMillis() % 1000 / 500.0 - 1;
        int size = (int) (scale * 1.5F);
        int offset = (int) (Math.floor(Math.abs(factor * factor) * 8) * 8);

        GlStateManager.color(1, 1, 1);
        GlStateManager.enableTexture2D();
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();
        Gui.drawScaledCustomSizeModalRect(x - size / 2, y - size + size / 8, offset, 0, 8, 8, size, size, 128, 128);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entityLivingBase, double x, double y, double z, float yaw, float partialTicks)
    {
        if (GuiModelRenderer.isRendering() || MorphUtils.isRenderingOnScreen)
        {
            return;
        }

        if (MatrixUtils.matrix != null)
        {
            Matrix4f parent = new Matrix4f(MatrixUtils.matrix);
            Matrix4f matrix4f = MatrixUtils.readModelView(SnowstormMorph.getMatrix());

            parent.invert();
            parent.mul(matrix4f);

            Vector4f zero = SnowstormMorph.calculateGlobal(parent, entityLivingBase, 0, 0, 0, partialTicks);

            Vector3f ax = new Vector3f(parent.m00, parent.m01, parent.m02);
            Vector3f ay = new Vector3f(parent.m10, parent.m11, parent.m12);
            Vector3f az = new Vector3f(parent.m20, parent.m21, parent.m22);

            ax.normalize();
            ay.normalize();
            az.normalize();

            this.lastRotation.setRow(0, ax);
            this.lastRotation.setRow(1, ay);
            this.lastRotation.setRow(2, az);

            this.lastGlobal.x = zero.x;
            this.lastGlobal.y = zero.y;
            this.lastGlobal.z = zero.z;
        }
        else
        {
            this.lastRotation.setIdentity();

            this.lastGlobal.x = Interpolations.lerp(entityLivingBase.prevPosX, entityLivingBase.posX, partialTicks);
            this.lastGlobal.y = Interpolations.lerp(entityLivingBase.prevPosY, entityLivingBase.posY, partialTicks);
            this.lastGlobal.z = Interpolations.lerp(entityLivingBase.prevPosZ, entityLivingBase.posZ, partialTicks);
        }

        if (!this.morphParticles.isEmpty())
        {
            GL11.glPushMatrix();
            GL11.glTranslated(x, y, z);

            for (MorphParticle particle : this.morphParticles)
            {
                particle.render(entityLivingBase, partialTicks);
            }

            GL11.glPopMatrix();
        }
    }

    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        boolean alive = this.duration < 0 || this.tick < this.duration;

        if (this.frequency != 0 && this.tick >= this.delay && this.tick % this.frequency == 0 && alive)
        {
            final int max = this.cap;
            int particlesPerSecond = (int) (20 / (float) this.frequency * this.count);

            boolean vanillaCap = this.mode == ParticleMode.VANILLA && particlesPerSecond <= max;
            boolean morphCap = this.mode == ParticleMode.MORPH && this.maximum <= max;

            if ((vanillaCap || morphCap) && target.world.isRemote)
            {
                if (this.mode == ParticleMode.VANILLA && this.vanillaType != null)
                {
                    double x = this.lastGlobal.x + this.vanillaX;
                    double y = this.lastGlobal.y + this.vanillaY;
                    double z = this.lastGlobal.z + this.vanillaZ;

                    Vector3f vector = new Vector3f(0, 0, 0);

                    for (int i = 0; i < this.count; i ++)
                    {
                        double dx = this.rand.nextGaussian() * this.vanillaDX;
                        double dy = this.rand.nextGaussian() * this.vanillaDY;
                        double dz = this.rand.nextGaussian() * this.vanillaDZ;
                        double sx = this.rand.nextGaussian() * this.speed;
                        double sy = this.rand.nextGaussian() * this.speed;
                        double sz = this.rand.nextGaussian() * this.speed;

                        if (this.localRotation)
                        {
                            vector.set((float) dx, (float) dy, (float) dz);
                            this.lastRotation.transform(vector);

                            dx = vector.x;
                            dy = vector.y;
                            dz = vector.z;
                        }

                        try
                        {
                            target.world.spawnParticle(this.vanillaType, true, x + dx, y + dy, z + dz, sx, sy, sz, this.arguments);
                        }
                        catch (Throwable e)
                        {}
                    }
                }
                else if (this.mode == ParticleMode.MORPH && this.morph != null && this.morphParticles.size() < this.maximum)
                {
                    for (int i = 0; i < this.count && this.morphParticles.size() < this.maximum; i ++)
                    {
                        this.morphParticles.add(new MorphParticle(this));
                    }
                }
            }
        }

        /* Update morph based particles */
        if (target.world.isRemote)
        {
            Iterator<MorphParticle> it = this.morphParticles.iterator();

            while (it.hasNext())
            {
                MorphParticle particle = it.next();

                particle.update(target);

                if (particle.isDead())
                {
                    it.remove();
                }
            }
        }

        this.tick ++;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof ParticleMorph)
        {
            ParticleMorph particle = (ParticleMorph) obj;

            /* Common properties */
            result = result && this.mode == particle.mode;
            result = result && this.frequency == particle.frequency;
            result = result && this.duration == particle.duration;
            result = result && this.delay == particle.delay;
            result = result && this.cap == particle.cap;

            /* Vanilla properties */
            result = result && this.vanillaType == particle.vanillaType;
            result = result && this.vanillaX == particle.vanillaX;
            result = result && this.vanillaY == particle.vanillaY;
            result = result && this.vanillaZ == particle.vanillaZ;
            result = result && this.vanillaDX == particle.vanillaDX;
            result = result && this.vanillaDY == particle.vanillaDY;
            result = result && this.vanillaDZ == particle.vanillaDZ;
            result = result && this.speed == particle.speed;
            result = result && this.count == particle.count;
            result = result && this.localRotation == particle.localRotation;

            boolean sameArgs = false;

            if (this.arguments.length == particle.arguments.length)
            {
                int same = 0;

                for (int i = 0; i < this.arguments.length; i++)
                {
                    if (this.arguments[i] == particle.arguments[i])
                    {
                        same ++;
                    }
                }

                sameArgs = same == this.arguments.length;
            }

            result = result && sameArgs;

            result = result && Objects.equals(this.morph, particle.morph);
            result = result && this.movementType == particle.movementType;
            result = result && this.yaw == particle.yaw;
            result = result && this.pitch == particle.pitch;
            result = result && this.sequencer == particle.sequencer;
            result = result && this.random == particle.random;
            result = result && this.fade == particle.fade;
            result = result && this.lifeSpan == particle.lifeSpan;
            result = result && this.maximum == particle.maximum;
        }

        return result;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof ParticleMorph)
        {
            this.copy(morph);
            this.tick = this.morphIndex = 0;

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public boolean useTargetDefault()
    {
        return true;
    }

    @Override
    public AbstractMorph create()
    {
        return new ParticleMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof ParticleMorph)
        {
            ParticleMorph morph = (ParticleMorph) from;

            this.mode = morph.mode;
            this.frequency = morph.frequency;
            this.duration = morph.duration;
            this.delay = morph.delay;
            this.cap = morph.cap;

            this.vanillaType = morph.vanillaType;
            this.vanillaX = morph.vanillaX;
            this.vanillaY = morph.vanillaY;
            this.vanillaZ = morph.vanillaZ;
            this.vanillaDX = morph.vanillaDX;
            this.vanillaDY = morph.vanillaDY;
            this.vanillaDZ = morph.vanillaDZ;
            this.speed = morph.speed;
            this.count = morph.count;
            this.localRotation = morph.localRotation;
            this.arguments = morph.arguments;

            this.morph = MorphUtils.copy(morph.morph);
            this.movementType = morph.movementType;
            this.yaw = morph.yaw;
            this.pitch = morph.pitch;
            this.sequencer = morph.sequencer;
            this.random = morph.random;
            this.fade = morph.fade;
            this.lifeSpan = morph.lifeSpan;
            this.maximum = morph.maximum;
        }
    }

    @Override
    public float getWidth(EntityLivingBase entityLivingBase)
    {
        return 0.6F;
    }

    @Override
    public float getHeight(EntityLivingBase entityLivingBase)
    {
        return 1.8F;
    }

    @Override
    public void reset()
    {
        super.reset();
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Mode")) this.mode = tag.getString("Mode").equals(ParticleMode.MORPH.type) ? ParticleMode.MORPH : ParticleMode.VANILLA;
        if (tag.hasKey("Frequency")) this.frequency = tag.getInteger("Frequency");
        if (tag.hasKey("Duration")) this.duration = tag.getInteger("Duration");
        if (tag.hasKey("Delay")) this.delay = tag.getInteger("Delay");
        if (tag.hasKey("Cap")) this.cap = tag.getInteger("Cap");

        if (tag.hasKey("Type")) this.vanillaType = EnumParticleTypes.getByName(tag.getString("Type"));
        if (tag.hasKey("X")) this.vanillaX = tag.getDouble("X");
        if (tag.hasKey("Y")) this.vanillaY = tag.getDouble("Y");
        if (tag.hasKey("Z")) this.vanillaZ = tag.getDouble("Z");
        if (tag.hasKey("DX")) this.vanillaDX = tag.getDouble("DX");
        if (tag.hasKey("DY")) this.vanillaDY = tag.getDouble("DY");
        if (tag.hasKey("DZ")) this.vanillaDZ = tag.getDouble("DZ");
        if (tag.hasKey("Speed")) this.speed = tag.getDouble("Speed");
        if (tag.hasKey("Count")) this.count = tag.getInteger("Count");
        if (tag.hasKey("LocalRotation")) this.localRotation = tag.getBoolean("LocalRotation");
        if (tag.hasKey("Args")) this.arguments = tag.getIntArray("Args");

        if (tag.hasKey("Morph")) this.morph = MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag("Morph"));
        if (tag.hasKey("Movement")) this.movementType = MorphParticle.MovementType.getType(tag.getString("Movement"));
        if (tag.hasKey("Yaw")) this.yaw = tag.getBoolean("Yaw");
        if (tag.hasKey("Pitch")) this.pitch = tag.getBoolean("Pitch");
        if (tag.hasKey("Sequencer")) this.sequencer = tag.getBoolean("Sequencer");
        if (tag.hasKey("Random")) this.random = tag.getBoolean("Random");
        if (tag.hasKey("Fade")) this.fade = tag.getInteger("Fade");
        if (tag.hasKey("Life")) this.lifeSpan = tag.getInteger("Life");
        if (tag.hasKey("Max")) this.maximum = tag.getInteger("Max");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.mode != ParticleMode.VANILLA) tag.setString("Mode", this.mode.type);
        if (this.frequency != 2) tag.setInteger("Frequency", this.frequency);
        if (this.duration != -1) tag.setInteger("Duration", this.duration);
        if (this.delay != 0) tag.setInteger("Delay", this.delay);
        if (this.cap != 2500) tag.setInteger("Cap", this.cap);

        if (this.vanillaType != EnumParticleTypes.EXPLOSION_NORMAL) tag.setString("Type", this.vanillaType.getParticleName());
        if (this.vanillaX != 0) tag.setDouble("X", this.vanillaX);
        if (this.vanillaY != 0) tag.setDouble("Y", this.vanillaY);
        if (this.vanillaZ != 0) tag.setDouble("Z", this.vanillaZ);
        if (this.vanillaDX != 0.1) tag.setDouble("DX", this.vanillaDX);
        if (this.vanillaDY != 0.1) tag.setDouble("DY", this.vanillaDY);
        if (this.vanillaDZ != 0.1) tag.setDouble("DZ", this.vanillaDZ);
        if (this.speed != 0.1) tag.setDouble("Speed", this.speed);
        if (this.count != 10) tag.setInteger("Count", this.count);
        if (!this.localRotation) tag.setBoolean("LocalRotation", this.localRotation);
        if (this.arguments.length != 0) tag.setIntArray("Args", this.arguments);

        if (this.morph != null)
        {
            NBTTagCompound morph = new NBTTagCompound();

            this.morph.toNBT(morph);
            tag.setTag("Morph", morph);
        }

        if (this.movementType != MorphParticle.MovementType.OUT) tag.setString("Movement", this.movementType.id);
        if (!this.yaw) tag.setBoolean("Yaw", this.yaw);
        if (!this.pitch) tag.setBoolean("Pitch", this.pitch);
        if (this.sequencer) tag.setBoolean("Sequencer", this.sequencer);
        if (this.random) tag.setBoolean("Random", this.random);
        if (this.fade != 10) tag.setInteger("Fade", this.fade);
        if (this.lifeSpan != 50) tag.setInteger("Life", this.lifeSpan);
        if (this.maximum != 25) tag.setInteger("Max", this.maximum);
    }

    public static class MorphParticle
    {
        public ParticleMorph parent;
        public AbstractMorph morph;
        public MovementType movementType;

        public float targetX;
        public float targetY;
        public float targetZ;

        public float x;
        public float y;
        public float z;
        public float prevX;
        public float prevY;
        public float prevZ;

        public float yaw;
        public float pitch;
        public float prevYaw;
        public float prevPitch;

        public int timer;

        public MorphParticle(ParticleMorph morph)
        {
            this.parent = morph;
            this.morph = morph.getMorph();
            this.movementType = morph.movementType;
            this.movementType.calculateInitial(this);

            /* Stupid workaround to fix initial rotation */
            this.timer = 1;
            this.movementType.calculate(this);
            this.calculateRotation();
            this.movementType.calculateInitial(this);

            this.prevYaw = this.yaw;
            this.prevPitch = this.pitch;
        }

        public void update(EntityLivingBase entity)
        {
            this.timer ++;
            this.prevX = this.x;
            this.prevY = this.y;
            this.prevZ = this.z;
            this.prevYaw = this.yaw;
            this.prevPitch = this.pitch;

            this.movementType.calculate(this);
            this.calculateRotation();

            this.morph.update(entity);
        }

        private void calculateRotation()
        {
            double dX = this.x - this.prevX;
            double dY = this.y - this.prevY;
            double dZ = this.z - this.prevZ;

            double horizontalDistance = (double) MathHelper.sqrt(dX * dX + dZ * dZ);
            this.yaw = (float) (180 - MathHelper.atan2(dZ, dX) * 180 / Math.PI) + 90;
            this.pitch = (float) ((MathHelper.atan2(dY, horizontalDistance) * 180 / Math.PI));
        }

        public void render(EntityLivingBase entity, float partialTicks)
        {
            GL11.glPushMatrix();

            double x = Interpolations.lerp(this.prevX, this.x, partialTicks) + this.parent.vanillaX;
            double y = Interpolations.lerp(this.prevY, this.y, partialTicks) + this.parent.vanillaY;
            double z = Interpolations.lerp(this.prevZ, this.z, partialTicks) + this.parent.vanillaZ;
            double scale = Interpolations.envelope(this.timer + partialTicks, this.parent.lifeSpan, this.parent.fade);

            GL11.glTranslated(x, y, z);
            GL11.glScaled(scale, scale, scale);

            if (this.parent.yaw) GlStateManager.rotate(Interpolations.lerp(this.prevYaw, this.yaw, partialTicks), 0.0F, 1.0F, 0.0F);
            if (this.parent.pitch) GlStateManager.rotate(Interpolations.lerp(this.prevPitch, this.pitch, partialTicks), 1.0F, 0.0F, 0.0F);

            if (this.parent.yaw || this.parent.pitch)
            {
                float yaw = entity.rotationYaw;
                float pitch = entity.rotationPitch;
                float yawHead = entity.rotationYawHead;
                float yawBody = entity.renderYawOffset;
                float prevYaw = entity.prevRotationYaw;
                float prevPitch = entity.prevRotationPitch;
                float prevYawHead = entity.prevRotationYawHead;
                float prevYawBody = entity.prevRenderYawOffset;

                entity.rotationYaw = entity.prevRotationYaw = 0;
                entity.rotationYawHead = entity.prevRotationYawHead = 0;
                entity.rotationPitch = entity.prevRotationPitch = 0;
                entity.renderYawOffset = entity.prevRenderYawOffset = 0;

                this.morph.render(entity, 0, 0, 0, 0, partialTicks);

                entity.rotationYaw = yaw;
                entity.rotationPitch = pitch;
                entity.rotationYawHead = yawHead;
                entity.renderYawOffset = yawBody;
                entity.prevRotationYaw = prevYaw;
                entity.prevRotationPitch = prevPitch;
                entity.prevRotationYawHead = prevYawHead;
                entity.prevRenderYawOffset = prevYawBody;
            }
            else
            {
                this.morph.render(entity, 0, 0, 0, 0, partialTicks);
            }

            GL11.glPopMatrix();
        }

        public boolean isDead()
        {
            return this.timer >= this.parent.lifeSpan;
        }

        public float getFactor()
        {
            return this.parent.lifeSpan == 0 ? 1 : this.timer / (float) this.parent.lifeSpan;
        }

        public static enum MovementType
        {
            OUT("out")
            {
                @Override
                public void calculateInitial(MorphParticle particle)
                {
                    particle.targetX = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDX;
                    particle.targetY = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDY;
                    particle.targetZ = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDZ;

                    particle.x = particle.prevX = 0;
                    particle.y = particle.prevY = 0;
                    particle.z = particle.prevZ = 0;
                }

                @Override
                public void calculate(MorphParticle particle)
                {
                    float factor = particle.getFactor();

                    particle.x = Interpolations.lerp(0, particle.targetX, factor);
                    particle.y = Interpolations.lerp(0, particle.targetY, factor);
                    particle.z = Interpolations.lerp(0, particle.targetZ, factor);
                }
            },
            IN("in")
            {
                @Override
                public void calculateInitial(MorphParticle particle)
                {
                    particle.targetX = particle.x = particle.prevX = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDX;
                    particle.targetY = particle.y = particle.prevY = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDY;
                    particle.targetZ = particle.z = particle.prevZ = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDZ;
                }

                @Override
                public void calculate(MorphParticle particle)
                {
                    float factor = particle.getFactor();

                    particle.x = Interpolations.lerp(particle.targetX, 0, factor);
                    particle.y = Interpolations.lerp(particle.targetY, 0, factor);
                    particle.z = Interpolations.lerp(particle.targetZ, 0, factor);
                }
            },
            DROP("drop")
            {
                @Override
                public void calculateInitial(MorphParticle particle)
                {
                    particle.x = particle.prevX = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDX;
                    particle.y = particle.prevY = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDY;
                    particle.z = particle.prevZ = (particle.parent.rand.nextFloat() * 2 - 1) * (float) particle.parent.vanillaDZ;
                }

                @Override
                public void calculate(MorphParticle particle)
                {
                    if (particle.targetY < 5)
                    {
                        particle.targetY += 0.02F;
                    }

                    particle.y -= particle.targetY;
                }
            };

            public final String id;

            public static MovementType getType(String id)
            {
                for (MovementType type : values())
                {
                    if (type.id.equals(id)) return type;
                }

                return OUT;
            }

            private MovementType(String type)
            {
                this.id = type;
            }

            public abstract void calculateInitial(MorphParticle particle);

            public abstract void calculate(MorphParticle particle);
        }
    }

    public static enum ParticleMode
    {
        VANILLA("vanilla"), MORPH("morph");

        public final String type;

        private ParticleMode(String type)
        {
            this.type = type;
        }
    }
}

==================================================

--- Файл №530 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\RecordMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.blockbuster.ClientProxy;
import mchorse.blockbuster.common.entity.EntityActor;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.recording.actions.PacketRequestAction;
import mchorse.blockbuster.network.server.recording.ServerHandlerRequestRecording;
import mchorse.blockbuster.recording.RecordPlayer;
import mchorse.blockbuster.recording.actions.Action;
import mchorse.blockbuster.recording.data.Frame;
import mchorse.blockbuster.recording.data.Mode;
import mchorse.blockbuster.recording.data.Record;
import mchorse.blockbuster.recording.scene.Replay;
import mchorse.mclib.client.gui.framework.elements.utils.GuiInventoryElement;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.world.World;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.Objects;

public class RecordMorph extends AbstractMorph implements ISyncableMorph
{
    /**
     * Record morph's icon in GUI 
     */
    public static final ItemStack ICON = new ItemStack(Items.RECORD_13);

    @SideOnly(Side.CLIENT)
    public EntityActor actor;

    public boolean reload;

    /**
     * Initial morph
     */
    public AbstractMorph initial;

    /**
     * Record which should be played on this morph
     */
    public String record = "";

    /**
     * Loop the actor 
     */
    public boolean loop = true;

    /**
     * Random skip factor
     */
    public int randomSkip;

    private boolean initiate;
    private Animation animation = new Animation();
    private Replay replay = new Replay();

    public RecordMorph()
    {
        super();

        this.name = "blockbuster.record";
    }

    public void setRecord(String record)
    {
        this.record = record;
        this.reload = true;
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
}

    @Override
    public void resume()
    {
        this.animation.paused = false;
    }

    @SideOnly(Side.CLIENT)
    private void previewActor(Record record)
    {
        int tick = this.animation.progress % record.getLength();

        Frame frame = record.getFrame(Math.max(tick - 1, 0));

        if (frame == null)
        {
            return;
        }

        frame.apply(this.actor, true);

        if (frame.hasBodyYaw)
        {
            this.actor.prevRenderYawOffset = this.actor.renderYawOffset = frame.bodyYaw;
        }

        this.actor.prevPosX = this.actor.posX;
        this.actor.prevPosY = this.actor.posY;
        this.actor.prevPosZ = this.actor.posZ;

        this.actor.prevRotationYaw = this.actor.rotationYaw;
        this.actor.prevRotationPitch = this.actor.rotationPitch;
        this.actor.prevRotationYawHead = this.actor.rotationYawHead;
        this.actor.prevRenderYawOffset = this.actor.renderYawOffset;
        this.actor.playback.tick = tick;
        this.actor.playback.playing = false;

        if (!this.isPaused())
        {
            frame = record.getFrame(tick);

            if (frame == null)
            {
                return;
            }

            frame.apply(this.actor, true);

            if (frame.hasBodyYaw)
            {
                this.actor.renderYawOffset = frame.bodyYaw;
            }
        }

        this.initiate = true;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return I18n.format("blockbuster.morph.record");
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        this.initiateActor(player.world);

        /* Render icon when initial morph isn't available */
        float record = (float) Math.ceil(scale / 16);

        GlStateManager.disableDepth();
        GlStateManager.pushMatrix();
        GlStateManager.translate(x + 1, y - 9, 0);
        GlStateManager.scale(record, record, 1);
        GuiInventoryElement.drawItemStack(ICON, -8, -8, 0, null);
        GlStateManager.popMatrix();
        GlStateManager.enableDepth();

        if (this.initial != null)
        {
            this.initial.renderOnScreen(player, x, y, scale, alpha);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        this.initiateActor(entity.world);

        AbstractMorph morph = this.actor.getMorph();

        if (morph != null)
        {
            if (this.actor.playback.record != null)
            {
                Frame first = this.actor.playback.record.getFrame(0);

                if (first != null)
                {
                    if (!this.initiate)
                    {
                        this.actor.prevPosX = this.actor.posX = first.x;
                        this.actor.prevPosY = this.actor.posY = first.y;
                        this.actor.prevPosZ = this.actor.posZ = first.z;
                        this.initiate = true;
                    }

                    x += (this.actor.prevPosX + (this.actor.posX - this.actor.prevPosX) * partialTicks) - first.x;
                    y += (this.actor.prevPosY + (this.actor.posY - this.actor.prevPosY) * partialTicks) - first.y;
                    z += (this.actor.prevPosZ + (this.actor.posZ - this.actor.prevPosZ) * partialTicks) - first.z;
                }
            }

            morph.render(this.actor, x, y, z, entityYaw, partialTicks);
        }
    }

    @SideOnly(Side.CLIENT)
    private void initiateActor(World world)
    {
        if (this.reload)
        {
            this.actor = null;
            this.initiate = false;
            this.reload = false;
        }

        if (this.actor == null)
        {
            this.actor = new EntityActor(world);
            this.actor.morph.setDirect(MorphUtils.copy(this.initial));
            this.actor.playback = new RecordPlayer(null, Mode.FRAMES, this.actor);
            this.actor.playback.tick = (int) (this.randomSkip * Math.random());
            this.actor.manual = true;

            Record record = ClientProxy.manager.getClient(this.record);

            if (record == null && !this.record.isEmpty())
            {
                ServerHandlerRequestRecording.requestRecording(this.record);
            }
            else if (this.animation.progress != 0 && record != null)
            {
                if (record.actions.isEmpty())
                {
                    /* Just to prevent it from spamming messages */
                    record.actions.add(new ArrayList<Action>());
                    Dispatcher.sendToServer(new PacketRequestAction(this.record, false));
                }

                this.actor.playback.record = record;

                this.replay.morph = this.initial;
                this.previewActor(record);

                record.applyPreviousMorph(this.actor, this.replay, this.animation.progress, this.isPaused() ? Record.MorphType.PAUSE : Record.MorphType.FORCE);
            }
        }
    }

    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        if (target.world.isRemote)
        {
            this.updateActor();
        }
    }

    @SideOnly(Side.CLIENT)
    private void updateActor()
    {
        if (this.actor != null)
        {
            RecordPlayer player = this.actor.playback;

            if (player.record == null)
            {
                player.record = ClientProxy.manager.getClient(this.record);

                if (player.record != null)
                {
                    this.previewActor(player.record);
                }

                if (player.record != null && player.record.actions.isEmpty())
                {
                    /* Just to prevent it from spamming messages */
                    player.record.actions.add(new ArrayList<Action>());
                    Dispatcher.sendToServer(new PacketRequestAction(this.record, false));
                }
            }
            else
            {
                if (this.isPaused() && this.actor.playback.record != null)
                {
                    this.previewActor(this.actor.playback.record);
                    this.actor.playback.record.applyPreviousMorph(this.actor, this.replay, this.animation.progress, Record.MorphType.PAUSE);
                }
                else
                {
                    if (this.animation.progress != 0)
                    {
                        this.actor.playback.playing = true;
                        this.actor.playback.tick = this.animation.progress + 1;

                        this.animation.progress = 0;
                    }

                    this.actor.onUpdate();
                }

                if (!this.isPaused() && this.actor.playback.isFinished() && this.loop)
                {
                    this.actor.playback.record.reset(this.actor);
                    this.actor.playback.tick = (int) (this.randomSkip * Math.random());
                    this.actor.playback.record.applyAction(0, this.actor, true);
                    this.actor.morph.setDirect(MorphUtils.copy(this.initial));
                }
            }
        } else {
            this.animation.progress++;
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new RecordMorph();
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof RecordMorph)
        {
            RecordMorph recmorph = (RecordMorph) morph;

            this.mergeBasic(morph);

            if (!recmorph.animation.ignored)
            {
                this.animation.merge(recmorph.animation);
            }

            if (!recmorph.record.equals(this.record))
            {
                this.copy(recmorph);
            }

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof RecordMorph)
        {
            RecordMorph morph = (RecordMorph) from;

            this.record = morph.record;
            this.loop = morph.loop;
            this.randomSkip = morph.randomSkip;
            this.initial = MorphUtils.copy(morph.initial);
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return 0.6F;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return 1.8F;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof RecordMorph)
        {
            RecordMorph record = (RecordMorph) obj;

            result = result && Objects.equals(record.record, this.record);
            result = result && Objects.equals(record.initial, this.initial);
            result = result && record.loop == this.loop;
            result = result && record.randomSkip == this.randomSkip;
        }

        return result;
    }

    @Override
    public void reset()
    {
        super.reset();

        this.initial = null;
        this.record = "";
        this.reload = true;
        this.loop = true;
        this.randomSkip = 0;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Initial", NBT.TAG_COMPOUND))
        {
            this.initial = MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag("Initial"));
        }

        if (tag.hasKey("Record", NBT.TAG_STRING))
        {
            this.record = tag.getString("Record");
        }

        if (tag.hasKey("Loop", NBT.TAG_ANY_NUMERIC))
        {
            this.loop = tag.getBoolean("Loop");
        }

        if (tag.hasKey("RandomDelay", NBT.TAG_ANY_NUMERIC))
        {
            this.randomSkip = tag.getInteger("RandomDelay");
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.initial != null)
        {
            NBTTagCompound morph = new NBTTagCompound();

            this.initial.toNBT(morph);
            tag.setTag("Initial", morph);
        }

        if (!this.record.isEmpty())
        {
            tag.setString("Record", this.record);
        }

        if (!this.loop)
        {
            tag.setBoolean("Loop", this.loop);
        }

        if (this.randomSkip != 0)
        {
            tag.setInteger("RandomDelay", this.randomSkip);
        }
    }
}

==================================================

--- Файл №531 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\SequencerMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.blockbuster.utils.mclib.BBIcons;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.NBTUtils;
import mchorse.metamorph.api.Morph;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Random;

/**
 * Sequencer morph
 * 
 * Next big thing since S&B, allows creating animated morphs with 
 * variable delays between changes
 */
public class SequencerMorph extends AbstractMorph implements IMorphProvider, ISyncableMorph, IMorphGenerator
{
    /**
     * List of sequence entries (morph and their delay) 
     */
    public List<SequenceEntry> morphs = new ArrayList<SequenceEntry>();

    /**
     * Current morph 
     */
    public Morph currentMorph = new Morph();

    /**
     * Index of current cell 
     */
    public int current;

    /**
     * Timer on which depends the cycling
     */
    public int timer;

    /**
     * Timer for renderOnScreen
     */
    @SideOnly(Side.CLIENT)
    public int screenTimer;

    /**
     * Duration of the current  
     */
    public float duration;
    
    /**
     * Duration of the last
     */
    public float lastDuration;

    /**
     * Is current morph enabled set duration
     */
    public boolean morphSetDuration;

    /**
     * Record loop count
     */
    public int loopCount;

    /**
     * Is current morph the first morph of a loop
     */
    public boolean isFirstMorph = false;

    /**
     * Last update tick
     */
    public float lastUpdate;

    /**
     * Reverse playback 
     */
    public boolean reverse;

    /**
     * Random order of sequencer playback
     */
    public boolean isRandom;

    /**
     * Whether it's random, and truly random
     */
    public boolean isTrulyRandom;

    /**
     * Times of loop.
     */
    public int loop;

    /**
     * Move the model after each repetition
     */
    public float[] offset = new float[3];

    /**
     * How many times to repeat the offset.
     */
    public int offsetCount;

    /**
     * Keep the progress after merge.
     */
    public boolean keepProgress;

    private Animation animation = new Animation();
    private Random random = new Random();

    public SequencerMorph()
    {
        super();

        this.name = "sequencer";
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        FoundMorph found = this.getMorphAt(offset);

        if (found == null)
        {
            return;
        }

        AbstractMorph morph = MorphUtils.copy(found.getCurrentMorph());

        if (found.previous != null)
        {
            AbstractMorph prevMorph = MorphUtils.copy(found.getPreviousMorph());

            MorphUtils.pause(prevMorph, previous, (int) found.getPreviousDuration());
            found.applyPrevious(prevMorph);

            previous = prevMorph;
        }

        MorphUtils.pause(morph, previous, (int) (offset - found.lastDuration));
        MorphUtils.resume(morph);

        found.applyCurrent(morph);
        this.currentMorph.setDirect(morph);

        this.timer = offset;
        this.duration = found.totalDuration;
        this.current = found.index;
        this.loopCount = found.loopCount;
        this.isFirstMorph = found.isFirstMorph;
        this.lastDuration = found.lastDuration;
        this.morphSetDuration = found.current.setDuration;
        this.lastUpdate = offset;
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
    }

    @Override
    public void resume()
    {
        this.animation.paused = false;
        MorphUtils.resume(this.currentMorph.get());
    }

    @Override
    public AbstractMorph getMorph()
    {
        AbstractMorph morph = this.currentMorph.get();
        float progress = this.timer;
        float duration = this.duration - this.lastDuration;

        if (this.morphSetDuration)
        {
            if (duration > 0)
            {
                float setDuration = (float) Math.ceil(duration);
                float ticks = (progress - this.lastDuration) * setDuration / duration;
                int tick = (int) ticks * 10000;

                this.updateSetDuration(morph, tick, (int) setDuration * 10000);
            }
            else
            {
                this.updateSetDuration(morph, 1, 1);
            }
        }

        return morph;
    }

    @Override
    public boolean canGenerate()
    {
        AbstractMorph morph = this.currentMorph.get();

        if (morph instanceof IMorphGenerator)
        {
            return ((IMorphGenerator) morph).canGenerate();
        }
        else
        {
            return false;
        }
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks)
    {
        AbstractMorph morph = this.currentMorph.get();

        if (morph instanceof IMorphGenerator)
        {
            float progress = this.timer + partialTicks;
            float duration = this.duration - this.lastDuration;

            if (this.morphSetDuration && duration > 0)
            {
                float setDuration = (float) Math.ceil(duration);
                float ticks = (progress - this.lastDuration) * setDuration / duration;
                int tick = (int) ticks;

                if (this.updateSetDuration(morph, tick, (int) setDuration))
                {
                    partialTicks = ticks - tick;
                }
            }

            return ((IMorphGenerator) morph).genCurrentMorph(partialTicks);
        }
        else
        {
            return null;
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return I18n.format("blockbuster.morph.sequencer");
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        if (this.morphs.isEmpty())
        {
            GlStateManager.color(1, 1, 1);
            BBIcons.CHICKEN.render(x - 8, y - 20);

            return;
        }

        this.screenTimer++;
        this.screenTimer %= 2000;

        FoundMorph found = this.getMorphAt(this.screenTimer);
        AbstractMorph morph = MorphUtils.copy(found.getCurrentMorph());
        AbstractMorph prevMorph = MorphUtils.copy(found.getPreviousMorph());

        MorphUtils.pause(morph, prevMorph, (int) (this.screenTimer - found.lastDuration));

        if (morph != null)
        {
            MorphUtils.renderOnScreen(morph, player, x, y, scale, alpha);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        float progress = this.timer + partialTicks;

        if (!this.isPaused())
        {
            this.updateClient(entity, progress);

            partialTicks = progress - this.lastDuration;
            partialTicks -= (int) partialTicks;
        }
        else
        {
            partialTicks = 0;
            progress = this.timer;
        }

        AbstractMorph morph = this.currentMorph.get();

        if (morph != null)
        {
            if (this.offsetCount > -1)
            {
                int times = this.loopCount % (this.offsetCount + 1);
                double baseMul = 0.0625 * (this.reverse ? -1 : 1);
                double offsetMul = baseMul * times;
                Vec3d offset = new Vec3d(this.offset[0] * offsetMul, this.offset[1] * offsetMul, this.offset[2] * offsetMul);

                if (this.isFirstMorph && !this.currentMorph.isEmpty())
                {
                    if (this.currentMorph.get() instanceof IAnimationProvider)
                    {
                        Animation anim = ((IAnimationProvider) this.currentMorph.get()).getAnimation();

                        if (anim.isInProgress())
                        {
                            double lastMul = baseMul * (times - 1);

                            double lerpX = anim.interp.interpolate(this.offset[0] * lastMul, this.offset[0] * offsetMul, anim.getFactor(partialTicks));
                            double lerpY = anim.interp.interpolate(this.offset[1] * lastMul, this.offset[1] * offsetMul, anim.getFactor(partialTicks));
                            double lerpZ = anim.interp.interpolate(this.offset[2] * lastMul, this.offset[2] * offsetMul, anim.getFactor(partialTicks));
                            
                            offset = new Vec3d(lerpX, lerpY, lerpZ);
                        }
                    }
                }

                float yaw = Interpolations.lerpYaw(entity.prevRenderYawOffset, entity.renderYawOffset, partialTicks);
                offset = offset.rotateYaw((float) Math.toRadians(-yaw));

                x += offset.x;
                y += offset.y;
                z += offset.z;
            }

            float duration = this.duration - this.lastDuration;

            if (this.morphSetDuration)
            {
                if (duration > 0)
                {
                    float setDuration = (float) Math.ceil(duration);
                    float ticks = (progress - this.lastDuration) * setDuration / duration;
                    int tick = (int) ticks;

                    if (this.updateSetDuration(morph, tick, (int) setDuration))
                    {
                        partialTicks = ticks - tick;
                    }
                }
                else
                {
                    this.updateSetDuration(morph, 1, 1);
                }
            }

            MorphUtils.render(morph, entity, x, y, z, entityYaw, partialTicks);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public boolean renderHand(EntityPlayer player, EnumHand hand)
    {
        AbstractMorph morph = this.currentMorph.get();

        if (morph != null)
        {
            return morph.renderHand(player, hand);
        }

        return false;
    }

    /* Random stuff */

    private Random getRandomSeed(float duration)
    {
        if (this.isTrulyRandom)
        {
            this.random.setSeed(System.nanoTime());
        }
        else
        {
            this.random.setSeed((long) (duration * 100000L));
        }

        return this.random;
    }

    public AbstractMorph getRandom()
    {
        if (this.morphs.isEmpty())
        {
            return null;
        }

        double factor = this.isTrulyRandom ? Math.random() : this.random.nextDouble();

        return this.get((int) (factor * this.morphs.size()));
    }

    public int getRandomIndex(float duration)
    {
        return (int) (this.getRandomSeed(duration * 2 + 5).nextFloat() * this.morphs.size());
    }

    public AbstractMorph get(int index)
    {
        if (index >= this.morphs.size() || index < 0)
        {
            return null;
        }

        return this.morphs.get(index).morph;
    }

    /* Search */

    public FoundMorph getMorphAt(int tick)
    {
        /* There is no found morph if there are no sequences or tick is negative */
        if (this.morphs.isEmpty() || tick < 0)
        {
            return null;
        }

        float duration = this.getMaxDuration();
        int size = this.morphs.size();

        /* A shortcut in case the durations of every sequence is zero */
        if (duration <= 0)
        {
            return new FoundMorph(size - 1, this.morphs.get(size - 1), size == 1 ? null : this.morphs.get(size - 2), 0, 0, 0, 0, false);
        }

        /* Now the main fun part */
        SequenceEntry entry = null;
        SequenceEntry lastEntry = null;
        int i = this.reverse ? size - 1 : 0;
        int lastIndex = i;

        duration = 0;

        if (this.isRandom)
        {
            i = this.getRandomIndex(duration);
        }

        float lastDuration = 0;
        float prevLastDuration = 0;

        int loopCount = 0;
        int lastLoopCount = 0;
        boolean isFirstMorph = false;
        boolean lastIsFirstMorph = false;

        do
        {
            prevLastDuration = lastDuration;
            lastDuration = duration;
            lastEntry = entry;
            lastLoopCount = loopCount;
            lastIsFirstMorph = isFirstMorph;

            entry = this.morphs.get(i);
            lastIndex = i;

            if (entry != null && entry.endPoint && this.loop > 0 && loopCount >= this.loop - 1)
            {
                break;
            }

            isFirstMorph = false;

            if (this.isRandom)
            {
                if (entry != null && entry.endPoint)
                {
                    loopCount++;
                    isFirstMorph = true;
                }
                
                i = this.getRandomIndex(duration);
            }
            else
            {
                int next = i + (this.reverse ? -1 : 1);
                int current = MathUtils.cycler(next, 0, size - 1);

                if (current != next)
                {
                    if (this.loop > 0 && loopCount >= this.loop - 1)
                    {
                        break;
                    }
                    else
                    {
                        loopCount++;
                        isFirstMorph = true;
                    }
                }

                i = current;
            }

            duration += entry.getDuration(this.getRandomSeed(duration));
        }
        while (duration < tick);

        return entry == null ? null : new FoundMorph(lastIndex, entry, lastEntry, duration, lastDuration, prevLastDuration, lastLoopCount, lastIsFirstMorph);
    }

    public int getTickAt(int index)
    {
        if (this.morphs.isEmpty() || index < 0 || this.getMaxDuration() < 0.0001F || this.isRandom && this.isTrulyRandom)
        {
            return (int) this.getDuration();
        }

        int size = this.morphs.size();

        int i = -1;
        float duration = 0;

        int loopCount = 0;

        while (i != index)
        {
            SequenceEntry entry = null;
            
            if (i > 0 && i < size)
            {
                entry = this.morphs.get(i);
            }

            if (entry != null && entry.endPoint && this.loop > 0 && this.loopCount >= this.loop - 1)
            {
                break;
            }

            if (this.isRandom)
            {
                if (entry != null && entry.endPoint)
                {
                    loopCount++;
                }

                i = this.getRandomIndex(duration);
            }
            else
            {
                int next = i + (this.reverse ? -1 : 1);
                int current = MathUtils.cycler(next, 0, size - 1);

                if (current != next)
                {
                    if (this.loop > 0 && loopCount >= this.loop - 1)
                    {
                        break;
                    }
                    else
                    {
                        if (i == -1)
                        {
                            this.loopCount = 0;
                        }
                        else
                        {
                            this.loopCount++;
                        }
                    }
                }

                i = current;
            }

            duration += this.morphs.get(i).getDuration(this.getRandomSeed(duration));
        }

        return (int) duration;
    }

    /**
     * Get duration of this sequencer morph for a single cycle
     */
    public float getDuration()
    {
        float duration = 0F;

        for (SequenceEntry entry : this.morphs)
        {
            duration += entry.getDuration(this.getRandomSeed(duration));
        }

        return duration;
    }
    
    /**
     * Get maxium duration
     */
    public float getMaxDuration()
    {
        float duration = 0F;

        for (SequenceEntry entry : this.morphs)
        {
            duration += entry.duration + Math.max(entry.random, 0);
        }

        return duration;
    }

    @Override
    public void update(EntityLivingBase target)
    {
        this.updateCycle();

        AbstractMorph morph = this.currentMorph.get();

        if (morph != null)
        {
            morph.update(target);
        }
    }

    /**
     * Update timer and morph for render
     */
    @SideOnly(Side.CLIENT)
    protected void updateClient(EntityLivingBase entity, float progress)
    {
        this.updateMorph(progress);
    }

    /**
     * Update the cycle timer 
     */
    protected void updateCycle()
    {
        if (this.isPaused())
        {
            return;
        }

        this.updateMorph(this.timer);
        this.timer++;
    }

    /**
     * Update the current morph, make sure that we have currently the 
     * correct morph.
     */
    protected void updateMorph(float timer)
    {
        while (!this.morphs.isEmpty() && timer >= this.duration)
        {
            int size = this.morphs.size();
            SequenceEntry entry = null;

            if (this.current >= 0 && this.current < size)
            {
                entry = this.morphs.get(this.current);
            }

            if (entry != null && entry.endPoint && this.loop > 0 && this.loopCount >= this.loop - 1)
            {
                break;
            }

            this.isFirstMorph = false;

            if (this.isRandom)
            {
                if (entry != null && entry.endPoint)
                {
                    this.loopCount++;
                    this.isFirstMorph = true;
                }

                this.current = this.getRandomIndex(this.duration);
            }
            else
            {
                int next = this.current + (this.reverse ? -1 : 1);
                int current = MathUtils.cycler(next, 0, size - 1);

                if (current != next)
                {
                    if (this.loop > 0 && this.loopCount >= this.loop - 1)
                    {
                        return;
                    }
                    else
                    {
                        if (this.current == -1)
                        {
                            this.loopCount = 0;
                        }
                        else
                        {
                            this.loopCount++;
                        }

                        this.isFirstMorph = true;
                    }
                }
                
                this.current = current;
            }

            if (this.current >= 0 && this.current < size)
            {
                entry = this.morphs.get(this.current);
                AbstractMorph morph = MorphUtils.copy(entry.morph);
                float duration = entry.getDuration(this.getRandomSeed(this.duration));

                this.updateProgress(this.currentMorph.get(), (int) (this.duration - this.lastDuration) - (int) Math.max(this.lastUpdate - this.lastDuration, 0));

                if (this.morphSetDuration)
                {
                    this.updateSetDuration(this.currentMorph.get(), 1, 1);
                }

                this.currentMorph.set(morph);
                this.lastDuration = this.duration;
                this.duration += duration;
                this.morphSetDuration = entry.setDuration;
            }

            if (this.duration - this.lastDuration < 0.0001 && this.getMaxDuration() < 0.0001)
            {
                break;
            }
        }
    }

    /**
     * Set animation's duration to 1
     */
    protected boolean updateSetDuration(AbstractMorph morph, int progress, int duration)
    {
        boolean result = false;

        if (!(morph instanceof SequencerMorph) && morph instanceof IMorphProvider)
        {
            result |= updateSetDuration(((IMorphProvider) morph).getMorph(), progress, duration);
        }

        if (morph instanceof IAnimationProvider)
        {
            ((IAnimationProvider) morph).getAnimation().duration = duration;
            ((IAnimationProvider) morph).getAnimation().progress = progress;

            result = true;
        }

        if (morph instanceof IBodyPartProvider)
        {
            for (BodyPart part : ((IBodyPartProvider) morph).getBodyPart().parts)
            {
                result |= this.updateSetDuration(part.morph.get(), progress, duration);
            }
        }

        return result;
    }

    protected void updateProgress(AbstractMorph morph, int progress)
    {
        if (morph instanceof SequencerMorph)
        {
            //breaks keep progress with the fix that emoticons action animation flickers (thanks to MiaoNLI for this update)
            //((SequencerMorph) morph).timer += progress;
        }
        else if (morph instanceof IMorphProvider)
        {
            updateProgress(((IMorphProvider) morph).getMorph(), progress);
        }

        if (morph instanceof IAnimationProvider)
        {
            ((IAnimationProvider) morph).getAnimation().progress += progress;
        }

        if (morph instanceof IBodyPartProvider)
        {
            for (BodyPart part : ((IBodyPartProvider) morph).getBodyPart().parts)
            {
                this.updateProgress(part.morph.get(), progress);
            }
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new SequencerMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof SequencerMorph)
        {
            SequencerMorph morph = (SequencerMorph) from;

            for (SequenceEntry entry : morph.morphs)
            {
                this.morphs.add(entry.clone());
            }

            this.reverse = morph.reverse;
            this.isRandom = morph.isRandom;
            this.isTrulyRandom = morph.isTrulyRandom;

            /* Runtime properties */
            this.currentMorph.copy(morph.currentMorph);
            this.timer = morph.timer;
            this.current = morph.current;
            this.duration = morph.duration;
            
            this.loop = morph.loop;
            this.offset[0] = morph.offset[0];
            this.offset[1] = morph.offset[1];
            this.offset[2] = morph.offset[2];
            this.offsetCount = morph.offsetCount;

            this.keepProgress = morph.keepProgress;
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        AbstractMorph morph = this.currentMorph.get();

        return morph == null ? 0 : morph.getWidth(target);
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        AbstractMorph morph = this.currentMorph.get();

        return morph == null ? 0 : morph.getHeight(target);
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof SequencerMorph)
        {
            SequencerMorph seq = (SequencerMorph) obj;

            result = result && Objects.equals(this.morphs, seq.morphs);
            result = result && this.reverse == seq.reverse;
            result = result && this.isRandom == seq.isRandom;
            result = result && this.isTrulyRandom == seq.isTrulyRandom;
            result = result && this.loop == seq.loop;
            result = result && Objects.deepEquals(this.offset, seq.offset);
            result = result && this.offsetCount == seq.offsetCount;
            result = result && this.keepProgress == seq.keepProgress;
        }

        return result;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof SequencerMorph)
        {
            SequencerMorph sequencer = (SequencerMorph) morph;

            if (!sequencer.morphs.equals(this.morphs))
            {
                this.mergeBasic(morph);
                this.morphs.clear();

                for (SequenceEntry entry : sequencer.morphs)
                {
                    this.morphs.add(entry.clone());
                }

                this.current = -1;
                this.duration = 0;

                if (!sequencer.keepProgress)
                {
                    this.timer = 0;
                }

                this.reverse = sequencer.reverse;
                this.isRandom = sequencer.isRandom;

                this.loopCount = 0;
                this.isFirstMorph = false;
                this.loop = sequencer.loop;
                this.offset[0] = sequencer.offset[0];
                this.offset[1] = sequencer.offset[1];
                this.offset[2] = sequencer.offset[2];
                this.offsetCount = sequencer.offsetCount;

                this.lastDuration = 0;
                this.lastUpdate = 0;

                return true;
            }
        }

        return super.canMerge(morph);
    }

    @Override
    public void afterMerge(AbstractMorph morph)
    {
        super.afterMerge(morph);

        this.currentMorph.setDirect(morph);
        this.current = -1;
        this.duration = 0;
        this.timer = 0;
        this.loopCount = 0;
        this.isFirstMorph = false;
        this.lastDuration = 0;
        this.lastUpdate = 0;

        if (morph instanceof SequencerMorph)
        {
            SequencerMorph sequencer = (SequencerMorph) morph;

            if (this.keepProgress)
            {
                this.timer = sequencer.timer;
            }
        }
    }

    @Override
    public void reset()
    {
        super.reset();

        this.current = -1;
        this.timer = 0;
        this.duration = 0;
        this.loopCount = 0;
        this.reverse = false;
        this.currentMorph.setDirect(null);
        this.morphs.clear();
        this.loop = 0;
        this.offset[0] = this.offset[1] = this.offset[2] = 0;
        this.offsetCount = 0;
        this.lastUpdate = 0;
        this.keepProgress = false;
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.reverse) tag.setBoolean("Reverse", this.reverse);
        if (this.isRandom) tag.setBoolean("Random", this.isRandom);
        if (this.isTrulyRandom) tag.setBoolean("TrulyRandom", this.isTrulyRandom);
        if (this.loop > 0) tag.setInteger("Loop", this.loop);
        tag.setTag("Offset", NBTUtils.writeFloatList(new NBTTagList(), this.offset));
        if (this.offsetCount > 0) tag.setInteger("OffsetCount", this.offsetCount);
        if (this.keepProgress) tag.setBoolean("KeepProgress", this.keepProgress);

        if (!this.morphs.isEmpty())
        {
            NBTTagList list = new NBTTagList();

            for (SequenceEntry entry : this.morphs)
            {
                list.appendTag(entry.toNBT());
            }

            tag.setTag("List", list);
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Reverse")) this.reverse = tag.getBoolean("Reverse");
        if (tag.hasKey("Random")) this.isRandom = tag.getBoolean("Random");
        if (tag.hasKey("TrulyRandom")) this.isTrulyRandom = tag.getBoolean("TrulyRandom");
        if (tag.hasKey("Loop")) this.loop = tag.getInteger("Loop");
        if (tag.hasKey("Offset")) NBTUtils.readFloatList(tag.getTagList("Offset", 5), this.offset);
        if (tag.hasKey("OffsetCount")) this.offsetCount = tag.getInteger("OffsetCount");
        if (tag.hasKey("KeepProgress")) this.keepProgress = tag.getBoolean("KeepProgress");

        if (tag.hasKey("List", NBT.TAG_LIST))
        {
            NBTTagList list = tag.getTagList("List", NBT.TAG_COMPOUND);

            for (int i = 0, c = list.tagCount(); i < c; i++)
            {
                SequenceEntry entry = new SequenceEntry();

                entry.fromNBT(list.getCompoundTagAt(i));
                this.morphs.add(entry);
            }

            this.current = -1;
            this.duration = 0;
            this.timer = 0;
            this.loopCount = 0;
            this.lastUpdate = 0;
        }
    }

    /**
     * Sequence entry
     * 
     * Represents a data class cell/entry thing that stores morph and 
     * its delay/duration until next morph in the sequence.
     */
    public static class SequenceEntry
    {
        public AbstractMorph morph;
        public float duration = 10;
        public float random = 0;
        public boolean setDuration;
        public boolean endPoint;

        public SequenceEntry()
        {}

        public SequenceEntry(AbstractMorph morph)
        {
            this.morph = morph;
        }

        public SequenceEntry(AbstractMorph morph, float duration)
        {
            this(morph, duration, 0);
        }

        public SequenceEntry(AbstractMorph morph, float duration, float random)
        {
            this(morph, duration, random, true);
        }
        
        public SequenceEntry(AbstractMorph morph, float duration, float random, boolean setDuration)
        {
            this(morph, duration, random, setDuration, false);
        }

        public SequenceEntry(AbstractMorph morph, float duration, float random, boolean setDuration, boolean endPoint)
        {
            this.morph = morph;
            this.duration = duration;
            this.random = random;
            this.setDuration = setDuration;
            this.endPoint = endPoint;
        }

        public float getDuration(Random random)
        {
            return this.duration + (this.random != 0 ? random.nextFloat() * this.random : 0);
        }

        @Override
        public SequenceEntry clone()
        {
            return new SequenceEntry(MorphUtils.copy(this.morph), this.duration, this.random, this.setDuration, this.endPoint);
        }

        @Override
        public boolean equals(Object obj)
        {
            if (obj instanceof SequenceEntry)
            {
                SequenceEntry entry = (SequenceEntry) obj;

                return Objects.equals(this.morph, entry.morph)
                    && this.duration == entry.duration
                    && this.random == entry.random
                    && this.setDuration == entry.setDuration
                    && this.endPoint == entry.endPoint;
            }

            return super.equals(obj);
        }

        public NBTTagCompound toNBT()
        {
            NBTTagCompound entryTag = new NBTTagCompound();

            if (this.morph != null)
            {
                entryTag.setTag("Morph", this.morph.toNBT());
            }

            entryTag.setFloat("Duration", this.duration);
            entryTag.setFloat("Random", this.random);
            entryTag.setBoolean("SetDuration", this.setDuration);
            entryTag.setBoolean("EndPoint", this.endPoint);

            return entryTag;
        }

        public void fromNBT(NBTTagCompound tag)
        {
            if (tag.hasKey("Morph", NBT.TAG_COMPOUND))
            {
                this.morph = MorphManager.INSTANCE.morphFromNBT(tag.getCompoundTag("Morph"));
            }

            if (tag.hasKey("Duration", NBT.TAG_ANY_NUMERIC))
            {
                this.duration = tag.getFloat("Duration");
            }

            if (tag.hasKey("Random", NBT.TAG_ANY_NUMERIC))
            {
                this.random = tag.getFloat("Random");
            }

            this.setDuration = tag.hasKey("SetDuration") && tag.getBoolean("SetDuration");
            this.endPoint = tag.hasKey("EndPoint") && tag.getBoolean("EndPoint");
        }
    }

    /**
     * Data class that is responsible for storing found morph(s)
     * when doing search for specific morph at given tick
     */
    public static class FoundMorph
    {
        public int index;
        public SequenceEntry current;
        public SequenceEntry previous;
        public float totalDuration;
        public float lastDuration;
        public float prevLastDuration;
        public int loopCount;
        public boolean isFirstMorph;

        public FoundMorph(int index, SequenceEntry current, SequenceEntry previous, float totalDuration, float lastDuration, float prevLastDuration, int loopCount, boolean isFirstMorph)
        {
            this.index = index;
            this.current = current;
            this.previous = previous;
            this.totalDuration = totalDuration;
            this.lastDuration = lastDuration;
            this.prevLastDuration = prevLastDuration;
            this.loopCount = loopCount;
            this.isFirstMorph = isFirstMorph;
        }

        public AbstractMorph getCurrentMorph()
        {
            return this.current == null ? null : this.current.morph;
        }

        public AbstractMorph getPreviousMorph()
        {
            return this.previous == null ? null : this.previous.morph;
        }

        public float getCurrentDuration()
        {
            return this.totalDuration - this.lastDuration;
        }

        public float getPreviousDuration()
        {
            return this.lastDuration - this.prevLastDuration;
        }

        public void applyCurrent(AbstractMorph morph)
        {
            if (this.current.setDuration && morph instanceof IAnimationProvider)
            {
                ((IAnimationProvider) morph).getAnimation().duration = (int) this.getCurrentDuration();
            }
        }

        public void applyPrevious(AbstractMorph morph)
        {
            if (this.previous.setDuration && morph instanceof IAnimationProvider)
            {
                ((IAnimationProvider) morph).getAnimation().duration = (int) this.getPreviousDuration();
            }
        }
    }
}

==================================================

--- Файл №532 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\SnowstormMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.blockbuster.Blockbuster;
import mchorse.blockbuster.client.RenderingHandler;
import mchorse.blockbuster.client.particles.BedrockLibrary;
import mchorse.blockbuster.client.particles.BedrockScheme;
import mchorse.blockbuster.client.particles.emitter.BedrockEmitter;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.metamorph.api.MorphUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;

public class SnowstormMorph extends AbstractMorph
{
    @SideOnly(Side.CLIENT)
    private static Matrix4f matrix;

    @SideOnly(Side.CLIENT)
    private static Vector4f vector;

    public String scheme = "";
    public Map<String, String> variables = new HashMap<String, String>();

    private BedrockEmitter emitter;
    public List<BedrockEmitter> lastEmitters;

    private long lastUpdate;
    private int lastAge = 0; //to determine which tick it is

    public static Matrix4f getMatrix()
    {
        if (matrix == null)
        {
            matrix = new Matrix4f();
        }

        return matrix;
    }

    public static Vector4f getVector()
    {
        if (vector == null)
        {
            vector = new Vector4f();
        }

        return vector;
    }

    @SideOnly(Side.CLIENT)
    public static Vector4f calculateGlobal(Matrix4f matrix, EntityLivingBase entity, float x, float y, float z, float partial)
    {
        Vector4f vector4f = getVector();

        vector4f.set(x, y, z, 1);
        matrix.transform(vector4f);
        vector4f.add(new Vector4f(
            (float) Interpolations.lerp(entity.prevPosX, entity.posX, partial),
            (float) Interpolations.lerp(entity.prevPosY, entity.posY, partial),
            (float) Interpolations.lerp(entity.prevPosZ, entity.posZ, partial),
            (float) 0
        ));

        return vector4f;
    }

    public SnowstormMorph()
    {
        super();
        this.name = "snowstorm";
    }

    public void replaceVariable(String name, String expression)
    {
        this.variables.put(name, expression);
        this.emitter.parseVariable(name, expression);
    }

    public BedrockEmitter getEmitter()
    {
        if (this.emitter == null)
        {
            this.setClientScheme(this.scheme);
        }

        return this.emitter;
    }

    public List<BedrockEmitter> getLastEmitters()
    {
        if (this.lastEmitters == null)
        {
            this.lastEmitters = new ArrayList<BedrockEmitter>();
        }

        return this.lastEmitters;
    }

    public void setScheme(String key)
    {
        this.scheme = key;

        if (this.emitter != null)
        {
            this.setClientScheme(key);
        }
    }

    private void setClientScheme(String key)
    {
        if (this.emitter != null)
        {
            this.getEmitter().running = false;
            this.getLastEmitters().add(this.getEmitter());
        }

        this.emitter = new BedrockEmitter();
        this.emitter.setScheme(this.getScheme(key), this.variables);
    }

    private BedrockScheme getScheme(String key)
    {
        return Blockbuster.proxy.particles.presets.get(key);
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        return this.getEmitter().scheme != null ? this.getEmitter().scheme.identifier : this.name;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer entityPlayer, int x, int y, float scale, float alpha)
    {
        this.getEmitter().renderOnScreen(x, y, scale);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase target, double x, double y, double z, float yaw, float partialTicks)
    {
        if (GuiModelRenderer.isRendering() || MorphUtils.isRenderingOnScreen)
        {
            return;
        }

        if (this.emitter != null && this.emitter.scheme != null && this.lastUpdate < BedrockLibrary.lastUpdate)
        {
            this.lastUpdate = BedrockLibrary.lastUpdate;

            if (this.emitter.scheme != this.getScheme(this.scheme))
            {
                this.setClientScheme(this.scheme);
            }
        }

        BedrockEmitter emitter = this.getEmitter();

        if (MatrixUtils.matrix != null)
        {
            MatrixUtils.Transformation transformation = MatrixUtils.extractTransformations(MatrixUtils.matrix, MatrixUtils.readModelView(), MatrixUtils.MatrixMajor.COLUMN);

            Vector4f zero = calculateGlobal(transformation.translation, target, 0, 0, 0, partialTicks);

            if (this.lastAge != this.age)
            {
                emitter.prevRotation.set(emitter.rotation);
                emitter.prevGlobal.set(emitter.lastGlobal);
            }

            this.lastAge = this.age;

            emitter.lastGlobal.x = zero.x;
            emitter.lastGlobal.y = zero.y;
            emitter.lastGlobal.z = zero.z;

            emitter.translation.set(this.cachedTranslation);

            emitter.rotation.set(transformation.getRotation3f());

            emitter.scale[0] = transformation.scale.m00;
            emitter.scale[1] = transformation.scale.m11;
            emitter.scale[2] = transformation.scale.m22;

            Iterator<BedrockEmitter> it = this.getLastEmitters().iterator();

            while (it.hasNext())
            {
                BedrockEmitter last = it.next();

                if (!last.added)
                {
                    it.remove();

                    continue;
                }

                last.lastGlobal.set(emitter.lastGlobal);
                last.rotation.set(emitter.rotation);
            }
        }
        else
        {
            emitter.lastGlobal.x = Interpolations.lerp(target.prevPosX, target.posX, partialTicks);
            emitter.lastGlobal.y = Interpolations.lerp(target.prevPosY, target.posY, partialTicks);
            emitter.lastGlobal.z = Interpolations.lerp(target.prevPosZ, target.posZ, partialTicks);
            emitter.rotation.setIdentity();

            Iterator<BedrockEmitter> it = this.getLastEmitters().iterator();

            while (it.hasNext())
            {
                BedrockEmitter last = it.next();

                if (!last.added)
                {
                    it.remove();

                    continue;
                }

                last.lastGlobal.set(emitter.lastGlobal);
                last.rotation.set(emitter.rotation);
            }
        }

        RenderingHandler.addEmitter(emitter, target);
        this.updateClient();
    }

    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        if (target.world.isRemote)
        {
            this.updateClient();
        }
    }

    @SideOnly(Side.CLIENT)
    private void updateClient()
    {
        this.getEmitter().sanityTicks = 0;

        for (BedrockEmitter emitter : this.getLastEmitters())
        {
            emitter.sanityTicks = 0;
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new SnowstormMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof SnowstormMorph)
        {
            SnowstormMorph morph = (SnowstormMorph) from;

            this.setScheme(morph.scheme);
            this.variables.putAll(morph.variables);
        }
    }

    @Override
    public float getWidth(EntityLivingBase entityLivingBase)
    {
        return 0.6F;
    }

    @Override
    public float getHeight(EntityLivingBase entityLivingBase)
    {
        return 1.8F;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof SnowstormMorph)
        {
            SnowstormMorph morph = (SnowstormMorph) obj;

            result = result && Objects.equals(this.scheme, morph.scheme);
            result = result && Objects.equals(this.variables, morph.variables);
        }

        return result;
    }

    @Override
    public boolean useTargetDefault()
    {
        return true;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof SnowstormMorph)
        {
            SnowstormMorph snow = (SnowstormMorph) morph;

            this.mergeBasic(morph);

            this.variables = snow.variables;

            if (this.emitter != null)
            {
                if (!this.scheme.equals(snow.scheme))
                {
                    this.setScheme(snow.scheme);
                }
                else
                {
                    this.emitter.parseVariables(this.variables);
                }
            }

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public void reset()
    {
        super.reset();

        this.scheme = "";
        this.variables.clear();
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Vars"))
        {
            NBTTagCompound vars = tag.getCompoundTag("Vars");

            for (String key : vars.getKeySet())
            {
                this.variables.put(key, vars.getString(key));
            }
        }

        if (tag.hasKey("Scheme"))
        {
            this.setScheme(tag.getString("Scheme"));
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (!this.variables.isEmpty())
        {
            NBTTagCompound vars = new NBTTagCompound();

            for (Map.Entry<String, String> entry : this.variables.entrySet())
            {
                vars.setString(entry.getKey(), entry.getValue());
            }

            tag.setTag("Vars", vars);
        }

        tag.setString("Scheme", this.scheme);
    }
}

==================================================

--- Файл №533 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\StructureMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import mchorse.blockbuster.api.ModelPose;
import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster.network.Dispatcher;
import mchorse.blockbuster.network.common.structure.PacketStructure;
import mchorse.blockbuster.network.common.structure.PacketStructureRequest;
import mchorse.blockbuster.network.server.ServerHandlerStructureRequest;
import mchorse.blockbuster_pack.morphs.structure.StructureAnimation;
import mchorse.blockbuster_pack.morphs.structure.StructureRenderer;
import mchorse.blockbuster_pack.morphs.structure.StructureStatus;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.utils.ForgeUtils;
import mchorse.mclib.utils.Interpolations;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.init.Biomes;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.server.management.PlayerList;
import net.minecraft.util.ResourceLocation;
import net.minecraft.world.biome.Biome;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import java.io.File;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

public class StructureMorph extends AbstractMorph implements IAnimationProvider, ISyncableMorph, IMorphGenerator
{
    private static final ResourceLocation DEFAULT_BIOME = new ResourceLocation("ocean");

    /**
     * Map of baked structures 
     */
    @SideOnly(Side.CLIENT)
    public static Map<String, StructureRenderer> STRUCTURES;

    /**
     * Cache of structures 
     */
    public static final Map<String, Long> STRUCTURE_CACHE = new HashMap<String, Long>();

    /**
     * The name of the structure which should be rendered 
     */
    public String structure = "";
    
    /**
     * The biome used for render
     */
    public ResourceLocation biome = DEFAULT_BIOME;

    /**
     * Whether this structure use world lighting.
     */
    public boolean lighting = true;

    /**
     * TSR for structure morph
     */
    public ModelTransform pose = new ModelTransform();

    public StructureAnimation animation = new StructureAnimation();

    /* Rotation point */
    public float anchorX;
    public float anchorY;
    public float anchorZ;

    @SideOnly(Side.CLIENT)
    public static void request()
    {
        if (STRUCTURES.isEmpty())
        {
            Dispatcher.sendToServer(new PacketStructureRequest());
        }
    }

    @SideOnly(Side.CLIENT)
    public static void reloadStructures()
    {
        cleanUp();
        request();
    }

    /**
     * Update structures 
     */
    public static void checkStructures()
    {
        for (String name : ServerHandlerStructureRequest.getAllStructures())
        {
            File file = ServerHandlerStructureRequest.getStructureFolder(name);
            Long modified = STRUCTURE_CACHE.get(name);

            if (modified == null)
            {
                modified = file.lastModified();
                STRUCTURE_CACHE.put(name, modified);
            }

            if (modified < file.lastModified())
            {
                STRUCTURE_CACHE.put(name, file.lastModified());

                IMessage packet = new PacketStructure(name, null);

                for (EntityPlayerMP player : ForgeUtils.getServerPlayers())
                {
                    if (player != null)
                    {
                        Dispatcher.sendTo(packet, player);
                    }
                }
            }
        }
    }

    @SideOnly(Side.CLIENT)
    public static void cleanUp()
    {
        for (StructureRenderer renderer : STRUCTURES.values())
        {
            renderer.delete();
        }

        STRUCTURES.clear();
    }

    public StructureMorph()
    {
        super();

        this.name = "structure";
    }

    @Override
    public Animation getAnimation()
    {
        return this.animation;
    }

    public Biome getBiome()
    {
        Biome biome = Biome.REGISTRY.getObject(this.biome);

        return biome == null ? Biomes.DEFAULT : biome;
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        if (previous instanceof StructureMorph)
        {
            StructureMorph structure = (StructureMorph) previous;

            this.animation.last = new ModelTransform();
            this.animation.last.copy(structure.pose);
        }
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
    }

    @Override
    public boolean canGenerate()
    {
        return this.animation.isInProgress();
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks)
    {
        StructureMorph morph = (StructureMorph) this.copy();

        this.animation.apply(morph.pose, partialTicks);
        morph.animation.duration = this.animation.progress;

        return morph;
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        String suffix = this.structure != null && !this.structure.isEmpty() ? " (" + this.structure + "-" + this.biome.getResourcePath() + ")" : "";

        return I18n.format("blockbuster.morph.structure") + suffix;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        StructureRenderer renderer = STRUCTURES.get(this.structure);

        if (renderer != null)
        {
            if (renderer.status != StructureStatus.LOADED)
            {
                if (renderer.status == StructureStatus.UNLOADED)
                {
                    renderer.status = StructureStatus.LOADING;
                    Dispatcher.sendToServer(new PacketStructureRequest(this.structure));
                }

                return;
            }

            int max = Math.max(renderer.size.getX(), Math.max(renderer.size.getY(), renderer.size.getZ()));

            scale /= 0.65F * max;

            Minecraft.getMinecraft().renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);

            float lastX = OpenGlHelper.lastBrightnessX;
            float lastY = OpenGlHelper.lastBrightnessY;
            
            GlStateManager.enableDepth();
            GlStateManager.enableAlpha();
            GlStateManager.disableCull();
            GlStateManager.pushMatrix();
            GlStateManager.translate(x, y, 0);
            GlStateManager.scale(scale, scale, scale);
            GlStateManager.rotate(45.0F, -1.0F, 0.0F, 0.0F);
            GlStateManager.rotate(45.0F, 0.0F, -1.0F, 0.0F);
            GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
            GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);

            renderer.render(this);
            renderer.renderTEs(this);
            GlStateManager.disableLighting();
            GlStateManager.popMatrix();
            GlStateManager.enableCull();
            GlStateManager.disableAlpha();
            GlStateManager.disableDepth();
            
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastX, lastY);
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        StructureRenderer renderer = STRUCTURES.get(this.structure);

        if (renderer != null)
        {
            if (renderer.status != StructureStatus.LOADED)
            {
                if (renderer.status == StructureStatus.UNLOADED)
                {
                    renderer.status = StructureStatus.LOADING;
                    Dispatcher.sendToServer(new PacketStructureRequest(this.structure));
                }

                return;
            }

            float lastX = OpenGlHelper.lastBrightnessX;
            float lastY = OpenGlHelper.lastBrightnessY;
            
            if (GuiModelRenderer.isRendering() && !this.lighting)
            {
                Minecraft.getMinecraft().entityRenderer.enableLightmap();
            }

            Minecraft.getMinecraft().renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);

            /* These states are important to enable */
            GlStateManager.pushMatrix();
            GlStateManager.enableRescaleNormal();
            GlStateManager.translate(x, y, z);

            ModelTransform transform = this.pose;

            float anchorX = this.anchorX;
            float anchorY = this.anchorY;
            float anchorZ = this.anchorZ;

            if (this.animation.isInProgress())
            {
                transform = new ModelTransform();
                transform.copy(this.pose);

                this.animation.apply(transform, partialTicks);

                if (this.animation.lastAnchorX != null)
                {
                    float factor = this.animation.getFactor(partialTicks);

                    anchorX = this.animation.interp.interpolate(this.animation.lastAnchorX, anchorX, factor);
                    anchorY = this.animation.interp.interpolate(this.animation.lastAnchorY, anchorY, factor);
                    anchorZ = this.animation.interp.interpolate(this.animation.lastAnchorZ, anchorZ, factor);
                }
            }

            transform.transform();
            GlStateManager.translate(anchorX, anchorY, anchorZ);
            
            RenderHelper.disableStandardItemLighting();
            
            GlStateManager.shadeModel(GL11.GL_SMOOTH);
            GlStateManager.enableAlpha();
            GlStateManager.enableBlend();
            GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

            renderer.render(this);

            GlStateManager.disableBlend();
            GlStateManager.disableAlpha();
            GlStateManager.shadeModel(GL11.GL_FLAT);
            
            GlStateManager.enableLighting();
            GlStateManager.enableLight(0);
            GlStateManager.enableLight(1);
            GlStateManager.enableColorMaterial();

            GL11.glColor4f(1, 1, 1, 1);
            renderer.renderTEs(this);
            
            GlStateManager.popMatrix();
            
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, lastX, lastY);
            if (GuiModelRenderer.isRendering() && !this.lighting)
            {
                Minecraft.getMinecraft().entityRenderer.disableLightmap();
            }
        }
    }

    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        this.animation.update();
    }

    @Override
    public AbstractMorph create()
    {
        return new StructureMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof StructureMorph)
        {
            StructureMorph morph = (StructureMorph) from;

            this.structure = morph.structure;
            this.pose.copy(morph.pose);
            this.animation.copy(morph.animation);
            this.biome = morph.biome;
            this.lighting = morph.lighting;
            this.anchorX = morph.anchorX;
            this.anchorY = morph.anchorY;
            this.anchorZ = morph.anchorZ;

            this.animation.reset();
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return 0.6F;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return 1.8F;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof StructureMorph)
        {
            StructureMorph morph = (StructureMorph) obj;

            result = result && Objects.equals(this.structure, morph.structure);
            result = result && Objects.equals(this.pose, morph.pose);
            result = result && Objects.equals(this.animation, morph.animation);
            result = result && Objects.equals(this.biome, morph.biome);
            result = result && this.lighting == morph.lighting;
            result = result && this.anchorX == morph.anchorX;
            result = result && this.anchorY == morph.anchorY;
            result = result && this.anchorZ == morph.anchorZ;
        }

        return result;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof StructureMorph)
        {
            StructureMorph structure = (StructureMorph) morph;

            this.mergeBasic(morph);

            if (!structure.animation.ignored)
            {
                ModelTransform pose = new ModelTransform();

                pose.copy(this.pose);

                this.copy(structure);
                this.animation.merge(this, structure);
                this.animation.last = pose;
                this.animation.progress = 0;
            }

            return true;
        }

        return super.canMerge(morph);
    }

    @Override
    public void reset()
    {
        super.reset();

        this.animation.reset();
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Structure")) this.structure = tag.getString("Structure");
        if (tag.hasKey("Pose")) this.pose.fromNBT(tag.getCompoundTag("Pose"));
        if (tag.hasKey("Animation")) this.animation.fromNBT(tag.getCompoundTag("Animation"));
        if (tag.hasKey("Biome")) this.biome = new ResourceLocation(tag.getString("Biome"));
        if (tag.hasKey("Lighting")) this.lighting = tag.getBoolean("Lighting");
        if (tag.hasKey("AnchorX")) this.anchorX = tag.getFloat("AnchorX");
        if (tag.hasKey("AnchorY")) this.anchorY = tag.getFloat("AnchorY");
        if (tag.hasKey("AnchorZ")) this.anchorZ = tag.getFloat("AnchorZ");
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (!this.structure.isEmpty())
        {
            tag.setString("Structure", this.structure);
        }

        if (!this.pose.isDefault())
        {
            tag.setTag("Pose", this.pose.toNBT());
        }

        NBTTagCompound animation = this.animation.toNBT();

        if (!animation.hasNoTags())
        {
            tag.setTag("Animation", animation);
        }
        
        if (!this.biome.equals(DEFAULT_BIOME))
        {
            ResourceLocation biome = this.biome == null ? DEFAULT_BIOME : this.biome;

            tag.setString("Biome", biome.toString());
        }
        
        if (!this.lighting)
        {
            tag.setBoolean("Lighting", this.lighting);
        }

        if (this.anchorX != 0)
        {
            tag.setFloat("AnchorX", this.anchorX);
        }

        if (this.anchorY != 0)
        {
            tag.setFloat("AnchorY", this.anchorY);
        }

        if (this.anchorZ != 0)
        {
            tag.setFloat("AnchorZ", this.anchorZ);
        }
    }
}

==================================================

--- Файл №534 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\TrackerMorph.java
--------------------
package mchorse.blockbuster_pack.morphs;

import com.google.common.base.Objects;
import mchorse.blockbuster_pack.trackers.MorphTracker;
import mchorse.blockbuster_pack.trackers.BaseTracker;
import mchorse.blockbuster_pack.trackers.TrackerRegistry;
import mchorse.mclib.client.Draw;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.EntityRenderer;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.resources.I18n;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.util.Constants.NBT;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix4f;
import java.awt.Color;

public class TrackerMorph extends AbstractMorph
{
    public BaseTracker tracker = new MorphTracker();

    public boolean hidden = false;

    private int renderTimer = 0;

    public TrackerMorph()
    {
        this.name = "tracker";
    }

    @Override
    @SideOnly(Side.CLIENT)
    protected String getSubclassDisplayName()
    {
        if (this.tracker != null && !this.tracker.name.isEmpty())
        {
            return I18n.format("blockbuster.gui.tracker_morph.type." + TrackerRegistry.CLASS_TO_ID.get(this.tracker.getClass())) + " (" + this.tracker.name + ")";
        }
        else
        {
            return I18n.format("blockbuster.gui.tracker_morph.name");
        }
    }

    @Override
    public void update(EntityLivingBase target)
    {
        super.update(target);

        if (target.world.isRemote)
        {
            this.renderTimer++;
        }
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer player, int x, int y, float scale, float alpha)
    {
        this.renderTimer++;

        FontRenderer font = Minecraft.getMinecraft().fontRenderer;

        GlStateManager.pushMatrix();

        GlStateManager.disableDepth();
        GlStateManager.translate(x, y - 15, 0);

        GlStateManager.pushMatrix();

        GlStateManager.translate(-5, 0, 0);
        GlStateManager.rotate(-45.0F, 1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(-45.0F, 0.0F, 1.0F, 0.0F);
        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
        GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
        GlStateManager.scale(scale * 2, scale * 2, scale * 2);

        renderPointer();

        GlStateManager.popMatrix();

        String name = I18n.format("blockbuster.gui.tracker_morph.name");

        if (this.tracker != null && this.tracker.name != null && !this.tracker.name.isEmpty())
        {
            name = this.tracker.name;
        }

        font.drawString(name, -font.getStringWidth(name) / 2, 5, 0xFFFFFFFF);

        GlStateManager.enableDepth();

        GlStateManager.popMatrix();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        GlStateManager.pushMatrix();
        GL11.glTranslated(x, y, z);

        if (Minecraft.isGuiEnabled() && !this.hidden || GuiModelRenderer.isRendering())
        {
            GlStateManager.disableLighting();
            this.renderPointer();
            GlStateManager.enableLighting();

            /* Don't render labels in gui - it clutters the screen */
            if (!this.hidden)
            {
                this.renderLabel();
            }
        }

        if (this.tracker != null)
        {
            this.tracker.track(entity, x, y, z, entityYaw, partialTicks);
        }

        GlStateManager.popMatrix();
    }

    private void renderPointer()
    {
        this.renderTimer %= 50;
        int rgb = Color.HSBtoRGB(this.renderTimer / 50.0F, 1.0F, 1.0F);
        int rgb2 = Color.HSBtoRGB(this.renderTimer / 50.0F + 0.5F, 1.0F, 1.0F);

        GlStateManager.pushMatrix();

        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
        GlStateManager.disableTexture2D();

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();
        GlStateManager.glLineWidth(5.0F);
        buffer.begin(1, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(0.0, 0.0, 0.0).color(0.0F, 0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(0.0, 0.0, 1.0).color(rgb >> 16 & 0xFF, rgb >> 8 & 0xFF, rgb >> 0 & 0xFF, 255).endVertex();
        buffer.pos(0.0, 0.0, 0.0).color(0.0F, 0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(0.0, 0.5, 0.0).color(rgb2 >> 16 & 0xFF, rgb2 >> 8 & 0xFF, rgb2 >> 0 & 0xFF, 255).endVertex();
        tessellator.draw();
        GlStateManager.glLineWidth(1.0F);
        Draw.point(0, 0, 0);

        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.enableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
        GlStateManager.enableTexture2D();

        GlStateManager.popMatrix();
    }

    private void renderLabel()
    {
        if (this.tracker != null && !this.tracker.name.isEmpty())
        {
            Minecraft mc = Minecraft.getMinecraft();
            FontRenderer font = mc.fontRenderer;

            Matrix4f mat = MatrixUtils.readModelView(new Matrix4f());

            GlStateManager.pushMatrix();
            GlStateManager.loadIdentity();
            EntityRenderer.drawNameplate(font, this.tracker.name, mat.m03, mat.m13 + font.FONT_HEIGHT / 48.0F + 0.1F, mat.m23, 0, 180F, 0, mc.gameSettings.thirdPersonView == 2, false);
            GlStateManager.popMatrix();
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new TrackerMorph();
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return 0;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return 0;
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof TrackerMorph)
        {
            TrackerMorph morph = (TrackerMorph) from;

            this.tracker = null;

            if (morph.tracker != null)
            {
                this.tracker = morph.tracker.copy();
            }

            this.hidden = morph.hidden;
        }
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof TrackerMorph)
        {
            this.mergeBasic(morph);

            TrackerMorph trackerMorph = (TrackerMorph) morph;

            this.hidden = trackerMorph.hidden;

            if (this.tracker != null)
            {
                return this.tracker.canMerge(trackerMorph.tracker);
            }
        }

        return super.canMerge(morph);
    }

    @Override
    public boolean equals(Object object)
    {
        boolean result = super.equals(object);

        if (object instanceof TrackerMorph)
        {
            TrackerMorph morph = (TrackerMorph) object;

            result = result && Objects.equal(this.tracker, morph.tracker);
            result = result && this.hidden == morph.hidden;

            return result;
        }

        return result;
    }

    @Override
    public boolean useTargetDefault()
    {
        return true;
    }

    @Override
    public void reset()
    {
        this.tracker = new MorphTracker();
        this.hidden = false;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Tracker", NBT.TAG_COMPOUND))
        {
            NBTTagCompound tracker = tag.getCompoundTag("Tracker");

            Class<? extends BaseTracker> clazz = TrackerRegistry.ID_TO_CLASS.get(tracker.getString("Id"));

            /* backwards compatibility with old minema tracker that got merge to MorphTracker class */
            if (tracker.getString("Id").equals("minema")) {
                clazz = MorphTracker.class;
            }

            if (clazz != null)
            {
                try
                {
                    this.tracker = clazz.newInstance();
                    this.tracker.fromNBT(tracker);
                }
                catch (InstantiationException | IllegalAccessException e)
                {
                    e.printStackTrace();
                }
            }
        }

        if (tag.hasKey("Hidden", NBT.TAG_BYTE))
        {
            this.hidden = tag.getBoolean("Hidden");
        }
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.tracker != null)
        {
            NBTTagCompound tracker = new NBTTagCompound();

            tracker.setString("Id", TrackerRegistry.CLASS_TO_ID.get(this.tracker.getClass()));
            this.tracker.toNBT(tracker);
            tag.setTag("Tracker", tracker);
        }

        if (this.hidden)
        {
            tag.setBoolean("Hidden", this.hidden);
        }
    }
}


==================================================

--- Файл №535 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\structure\StructureAnimation.java
--------------------
package mchorse.blockbuster_pack.morphs.structure;

import mchorse.blockbuster.api.ModelTransform;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import mchorse.metamorph.api.morphs.utils.Animation;

public class StructureAnimation extends Animation
{
    public ModelTransform last;
    public Float lastAnchorX;
    public Float lastAnchorY;
    public Float lastAnchorZ;

    @Override
    public void reset()
    {
        super.reset();

        this.last = null;
        this.lastAnchorX = null;
        this.lastAnchorY = null;
        this.lastAnchorZ = null;
    }

    public void merge(StructureMorph last, StructureMorph next)
    {
        this.merge(next.animation);
        this.last = new ModelTransform();
        this.last.copy(last.pose);
        this.lastAnchorX = last.anchorX;
        this.lastAnchorY = last.anchorY;
        this.lastAnchorZ = last.anchorZ;
    }

    public void apply(ModelTransform transform, float partialTicks)
    {
        if (this.last != null)
        {
            float factor = this.getFactor(partialTicks);

            transform.interpolate(this.last, transform, factor, this.interp);
        }
    }
}

==================================================

--- Файл №536 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\structure\StructureRenderer.java
--------------------
package mchorse.blockbuster_pack.morphs.structure;

import mchorse.blockbuster.network.client.ClientHandlerStructure;
import mchorse.blockbuster_pack.morphs.StructureMorph;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BlockRendererDispatcher;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.tileentity.TileEntityRendererDispatcher;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.renderer.vertex.VertexFormat;
import net.minecraft.client.renderer.vertex.VertexFormatElement;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.BlockRenderLayer;
import net.minecraft.util.EnumBlockRenderType;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.biome.Biome;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;

/**
 * Structure renderer
 *
 * All it does is renders compiled display list and also has the
 * method {@link #delete()} to clean up memory.
 */
@SideOnly(Side.CLIENT)
public class StructureRenderer
{
    public static int renderTimes = 0;

    public StructureStatus status = StructureStatus.UNLOADED;
    public Map<Biome, int[]> solidBuffers = new HashMap<Biome, int[]>();
    public Map<Biome, int[]> cutoutBuffers = new HashMap<Biome, int[]>();
    public Map<Biome, int[]> translucentBuffers = new HashMap<Biome, int[]>();
    public BlockPos size;
    public ClientHandlerStructure.FakeWorld world;
    public VertexFormat worldLighting;
    public VertexFormat structureLighting;
    public Map<TileEntity, Integer> tileEntityLighting = new LinkedHashMap<TileEntity, Integer>();

    public StructureRenderer()
    {}

    public StructureRenderer(BlockPos size, ClientHandlerStructure.FakeWorld world)
    {
        this.size = size;
        this.world = world;

        this.setupFormat();
        this.status = StructureStatus.LOADED;
    }

    public void setupFormat()
    {
        /* Check if optifine changed format. */
        if (!DefaultVertexFormats.BLOCK.equals(this.structureLighting))
        {
            this.solidBuffers.clear();
            this.structureLighting = DefaultVertexFormats.BLOCK;
            this.worldLighting = new VertexFormat();

            for (VertexFormatElement element : this.structureLighting.getElements())
            {
                if (DefaultVertexFormats.TEX_2S.equals(element))
                {
                    this.worldLighting.addElement(new VertexFormatElement(0, VertexFormatElement.EnumType.SHORT, VertexFormatElement.EnumUsage.PADDING, 2));
                }
                else
                {
                    this.worldLighting.addElement(element);
                }
            }
        }
    }

    public void rebuild(Biome biome)
    {
        this.world.biome = biome;

        int ao = Minecraft.getMinecraft().gameSettings.ambientOcclusion;

        Minecraft.getMinecraft().gameSettings.ambientOcclusion = 0;

        this.solidBuffers.put(biome, this.render(0));
        this.cutoutBuffers.put(biome, this.render(1));
        this.translucentBuffers.put(biome, this.render(2));

        Minecraft.getMinecraft().gameSettings.ambientOcclusion = ao;

        if (this.tileEntityLighting.isEmpty())
        {
            for (TileEntity te : this.world.loadedTileEntityList)
            {
                this.tileEntityLighting.put(te, this.world.getCombinedLight(te.getPos(), 0));
            }
        }
    }

    public void render(StructureMorph morph)
    {
        GL11.glNormal3f(0, 0.6F, 0);

        Biome biome = morph.getBiome();

        if (this.solidBuffers.get(biome) == null)
        {
            this.setupFormat();
            this.rebuild(biome);
        }

        Tessellator tess = Tessellator.getInstance();
        BufferBuilder buffer = tess.getBuffer();

        GlStateManager.disableAlpha();
        GlStateManager.disableBlend();

        if (this.solidBuffers.get(biome) != null && this.solidBuffers.get(biome).length > 0)
        {
            buffer.begin(GL11.GL_QUADS, morph.lighting ? this.worldLighting : this.structureLighting);
            buffer.addVertexData(this.solidBuffers.get(biome));
            tess.draw();
        }

        GlStateManager.enableAlpha();

        if (this.cutoutBuffers.get(biome) != null && this.cutoutBuffers.get(biome).length > 0)
        {
            buffer.begin(GL11.GL_QUADS, morph.lighting ? this.worldLighting : this.structureLighting);
            buffer.addVertexData(this.cutoutBuffers.get(biome));
            tess.draw();
        }

        GlStateManager.enableBlend();

        if (this.translucentBuffers.get(biome) != null && this.translucentBuffers.get(biome).length > 0)
        {
            buffer.begin(GL11.GL_QUADS, morph.lighting ? this.worldLighting : this.structureLighting);
            buffer.addVertexData(this.translucentBuffers.get(biome));
            tess.draw();
        }
    }

    public int[] render(int type)
    {
        Tessellator tess = Tessellator.getInstance();
        BufferBuilder buffer = tess.getBuffer();

        buffer.begin(GL11.GL_QUADS, this.structureLighting);

        BlockPos origin = new BlockPos(1, 1, 1);
        int w = this.size.getX();
        int h = this.size.getY();
        int d = this.size.getZ();

        BlockRendererDispatcher dispatcher = Minecraft.getMinecraft().getBlockRendererDispatcher();

        /* Centerize the geometry */
        buffer.setTranslation(-w / 2F - origin.getX(), -origin.getY(), -d / 2F - origin.getZ());

        for (BlockPos.MutableBlockPos pos : BlockPos.getAllInBoxMutable(origin, origin.add(w, h, d)))
        {
            IBlockState state = this.world.getBlockState(pos);
            Block block = state.getBlock();

            if (block.getDefaultState().getRenderType() != EnumBlockRenderType.INVISIBLE)
            {
                if (type == 0 && block.getBlockLayer() == BlockRenderLayer.SOLID
                    || type == 1 && (block.getBlockLayer() == BlockRenderLayer.CUTOUT || block.getBlockLayer() == BlockRenderLayer.CUTOUT_MIPPED)
                    || type == 2 && block.getBlockLayer() == BlockRenderLayer.TRANSLUCENT)
                {
                    dispatcher.renderBlock(state, pos, this.world, buffer);
                }
            }
        }

        buffer.setTranslation(0, 0, 0);
        buffer.finishDrawing();

        int count = buffer.getVertexCount();
        int[] vertexData = new int[count * this.structureLighting.getIntegerSize()];
        buffer.getByteBuffer().asIntBuffer().get(vertexData);

        return vertexData;
    }

    public void renderTEs(StructureMorph morph)
    {
        if (renderTimes >= 10 || GL11.glGetInteger(GL11.GL_MODELVIEW_STACK_DEPTH) >= GL11.glGetInteger(GL11.GL_MAX_MODELVIEW_STACK_DEPTH) - 4)
        {
            return;
        }
        
        if (this.world == null)
        {
            return;
        }

        renderTimes++;
        
        for (Entry<TileEntity, Integer> entry : this.tileEntityLighting.entrySet())
        {
            if (!morph.lighting)
            {
                int block = entry.getValue() % 65536;
                int sky = entry.getValue() / 65536;
                OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, block, sky);
            }
            
            TileEntity te = entry.getKey();
            BlockPos pos = te.getPos();
            
            TileEntityRendererDispatcher.instance.render(te, pos.getX() - this.size.getX() / 2D - 1, pos.getY() - 1, pos.getZ() - this.size.getZ() / 2D - 1, 0);
            /* For Beacon & End Gateway */
            GlStateManager.disableFog();
        }
            
        renderTimes--;
    }

    public void delete()
    {
        if (!this.solidBuffers.isEmpty())
        {
            this.solidBuffers.clear();
            this.tileEntityLighting.clear();
            this.status = StructureStatus.UNLOADED;
        }
    }
}

==================================================

--- Файл №537 ---
Путь: main\java\mchorse\blockbuster_pack\morphs\structure\StructureStatus.java
--------------------
package mchorse.blockbuster_pack.morphs.structure;

public enum StructureStatus
{
    UNLOADED, LOADING, LOADED;
}

==================================================

--- Файл №538 ---
Путь: main\java\mchorse\blockbuster_pack\trackers\ApertureCamera.java
--------------------
package mchorse.blockbuster_pack.trackers;

import javax.vecmath.Matrix4f;
import javax.vecmath.SingularMatrixException;
import javax.vecmath.Vector3f;

import org.lwjgl.opengl.GL11;

import mchorse.aperture.Aperture;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.MatrixUtils.RotationOrder;
import mchorse.mclib.utils.MatrixUtils.Transformation;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.common.Optional.Method;

public class ApertureCamera extends BaseTracker
{
    private static final Matrix4f BUFFER = new Matrix4f();

    public static boolean enable = false;
    public static String tracking = "";

    public static final Vector3f pos = new Vector3f();
    public static final Vector3f rot = new Vector3f();

    public static final Vector3f offsetPos = new Vector3f();
    public static final Vector3f offsetRot = new Vector3f();

    @Override
    @Method(modid = Aperture.MOD_ID)
    public void track(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {
        if (enable && tracking != null && !tracking.isEmpty() && tracking.equals(this.name))
        {
            GL11.glPushMatrix();
            GL11.glTranslated(offsetPos.x, offsetPos.y, offsetPos.z);
            GL11.glRotatef(-offsetRot.y, 0, 1, 0);
            GL11.glRotatef(offsetRot.x, 1, 0, 0);
            GL11.glRotatef(offsetRot.z, 0, 0, 1);
            MatrixUtils.readModelView(BUFFER);
            GL11.glPopMatrix();

            enable = false;

            Transformation transform = MatrixUtils.extractTransformations(null, BUFFER);
            pos.set(transform.getTranslation3f());

            try
            {
                transform.rotation.invert();
            }
            catch (SingularMatrixException e)
            {
                return;
            }

            Vector3f rotation = transform.getRotation(RotationOrder.YXZ, 1);
            if (rotation != null)
            {
                rot.set(rotation);
                if (transform.getScale(1).y < 0)
                {
                    rot.z += 180;
                }
                else
                {
                    rot.x *= -1;
                    rot.z *= -1;
                }
            }
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        return obj instanceof ApertureCamera && super.equals(obj);
    }
}


==================================================

--- Файл №539 ---
Путь: main\java\mchorse\blockbuster_pack\trackers\BaseTracker.java
--------------------
package mchorse.blockbuster_pack.trackers;

import java.util.Objects;

import mchorse.mclib.network.INBTSerializable;
import mchorse.metamorph.api.morphs.AbstractMorph;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;

public abstract class BaseTracker implements INBTSerializable
{
    public String name = "";

    public BaseTracker()
    {
        this.init();
    }

    public void init()
    {}

    public void track(EntityLivingBase entity, double x, double y, double z, float entityYaw, float partialTicks)
    {}

    public BaseTracker copy()
    {
        BaseTracker tracker = null;

        try
        {
            tracker = this.getClass().newInstance();
            tracker.copy(this);
        }
        catch (InstantiationException | IllegalAccessException e)
        {
            e.printStackTrace();
        }

        return tracker;
    }

    public void copy(BaseTracker tracker)
    {
        if (tracker != null)
        {
            this.name = tracker.name;
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof BaseTracker)
        {
            return Objects.equals(this.name, ((BaseTracker) obj).name);
        }

        return super.equals(obj);
    }

    public boolean canMerge(BaseTracker morph)
    {
        if (morph != null)
        {
            return this.name.equals(morph.name);
        }

        return false;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        this.name = tag.getString("Name");
    }

    @Override
    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        tag.setString("Name", this.name);

        return tag;
    }
}


==================================================

--- Файл №540 ---
Путь: main\java\mchorse\blockbuster_pack\trackers\MorphTracker.java
--------------------
package mchorse.blockbuster_pack.trackers;

import info.ata4.minecraft.minema.Minema;
import info.ata4.minecraft.minema.MinemaAPI;
import mchorse.aperture.Aperture;
import mchorse.aperture.camera.CameraExporter;
import mchorse.aperture.client.gui.GuiMinemaPanel;
import mchorse.mclib.utils.ReflectionUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.common.Optional;

public class MorphTracker extends BaseTracker
{
    private CameraExporter.TrackingPacket trackingPacket = null;
    /* for aperture tracking */
    private boolean combineTracking;
    private ApertureTracker apertureTracker;
    private MinemaTracker minemaTracker;

    public void setCombineTracking(boolean combineTracking)
    {
        this.combineTracking = combineTracking;
    }

    public boolean getCombineTracking()
    {
        return this.combineTracking;
    }

    @Override
    public void init()
    {
        if (Loader.isModLoaded(Minema.MODID)) {
            this.minemaTracker = new MinemaTracker();
        }

        if (Loader.isModLoaded(Aperture.MOD_ID)) {
            this.apertureTracker = new ApertureTracker();
        }
    }

    @Override
    public void track(EntityLivingBase target, double x, double y, double z, float entityYaw, float partialTicks)
    {
        /* minema tracking */
        if (this.minemaTracker != null) this.minemaTracker.track(this);

        /* aperture tracking */
        if (this.trackingPacket != null && this.trackingPacket.isReset())
        {
            this.trackingPacket = null;

            return;
        }

        if(this.apertureTracker != null && !ReflectionUtils.isOptifineShadowPass() && !this.name.equals(""))
        {
            this.apertureTracker.track(this);
        }
    }

    @Override
    public boolean canMerge(BaseTracker tracker)
    {
        if (tracker instanceof MorphTracker)
        {
            MorphTracker apTracker = (MorphTracker) tracker;
            this.combineTracking = apTracker.combineTracking;

            return super.canMerge(tracker);
        }

        return false;
    }

    @Override
    public void copy(BaseTracker tracker)
    {
        if (tracker instanceof MorphTracker)
        {
            MorphTracker trackerAperture = (MorphTracker) tracker;

            this.combineTracking = trackerAperture.combineTracking;
        }

        super.copy(tracker);
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = false;

        if (obj instanceof MorphTracker)
        {
            MorphTracker morph = (MorphTracker) obj;

            result = super.equals(obj) && this.combineTracking == morph.combineTracking;
        }

        return result;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        this.combineTracking = tag.getBoolean("CombineTracking");
    }

    @Override
    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        tag.setBoolean("CombineTracking", this.combineTracking);

        return tag;
    }

    private static class Tracker {
        public void track(MorphTracker tracker) {}
    }

    private static class MinemaTracker extends Tracker
    {
        @Override
        @Optional.Method(modid = Minema.MODID)
        public void track(MorphTracker tracker)
        {
            MinemaAPI.doTrack(tracker.name);
        }
    }

    private static class ApertureTracker extends Tracker
    {
        @Override
        @Optional.Method(modid = Aperture.MOD_ID)
        public void track(MorphTracker tracker)
        {
            if (GuiMinemaPanel.trackingExporter.isTracking())
            {
                if (tracker.trackingPacket == null)
                {
                    CameraExporter.TrackingPacket packet = new CameraExporter.TrackingPacket(tracker.name, tracker.combineTracking);

                    if (GuiMinemaPanel.trackingExporter.addTracker(packet))
                    {
                        tracker.trackingPacket = packet;
                    }
                }

                GuiMinemaPanel.trackingExporter.track(tracker.trackingPacket);
            }
        }
    }
}


==================================================

--- Файл №541 ---
Путь: main\java\mchorse\blockbuster_pack\trackers\TrackerRegistry.java
--------------------
package mchorse.blockbuster_pack.trackers;

import java.util.LinkedHashMap;
import java.util.Map;

import mchorse.blockbuster_pack.client.gui.trackers.GuiBaseTracker;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Tracker Registry
 */
public class TrackerRegistry
{
    public static final Map<String, Class<? extends BaseTracker>> ID_TO_CLASS = new LinkedHashMap<String, Class<? extends BaseTracker>>();

    public static final Map<Class<? extends BaseTracker>, String> CLASS_TO_ID = new LinkedHashMap<Class<? extends BaseTracker>, String>();

    @SideOnly(Side.CLIENT)
    public static Map<Class<? extends BaseTracker>, GuiBaseTracker<? extends BaseTracker>> CLIENT;

    public static void registerTracker(String id, Class<? extends BaseTracker> clazz)
    {
        ID_TO_CLASS.put(id, clazz);
        CLASS_TO_ID.put(clazz, id);
    }
}


==================================================

--- Файл №542 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelBat.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

public class ModelBat extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer right_wing;
    public ModelCustomRenderer right_wing_2;

    public ModelCustomRenderer left_wing;
    public ModelCustomRenderer left_wing_2;

    public ModelBat(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {}

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        GlStateManager.translate(0.0F, -0.4F - MathHelper.cos(ageInTicks * 0.3F) * 0.1F, 0.0F);

        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        this.right_wing.rotateAngleY = MathHelper.cos(ageInTicks * 1.3F) * (float) Math.PI * 0.25F * (0.5F + limbSwingAmount);
        this.left_wing.rotateAngleY = -this.right_wing.rotateAngleY;
        this.right_wing_2.rotateAngleY = this.right_wing.rotateAngleY * 0.5F;
        this.left_wing_2.rotateAngleY = -this.right_wing.rotateAngleY * 0.5F;
    }
}

==================================================

--- Файл №543 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelBlaze.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Blaze model
 * 
 * This class is responsible for animating blaze, but specifically blaze's 
 * sticks (floating sticks).
 * 
 * This class has a total copy of blaze sticks animation.
 */
public class ModelBlaze extends ModelCustom implements IModelCustom
{
    /* These fields are going to be injected via reflection */
    public ModelCustomRenderer top_front;
    public ModelCustomRenderer top_back;
    public ModelCustomRenderer top_left;
    public ModelCustomRenderer top_right;

    public ModelCustomRenderer middle_front_left;
    public ModelCustomRenderer middle_front_right;
    public ModelCustomRenderer middle_back_left;
    public ModelCustomRenderer middle_back_right;

    public ModelCustomRenderer bottom_front_left;
    public ModelCustomRenderer bottom_front_right;
    public ModelCustomRenderer bottom_back_left;
    public ModelCustomRenderer bottom_back_right;

    /* This field is going to be constructed in onGenerated */
    public ModelCustomRenderer[] blaze_sticks;

    public ModelBlaze(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {
        this.blaze_sticks = new ModelCustomRenderer[] {top_right, top_front, top_back, top_left, middle_front_left, middle_front_right, middle_back_left, middle_back_right, bottom_front_left, bottom_front_right, bottom_back_left, bottom_back_right};
    }

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        float f = ageInTicks * (float) Math.PI * -0.1F;

        for (int i = 0; i < 4; ++i)
        {
            this.blaze_sticks[i].rotationPointY = -2.0F + MathHelper.cos(((float) (i * 2) + ageInTicks) * 0.25F);
            this.blaze_sticks[i].rotationPointX = MathHelper.cos(f) * 9.0F;
            this.blaze_sticks[i].rotationPointZ = MathHelper.sin(f) * 9.0F;
            ++f;
        }

        f = ((float) Math.PI / 4F) + ageInTicks * (float) Math.PI * 0.03F;

        for (int j = 4; j < 8; ++j)
        {
            this.blaze_sticks[j].rotationPointY = 2.0F + MathHelper.cos(((float) (j * 2) + ageInTicks) * 0.25F);
            this.blaze_sticks[j].rotationPointX = MathHelper.cos(f) * 7.0F;
            this.blaze_sticks[j].rotationPointZ = MathHelper.sin(f) * 7.0F;
            ++f;
        }

        f = 0.47123894F + ageInTicks * (float) Math.PI * -0.05F;

        for (int k = 8; k < 12; ++k)
        {
            this.blaze_sticks[k].rotationPointY = 11.0F + MathHelper.cos(((float) k * 1.5F + ageInTicks) * 0.5F);
            this.blaze_sticks[k].rotationPointX = MathHelper.cos(f) * 5.0F;
            this.blaze_sticks[k].rotationPointZ = MathHelper.sin(f) * 5.0F;
            ++f;
        }
    }
}

==================================================

--- Файл №544 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelChicken.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Model chicken class
 * 
 * Just adds wing flapping animation to this model.
 */
public class ModelChicken extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer left_arm;
    public ModelCustomRenderer right_arm;

    public ModelChicken(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {}

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        if (!entityIn.onGround || Math.abs(entityIn.motionY) > 0.1)
        {
            float flap = MathHelper.sin(ageInTicks) + 1.0F;

            this.right_arm.rotateAngleZ = flap;
            this.left_arm.rotateAngleZ = -flap;
        }
    }
}

==================================================

--- Файл №545 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelExtended.java
--------------------
package mchorse.metamorph.client.model.custom;

import java.util.ArrayList;
import java.util.List;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Extended model
 * 
 * This extended model implements two additional limb animations. Wheels 
 * and wings. 
 * 
 * If a model specifies this class as this model, then by having 
 * "wheel_" or "wing_", then those limbs will have additional wheel or 
 * wing animation. 
 * 
 * You can also have wing wheel, but I don't know how convenient it is.
 */
public class ModelExtended extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer[] wheels;
    public ModelCustomRenderer[] wings;

    public ModelExtended(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {
        List<ModelCustomRenderer> wheels = new ArrayList<ModelCustomRenderer>();
        List<ModelCustomRenderer> wings = new ArrayList<ModelCustomRenderer>();

        for (ModelCustomRenderer limb : this.limbs)
        {
            String name = limb.limb.name;

            if (name.contains("wheel_")) wheels.add(limb);
            if (name.contains("wing_")) wings.add(limb);
        }

        this.wheels = wheels.toArray(new ModelCustomRenderer[wheels.size()]);
        this.wings = wings.toArray(new ModelCustomRenderer[wings.size()]);
    }

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        for (ModelCustomRenderer wheel : this.wheels)
        {
            wheel.rotateAngleX += limbSwing;

            if (wheel.limb.name.contains("frontal"))
            {
                wheel.rotateAngleY = netHeadYaw / 180 * (float) Math.PI;
            }
        }

        for (ModelCustomRenderer wing : this.wings)
        {
            wing.rotateAngleY = MathHelper.cos(ageInTicks * 1.3F) * (float) Math.PI * 0.25F * (0.5F + limbSwingAmount) * (wing.limb.invert || wing.limb.mirror ? -1 : 1);
        }
    }
}

==================================================

--- Файл №546 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelGhast.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Model ghast class
 * 
 * This class is mainly responsible for making ghast animate like vanilla 
 * ghast. Of course, some of the code is taken from {@link ModelGhast}.
 */
public class ModelGhast extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer left_arm;
    public ModelCustomRenderer right_arm;
    public ModelCustomRenderer arm_1;
    public ModelCustomRenderer arm_2;
    public ModelCustomRenderer arm_3;
    public ModelCustomRenderer arm_4;
    public ModelCustomRenderer arm_5;
    public ModelCustomRenderer arm_6;
    public ModelCustomRenderer arm_7;

    public ModelCustomRenderer[] tentacles;

    public ModelGhast(Model model)
    {
        super(model);
    }

    /**
     * Finally this method is used! 
     */
    @Override
    public void onGenerated()
    {
        this.tentacles = new ModelCustomRenderer[] {left_arm, right_arm, arm_1, arm_2, arm_3, arm_4, arm_5, arm_6, arm_7};
    }

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        for (ModelCustomRenderer limb : this.limbs)
        {
            this.applyLimbPose(limb);
        }

        for (int i = 0; i < this.tentacles.length; ++i)
        {
            this.tentacles[i].rotateAngleX = 0.2F * MathHelper.sin(ageInTicks * 0.3F + (float) i) + 0.4F;
        }
    }

    public void render(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        this.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale, entityIn);

        GlStateManager.pushMatrix();
        GlStateManager.translate(0.0F, 0.6F, 0.0F);

        super.render(entityIn, limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scale);

        GlStateManager.popMatrix();
    }
}

==================================================

--- Файл №547 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelGuardian.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Guardian model
 * 
 * This class is responsible for making eye and tail animations
 */
public class ModelGuardian extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer eye;

    public ModelCustomRenderer tail_1;
    public ModelCustomRenderer tail_2;
    public ModelCustomRenderer tail_3;
    public ModelCustomRenderer tail_end;

    public ModelGuardian(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {}

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        /* Make eye look up and down */
        eye.rotationPointY += headPitch / 90;

        limbSwingAmount += 0.1;

        /* Make tail look cool */
        this.tail_1.rotateAngleY = limbSwingAmount * MathHelper.sin(ageInTicks / 2) * (float) Math.PI * 0.1F;
        this.tail_2.rotateAngleY = limbSwingAmount * MathHelper.sin(ageInTicks / 2) * (float) Math.PI * 0.075F;
        this.tail_3.rotateAngleY = limbSwingAmount * MathHelper.sin(ageInTicks / 2) * (float) Math.PI * 0.05F;
    }
}

==================================================

--- Файл №548 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelIronGolem.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.entity.Entity;

public class ModelIronGolem extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer left_arm;
    public ModelCustomRenderer right_arm;

    public ModelIronGolem(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {}

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        float i = this.swingProgress;

        if (i != 0)
        {
            this.right_arm.rotateAngleX = -2.0F + 1.2F * this.triangleWave(i, 1.0F);
            this.left_arm.rotateAngleX = -2.0F + 1.2F * this.triangleWave(i, 1.0F);
        }
    }

    private float triangleWave(float input, float magnitude)
    {
        return (Math.abs(input % magnitude - magnitude * 0.5F) - magnitude * 0.25F) / (magnitude * 0.25F);
    }
}

==================================================

--- Файл №549 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelSilverfish.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Model silverfish
 * 
 * Makes silverfish model make wobble-wobble... Just kidding, it makes it 
 * move like real silverfish model.
 */
public class ModelSilverfish extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer head;
    public ModelCustomRenderer wing_1;
    public ModelCustomRenderer wing_2;
    public ModelCustomRenderer wing_3;
    public ModelCustomRenderer wing_4;
    public ModelCustomRenderer wing_5;
    public ModelCustomRenderer tail_end;

    public ModelCustomRenderer spike_1;
    public ModelCustomRenderer spike_2;
    public ModelCustomRenderer spike_3;

    public ModelCustomRenderer[] spikes;
    public ModelCustomRenderer[] wings;

    public ModelSilverfish(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {
        this.spikes = new ModelCustomRenderer[] {spike_1, spike_2, spike_3};
        this.wings = new ModelCustomRenderer[] {head, wing_1, wing_2, wing_3, wing_4, wing_5, tail_end};
    }

    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        for (int i = 0; i < this.wings.length; ++i)
        {
            this.wings[i].rotateAngleY = MathHelper.cos(ageInTicks * 0.9F + (float) i * 0.15F * (float) Math.PI) * (float) Math.PI * 0.05F * (float) (1 + Math.abs(i - 2));
            this.wings[i].rotationPointX = MathHelper.sin(ageInTicks * 0.9F + (float) i * 0.15F * (float) Math.PI) * (float) Math.PI * 0.2F * (float) Math.abs(i - 2);
        }

        this.spikes[0].rotateAngleY = this.wings[2].rotateAngleY;
        this.spikes[1].rotateAngleY = this.wings[4].rotateAngleY;
        this.spikes[1].rotationPointX = this.wings[4].rotationPointX;
        this.spikes[2].rotateAngleY = this.wings[1].rotateAngleY;
        this.spikes[2].rotationPointX = this.wings[1].rotationPointX;
    }
}

==================================================

--- Файл №550 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelSlime.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.entity.Entity;

public class ModelSlime extends ModelCustom implements IModelCustom
{
    public ModelCustomRenderer head;
    public ModelCustomRenderer right_eye;
    public ModelCustomRenderer left_eye;
    public ModelCustomRenderer mouth;
    public ModelCustomRenderer outer;

    public ModelSlime(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {}

    @Override
    public void render(Entity entityIn, float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scale)
    {
        GlStateManager.pushMatrix();
        GlStateManager.translate(0, -1, 0);
        this.head.render(scale);

        if (!this.model.name.equals("Slime"))
        {
            GlStateManager.color(1.0F, 1.0F, 1.0F, 0.8F);
        }

        GlStateManager.enableNormalize();
        GlStateManager.enableBlend();
        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
        this.outer.render(scale);
        GlStateManager.disableBlend();
        GlStateManager.disableNormalize();
        GlStateManager.popMatrix();
    }
}

==================================================

--- Файл №551 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelSpider.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import net.minecraft.client.model.ModelRenderer;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;

/**
 * Custom spider model class
 * 
 * This class is responsible mainly for doing spider animations.
 */
public class ModelSpider extends ModelCustom implements IModelCustom
{
    public ModelRenderer left_leg_1;
    public ModelRenderer left_leg_2;
    public ModelRenderer left_leg_3;
    public ModelRenderer left_leg_4;

    public ModelRenderer right_leg_1;
    public ModelRenderer right_leg_2;
    public ModelRenderer right_leg_3;
    public ModelRenderer right_leg_4;

    public ModelSpider(Model model)
    {
        super(model);
    }

    @Override
    public void onGenerated()
    {}

    /**
     * Does the spider animation. The animation code was taken from {@link ModelSpider} 
     */
    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        super.setRotationAngles(limbSwing, limbSwingAmount, ageInTicks, netHeadYaw, headPitch, scaleFactor, entityIn);

        this.right_leg_1.rotateAngleZ = -((float) Math.PI / 4F);
        this.left_leg_1.rotateAngleZ = ((float) Math.PI / 4F);
        this.right_leg_2.rotateAngleZ = -0.58119464F;
        this.left_leg_2.rotateAngleZ = 0.58119464F;
        this.right_leg_3.rotateAngleZ = -0.58119464F;
        this.left_leg_3.rotateAngleZ = 0.58119464F;
        this.right_leg_4.rotateAngleZ = -((float) Math.PI / 4F);
        this.left_leg_4.rotateAngleZ = ((float) Math.PI / 4F);

        this.right_leg_1.rotateAngleY = ((float) Math.PI / 4F);
        this.left_leg_1.rotateAngleY = -((float) Math.PI / 4F);
        this.right_leg_2.rotateAngleY = 0.3926991F;
        this.left_leg_2.rotateAngleY = -0.3926991F;
        this.right_leg_3.rotateAngleY = -0.3926991F;
        this.left_leg_3.rotateAngleY = 0.3926991F;
        this.right_leg_4.rotateAngleY = -((float) Math.PI / 4F);
        this.left_leg_4.rotateAngleY = ((float) Math.PI / 4F);

        float f3 = -(MathHelper.cos(limbSwing * 0.6662F * 2.0F + 0.0F) * 0.4F) * limbSwingAmount;
        float f4 = -(MathHelper.cos(limbSwing * 0.6662F * 2.0F + (float) Math.PI) * 0.4F) * limbSwingAmount;
        float f5 = -(MathHelper.cos(limbSwing * 0.6662F * 2.0F + ((float) Math.PI / 2F)) * 0.4F) * limbSwingAmount;
        float f6 = -(MathHelper.cos(limbSwing * 0.6662F * 2.0F + ((float) Math.PI * 3F / 2F)) * 0.4F) * limbSwingAmount;
        float f7 = Math.abs(MathHelper.sin(limbSwing * 0.6662F + 0.0F) * 0.4F) * limbSwingAmount;
        float f8 = Math.abs(MathHelper.sin(limbSwing * 0.6662F + (float) Math.PI) * 0.4F) * limbSwingAmount;
        float f9 = Math.abs(MathHelper.sin(limbSwing * 0.6662F + ((float) Math.PI / 2F)) * 0.4F) * limbSwingAmount;
        float f10 = Math.abs(MathHelper.sin(limbSwing * 0.6662F + ((float) Math.PI * 3F / 2F)) * 0.4F) * limbSwingAmount;

        this.right_leg_1.rotateAngleY += f3;
        this.left_leg_1.rotateAngleY += -f3;
        this.right_leg_2.rotateAngleY += f4;
        this.left_leg_2.rotateAngleY += -f4;
        this.right_leg_3.rotateAngleY += f5;
        this.left_leg_3.rotateAngleY += -f5;
        this.right_leg_4.rotateAngleY += f6;
        this.left_leg_4.rotateAngleY += -f6;
        this.right_leg_1.rotateAngleZ += f7;
        this.left_leg_1.rotateAngleZ += -f7;
        this.right_leg_2.rotateAngleZ += f8;
        this.left_leg_2.rotateAngleZ += -f8;
        this.right_leg_3.rotateAngleZ += f9;
        this.left_leg_3.rotateAngleZ += -f9;
        this.right_leg_4.rotateAngleZ += f10;
        this.left_leg_4.rotateAngleZ += -f10;
    }
}

==================================================

--- Файл №552 ---
Путь: main\java\mchorse\metamorph\client\model\custom\ModelSquid.java
--------------------
package mchorse.metamorph.client.model.custom;

import mchorse.blockbuster.api.Model;
import mchorse.blockbuster.client.model.ModelCustom;
import mchorse.blockbuster.client.model.ModelCustomRenderer;
import mchorse.blockbuster.client.model.parsing.IModelCustom;
import mchorse.blockbuster.client.model.parsing.ModelParser;
import net.minecraft.entity.Entity;

/**
 * Squid's custom model, isn't it exciting, huh? 
 */
public class ModelSquid extends ModelCustom implements IModelCustom
{
    /**
     * Going to be injected by {@link ModelParser} 
     */
    public ModelCustomRenderer head;

    public ModelSquid(Model model)
    {
        super(model);
    }

    /**
     * This is empty, because this class doesn't requires some fancy 
     * configuration of the model before doing its job. 
     */
    @Override
    public void onGenerated()
    {}

    /**
     * Move those tentacles, dude... 
     */
    @Override
    public void setRotationAngles(float limbSwing, float limbSwingAmount, float ageInTicks, float netHeadYaw, float headPitch, float scaleFactor, Entity entityIn)
    {
        float pi = (float) Math.PI;
        boolean inWater = entityIn.isInWater();

        head.rotateAngleX = 0;

        for (ModelCustomRenderer limb : this.limbs)
        {
            this.applyLimbPose(limb);

            if (limb == this.head)
            {
                continue;
            }

            limb.rotateAngleX = pi / 8 + (float) Math.sin(limbSwing / (inWater ? 4 : 2)) * pi / 8;
        }

        if (inWater)
        {
            head.rotateAngleX = pi / 2 + (float) Math.sin(limbSwing / 6) * pi / 16;
        }
    }
}

==================================================

--- Файл №553 ---
Путь: main\java\mchorse\metamorph\client\model\custom\package-info.java
--------------------
package mchorse.metamorph.client.model.custom;

/**
 * Classes in this package are legacy model animation code for custom 
 * models from few first iterations of Metamorph mod.
 * 
 * There are still models on the internet which are using those classes.
 */

==================================================

--- Файл №554 ---
Путь: main\resources\mcmod.info
--------------------
[
    {
        "modid": "blockbuster",
        "name": "Blockbuster",
        "description": "The Machinima Studio",
        "version": "${version}",
        "mcversion": "${mcversion}",
        "url": "https://www.curseforge.com/minecraft/mc-mods/blockbuster",
        "updateJSON": "https://raw.githubusercontent.com/mchorse/blockbuster/1.12/version.json",
        "authorList": ["mchorse", "Chryfi", "MiaoNLI", "Evanechecssss"],
        "credits": "Minecraft Forge, Minecraft Forge forum, Ernio, NlL5, EchebKeso and his Mocap mod, Badr, Tom Soel, Vasily12345, The Minebox, AzureZhen for feature suggesting and testing! Also TheImaginationCrafter for suggesting OBJ feature, and also all members of McHorse's Pub Discord server! Also big thanks to ycwei982 for testing, adding few features and localization, Andruxioid and Olrik&Flynn for testing and localization!",
        "requiredMods": ["mclib", "metamorph"],
        "dependencies": ["mclib", "metamorph"]
    }
]

==================================================

--- Файл №555 ---
Путь: main\resources\assets\blockbuster\blockstates\dim_green.json
--------------------
{
    "forge_marker": 1,
    "variants": {
        "color": {
            "green": {
                "textures": {"all": "blockbuster:blocks/green"},
                "model": "blockbuster:green"
            },
            "blue": { 
                "textures": {"all": "blockbuster:blocks/blue"}, 
                "model": "blockbuster:green" 
            },
            "red": {
                "textures": {"all": "blockbuster:blocks/red"}, 
                "model": "blockbuster:green" 
            },
            "yellow": { 
                "textures": {"all": "blockbuster:blocks/yellow"}, 
                "model": "blockbuster:green" 
            },
            "cyan": { 
                "textures": {"all": "blockbuster:blocks/cyan"}, 
                "model": "blockbuster:green" 
            },
            "purple": { 
                "textures": {"all": "blockbuster:blocks/purple"}, 
                "model": "blockbuster:green" 
            },
            "white": { 
                "textures": {"all": "blockbuster:blocks/white"}, 
                "model": "blockbuster:green" 
            },
            "black": { 
                "textures": {"all": "blockbuster:blocks/black"}, 
                "model": "blockbuster:green"
            }
        }
    }
}

==================================================

--- Файл №556 ---
Путь: main\resources\assets\blockbuster\blockstates\director.json
--------------------
{
    "variants": {
        "hidden=false,playing=true": { "model": "blockbuster:director_play" },
        "hidden=false,playing=false": { "model": "blockbuster:director_stop" },
        "hidden=true,playing=true": { "model": "blockbuster:director_play" },
        "hidden=true,playing=false": { "model": "blockbuster:director_stop" }
    }
}

==================================================

--- Файл №557 ---
Путь: main\resources\assets\blockbuster\blockstates\green.json
--------------------
{
    "forge_marker": 1,
    "variants": {
        "color": {
            "green": {
                "textures": {"all": "blockbuster:blocks/green"},
                "model": "blockbuster:green"
            },
            "blue": { 
                "textures": {"all": "blockbuster:blocks/blue"}, 
                "model": "blockbuster:green" 
            },
            "red": {
                "textures": {"all": "blockbuster:blocks/red"}, 
                "model": "blockbuster:green" 
            },
            "yellow": { 
                "textures": {"all": "blockbuster:blocks/yellow"}, 
                "model": "blockbuster:green" 
            },
            "cyan": { 
                "textures": {"all": "blockbuster:blocks/cyan"}, 
                "model": "blockbuster:green" 
            },
            "purple": { 
                "textures": {"all": "blockbuster:blocks/purple"}, 
                "model": "blockbuster:green" 
            },
            "white": { 
                "textures": {"all": "blockbuster:blocks/white"}, 
                "model": "blockbuster:green" 
            },
            "black": { 
                "textures": {"all": "blockbuster:blocks/black"}, 
                "model": "blockbuster:green"
            }
        }
    }
}

==================================================

--- Файл №558 ---
Путь: main\resources\assets\blockbuster\blockstates\model.json
--------------------
{
    "forge_marker": 1,
    "variants": {
        "normal": { "model": "blockbuster:model" },
        "light": {
            "0": { "model": "blockbuster:model" },
            "1": { "model": "blockbuster:model" },
            "2": { "model": "blockbuster:model" },
            "3": { "model": "blockbuster:model" },
            "4": { "model": "blockbuster:model" },
            "5": { "model": "blockbuster:model" },
            "6": { "model": "blockbuster:model" },
            "7": { "model": "blockbuster:model" },
            "8": { "model": "blockbuster:model" },
            "9": { "model": "blockbuster:model" },
            "10": { "model": "blockbuster:model" },
            "11": { "model": "blockbuster:model" },
            "12": { "model": "blockbuster:model" },
            "13": { "model": "blockbuster:model" },
            "14": { "model": "blockbuster:model" },
            "15": { "model": "blockbuster:model" }
        }
    }
}

==================================================

--- Файл №559 ---
Путь: main\resources\assets\blockbuster\blockstates\model_static.json
--------------------
{
    "variants": {
        "normal": { "model": "blockbuster:model_static" }
    }
}

==================================================

--- Файл №560 ---
Путь: main\resources\assets\blockbuster\models\user.json
--------------------
{}

==================================================

--- Файл №561 ---
Путь: main\resources\assets\blockbuster\models\block\director_empty.json
--------------------
{
    "parent": "builtin/entity"
}

==================================================

--- Файл №562 ---
Путь: main\resources\assets\blockbuster\models\block\director_play.json
--------------------
{
    "parent": "block/cube",
    "textures": {
        "particle": "blockbuster:blocks/director_block_side",
        "down": "blockbuster:blocks/director_block_blank",
        "up": "blockbuster:blocks/director_block_blank",
        "north": "blockbuster:blocks/director_block_side",
        "east": "blockbuster:blocks/director_block_current_start",
        "south": "blockbuster:blocks/director_block_side",
        "west": "blockbuster:blocks/director_block_stop"
    }
}

==================================================

--- Файл №563 ---
Путь: main\resources\assets\blockbuster\models\block\director_stop.json
--------------------
{
    "parent": "block/cube",
    "textures": {
        "particle": "blockbuster:blocks/director_block_side",
        "down": "blockbuster:blocks/director_block_blank",
        "up": "blockbuster:blocks/director_block_blank",
        "north": "blockbuster:blocks/director_block_side",
        "east": "blockbuster:blocks/director_block_start",
        "south": "blockbuster:blocks/director_block_side",
        "west": "blockbuster:blocks/director_block_current_stop"
    }
}

==================================================

--- Файл №564 ---
Путь: main\resources\assets\blockbuster\models\block\green.json
--------------------
{
    "parent": "block/cube_all",
    "textures": {
    	"all": "blockbuster:blocks/green"
    },
    "elements": [
        {
            "from": [ 0, 0, 0 ],
            "to": [ 16, 16, 16 ],
            "shade": false,
            "faces": {
                "down":  { "texture": "#all", "cullface": "down" },
                "up":    { "texture": "#all", "cullface": "up" },
                "north": { "texture": "#all", "cullface": "north" },
                "south": { "texture": "#all", "cullface": "south" },
                "west":  { "texture": "#all", "cullface": "west" },
                "east":  { "texture": "#all", "cullface": "east" }
            }
        }
    ]
}

==================================================

--- Файл №565 ---
Путь: main\resources\assets\blockbuster\models\block\model.json
--------------------
{
    "parent": "builtin/entity",
    "display": {
        "head": {
            "rotation": [ 0, -180, 0 ],
            "translation": [ 0, 6.376, 0],
            "scale":[ 1.6, 1.6, 1.6 ]
        }
    }
}

==================================================

--- Файл №566 ---
Путь: main\resources\assets\blockbuster\models\block\model_static.json
--------------------
{
    "parent": "block/cube",
    "textures": {
        "particle": "blockbuster:blocks/model_side",
        "down": "blockbuster:blocks/director_block_blank",
        "up": "blockbuster:blocks/director_block_blank",
        "north": "blockbuster:blocks/model_side",
        "east": "blockbuster:blocks/model_side",
        "south": "blockbuster:blocks/model_side",
        "west": "blockbuster:blocks/model_side"
    }
}

==================================================

--- Файл №567 ---
Путь: main\resources\assets\blockbuster\models\entity\alex.json
--------------------
{
    "scheme": "1.3",
    "name": "Alex",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/alex.png",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "limbs": {
        "right_arm": {
            "size": [ 3, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 16, 48 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "swinging": true
        },
        "right_armwear": {
            "size": [ 3, 12, 4 ],
            "texture": [ 40, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "right_arm"
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "left_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg"
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        },
        "bodywear": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body"
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true
        },
        "left_arm": {
            "size": [ 3, 12, 4 ],
            "texture": [ 32, 48 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "invert": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "right_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg"
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "left_armwear": {
            "size": [ 3, 12, 4 ],
            "texture": [ 48, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "left_arm"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №568 ---
Путь: main\resources\assets\blockbuster\models\entity\alex_3d.json
--------------------
{
    "scheme": "1.3",
    "name": "Alex 3D",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/alex.png",
    "skins": "alex",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "limbs": {
        "right_arm": {
            "size": [ 3, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 16, 48 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "swinging": true
        },
        "right_armwear": {
            "size": [ 3, 12, 4 ],
            "texture": [ 40, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "right_arm",
            "is3D": true
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head",
            "is3D": true
        },
        "left_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg",
            "is3D": true
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        },
        "bodywear": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body",
            "is3D": true
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true
        },
        "left_arm": {
            "size": [ 3, 12, 4 ],
            "texture": [ 32, 48 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "invert": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "right_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg",
            "is3D": true
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "left_armwear": {
            "size": [ 3, 12, 4 ],
            "texture": [ 48, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "left_arm",
            "is3D": true
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №569 ---
Путь: main\resources\assets\blockbuster\models\entity\cape.json
--------------------
{
    "scheme": "1.3",
    "name": "Cape",
    "texture": [ 64, 32 ],
    "shapes": [],
    "default": "blockbuster:textures/entity/cape.png",
    "limbs": {
        "head": {
            "size": [ 10, 16, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "cape": true
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 0.9, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 0.0, -2.0 ],
                    "rotate": [ -15.0, 180.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №570 ---
Путь: main\resources\assets\blockbuster\models\entity\empty.json
--------------------
{
    "scheme": "1.3",
    "name": "Empty",
    "texture": [ 64, 32 ],
    "skins": "",
    "materials": {},
    "default": "blockbuster:textures/entity/actor.png",
    "limbs": {
        "head": {
            "size": [ 1, 1, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "slot": "NONE",
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 0.9, 0.6 ],
            "limbs": {}
        },
        "flying": {
            "size": [ 0.6, 0.9, 0.6 ],
            "limbs": {}
        },
        "sneaking": {
            "size": [ 0.6, 0.9, 0.6 ],
            "limbs": {}
        },
        "riding": {
            "size": [ 0.6, 0.9, 0.6 ],
            "limbs": {}
        },
        "sleeping": {
            "size": [ 0.6, 0.9, 0.2 ],
            "limbs": {}
        }
    }
}

==================================================

--- Файл №571 ---
Путь: main\resources\assets\blockbuster\models\entity\fred.json
--------------------
{
    "scheme": "1.3",
    "name": "Fred",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/steve.png",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "limbs": {
        "right_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 16, 48 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "swinging": true
        },
        "right_armwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "right_arm"
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "left_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg"
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        },
        "bodywear": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body"
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true
        },
        "left_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 32, 48 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "invert": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "right_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg"
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "left_armwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 48, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "left_arm"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №572 ---
Путь: main\resources\assets\blockbuster\models\entity\fred_3d.json
--------------------
{
    "scheme": "1.3",
    "name": "Fred 3D",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/steve.png",
    "skins": "fred",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "limbs": {
        "right_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 16, 48 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "swinging": true
        },
        "right_armwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "right_arm",
            "is3D": true
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head",
            "is3D": true
        },
        "left_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg",
            "is3D": true
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        },
        "bodywear": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body",
            "is3D": true
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true
        },
        "left_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 32, 48 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "invert": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "right_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg",
            "is3D": true
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "left_armwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 48, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "left_arm",
            "is3D": true
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №573 ---
Путь: main\resources\assets\blockbuster\models\entity\steve.json
--------------------
{
    "scheme": "1.3",
    "name": "Steve",
    "texture": [ 64, 32 ],
    "default": "blockbuster:textures/entity/actor.png",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "limbs": {
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true
        },
        "right_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "mirror": true,
            "swinging": true,
            "invert": true
        },
        "left_leg_shoe": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg",
            "opacity": 0.0,
            "mirror": true,
            "invert": true
        },
        "left_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "mirror": true,
            "idle": true,
            "swinging": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "right_leg_shoe": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg",
            "opacity": 0.0,
            "invert": true
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "body_armor": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body",
            "opacity": 0.0
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №574 ---
Путь: main\resources\assets\blockbuster\models\entity\steve_3d.json
--------------------
{
    "scheme": "1.3",
    "name": "Steve 3D",
    "texture": [ 64, 32 ],
    "default": "blockbuster:textures/entity/actor.png",
    "skins": "steve",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "limbs": {
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true
        },
        "right_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "mirror": true,
            "swinging": true,
            "invert": true
        },
        "left_leg_shoe": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg",
            "opacity": 0.0,
            "mirror": true,
            "invert": true
        },
        "left_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "mirror": true,
            "idle": true,
            "swinging": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "right_leg_shoe": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg",
            "opacity": 0.0,
            "invert": true
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head",
            "is3D": true
        },
        "body_armor": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body",
            "opacity": 0.0
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №575 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.0.json
--------------------
{
    "scheme": "1.3",
    "name": "Eyes 3.0",
    "texture": [ 16, 16 ],
    "default": "blockbuster:textures/entity/eyes/steve.png",
    "limbs": {
        "eyebrow_r_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 0, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "parent": "eyebrow_r"
        },
        "eye_r": {
            "size": [ 2, 2, 1 ],
            "texture": [ 0, 3 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eye_l_pupil": {
            "size": [ 1, 2, 1 ],
            "texture": [ 6, 0 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_lt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyebrow_r": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eye_r_pupil": {
            "size": [ 1, 2, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyebrow_l_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 6, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "parent": "eyebrow_l"
        },
        "eye_l": {
            "size": [ 2, 2, 1 ],
            "texture": [ 6, 3 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_lb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_rb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_rt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyebrow_l": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        }
    },
    "poses": {
        "look_downleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_up": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sad_kawaii_one": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "thinking_flipped": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 6.25, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_right": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "angry": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.099, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.0, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "suspicious": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.1, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.1, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ]
                }
            }
        },
        "thinking": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.25, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_upright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "closed_one": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "standing": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "derp": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.991, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_upleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_downright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "no_eyebrows": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.4, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.4, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.4 ]
                }
            }
        },
        "sad": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "look_down": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "closed": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "eyeless": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sleepy": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, -3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, 3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "scared": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.79, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.789, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "sad_kawaii": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "look_left": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        }
    }
}

==================================================

--- Файл №576 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.0_1px.json
--------------------
{
    "scheme": "1.3",
    "name": "Eyes 3.0 (1px)",
    "texture": [ 16, 16 ],
    "default": "blockbuster:textures/entity/eyes/steve.png",
    "skins": "eyes3.0",
    "limbs": {
        "eyebrow_r_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 0, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "parent": "eyebrow_r"
        },
        "eye_r": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 3 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eye_l_pupil": {
            "size": [ 1, 1, 1 ],
            "texture": [ 6, 1 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_lt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyebrow_r": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eye_r_pupil": {
            "size": [ 1, 1, 1 ],
            "texture": [ 0, 1 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyebrow_l_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 6, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "parent": "eyebrow_l"
        },
        "eye_l": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 3 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_lb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_rb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyelid_rt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "eyebrow_l": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        }
    },
    "poses": {
        "look_downleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_up": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.35, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.35, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "thinking_flipped": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.2, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_right": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "angry": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.099, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.2, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.0, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.2, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "suspicious": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.2, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.9, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.9, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.2, 3.6 ]
                }
            }
        },
        "thinking": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.2, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_upright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.35, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.35, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "standing": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "derp": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.991, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_upleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.35, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.35, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_downright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "no_eyebrows": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.4, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.4, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.4 ]
                }
            }
        },
        "sad": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.3, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.3, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "look_down": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "closed": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.0, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.0, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.0, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.0, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "eyeless": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "sleepy": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.63, 3.475 ],
                    "rotate": [ 0.0, 0.0, -3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.625, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.625, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.63, 3.475 ],
                    "rotate": [ 0.0, 0.0, 3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "scared": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.4, 3.45 ],
                    "scale": [ 0.35, 0.35, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.4, 3.45 ],
                    "scale": [ 0.35, 0.35, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.79, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.789, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "sad_kawaii": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.3, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.3, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "look_left": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        }
    }
}

==================================================

--- Файл №577 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1.json
--------------------
{
    "scheme": "1.3",
    "name": "Eyes 3.1",
    "texture": [ 16, 16 ],
    "providesObj": true,
    "legacyObj": false,
    "default": "blockbuster:textures/entity/eyes/steve.png",
    "limbs": {
        "eyebrow_r_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 0, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.219, 0.281, -0.225 ],
            "parent": "eyebrow_r"
        },
        "eye_r": {
            "size": [ 2, 2, 1 ],
            "texture": [ 0, 3 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.062, 0.187, -0.206 ]
        },
        "eye_l_pupil": {
            "size": [ 1, 2, 1 ],
            "texture": [ 6, 0 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ -0.062, 0.187, -0.216 ]
        },
        "eyelid_lt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.125, 0.344, -0.217 ]
        },
        "eyebrow_r": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.125, 0.344, -0.225 ]
        },
        "eye_r_pupil": {
            "size": [ 1, 2, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.062, 0.187, -0.215625 ]
        },
        "eyebrow_l_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 6, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.219, 0.28125, -0.225 ],
            "parent": "eyebrow_l"
        },
        "eye_l": {
            "size": [ 2, 2, 1 ],
            "texture": [ 6, 3 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ -0.062, 0.187, -0.206 ]
        },
        "eyelid_lb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.125, 0.156, -0.217 ]
        },
        "eyelid_rb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.125, 0.156, -0.217 ]
        },
        "eyelid_rt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.125, 0.34375, -0.217 ]
        },
        "eyebrow_l": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.125, 0.344, -0.225 ]
        }
    },
    "poses": {
        "look_upleft_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "happy": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.5,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.045, 5.1, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.05, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.711, 3.475 ],
                    "rotate": [ 0.0, 0.0, 5.0 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.711, 3.475 ],
                    "rotate": [ 0.0, 0.0, -5.0 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.045, 5.1, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "standing_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.4, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.4, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.4 ]
                }
            }
        },
        "envious": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lt",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.695, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.531, 3.475 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.758, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.695, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.531, 3.475 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.758, 3.6 ]
                }
            }
        },
        "flushed": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": -1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 1.5,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.664, 3.712, 3.45 ],
                    "scale": [ 0.4, 0.2, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.133, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.203, 5.86, 3.6 ],
                    "rotate": [ 0.0, 0.0, 12.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.664, 3.712, 3.45 ],
                    "scale": [ 0.4, 0.2, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.914, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.914, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.133, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.203, 5.86, 3.6 ],
                    "rotate": [ 0.0, 0.0, -12.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "thinking_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.1,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 0.3,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -0.75,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.25, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.797, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.641, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.227, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_down": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_downright_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_left_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "angry": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.099, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.0, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "suspicious": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.1, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.1, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ]
                }
            }
        },
        "look_upright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "unamused_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 0.25,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -0.25,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -0.5, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.75, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.32, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.75, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -0.5, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.32, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_right_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "angry_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.25, -0.883, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.25, -0.883, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "scared": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.79, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.789, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "sad_kawaii": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "sad_kawaii_one": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "thinking_flipped": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 6.25, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "closed_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": -0.25,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -0.25,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "pensive": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": -1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -0.625, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.0, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -0.625, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.0, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "stoned": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_rt",
                    "value": -0.25,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": -0.25,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": -1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.329, 3.45 ],
                    "scale": [ 1.5, 1.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.25, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.329, 3.45 ],
                    "scale": [ 1.5, 1.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.6, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.6, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.25, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ]
                }
            }
        },
        "thinking": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.25, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "closed_one": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "smirk": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 0.25,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": 0.25,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.87575, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.65, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.1875, 5.806, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.87575, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.65, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.1875, 5.119, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ]
                }
            }
        },
        "derp": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.991, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "unamused": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -0.5, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.75, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.32, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.75, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -0.5, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.32, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_upleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sleepy_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lt",
                    "value": -0.55,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": -0.55,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, -3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.664, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.664, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, 3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_downright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sad": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "eyeless": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sleepy": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, -3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, 3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_downleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_up": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_down_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_upright_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_right": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sad_up": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": -2.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -2.0,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.15,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.15,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.25, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.25, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 1.891, 2.68, 3.475 ],
                    "rotate": [ 0.0, 0.0, -10.0 ]
                },
                "eyelid_rb": {
                    "translate": [ -1.891, 2.68, 3.475 ],
                    "rotate": [ 0.0, 0.0, 10.0 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "suspicious_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lb",
                    "value": 0.9,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 0.9,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.1, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.1, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ]
                }
            }
        },
        "shocked": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_r",
                    "value": -2.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 2.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.25,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -0.75,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 0.75,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": -0.75,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.899, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.157, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.094, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.0, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.141, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.564, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "standing": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "scared_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lb",
                    "value": 1.1,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.1,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": -0.2,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -0.2,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.79, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.789, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "closed_cute": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 0.75,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 0.75,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.352, 3.6 ],
                    "rotate": [ 0.0, 0.0, -3.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.352, 3.6 ],
                    "rotate": [ 0.0, 0.0, 3.0 ]
                }
            }
        },
        "closed": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "interested": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.25, 3.45 ],
                    "scale": [ 0.8, 0.75, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.844, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.25, 3.45 ],
                    "scale": [ 0.8, 0.75, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.844, 3.6 ]
                }
            }
        },
        "look_up_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_downleft_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_left": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        }
    }
}

==================================================

--- Файл №578 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple.json
--------------------
{
    "scheme": "1.3",
    "name": "Eyes 3.1 (Simple)",
    "texture": [ 16, 16 ],
    "providesObj": true,
    "legacyObj": false,
    "default": "blockbuster:textures/entity/eyes/steve.png",
    "limbs": {
        "eyebrow_r_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 0, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.219, 0.281, -0.225 ],
            "parent": "eyebrow_r"
        },
        "eye_r": {
            "size": [ 2, 2, 1 ],
            "texture": [ 0, 3 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.062, 0.187, -0.206 ]
        },
        "eye_l_pupil": {
            "size": [ 1, 2, 1 ],
            "texture": [ 6, 0 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ -0.062, 0.187, -0.216 ]
        },
        "eyelid_lt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.125, 0.344, -0.217 ]
        },
        "eyebrow_r": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.125, 0.344, -0.225 ]
        },
        "eye_r_pupil": {
            "size": [ 1, 2, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.0, 1.0, 0.5 ],
            "origin": [ 0.062, 0.187, -0.215625 ]
        },
        "eyebrow_l_2": {
            "size": [ 1, 1, 1 ],
            "texture": [ 6, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.219, 0.28125, -0.225 ],
            "parent": "eyebrow_l"
        },
        "eye_l": {
            "size": [ 2, 2, 1 ],
            "texture": [ 6, 3 ],
            "anchor": [ 1.0, 1.0, 0.5 ],
            "origin": [ -0.062, 0.187, -0.206 ]
        },
        "eyelid_lb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.125, 0.156, -0.217 ]
        },
        "eyelid_rb": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 12 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.125, 0.156, -0.217 ]
        },
        "eyelid_rt": {
            "size": [ 2, 1, 1 ],
            "texture": [ 0, 10 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.125, 0.34375, -0.217 ]
        },
        "eyebrow_l": {
            "size": [ 2, 1, 1 ],
            "texture": [ 6, 6 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ -0.125, 0.344, -0.225 ]
        }
    },
    "poses": {
        "look_upleft_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "happy": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.5,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.045, 5.1, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.05, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.711, 3.475 ],
                    "rotate": [ 0.0, 0.0, 5.0 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.711, 3.475 ],
                    "rotate": [ 0.0, 0.0, -5.0 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.045, 5.1, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "standing_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.4, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.4, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.4 ]
                }
            }
        },
        "envious": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lt",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.695, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.531, 3.475 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.758, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.695, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.531, 3.475 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.758, 3.6 ]
                }
            }
        },
        "flushed": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": -1.5,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 1.5,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.664, 3.712, 3.45 ],
                    "scale": [ 0.4, 0.2, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.133, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.203, 5.86, 3.6 ],
                    "rotate": [ 0.0, 0.0, 12.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.664, 3.712, 3.45 ],
                    "scale": [ 0.4, 0.2, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.914, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.914, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.133, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.203, 5.86, 3.6 ],
                    "rotate": [ 0.0, 0.0, -12.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "thinking_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 1.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.1,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 0.3,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -0.75,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.25, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.797, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.641, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.227, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_down": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_downright_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_left_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "angry": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.099, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.0, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "suspicious": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.1, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.1, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ]
                }
            }
        },
        "look_upright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "unamused_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 0.25,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -0.25,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -0.5, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.75, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.32, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.75, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -0.5, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.32, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_right_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "angry_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.25, -0.883, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.25, -0.883, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "scared": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.79, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.789, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "sad_kawaii": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "sad_kawaii_one": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.75, 1.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.75, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "thinking_flipped": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 6.25, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "closed_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": -0.25,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -0.25,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "pensive": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": -1.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -0.625, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.0, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -0.625, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.0, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "stoned": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_rt",
                    "value": -0.25,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": -0.25,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": -1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -1.0,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.329, 3.45 ],
                    "scale": [ 1.5, 1.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.25, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.329, 3.45 ],
                    "scale": [ 1.5, 1.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.6, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.6, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.25, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ]
                }
            }
        },
        "thinking": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.25, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "closed_one": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "smirk": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 0.25,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": 0.25,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.87575, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.65, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.1875, 5.806, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.87575, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.65, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.1875, 5.119, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ]
                }
            }
        },
        "derp": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.991, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "unamused": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -0.5, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.75, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.32, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.75, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -0.5, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.32, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.5, 3.6 ]
                }
            }
        },
        "look_upleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sleepy_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lt",
                    "value": -0.55,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": -0.55,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, -3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.664, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.664, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, 3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_downright": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sad": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "eyeless": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.8 ],
                    "scale": [ 0.0, 0.0, 0.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sleepy": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, -3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, 5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.7, 3.475 ],
                    "rotate": [ 0.0, 0.0, 3.0 ],
                    "scale": [ 1.05, 2.0, 1.0 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ],
                    "rotate": [ 0.0, 0.0, -5.0 ],
                    "scale": [ 1.1, 1.0, 1.0 ]
                }
            }
        },
        "look_downleft": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_up": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "look_down_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_upright_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_right": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -1.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "sad_up": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": -2.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -2.0,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": 1.15,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.15,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.25, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.25, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 1.891, 2.68, 3.475 ],
                    "rotate": [ 0.0, 0.0, -10.0 ]
                },
                "eyelid_rb": {
                    "translate": [ -1.891, 2.68, 3.475 ],
                    "rotate": [ 0.0, 0.0, 10.0 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -10.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "suspicious_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lb",
                    "value": 0.9,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 0.9,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 4.7, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.1, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.1, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 4.7, 3.6 ]
                }
            }
        },
        "shocked": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_r",
                    "value": -2.0,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": 2.0,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.25,
                    "relative": true
                },
                {
                    "name": "eyelid_lb",
                    "value": -0.75,
                    "relative": true
                },
                {
                    "name": "eyelid_rt",
                    "value": 0.75,
                    "relative": true
                },
                {
                    "name": "eyelid_lt",
                    "value": -0.75,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.899, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 6.157, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.094, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.0, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.141, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.564, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "standing": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        },
        "scared_curved": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyelid_lb",
                    "value": 1.1,
                    "relative": true
                },
                {
                    "name": "eyelid_rb",
                    "value": 1.1,
                    "relative": true
                },
                {
                    "name": "eyebrow_l",
                    "value": -0.2,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": -0.2,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, 7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.999, 3.5, 3.45 ],
                    "scale": [ 0.5, 0.5, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.79, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.789, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.0, 3.6 ],
                    "rotate": [ 0.0, 0.0, -7.0 ],
                    "scale": [ 1.2, 1.0, 1.0 ]
                }
            }
        },
        "closed_cute": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 0.75,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 0.75,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.352, 3.6 ],
                    "rotate": [ 0.0, 0.0, -3.0 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.352, 3.6 ],
                    "rotate": [ 0.0, 0.0, 3.0 ]
                }
            }
        },
        "closed": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, 1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 4.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 3.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ],
                    "scale": [ 1.0, 0.0, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, 1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 3.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 3.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 4.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 3.5, 3.6 ]
                }
            }
        },
        "interested": {
            "size": [ 0.5, 0.5, 0.6 ],
            "shapes": [
                {
                    "name": "eyebrow_l",
                    "value": 0.5,
                    "relative": true
                },
                {
                    "name": "eyebrow_r",
                    "value": 0.5,
                    "relative": true
                } ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 3.25, 3.45 ],
                    "scale": [ 0.8, 0.75, 1.0 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.844, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.25, 3.45 ],
                    "scale": [ 0.8, 0.75, 1.0 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.844, 3.6 ]
                }
            }
        },
        "look_up_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 0.99, 4.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 4.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_downleft_ne": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 2.5, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.401 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 2.5, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.401 ]
                }
            }
        },
        "look_left": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "eyebrow_r_2": {
                    "translate": [ -1.499, -1.0, 0.0 ]
                },
                "eye_r": {
                    "translate": [ -1.0, 3.0, 3.301 ]
                },
                "eye_l_pupil": {
                    "translate": [ 1.99, 3.0, 3.45 ]
                },
                "eyelid_lt": {
                    "translate": [ 2.0, 5.5, 3.475 ]
                },
                "eyebrow_r": {
                    "translate": [ -2.0, 5.5, 3.6 ]
                },
                "eye_r_pupil": {
                    "translate": [ -0.99, 3.0, 3.45 ]
                },
                "eyebrow_l_2": {
                    "translate": [ 1.499, -1.0, 0.0 ]
                },
                "eye_l": {
                    "translate": [ 1.0, 3.0, 3.301 ]
                },
                "eyelid_lb": {
                    "translate": [ 2.0, 2.5, 3.475 ]
                },
                "eyelid_rb": {
                    "translate": [ -2.0, 2.5, 3.475 ]
                },
                "eyelid_rt": {
                    "translate": [ -2.0, 5.5, 3.475 ]
                },
                "eyebrow_l": {
                    "translate": [ 2.0, 5.5, 3.6 ]
                }
            }
        }
    }
}

==================================================

--- Файл №579 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\alex.json
--------------------
{
    "scheme": "1.3",
    "name": "Alex (eyes)",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/alex.png",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "skins": "alex",
    "presets": {
        "Alex (2px eyes)": "{Skin:[{Path:\"minecraft:textures/entity/alex.png\"},{Path:\"blockbuster:textures/entity/eye_masks/2px.png\",Erase:1b}]}",
        "Alex (1px eyes)": "{Skin:[{Path:\"minecraft:textures/entity/alex.png\"},{Path:\"blockbuster:textures/entity/eye_masks/1px.png\",Erase:1b}]}"
    },
    "limbs": {
        "right_arm": {
            "size": [ 3, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 16, 48 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "swinging": true
        },
        "right_armwear": {
            "size": [ 3, 12, 4 ],
            "texture": [ 40, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "right_arm"
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "left_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg"
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        },
        "bodywear": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body"
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true,
            "is3D": true
        },
        "left_arm": {
            "size": [ 3, 12, 4 ],
            "texture": [ 32, 48 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "invert": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "right_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg"
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "left_armwear": {
            "size": [ 3, 12, 4 ],
            "texture": [ 48, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "left_arm"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -5.5, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 5.5, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №580 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\fred.json
--------------------
{
    "scheme": "1.3",
    "name": "Fred (eyes)",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/steve.png",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "skins": "fred",
    "presets": {
        "Fred (2px eyes)": "{Skin:[{Path:\"minecraft:textures/entity/steve.png\"},{Path:\"blockbuster:textures/entity/eye_masks/2px.png\",Erase:1b}]}",
        "Fred (1px eyes)": "{Skin:[{Path:\"minecraft:textures/entity/steve.png\"},{Path:\"blockbuster:textures/entity/eye_masks/1px.png\",Erase:1b}]}"
    },
    "limbs": {
        "right_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 16, 48 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "swinging": true
        },
        "right_armwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "right_arm"
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "left_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg"
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        },
        "bodywear": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body"
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true,
            "is3D": true
        },
        "left_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 32, 48 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "invert": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "right_legwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 32 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg"
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "left_armwear": {
            "size": [ 4, 12, 4 ],
            "texture": [ 48, 48 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "left_arm"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "right_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "left_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "bodywear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "right_legwear": {
                    "translate": [ 0.0, -6.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "left_armwear": {
                    "translate": [ 0.0, -4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №581 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\head.json
--------------------
{
    "scheme": "1.3",
    "name": "Head (64x64)",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/steve.png",
    "skins": "fred",
    "limbs": {
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "is3D": true,
            "lookX": true,
            "lookY": true
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №582 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\head_3d.json
--------------------
{
    "scheme": "1.3",
    "name": "Head 3D (64x64)",
    "texture": [ 64, 64 ],
    "default": "minecraft:textures/entity/steve.png",
    "skins": "fred",
    "limbs": {
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head",
            "is3D": true
        },
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "is3D": true,
            "lookX": true,
            "lookY": true
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.5, 0.5, 0.6 ],
            "limbs": {
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №583 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\steve.json
--------------------
{
    "scheme": "1.3",
    "name": "Steve (eyes)",
    "texture": [ 64, 32 ],
    "default": "blockbuster:textures/entity/actor.png",
    "scale": [ 0.9375, 0.9375, 0.9375 ],
    "skins": "steve",
    "presets": {
        "Steve (2px eyes)": "{Skin:[{Path:\"blockbuster:textures/entity/actor.png\"},{Path:\"blockbuster:textures/entity/eye_masks/2px.png\",SizeH:32,Erase:1b,AutoSize:0b}]}",
        "Steve (1px eyes)": "{Skin:[{Path:\"blockbuster:textures/entity/actor.png\"},{Path:\"blockbuster:textures/entity/eye_masks/1px.png\",SizeH:32,Erase:1b,AutoSize:0b,ShiftY:-1}]}"
    },
    "limbs": {
        "head": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 1.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "head",
            "parent": "anchor",
            "looking": true,
            "is3D": true
        },
        "right_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "right",
            "slot": "right_shoulder",
            "parent": "body",
            "idle": true,
            "swinging": true,
            "swiping": true
        },
        "left_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "left_leg",
            "parent": "body",
            "mirror": true,
            "swinging": true,
            "invert": true
        },
        "left_leg_shoe": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "left_foot",
            "parent": "left_leg",
            "opacity": 0.0,
            "mirror": true,
            "invert": true
        },
        "left_arm": {
            "size": [ 4, 12, 4 ],
            "texture": [ 40, 16 ],
            "anchor": [ 0.5, 0.1666, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "holding": "left",
            "slot": "left_shoulder",
            "parent": "body",
            "mirror": true,
            "idle": true,
            "swinging": true
        },
        "right_leg": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "right_leg",
            "parent": "body",
            "swinging": true,
            "invert": true
        },
        "anchor": {
            "size": [ 2, 2, 2 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "opacity": 0.0
        },
        "right_leg_shoe": {
            "size": [ 4, 12, 4 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "right_foot",
            "parent": "right_leg",
            "opacity": 0.0,
            "invert": true
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 32, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "parent": "head"
        },
        "body_armor": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "sizeOffset": 0.25,
            "slot": "chest",
            "parent": "body",
            "opacity": 0.0
        },
        "body": {
            "size": [ 8, 12, 4 ],
            "texture": [ 16, 16 ],
            "anchor": [ 0.5, 0.0, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "slot": "leggings",
            "parent": "anchor"
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -45.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 3.8, 0.0 ],
                    "scale": [ 1.005, 1.0, 1.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.990999, 1.0, 1.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 1.0 ],
                    "rotate": [ -5.74, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -1.98, -9.6, 0.8 ],
                    "rotate": [ -28.64, 0.0, 0.0 ],
                    "scale": [ 0.99, 1.0, 1.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 4.8, 0.0 ],
                    "rotate": [ 28.64, 0.0, 0.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, 18.0, -4.5 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -81.0, -18.0, 4.5 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "dabbing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 50.0, 45.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -110.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -90.0, -30.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "t_pose": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, -90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ 0.0, 0.0, 90.0 ],
                    "scale": [ 1.0, 1.0, 1.01 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 16.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ 30.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ -90.0, 0.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "sitting": {
            "size": [ 0.6, 1.3, 0.6 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, 18.0, -4.5 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -36.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ],
                    "rotate": [ -90.0, -18.0, 4.5 ]
                },
                "anchor": {
                    "translate": [ 0.0, 5.75, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        },
        "lying": {
            "size": [ 0.6, 0.4, 0.2 ],
            "limbs": {
                "head": {
                    "translate": [ 0.0, 8.0, 0.0 ],
                    "rotate": [ -40.0, 0.0, 0.0 ]
                },
                "right_arm": {
                    "translate": [ -6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "left_leg": {
                    "translate": [ 2.0, -12.0, 0.0 ]
                },
                "left_arm": {
                    "translate": [ 6.0, -2.0, 0.0 ],
                    "rotate": [ -180.0, 0.0, 0.0 ]
                },
                "right_leg": {
                    "translate": [ -2.0, -12.0, 0.0 ]
                },
                "anchor": {
                    "translate": [ 0.0, 2.0, 0.0 ],
                    "rotate": [ 90.0, 0.0, 0.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ]
                },
                "body": {
                    "translate": [ 0.0, 8.0, 0.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №584 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\base.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
v -0.093750 0.375000 -0.185900
v -0.093750 0.312500 -0.185900
v -0.093750 0.312500 -0.248400
v -0.093750 0.375000 -0.248400
v -0.078125 0.375000 -0.185900
v -0.078125 0.312500 -0.185900
v -0.078125 0.312500 -0.248400
v -0.078125 0.375000 -0.248400
v -0.109375 0.375000 -0.185900
v -0.109375 0.312500 -0.185900
v -0.109375 0.312500 -0.248400
v -0.109375 0.375000 -0.248400
v -0.156250 0.375000 -0.185900
v -0.156250 0.312500 -0.185900
v -0.156250 0.312500 -0.248400
v -0.156250 0.375000 -0.248400
v -0.140625 0.375000 -0.185900
v -0.140625 0.312500 -0.185900
v -0.140625 0.312500 -0.248400
v -0.140625 0.375000 -0.248400
v -0.171875 0.375000 -0.185900
v -0.171875 0.312500 -0.185900
v -0.171875 0.312500 -0.248400
v -0.171875 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/40 59/124/40 58/125/40 78/126/40
f 77/127/39 57/128/39 60/120/39 80/119/39
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/40 63/138/40 62/139/40 70/140/40
f 69/141/39 61/142/39 64/134/39 72/133/39
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/40 67/108/40 66/111/40 62/139/40
f 61/142/39 65/105/39 68/107/39 64/134/39
f 57/128/39 69/141/39 72/133/39 60/120/39
f 59/124/40 71/137/40 70/140/40 58/125/40
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/39 73/146/39 76/147/39 84/148/39
f 83/149/40 75/150/40 74/151/40 82/152/40
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/39 77/127/39 80/119/39 76/147/39
f 75/150/40 79/123/40 78/126/40 74/151/40
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/40 83/149/40 82/152/40 52/160/40
f 49/161/39 81/145/39 84/148/39 50/100/39
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
v 0.156250 0.375000 -0.185900
v 0.156250 0.312500 -0.185900
v 0.156250 0.312500 -0.248400
v 0.156250 0.375000 -0.248400
v 0.093750 0.375000 -0.185900
v 0.093750 0.312500 -0.185900
v 0.093750 0.312500 -0.248400
v 0.093750 0.375000 -0.248400
v 0.109375 0.375000 -0.185900
v 0.109375 0.312500 -0.185900
v 0.109375 0.312500 -0.248400
v 0.109375 0.375000 -0.248400
v 0.078125 0.375000 -0.185900
v 0.078125 0.312500 -0.185900
v 0.078125 0.312500 -0.248400
v 0.078125 0.375000 -0.248400
v 0.140625 0.375000 -0.185900
v 0.140625 0.312500 -0.185900
v 0.140625 0.312500 -0.248400
v 0.140625 0.375000 -0.248400
v 0.171875 0.375000 -0.185900
v 0.171875 0.312500 -0.185900
v 0.171875 0.312500 -0.248400
v 0.171875 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 85/162/43 88/163/43 87/164/43 86/165/43
f 89/166/44 92/167/44 91/168/44 90/169/44
f 117/170/45 90/171/45 89/166/45 120/172/45
f 119/173/46 92/174/46 91/175/46 118/176/46
f 120/172/47 89/166/47 92/167/47 119/177/47
f 109/178/48 85/162/48 88/163/48 110/179/48
f 113/180/48 93/181/48 94/182/48 114/183/48
f 108/184/47 96/185/47 95/186/47 107/187/47
f 107/188/46 95/189/46 94/190/46 106/191/46
f 105/192/45 93/193/45 96/185/45 108/184/45
f 117/194/48 97/195/48 98/196/48 118/197/48
f 116/198/47 100/199/47 99/200/47 115/201/47
f 115/202/46 99/203/46 98/204/46 114/205/46
f 113/206/45 97/207/45 100/199/45 116/198/45
f 109/208/45 101/209/45 104/210/45 112/211/45
f 111/212/46 103/213/46 102/214/46 110/215/46
f 112/211/47 104/210/47 103/216/47 111/217/47
f 105/218/48 101/219/48 102/220/48 106/221/48
f 93/181/48 105/218/48 106/221/48 94/182/48
f 101/209/45 105/192/45 108/184/45 104/210/45
f 103/213/46 107/188/46 106/191/46 102/214/46
f 104/210/47 108/184/47 107/187/47 103/216/47
f 86/165/47 112/211/47 111/217/47 87/164/47
f 87/222/46 111/212/46 110/215/46 88/223/46
f 85/224/45 109/208/45 112/211/45 86/165/45
f 101/219/48 109/178/48 110/179/48 102/220/48
f 93/193/45 113/206/45 116/198/45 96/185/45
f 95/189/46 115/202/46 114/205/46 94/190/46
f 96/185/47 116/198/47 115/201/47 95/186/47
f 97/195/48 113/180/48 114/183/48 98/196/48
f 90/225/48 117/194/48 118/197/48 91/226/48
f 100/199/47 120/172/47 119/177/47 99/200/47
f 99/203/46 119/173/46 118/176/46 98/204/46
f 97/207/45 117/170/45 120/172/45 100/199/45
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
v 0.156250 0.187500 -0.185900
v 0.156250 0.125000 -0.185900
v 0.156250 0.125000 -0.248400
v 0.156250 0.187500 -0.248400
v 0.093750 0.187500 -0.185900
v 0.093750 0.125000 -0.185900
v 0.093750 0.125000 -0.248400
v 0.093750 0.187500 -0.248400
v 0.109375 0.187500 -0.185900
v 0.109375 0.125000 -0.185900
v 0.109375 0.125000 -0.248400
v 0.109375 0.187500 -0.248400
v 0.140625 0.187500 -0.185900
v 0.140625 0.125000 -0.185900
v 0.140625 0.125000 -0.248400
v 0.140625 0.187500 -0.248400
v 0.171875 0.187500 -0.185900
v 0.171875 0.125000 -0.185900
v 0.171875 0.125000 -0.248400
v 0.171875 0.187500 -0.248400
v 0.078125 0.187500 -0.185900
v 0.078125 0.125000 -0.185900
v 0.078125 0.125000 -0.248400
v 0.078125 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 121/227/49 124/228/49 123/229/49 122/230/49
f 125/231/50 128/232/50 127/233/50 126/234/50
f 149/235/51 126/236/51 125/231/51 152/237/51
f 151/238/52 128/239/52 127/240/52 150/241/52
f 152/237/53 125/231/53 128/232/53 151/242/53
f 153/243/54 121/227/54 124/228/54 154/244/54
f 145/245/54 129/246/54 130/247/54 146/248/54
f 144/249/53 132/250/53 131/251/53 143/252/53
f 143/253/52 131/254/52 130/255/52 142/256/52
f 141/257/51 129/258/51 132/250/51 144/249/51
f 149/259/54 133/260/54 134/261/54 150/262/54
f 148/263/53 136/264/53 135/265/53 147/266/53
f 147/267/52 135/268/52 134/269/52 146/270/52
f 145/271/51 133/272/51 136/264/51 148/263/51
f 153/273/51 137/274/51 140/275/51 156/276/51
f 155/277/52 139/278/52 138/279/52 154/280/52
f 156/276/53 140/275/53 139/281/53 155/282/53
f 141/283/54 137/284/54 138/285/54 142/286/54
f 129/246/54 141/283/54 142/286/54 130/247/54
f 137/274/51 141/257/51 144/249/51 140/275/51
f 139/278/52 143/253/52 142/256/52 138/279/52
f 140/275/53 144/249/53 143/252/53 139/281/53
f 129/258/51 145/271/51 148/263/51 132/250/51
f 131/254/52 147/267/52 146/270/52 130/255/52
f 132/250/53 148/263/53 147/266/53 131/251/53
f 133/260/54 145/245/54 146/248/54 134/261/54
f 126/287/54 149/259/54 150/262/54 127/288/54
f 136/264/53 152/237/53 151/242/53 135/265/53
f 135/268/52 151/238/52 150/241/52 134/269/52
f 133/272/51 149/235/51 152/237/51 136/264/51
f 122/230/53 156/276/53 155/282/53 123/229/53
f 123/289/52 155/277/52 154/280/52 124/290/52
f 121/291/51 153/273/51 156/276/51 122/230/51
f 137/284/54 153/243/54 154/244/54 138/285/54
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
v 0.156250 0.375000 -0.193700
v 0.156250 0.312500 -0.193700
v 0.156250 0.312500 -0.256200
v 0.156250 0.375000 -0.256200
v 0.093750 0.375000 -0.193700
v 0.093750 0.312500 -0.193700
v 0.093750 0.312500 -0.256200
v 0.093750 0.375000 -0.256200
v 0.140625 0.375000 -0.193700
v 0.140625 0.312500 -0.193700
v 0.140625 0.312500 -0.256200
v 0.140625 0.375000 -0.256200
v 0.171875 0.375000 -0.193700
v 0.171875 0.312500 -0.193700
v 0.171875 0.312500 -0.256200
v 0.171875 0.375000 -0.256200
v 0.109375 0.375000 -0.193700
v 0.109375 0.312500 -0.193700
v 0.109375 0.312500 -0.256200
v 0.109375 0.375000 -0.256200
v 0.078125 0.375000 -0.193700
v 0.078125 0.312500 -0.193700
v 0.078125 0.312500 -0.256200
v 0.078125 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 157/292/55 160/293/55 159/294/55 158/295/55
f 161/296/56 164/297/56 163/298/56 162/299/56
f 181/300/57 162/301/57 161/296/57 184/302/57
f 183/303/58 164/304/58 163/305/58 182/306/58
f 184/302/59 161/296/59 164/297/59 183/307/59
f 189/308/60 157/292/60 160/293/60 190/309/60
f 177/310/60 165/311/60 166/312/60 178/313/60
f 188/314/59 168/315/59 167/316/59 187/317/59
f 187/318/58 167/319/58 166/320/58 186/321/58
f 185/322/57 165/323/57 168/315/57 188/314/57
f 181/324/60 169/325/60 170/326/60 182/327/60
f 180/328/59 172/329/59 171/330/59 179/331/59
f 179/332/58 171/333/58 170/334/58 178/335/58
f 177/336/57 169/337/57 172/329/57 180/328/57
f 189/338/57 173/339/57 176/340/57 192/341/57
f 191/342/58 175/343/58 174/344/58 190/345/58
f 192/341/59 176/340/59 175/346/59 191/347/59
f 185/348/60 173/349/60 174/350/60 186/351/60
f 165/323/57 177/336/57 180/328/57 168/315/57
f 167/319/58 179/332/58 178/335/58 166/320/58
f 168/315/59 180/328/59 179/331/59 167/316/59
f 169/325/60 177/310/60 178/313/60 170/326/60
f 162/352/60 181/324/60 182/327/60 163/353/60
f 172/329/59 184/302/59 183/307/59 171/330/59
f 171/333/58 183/303/58 182/306/58 170/334/58
f 169/337/57 181/300/57 184/302/57 172/329/57
f 165/311/60 185/348/60 186/351/60 166/312/60
f 173/339/57 185/322/57 188/314/57 176/340/57
f 175/343/58 187/318/58 186/321/58 174/344/58
f 176/340/59 188/314/59 187/317/59 175/346/59
f 158/295/59 192/341/59 191/347/59 159/294/59
f 159/354/58 191/342/58 190/345/58 160/355/58
f 157/356/57 189/338/57 192/341/57 158/295/57
f 173/349/60 189/308/60 190/309/60 174/350/60
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
v -0.093750 0.187500 -0.185900
v -0.093750 0.125000 -0.185900
v -0.093750 0.125000 -0.248400
v -0.093750 0.187500 -0.248400
v -0.109375 0.187500 -0.185900
v -0.109375 0.125000 -0.185900
v -0.109375 0.125000 -0.248400
v -0.109375 0.187500 -0.248400
v -0.078125 0.187500 -0.185900
v -0.078125 0.125000 -0.185900
v -0.078125 0.125000 -0.248400
v -0.078125 0.187500 -0.248400
v -0.156250 0.187500 -0.185900
v -0.156250 0.125000 -0.185900
v -0.156250 0.125000 -0.248400
v -0.156250 0.187500 -0.248400
v -0.140625 0.187500 -0.185900
v -0.140625 0.125000 -0.185900
v -0.140625 0.125000 -0.248400
v -0.140625 0.187500 -0.248400
v -0.171875 0.187500 -0.185900
v -0.171875 0.125000 -0.185900
v -0.171875 0.125000 -0.248400
v -0.171875 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 193/357/61 196/358/61 195/359/61 194/360/61
f 197/361/62 200/362/62 199/363/62 198/364/62
f 213/365/63 198/366/63 197/361/63 216/367/63
f 215/368/64 200/369/64 199/370/64 214/371/64
f 216/367/65 197/361/65 200/362/65 215/372/65
f 225/373/66 193/357/66 196/358/66 226/374/66
f 209/375/66 201/376/66 202/377/66 210/378/66
f 224/379/65 204/380/65 203/381/65 223/382/65
f 223/383/64 203/384/64 202/385/64 222/386/64
f 221/387/63 201/388/63 204/380/63 224/379/63
f 213/389/66 205/390/66 206/391/66 214/392/66
f 212/393/65 208/394/65 207/395/65 211/396/65
f 211/397/64 207/398/64 206/399/64 210/400/64
f 209/401/63 205/402/63 208/394/63 212/393/63
f 201/388/63 209/401/63 212/393/63 204/380/63
f 203/384/64 211/397/64 210/400/64 202/385/64
f 204/380/65 212/393/65 211/396/65 203/381/65
f 205/390/66 209/375/66 210/378/66 206/391/66
f 198/403/66 213/389/66 214/392/66 199/404/66
f 208/394/65 216/367/65 215/372/65 207/395/65
f 207/398/64 215/368/64 214/371/64 206/399/64
f 205/402/63 213/365/63 216/367/63 208/394/63
f 225/405/63 217/406/63 220/407/63 228/408/63
f 227/409/64 219/410/64 218/411/64 226/412/64
f 228/408/65 220/407/65 219/413/65 227/414/65
f 221/415/66 217/416/66 218/417/66 222/418/66
f 201/376/66 221/415/66 222/418/66 202/377/66
f 217/406/63 221/387/63 224/379/63 220/407/63
f 219/410/64 223/383/64 222/386/64 218/411/64
f 220/407/65 224/379/65 223/382/65 219/413/65
f 194/360/65 228/408/65 227/414/65 195/359/65
f 195/419/64 227/409/64 226/412/64 196/420/64
f 193/421/63 225/405/63 228/408/63 194/360/63
f 217/416/66 225/373/66 226/374/66 218/417/66
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
v -0.093750 0.375000 -0.193700
v -0.093750 0.312500 -0.193700
v -0.093750 0.312500 -0.256200
v -0.093750 0.375000 -0.256200
v -0.078125 0.375000 -0.193700
v -0.078125 0.312500 -0.193700
v -0.078125 0.312500 -0.256200
v -0.078125 0.375000 -0.256200
v -0.109375 0.375000 -0.193700
v -0.109375 0.312500 -0.193700
v -0.109375 0.312500 -0.256200
v -0.109375 0.375000 -0.256200
v -0.156250 0.375000 -0.193700
v -0.156250 0.312500 -0.193700
v -0.156250 0.312500 -0.256200
v -0.156250 0.375000 -0.256200
v -0.140625 0.375000 -0.193700
v -0.140625 0.312500 -0.193700
v -0.140625 0.312500 -0.256200
v -0.140625 0.375000 -0.256200
v -0.171875 0.375000 -0.193700
v -0.171875 0.312500 -0.193700
v -0.171875 0.312500 -0.256200
v -0.171875 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 229/422/67 232/423/67 231/424/67 230/425/67
f 233/426/68 236/427/68 235/428/68 234/429/68
f 245/430/69 234/431/69 233/426/69 248/432/69
f 247/433/70 236/434/70 235/435/70 246/436/70
f 248/432/71 233/426/71 236/427/71 247/437/71
f 261/438/72 229/422/72 232/423/72 262/439/72
f 249/440/72 237/441/72 238/442/72 250/443/72
f 260/444/71 240/445/71 239/446/71 259/447/71
f 259/448/70 239/449/70 238/450/70 258/451/70
f 257/452/69 237/453/69 240/445/69 260/444/69
f 245/454/72 241/455/72 242/456/72 246/457/72
f 252/458/71 244/459/71 243/460/71 251/461/71
f 251/462/70 243/463/70 242/464/70 250/465/70
f 249/466/69 241/467/69 244/459/69 252/458/69
f 234/468/72 245/454/72 246/457/72 235/469/72
f 244/459/71 248/432/71 247/437/71 243/460/71
f 243/463/70 247/433/70 246/436/70 242/464/70
f 241/467/69 245/430/69 248/432/69 244/459/69
f 237/453/69 249/466/69 252/458/69 240/445/69
f 239/449/70 251/462/70 250/465/70 238/450/70
f 240/445/71 252/458/71 251/461/71 239/446/71
f 241/455/72 249/440/72 250/443/72 242/456/72
f 261/470/69 253/471/69 256/472/69 264/473/69
f 263/474/70 255/475/70 254/476/70 262/477/70
f 264/473/71 256/472/71 255/478/71 263/479/71
f 257/480/72 253/481/72 254/482/72 258/483/72
f 237/441/72 257/480/72 258/483/72 238/442/72
f 253/471/69 257/452/69 260/444/69 256/472/69
f 255/475/70 259/448/70 258/451/70 254/476/70
f 256/472/71 260/444/71 259/447/71 255/478/71
f 230/425/71 264/473/71 263/479/71 231/424/71
f 231/484/70 263/474/70 262/477/70 232/485/70
f 229/486/69 261/470/69 264/473/69 230/425/69
f 253/481/72 261/438/72 262/439/72 254/482/72


==================================================

--- Файл №585 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\eyebrow_l.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
v -0.093750 0.375000 -0.185900
v -0.093750 0.312500 -0.185900
v -0.093750 0.312500 -0.248400
v -0.093750 0.375000 -0.248400
v -0.078125 0.375000 -0.185900
v -0.078125 0.312500 -0.185900
v -0.078125 0.312500 -0.248400
v -0.078125 0.375000 -0.248400
v -0.109375 0.375000 -0.185900
v -0.109375 0.312500 -0.185900
v -0.109375 0.312500 -0.248400
v -0.109375 0.375000 -0.248400
v -0.156250 0.375000 -0.185900
v -0.156250 0.312500 -0.185900
v -0.156250 0.312500 -0.248400
v -0.156250 0.375000 -0.248400
v -0.140625 0.375000 -0.185900
v -0.140625 0.312500 -0.185900
v -0.140625 0.312500 -0.248400
v -0.140625 0.375000 -0.248400
v -0.171875 0.375000 -0.185900
v -0.171875 0.312500 -0.185900
v -0.171875 0.312500 -0.248400
v -0.171875 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/40 59/124/40 58/125/40 78/126/40
f 77/127/39 57/128/39 60/120/39 80/119/39
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/40 63/138/40 62/139/40 70/140/40
f 69/141/39 61/142/39 64/134/39 72/133/39
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/40 67/108/40 66/111/40 62/139/40
f 61/142/39 65/105/39 68/107/39 64/134/39
f 57/128/39 69/141/39 72/133/39 60/120/39
f 59/124/40 71/137/40 70/140/40 58/125/40
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/39 73/146/39 76/147/39 84/148/39
f 83/149/40 75/150/40 74/151/40 82/152/40
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/39 77/127/39 80/119/39 76/147/39
f 75/150/40 79/123/40 78/126/40 74/151/40
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/40 83/149/40 82/152/40 52/160/40
f 49/161/39 81/145/39 84/148/39 50/100/39
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
v 0.156250 0.375000 -0.185900
v 0.156250 0.312500 -0.185900
v 0.156250 0.312500 -0.248400
v 0.156250 0.375000 -0.248400
v 0.093750 0.375000 -0.185900
v 0.093750 0.312500 -0.185900
v 0.093750 0.312500 -0.248400
v 0.093750 0.375000 -0.248400
v 0.109375 0.375000 -0.185900
v 0.109375 0.312500 -0.185900
v 0.109375 0.312500 -0.248400
v 0.109375 0.375000 -0.248400
v 0.078125 0.375000 -0.185900
v 0.078125 0.312500 -0.185900
v 0.078125 0.312500 -0.248400
v 0.078125 0.375000 -0.248400
v 0.140625 0.375000 -0.185900
v 0.140625 0.312500 -0.185900
v 0.140625 0.312500 -0.248400
v 0.140625 0.375000 -0.248400
v 0.171875 0.375000 -0.185900
v 0.171875 0.312500 -0.185900
v 0.171875 0.312500 -0.248400
v 0.171875 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 85/162/43 88/163/43 87/164/43 86/165/43
f 89/166/44 92/167/44 91/168/44 90/169/44
f 117/170/45 90/171/45 89/166/45 120/172/45
f 119/173/46 92/174/46 91/175/46 118/176/46
f 120/172/47 89/166/47 92/167/47 119/177/47
f 109/178/48 85/162/48 88/163/48 110/179/48
f 113/180/48 93/181/48 94/182/48 114/183/48
f 108/184/47 96/185/47 95/186/47 107/187/47
f 107/188/46 95/189/46 94/190/46 106/191/46
f 105/192/45 93/193/45 96/185/45 108/184/45
f 117/194/48 97/195/48 98/196/48 118/197/48
f 116/198/47 100/199/47 99/200/47 115/201/47
f 115/202/46 99/203/46 98/204/46 114/205/46
f 113/206/45 97/207/45 100/199/45 116/198/45
f 109/208/45 101/209/45 104/210/45 112/211/45
f 111/212/46 103/213/46 102/214/46 110/215/46
f 112/211/47 104/210/47 103/216/47 111/217/47
f 105/218/48 101/219/48 102/220/48 106/221/48
f 93/181/48 105/218/48 106/221/48 94/182/48
f 101/209/45 105/192/45 108/184/45 104/210/45
f 103/213/46 107/188/46 106/191/46 102/214/46
f 104/210/47 108/184/47 107/187/47 103/216/47
f 86/165/47 112/211/47 111/217/47 87/164/47
f 87/222/46 111/212/46 110/215/46 88/223/46
f 85/224/45 109/208/45 112/211/45 86/165/45
f 101/219/48 109/178/48 110/179/48 102/220/48
f 93/193/45 113/206/45 116/198/45 96/185/45
f 95/189/46 115/202/46 114/205/46 94/190/46
f 96/185/47 116/198/47 115/201/47 95/186/47
f 97/195/48 113/180/48 114/183/48 98/196/48
f 90/225/48 117/194/48 118/197/48 91/226/48
f 100/199/47 120/172/47 119/177/47 99/200/47
f 99/203/46 119/173/46 118/176/46 98/204/46
f 97/207/45 117/170/45 120/172/45 100/199/45
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
v 0.156250 0.187500 -0.185900
v 0.156250 0.125000 -0.185900
v 0.156250 0.125000 -0.248400
v 0.156250 0.187500 -0.248400
v 0.093750 0.187500 -0.185900
v 0.093750 0.125000 -0.185900
v 0.093750 0.125000 -0.248400
v 0.093750 0.187500 -0.248400
v 0.109375 0.187500 -0.185900
v 0.109375 0.125000 -0.185900
v 0.109375 0.125000 -0.248400
v 0.109375 0.187500 -0.248400
v 0.140625 0.187500 -0.185900
v 0.140625 0.125000 -0.185900
v 0.140625 0.125000 -0.248400
v 0.140625 0.187500 -0.248400
v 0.171875 0.187500 -0.185900
v 0.171875 0.125000 -0.185900
v 0.171875 0.125000 -0.248400
v 0.171875 0.187500 -0.248400
v 0.078125 0.187500 -0.185900
v 0.078125 0.125000 -0.185900
v 0.078125 0.125000 -0.248400
v 0.078125 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 121/227/49 124/228/49 123/229/49 122/230/49
f 125/231/50 128/232/50 127/233/50 126/234/50
f 149/235/51 126/236/51 125/231/51 152/237/51
f 151/238/52 128/239/52 127/240/52 150/241/52
f 152/237/53 125/231/53 128/232/53 151/242/53
f 153/243/54 121/227/54 124/228/54 154/244/54
f 145/245/54 129/246/54 130/247/54 146/248/54
f 144/249/53 132/250/53 131/251/53 143/252/53
f 143/253/52 131/254/52 130/255/52 142/256/52
f 141/257/51 129/258/51 132/250/51 144/249/51
f 149/259/54 133/260/54 134/261/54 150/262/54
f 148/263/53 136/264/53 135/265/53 147/266/53
f 147/267/52 135/268/52 134/269/52 146/270/52
f 145/271/51 133/272/51 136/264/51 148/263/51
f 153/273/51 137/274/51 140/275/51 156/276/51
f 155/277/52 139/278/52 138/279/52 154/280/52
f 156/276/53 140/275/53 139/281/53 155/282/53
f 141/283/54 137/284/54 138/285/54 142/286/54
f 129/246/54 141/283/54 142/286/54 130/247/54
f 137/274/51 141/257/51 144/249/51 140/275/51
f 139/278/52 143/253/52 142/256/52 138/279/52
f 140/275/53 144/249/53 143/252/53 139/281/53
f 129/258/51 145/271/51 148/263/51 132/250/51
f 131/254/52 147/267/52 146/270/52 130/255/52
f 132/250/53 148/263/53 147/266/53 131/251/53
f 133/260/54 145/245/54 146/248/54 134/261/54
f 126/287/54 149/259/54 150/262/54 127/288/54
f 136/264/53 152/237/53 151/242/53 135/265/53
f 135/268/52 151/238/52 150/241/52 134/269/52
f 133/272/51 149/235/51 152/237/51 136/264/51
f 122/230/53 156/276/53 155/282/53 123/229/53
f 123/289/52 155/277/52 154/280/52 124/290/52
f 121/291/51 153/273/51 156/276/51 122/230/51
f 137/284/54 153/243/54 154/244/54 138/285/54
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
v 0.156250 0.375000 -0.193700
v 0.156250 0.312500 -0.193700
v 0.156250 0.312500 -0.256200
v 0.156250 0.375000 -0.256200
v 0.093750 0.375000 -0.193700
v 0.093750 0.312500 -0.193700
v 0.093750 0.312500 -0.256200
v 0.093750 0.375000 -0.256200
v 0.140625 0.375000 -0.193700
v 0.140625 0.312500 -0.193700
v 0.140625 0.312500 -0.256200
v 0.140625 0.375000 -0.256200
v 0.171875 0.375000 -0.193700
v 0.171875 0.312500 -0.193700
v 0.171875 0.312500 -0.256200
v 0.171875 0.375000 -0.256200
v 0.109375 0.375000 -0.193700
v 0.109375 0.312500 -0.193700
v 0.109375 0.312500 -0.256200
v 0.109375 0.375000 -0.256200
v 0.078125 0.375000 -0.193700
v 0.078125 0.312500 -0.193700
v 0.078125 0.312500 -0.256200
v 0.078125 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 157/292/55 160/293/55 159/294/55 158/295/55
f 161/296/56 164/297/56 163/298/56 162/299/56
f 181/300/57 162/301/57 161/296/57 184/302/57
f 183/303/58 164/304/58 163/305/58 182/306/58
f 184/302/59 161/296/59 164/297/59 183/307/59
f 189/308/60 157/292/60 160/293/60 190/309/60
f 177/310/60 165/311/60 166/312/60 178/313/60
f 188/314/59 168/315/59 167/316/59 187/317/59
f 187/318/58 167/319/58 166/320/58 186/321/58
f 185/322/57 165/323/57 168/315/57 188/314/57
f 181/324/60 169/325/60 170/326/60 182/327/60
f 180/328/59 172/329/59 171/330/59 179/331/59
f 179/332/58 171/333/58 170/334/58 178/335/58
f 177/336/57 169/337/57 172/329/57 180/328/57
f 189/338/57 173/339/57 176/340/57 192/341/57
f 191/342/58 175/343/58 174/344/58 190/345/58
f 192/341/59 176/340/59 175/346/59 191/347/59
f 185/348/60 173/349/60 174/350/60 186/351/60
f 165/323/57 177/336/57 180/328/57 168/315/57
f 167/319/58 179/332/58 178/335/58 166/320/58
f 168/315/59 180/328/59 179/331/59 167/316/59
f 169/325/60 177/310/60 178/313/60 170/326/60
f 162/352/60 181/324/60 182/327/60 163/353/60
f 172/329/59 184/302/59 183/307/59 171/330/59
f 171/333/58 183/303/58 182/306/58 170/334/58
f 169/337/57 181/300/57 184/302/57 172/329/57
f 165/311/60 185/348/60 186/351/60 166/312/60
f 173/339/57 185/322/57 188/314/57 176/340/57
f 175/343/58 187/318/58 186/321/58 174/344/58
f 176/340/59 188/314/59 187/317/59 175/346/59
f 158/295/59 192/341/59 191/347/59 159/294/59
f 159/354/58 191/342/58 190/345/58 160/355/58
f 157/356/57 189/338/57 192/341/57 158/295/57
f 173/349/60 189/308/60 190/309/60 174/350/60
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
v -0.093750 0.187500 -0.185900
v -0.093750 0.125000 -0.185900
v -0.093750 0.125000 -0.248400
v -0.093750 0.187500 -0.248400
v -0.109375 0.187500 -0.185900
v -0.109375 0.125000 -0.185900
v -0.109375 0.125000 -0.248400
v -0.109375 0.187500 -0.248400
v -0.078125 0.187500 -0.185900
v -0.078125 0.125000 -0.185900
v -0.078125 0.125000 -0.248400
v -0.078125 0.187500 -0.248400
v -0.156250 0.187500 -0.185900
v -0.156250 0.125000 -0.185900
v -0.156250 0.125000 -0.248400
v -0.156250 0.187500 -0.248400
v -0.140625 0.187500 -0.185900
v -0.140625 0.125000 -0.185900
v -0.140625 0.125000 -0.248400
v -0.140625 0.187500 -0.248400
v -0.171875 0.187500 -0.185900
v -0.171875 0.125000 -0.185900
v -0.171875 0.125000 -0.248400
v -0.171875 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 193/357/61 196/358/61 195/359/61 194/360/61
f 197/361/62 200/362/62 199/363/62 198/364/62
f 213/365/63 198/366/63 197/361/63 216/367/63
f 215/368/64 200/369/64 199/370/64 214/371/64
f 216/367/65 197/361/65 200/362/65 215/372/65
f 225/373/66 193/357/66 196/358/66 226/374/66
f 209/375/66 201/376/66 202/377/66 210/378/66
f 224/379/65 204/380/65 203/381/65 223/382/65
f 223/383/64 203/384/64 202/385/64 222/386/64
f 221/387/63 201/388/63 204/380/63 224/379/63
f 213/389/66 205/390/66 206/391/66 214/392/66
f 212/393/65 208/394/65 207/395/65 211/396/65
f 211/397/64 207/398/64 206/399/64 210/400/64
f 209/401/63 205/402/63 208/394/63 212/393/63
f 201/388/63 209/401/63 212/393/63 204/380/63
f 203/384/64 211/397/64 210/400/64 202/385/64
f 204/380/65 212/393/65 211/396/65 203/381/65
f 205/390/66 209/375/66 210/378/66 206/391/66
f 198/403/66 213/389/66 214/392/66 199/404/66
f 208/394/65 216/367/65 215/372/65 207/395/65
f 207/398/64 215/368/64 214/371/64 206/399/64
f 205/402/63 213/365/63 216/367/63 208/394/63
f 225/405/63 217/406/63 220/407/63 228/408/63
f 227/409/64 219/410/64 218/411/64 226/412/64
f 228/408/65 220/407/65 219/413/65 227/414/65
f 221/415/66 217/416/66 218/417/66 222/418/66
f 201/376/66 221/415/66 222/418/66 202/377/66
f 217/406/63 221/387/63 224/379/63 220/407/63
f 219/410/64 223/383/64 222/386/64 218/411/64
f 220/407/65 224/379/65 223/382/65 219/413/65
f 194/360/65 228/408/65 227/414/65 195/359/65
f 195/419/64 227/409/64 226/412/64 196/420/64
f 193/421/63 225/405/63 228/408/63 194/360/63
f 217/416/66 225/373/66 226/374/66 218/417/66
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.387000 -0.193700
v -0.125000 0.324500 -0.193700
v -0.125000 0.324500 -0.256200
v -0.125000 0.387000 -0.256200
v -0.093750 0.383000 -0.193700
v -0.093750 0.320500 -0.193700
v -0.093750 0.320500 -0.256200
v -0.093750 0.383000 -0.256200
v -0.078125 0.379000 -0.193700
v -0.078125 0.316500 -0.193700
v -0.078125 0.316500 -0.256200
v -0.078125 0.379000 -0.256200
v -0.109375 0.386000 -0.193700
v -0.109375 0.323500 -0.193700
v -0.109375 0.323500 -0.256200
v -0.109375 0.386000 -0.256200
v -0.156250 0.383000 -0.193700
v -0.156250 0.320500 -0.193700
v -0.156250 0.320500 -0.256200
v -0.156250 0.383000 -0.256200
v -0.140625 0.386000 -0.193700
v -0.140625 0.323500 -0.193700
v -0.140625 0.323500 -0.256200
v -0.140625 0.386000 -0.256200
v -0.171875 0.379000 -0.193700
v -0.171875 0.316500 -0.193700
v -0.171875 0.316500 -0.256200
v -0.171875 0.379000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.2480 0.9688 0.0000
vn -0.2480 -0.9688 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1265 -0.9920 0.0000
vn -0.0000 -1.0000 0.0000
vn -0.1265 0.9920 0.0000
vn 0.0000 1.0000 0.0000
vn -0.1265 -0.9920 0.0000
vn -0.2184 -0.9759 0.0000
vn 0.1265 0.9920 0.0000
vn 0.2184 0.9759 0.0000
vn -0.2480 0.9688 0.0000
vn -0.2184 0.9759 0.0000
vn 0.2480 -0.9688 0.0000
vn 0.2184 -0.9759 0.0000
s 1
f 229/422/67 232/423/67 231/424/67 230/425/67
f 233/426/68 236/427/68 235/428/68 234/429/68
f 245/430/69 234/431/69 233/426/69 248/432/69
f 247/433/70 236/434/70 235/435/70 246/436/70
f 248/432/71 233/426/71 236/427/71 247/437/71
f 261/438/72 229/422/72 232/423/72 262/439/72
f 249/440/72 237/441/72 238/442/72 250/443/72
f 260/444/71 240/445/71 239/446/71 259/447/71
f 259/448/73 239/449/74 238/450/74 258/451/73
f 257/452/75 237/453/76 240/445/76 260/444/75
f 245/454/72 241/455/72 242/456/72 246/457/72
f 252/458/71 244/459/71 243/460/71 251/461/71
f 251/462/77 243/463/78 242/464/78 250/465/77
f 249/466/79 241/467/80 244/459/80 252/458/79
f 234/468/72 245/454/72 246/457/72 235/469/72
f 244/459/71 248/432/71 247/437/71 243/460/71
f 243/463/78 247/433/70 246/436/70 242/464/78
f 241/467/80 245/430/69 248/432/69 244/459/80
f 237/453/76 249/466/79 252/458/79 240/445/76
f 239/449/74 251/462/77 250/465/77 238/450/74
f 240/445/71 252/458/71 251/461/71 239/446/71
f 241/455/72 249/440/72 250/443/72 242/456/72
f 261/470/81 253/471/82 256/472/82 264/473/81
f 263/474/83 255/475/84 254/476/84 262/477/83
f 264/473/71 256/472/71 255/478/71 263/479/71
f 257/480/72 253/481/72 254/482/72 258/483/72
f 237/441/72 257/480/72 258/483/72 238/442/72
f 253/471/82 257/452/75 260/444/75 256/472/82
f 255/475/84 259/448/73 258/451/73 254/476/84
f 256/472/71 260/444/71 259/447/71 255/478/71
f 230/425/71 264/473/71 263/479/71 231/424/71
f 231/484/83 263/474/83 262/477/83 232/485/83
f 229/486/81 261/470/81 264/473/81 230/425/81
f 253/481/72 261/438/72 262/439/72 254/482/72


==================================================

--- Файл №586 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\eyebrow_r.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
v -0.093750 0.375000 -0.185900
v -0.093750 0.312500 -0.185900
v -0.093750 0.312500 -0.248400
v -0.093750 0.375000 -0.248400
v -0.078125 0.375000 -0.185900
v -0.078125 0.312500 -0.185900
v -0.078125 0.312500 -0.248400
v -0.078125 0.375000 -0.248400
v -0.109375 0.375000 -0.185900
v -0.109375 0.312500 -0.185900
v -0.109375 0.312500 -0.248400
v -0.109375 0.375000 -0.248400
v -0.156250 0.375000 -0.185900
v -0.156250 0.312500 -0.185900
v -0.156250 0.312500 -0.248400
v -0.156250 0.375000 -0.248400
v -0.140625 0.375000 -0.185900
v -0.140625 0.312500 -0.185900
v -0.140625 0.312500 -0.248400
v -0.140625 0.375000 -0.248400
v -0.171875 0.375000 -0.185900
v -0.171875 0.312500 -0.185900
v -0.171875 0.312500 -0.248400
v -0.171875 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/40 59/124/40 58/125/40 78/126/40
f 77/127/39 57/128/39 60/120/39 80/119/39
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/40 63/138/40 62/139/40 70/140/40
f 69/141/39 61/142/39 64/134/39 72/133/39
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/40 67/108/40 66/111/40 62/139/40
f 61/142/39 65/105/39 68/107/39 64/134/39
f 57/128/39 69/141/39 72/133/39 60/120/39
f 59/124/40 71/137/40 70/140/40 58/125/40
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/39 73/146/39 76/147/39 84/148/39
f 83/149/40 75/150/40 74/151/40 82/152/40
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/39 77/127/39 80/119/39 76/147/39
f 75/150/40 79/123/40 78/126/40 74/151/40
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/40 83/149/40 82/152/40 52/160/40
f 49/161/39 81/145/39 84/148/39 50/100/39
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
v 0.156250 0.375000 -0.185900
v 0.156250 0.312500 -0.185900
v 0.156250 0.312500 -0.248400
v 0.156250 0.375000 -0.248400
v 0.093750 0.375000 -0.185900
v 0.093750 0.312500 -0.185900
v 0.093750 0.312500 -0.248400
v 0.093750 0.375000 -0.248400
v 0.109375 0.375000 -0.185900
v 0.109375 0.312500 -0.185900
v 0.109375 0.312500 -0.248400
v 0.109375 0.375000 -0.248400
v 0.078125 0.375000 -0.185900
v 0.078125 0.312500 -0.185900
v 0.078125 0.312500 -0.248400
v 0.078125 0.375000 -0.248400
v 0.140625 0.375000 -0.185900
v 0.140625 0.312500 -0.185900
v 0.140625 0.312500 -0.248400
v 0.140625 0.375000 -0.248400
v 0.171875 0.375000 -0.185900
v 0.171875 0.312500 -0.185900
v 0.171875 0.312500 -0.248400
v 0.171875 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 85/162/43 88/163/43 87/164/43 86/165/43
f 89/166/44 92/167/44 91/168/44 90/169/44
f 117/170/45 90/171/45 89/166/45 120/172/45
f 119/173/46 92/174/46 91/175/46 118/176/46
f 120/172/47 89/166/47 92/167/47 119/177/47
f 109/178/48 85/162/48 88/163/48 110/179/48
f 113/180/48 93/181/48 94/182/48 114/183/48
f 108/184/47 96/185/47 95/186/47 107/187/47
f 107/188/46 95/189/46 94/190/46 106/191/46
f 105/192/45 93/193/45 96/185/45 108/184/45
f 117/194/48 97/195/48 98/196/48 118/197/48
f 116/198/47 100/199/47 99/200/47 115/201/47
f 115/202/46 99/203/46 98/204/46 114/205/46
f 113/206/45 97/207/45 100/199/45 116/198/45
f 109/208/45 101/209/45 104/210/45 112/211/45
f 111/212/46 103/213/46 102/214/46 110/215/46
f 112/211/47 104/210/47 103/216/47 111/217/47
f 105/218/48 101/219/48 102/220/48 106/221/48
f 93/181/48 105/218/48 106/221/48 94/182/48
f 101/209/45 105/192/45 108/184/45 104/210/45
f 103/213/46 107/188/46 106/191/46 102/214/46
f 104/210/47 108/184/47 107/187/47 103/216/47
f 86/165/47 112/211/47 111/217/47 87/164/47
f 87/222/46 111/212/46 110/215/46 88/223/46
f 85/224/45 109/208/45 112/211/45 86/165/45
f 101/219/48 109/178/48 110/179/48 102/220/48
f 93/193/45 113/206/45 116/198/45 96/185/45
f 95/189/46 115/202/46 114/205/46 94/190/46
f 96/185/47 116/198/47 115/201/47 95/186/47
f 97/195/48 113/180/48 114/183/48 98/196/48
f 90/225/48 117/194/48 118/197/48 91/226/48
f 100/199/47 120/172/47 119/177/47 99/200/47
f 99/203/46 119/173/46 118/176/46 98/204/46
f 97/207/45 117/170/45 120/172/45 100/199/45
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
v 0.156250 0.187500 -0.185900
v 0.156250 0.125000 -0.185900
v 0.156250 0.125000 -0.248400
v 0.156250 0.187500 -0.248400
v 0.093750 0.187500 -0.185900
v 0.093750 0.125000 -0.185900
v 0.093750 0.125000 -0.248400
v 0.093750 0.187500 -0.248400
v 0.109375 0.187500 -0.185900
v 0.109375 0.125000 -0.185900
v 0.109375 0.125000 -0.248400
v 0.109375 0.187500 -0.248400
v 0.140625 0.187500 -0.185900
v 0.140625 0.125000 -0.185900
v 0.140625 0.125000 -0.248400
v 0.140625 0.187500 -0.248400
v 0.171875 0.187500 -0.185900
v 0.171875 0.125000 -0.185900
v 0.171875 0.125000 -0.248400
v 0.171875 0.187500 -0.248400
v 0.078125 0.187500 -0.185900
v 0.078125 0.125000 -0.185900
v 0.078125 0.125000 -0.248400
v 0.078125 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 121/227/49 124/228/49 123/229/49 122/230/49
f 125/231/50 128/232/50 127/233/50 126/234/50
f 149/235/51 126/236/51 125/231/51 152/237/51
f 151/238/52 128/239/52 127/240/52 150/241/52
f 152/237/53 125/231/53 128/232/53 151/242/53
f 153/243/54 121/227/54 124/228/54 154/244/54
f 145/245/54 129/246/54 130/247/54 146/248/54
f 144/249/53 132/250/53 131/251/53 143/252/53
f 143/253/52 131/254/52 130/255/52 142/256/52
f 141/257/51 129/258/51 132/250/51 144/249/51
f 149/259/54 133/260/54 134/261/54 150/262/54
f 148/263/53 136/264/53 135/265/53 147/266/53
f 147/267/52 135/268/52 134/269/52 146/270/52
f 145/271/51 133/272/51 136/264/51 148/263/51
f 153/273/51 137/274/51 140/275/51 156/276/51
f 155/277/52 139/278/52 138/279/52 154/280/52
f 156/276/53 140/275/53 139/281/53 155/282/53
f 141/283/54 137/284/54 138/285/54 142/286/54
f 129/246/54 141/283/54 142/286/54 130/247/54
f 137/274/51 141/257/51 144/249/51 140/275/51
f 139/278/52 143/253/52 142/256/52 138/279/52
f 140/275/53 144/249/53 143/252/53 139/281/53
f 129/258/51 145/271/51 148/263/51 132/250/51
f 131/254/52 147/267/52 146/270/52 130/255/52
f 132/250/53 148/263/53 147/266/53 131/251/53
f 133/260/54 145/245/54 146/248/54 134/261/54
f 126/287/54 149/259/54 150/262/54 127/288/54
f 136/264/53 152/237/53 151/242/53 135/265/53
f 135/268/52 151/238/52 150/241/52 134/269/52
f 133/272/51 149/235/51 152/237/51 136/264/51
f 122/230/53 156/276/53 155/282/53 123/229/53
f 123/289/52 155/277/52 154/280/52 124/290/52
f 121/291/51 153/273/51 156/276/51 122/230/51
f 137/284/54 153/243/54 154/244/54 138/285/54
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.387000 -0.193700
v 0.125000 0.324500 -0.193700
v 0.125000 0.324500 -0.256200
v 0.125000 0.387000 -0.256200
v 0.156250 0.383000 -0.193700
v 0.156250 0.320500 -0.193700
v 0.156250 0.320500 -0.256200
v 0.156250 0.383000 -0.256200
v 0.093750 0.383000 -0.193700
v 0.093750 0.320500 -0.193700
v 0.093750 0.320500 -0.256200
v 0.093750 0.383000 -0.256200
v 0.140625 0.386000 -0.193700
v 0.140625 0.323500 -0.193700
v 0.140625 0.323500 -0.256200
v 0.140625 0.386000 -0.256200
v 0.171875 0.379000 -0.193700
v 0.171875 0.316500 -0.193700
v 0.171875 0.316500 -0.256200
v 0.171875 0.379000 -0.256200
v 0.109375 0.386000 -0.193700
v 0.109375 0.323500 -0.193700
v 0.109375 0.323500 -0.256200
v 0.109375 0.386000 -0.256200
v 0.078125 0.379000 -0.193700
v 0.078125 0.316500 -0.193700
v 0.078125 0.316500 -0.256200
v 0.078125 0.379000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.2480 0.9688 0.0000
vn -0.2480 -0.9688 0.0000
vn 0.0000 0.0000 -1.0000
vn -0.0000 -0.0000 1.0000
vn 0.1265 -0.9920 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1265 0.9920 0.0000
vn 0.0000 1.0000 0.0000
vn -0.1265 -0.9920 0.0000
vn -0.2184 -0.9759 0.0000
vn 0.1265 0.9920 0.0000
vn 0.2184 0.9759 0.0000
vn -0.2480 0.9688 0.0000
vn -0.2184 0.9759 0.0000
vn 0.2480 -0.9688 0.0000
vn 0.2184 -0.9759 0.0000
s 1
f 157/292/55 160/293/55 159/294/55 158/295/55
f 161/296/56 164/297/56 163/298/56 162/299/56
f 181/300/57 162/301/57 161/296/57 184/302/57
f 183/303/58 164/304/58 163/305/58 182/306/58
f 184/302/59 161/296/59 164/297/59 183/307/59
f 189/308/60 157/292/60 160/293/60 190/309/60
f 177/310/60 165/311/60 166/312/60 178/313/60
f 188/314/59 168/315/59 167/316/59 187/317/59
f 187/318/61 167/319/62 166/320/62 186/321/61
f 185/322/63 165/323/64 168/315/64 188/314/63
f 181/324/60 169/325/60 170/326/60 182/327/60
f 180/328/59 172/329/59 171/330/59 179/331/59
f 179/332/65 171/333/66 170/334/66 178/335/65
f 177/336/67 169/337/68 172/329/68 180/328/67
f 189/338/69 173/339/70 176/340/70 192/341/69
f 191/342/71 175/343/72 174/344/72 190/345/71
f 192/341/59 176/340/59 175/346/59 191/347/59
f 185/348/60 173/349/60 174/350/60 186/351/60
f 165/323/64 177/336/67 180/328/67 168/315/64
f 167/319/62 179/332/65 178/335/65 166/320/62
f 168/315/59 180/328/59 179/331/59 167/316/59
f 169/325/60 177/310/60 178/313/60 170/326/60
f 162/352/60 181/324/60 182/327/60 163/353/60
f 172/329/59 184/302/59 183/307/59 171/330/59
f 171/333/66 183/303/58 182/306/58 170/334/66
f 169/337/68 181/300/57 184/302/57 172/329/68
f 165/311/60 185/348/60 186/351/60 166/312/60
f 173/339/70 185/322/63 188/314/63 176/340/70
f 175/343/72 187/318/61 186/321/61 174/344/72
f 176/340/59 188/314/59 187/317/59 175/346/59
f 158/295/59 192/341/59 191/347/59 159/294/59
f 159/354/71 191/342/71 190/345/71 160/355/71
f 157/356/69 189/338/69 192/341/69 158/295/69
f 173/349/60 189/308/60 190/309/60 174/350/60
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
v -0.093750 0.187500 -0.185900
v -0.093750 0.125000 -0.185900
v -0.093750 0.125000 -0.248400
v -0.093750 0.187500 -0.248400
v -0.109375 0.187500 -0.185900
v -0.109375 0.125000 -0.185900
v -0.109375 0.125000 -0.248400
v -0.109375 0.187500 -0.248400
v -0.078125 0.187500 -0.185900
v -0.078125 0.125000 -0.185900
v -0.078125 0.125000 -0.248400
v -0.078125 0.187500 -0.248400
v -0.156250 0.187500 -0.185900
v -0.156250 0.125000 -0.185900
v -0.156250 0.125000 -0.248400
v -0.156250 0.187500 -0.248400
v -0.140625 0.187500 -0.185900
v -0.140625 0.125000 -0.185900
v -0.140625 0.125000 -0.248400
v -0.140625 0.187500 -0.248400
v -0.171875 0.187500 -0.185900
v -0.171875 0.125000 -0.185900
v -0.171875 0.125000 -0.248400
v -0.171875 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 193/357/73 196/358/73 195/359/73 194/360/73
f 197/361/74 200/362/74 199/363/74 198/364/74
f 213/365/75 198/366/75 197/361/75 216/367/75
f 215/368/76 200/369/76 199/370/76 214/371/76
f 216/367/77 197/361/77 200/362/77 215/372/77
f 225/373/78 193/357/78 196/358/78 226/374/78
f 209/375/78 201/376/78 202/377/78 210/378/78
f 224/379/77 204/380/77 203/381/77 223/382/77
f 223/383/76 203/384/76 202/385/76 222/386/76
f 221/387/75 201/388/75 204/380/75 224/379/75
f 213/389/78 205/390/78 206/391/78 214/392/78
f 212/393/77 208/394/77 207/395/77 211/396/77
f 211/397/76 207/398/76 206/399/76 210/400/76
f 209/401/75 205/402/75 208/394/75 212/393/75
f 201/388/75 209/401/75 212/393/75 204/380/75
f 203/384/76 211/397/76 210/400/76 202/385/76
f 204/380/77 212/393/77 211/396/77 203/381/77
f 205/390/78 209/375/78 210/378/78 206/391/78
f 198/403/78 213/389/78 214/392/78 199/404/78
f 208/394/77 216/367/77 215/372/77 207/395/77
f 207/398/76 215/368/76 214/371/76 206/399/76
f 205/402/75 213/365/75 216/367/75 208/394/75
f 225/405/75 217/406/75 220/407/75 228/408/75
f 227/409/76 219/410/76 218/411/76 226/412/76
f 228/408/77 220/407/77 219/413/77 227/414/77
f 221/415/78 217/416/78 218/417/78 222/418/78
f 201/376/78 221/415/78 222/418/78 202/377/78
f 217/406/75 221/387/75 224/379/75 220/407/75
f 219/410/76 223/383/76 222/386/76 218/411/76
f 220/407/77 224/379/77 223/382/77 219/413/77
f 194/360/77 228/408/77 227/414/77 195/359/77
f 195/419/76 227/409/76 226/412/76 196/420/76
f 193/421/75 225/405/75 228/408/75 194/360/75
f 217/416/78 225/373/78 226/374/78 218/417/78
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
v -0.093750 0.375000 -0.193700
v -0.093750 0.312500 -0.193700
v -0.093750 0.312500 -0.256200
v -0.093750 0.375000 -0.256200
v -0.078125 0.375000 -0.193700
v -0.078125 0.312500 -0.193700
v -0.078125 0.312500 -0.256200
v -0.078125 0.375000 -0.256200
v -0.109375 0.375000 -0.193700
v -0.109375 0.312500 -0.193700
v -0.109375 0.312500 -0.256200
v -0.109375 0.375000 -0.256200
v -0.156250 0.375000 -0.193700
v -0.156250 0.312500 -0.193700
v -0.156250 0.312500 -0.256200
v -0.156250 0.375000 -0.256200
v -0.140625 0.375000 -0.193700
v -0.140625 0.312500 -0.193700
v -0.140625 0.312500 -0.256200
v -0.140625 0.375000 -0.256200
v -0.171875 0.375000 -0.193700
v -0.171875 0.312500 -0.193700
v -0.171875 0.312500 -0.256200
v -0.171875 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 229/422/79 232/423/79 231/424/79 230/425/79
f 233/426/80 236/427/80 235/428/80 234/429/80
f 245/430/81 234/431/81 233/426/81 248/432/81
f 247/433/82 236/434/82 235/435/82 246/436/82
f 248/432/83 233/426/83 236/427/83 247/437/83
f 261/438/84 229/422/84 232/423/84 262/439/84
f 249/440/84 237/441/84 238/442/84 250/443/84
f 260/444/83 240/445/83 239/446/83 259/447/83
f 259/448/82 239/449/82 238/450/82 258/451/82
f 257/452/81 237/453/81 240/445/81 260/444/81
f 245/454/84 241/455/84 242/456/84 246/457/84
f 252/458/83 244/459/83 243/460/83 251/461/83
f 251/462/82 243/463/82 242/464/82 250/465/82
f 249/466/81 241/467/81 244/459/81 252/458/81
f 234/468/84 245/454/84 246/457/84 235/469/84
f 244/459/83 248/432/83 247/437/83 243/460/83
f 243/463/82 247/433/82 246/436/82 242/464/82
f 241/467/81 245/430/81 248/432/81 244/459/81
f 237/453/81 249/466/81 252/458/81 240/445/81
f 239/449/82 251/462/82 250/465/82 238/450/82
f 240/445/83 252/458/83 251/461/83 239/446/83
f 241/455/84 249/440/84 250/443/84 242/456/84
f 261/470/81 253/471/81 256/472/81 264/473/81
f 263/474/82 255/475/82 254/476/82 262/477/82
f 264/473/83 256/472/83 255/478/83 263/479/83
f 257/480/84 253/481/84 254/482/84 258/483/84
f 237/441/84 257/480/84 258/483/84 238/442/84
f 253/471/81 257/452/81 260/444/81 256/472/81
f 255/475/82 259/448/82 258/451/82 254/476/82
f 256/472/83 260/444/83 259/447/83 255/478/83
f 230/425/83 264/473/83 263/479/83 231/424/83
f 231/484/82 263/474/82 262/477/82 232/485/82
f 229/486/81 261/470/81 264/473/81 230/425/81
f 253/481/84 261/438/84 262/439/84 254/482/84


==================================================

--- Файл №587 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\eyelid_lb.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
v -0.093750 0.375000 -0.185900
v -0.093750 0.312500 -0.185900
v -0.093750 0.312500 -0.248400
v -0.093750 0.375000 -0.248400
v -0.078125 0.375000 -0.185900
v -0.078125 0.312500 -0.185900
v -0.078125 0.312500 -0.248400
v -0.078125 0.375000 -0.248400
v -0.109375 0.375000 -0.185900
v -0.109375 0.312500 -0.185900
v -0.109375 0.312500 -0.248400
v -0.109375 0.375000 -0.248400
v -0.156250 0.375000 -0.185900
v -0.156250 0.312500 -0.185900
v -0.156250 0.312500 -0.248400
v -0.156250 0.375000 -0.248400
v -0.140625 0.375000 -0.185900
v -0.140625 0.312500 -0.185900
v -0.140625 0.312500 -0.248400
v -0.140625 0.375000 -0.248400
v -0.171875 0.375000 -0.185900
v -0.171875 0.312500 -0.185900
v -0.171875 0.312500 -0.248400
v -0.171875 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/40 59/124/40 58/125/40 78/126/40
f 77/127/39 57/128/39 60/120/39 80/119/39
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/40 63/138/40 62/139/40 70/140/40
f 69/141/39 61/142/39 64/134/39 72/133/39
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/40 67/108/40 66/111/40 62/139/40
f 61/142/39 65/105/39 68/107/39 64/134/39
f 57/128/39 69/141/39 72/133/39 60/120/39
f 59/124/40 71/137/40 70/140/40 58/125/40
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/39 73/146/39 76/147/39 84/148/39
f 83/149/40 75/150/40 74/151/40 82/152/40
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/39 77/127/39 80/119/39 76/147/39
f 75/150/40 79/123/40 78/126/40 74/151/40
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/40 83/149/40 82/152/40 52/160/40
f 49/161/39 81/145/39 84/148/39 50/100/39
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
v 0.156250 0.375000 -0.185900
v 0.156250 0.312500 -0.185900
v 0.156250 0.312500 -0.248400
v 0.156250 0.375000 -0.248400
v 0.093750 0.375000 -0.185900
v 0.093750 0.312500 -0.185900
v 0.093750 0.312500 -0.248400
v 0.093750 0.375000 -0.248400
v 0.109375 0.375000 -0.185900
v 0.109375 0.312500 -0.185900
v 0.109375 0.312500 -0.248400
v 0.109375 0.375000 -0.248400
v 0.078125 0.375000 -0.185900
v 0.078125 0.312500 -0.185900
v 0.078125 0.312500 -0.248400
v 0.078125 0.375000 -0.248400
v 0.140625 0.375000 -0.185900
v 0.140625 0.312500 -0.185900
v 0.140625 0.312500 -0.248400
v 0.140625 0.375000 -0.248400
v 0.171875 0.375000 -0.185900
v 0.171875 0.312500 -0.185900
v 0.171875 0.312500 -0.248400
v 0.171875 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 85/162/43 88/163/43 87/164/43 86/165/43
f 89/166/44 92/167/44 91/168/44 90/169/44
f 117/170/45 90/171/45 89/166/45 120/172/45
f 119/173/46 92/174/46 91/175/46 118/176/46
f 120/172/47 89/166/47 92/167/47 119/177/47
f 109/178/48 85/162/48 88/163/48 110/179/48
f 113/180/48 93/181/48 94/182/48 114/183/48
f 108/184/47 96/185/47 95/186/47 107/187/47
f 107/188/46 95/189/46 94/190/46 106/191/46
f 105/192/45 93/193/45 96/185/45 108/184/45
f 117/194/48 97/195/48 98/196/48 118/197/48
f 116/198/47 100/199/47 99/200/47 115/201/47
f 115/202/46 99/203/46 98/204/46 114/205/46
f 113/206/45 97/207/45 100/199/45 116/198/45
f 109/208/45 101/209/45 104/210/45 112/211/45
f 111/212/46 103/213/46 102/214/46 110/215/46
f 112/211/47 104/210/47 103/216/47 111/217/47
f 105/218/48 101/219/48 102/220/48 106/221/48
f 93/181/48 105/218/48 106/221/48 94/182/48
f 101/209/45 105/192/45 108/184/45 104/210/45
f 103/213/46 107/188/46 106/191/46 102/214/46
f 104/210/47 108/184/47 107/187/47 103/216/47
f 86/165/47 112/211/47 111/217/47 87/164/47
f 87/222/46 111/212/46 110/215/46 88/223/46
f 85/224/45 109/208/45 112/211/45 86/165/45
f 101/219/48 109/178/48 110/179/48 102/220/48
f 93/193/45 113/206/45 116/198/45 96/185/45
f 95/189/46 115/202/46 114/205/46 94/190/46
f 96/185/47 116/198/47 115/201/47 95/186/47
f 97/195/48 113/180/48 114/183/48 98/196/48
f 90/225/48 117/194/48 118/197/48 91/226/48
f 100/199/47 120/172/47 119/177/47 99/200/47
f 99/203/46 119/173/46 118/176/46 98/204/46
f 97/207/45 117/170/45 120/172/45 100/199/45
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
v 0.156250 0.187500 -0.185900
v 0.156250 0.125000 -0.185900
v 0.156250 0.125000 -0.248400
v 0.156250 0.187500 -0.248400
v 0.093750 0.187500 -0.185900
v 0.093750 0.125000 -0.185900
v 0.093750 0.125000 -0.248400
v 0.093750 0.187500 -0.248400
v 0.109375 0.187500 -0.185900
v 0.109375 0.125000 -0.185900
v 0.109375 0.125000 -0.248400
v 0.109375 0.187500 -0.248400
v 0.140625 0.187500 -0.185900
v 0.140625 0.125000 -0.185900
v 0.140625 0.125000 -0.248400
v 0.140625 0.187500 -0.248400
v 0.171875 0.187500 -0.185900
v 0.171875 0.125000 -0.185900
v 0.171875 0.125000 -0.248400
v 0.171875 0.187500 -0.248400
v 0.078125 0.187500 -0.185900
v 0.078125 0.125000 -0.185900
v 0.078125 0.125000 -0.248400
v 0.078125 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 121/227/49 124/228/49 123/229/49 122/230/49
f 125/231/50 128/232/50 127/233/50 126/234/50
f 149/235/51 126/236/51 125/231/51 152/237/51
f 151/238/52 128/239/52 127/240/52 150/241/52
f 152/237/53 125/231/53 128/232/53 151/242/53
f 153/243/54 121/227/54 124/228/54 154/244/54
f 145/245/54 129/246/54 130/247/54 146/248/54
f 144/249/53 132/250/53 131/251/53 143/252/53
f 143/253/52 131/254/52 130/255/52 142/256/52
f 141/257/51 129/258/51 132/250/51 144/249/51
f 149/259/54 133/260/54 134/261/54 150/262/54
f 148/263/53 136/264/53 135/265/53 147/266/53
f 147/267/52 135/268/52 134/269/52 146/270/52
f 145/271/51 133/272/51 136/264/51 148/263/51
f 153/273/51 137/274/51 140/275/51 156/276/51
f 155/277/52 139/278/52 138/279/52 154/280/52
f 156/276/53 140/275/53 139/281/53 155/282/53
f 141/283/54 137/284/54 138/285/54 142/286/54
f 129/246/54 141/283/54 142/286/54 130/247/54
f 137/274/51 141/257/51 144/249/51 140/275/51
f 139/278/52 143/253/52 142/256/52 138/279/52
f 140/275/53 144/249/53 143/252/53 139/281/53
f 129/258/51 145/271/51 148/263/51 132/250/51
f 131/254/52 147/267/52 146/270/52 130/255/52
f 132/250/53 148/263/53 147/266/53 131/251/53
f 133/260/54 145/245/54 146/248/54 134/261/54
f 126/287/54 149/259/54 150/262/54 127/288/54
f 136/264/53 152/237/53 151/242/53 135/265/53
f 135/268/52 151/238/52 150/241/52 134/269/52
f 133/272/51 149/235/51 152/237/51 136/264/51
f 122/230/53 156/276/53 155/282/53 123/229/53
f 123/289/52 155/277/52 154/280/52 124/290/52
f 121/291/51 153/273/51 156/276/51 122/230/51
f 137/284/54 153/243/54 154/244/54 138/285/54
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
v 0.156250 0.375000 -0.193700
v 0.156250 0.312500 -0.193700
v 0.156250 0.312500 -0.256200
v 0.156250 0.375000 -0.256200
v 0.093750 0.375000 -0.193700
v 0.093750 0.312500 -0.193700
v 0.093750 0.312500 -0.256200
v 0.093750 0.375000 -0.256200
v 0.140625 0.375000 -0.193700
v 0.140625 0.312500 -0.193700
v 0.140625 0.312500 -0.256200
v 0.140625 0.375000 -0.256200
v 0.171875 0.375000 -0.193700
v 0.171875 0.312500 -0.193700
v 0.171875 0.312500 -0.256200
v 0.171875 0.375000 -0.256200
v 0.109375 0.375000 -0.193700
v 0.109375 0.312500 -0.193700
v 0.109375 0.312500 -0.256200
v 0.109375 0.375000 -0.256200
v 0.078125 0.375000 -0.193700
v 0.078125 0.312500 -0.193700
v 0.078125 0.312500 -0.256200
v 0.078125 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 157/292/55 160/293/55 159/294/55 158/295/55
f 161/296/56 164/297/56 163/298/56 162/299/56
f 181/300/57 162/301/57 161/296/57 184/302/57
f 183/303/58 164/304/58 163/305/58 182/306/58
f 184/302/59 161/296/59 164/297/59 183/307/59
f 189/308/60 157/292/60 160/293/60 190/309/60
f 177/310/60 165/311/60 166/312/60 178/313/60
f 188/314/59 168/315/59 167/316/59 187/317/59
f 187/318/58 167/319/58 166/320/58 186/321/58
f 185/322/57 165/323/57 168/315/57 188/314/57
f 181/324/60 169/325/60 170/326/60 182/327/60
f 180/328/59 172/329/59 171/330/59 179/331/59
f 179/332/58 171/333/58 170/334/58 178/335/58
f 177/336/57 169/337/57 172/329/57 180/328/57
f 189/338/57 173/339/57 176/340/57 192/341/57
f 191/342/58 175/343/58 174/344/58 190/345/58
f 192/341/59 176/340/59 175/346/59 191/347/59
f 185/348/60 173/349/60 174/350/60 186/351/60
f 165/323/57 177/336/57 180/328/57 168/315/57
f 167/319/58 179/332/58 178/335/58 166/320/58
f 168/315/59 180/328/59 179/331/59 167/316/59
f 169/325/60 177/310/60 178/313/60 170/326/60
f 162/352/60 181/324/60 182/327/60 163/353/60
f 172/329/59 184/302/59 183/307/59 171/330/59
f 171/333/58 183/303/58 182/306/58 170/334/58
f 169/337/57 181/300/57 184/302/57 172/329/57
f 165/311/60 185/348/60 186/351/60 166/312/60
f 173/339/57 185/322/57 188/314/57 176/340/57
f 175/343/58 187/318/58 186/321/58 174/344/58
f 176/340/59 188/314/59 187/317/59 175/346/59
f 158/295/59 192/341/59 191/347/59 159/294/59
f 159/354/58 191/342/58 190/345/58 160/355/58
f 157/356/57 189/338/57 192/341/57 158/295/57
f 173/349/60 189/308/60 190/309/60 174/350/60
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.199500 -0.185900
v -0.125000 0.137000 -0.185900
v -0.125000 0.137000 -0.248400
v -0.125000 0.199500 -0.248400
v -0.093750 0.195500 -0.185900
v -0.093750 0.133000 -0.185900
v -0.093750 0.133000 -0.248400
v -0.093750 0.195500 -0.248400
v -0.109375 0.198500 -0.185900
v -0.109375 0.136000 -0.185900
v -0.109375 0.136000 -0.248400
v -0.109375 0.198500 -0.248400
v -0.078125 0.191500 -0.185900
v -0.078125 0.129000 -0.185900
v -0.078125 0.129000 -0.248400
v -0.078125 0.191500 -0.248400
v -0.156250 0.195500 -0.185900
v -0.156250 0.133000 -0.185900
v -0.156250 0.133000 -0.248400
v -0.156250 0.195500 -0.248400
v -0.140625 0.198500 -0.185900
v -0.140625 0.136000 -0.185900
v -0.140625 0.136000 -0.248400
v -0.140625 0.198500 -0.248400
v -0.171875 0.191500 -0.185900
v -0.171875 0.129000 -0.185900
v -0.171875 0.129000 -0.248400
v -0.171875 0.191500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.2480 0.9688 0.0000
vn -0.2480 -0.9688 -0.0000
vn 0.0000 0.0000 -1.0000
vn -0.0000 -0.0000 1.0000
vn 0.1265 -0.9920 -0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1265 0.9920 0.0000
vn 0.0000 1.0000 0.0000
vn -0.1265 -0.9920 -0.0000
vn -0.2184 -0.9759 -0.0000
vn 0.1265 0.9920 0.0000
vn 0.2184 0.9759 0.0000
vn -0.2480 0.9688 0.0000
vn -0.2184 0.9759 0.0000
vn 0.2480 -0.9688 -0.0000
vn 0.2184 -0.9759 -0.0000
s 1
f 193/357/61 196/358/61 195/359/61 194/360/61
f 197/361/62 200/362/62 199/363/62 198/364/62
f 213/365/63 198/366/63 197/361/63 216/367/63
f 215/368/64 200/369/64 199/370/64 214/371/64
f 216/367/65 197/361/65 200/362/65 215/372/65
f 225/373/66 193/357/66 196/358/66 226/374/66
f 209/375/66 201/376/66 202/377/66 210/378/66
f 224/379/65 204/380/65 203/381/65 223/382/65
f 223/383/67 203/384/68 202/385/68 222/386/67
f 221/387/69 201/388/70 204/380/70 224/379/69
f 213/389/66 205/390/66 206/391/66 214/392/66
f 212/393/65 208/394/65 207/395/65 211/396/65
f 211/397/71 207/398/72 206/399/72 210/400/71
f 209/401/73 205/402/74 208/394/74 212/393/73
f 201/388/70 209/401/73 212/393/73 204/380/70
f 203/384/68 211/397/71 210/400/71 202/385/68
f 204/380/65 212/393/65 211/396/65 203/381/65
f 205/390/66 209/375/66 210/378/66 206/391/66
f 198/403/66 213/389/66 214/392/66 199/404/66
f 208/394/65 216/367/65 215/372/65 207/395/65
f 207/398/72 215/368/64 214/371/64 206/399/72
f 205/402/74 213/365/63 216/367/63 208/394/74
f 225/405/75 217/406/76 220/407/76 228/408/75
f 227/409/77 219/410/78 218/411/78 226/412/77
f 228/408/65 220/407/65 219/413/65 227/414/65
f 221/415/66 217/416/66 218/417/66 222/418/66
f 201/376/66 221/415/66 222/418/66 202/377/66
f 217/406/76 221/387/69 224/379/69 220/407/76
f 219/410/78 223/383/67 222/386/67 218/411/78
f 220/407/65 224/379/65 223/382/65 219/413/65
f 194/360/65 228/408/65 227/414/65 195/359/65
f 195/419/77 227/409/77 226/412/77 196/420/77
f 193/421/75 225/405/75 228/408/75 194/360/75
f 217/416/66 225/373/66 226/374/66 218/417/66
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
v -0.093750 0.375000 -0.193700
v -0.093750 0.312500 -0.193700
v -0.093750 0.312500 -0.256200
v -0.093750 0.375000 -0.256200
v -0.078125 0.375000 -0.193700
v -0.078125 0.312500 -0.193700
v -0.078125 0.312500 -0.256200
v -0.078125 0.375000 -0.256200
v -0.109375 0.375000 -0.193700
v -0.109375 0.312500 -0.193700
v -0.109375 0.312500 -0.256200
v -0.109375 0.375000 -0.256200
v -0.156250 0.375000 -0.193700
v -0.156250 0.312500 -0.193700
v -0.156250 0.312500 -0.256200
v -0.156250 0.375000 -0.256200
v -0.140625 0.375000 -0.193700
v -0.140625 0.312500 -0.193700
v -0.140625 0.312500 -0.256200
v -0.140625 0.375000 -0.256200
v -0.171875 0.375000 -0.193700
v -0.171875 0.312500 -0.193700
v -0.171875 0.312500 -0.256200
v -0.171875 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 229/422/79 232/423/79 231/424/79 230/425/79
f 233/426/80 236/427/80 235/428/80 234/429/80
f 245/430/81 234/431/81 233/426/81 248/432/81
f 247/433/82 236/434/82 235/435/82 246/436/82
f 248/432/83 233/426/83 236/427/83 247/437/83
f 261/438/84 229/422/84 232/423/84 262/439/84
f 249/440/84 237/441/84 238/442/84 250/443/84
f 260/444/83 240/445/83 239/446/83 259/447/83
f 259/448/82 239/449/82 238/450/82 258/451/82
f 257/452/81 237/453/81 240/445/81 260/444/81
f 245/454/84 241/455/84 242/456/84 246/457/84
f 252/458/83 244/459/83 243/460/83 251/461/83
f 251/462/82 243/463/82 242/464/82 250/465/82
f 249/466/81 241/467/81 244/459/81 252/458/81
f 234/468/84 245/454/84 246/457/84 235/469/84
f 244/459/83 248/432/83 247/437/83 243/460/83
f 243/463/82 247/433/82 246/436/82 242/464/82
f 241/467/81 245/430/81 248/432/81 244/459/81
f 237/453/81 249/466/81 252/458/81 240/445/81
f 239/449/82 251/462/82 250/465/82 238/450/82
f 240/445/83 252/458/83 251/461/83 239/446/83
f 241/455/84 249/440/84 250/443/84 242/456/84
f 261/470/81 253/471/81 256/472/81 264/473/81
f 263/474/82 255/475/82 254/476/82 262/477/82
f 264/473/83 256/472/83 255/478/83 263/479/83
f 257/480/84 253/481/84 254/482/84 258/483/84
f 237/441/84 257/480/84 258/483/84 238/442/84
f 253/471/81 257/452/81 260/444/81 256/472/81
f 255/475/82 259/448/82 258/451/82 254/476/82
f 256/472/83 260/444/83 259/447/83 255/478/83
f 230/425/83 264/473/83 263/479/83 231/424/83
f 231/484/82 263/474/82 262/477/82 232/485/82
f 229/486/81 261/470/81 264/473/81 230/425/81
f 253/481/84 261/438/84 262/439/84 254/482/84


==================================================

--- Файл №588 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\eyelid_lt.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.387000 -0.185900
v -0.125000 0.324500 -0.185900
v -0.125000 0.324500 -0.248400
v -0.125000 0.387000 -0.248400
v -0.093750 0.383000 -0.185900
v -0.093750 0.320500 -0.185900
v -0.093750 0.320500 -0.248400
v -0.093750 0.383000 -0.248400
v -0.078125 0.379000 -0.185900
v -0.078125 0.316500 -0.185900
v -0.078125 0.316500 -0.248400
v -0.078125 0.379000 -0.248400
v -0.109375 0.386000 -0.185900
v -0.109375 0.323500 -0.185900
v -0.109375 0.323500 -0.248400
v -0.109375 0.386000 -0.248400
v -0.156250 0.383000 -0.185900
v -0.156250 0.320500 -0.185900
v -0.156250 0.320500 -0.248400
v -0.156250 0.383000 -0.248400
v -0.140625 0.386000 -0.185900
v -0.140625 0.323500 -0.185900
v -0.140625 0.323500 -0.248400
v -0.140625 0.386000 -0.248400
v -0.171875 0.379000 -0.185900
v -0.171875 0.316500 -0.185900
v -0.171875 0.316500 -0.248400
v -0.171875 0.379000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.2480 0.9688 0.0000
vn -0.2480 -0.9688 0.0000
vn 0.0000 0.0000 -1.0000
vn -0.0000 -0.0000 1.0000
vn 0.1265 -0.9920 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1265 0.9920 0.0000
vn 0.0000 1.0000 0.0000
vn -0.1265 -0.9920 0.0000
vn -0.2184 -0.9759 0.0000
vn 0.1265 0.9920 0.0000
vn 0.2184 0.9759 0.0000
vn -0.2480 0.9688 0.0000
vn -0.2184 0.9759 0.0000
vn 0.2480 -0.9688 0.0000
vn 0.2184 -0.9759 0.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/43 59/124/44 58/125/44 78/126/43
f 77/127/45 57/128/46 60/120/46 80/119/45
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/47 63/138/48 62/139/48 70/140/47
f 69/141/49 61/142/50 64/134/50 72/133/49
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/48 67/108/40 66/111/40 62/139/48
f 61/142/50 65/105/39 68/107/39 64/134/50
f 57/128/46 69/141/49 72/133/49 60/120/46
f 59/124/44 71/137/47 70/140/47 58/125/44
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/51 73/146/52 76/147/52 84/148/51
f 83/149/53 75/150/54 74/151/54 82/152/53
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/52 77/127/45 80/119/45 76/147/52
f 75/150/54 79/123/43 78/126/43 74/151/54
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/53 83/149/53 82/152/53 52/160/53
f 49/161/51 81/145/51 84/148/51 50/100/51
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
v 0.156250 0.375000 -0.185900
v 0.156250 0.312500 -0.185900
v 0.156250 0.312500 -0.248400
v 0.156250 0.375000 -0.248400
v 0.093750 0.375000 -0.185900
v 0.093750 0.312500 -0.185900
v 0.093750 0.312500 -0.248400
v 0.093750 0.375000 -0.248400
v 0.109375 0.375000 -0.185900
v 0.109375 0.312500 -0.185900
v 0.109375 0.312500 -0.248400
v 0.109375 0.375000 -0.248400
v 0.078125 0.375000 -0.185900
v 0.078125 0.312500 -0.185900
v 0.078125 0.312500 -0.248400
v 0.078125 0.375000 -0.248400
v 0.140625 0.375000 -0.185900
v 0.140625 0.312500 -0.185900
v 0.140625 0.312500 -0.248400
v 0.140625 0.375000 -0.248400
v 0.171875 0.375000 -0.185900
v 0.171875 0.312500 -0.185900
v 0.171875 0.312500 -0.248400
v 0.171875 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 85/162/55 88/163/55 87/164/55 86/165/55
f 89/166/56 92/167/56 91/168/56 90/169/56
f 117/170/57 90/171/57 89/166/57 120/172/57
f 119/173/58 92/174/58 91/175/58 118/176/58
f 120/172/59 89/166/59 92/167/59 119/177/59
f 109/178/60 85/162/60 88/163/60 110/179/60
f 113/180/60 93/181/60 94/182/60 114/183/60
f 108/184/59 96/185/59 95/186/59 107/187/59
f 107/188/58 95/189/58 94/190/58 106/191/58
f 105/192/57 93/193/57 96/185/57 108/184/57
f 117/194/60 97/195/60 98/196/60 118/197/60
f 116/198/59 100/199/59 99/200/59 115/201/59
f 115/202/58 99/203/58 98/204/58 114/205/58
f 113/206/57 97/207/57 100/199/57 116/198/57
f 109/208/57 101/209/57 104/210/57 112/211/57
f 111/212/58 103/213/58 102/214/58 110/215/58
f 112/211/59 104/210/59 103/216/59 111/217/59
f 105/218/60 101/219/60 102/220/60 106/221/60
f 93/181/60 105/218/60 106/221/60 94/182/60
f 101/209/57 105/192/57 108/184/57 104/210/57
f 103/213/58 107/188/58 106/191/58 102/214/58
f 104/210/59 108/184/59 107/187/59 103/216/59
f 86/165/59 112/211/59 111/217/59 87/164/59
f 87/222/58 111/212/58 110/215/58 88/223/58
f 85/224/57 109/208/57 112/211/57 86/165/57
f 101/219/60 109/178/60 110/179/60 102/220/60
f 93/193/57 113/206/57 116/198/57 96/185/57
f 95/189/58 115/202/58 114/205/58 94/190/58
f 96/185/59 116/198/59 115/201/59 95/186/59
f 97/195/60 113/180/60 114/183/60 98/196/60
f 90/225/60 117/194/60 118/197/60 91/226/60
f 100/199/59 120/172/59 119/177/59 99/200/59
f 99/203/58 119/173/58 118/176/58 98/204/58
f 97/207/57 117/170/57 120/172/57 100/199/57
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
v 0.156250 0.187500 -0.185900
v 0.156250 0.125000 -0.185900
v 0.156250 0.125000 -0.248400
v 0.156250 0.187500 -0.248400
v 0.093750 0.187500 -0.185900
v 0.093750 0.125000 -0.185900
v 0.093750 0.125000 -0.248400
v 0.093750 0.187500 -0.248400
v 0.109375 0.187500 -0.185900
v 0.109375 0.125000 -0.185900
v 0.109375 0.125000 -0.248400
v 0.109375 0.187500 -0.248400
v 0.140625 0.187500 -0.185900
v 0.140625 0.125000 -0.185900
v 0.140625 0.125000 -0.248400
v 0.140625 0.187500 -0.248400
v 0.171875 0.187500 -0.185900
v 0.171875 0.125000 -0.185900
v 0.171875 0.125000 -0.248400
v 0.171875 0.187500 -0.248400
v 0.078125 0.187500 -0.185900
v 0.078125 0.125000 -0.185900
v 0.078125 0.125000 -0.248400
v 0.078125 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 121/227/61 124/228/61 123/229/61 122/230/61
f 125/231/62 128/232/62 127/233/62 126/234/62
f 149/235/63 126/236/63 125/231/63 152/237/63
f 151/238/64 128/239/64 127/240/64 150/241/64
f 152/237/65 125/231/65 128/232/65 151/242/65
f 153/243/66 121/227/66 124/228/66 154/244/66
f 145/245/66 129/246/66 130/247/66 146/248/66
f 144/249/65 132/250/65 131/251/65 143/252/65
f 143/253/64 131/254/64 130/255/64 142/256/64
f 141/257/63 129/258/63 132/250/63 144/249/63
f 149/259/66 133/260/66 134/261/66 150/262/66
f 148/263/65 136/264/65 135/265/65 147/266/65
f 147/267/64 135/268/64 134/269/64 146/270/64
f 145/271/63 133/272/63 136/264/63 148/263/63
f 153/273/63 137/274/63 140/275/63 156/276/63
f 155/277/64 139/278/64 138/279/64 154/280/64
f 156/276/65 140/275/65 139/281/65 155/282/65
f 141/283/66 137/284/66 138/285/66 142/286/66
f 129/246/66 141/283/66 142/286/66 130/247/66
f 137/274/63 141/257/63 144/249/63 140/275/63
f 139/278/64 143/253/64 142/256/64 138/279/64
f 140/275/65 144/249/65 143/252/65 139/281/65
f 129/258/63 145/271/63 148/263/63 132/250/63
f 131/254/64 147/267/64 146/270/64 130/255/64
f 132/250/65 148/263/65 147/266/65 131/251/65
f 133/260/66 145/245/66 146/248/66 134/261/66
f 126/287/66 149/259/66 150/262/66 127/288/66
f 136/264/65 152/237/65 151/242/65 135/265/65
f 135/268/64 151/238/64 150/241/64 134/269/64
f 133/272/63 149/235/63 152/237/63 136/264/63
f 122/230/65 156/276/65 155/282/65 123/229/65
f 123/289/64 155/277/64 154/280/64 124/290/64
f 121/291/63 153/273/63 156/276/63 122/230/63
f 137/284/66 153/243/66 154/244/66 138/285/66
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
v 0.156250 0.375000 -0.193700
v 0.156250 0.312500 -0.193700
v 0.156250 0.312500 -0.256200
v 0.156250 0.375000 -0.256200
v 0.093750 0.375000 -0.193700
v 0.093750 0.312500 -0.193700
v 0.093750 0.312500 -0.256200
v 0.093750 0.375000 -0.256200
v 0.140625 0.375000 -0.193700
v 0.140625 0.312500 -0.193700
v 0.140625 0.312500 -0.256200
v 0.140625 0.375000 -0.256200
v 0.171875 0.375000 -0.193700
v 0.171875 0.312500 -0.193700
v 0.171875 0.312500 -0.256200
v 0.171875 0.375000 -0.256200
v 0.109375 0.375000 -0.193700
v 0.109375 0.312500 -0.193700
v 0.109375 0.312500 -0.256200
v 0.109375 0.375000 -0.256200
v 0.078125 0.375000 -0.193700
v 0.078125 0.312500 -0.193700
v 0.078125 0.312500 -0.256200
v 0.078125 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 157/292/67 160/293/67 159/294/67 158/295/67
f 161/296/68 164/297/68 163/298/68 162/299/68
f 181/300/69 162/301/69 161/296/69 184/302/69
f 183/303/70 164/304/70 163/305/70 182/306/70
f 184/302/71 161/296/71 164/297/71 183/307/71
f 189/308/72 157/292/72 160/293/72 190/309/72
f 177/310/72 165/311/72 166/312/72 178/313/72
f 188/314/71 168/315/71 167/316/71 187/317/71
f 187/318/70 167/319/70 166/320/70 186/321/70
f 185/322/69 165/323/69 168/315/69 188/314/69
f 181/324/72 169/325/72 170/326/72 182/327/72
f 180/328/71 172/329/71 171/330/71 179/331/71
f 179/332/70 171/333/70 170/334/70 178/335/70
f 177/336/69 169/337/69 172/329/69 180/328/69
f 189/338/69 173/339/69 176/340/69 192/341/69
f 191/342/70 175/343/70 174/344/70 190/345/70
f 192/341/71 176/340/71 175/346/71 191/347/71
f 185/348/72 173/349/72 174/350/72 186/351/72
f 165/323/69 177/336/69 180/328/69 168/315/69
f 167/319/70 179/332/70 178/335/70 166/320/70
f 168/315/71 180/328/71 179/331/71 167/316/71
f 169/325/72 177/310/72 178/313/72 170/326/72
f 162/352/72 181/324/72 182/327/72 163/353/72
f 172/329/71 184/302/71 183/307/71 171/330/71
f 171/333/70 183/303/70 182/306/70 170/334/70
f 169/337/69 181/300/69 184/302/69 172/329/69
f 165/311/72 185/348/72 186/351/72 166/312/72
f 173/339/69 185/322/69 188/314/69 176/340/69
f 175/343/70 187/318/70 186/321/70 174/344/70
f 176/340/71 188/314/71 187/317/71 175/346/71
f 158/295/71 192/341/71 191/347/71 159/294/71
f 159/354/70 191/342/70 190/345/70 160/355/70
f 157/356/69 189/338/69 192/341/69 158/295/69
f 173/349/72 189/308/72 190/309/72 174/350/72
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
v -0.093750 0.187500 -0.185900
v -0.093750 0.125000 -0.185900
v -0.093750 0.125000 -0.248400
v -0.093750 0.187500 -0.248400
v -0.109375 0.187500 -0.185900
v -0.109375 0.125000 -0.185900
v -0.109375 0.125000 -0.248400
v -0.109375 0.187500 -0.248400
v -0.078125 0.187500 -0.185900
v -0.078125 0.125000 -0.185900
v -0.078125 0.125000 -0.248400
v -0.078125 0.187500 -0.248400
v -0.156250 0.187500 -0.185900
v -0.156250 0.125000 -0.185900
v -0.156250 0.125000 -0.248400
v -0.156250 0.187500 -0.248400
v -0.140625 0.187500 -0.185900
v -0.140625 0.125000 -0.185900
v -0.140625 0.125000 -0.248400
v -0.140625 0.187500 -0.248400
v -0.171875 0.187500 -0.185900
v -0.171875 0.125000 -0.185900
v -0.171875 0.125000 -0.248400
v -0.171875 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 193/357/73 196/358/73 195/359/73 194/360/73
f 197/361/74 200/362/74 199/363/74 198/364/74
f 213/365/75 198/366/75 197/361/75 216/367/75
f 215/368/76 200/369/76 199/370/76 214/371/76
f 216/367/77 197/361/77 200/362/77 215/372/77
f 225/373/78 193/357/78 196/358/78 226/374/78
f 209/375/78 201/376/78 202/377/78 210/378/78
f 224/379/77 204/380/77 203/381/77 223/382/77
f 223/383/76 203/384/76 202/385/76 222/386/76
f 221/387/75 201/388/75 204/380/75 224/379/75
f 213/389/78 205/390/78 206/391/78 214/392/78
f 212/393/77 208/394/77 207/395/77 211/396/77
f 211/397/76 207/398/76 206/399/76 210/400/76
f 209/401/75 205/402/75 208/394/75 212/393/75
f 201/388/75 209/401/75 212/393/75 204/380/75
f 203/384/76 211/397/76 210/400/76 202/385/76
f 204/380/77 212/393/77 211/396/77 203/381/77
f 205/390/78 209/375/78 210/378/78 206/391/78
f 198/403/78 213/389/78 214/392/78 199/404/78
f 208/394/77 216/367/77 215/372/77 207/395/77
f 207/398/76 215/368/76 214/371/76 206/399/76
f 205/402/75 213/365/75 216/367/75 208/394/75
f 225/405/75 217/406/75 220/407/75 228/408/75
f 227/409/76 219/410/76 218/411/76 226/412/76
f 228/408/77 220/407/77 219/413/77 227/414/77
f 221/415/78 217/416/78 218/417/78 222/418/78
f 201/376/78 221/415/78 222/418/78 202/377/78
f 217/406/75 221/387/75 224/379/75 220/407/75
f 219/410/76 223/383/76 222/386/76 218/411/76
f 220/407/77 224/379/77 223/382/77 219/413/77
f 194/360/77 228/408/77 227/414/77 195/359/77
f 195/419/76 227/409/76 226/412/76 196/420/76
f 193/421/75 225/405/75 228/408/75 194/360/75
f 217/416/78 225/373/78 226/374/78 218/417/78
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
v -0.093750 0.375000 -0.193700
v -0.093750 0.312500 -0.193700
v -0.093750 0.312500 -0.256200
v -0.093750 0.375000 -0.256200
v -0.078125 0.375000 -0.193700
v -0.078125 0.312500 -0.193700
v -0.078125 0.312500 -0.256200
v -0.078125 0.375000 -0.256200
v -0.109375 0.375000 -0.193700
v -0.109375 0.312500 -0.193700
v -0.109375 0.312500 -0.256200
v -0.109375 0.375000 -0.256200
v -0.156250 0.375000 -0.193700
v -0.156250 0.312500 -0.193700
v -0.156250 0.312500 -0.256200
v -0.156250 0.375000 -0.256200
v -0.140625 0.375000 -0.193700
v -0.140625 0.312500 -0.193700
v -0.140625 0.312500 -0.256200
v -0.140625 0.375000 -0.256200
v -0.171875 0.375000 -0.193700
v -0.171875 0.312500 -0.193700
v -0.171875 0.312500 -0.256200
v -0.171875 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 229/422/79 232/423/79 231/424/79 230/425/79
f 233/426/80 236/427/80 235/428/80 234/429/80
f 245/430/81 234/431/81 233/426/81 248/432/81
f 247/433/82 236/434/82 235/435/82 246/436/82
f 248/432/83 233/426/83 236/427/83 247/437/83
f 261/438/84 229/422/84 232/423/84 262/439/84
f 249/440/84 237/441/84 238/442/84 250/443/84
f 260/444/83 240/445/83 239/446/83 259/447/83
f 259/448/82 239/449/82 238/450/82 258/451/82
f 257/452/81 237/453/81 240/445/81 260/444/81
f 245/454/84 241/455/84 242/456/84 246/457/84
f 252/458/83 244/459/83 243/460/83 251/461/83
f 251/462/82 243/463/82 242/464/82 250/465/82
f 249/466/81 241/467/81 244/459/81 252/458/81
f 234/468/84 245/454/84 246/457/84 235/469/84
f 244/459/83 248/432/83 247/437/83 243/460/83
f 243/463/82 247/433/82 246/436/82 242/464/82
f 241/467/81 245/430/81 248/432/81 244/459/81
f 237/453/81 249/466/81 252/458/81 240/445/81
f 239/449/82 251/462/82 250/465/82 238/450/82
f 240/445/83 252/458/83 251/461/83 239/446/83
f 241/455/84 249/440/84 250/443/84 242/456/84
f 261/470/81 253/471/81 256/472/81 264/473/81
f 263/474/82 255/475/82 254/476/82 262/477/82
f 264/473/83 256/472/83 255/478/83 263/479/83
f 257/480/84 253/481/84 254/482/84 258/483/84
f 237/441/84 257/480/84 258/483/84 238/442/84
f 253/471/81 257/452/81 260/444/81 256/472/81
f 255/475/82 259/448/82 258/451/82 254/476/82
f 256/472/83 260/444/83 259/447/83 255/478/83
f 230/425/83 264/473/83 263/479/83 231/424/83
f 231/484/82 263/474/82 262/477/82 232/485/82
f 229/486/81 261/470/81 264/473/81 230/425/81
f 253/481/84 261/438/84 262/439/84 254/482/84


==================================================

--- Файл №589 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\eyelid_rb.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
v -0.093750 0.375000 -0.185900
v -0.093750 0.312500 -0.185900
v -0.093750 0.312500 -0.248400
v -0.093750 0.375000 -0.248400
v -0.078125 0.375000 -0.185900
v -0.078125 0.312500 -0.185900
v -0.078125 0.312500 -0.248400
v -0.078125 0.375000 -0.248400
v -0.109375 0.375000 -0.185900
v -0.109375 0.312500 -0.185900
v -0.109375 0.312500 -0.248400
v -0.109375 0.375000 -0.248400
v -0.156250 0.375000 -0.185900
v -0.156250 0.312500 -0.185900
v -0.156250 0.312500 -0.248400
v -0.156250 0.375000 -0.248400
v -0.140625 0.375000 -0.185900
v -0.140625 0.312500 -0.185900
v -0.140625 0.312500 -0.248400
v -0.140625 0.375000 -0.248400
v -0.171875 0.375000 -0.185900
v -0.171875 0.312500 -0.185900
v -0.171875 0.312500 -0.248400
v -0.171875 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/40 59/124/40 58/125/40 78/126/40
f 77/127/39 57/128/39 60/120/39 80/119/39
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/40 63/138/40 62/139/40 70/140/40
f 69/141/39 61/142/39 64/134/39 72/133/39
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/40 67/108/40 66/111/40 62/139/40
f 61/142/39 65/105/39 68/107/39 64/134/39
f 57/128/39 69/141/39 72/133/39 60/120/39
f 59/124/40 71/137/40 70/140/40 58/125/40
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/39 73/146/39 76/147/39 84/148/39
f 83/149/40 75/150/40 74/151/40 82/152/40
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/39 77/127/39 80/119/39 76/147/39
f 75/150/40 79/123/40 78/126/40 74/151/40
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/40 83/149/40 82/152/40 52/160/40
f 49/161/39 81/145/39 84/148/39 50/100/39
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
v 0.156250 0.375000 -0.185900
v 0.156250 0.312500 -0.185900
v 0.156250 0.312500 -0.248400
v 0.156250 0.375000 -0.248400
v 0.093750 0.375000 -0.185900
v 0.093750 0.312500 -0.185900
v 0.093750 0.312500 -0.248400
v 0.093750 0.375000 -0.248400
v 0.109375 0.375000 -0.185900
v 0.109375 0.312500 -0.185900
v 0.109375 0.312500 -0.248400
v 0.109375 0.375000 -0.248400
v 0.078125 0.375000 -0.185900
v 0.078125 0.312500 -0.185900
v 0.078125 0.312500 -0.248400
v 0.078125 0.375000 -0.248400
v 0.140625 0.375000 -0.185900
v 0.140625 0.312500 -0.185900
v 0.140625 0.312500 -0.248400
v 0.140625 0.375000 -0.248400
v 0.171875 0.375000 -0.185900
v 0.171875 0.312500 -0.185900
v 0.171875 0.312500 -0.248400
v 0.171875 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 85/162/43 88/163/43 87/164/43 86/165/43
f 89/166/44 92/167/44 91/168/44 90/169/44
f 117/170/45 90/171/45 89/166/45 120/172/45
f 119/173/46 92/174/46 91/175/46 118/176/46
f 120/172/47 89/166/47 92/167/47 119/177/47
f 109/178/48 85/162/48 88/163/48 110/179/48
f 113/180/48 93/181/48 94/182/48 114/183/48
f 108/184/47 96/185/47 95/186/47 107/187/47
f 107/188/46 95/189/46 94/190/46 106/191/46
f 105/192/45 93/193/45 96/185/45 108/184/45
f 117/194/48 97/195/48 98/196/48 118/197/48
f 116/198/47 100/199/47 99/200/47 115/201/47
f 115/202/46 99/203/46 98/204/46 114/205/46
f 113/206/45 97/207/45 100/199/45 116/198/45
f 109/208/45 101/209/45 104/210/45 112/211/45
f 111/212/46 103/213/46 102/214/46 110/215/46
f 112/211/47 104/210/47 103/216/47 111/217/47
f 105/218/48 101/219/48 102/220/48 106/221/48
f 93/181/48 105/218/48 106/221/48 94/182/48
f 101/209/45 105/192/45 108/184/45 104/210/45
f 103/213/46 107/188/46 106/191/46 102/214/46
f 104/210/47 108/184/47 107/187/47 103/216/47
f 86/165/47 112/211/47 111/217/47 87/164/47
f 87/222/46 111/212/46 110/215/46 88/223/46
f 85/224/45 109/208/45 112/211/45 86/165/45
f 101/219/48 109/178/48 110/179/48 102/220/48
f 93/193/45 113/206/45 116/198/45 96/185/45
f 95/189/46 115/202/46 114/205/46 94/190/46
f 96/185/47 116/198/47 115/201/47 95/186/47
f 97/195/48 113/180/48 114/183/48 98/196/48
f 90/225/48 117/194/48 118/197/48 91/226/48
f 100/199/47 120/172/47 119/177/47 99/200/47
f 99/203/46 119/173/46 118/176/46 98/204/46
f 97/207/45 117/170/45 120/172/45 100/199/45
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.199500 -0.185900
v 0.125000 0.137000 -0.185900
v 0.125000 0.137000 -0.248400
v 0.125000 0.199500 -0.248400
v 0.156250 0.195500 -0.185900
v 0.156250 0.133000 -0.185900
v 0.156250 0.133000 -0.248400
v 0.156250 0.195500 -0.248400
v 0.093750 0.195500 -0.185900
v 0.093750 0.133000 -0.185900
v 0.093750 0.133000 -0.248400
v 0.093750 0.195500 -0.248400
v 0.109375 0.198500 -0.185900
v 0.109375 0.136000 -0.185900
v 0.109375 0.136000 -0.248400
v 0.109375 0.198500 -0.248400
v 0.140625 0.198500 -0.185900
v 0.140625 0.136000 -0.185900
v 0.140625 0.136000 -0.248400
v 0.140625 0.198500 -0.248400
v 0.171875 0.191500 -0.185900
v 0.171875 0.129000 -0.185900
v 0.171875 0.129000 -0.248400
v 0.171875 0.191500 -0.248400
v 0.078125 0.191500 -0.185900
v 0.078125 0.129000 -0.185900
v 0.078125 0.129000 -0.248400
v 0.078125 0.191500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.2480 0.9688 0.0000
vn -0.2480 -0.9688 -0.0000
vn 0.0000 0.0000 -1.0000
vn -0.0000 -0.0000 1.0000
vn 0.1265 -0.9920 -0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1265 0.9920 0.0000
vn 0.0000 1.0000 0.0000
vn -0.1265 -0.9920 -0.0000
vn -0.2184 -0.9759 -0.0000
vn 0.1265 0.9920 0.0000
vn 0.2184 0.9759 0.0000
vn -0.2480 0.9688 0.0000
vn -0.2184 0.9759 0.0000
vn 0.2480 -0.9688 -0.0000
vn 0.2184 -0.9759 -0.0000
s 1
f 121/227/49 124/228/49 123/229/49 122/230/49
f 125/231/50 128/232/50 127/233/50 126/234/50
f 149/235/51 126/236/51 125/231/51 152/237/51
f 151/238/52 128/239/52 127/240/52 150/241/52
f 152/237/53 125/231/53 128/232/53 151/242/53
f 153/243/54 121/227/54 124/228/54 154/244/54
f 145/245/54 129/246/54 130/247/54 146/248/54
f 144/249/53 132/250/53 131/251/53 143/252/53
f 143/253/55 131/254/56 130/255/56 142/256/55
f 141/257/57 129/258/58 132/250/58 144/249/57
f 149/259/54 133/260/54 134/261/54 150/262/54
f 148/263/53 136/264/53 135/265/53 147/266/53
f 147/267/59 135/268/60 134/269/60 146/270/59
f 145/271/61 133/272/62 136/264/62 148/263/61
f 153/273/63 137/274/64 140/275/64 156/276/63
f 155/277/65 139/278/66 138/279/66 154/280/65
f 156/276/53 140/275/53 139/281/53 155/282/53
f 141/283/54 137/284/54 138/285/54 142/286/54
f 129/246/54 141/283/54 142/286/54 130/247/54
f 137/274/64 141/257/57 144/249/57 140/275/64
f 139/278/66 143/253/55 142/256/55 138/279/66
f 140/275/53 144/249/53 143/252/53 139/281/53
f 129/258/58 145/271/61 148/263/61 132/250/58
f 131/254/56 147/267/59 146/270/59 130/255/56
f 132/250/53 148/263/53 147/266/53 131/251/53
f 133/260/54 145/245/54 146/248/54 134/261/54
f 126/287/54 149/259/54 150/262/54 127/288/54
f 136/264/53 152/237/53 151/242/53 135/265/53
f 135/268/60 151/238/52 150/241/52 134/269/60
f 133/272/62 149/235/51 152/237/51 136/264/62
f 122/230/53 156/276/53 155/282/53 123/229/53
f 123/289/65 155/277/65 154/280/65 124/290/65
f 121/291/63 153/273/63 156/276/63 122/230/63
f 137/284/54 153/243/54 154/244/54 138/285/54
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
v 0.156250 0.375000 -0.193700
v 0.156250 0.312500 -0.193700
v 0.156250 0.312500 -0.256200
v 0.156250 0.375000 -0.256200
v 0.093750 0.375000 -0.193700
v 0.093750 0.312500 -0.193700
v 0.093750 0.312500 -0.256200
v 0.093750 0.375000 -0.256200
v 0.140625 0.375000 -0.193700
v 0.140625 0.312500 -0.193700
v 0.140625 0.312500 -0.256200
v 0.140625 0.375000 -0.256200
v 0.171875 0.375000 -0.193700
v 0.171875 0.312500 -0.193700
v 0.171875 0.312500 -0.256200
v 0.171875 0.375000 -0.256200
v 0.109375 0.375000 -0.193700
v 0.109375 0.312500 -0.193700
v 0.109375 0.312500 -0.256200
v 0.109375 0.375000 -0.256200
v 0.078125 0.375000 -0.193700
v 0.078125 0.312500 -0.193700
v 0.078125 0.312500 -0.256200
v 0.078125 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 157/292/67 160/293/67 159/294/67 158/295/67
f 161/296/68 164/297/68 163/298/68 162/299/68
f 181/300/69 162/301/69 161/296/69 184/302/69
f 183/303/70 164/304/70 163/305/70 182/306/70
f 184/302/71 161/296/71 164/297/71 183/307/71
f 189/308/72 157/292/72 160/293/72 190/309/72
f 177/310/72 165/311/72 166/312/72 178/313/72
f 188/314/71 168/315/71 167/316/71 187/317/71
f 187/318/70 167/319/70 166/320/70 186/321/70
f 185/322/69 165/323/69 168/315/69 188/314/69
f 181/324/72 169/325/72 170/326/72 182/327/72
f 180/328/71 172/329/71 171/330/71 179/331/71
f 179/332/70 171/333/70 170/334/70 178/335/70
f 177/336/69 169/337/69 172/329/69 180/328/69
f 189/338/69 173/339/69 176/340/69 192/341/69
f 191/342/70 175/343/70 174/344/70 190/345/70
f 192/341/71 176/340/71 175/346/71 191/347/71
f 185/348/72 173/349/72 174/350/72 186/351/72
f 165/323/69 177/336/69 180/328/69 168/315/69
f 167/319/70 179/332/70 178/335/70 166/320/70
f 168/315/71 180/328/71 179/331/71 167/316/71
f 169/325/72 177/310/72 178/313/72 170/326/72
f 162/352/72 181/324/72 182/327/72 163/353/72
f 172/329/71 184/302/71 183/307/71 171/330/71
f 171/333/70 183/303/70 182/306/70 170/334/70
f 169/337/69 181/300/69 184/302/69 172/329/69
f 165/311/72 185/348/72 186/351/72 166/312/72
f 173/339/69 185/322/69 188/314/69 176/340/69
f 175/343/70 187/318/70 186/321/70 174/344/70
f 176/340/71 188/314/71 187/317/71 175/346/71
f 158/295/71 192/341/71 191/347/71 159/294/71
f 159/354/70 191/342/70 190/345/70 160/355/70
f 157/356/69 189/338/69 192/341/69 158/295/69
f 173/349/72 189/308/72 190/309/72 174/350/72
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
v -0.093750 0.187500 -0.185900
v -0.093750 0.125000 -0.185900
v -0.093750 0.125000 -0.248400
v -0.093750 0.187500 -0.248400
v -0.109375 0.187500 -0.185900
v -0.109375 0.125000 -0.185900
v -0.109375 0.125000 -0.248400
v -0.109375 0.187500 -0.248400
v -0.078125 0.187500 -0.185900
v -0.078125 0.125000 -0.185900
v -0.078125 0.125000 -0.248400
v -0.078125 0.187500 -0.248400
v -0.156250 0.187500 -0.185900
v -0.156250 0.125000 -0.185900
v -0.156250 0.125000 -0.248400
v -0.156250 0.187500 -0.248400
v -0.140625 0.187500 -0.185900
v -0.140625 0.125000 -0.185900
v -0.140625 0.125000 -0.248400
v -0.140625 0.187500 -0.248400
v -0.171875 0.187500 -0.185900
v -0.171875 0.125000 -0.185900
v -0.171875 0.125000 -0.248400
v -0.171875 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 193/357/73 196/358/73 195/359/73 194/360/73
f 197/361/74 200/362/74 199/363/74 198/364/74
f 213/365/75 198/366/75 197/361/75 216/367/75
f 215/368/76 200/369/76 199/370/76 214/371/76
f 216/367/77 197/361/77 200/362/77 215/372/77
f 225/373/78 193/357/78 196/358/78 226/374/78
f 209/375/78 201/376/78 202/377/78 210/378/78
f 224/379/77 204/380/77 203/381/77 223/382/77
f 223/383/76 203/384/76 202/385/76 222/386/76
f 221/387/75 201/388/75 204/380/75 224/379/75
f 213/389/78 205/390/78 206/391/78 214/392/78
f 212/393/77 208/394/77 207/395/77 211/396/77
f 211/397/76 207/398/76 206/399/76 210/400/76
f 209/401/75 205/402/75 208/394/75 212/393/75
f 201/388/75 209/401/75 212/393/75 204/380/75
f 203/384/76 211/397/76 210/400/76 202/385/76
f 204/380/77 212/393/77 211/396/77 203/381/77
f 205/390/78 209/375/78 210/378/78 206/391/78
f 198/403/78 213/389/78 214/392/78 199/404/78
f 208/394/77 216/367/77 215/372/77 207/395/77
f 207/398/76 215/368/76 214/371/76 206/399/76
f 205/402/75 213/365/75 216/367/75 208/394/75
f 225/405/75 217/406/75 220/407/75 228/408/75
f 227/409/76 219/410/76 218/411/76 226/412/76
f 228/408/77 220/407/77 219/413/77 227/414/77
f 221/415/78 217/416/78 218/417/78 222/418/78
f 201/376/78 221/415/78 222/418/78 202/377/78
f 217/406/75 221/387/75 224/379/75 220/407/75
f 219/410/76 223/383/76 222/386/76 218/411/76
f 220/407/77 224/379/77 223/382/77 219/413/77
f 194/360/77 228/408/77 227/414/77 195/359/77
f 195/419/76 227/409/76 226/412/76 196/420/76
f 193/421/75 225/405/75 228/408/75 194/360/75
f 217/416/78 225/373/78 226/374/78 218/417/78
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
v -0.093750 0.375000 -0.193700
v -0.093750 0.312500 -0.193700
v -0.093750 0.312500 -0.256200
v -0.093750 0.375000 -0.256200
v -0.078125 0.375000 -0.193700
v -0.078125 0.312500 -0.193700
v -0.078125 0.312500 -0.256200
v -0.078125 0.375000 -0.256200
v -0.109375 0.375000 -0.193700
v -0.109375 0.312500 -0.193700
v -0.109375 0.312500 -0.256200
v -0.109375 0.375000 -0.256200
v -0.156250 0.375000 -0.193700
v -0.156250 0.312500 -0.193700
v -0.156250 0.312500 -0.256200
v -0.156250 0.375000 -0.256200
v -0.140625 0.375000 -0.193700
v -0.140625 0.312500 -0.193700
v -0.140625 0.312500 -0.256200
v -0.140625 0.375000 -0.256200
v -0.171875 0.375000 -0.193700
v -0.171875 0.312500 -0.193700
v -0.171875 0.312500 -0.256200
v -0.171875 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 229/422/79 232/423/79 231/424/79 230/425/79
f 233/426/80 236/427/80 235/428/80 234/429/80
f 245/430/81 234/431/81 233/426/81 248/432/81
f 247/433/82 236/434/82 235/435/82 246/436/82
f 248/432/83 233/426/83 236/427/83 247/437/83
f 261/438/84 229/422/84 232/423/84 262/439/84
f 249/440/84 237/441/84 238/442/84 250/443/84
f 260/444/83 240/445/83 239/446/83 259/447/83
f 259/448/82 239/449/82 238/450/82 258/451/82
f 257/452/81 237/453/81 240/445/81 260/444/81
f 245/454/84 241/455/84 242/456/84 246/457/84
f 252/458/83 244/459/83 243/460/83 251/461/83
f 251/462/82 243/463/82 242/464/82 250/465/82
f 249/466/81 241/467/81 244/459/81 252/458/81
f 234/468/84 245/454/84 246/457/84 235/469/84
f 244/459/83 248/432/83 247/437/83 243/460/83
f 243/463/82 247/433/82 246/436/82 242/464/82
f 241/467/81 245/430/81 248/432/81 244/459/81
f 237/453/81 249/466/81 252/458/81 240/445/81
f 239/449/82 251/462/82 250/465/82 238/450/82
f 240/445/83 252/458/83 251/461/83 239/446/83
f 241/455/84 249/440/84 250/443/84 242/456/84
f 261/470/81 253/471/81 256/472/81 264/473/81
f 263/474/82 255/475/82 254/476/82 262/477/82
f 264/473/83 256/472/83 255/478/83 263/479/83
f 257/480/84 253/481/84 254/482/84 258/483/84
f 237/441/84 257/480/84 258/483/84 238/442/84
f 253/471/81 257/452/81 260/444/81 256/472/81
f 255/475/82 259/448/82 258/451/82 254/476/82
f 256/472/83 260/444/83 259/447/83 255/478/83
f 230/425/83 264/473/83 263/479/83 231/424/83
f 231/484/82 263/474/82 262/477/82 232/485/82
f 229/486/81 261/470/81 264/473/81 230/425/81
f 253/481/84 261/438/84 262/439/84 254/482/84


==================================================

--- Файл №590 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1\eyelid_rt.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r_2
v 0.187400 0.312500 -0.193700
v 0.187400 0.312500 -0.256200
v 0.187400 0.250000 -0.256200
v 0.187400 0.250000 -0.193700
v 0.249900 0.312500 -0.256200
v 0.249900 0.312500 -0.193700
v 0.249900 0.250000 -0.193700
v 0.249900 0.250000 -0.256200
vt 0.187500 0.437500
vt 0.187500 0.375000
vt 0.125000 0.375000
vt 0.125000 0.437500
vt 0.062500 0.437500
vt 0.062500 0.375000
vt 0.000000 0.375000
vt 0.000000 0.437500
vt 0.125000 0.500000
vt 0.062500 0.500000
vt 0.187500 0.437500
vt 0.125000 0.437500
vt 0.125000 0.500000
vt 0.187500 0.500000
vt 0.250000 0.437500
vt 0.250000 0.375000
vn -1.0000 -0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 1/1/1 4/2/1 3/3/1 2/4/1
f 5/5/2 8/6/2 7/7/2 6/8/2
f 1/9/3 6/10/3 5/5/3 2/4/3
f 3/11/4 8/12/4 7/13/4 4/14/4
f 2/4/5 5/5/5 8/6/5 3/3/5
f 6/15/6 1/1/6 4/2/6 7/16/6
o eye_r_pupil
v 0.061900 0.312500 -0.184400
v 0.061900 0.312500 -0.246900
v 0.061900 0.187500 -0.246900
v 0.061900 0.187500 -0.184400
v 0.124400 0.312500 -0.246900
v 0.124400 0.312500 -0.184400
v 0.124400 0.187500 -0.184400
v 0.124400 0.187500 -0.246900
vt 0.187500 0.937500
vt 0.187500 0.812500
vt 0.125000 0.812500
vt 0.125000 0.937500
vt 0.062500 0.937500
vt 0.062500 0.812500
vt 0.000000 0.812500
vt 0.000000 0.937500
vt 0.125000 1.000000
vt 0.062500 1.000000
vt 0.187500 0.937500
vt 0.125000 0.937500
vt 0.125000 1.000000
vt 0.187500 1.000000
vt 0.250000 0.937500
vt 0.250000 0.812500
vn -1.0000 -0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 9/17/7 12/18/7 11/19/7 10/20/7
f 13/21/8 16/22/8 15/23/8 14/24/8
f 9/25/9 14/26/9 13/21/9 10/20/9
f 11/27/10 16/28/10 15/29/10 12/30/10
f 10/20/11 13/21/11 16/22/11 11/19/11
f 14/31/12 9/17/12 12/18/12 15/32/12
o eye_l
v -0.187500 0.312500 -0.175100
v -0.187500 0.312500 -0.237600
v -0.187500 0.187500 -0.237600
v -0.187500 0.187500 -0.175100
v -0.062500 0.312500 -0.237600
v -0.062500 0.312500 -0.175100
v -0.062500 0.187500 -0.175100
v -0.062500 0.187500 -0.237600
vt 0.625000 0.750000
vt 0.625000 0.625000
vt 0.562500 0.625000
vt 0.562500 0.750000
vt 0.437500 0.750000
vt 0.437500 0.625000
vt 0.375000 0.625000
vt 0.375000 0.750000
vt 0.562500 0.812500
vt 0.437500 0.812500
vt 0.687500 0.750000
vt 0.562500 0.750000
vt 0.562500 0.812500
vt 0.687500 0.812500
vt 0.750000 0.750000
vt 0.750000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 17/33/13 20/34/13 19/35/13 18/36/13
f 21/37/14 24/38/14 23/39/14 22/40/14
f 17/41/15 22/42/15 21/37/15 18/36/15
f 19/43/16 24/44/16 23/45/16 20/46/16
f 18/36/17 21/37/17 24/38/17 19/35/17
f 22/47/18 17/33/18 20/34/18 23/48/18
o eye_l_pupil
v -0.124400 0.312500 -0.184400
v -0.124400 0.312500 -0.246900
v -0.124400 0.187500 -0.246900
v -0.124400 0.187500 -0.184400
v -0.061900 0.312500 -0.246900
v -0.061900 0.312500 -0.184400
v -0.061900 0.187500 -0.184400
v -0.061900 0.187500 -0.246900
vt 0.562500 0.937500
vt 0.562500 0.812500
vt 0.500000 0.812500
vt 0.500000 0.937500
vt 0.437500 0.937500
vt 0.437500 0.812500
vt 0.375000 0.812500
vt 0.375000 0.937500
vt 0.500000 1.000000
vt 0.437500 1.000000
vt 0.562500 0.937500
vt 0.500000 0.937500
vt 0.500000 1.000000
vt 0.562500 1.000000
vt 0.625000 0.937500
vt 0.625000 0.812500
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/49/19 28/50/19 27/51/19 26/52/19
f 29/53/20 32/54/20 31/55/20 30/56/20
f 25/57/21 30/58/21 29/53/21 26/52/21
f 27/59/22 32/60/22 31/61/22 28/62/22
f 26/52/23 29/53/23 32/54/23 27/51/23
f 30/63/24 25/49/24 28/50/24 31/64/24
o eye_r
v 0.062500 0.312500 -0.175100
v 0.062500 0.312500 -0.237600
v 0.062500 0.187500 -0.237600
v 0.062500 0.187500 -0.175100
v 0.187500 0.312500 -0.237600
v 0.187500 0.312500 -0.175100
v 0.187500 0.187500 -0.175100
v 0.187500 0.187500 -0.237600
vt 0.250000 0.750000
vt 0.250000 0.625000
vt 0.187500 0.625000
vt 0.187500 0.750000
vt 0.062500 0.750000
vt 0.062500 0.625000
vt 0.000000 0.625000
vt 0.000000 0.750000
vt 0.187500 0.812500
vt 0.062500 0.812500
vt 0.312500 0.750000
vt 0.187500 0.750000
vt 0.187500 0.812500
vt 0.312500 0.812500
vt 0.375000 0.750000
vt 0.375000 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 33/65/25 36/66/25 35/67/25 34/68/25
f 37/69/26 40/70/26 39/71/26 38/72/26
f 33/73/27 38/74/27 37/69/27 34/68/27
f 35/75/28 40/76/28 39/77/28 36/78/28
f 34/68/29 37/69/29 40/70/29 35/67/29
f 38/79/30 33/65/30 36/66/30 39/80/30
o eyebrow_l_2
v -0.249900 0.312500 -0.193700
v -0.249900 0.312500 -0.256200
v -0.249900 0.250000 -0.256200
v -0.249900 0.250000 -0.193700
v -0.187400 0.312500 -0.256200
v -0.187400 0.312500 -0.193700
v -0.187400 0.250000 -0.193700
v -0.187400 0.250000 -0.256200
vt 0.562500 0.437500
vt 0.562500 0.375000
vt 0.500000 0.375000
vt 0.500000 0.437500
vt 0.437500 0.437500
vt 0.437500 0.375000
vt 0.375000 0.375000
vt 0.375000 0.437500
vt 0.500000 0.500000
vt 0.437500 0.500000
vt 0.562500 0.437500
vt 0.500000 0.437500
vt 0.500000 0.500000
vt 0.562500 0.500000
vt 0.625000 0.437500
vt 0.625000 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 0.0000 1.0000
s 1
f 41/81/31 44/82/31 43/83/31 42/84/31
f 45/85/32 48/86/32 47/87/32 46/88/32
f 41/89/33 46/90/33 45/85/33 42/84/33
f 43/91/34 48/92/34 47/93/34 44/94/34
f 42/84/35 45/85/35 48/86/35 43/83/35
f 46/95/36 41/81/36 44/82/36 47/96/36
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
v -0.093750 0.375000 -0.185900
v -0.093750 0.312500 -0.185900
v -0.093750 0.312500 -0.248400
v -0.093750 0.375000 -0.248400
v -0.078125 0.375000 -0.185900
v -0.078125 0.312500 -0.185900
v -0.078125 0.312500 -0.248400
v -0.078125 0.375000 -0.248400
v -0.109375 0.375000 -0.185900
v -0.109375 0.312500 -0.185900
v -0.109375 0.312500 -0.248400
v -0.109375 0.375000 -0.248400
v -0.156250 0.375000 -0.185900
v -0.156250 0.312500 -0.185900
v -0.156250 0.312500 -0.248400
v -0.156250 0.375000 -0.248400
v -0.140625 0.375000 -0.185900
v -0.140625 0.312500 -0.185900
v -0.140625 0.312500 -0.248400
v -0.140625 0.375000 -0.248400
v -0.171875 0.375000 -0.185900
v -0.171875 0.312500 -0.185900
v -0.171875 0.312500 -0.248400
v -0.171875 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.625000 0.250000
vt 0.562500 0.250000
vt 0.562500 0.312500
vt 0.437500 0.312500
vt 0.437500 0.250000
vt 0.375000 0.250000
vt 0.375000 0.312500
vt 0.453125 0.375000
vt 0.437500 0.375000
vt 0.453125 0.312500
vt 0.578125 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.578125 0.375000
vt 0.453125 0.250000
vt 0.640625 0.312500
vt 0.640625 0.250000
vt 0.703125 0.312500
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.703125 0.250000
vt 0.515625 0.312500
vt 0.500000 0.312500
vt 0.500000 0.250000
vt 0.515625 0.250000
vt 0.640625 0.312500
vt 0.625000 0.312500
vt 0.625000 0.375000
vt 0.640625 0.375000
vt 0.515625 0.375000
vt 0.500000 0.375000
vt 0.734375 0.312500
vt 0.718750 0.312500
vt 0.718750 0.250000
vt 0.734375 0.250000
vt 0.484375 0.312500
vt 0.468750 0.312500
vt 0.468750 0.250000
vt 0.484375 0.250000
vt 0.609375 0.312500
vt 0.593750 0.312500
vt 0.593750 0.375000
vt 0.609375 0.375000
vt 0.484375 0.375000
vt 0.468750 0.375000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.546875 0.375000
vt 0.531250 0.375000
vt 0.531250 0.312500
vt 0.546875 0.312500
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.375000
vt 0.671875 0.375000
vt 0.531250 0.250000
vt 0.546875 0.250000
vt 0.671875 0.312500
vt 0.656250 0.312500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/97/37 52/98/37 51/99/37 50/100/37
f 53/101/38 56/102/38 55/103/38 54/104/38
f 65/105/39 54/106/39 53/101/39 68/107/39
f 67/108/40 56/109/40 55/110/40 66/111/40
f 68/107/41 53/101/41 56/102/41 67/112/41
f 81/113/42 49/97/42 52/98/42 82/114/42
f 69/115/42 57/116/42 58/117/42 70/118/42
f 80/119/41 60/120/41 59/121/41 79/122/41
f 79/123/40 59/124/40 58/125/40 78/126/40
f 77/127/39 57/128/39 60/120/39 80/119/39
f 65/129/42 61/130/42 62/131/42 66/132/42
f 72/133/41 64/134/41 63/135/41 71/136/41
f 71/137/40 63/138/40 62/139/40 70/140/40
f 69/141/39 61/142/39 64/134/39 72/133/39
f 54/143/42 65/129/42 66/132/42 55/144/42
f 64/134/41 68/107/41 67/112/41 63/135/41
f 63/138/40 67/108/40 66/111/40 62/139/40
f 61/142/39 65/105/39 68/107/39 64/134/39
f 57/128/39 69/141/39 72/133/39 60/120/39
f 59/124/40 71/137/40 70/140/40 58/125/40
f 60/120/41 72/133/41 71/136/41 59/121/41
f 61/130/42 69/115/42 70/118/42 62/131/42
f 81/145/39 73/146/39 76/147/39 84/148/39
f 83/149/40 75/150/40 74/151/40 82/152/40
f 84/148/41 76/147/41 75/153/41 83/154/41
f 77/155/42 73/156/42 74/157/42 78/158/42
f 57/116/42 77/155/42 78/158/42 58/117/42
f 73/146/39 77/127/39 80/119/39 76/147/39
f 75/150/40 79/123/40 78/126/40 74/151/40
f 76/147/41 80/119/41 79/122/41 75/153/41
f 50/100/41 84/148/41 83/154/41 51/99/41
f 51/159/40 83/149/40 82/152/40 52/160/40
f 49/161/39 81/145/39 84/148/39 50/100/39
f 73/156/42 81/113/42 82/114/42 74/157/42
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.387000 -0.185900
v 0.125000 0.324500 -0.185900
v 0.125000 0.324500 -0.248400
v 0.125000 0.387000 -0.248400
v 0.156250 0.383000 -0.185900
v 0.156250 0.320500 -0.185900
v 0.156250 0.320500 -0.248400
v 0.156250 0.383000 -0.248400
v 0.093750 0.383000 -0.185900
v 0.093750 0.320500 -0.185900
v 0.093750 0.320500 -0.248400
v 0.093750 0.383000 -0.248400
v 0.109375 0.386000 -0.185900
v 0.109375 0.323500 -0.185900
v 0.109375 0.323500 -0.248400
v 0.109375 0.386000 -0.248400
v 0.078125 0.379000 -0.185900
v 0.078125 0.316500 -0.185900
v 0.078125 0.316500 -0.248400
v 0.078125 0.379000 -0.248400
v 0.140625 0.386000 -0.185900
v 0.140625 0.323500 -0.185900
v 0.140625 0.323500 -0.248400
v 0.140625 0.386000 -0.248400
v 0.171875 0.379000 -0.185900
v 0.171875 0.316500 -0.185900
v 0.171875 0.316500 -0.248400
v 0.171875 0.379000 -0.248400
vt 0.250000 0.312500
vt 0.250000 0.250000
vt 0.187500 0.250000
vt 0.187500 0.312500
vt 0.062500 0.312500
vt 0.062500 0.250000
vt 0.000000 0.250000
vt 0.000000 0.312500
vt 0.078125 0.375000
vt 0.062500 0.375000
vt 0.078125 0.312500
vt 0.203125 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.203125 0.375000
vt 0.078125 0.250000
vt 0.265625 0.312500
vt 0.265625 0.250000
vt 0.328125 0.312500
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.328125 0.250000
vt 0.140625 0.312500
vt 0.125000 0.312500
vt 0.125000 0.250000
vt 0.140625 0.250000
vt 0.265625 0.312500
vt 0.250000 0.312500
vt 0.250000 0.375000
vt 0.265625 0.375000
vt 0.140625 0.375000
vt 0.125000 0.375000
vt 0.359375 0.312500
vt 0.343750 0.312500
vt 0.343750 0.250000
vt 0.359375 0.250000
vt 0.109375 0.312500
vt 0.093750 0.312500
vt 0.093750 0.250000
vt 0.109375 0.250000
vt 0.234375 0.312500
vt 0.218750 0.312500
vt 0.218750 0.375000
vt 0.234375 0.375000
vt 0.109375 0.375000
vt 0.093750 0.375000
vt 0.171875 0.375000
vt 0.156250 0.375000
vt 0.156250 0.312500
vt 0.171875 0.312500
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.375000
vt 0.296875 0.375000
vt 0.156250 0.250000
vt 0.171875 0.250000
vt 0.296875 0.312500
vt 0.281250 0.312500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vt 0.375000 0.312500
vt 0.375000 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.2480 0.9688 0.0000
vn -0.2480 -0.9688 0.0000
vn -0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1265 -0.9920 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1265 0.9920 0.0000
vn 0.0000 1.0000 0.0000
vn -0.1265 -0.9920 0.0000
vn -0.2184 -0.9759 0.0000
vn 0.1265 0.9920 0.0000
vn 0.2184 0.9759 0.0000
vn -0.2480 0.9688 0.0000
vn -0.2184 0.9759 0.0000
vn 0.2480 -0.9688 0.0000
vn 0.2184 -0.9759 0.0000
s 1
f 85/162/43 88/163/43 87/164/43 86/165/43
f 89/166/44 92/167/44 91/168/44 90/169/44
f 117/170/45 90/171/45 89/166/45 120/172/45
f 119/173/46 92/174/46 91/175/46 118/176/46
f 120/172/47 89/166/47 92/167/47 119/177/47
f 109/178/48 85/162/48 88/163/48 110/179/48
f 113/180/48 93/181/48 94/182/48 114/183/48
f 108/184/47 96/185/47 95/186/47 107/187/47
f 107/188/49 95/189/50 94/190/50 106/191/49
f 105/192/51 93/193/52 96/185/52 108/184/51
f 117/194/48 97/195/48 98/196/48 118/197/48
f 116/198/47 100/199/47 99/200/47 115/201/47
f 115/202/53 99/203/54 98/204/54 114/205/53
f 113/206/55 97/207/56 100/199/56 116/198/55
f 109/208/57 101/209/58 104/210/58 112/211/57
f 111/212/59 103/213/60 102/214/60 110/215/59
f 112/211/47 104/210/47 103/216/47 111/217/47
f 105/218/48 101/219/48 102/220/48 106/221/48
f 93/181/48 105/218/48 106/221/48 94/182/48
f 101/209/58 105/192/51 108/184/51 104/210/58
f 103/213/60 107/188/49 106/191/49 102/214/60
f 104/210/47 108/184/47 107/187/47 103/216/47
f 86/165/47 112/211/47 111/217/47 87/164/47
f 87/222/59 111/212/59 110/215/59 88/223/59
f 85/224/57 109/208/57 112/211/57 86/165/57
f 101/219/48 109/178/48 110/179/48 102/220/48
f 93/193/52 113/206/55 116/198/55 96/185/52
f 95/189/50 115/202/53 114/205/53 94/190/50
f 96/185/47 116/198/47 115/201/47 95/186/47
f 97/195/48 113/180/48 114/183/48 98/196/48
f 90/225/48 117/194/48 118/197/48 91/226/48
f 100/199/47 120/172/47 119/177/47 99/200/47
f 99/203/54 119/173/46 118/176/46 98/204/54
f 97/207/56 117/170/45 120/172/45 100/199/56
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
v 0.156250 0.187500 -0.185900
v 0.156250 0.125000 -0.185900
v 0.156250 0.125000 -0.248400
v 0.156250 0.187500 -0.248400
v 0.093750 0.187500 -0.185900
v 0.093750 0.125000 -0.185900
v 0.093750 0.125000 -0.248400
v 0.093750 0.187500 -0.248400
v 0.109375 0.187500 -0.185900
v 0.109375 0.125000 -0.185900
v 0.109375 0.125000 -0.248400
v 0.109375 0.187500 -0.248400
v 0.140625 0.187500 -0.185900
v 0.140625 0.125000 -0.185900
v 0.140625 0.125000 -0.248400
v 0.140625 0.187500 -0.248400
v 0.171875 0.187500 -0.185900
v 0.171875 0.125000 -0.185900
v 0.171875 0.125000 -0.248400
v 0.171875 0.187500 -0.248400
v 0.078125 0.187500 -0.185900
v 0.078125 0.125000 -0.185900
v 0.078125 0.125000 -0.248400
v 0.078125 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.250000 0.125000
vt 0.187500 0.125000
vt 0.187500 0.187500
vt 0.062500 0.187500
vt 0.062500 0.125000
vt 0.000000 0.125000
vt 0.000000 0.187500
vt 0.078125 0.250000
vt 0.062500 0.250000
vt 0.078125 0.187500
vt 0.203125 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.203125 0.250000
vt 0.078125 0.125000
vt 0.265625 0.187500
vt 0.265625 0.125000
vt 0.328125 0.187500
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.328125 0.125000
vt 0.140625 0.187500
vt 0.125000 0.187500
vt 0.125000 0.125000
vt 0.140625 0.125000
vt 0.265625 0.187500
vt 0.250000 0.187500
vt 0.250000 0.250000
vt 0.265625 0.250000
vt 0.140625 0.250000
vt 0.125000 0.250000
vt 0.359375 0.187500
vt 0.343750 0.187500
vt 0.343750 0.125000
vt 0.359375 0.125000
vt 0.109375 0.187500
vt 0.093750 0.187500
vt 0.093750 0.125000
vt 0.109375 0.125000
vt 0.234375 0.187500
vt 0.218750 0.187500
vt 0.218750 0.250000
vt 0.234375 0.250000
vt 0.109375 0.250000
vt 0.093750 0.250000
vt 0.171875 0.250000
vt 0.156250 0.250000
vt 0.156250 0.187500
vt 0.171875 0.187500
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.250000
vt 0.296875 0.250000
vt 0.156250 0.125000
vt 0.171875 0.125000
vt 0.296875 0.187500
vt 0.281250 0.187500
vt 0.281250 0.125000
vt 0.296875 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 121/227/61 124/228/61 123/229/61 122/230/61
f 125/231/62 128/232/62 127/233/62 126/234/62
f 149/235/63 126/236/63 125/231/63 152/237/63
f 151/238/64 128/239/64 127/240/64 150/241/64
f 152/237/65 125/231/65 128/232/65 151/242/65
f 153/243/66 121/227/66 124/228/66 154/244/66
f 145/245/66 129/246/66 130/247/66 146/248/66
f 144/249/65 132/250/65 131/251/65 143/252/65
f 143/253/64 131/254/64 130/255/64 142/256/64
f 141/257/63 129/258/63 132/250/63 144/249/63
f 149/259/66 133/260/66 134/261/66 150/262/66
f 148/263/65 136/264/65 135/265/65 147/266/65
f 147/267/64 135/268/64 134/269/64 146/270/64
f 145/271/63 133/272/63 136/264/63 148/263/63
f 153/273/63 137/274/63 140/275/63 156/276/63
f 155/277/64 139/278/64 138/279/64 154/280/64
f 156/276/65 140/275/65 139/281/65 155/282/65
f 141/283/66 137/284/66 138/285/66 142/286/66
f 129/246/66 141/283/66 142/286/66 130/247/66
f 137/274/63 141/257/63 144/249/63 140/275/63
f 139/278/64 143/253/64 142/256/64 138/279/64
f 140/275/65 144/249/65 143/252/65 139/281/65
f 129/258/63 145/271/63 148/263/63 132/250/63
f 131/254/64 147/267/64 146/270/64 130/255/64
f 132/250/65 148/263/65 147/266/65 131/251/65
f 133/260/66 145/245/66 146/248/66 134/261/66
f 126/287/66 149/259/66 150/262/66 127/288/66
f 136/264/65 152/237/65 151/242/65 135/265/65
f 135/268/64 151/238/64 150/241/64 134/269/64
f 133/272/63 149/235/63 152/237/63 136/264/63
f 122/230/65 156/276/65 155/282/65 123/229/65
f 123/289/64 155/277/64 154/280/64 124/290/64
f 121/291/63 153/273/63 156/276/63 122/230/63
f 137/284/66 153/243/66 154/244/66 138/285/66
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
v 0.156250 0.375000 -0.193700
v 0.156250 0.312500 -0.193700
v 0.156250 0.312500 -0.256200
v 0.156250 0.375000 -0.256200
v 0.093750 0.375000 -0.193700
v 0.093750 0.312500 -0.193700
v 0.093750 0.312500 -0.256200
v 0.093750 0.375000 -0.256200
v 0.140625 0.375000 -0.193700
v 0.140625 0.312500 -0.193700
v 0.140625 0.312500 -0.256200
v 0.140625 0.375000 -0.256200
v 0.171875 0.375000 -0.193700
v 0.171875 0.312500 -0.193700
v 0.171875 0.312500 -0.256200
v 0.171875 0.375000 -0.256200
v 0.109375 0.375000 -0.193700
v 0.109375 0.312500 -0.193700
v 0.109375 0.312500 -0.256200
v 0.109375 0.375000 -0.256200
v 0.078125 0.375000 -0.193700
v 0.078125 0.312500 -0.193700
v 0.078125 0.312500 -0.256200
v 0.078125 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.250000 0.500000
vt 0.187500 0.500000
vt 0.187500 0.562500
vt 0.062500 0.562500
vt 0.062500 0.500000
vt 0.000000 0.500000
vt 0.000000 0.562500
vt 0.078125 0.625000
vt 0.062500 0.625000
vt 0.078125 0.562500
vt 0.203125 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.203125 0.625000
vt 0.078125 0.500000
vt 0.265625 0.562500
vt 0.265625 0.500000
vt 0.328125 0.562500
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.328125 0.500000
vt 0.140625 0.562500
vt 0.125000 0.562500
vt 0.125000 0.500000
vt 0.140625 0.500000
vt 0.265625 0.562500
vt 0.250000 0.562500
vt 0.250000 0.625000
vt 0.265625 0.625000
vt 0.140625 0.625000
vt 0.125000 0.625000
vt 0.359375 0.562500
vt 0.343750 0.562500
vt 0.343750 0.500000
vt 0.359375 0.500000
vt 0.109375 0.562500
vt 0.093750 0.562500
vt 0.093750 0.500000
vt 0.109375 0.500000
vt 0.234375 0.562500
vt 0.218750 0.562500
vt 0.218750 0.625000
vt 0.234375 0.625000
vt 0.109375 0.625000
vt 0.093750 0.625000
vt 0.171875 0.625000
vt 0.156250 0.625000
vt 0.156250 0.562500
vt 0.171875 0.562500
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.625000
vt 0.296875 0.625000
vt 0.156250 0.500000
vt 0.171875 0.500000
vt 0.296875 0.562500
vt 0.281250 0.562500
vt 0.281250 0.500000
vt 0.296875 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 157/292/67 160/293/67 159/294/67 158/295/67
f 161/296/68 164/297/68 163/298/68 162/299/68
f 181/300/69 162/301/69 161/296/69 184/302/69
f 183/303/70 164/304/70 163/305/70 182/306/70
f 184/302/71 161/296/71 164/297/71 183/307/71
f 189/308/72 157/292/72 160/293/72 190/309/72
f 177/310/72 165/311/72 166/312/72 178/313/72
f 188/314/71 168/315/71 167/316/71 187/317/71
f 187/318/70 167/319/70 166/320/70 186/321/70
f 185/322/69 165/323/69 168/315/69 188/314/69
f 181/324/72 169/325/72 170/326/72 182/327/72
f 180/328/71 172/329/71 171/330/71 179/331/71
f 179/332/70 171/333/70 170/334/70 178/335/70
f 177/336/69 169/337/69 172/329/69 180/328/69
f 189/338/69 173/339/69 176/340/69 192/341/69
f 191/342/70 175/343/70 174/344/70 190/345/70
f 192/341/71 176/340/71 175/346/71 191/347/71
f 185/348/72 173/349/72 174/350/72 186/351/72
f 165/323/69 177/336/69 180/328/69 168/315/69
f 167/319/70 179/332/70 178/335/70 166/320/70
f 168/315/71 180/328/71 179/331/71 167/316/71
f 169/325/72 177/310/72 178/313/72 170/326/72
f 162/352/72 181/324/72 182/327/72 163/353/72
f 172/329/71 184/302/71 183/307/71 171/330/71
f 171/333/70 183/303/70 182/306/70 170/334/70
f 169/337/69 181/300/69 184/302/69 172/329/69
f 165/311/72 185/348/72 186/351/72 166/312/72
f 173/339/69 185/322/69 188/314/69 176/340/69
f 175/343/70 187/318/70 186/321/70 174/344/70
f 176/340/71 188/314/71 187/317/71 175/346/71
f 158/295/71 192/341/71 191/347/71 159/294/71
f 159/354/70 191/342/70 190/345/70 160/355/70
f 157/356/69 189/338/69 192/341/69 158/295/69
f 173/349/72 189/308/72 190/309/72 174/350/72
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
v -0.093750 0.187500 -0.185900
v -0.093750 0.125000 -0.185900
v -0.093750 0.125000 -0.248400
v -0.093750 0.187500 -0.248400
v -0.109375 0.187500 -0.185900
v -0.109375 0.125000 -0.185900
v -0.109375 0.125000 -0.248400
v -0.109375 0.187500 -0.248400
v -0.078125 0.187500 -0.185900
v -0.078125 0.125000 -0.185900
v -0.078125 0.125000 -0.248400
v -0.078125 0.187500 -0.248400
v -0.156250 0.187500 -0.185900
v -0.156250 0.125000 -0.185900
v -0.156250 0.125000 -0.248400
v -0.156250 0.187500 -0.248400
v -0.140625 0.187500 -0.185900
v -0.140625 0.125000 -0.185900
v -0.140625 0.125000 -0.248400
v -0.140625 0.187500 -0.248400
v -0.171875 0.187500 -0.185900
v -0.171875 0.125000 -0.185900
v -0.171875 0.125000 -0.248400
v -0.171875 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.625000 0.125000
vt 0.562500 0.125000
vt 0.562500 0.187500
vt 0.437500 0.187500
vt 0.437500 0.125000
vt 0.375000 0.125000
vt 0.375000 0.187500
vt 0.453125 0.250000
vt 0.437500 0.250000
vt 0.453125 0.187500
vt 0.578125 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.578125 0.250000
vt 0.453125 0.125000
vt 0.640625 0.187500
vt 0.640625 0.125000
vt 0.703125 0.187500
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.703125 0.125000
vt 0.515625 0.187500
vt 0.500000 0.187500
vt 0.500000 0.125000
vt 0.515625 0.125000
vt 0.640625 0.187500
vt 0.625000 0.187500
vt 0.625000 0.250000
vt 0.640625 0.250000
vt 0.515625 0.250000
vt 0.500000 0.250000
vt 0.734375 0.187500
vt 0.718750 0.187500
vt 0.718750 0.125000
vt 0.734375 0.125000
vt 0.484375 0.187500
vt 0.468750 0.187500
vt 0.468750 0.125000
vt 0.484375 0.125000
vt 0.609375 0.187500
vt 0.593750 0.187500
vt 0.593750 0.250000
vt 0.609375 0.250000
vt 0.484375 0.250000
vt 0.468750 0.250000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.546875 0.250000
vt 0.531250 0.250000
vt 0.531250 0.187500
vt 0.546875 0.187500
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.250000
vt 0.671875 0.250000
vt 0.531250 0.125000
vt 0.546875 0.125000
vt 0.671875 0.187500
vt 0.656250 0.187500
vt 0.656250 0.125000
vt 0.671875 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn -1.0000 0.0000 -0.0000
vn 1.0000 -0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 193/357/73 196/358/73 195/359/73 194/360/73
f 197/361/74 200/362/74 199/363/74 198/364/74
f 213/365/75 198/366/75 197/361/75 216/367/75
f 215/368/76 200/369/76 199/370/76 214/371/76
f 216/367/77 197/361/77 200/362/77 215/372/77
f 225/373/78 193/357/78 196/358/78 226/374/78
f 209/375/78 201/376/78 202/377/78 210/378/78
f 224/379/77 204/380/77 203/381/77 223/382/77
f 223/383/76 203/384/76 202/385/76 222/386/76
f 221/387/75 201/388/75 204/380/75 224/379/75
f 213/389/78 205/390/78 206/391/78 214/392/78
f 212/393/77 208/394/77 207/395/77 211/396/77
f 211/397/76 207/398/76 206/399/76 210/400/76
f 209/401/75 205/402/75 208/394/75 212/393/75
f 201/388/75 209/401/75 212/393/75 204/380/75
f 203/384/76 211/397/76 210/400/76 202/385/76
f 204/380/77 212/393/77 211/396/77 203/381/77
f 205/390/78 209/375/78 210/378/78 206/391/78
f 198/403/78 213/389/78 214/392/78 199/404/78
f 208/394/77 216/367/77 215/372/77 207/395/77
f 207/398/76 215/368/76 214/371/76 206/399/76
f 205/402/75 213/365/75 216/367/75 208/394/75
f 225/405/75 217/406/75 220/407/75 228/408/75
f 227/409/76 219/410/76 218/411/76 226/412/76
f 228/408/77 220/407/77 219/413/77 227/414/77
f 221/415/78 217/416/78 218/417/78 222/418/78
f 201/376/78 221/415/78 222/418/78 202/377/78
f 217/406/75 221/387/75 224/379/75 220/407/75
f 219/410/76 223/383/76 222/386/76 218/411/76
f 220/407/77 224/379/77 223/382/77 219/413/77
f 194/360/77 228/408/77 227/414/77 195/359/77
f 195/419/76 227/409/76 226/412/76 196/420/76
f 193/421/75 225/405/75 228/408/75 194/360/75
f 217/416/78 225/373/78 226/374/78 218/417/78
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
v -0.093750 0.375000 -0.193700
v -0.093750 0.312500 -0.193700
v -0.093750 0.312500 -0.256200
v -0.093750 0.375000 -0.256200
v -0.078125 0.375000 -0.193700
v -0.078125 0.312500 -0.193700
v -0.078125 0.312500 -0.256200
v -0.078125 0.375000 -0.256200
v -0.109375 0.375000 -0.193700
v -0.109375 0.312500 -0.193700
v -0.109375 0.312500 -0.256200
v -0.109375 0.375000 -0.256200
v -0.156250 0.375000 -0.193700
v -0.156250 0.312500 -0.193700
v -0.156250 0.312500 -0.256200
v -0.156250 0.375000 -0.256200
v -0.140625 0.375000 -0.193700
v -0.140625 0.312500 -0.193700
v -0.140625 0.312500 -0.256200
v -0.140625 0.375000 -0.256200
v -0.171875 0.375000 -0.193700
v -0.171875 0.312500 -0.193700
v -0.171875 0.312500 -0.256200
v -0.171875 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.625000 0.500000
vt 0.562500 0.500000
vt 0.562500 0.562500
vt 0.437500 0.562500
vt 0.437500 0.500000
vt 0.375000 0.500000
vt 0.375000 0.562500
vt 0.453125 0.625000
vt 0.437500 0.625000
vt 0.453125 0.562500
vt 0.578125 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.578125 0.625000
vt 0.453125 0.500000
vt 0.640625 0.562500
vt 0.640625 0.500000
vt 0.703125 0.562500
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.703125 0.500000
vt 0.515625 0.562500
vt 0.500000 0.562500
vt 0.500000 0.500000
vt 0.515625 0.500000
vt 0.640625 0.562500
vt 0.625000 0.562500
vt 0.625000 0.625000
vt 0.640625 0.625000
vt 0.515625 0.625000
vt 0.500000 0.625000
vt 0.734375 0.562500
vt 0.718750 0.562500
vt 0.718750 0.500000
vt 0.734375 0.500000
vt 0.484375 0.562500
vt 0.468750 0.562500
vt 0.468750 0.500000
vt 0.484375 0.500000
vt 0.609375 0.562500
vt 0.593750 0.562500
vt 0.593750 0.625000
vt 0.609375 0.625000
vt 0.484375 0.625000
vt 0.468750 0.625000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.546875 0.625000
vt 0.531250 0.625000
vt 0.531250 0.562500
vt 0.546875 0.562500
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.625000
vt 0.671875 0.625000
vt 0.531250 0.500000
vt 0.546875 0.500000
vt 0.671875 0.562500
vt 0.656250 0.562500
vt 0.656250 0.500000
vt 0.671875 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn -1.0000 0.0000 -0.0000
vn 1.0000 0.0000 0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 229/422/79 232/423/79 231/424/79 230/425/79
f 233/426/80 236/427/80 235/428/80 234/429/80
f 245/430/81 234/431/81 233/426/81 248/432/81
f 247/433/82 236/434/82 235/435/82 246/436/82
f 248/432/83 233/426/83 236/427/83 247/437/83
f 261/438/84 229/422/84 232/423/84 262/439/84
f 249/440/84 237/441/84 238/442/84 250/443/84
f 260/444/83 240/445/83 239/446/83 259/447/83
f 259/448/82 239/449/82 238/450/82 258/451/82
f 257/452/81 237/453/81 240/445/81 260/444/81
f 245/454/84 241/455/84 242/456/84 246/457/84
f 252/458/83 244/459/83 243/460/83 251/461/83
f 251/462/82 243/463/82 242/464/82 250/465/82
f 249/466/81 241/467/81 244/459/81 252/458/81
f 234/468/84 245/454/84 246/457/84 235/469/84
f 244/459/83 248/432/83 247/437/83 243/460/83
f 243/463/82 247/433/82 246/436/82 242/464/82
f 241/467/81 245/430/81 248/432/81 244/459/81
f 237/453/81 249/466/81 252/458/81 240/445/81
f 239/449/82 251/462/82 250/465/82 238/450/82
f 240/445/83 252/458/83 251/461/83 239/446/83
f 241/455/84 249/440/84 250/443/84 242/456/84
f 261/470/81 253/471/81 256/472/81 264/473/81
f 263/474/82 255/475/82 254/476/82 262/477/82
f 264/473/83 256/472/83 255/478/83 263/479/83
f 257/480/84 253/481/84 254/482/84 258/483/84
f 237/441/84 257/480/84 258/483/84 238/442/84
f 253/471/81 257/452/81 260/444/81 256/472/81
f 255/475/82 259/448/82 258/451/82 254/476/82
f 256/472/83 260/444/83 259/447/83 255/478/83
f 230/425/83 264/473/83 263/479/83 231/424/83
f 231/484/82 263/474/82 262/477/82 232/485/82
f 229/486/81 261/470/81 264/473/81 230/425/81
f 253/481/84 261/438/84 262/439/84 254/482/84


==================================================

--- Файл №591 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\base.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/3 5/5/3 12/11/3
f 11/12/4 8/13/4 7/14/4 10/15/4
f 12/11/5 5/5/5 8/8/5 11/16/5
f 9/17/6 1/1/6 4/4/6 10/18/6
f 6/19/6 9/17/6 10/18/6 7/20/6
f 2/2/5 12/11/5 11/16/5 3/3/5
f 3/21/4 11/12/4 10/15/4 4/22/4
f 1/23/3 9/9/3 12/11/3 2/2/3
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 13/24/7 14/25/7 15/26/7 16/27/7
f 17/28/8 18/29/8 19/30/8 20/31/8
f 21/32/9 18/33/9 17/28/9 24/34/9
f 23/35/10 20/36/10 19/37/10 22/38/10
f 24/34/11 17/28/11 20/31/11 23/39/11
f 21/40/12 13/24/12 16/27/12 22/41/12
f 18/42/12 21/40/12 22/41/12 19/43/12
f 14/25/11 24/34/11 23/39/11 15/26/11
f 15/44/10 23/35/10 22/38/10 16/45/10
f 13/46/9 21/32/9 24/34/9 14/25/9
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 25/47/13 26/48/13 27/49/13 28/50/13
f 29/51/14 30/52/14 31/53/14 32/54/14
f 33/55/15 30/56/15 29/51/15 36/57/15
f 35/58/16 32/59/16 31/60/16 34/61/16
f 36/57/17 29/51/17 32/54/17 35/62/17
f 33/63/18 25/47/18 28/50/18 34/64/18
f 30/65/18 33/63/18 34/64/18 31/66/18
f 26/48/17 36/57/17 35/62/17 27/49/17
f 27/67/16 35/58/16 34/61/16 28/68/16
f 25/69/15 33/55/15 36/57/15 26/48/15
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 37/70/19 38/71/19 39/72/19 40/73/19
f 41/74/20 42/75/20 43/76/20 44/77/20
f 45/78/21 42/79/21 41/74/21 48/80/21
f 47/81/22 44/82/22 43/83/22 46/84/22
f 48/80/23 41/74/23 44/77/23 47/85/23
f 45/86/24 37/70/24 40/73/24 46/87/24
f 42/88/24 45/86/24 46/87/24 43/89/24
f 38/71/23 48/80/23 47/85/23 39/72/23
f 39/90/22 47/81/22 46/84/22 40/91/22
f 37/92/21 45/78/21 48/80/21 38/71/21
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 49/93/25 50/94/25 51/95/25 52/96/25
f 53/97/26 54/98/26 55/99/26 56/100/26
f 57/101/27 54/102/27 53/97/27 60/103/27
f 59/104/28 56/105/28 55/106/28 58/107/28
f 60/103/29 53/97/29 56/100/29 59/108/29
f 57/109/30 49/93/30 52/96/30 58/110/30
f 54/111/30 57/109/30 58/110/30 55/112/30
f 50/94/29 60/103/29 59/108/29 51/95/29
f 51/113/28 59/104/28 58/107/28 52/114/28
f 49/115/27 57/101/27 60/103/27 50/94/27
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
s 1
f 61/116/31 62/117/31 63/118/31 64/119/31
f 65/120/32 66/121/32 67/122/32 68/123/32
f 69/124/33 66/125/33 65/120/33 72/126/33
f 71/127/34 68/128/34 67/129/34 70/130/34
f 72/126/35 65/120/35 68/123/35 71/131/35
f 69/132/36 61/116/36 64/119/36 70/133/36
f 66/134/36 69/132/36 70/133/36 67/135/36
f 62/117/35 72/126/35 71/131/35 63/118/35
f 63/136/34 71/127/34 70/130/34 64/137/34
f 61/138/33 69/124/33 72/126/33 62/117/33


==================================================

--- Файл №592 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\eyebrow_l.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
mtllib eyebrow_l.mtl
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/3 5/5/3 12/11/3
f 11/12/4 8/13/4 7/14/4 10/15/4
f 12/11/5 5/5/5 8/8/5 11/16/5
f 9/17/6 1/1/6 4/4/6 10/18/6
f 6/19/6 9/17/6 10/18/6 7/20/6
f 2/2/5 12/11/5 11/16/5 3/3/5
f 3/21/4 11/12/4 10/15/4 4/22/4
f 1/23/3 9/9/3 12/11/3 2/2/3
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.387000 -0.193700
v -0.125000 0.324500 -0.193700
v -0.125000 0.324500 -0.256200
v -0.125000 0.387000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.1886 0.9821 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1886 -0.9821 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1886 -0.9821 0.0000
vn -0.1886 0.9821 0.0000
usemtl default.002
s 1
f 13/24/7 14/25/7 15/26/7 16/27/7
f 17/28/8 18/29/8 19/30/8 20/31/8
f 21/32/9 18/33/10 17/28/10 24/34/9
f 23/35/11 20/36/12 19/37/12 22/38/11
f 24/34/13 17/28/13 20/31/13 23/39/13
f 21/40/14 13/24/14 16/27/14 22/41/14
f 18/42/14 21/40/14 22/41/14 19/43/14
f 14/25/13 24/34/13 23/39/13 15/26/13
f 15/44/15 23/35/11 22/38/11 16/45/15
f 13/46/16 21/32/9 24/34/9 14/25/16
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 25/47/17 26/48/17 27/49/17 28/50/17
f 29/51/18 30/52/18 31/53/18 32/54/18
f 33/55/19 30/56/19 29/51/19 36/57/19
f 35/58/20 32/59/20 31/60/20 34/61/20
f 36/57/21 29/51/21 32/54/21 35/62/21
f 33/63/22 25/47/22 28/50/22 34/64/22
f 30/65/22 33/63/22 34/64/22 31/66/22
f 26/48/21 36/57/21 35/62/21 27/49/21
f 27/67/20 35/58/20 34/61/20 28/68/20
f 25/69/19 33/55/19 36/57/19 26/48/19
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 37/70/23 38/71/23 39/72/23 40/73/23
f 41/74/24 42/75/24 43/76/24 44/77/24
f 45/78/25 42/79/25 41/74/25 48/80/25
f 47/81/26 44/82/26 43/83/26 46/84/26
f 48/80/27 41/74/27 44/77/27 47/85/27
f 45/86/28 37/70/28 40/73/28 46/87/28
f 42/88/28 45/86/28 46/87/28 43/89/28
f 38/71/27 48/80/27 47/85/27 39/72/27
f 39/90/26 47/81/26 46/84/26 40/91/26
f 37/92/25 45/78/25 48/80/25 38/71/25
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 49/93/29 50/94/29 51/95/29 52/96/29
f 53/97/30 54/98/30 55/99/30 56/100/30
f 57/101/31 54/102/31 53/97/31 60/103/31
f 59/104/32 56/105/32 55/106/32 58/107/32
f 60/103/33 53/97/33 56/100/33 59/108/33
f 57/109/34 49/93/34 52/96/34 58/110/34
f 54/111/34 57/109/34 58/110/34 55/112/34
f 50/94/33 60/103/33 59/108/33 51/95/33
f 51/113/32 59/104/32 58/107/32 52/114/32
f 49/115/31 57/101/31 60/103/31 50/94/31
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 61/116/35 62/117/35 63/118/35 64/119/35
f 65/120/36 66/121/36 67/122/36 68/123/36
f 69/124/37 66/125/37 65/120/37 72/126/37
f 71/127/38 68/128/38 67/129/38 70/130/38
f 72/126/39 65/120/39 68/123/39 71/131/39
f 69/132/40 61/116/40 64/119/40 70/133/40
f 66/134/40 69/132/40 70/133/40 67/135/40
f 62/117/39 72/126/39 71/131/39 63/118/39
f 63/136/38 71/127/38 70/130/38 64/137/38
f 61/138/37 69/124/37 72/126/37 62/117/37


==================================================

--- Файл №593 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\eyebrow_r.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
mtllib eyebrow_r.mtl
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.387000 -0.193700
v 0.125000 0.324500 -0.193700
v 0.125000 0.324500 -0.256200
v 0.125000 0.387000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.1886 0.9821 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1886 -0.9821 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1886 -0.9821 0.0000
vn -0.1886 0.9821 0.0000
usemtl default.002
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/4 5/5/4 12/11/3
f 11/12/5 8/13/6 7/14/6 10/15/5
f 12/11/7 5/5/7 8/8/7 11/16/7
f 9/17/8 1/1/8 4/4/8 10/18/8
f 6/19/8 9/17/8 10/18/8 7/20/8
f 2/2/7 12/11/7 11/16/7 3/3/7
f 3/21/9 11/12/5 10/15/5 4/22/9
f 1/23/10 9/9/3 12/11/3 2/2/10
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 13/24/11 14/25/11 15/26/11 16/27/11
f 17/28/12 18/29/12 19/30/12 20/31/12
f 21/32/13 18/33/13 17/28/13 24/34/13
f 23/35/14 20/36/14 19/37/14 22/38/14
f 24/34/15 17/28/15 20/31/15 23/39/15
f 21/40/16 13/24/16 16/27/16 22/41/16
f 18/42/16 21/40/16 22/41/16 19/43/16
f 14/25/15 24/34/15 23/39/15 15/26/15
f 15/44/14 23/35/14 22/38/14 16/45/14
f 13/46/13 21/32/13 24/34/13 14/25/13
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 25/47/17 26/48/17 27/49/17 28/50/17
f 29/51/18 30/52/18 31/53/18 32/54/18
f 33/55/19 30/56/19 29/51/19 36/57/19
f 35/58/20 32/59/20 31/60/20 34/61/20
f 36/57/21 29/51/21 32/54/21 35/62/21
f 33/63/22 25/47/22 28/50/22 34/64/22
f 30/65/22 33/63/22 34/64/22 31/66/22
f 26/48/21 36/57/21 35/62/21 27/49/21
f 27/67/20 35/58/20 34/61/20 28/68/20
f 25/69/19 33/55/19 36/57/19 26/48/19
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 37/70/23 38/71/23 39/72/23 40/73/23
f 41/74/24 42/75/24 43/76/24 44/77/24
f 45/78/25 42/79/25 41/74/25 48/80/25
f 47/81/26 44/82/26 43/83/26 46/84/26
f 48/80/27 41/74/27 44/77/27 47/85/27
f 45/86/28 37/70/28 40/73/28 46/87/28
f 42/88/28 45/86/28 46/87/28 43/89/28
f 38/71/27 48/80/27 47/85/27 39/72/27
f 39/90/26 47/81/26 46/84/26 40/91/26
f 37/92/25 45/78/25 48/80/25 38/71/25
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 49/93/29 50/94/29 51/95/29 52/96/29
f 53/97/30 54/98/30 55/99/30 56/100/30
f 57/101/31 54/102/31 53/97/31 60/103/31
f 59/104/32 56/105/32 55/106/32 58/107/32
f 60/103/33 53/97/33 56/100/33 59/108/33
f 57/109/34 49/93/34 52/96/34 58/110/34
f 54/111/34 57/109/34 58/110/34 55/112/34
f 50/94/33 60/103/33 59/108/33 51/95/33
f 51/113/32 59/104/32 58/107/32 52/114/32
f 49/115/31 57/101/31 60/103/31 50/94/31
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 61/116/35 62/117/35 63/118/35 64/119/35
f 65/120/36 66/121/36 67/122/36 68/123/36
f 69/124/37 66/125/37 65/120/37 72/126/37
f 71/127/38 68/128/38 67/129/38 70/130/38
f 72/126/39 65/120/39 68/123/39 71/131/39
f 69/132/40 61/116/40 64/119/40 70/133/40
f 66/134/40 69/132/40 70/133/40 67/135/40
f 62/117/39 72/126/39 71/131/39 63/118/39
f 63/136/38 71/127/38 70/130/38 64/137/38
f 61/138/37 69/124/37 72/126/37 62/117/37


==================================================

--- Файл №594 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\eyelid_lb.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
mtllib eyelid_lb.mtl
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/3 5/5/3 12/11/3
f 11/12/4 8/13/4 7/14/4 10/15/4
f 12/11/5 5/5/5 8/8/5 11/16/5
f 9/17/6 1/1/6 4/4/6 10/18/6
f 6/19/6 9/17/6 10/18/6 7/20/6
f 2/2/5 12/11/5 11/16/5 3/3/5
f 3/21/4 11/12/4 10/15/4 4/22/4
f 1/23/3 9/9/3 12/11/3 2/2/3
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 13/24/7 14/25/7 15/26/7 16/27/7
f 17/28/8 18/29/8 19/30/8 20/31/8
f 21/32/9 18/33/9 17/28/9 24/34/9
f 23/35/10 20/36/10 19/37/10 22/38/10
f 24/34/11 17/28/11 20/31/11 23/39/11
f 21/40/12 13/24/12 16/27/12 22/41/12
f 18/42/12 21/40/12 22/41/12 19/43/12
f 14/25/11 24/34/11 23/39/11 15/26/11
f 15/44/10 23/35/10 22/38/10 16/45/10
f 13/46/9 21/32/9 24/34/9 14/25/9
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 25/47/13 26/48/13 27/49/13 28/50/13
f 29/51/14 30/52/14 31/53/14 32/54/14
f 33/55/15 30/56/15 29/51/15 36/57/15
f 35/58/16 32/59/16 31/60/16 34/61/16
f 36/57/17 29/51/17 32/54/17 35/62/17
f 33/63/18 25/47/18 28/50/18 34/64/18
f 30/65/18 33/63/18 34/64/18 31/66/18
f 26/48/17 36/57/17 35/62/17 27/49/17
f 27/67/16 35/58/16 34/61/16 28/68/16
f 25/69/15 33/55/15 36/57/15 26/48/15
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 37/70/19 38/71/19 39/72/19 40/73/19
f 41/74/20 42/75/20 43/76/20 44/77/20
f 45/78/21 42/79/21 41/74/21 48/80/21
f 47/81/22 44/82/22 43/83/22 46/84/22
f 48/80/23 41/74/23 44/77/23 47/85/23
f 45/86/24 37/70/24 40/73/24 46/87/24
f 42/88/24 45/86/24 46/87/24 43/89/24
f 38/71/23 48/80/23 47/85/23 39/72/23
f 39/90/22 47/81/22 46/84/22 40/91/22
f 37/92/21 45/78/21 48/80/21 38/71/21
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 49/93/25 50/94/25 51/95/25 52/96/25
f 53/97/26 54/98/26 55/99/26 56/100/26
f 57/101/27 54/102/27 53/97/27 60/103/27
f 59/104/28 56/105/28 55/106/28 58/107/28
f 60/103/29 53/97/29 56/100/29 59/108/29
f 57/109/30 49/93/30 52/96/30 58/110/30
f 54/111/30 57/109/30 58/110/30 55/112/30
f 50/94/29 60/103/29 59/108/29 51/95/29
f 51/113/28 59/104/28 58/107/28 52/114/28
f 49/115/27 57/101/27 60/103/27 50/94/27
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.199500 -0.185900
v -0.125000 0.137000 -0.185900
v -0.125000 0.137000 -0.248400
v -0.125000 0.199500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.1886 0.9821 0.0000
vn 0.0000 -1.0000 -0.0000
vn -0.1886 -0.9821 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1886 -0.9821 -0.0000
vn -0.1886 0.9821 0.0000
usemtl default.002
s 1
f 61/116/31 62/117/31 63/118/31 64/119/31
f 65/120/32 66/121/32 67/122/32 68/123/32
f 69/124/33 66/125/34 65/120/34 72/126/33
f 71/127/35 68/128/36 67/129/36 70/130/35
f 72/126/37 65/120/37 68/123/37 71/131/37
f 69/132/38 61/116/38 64/119/38 70/133/38
f 66/134/38 69/132/38 70/133/38 67/135/38
f 62/117/37 72/126/37 71/131/37 63/118/37
f 63/136/39 71/127/35 70/130/35 64/137/39
f 61/138/40 69/124/33 72/126/33 62/117/40


==================================================

--- Файл №595 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\eyelid_lt.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
mtllib eyelid_lt.mtl
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/3 5/5/3 12/11/3
f 11/12/4 8/13/4 7/14/4 10/15/4
f 12/11/5 5/5/5 8/8/5 11/16/5
f 9/17/6 1/1/6 4/4/6 10/18/6
f 6/19/6 9/17/6 10/18/6 7/20/6
f 2/2/5 12/11/5 11/16/5 3/3/5
f 3/21/4 11/12/4 10/15/4 4/22/4
f 1/23/3 9/9/3 12/11/3 2/2/3
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 13/24/7 14/25/7 15/26/7 16/27/7
f 17/28/8 18/29/8 19/30/8 20/31/8
f 21/32/9 18/33/9 17/28/9 24/34/9
f 23/35/10 20/36/10 19/37/10 22/38/10
f 24/34/11 17/28/11 20/31/11 23/39/11
f 21/40/12 13/24/12 16/27/12 22/41/12
f 18/42/12 21/40/12 22/41/12 19/43/12
f 14/25/11 24/34/11 23/39/11 15/26/11
f 15/44/10 23/35/10 22/38/10 16/45/10
f 13/46/9 21/32/9 24/34/9 14/25/9
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 25/47/13 26/48/13 27/49/13 28/50/13
f 29/51/14 30/52/14 31/53/14 32/54/14
f 33/55/15 30/56/15 29/51/15 36/57/15
f 35/58/16 32/59/16 31/60/16 34/61/16
f 36/57/17 29/51/17 32/54/17 35/62/17
f 33/63/18 25/47/18 28/50/18 34/64/18
f 30/65/18 33/63/18 34/64/18 31/66/18
f 26/48/17 36/57/17 35/62/17 27/49/17
f 27/67/16 35/58/16 34/61/16 28/68/16
f 25/69/15 33/55/15 36/57/15 26/48/15
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.387000 -0.185900
v -0.125000 0.324500 -0.185900
v -0.125000 0.324500 -0.248400
v -0.125000 0.387000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.1886 0.9821 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1886 -0.9821 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1886 -0.9821 0.0000
vn -0.1886 0.9821 0.0000
usemtl default.002
s 1
f 37/70/19 38/71/19 39/72/19 40/73/19
f 41/74/20 42/75/20 43/76/20 44/77/20
f 45/78/21 42/79/22 41/74/22 48/80/21
f 47/81/23 44/82/24 43/83/24 46/84/23
f 48/80/25 41/74/25 44/77/25 47/85/25
f 45/86/26 37/70/26 40/73/26 46/87/26
f 42/88/26 45/86/26 46/87/26 43/89/26
f 38/71/25 48/80/25 47/85/25 39/72/25
f 39/90/27 47/81/23 46/84/23 40/91/27
f 37/92/28 45/78/21 48/80/21 38/71/28
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 49/93/29 50/94/29 51/95/29 52/96/29
f 53/97/30 54/98/30 55/99/30 56/100/30
f 57/101/31 54/102/31 53/97/31 60/103/31
f 59/104/32 56/105/32 55/106/32 58/107/32
f 60/103/33 53/97/33 56/100/33 59/108/33
f 57/109/34 49/93/34 52/96/34 58/110/34
f 54/111/34 57/109/34 58/110/34 55/112/34
f 50/94/33 60/103/33 59/108/33 51/95/33
f 51/113/32 59/104/32 58/107/32 52/114/32
f 49/115/31 57/101/31 60/103/31 50/94/31
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 61/116/35 62/117/35 63/118/35 64/119/35
f 65/120/36 66/121/36 67/122/36 68/123/36
f 69/124/37 66/125/37 65/120/37 72/126/37
f 71/127/38 68/128/38 67/129/38 70/130/38
f 72/126/39 65/120/39 68/123/39 71/131/39
f 69/132/40 61/116/40 64/119/40 70/133/40
f 66/134/40 69/132/40 70/133/40 67/135/40
f 62/117/39 72/126/39 71/131/39 63/118/39
f 63/136/38 71/127/38 70/130/38 64/137/38
f 61/138/37 69/124/37 72/126/37 62/117/37


==================================================

--- Файл №596 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\eyelid_rb.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
mtllib eyelid_rb.mtl
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/3 5/5/3 12/11/3
f 11/12/4 8/13/4 7/14/4 10/15/4
f 12/11/5 5/5/5 8/8/5 11/16/5
f 9/17/6 1/1/6 4/4/6 10/18/6
f 6/19/6 9/17/6 10/18/6 7/20/6
f 2/2/5 12/11/5 11/16/5 3/3/5
f 3/21/4 11/12/4 10/15/4 4/22/4
f 1/23/3 9/9/3 12/11/3 2/2/3
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 13/24/7 14/25/7 15/26/7 16/27/7
f 17/28/8 18/29/8 19/30/8 20/31/8
f 21/32/9 18/33/9 17/28/9 24/34/9
f 23/35/10 20/36/10 19/37/10 22/38/10
f 24/34/11 17/28/11 20/31/11 23/39/11
f 21/40/12 13/24/12 16/27/12 22/41/12
f 18/42/12 21/40/12 22/41/12 19/43/12
f 14/25/11 24/34/11 23/39/11 15/26/11
f 15/44/10 23/35/10 22/38/10 16/45/10
f 13/46/9 21/32/9 24/34/9 14/25/9
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.199500 -0.185900
v 0.125000 0.137000 -0.185900
v 0.125000 0.137000 -0.248400
v 0.125000 0.199500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.1886 0.9821 0.0000
vn 0.0000 -1.0000 -0.0000
vn -0.1886 -0.9821 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1886 -0.9821 -0.0000
vn -0.1886 0.9821 0.0000
usemtl default.002
s 1
f 25/47/13 26/48/13 27/49/13 28/50/13
f 29/51/14 30/52/14 31/53/14 32/54/14
f 33/55/15 30/56/16 29/51/16 36/57/15
f 35/58/17 32/59/18 31/60/18 34/61/17
f 36/57/19 29/51/19 32/54/19 35/62/19
f 33/63/20 25/47/20 28/50/20 34/64/20
f 30/65/20 33/63/20 34/64/20 31/66/20
f 26/48/19 36/57/19 35/62/19 27/49/19
f 27/67/21 35/58/17 34/61/17 28/68/21
f 25/69/22 33/55/15 36/57/15 26/48/22
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 37/70/23 38/71/23 39/72/23 40/73/23
f 41/74/24 42/75/24 43/76/24 44/77/24
f 45/78/25 42/79/25 41/74/25 48/80/25
f 47/81/26 44/82/26 43/83/26 46/84/26
f 48/80/27 41/74/27 44/77/27 47/85/27
f 45/86/28 37/70/28 40/73/28 46/87/28
f 42/88/28 45/86/28 46/87/28 43/89/28
f 38/71/27 48/80/27 47/85/27 39/72/27
f 39/90/26 47/81/26 46/84/26 40/91/26
f 37/92/25 45/78/25 48/80/25 38/71/25
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.375000 -0.185900
v 0.125000 0.312500 -0.185900
v 0.125000 0.312500 -0.248400
v 0.125000 0.375000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 49/93/29 50/94/29 51/95/29 52/96/29
f 53/97/30 54/98/30 55/99/30 56/100/30
f 57/101/31 54/102/31 53/97/31 60/103/31
f 59/104/32 56/105/32 55/106/32 58/107/32
f 60/103/33 53/97/33 56/100/33 59/108/33
f 57/109/34 49/93/34 52/96/34 58/110/34
f 54/111/34 57/109/34 58/110/34 55/112/34
f 50/94/33 60/103/33 59/108/33 51/95/33
f 51/113/32 59/104/32 58/107/32 52/114/32
f 49/115/31 57/101/31 60/103/31 50/94/31
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 61/116/35 62/117/35 63/118/35 64/119/35
f 65/120/36 66/121/36 67/122/36 68/123/36
f 69/124/37 66/125/37 65/120/37 72/126/37
f 71/127/38 68/128/38 67/129/38 70/130/38
f 72/126/39 65/120/39 68/123/39 71/131/39
f 69/132/40 61/116/40 64/119/40 70/133/40
f 66/134/40 69/132/40 70/133/40 67/135/40
f 62/117/39 72/126/39 71/131/39 63/118/39
f 63/136/38 71/127/38 70/130/38 64/137/38
f 61/138/37 69/124/37 72/126/37 62/117/37


==================================================

--- Файл №597 ---
Путь: main\resources\assets\blockbuster\models\entity\eyes\3.1_simple\eyelid_rt.obj
--------------------
# Blender v2.79 (sub 0) OBJ File: 'eyes31.blend'
# www.blender.org
mtllib eyelid_rt.mtl
o eyebrow_r
v 0.062500 0.375000 -0.193700
v 0.062500 0.375000 -0.256200
v 0.062500 0.312500 -0.256200
v 0.062500 0.312500 -0.193700
v 0.187500 0.375000 -0.256200
v 0.187500 0.375000 -0.193700
v 0.187500 0.312500 -0.193700
v 0.187500 0.312500 -0.256200
v 0.125000 0.375000 -0.193700
v 0.125000 0.312500 -0.193700
v 0.125000 0.312500 -0.256200
v 0.125000 0.375000 -0.256200
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.500000
vt 0.250000 0.500000
vt 0.062500 0.562500
vt 0.000000 0.562500
vt 0.000000 0.500000
vt 0.062500 0.500000
vt 0.125000 0.625000
vt 0.062500 0.625000
vt 0.125000 0.562500
vt 0.250000 0.562500
vt 0.187500 0.562500
vt 0.187500 0.625000
vt 0.250000 0.625000
vt 0.125000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.500000
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.312500 0.562500
vt 0.312500 0.625000
vt 0.187500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 1/1/1 2/2/1 3/3/1 4/4/1
f 5/5/2 6/6/2 7/7/2 8/8/2
f 9/9/3 6/10/3 5/5/3 12/11/3
f 11/12/4 8/13/4 7/14/4 10/15/4
f 12/11/5 5/5/5 8/8/5 11/16/5
f 9/17/6 1/1/6 4/4/6 10/18/6
f 6/19/6 9/17/6 10/18/6 7/20/6
f 2/2/5 12/11/5 11/16/5 3/3/5
f 3/21/4 11/12/4 10/15/4 4/22/4
f 1/23/3 9/9/3 12/11/3 2/2/3
o eyebrow_l
v -0.187500 0.375000 -0.193700
v -0.187500 0.375000 -0.256200
v -0.187500 0.312500 -0.256200
v -0.187500 0.312500 -0.193700
v -0.062500 0.375000 -0.256200
v -0.062500 0.375000 -0.193700
v -0.062500 0.312500 -0.193700
v -0.062500 0.312500 -0.256200
v -0.125000 0.375000 -0.193700
v -0.125000 0.312500 -0.193700
v -0.125000 0.312500 -0.256200
v -0.125000 0.375000 -0.256200
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.500000
vt 0.625000 0.500000
vt 0.437500 0.562500
vt 0.375000 0.562500
vt 0.375000 0.500000
vt 0.437500 0.500000
vt 0.500000 0.625000
vt 0.437500 0.625000
vt 0.500000 0.562500
vt 0.625000 0.562500
vt 0.562500 0.562500
vt 0.562500 0.625000
vt 0.625000 0.625000
vt 0.500000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.500000
vt 0.750000 0.562500
vt 0.750000 0.500000
vt 0.687500 0.562500
vt 0.687500 0.625000
vt 0.562500 0.625000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 13/24/7 14/25/7 15/26/7 16/27/7
f 17/28/8 18/29/8 19/30/8 20/31/8
f 21/32/9 18/33/9 17/28/9 24/34/9
f 23/35/10 20/36/10 19/37/10 22/38/10
f 24/34/11 17/28/11 20/31/11 23/39/11
f 21/40/12 13/24/12 16/27/12 22/41/12
f 18/42/12 21/40/12 22/41/12 19/43/12
f 14/25/11 24/34/11 23/39/11 15/26/11
f 15/44/10 23/35/10 22/38/10 16/45/10
f 13/46/9 21/32/9 24/34/9 14/25/9
o eyelid_rb
v 0.062500 0.187500 -0.185900
v 0.062500 0.187500 -0.248400
v 0.062500 0.125000 -0.248400
v 0.062500 0.125000 -0.185900
v 0.187500 0.187500 -0.248400
v 0.187500 0.187500 -0.185900
v 0.187500 0.125000 -0.185900
v 0.187500 0.125000 -0.248400
v 0.125000 0.187500 -0.185900
v 0.125000 0.125000 -0.185900
v 0.125000 0.125000 -0.248400
v 0.125000 0.187500 -0.248400
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.125000
vt 0.250000 0.125000
vt 0.062500 0.187500
vt 0.000000 0.187500
vt 0.000000 0.125000
vt 0.062500 0.125000
vt 0.125000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.187500
vt 0.250000 0.187500
vt 0.187500 0.187500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.125000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.125000
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.312500 0.187500
vt 0.312500 0.250000
vt 0.187500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 25/47/13 26/48/13 27/49/13 28/50/13
f 29/51/14 30/52/14 31/53/14 32/54/14
f 33/55/15 30/56/15 29/51/15 36/57/15
f 35/58/16 32/59/16 31/60/16 34/61/16
f 36/57/17 29/51/17 32/54/17 35/62/17
f 33/63/18 25/47/18 28/50/18 34/64/18
f 30/65/18 33/63/18 34/64/18 31/66/18
f 26/48/17 36/57/17 35/62/17 27/49/17
f 27/67/16 35/58/16 34/61/16 28/68/16
f 25/69/15 33/55/15 36/57/15 26/48/15
o eyelid_lt
v -0.187500 0.375000 -0.185900
v -0.187500 0.375000 -0.248400
v -0.187500 0.312500 -0.248400
v -0.187500 0.312500 -0.185900
v -0.062500 0.375000 -0.248400
v -0.062500 0.375000 -0.185900
v -0.062500 0.312500 -0.185900
v -0.062500 0.312500 -0.248400
v -0.125000 0.375000 -0.185900
v -0.125000 0.312500 -0.185900
v -0.125000 0.312500 -0.248400
v -0.125000 0.375000 -0.248400
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.437500 0.312500
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.375000
vt 0.437500 0.375000
vt 0.500000 0.312500
vt 0.625000 0.312500
vt 0.562500 0.312500
vt 0.562500 0.375000
vt 0.625000 0.375000
vt 0.500000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.250000
vt 0.750000 0.312500
vt 0.750000 0.250000
vt 0.687500 0.312500
vt 0.687500 0.375000
vt 0.562500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 37/70/19 38/71/19 39/72/19 40/73/19
f 41/74/20 42/75/20 43/76/20 44/77/20
f 45/78/21 42/79/21 41/74/21 48/80/21
f 47/81/22 44/82/22 43/83/22 46/84/22
f 48/80/23 41/74/23 44/77/23 47/85/23
f 45/86/24 37/70/24 40/73/24 46/87/24
f 42/88/24 45/86/24 46/87/24 43/89/24
f 38/71/23 48/80/23 47/85/23 39/72/23
f 39/90/22 47/81/22 46/84/22 40/91/22
f 37/92/21 45/78/21 48/80/21 38/71/21
o eyelid_rt
v 0.062500 0.375000 -0.185900
v 0.062500 0.375000 -0.248400
v 0.062500 0.312500 -0.248400
v 0.062500 0.312500 -0.185900
v 0.187500 0.375000 -0.248400
v 0.187500 0.375000 -0.185900
v 0.187500 0.312500 -0.185900
v 0.187500 0.312500 -0.248400
v 0.125000 0.387000 -0.185900
v 0.125000 0.324500 -0.185900
v 0.125000 0.324500 -0.248400
v 0.125000 0.387000 -0.248400
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.250000
vt 0.250000 0.250000
vt 0.062500 0.312500
vt 0.000000 0.312500
vt 0.000000 0.250000
vt 0.062500 0.250000
vt 0.125000 0.375000
vt 0.062500 0.375000
vt 0.125000 0.312500
vt 0.250000 0.312500
vt 0.187500 0.312500
vt 0.187500 0.375000
vt 0.250000 0.375000
vt 0.125000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.250000
vt 0.375000 0.312500
vt 0.375000 0.250000
vt 0.312500 0.312500
vt 0.312500 0.375000
vt 0.187500 0.375000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.1886 0.9821 0.0000
vn 0.0000 -1.0000 0.0000
vn -0.1886 -0.9821 0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
vn 0.1886 -0.9821 0.0000
vn -0.1886 0.9821 0.0000
usemtl default.002
s 1
f 49/93/25 50/94/25 51/95/25 52/96/25
f 53/97/26 54/98/26 55/99/26 56/100/26
f 57/101/27 54/102/28 53/97/28 60/103/27
f 59/104/29 56/105/30 55/106/30 58/107/29
f 60/103/31 53/97/31 56/100/31 59/108/31
f 57/109/32 49/93/32 52/96/32 58/110/32
f 54/111/32 57/109/32 58/110/32 55/112/32
f 50/94/31 60/103/31 59/108/31 51/95/31
f 51/113/33 59/104/29 58/107/29 52/114/33
f 49/115/34 57/101/27 60/103/27 50/94/34
o eyelid_lb
v -0.187500 0.187500 -0.185900
v -0.187500 0.187500 -0.248400
v -0.187500 0.125000 -0.248400
v -0.187500 0.125000 -0.185900
v -0.062500 0.187500 -0.248400
v -0.062500 0.187500 -0.185900
v -0.062500 0.125000 -0.185900
v -0.062500 0.125000 -0.248400
v -0.125000 0.187500 -0.185900
v -0.125000 0.125000 -0.185900
v -0.125000 0.125000 -0.248400
v -0.125000 0.187500 -0.248400
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.125000
vt 0.625000 0.125000
vt 0.437500 0.187500
vt 0.375000 0.187500
vt 0.375000 0.125000
vt 0.437500 0.125000
vt 0.500000 0.250000
vt 0.437500 0.250000
vt 0.500000 0.187500
vt 0.625000 0.187500
vt 0.562500 0.187500
vt 0.562500 0.250000
vt 0.625000 0.250000
vt 0.500000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.125000
vt 0.750000 0.187500
vt 0.750000 0.125000
vt 0.687500 0.187500
vt 0.687500 0.250000
vt 0.562500 0.250000
vn 1.0000 -0.0000 -0.0000
vn -1.0000 -0.0000 -0.0000
vn 0.0000 1.0000 0.0000
vn 0.0000 -1.0000 -0.0000
vn 0.0000 0.0000 -1.0000
vn 0.0000 -0.0000 1.0000
usemtl default.002
s 1
f 61/116/35 62/117/35 63/118/35 64/119/35
f 65/120/36 66/121/36 67/122/36 68/123/36
f 69/124/37 66/125/37 65/120/37 72/126/37
f 71/127/38 68/128/38 67/129/38 70/130/38
f 72/126/39 65/120/39 68/123/39 71/131/39
f 69/132/40 61/116/40 64/119/40 70/133/40
f 66/134/40 69/132/40 70/133/40 67/135/40
f 62/117/39 72/126/39 71/131/39 63/118/39
f 63/136/38 71/127/38 70/130/38 64/137/38
f 61/138/37 69/124/37 72/126/37 62/117/37


==================================================

--- Файл №598 ---
Путь: main\resources\assets\blockbuster\models\entity\mchorse\head.json
--------------------
{
    "scheme": "1.3",
    "name": "McHorse (head)",
    "default": "blockbuster:textures/entity/mchorse/head.png",
    "texture": [ 32, 32 ],
    "limbs": {
        "mouth": {
            "size": [ 6, 3, 4 ],
            "texture": [ 2, 1 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "is3D": true
        },
        "mane": {
            "size": [ 2, 8, 2 ],
            "texture": [ 0, 8 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "is3D": true
        },
        "outer": {
            "size": [ 8, 8, 8 ],
            "texture": [ 0, 16 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "is3D": true
        },
        "right_ear": {
            "size": [ 2, 4, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ]
        },
        "left_ear": {
            "size": [ 2, 4, 1 ],
            "texture": [ 0, 0 ],
            "anchor": [ 0.5, 0.5, 0.5 ],
            "origin": [ 0.0, 0.0, 0.0 ],
            "mirror": true
        }
    },
    "poses": {
        "standing": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "mouth": {
                    "translate": [ 0.0, 1.55, 5.0 ]
                },
                "mane": {
                    "translate": [ 0.0, 5.0, -4.0 ]
                },
                "outer": {
                    "translate": [ 0.0, 4.0, 0.0 ],
                    "scale": [ 1.1, 1.1, 1.1 ]
                },
                "right_ear": {
                    "translate": [ -2.5, 8.0, -3.0 ]
                },
                "left_ear": {
                    "translate": [ 2.5, 8.0, -3.0 ]
                }
            }
        },
        "flying": {
            "size": [ 0.6, 0.6, 0.6 ],
            "limbs": {
                "mouth": {
                    "translate": [ 0.0, 1.55, 5.0 ]
                },
                "mane": {
                    "translate": [ 0.0, 5.0, -4.0 ]
                },
                "right_ear": {
                    "translate": [ -2.5, 8.0, -3.0 ]
                },
                "left_ear": {
                    "translate": [ 2.5, 8.0, -3.0 ]
                }
            }
        },
        "leaning": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "mouth": {
                    "translate": [ 0.0, 1.55, 5.0 ]
                },
                "mane": {
                    "translate": [ 0.0, 5.0, -4.0 ]
                },
                "right_ear": {
                    "translate": [ -2.5, 8.0, -3.0 ]
                },
                "left_ear": {
                    "translate": [ 2.5, 8.0, -3.0 ]
                }
            }
        },
        "sneaking": {
            "size": [ 0.6, 1.65, 0.6 ],
            "limbs": {
                "mouth": {
                    "translate": [ 0.0, 1.55, 5.0 ]
                },
                "mane": {
                    "translate": [ 0.0, 5.0, -4.0 ]
                },
                "right_ear": {
                    "translate": [ -2.5, 8.0, -3.0 ]
                },
                "left_ear": {
                    "translate": [ 2.5, 8.0, -3.0 ]
                }
            }
        },
        "riding": {
            "size": [ 0.6, 1.8, 0.6 ],
            "limbs": {
                "mouth": {
                    "translate": [ 0.0, 1.55, 5.0 ]
                },
                "mane": {
                    "translate": [ 0.0, 5.0, -4.0 ]
                },
                "right_ear": {
                    "translate": [ -2.5, 8.0, -3.0 ]
                },
                "left_ear": {
                    "translate": [ 2.5, 8.0, -3.0 ]
                }
            }
        },
        "sleeping": {
            "size": [ 0.2, 0.2, 0.2 ],
            "limbs": {
                "mouth": {
                    "translate": [ 0.0, 1.55, 5.0 ]
                },
                "mane": {
                    "translate": [ 0.0, 5.0, -4.0 ]
                },
                "right_ear": {
                    "translate": [ -2.5, 8.0, -3.0 ]
                },
                "left_ear": {
                    "translate": [ 2.5, 8.0, -3.0 ]
                }
            }
        }
    }
}

==================================================

--- Файл №599 ---
Путь: main\resources\assets\blockbuster\models\item\actor_config.json
--------------------
{
    "parent": "item/generated",
    "textures": {
        "layer0": "blockbuster:items/actor_config"
    }
}

==================================================

--- Файл №600 ---
Путь: main\resources\assets\blockbuster\models\item\dim_green.json
--------------------
{
    "parent": "builtin/entity"
}

==================================================

--- Файл №601 ---
Путь: main\resources\assets\blockbuster\models\item\director.json
--------------------
{
	"parent": "blockbuster:block/director_stop"
}

==================================================

--- Файл №602 ---
Путь: main\resources\assets\blockbuster\models\item\green.json
--------------------
{
    "parent": "blockbuster:block/green"
}

==================================================

--- Файл №603 ---
Путь: main\resources\assets\blockbuster\models\item\gun.json
--------------------
{
    "parent": "builtin/entity",
    "display": {
        "head": {
            "rotation": [ 0, -180, 0 ],
            "translation": [ 0, 6.376, 0],
            "scale":[ 1.6, 1.6, 1.6 ]
        }
    }
}

==================================================

--- Файл №604 ---
Путь: main\resources\assets\blockbuster\models\item\model.json
--------------------
{
	"parent": "blockbuster:block/model"
}

==================================================

--- Файл №605 ---
Путь: main\resources\assets\blockbuster\models\item\model_static.json
--------------------
{
	"parent": "blockbuster:block/model_static"
}

==================================================

--- Файл №606 ---
Путь: main\resources\assets\blockbuster\models\item\playback.json
--------------------
{
    "parent": "item/generated",
    "textures": {
        "layer0": "blockbuster:items/playback"
    }
}

==================================================

--- Файл №607 ---
Путь: main\resources\assets\blockbuster\models\item\register.json
--------------------
{
    "parent": "item/handheld",
    "textures": {
        "layer0": "blockbuster:items/register"
    },
    "display": {
        "thirdperson_righthand": {
            "rotation": [ 0, -90, 55 ],
            "translation": [ 0, 2, -2.5 ],
            "scale": [ 0.85, 0.85, 0.85 ]
        },
        "thirdperson_lefthand": {
            "rotation": [ 0, 90, -55 ],
            "translation": [ 0, 2, -2.5 ],
            "scale": [ 0.85, 0.85, 0.85 ]
        }
    }
}

==================================================

--- Файл №608 ---
Путь: main\resources\assets\blockbuster\models\user\README.txt
--------------------
In this folder, you can place your own models in order to "pack" them into 
Blockbuster mod's jar. Automatically it won't work though, you'll need to 
edit the user.json file, and add there the models you're going to use, 
specify if OBJ, MTL, OBJ shapes or VOX files paths relative to users folder
and also change the paths to point into Blockbuster's jar path.

The JSON format for user.json is something like this:

{
    "siren_head": {
        "obj": "Siren_head.obj"
    },
    "shrek": {
        "obj": "model.obj",
        "mtl": "model.mtl",
        "shapes": [
            "shapes/smile.obj"
        ]
    },
    "lego": {
        "obj": "lego.obj",
        "mtl": "lego.mtl"
    },
    "book": {
        "vox": "book.vox"
    }
}

It's pretty hard to explain the entire thing, but if you'll stumble upon this 
file and will be have issues with packing your models into the mod's jar, feel 
free to join my Discord server and ask me about this: https://discord.gg/qfxrqUF

==================================================

--- Файл №609 ---
Путь: main\resources\assets\blockbuster\optifine\dynamic_lights.properties
--------------------
###############################################################################
# Sample configuration for OptiFine's Dynamic Lights feature.
###############################################################################
# dynamic_lights.properties
###############################################################################
# This file is offered without any copyright restrictions.
# Please copy and modify it to suit your needs.
#
# This configuration file allows mods to define dynamic light levels for entities and items.
# Location: "/assets/<mod_id>/optifine/dynamic_lights.properties"

# Entity light levels
# The entity name is automatically expanded with the mod_id.
# The light level should be between 0 and 15.
# For exaple:
#   entities=basalz:15 blitz:7
#entities=<entity:light> ...

# Item light levels
# The item name is automatically expanded with the mod_id.
# The light level should be between 0 and 15.
# For exaple:
#   items=florb:15 morb:7
items=model1:1 model2:2 model3:3 model4:4 model5:5 model6:6 model7:7 model8:8 model9:9 model10:10 model11:11 model12:12 model13:13 model14:14 model15:15

==================================================

--- Файл №610 ---
Путь: main\resources\assets\blockbuster\particles\default_fire.json
--------------------
{
	"format_version": "1.10.0",
	"particle_effect": {
		"description": {
			"identifier": "snowstorm:fire",
			"basic_render_parameters": {
				"material": "particles_alpha",
				"texture": "minecraft:textures/blocks/fire_layer_1.png"
			}
		},
		"components": {
			"minecraft:emitter_rate_steady": {
				"spawn_rate": 20,
				"max_particles": 1000
			},
			"minecraft:emitter_lifetime_looping": {
				"active_time": 1
			},
			"minecraft:emitter_shape_disc": {
				"offset": [0, 0.4, 0],
				"radius": 1.2,
				"direction": "outwards"
			},
			"minecraft:particle_lifetime_expression": {
				"max_lifetime": "Math.random(1, 1.4)"
			},
			"minecraft:particle_initial_speed": 1,
			"minecraft:particle_motion_dynamic": {
				"linear_acceleration": ["(variable.particle_random_1-0.5)", 1.2, "(variable.particle_random_1-0.5)"]
			},
			"minecraft:particle_appearance_billboard": {
				"size": [0.4, 0.4],
				"facing_camera_mode": "lookat_xyz",
				"uv": {
					"texture_width": 16,
					"texture_height": 512,
					"flipbook": {
						"base_UV": [0, 0],
						"size_UV": [16, 16],
						"step_UV": [0, 16],
						"max_frame": 32,
						"stretch_to_lifetime": true
					}
				}
			}
		}
	}
}

==================================================

--- Файл №611 ---
Путь: main\resources\assets\blockbuster\particles\default_magic.json
--------------------
{
	"format_version": "1.10.0",
	"particle_effect": {
		"description": {
			"identifier": "snowstorm:magic",
			"basic_render_parameters": {
				"material": "particles_alpha",
				"texture": "textures/particle/particles"
			}
		},
		"components": {
			"minecraft:emitter_local_space": {
				"position": true,
				"rotation": true
			},
			"minecraft:emitter_rate_steady": {
				"spawn_rate": 500,
				"max_particles": 1000
			},
			"minecraft:emitter_lifetime_expression": {
				"activation_expression": 1
			},
			"minecraft:emitter_shape_disc": {
				"offset": ["math.sin(variable.emitter_age*200)*6", "math.cos(variable.emitter_age*260)*6", 5],
				"radius": 1.6,
				"plane_normal": ["math.sin(variable.emitter_age*200)*6", 0, 1],
				"surface_only": true,
				"direction": "outwards"
			},
			"minecraft:particle_lifetime_expression": {
				"max_lifetime": "math.random(3, 4)"
			},
			"minecraft:particle_initial_spin": {
				"rotation_rate": "Math.random(-100, 100)"
			},
			"minecraft:particle_initial_speed": 1,
			"minecraft:particle_motion_dynamic": {
				"linear_acceleration": ["math.random(0, 4)", "math.random(0, 8)", "variable.particle_random_3>0.2 ? -10 : -4"]
			},
			"minecraft:particle_appearance_billboard": {
				"size": ["0.04+variable.particle_random_2/5", "0.04+variable.particle_random_2/5"],
				"facing_camera_mode": "rotate_xyz",
				"uv": {
					"texture_width": 128,
					"texture_height": 128,
					"flipbook": {
						"base_UV": [64, 96],
						"size_UV": [8, 8],
						"step_UV": [-8, 0],
						"max_frame": 8,
						"stretch_to_lifetime": true
					}
				}
			},
			"minecraft:particle_appearance_tinting": {
				"color": ["Math.clamp(0.3 + variable.particle_random_4/7 + (variable.particle_random_3>0.2 ? 0.4 : 0), 0, 1)", "Math.clamp(0.2+variable.particle_random_4/5, 0, 1)", "Math.clamp(0.88 + variable.particle_random_4/8, 0, 1)", 1]
			}
		}
	}
}

==================================================

--- Файл №612 ---
Путь: main\resources\assets\blockbuster\particles\default_rain.json
--------------------
{
	"format_version": "1.10.0",
	"particle_effect": {
		"description": {
			"identifier": "snowstorm:rain",
			"basic_render_parameters": {
				"material": "particles_alpha",
				"texture": "textures/particle/particles"
			}
		},
		"components": {
			"minecraft:emitter_rate_steady": {
				"spawn_rate": 640,
				"max_particles": 4000
			},
			"minecraft:emitter_lifetime_looping": {
				"active_time": 4
			},
			"minecraft:emitter_shape_box": {
				"offset": [0, 40, 0],
				"half_dimensions": [32, 0, 32],
				"direction": ["2+Math.random(-1, 1)/2", "-16-Math.random(0, 8)", "Math.random(-1, 1)/2"]
			},
			"minecraft:particle_lifetime_expression": {
				"max_lifetime": 2.7
			},
			"minecraft:particle_expire_if_not_in_blocks": ["minecraft:air"],
			"minecraft:particle_initial_speed": "16+Math.random(0, 8)",
			"minecraft:particle_motion_dynamic": {
				"linear_acceleration": [0, -4, 0]
			},
			"minecraft:particle_appearance_billboard": {
				"size": ["0.04+variable.particle_random_1/8", "0.2+variable.particle_random_1/2"],
				"facing_camera_mode": "lookat_y",
				"uv": {
					"texture_width": 16,
					"texture_height": 16,
					"uv": ["0.125 * (8 * (0.125 * (math.floor(variable.particle_random_2*7)*8)))", 10],
					"uv_size": [1, 1]
				}
			},
			"minecraft:particle_appearance_tinting": {
				"color": [0.29412, 0.63922, 1, 1]
			}
		}
	}
}

==================================================

--- Файл №613 ---
Путь: main\resources\assets\blockbuster\particles\default_snow.json
--------------------
{
	"format_version": "1.10.0",
	"particle_effect": {
		"description": {
			"identifier": "snowstorm:snow",
			"basic_render_parameters": {
				"material": "particles_alpha",
				"texture": "textures/particle/particles"
			}
		},
		"components": {
			"minecraft:emitter_rate_steady": {
				"spawn_rate": 80,
				"max_particles": 4000
			},
			"minecraft:emitter_lifetime_looping": {
				"active_time": 1
			},
			"minecraft:emitter_shape_box": {
				"offset": [0, 20, 0],
				"half_dimensions": [36, 0, 36],
				"direction": ["Math.random(-1, 1)", "-1.2-Math.random(0, 1)", "Math.random(-1, 1)"]
			},
			"minecraft:particle_lifetime_expression": {
				"max_lifetime": 25
			},
			"minecraft:particle_initial_spin": {
				"rotation": "variable.particle_random_3*360"
			},
			"minecraft:particle_initial_speed": 1,
			"minecraft:particle_motion_dynamic": {
				"linear_acceleration": [0, -0.2, 0]
			},
			"minecraft:particle_appearance_billboard": {
				"size": ["0.07+variable.particle_random_1/6", "0.07+variable.particle_random_1/6"],
				"facing_camera_mode": "rotate_xyz",
				"uv": {
					"texture_width": 128,
					"texture_height": 128,
					"uv": ["8 * (0.125 * (math.floor(variable.particle_random_2*8)*8))", 72],
					"uv_size": [8, 8]
				}
			}
		}
	}
}

==================================================

--- Файл №614 ---
Путь: main\resources\assets\blockbuster\textures\default_particles.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5268 байт]

==================================================

--- Файл №615 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 284 байт]

==================================================

--- Файл №616 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb0.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 294 байт]

==================================================

--- Файл №617 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb1.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 280 байт]

==================================================

--- Файл №618 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb10.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 373 байт]

==================================================

--- Файл №619 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb11.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 376 байт]

==================================================

--- Файл №620 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb12.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 383 байт]

==================================================

--- Файл №621 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb13.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 358 байт]

==================================================

--- Файл №622 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb14.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 317 байт]

==================================================

--- Файл №623 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb15.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 280 байт]

==================================================

--- Файл №624 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb2.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 290 байт]

==================================================

--- Файл №625 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb3.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 316 байт]

==================================================

--- Файл №626 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb4.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 288 байт]

==================================================

--- Файл №627 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb5.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 343 байт]

==================================================

--- Файл №628 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb6.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 347 байт]

==================================================

--- Файл №629 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb7.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 399 байт]

==================================================

--- Файл №630 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb8.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 368 байт]

==================================================

--- Файл №631 ---
Путь: main\resources\assets\blockbuster\textures\light_bulb9.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 370 байт]

==================================================

--- Файл №632 ---
Путь: main\resources\assets\blockbuster\textures\spotlight.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 302 байт]

==================================================

--- Файл №633 ---
Путь: main\resources\assets\blockbuster\textures\spotlight_light.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 192 байт]

==================================================

--- Файл №634 ---
Путь: main\resources\assets\blockbuster\textures\blocks\black.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 946 байт]

==================================================

--- Файл №635 ---
Путь: main\resources\assets\blockbuster\textures\blocks\blue.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 959 байт]

==================================================

--- Файл №636 ---
Путь: main\resources\assets\blockbuster\textures\blocks\cyan.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 960 байт]

==================================================

--- Файл №637 ---
Путь: main\resources\assets\blockbuster\textures\blocks\director_block_blank.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1185 байт]

==================================================

--- Файл №638 ---
Путь: main\resources\assets\blockbuster\textures\blocks\director_block_current_start.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1279 байт]

==================================================

--- Файл №639 ---
Путь: main\resources\assets\blockbuster\textures\blocks\director_block_current_stop.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1245 байт]

==================================================

--- Файл №640 ---
Путь: main\resources\assets\blockbuster\textures\blocks\director_block_side.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1251 байт]

==================================================

--- Файл №641 ---
Путь: main\resources\assets\blockbuster\textures\blocks\director_block_start.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1287 байт]

==================================================

--- Файл №642 ---
Путь: main\resources\assets\blockbuster\textures\blocks\director_block_stop.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1248 байт]

==================================================

--- Файл №643 ---
Путь: main\resources\assets\blockbuster\textures\blocks\green.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 162 байт]

==================================================

--- Файл №644 ---
Путь: main\resources\assets\blockbuster\textures\blocks\model_side.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1347 байт]

==================================================

--- Файл №645 ---
Путь: main\resources\assets\blockbuster\textures\blocks\purple.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 957 байт]

==================================================

--- Файл №646 ---
Путь: main\resources\assets\blockbuster\textures\blocks\red.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 956 байт]

==================================================

--- Файл №647 ---
Путь: main\resources\assets\blockbuster\textures\blocks\white.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 953 байт]

==================================================

--- Файл №648 ---
Путь: main\resources\assets\blockbuster\textures\blocks\yellow.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 958 байт]

==================================================

--- Файл №649 ---
Путь: main\resources\assets\blockbuster\textures\entity\actor.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 2146 байт]

==================================================

--- Файл №650 ---
Путь: main\resources\assets\blockbuster\textures\entity\cape.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5311 байт]

==================================================

--- Файл №651 ---
Путь: main\resources\assets\blockbuster\textures\entity\pixel.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1274 байт]

==================================================

--- Файл №652 ---
Путь: main\resources\assets\blockbuster\textures\entity\eyes\alex.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 2539 байт]

==================================================

--- Файл №653 ---
Путь: main\resources\assets\blockbuster\textures\entity\eyes\steve.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 2637 байт]

==================================================

--- Файл №654 ---
Путь: main\resources\assets\blockbuster\textures\entity\eye_masks\1px.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1402 байт]

==================================================

--- Файл №655 ---
Путь: main\resources\assets\blockbuster\textures\entity\eye_masks\1px_l.2px_r.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1474 байт]

==================================================

--- Файл №656 ---
Путь: main\resources\assets\blockbuster\textures\entity\eye_masks\2px.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1476 байт]

==================================================

--- Файл №657 ---
Путь: main\resources\assets\blockbuster\textures\entity\eye_masks\2px_l.1px_r.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1461 байт]

==================================================

--- Файл №658 ---
Путь: main\resources\assets\blockbuster\textures\entity\mchorse\eyes.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 2697 байт]

==================================================

--- Файл №659 ---
Путь: main\resources\assets\blockbuster\textures\entity\mchorse\head.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 2818 байт]

==================================================

--- Файл №660 ---
Путь: main\resources\assets\blockbuster\textures\entity\mchorse\skin.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1887 байт]

==================================================

--- Файл №661 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\body.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3677 байт]

==================================================

--- Файл №662 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\bodywear.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3676 байт]

==================================================

--- Файл №663 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\full_body.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5539 байт]

==================================================

--- Файл №664 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\full_head.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5535 байт]

==================================================

--- Файл №665 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\full_left_arm.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5533 байт]

==================================================

--- Файл №666 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\full_left_leg.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5536 байт]

==================================================

--- Файл №667 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\full_right_arm.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 7755 байт]

==================================================

--- Файл №668 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\full_right_leg.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 5538 байт]

==================================================

--- Файл №669 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\head.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3674 байт]

==================================================

--- Файл №670 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\left_arm.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3671 байт]

==================================================

--- Файл №671 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\left_armwear.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3668 байт]

==================================================

--- Файл №672 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\left_leg.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3671 байт]

==================================================

--- Файл №673 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\left_legwear.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3671 байт]

==================================================

--- Файл №674 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\outer_head.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3671 байт]

==================================================

--- Файл №675 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\right_arm.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3673 байт]

==================================================

--- Файл №676 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\right_armwear.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3674 байт]

==================================================

--- Файл №677 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\right_leg.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3674 байт]

==================================================

--- Файл №678 ---
Путь: main\resources\assets\blockbuster\textures\entity\skin_masks\right_legwear.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3675 байт]

==================================================

--- Файл №679 ---
Путь: main\resources\assets\blockbuster\textures\gui\icon.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 64606 байт]

==================================================

--- Файл №680 ---
Путь: main\resources\assets\blockbuster\textures\gui\icons.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 16750 байт]

==================================================

--- Файл №681 ---
Путь: main\resources\assets\blockbuster\textures\gui\recording.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 3034 байт]

==================================================

--- Файл №682 ---
Путь: main\resources\assets\blockbuster\textures\items\actor_config.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1373 байт]

==================================================

--- Файл №683 ---
Путь: main\resources\assets\blockbuster\textures\items\playback.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1308 байт]

==================================================

--- Файл №684 ---
Путь: main\resources\assets\blockbuster\textures\items\register.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1283 байт]

==================================================

