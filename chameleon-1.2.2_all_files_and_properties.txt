Анализ содержимого папки: C:\Users\User\Desktop\mody\chameleon-1.2.2\src
==================================================

--- Файл №1 ---
Путь: main\java\mchorse\chameleon\Chameleon.java
--------------------
package mchorse.chameleon;

import mchorse.chameleon.mclib.ValueButtons;
import mchorse.mclib.McLib;
import mchorse.mclib.config.ConfigBuilder;
import mchorse.mclib.events.RegisterConfigEvent;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.Mod.EventHandler;
import net.minecraftforge.fml.common.SidedProxy;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

@Mod(modid = Chameleon.MOD_ID, name = Chameleon.MODNAME, version = Chameleon.VERSION, dependencies = "required-after:mclib@[%MCLIB%,);required-after:metamorph@[%METAMORPH%,)", updateJSON = "https://raw.githubusercontent.com/mchorse/chameleon/master/version.json")
public class Chameleon
{
    /* Sadly "chameleon" mod ID conflicts with another popular mod... */
    public static final String MOD_ID = "chameleon_morph";
    public static final String MODNAME = "Chameleon";
    public static final String VERSION = "%VERSION%";

    @SidedProxy(serverSide = "mchorse.chameleon.CommonProxy", clientSide = "mchorse.chameleon.ClientProxy")
    public static CommonProxy proxy;

    @EventHandler
    public void preInit(FMLPreInitializationEvent event)
    {
        McLib.EVENT_BUS.register(this);

        proxy.preInit(event);
    }

    @SubscribeEvent
    public void onConfig(RegisterConfigEvent event)
    {
        ConfigBuilder builder = event.createBuilder("chameleon");

        /* General */
        builder.category("general").register(new ValueButtons("buttons").clientSide());
    }
}

==================================================

--- Файл №2 ---
Путь: main\java\mchorse\chameleon\ClientProxy.java
--------------------
package mchorse.chameleon;

import mchorse.chameleon.client.ChameleonPack;
import mchorse.chameleon.lib.ChameleonLoader;
import mchorse.chameleon.lib.ChameleonModel;
import mchorse.chameleon.lib.MolangHelper;
import mchorse.chameleon.lib.data.animation.Animations;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.mclib.ChameleonTree;
import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.files.GlobalTree;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@SideOnly(Side.CLIENT)
public class ClientProxy extends CommonProxy
{
    public static final Map<String, ChameleonModel> chameleonModels = new HashMap<String, ChameleonModel>();
    public static final MolangParser parser;

    public static ChameleonPack pack;
    public static ChameleonTree tree;

    public static File modelsFile;

    private ChameleonLoader loader = new ChameleonLoader();

    static
    {
        parser = new MolangParser();

        MolangHelper.registerVars(parser);

        /* Additional Chameleon specific variables */
        parser.register(new Variable("query.head_yaw", 0));
        parser.register(new Variable("query.head_pitch", 0));

        parser.register(new Variable("query.velocity", 0));
        parser.register(new Variable("query.limb_swing", 0));
        parser.register(new Variable("query.limb_swing_amount", 0));
        parser.register(new Variable("query.age", 0));
    }

    @Override
    public void preInit(FMLPreInitializationEvent event)
    {
        super.preInit(event);

        modelsFile = new File(this.configFile, "models");

        this.reloadModels();
        pack = new ChameleonPack(modelsFile);

        ReflectionUtils.registerResourcePack(pack);
        GlobalTree.TREE.register(tree = new ChameleonTree(modelsFile));
    }

    @Override
    public void reloadModels()
    {
        modelsFile.mkdirs();

        if (!modelsFile.isDirectory())
        {
            return;
        }

        List<String> toCheck = new ArrayList<String>(chameleonModels.keySet());

        this.recursiveReloadModel(modelsFile, "", toCheck);

        /* Check and remove model if it got removed */
        for (String key : toCheck)
        {
            ChameleonModel model = chameleonModels.get(key);

            if (model != null && !model.isStillPresent())
            {
                chameleonModels.remove(key);
            }
        }
    }

    private void recursiveReloadModel(File folder, String prefix, List<String> toCheck)
    {
        File[] files = folder.listFiles();

        if (files == null)
        {
            return;
        }

        for (File modelFile : files)
        {
            if (modelFile.isDirectory())
            {
                if (!this.reloadModelFolder(modelFile, prefix, toCheck) && !modelFile.getName().equals("skins"))
                {
                    this.recursiveReloadModel(modelFile, prefix + modelFile.getName() + "/", toCheck);
                }
            }
        }
    }

    private boolean reloadModelFolder(File modelFolder, String prefix, List<String> toCheck)
    {
        File model = null;
        List<File> animations = new ArrayList<File>();
        File[] files = modelFolder.listFiles();
        long lastUpdated = 0;

        if (files == null)
        {
            return false;
        }

        for (File file : files)
        {
            if (model == null && file.getName().endsWith(".geo.json"))
            {
                model = file;
                lastUpdated = Math.max(file.lastModified(), lastUpdated);
            }
            else if (animations.isEmpty() && file.getName().endsWith(".animation.json"))
            {
                animations.add(file);
                lastUpdated = Math.max(file.lastModified(), lastUpdated);
            }
        }

        /* Scan for animation files also in animations folder */
        File animationsFolder = new File(modelFolder, "animations");

        if (animationsFolder.isDirectory())
        {
            File[] animationsInFolder = animationsFolder.listFiles();

            if (animationsInFolder != null)
            {
                for (File animationFile : animationsInFolder)
                {
                    if (animationFile.getName().endsWith(".animation.json"))
                    {
                        animations.add(animationFile);
                        lastUpdated = Math.max(animationFile.lastModified(), lastUpdated);
                    }
                }
            }
        }

        /* Load model and animation */
        String key = prefix + modelFolder.getName();
        ChameleonModel oldModel = chameleonModels.get(key);

        if (model != null && (oldModel == null || oldModel.lastUpdate < lastUpdated))
        {
            Model theModel = this.loader.loadModel(model);
            Animations theAnimations = this.loadAnimations(animations);

            if (theModel != null)
            {
                List<File> trackingFiles = new ArrayList<File>();

                trackingFiles.add(model);
                chameleonModels.put(key, new ChameleonModel(theModel, theAnimations, trackingFiles, lastUpdated));
                toCheck.remove(key);
            }
        }

        return chameleonModels.containsKey(key);
    }

    private Animations loadAnimations(List<File> files)
    {
        Animations animations = new Animations();

        for (File animationFile : files)
        {
            this.loader.loadAllAnimations(parser, animationFile, animations);
        }

        return animations;
    }

    @Override
    public Collection<String> getModelKeys()
    {
        return chameleonModels.keySet();
    }
}

==================================================

--- Файл №3 ---
Путь: main\java\mchorse\chameleon\CommonProxy.java
--------------------
package mchorse.chameleon;

import mchorse.chameleon.metamorph.ChameleonFactory;
import mchorse.metamorph.api.MorphManager;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

import java.io.File;
import java.util.Collection;
import java.util.Collections;

public class CommonProxy
{
    public File configFile;

    public void preInit(FMLPreInitializationEvent event)
    {
        this.configFile = new File(event.getModConfigurationDirectory(), "chameleon");

        MorphManager.INSTANCE.factories.add(new ChameleonFactory());
    }

    public void reloadModels()
    {}

    public Collection<String> getModelKeys()
    {
        return Collections.emptyList();
    }
}

==================================================

--- Файл №4 ---
Путь: main\java\mchorse\chameleon\animation\ActionConfig.java
--------------------
package mchorse.chameleon.animation;

import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagString;
import net.minecraftforge.common.util.Constants.NBT;

import java.util.Objects;

public class ActionConfig
{
    public String name = "";
    public boolean clamp = true;
    public boolean reset = true;
    public float speed = 1;
    public float fade = 5;
    public int tick = 0;

    public ActionConfig()
    {}

    public ActionConfig(String name)
    {
        this.name = name;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof ActionConfig)
        {
            ActionConfig config = (ActionConfig) obj;

            return Objects.equals(this.name, config.name)
                && this.clamp == config.clamp
                && this.reset == config.reset
                && this.speed == config.speed
                && this.fade == config.fade
                && this.tick == config.tick;
        }

        return super.equals(obj);
    }

    @Override
    public ActionConfig clone()
    {
        ActionConfig config = new ActionConfig(this.name);

        config.clamp = this.clamp;
        config.reset = this.reset;
        config.speed = this.speed;
        config.fade = this.fade;
        config.tick = this.tick;

        return config;
    }

    public void fromNBT(NBTBase base)
    {
        if (base instanceof NBTTagCompound)
        {
            NBTTagCompound tag = (NBTTagCompound) base;

            if (tag.hasKey("Name", NBT.TAG_STRING)) this.name = tag.getString("Name");
            if (tag.hasKey("Clamp", NBT.TAG_ANY_NUMERIC)) this.clamp = tag.getBoolean("Clamp");
            if (tag.hasKey("Reset", NBT.TAG_ANY_NUMERIC)) this.reset = tag.getBoolean("Reset");
            if (tag.hasKey("Speed", NBT.TAG_ANY_NUMERIC)) this.speed = tag.getFloat("Speed");
            if (tag.hasKey("Fade", NBT.TAG_ANY_NUMERIC)) this.fade = tag.getInteger("Fade");
            if (tag.hasKey("Tick", NBT.TAG_ANY_NUMERIC)) this.tick = tag.getInteger("Tick");
        }
        else if (base instanceof NBTTagString)
        {
            this.name = ((NBTTagString) base).getString();
        }
    }

    public NBTBase toNBT()
    {
        if (!this.name.isEmpty() && this.isDefault())
        {
            return new NBTTagString(this.name);
        }

        NBTTagCompound tag = new NBTTagCompound();

        if (!this.name.isEmpty()) tag.setString("Name", this.name);
        if (this.clamp != true) tag.setBoolean("Clamp", this.clamp);
        if (this.reset != true) tag.setBoolean("Reset", this.reset);
        if (this.speed != 1) tag.setFloat("Speed", this.speed);
        if (this.fade != 5) tag.setInteger("Fade", (int) this.fade);
        if (this.tick != 0) tag.setInteger("Tick", this.tick);

        return tag;
    }

    public boolean isDefault()
    {
        return this.clamp && this.reset && this.speed == 1 && this.fade == 5 && this.tick == 0;
    }
}

==================================================

--- Файл №5 ---
Путь: main\java\mchorse\chameleon\animation\ActionPlayback.java
--------------------
package mchorse.chameleon.animation;

import mchorse.chameleon.lib.ChameleonAnimator;
import mchorse.chameleon.lib.data.animation.Animation;
import mchorse.chameleon.lib.data.model.Model;
import net.minecraft.entity.EntityLivingBase;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class ActionPlayback
{
    public Animation action;
    public ActionConfig config;

    private int fade;
    private float ticks;
    private int duration;
    private double speed = 1;

    private boolean looping;
    private Fade fading = Fade.FINISHED;
    public boolean playing = true;
    public int priority;

    public ActionPlayback(Animation action, ActionConfig config)
    {
        this(action, config, true);
    }

    public ActionPlayback(Animation action, ActionConfig config, boolean looping)
    {
        this.action = action;
        this.config = config;
        this.duration = action.getLengthInTicks();
        this.looping = looping;
        this.setSpeed(1);
    }

    public ActionPlayback(Animation action, ActionConfig config, boolean looping, int priority)
    {
        this(action, config, looping);
        this.priority = priority;
    }

    /* Action playback control methods */

    /**
     * Resets the animation (if config allows)
     */
    public void reset()
    {
        if (this.config.reset)
        {
            this.ticks = Math.copySign(1, this.speed) < 0 ? this.duration : 0;
        }

        this.stopFade();
    }

    /**
     * Whether this action playback finished fading
     */
    public boolean finishedFading()
    {
        return this.fading != Fade.FINISHED && this.fade <= 0;
    }

    public boolean isFadingModeOut()
    {
        return this.fading == Fade.OUT;
    }

    public boolean isFadingModeIn()
    {
        return this.fading == Fade.IN;
    }

    /**
     * Whether this action playback is fading
     */
    public boolean isFading()
    {
        return this.fading != Fade.FINISHED && this.fade > 0;
    }

    /**
     * Start fading out
     */
    public void fadeOut()
    {
        this.fade = (int) this.config.fade;
        this.fading = Fade.OUT;
    }

    /**
     * Start fading in
     */
    public void fadeIn()
    {
        this.fade = (int) this.config.fade;
        this.fading = Fade.IN;
    }

    /**
     * Reset fading
     */
    public void stopFade()
    {
        this.fade = 0;
        this.fading = Fade.FINISHED;
    }

    public int getFade()
    {
        return this.fade;
    }

    /**
     * Calculate fade factor with given partial ticks
     *
     * Closer to 1 means started fading, meanwhile closer to 0 is almost
     * finished fading.
     */
    public float getFadeFactor(float partialTicks)
    {
        float factor = (this.fade - partialTicks) / this.config.fade;

        return this.fading == Fade.OUT ? factor : 1 - factor;
    }

    /**
     * Set speed of an action playback
     */
    public void setSpeed(double speed)
    {
        this.speed = speed * this.config.speed;
    }

    /* Update methods */

    public void update()
    {
        if (this.fading != Fade.FINISHED && this.fade > 0)
        {
            this.fade--;
        }

        if (!this.playing) return;

        this.ticks += this.speed;

        if (!this.looping && this.fading != Fade.OUT && this.ticks >= this.duration)
        {
            this.fadeOut();
        }

        if (this.looping)
        {
            if (this.ticks >= this.duration && this.speed > 0 && this.config.clamp)
            {
                this.ticks -= this.duration;
                this.ticks += this.config.tick;
            }
            else if (this.ticks < 0 && this.speed < 0 && this.config.clamp)
            {
                this.ticks = this.duration + this.ticks;
                this.ticks -= this.config.tick;
            }
        }
    }

    public float getTick(float partialTick)
    {
        float ticks = this.ticks + (float) (partialTick * this.speed);

        if (this.looping)
        {
            if (ticks >= this.duration && this.speed > 0 && this.config.clamp)
            {
                ticks -= this.duration;
            }
            else if (this.ticks < 0 && this.speed < 0 && this.config.clamp)
            {
                ticks = this.duration + ticks;
            }
        }

        return ticks;
    }

    public void apply(EntityLivingBase target, Model armature, float partialTick, float blend, boolean skipInitial)
    {
        ChameleonAnimator.animate(target, armature, this.action, this.getTick(partialTick), blend, skipInitial);
    }

    public static enum Fade
    {
        OUT, FINISHED, IN
    }
}

==================================================

--- Файл №6 ---
Путь: main\java\mchorse\chameleon\animation\ActionsConfig.java
--------------------
package mchorse.chameleon.animation;

import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;

/**
 * Animated actions config. This little dude right there is 
 * responsible for storing configuration for the name of actions 
 * which should be used for particular <s>set of skills</s> actions. 
 */
public class ActionsConfig
{
    public Map<String, ActionConfig> actions = new HashMap<String, ActionConfig>();

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof ActionsConfig)
        {
            ActionsConfig config = (ActionsConfig) obj;

            return Objects.equals(this.actions, config.actions);
        }

        return super.equals(obj);
    }

    public void copy(ActionsConfig config)
    {
        this.actions.clear();
        this.actions.putAll(config.actions);
    }

    public void fromNBT(NBTTagCompound tag)
    {
        this.actions.clear();

        for (String key : tag.getKeySet())
        {
            NBTBase base = tag.getTag(key);
            String newKey = this.toKey(key);
            ActionConfig config = new ActionConfig(newKey);

            config.fromNBT(base);
            this.actions.put(newKey, config);
        }
    }

    public NBTTagCompound toNBT()
    {
        return this.toNBT(new NBTTagCompound());
    }

    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        if (this.actions.isEmpty())
        {
            return null;
        }

        if (tag == null)
        {
            tag = new NBTTagCompound();
        }

        for (Map.Entry<String, ActionConfig> entry : this.actions.entrySet())
        {
            ActionConfig action = entry.getValue();
            String key = entry.getKey();

            if (!(key.equals(action.name) && action.isDefault()))
            {
                tag.setTag(key, action.toNBT());
            }
        }

        return tag;
    }

    /**
     * Get key for the action 
     */
    public ActionConfig getConfig(String key)
    {
        ActionConfig output = this.actions.get(key);

        return output == null ? new ActionConfig(key) : output;
    }

    /**
     * Translates JSON or NBT (camelCase or PascalCase) based key into 
     * internal under_score case.  
     */
    public String toKey(String key)
    {
        return key.replaceAll("([a-z])([A-Z])", "$1_$2").toLowerCase();
    }
}

==================================================

--- Файл №7 ---
Путь: main\java\mchorse\chameleon\animation\Animator.java
--------------------
package mchorse.chameleon.animation;

import mchorse.chameleon.animation.ActionPlayback.Fade;
import mchorse.chameleon.lib.ChameleonModel;
import mchorse.chameleon.lib.data.animation.Animation;
import mchorse.chameleon.lib.data.animation.Animations;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.metamorph.ChameleonMorph;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.item.EnumAction;
import net.minecraft.item.ItemStack;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Animator class
 * 
 * This class is responsible for applying currently running actions onto 
 * morph (more specifically onto an armature).
 */
@SideOnly(Side.CLIENT)
public class Animator
{
    /* Actions */
    public ActionPlayback idle;
    public ActionPlayback running;
    public ActionPlayback sprinting;
    public ActionPlayback crouching;
    public ActionPlayback crouchingIdle;
    public ActionPlayback swimming;
    public ActionPlayback swimmingIdle;
    public ActionPlayback flying;
    public ActionPlayback flyingIdle;
    public ActionPlayback riding;
    public ActionPlayback ridingIdle;
    public ActionPlayback dying;
    public ActionPlayback falling;
    public ActionPlayback sleeping;

    public ActionPlayback jump;
    public ActionPlayback swipe;
    public ActionPlayback hurt;
    public ActionPlayback land;
    public ActionPlayback shoot;
    public ActionPlayback consume;

    /* Syncable action */
    public ActionPlayback animation;

    /* Action pipeline properties */
    public ActionPlayback active;
    public ActionPlayback lastActive;
    public List<ActionPlayback> actions = new ArrayList<ActionPlayback>();

    public double prevX = Float.MAX_VALUE;
    public double prevZ = Float.MAX_VALUE;
    public double prevMY;

    /* States */
    public boolean wasOnGround = true;
    public boolean wasShooting = false;
    public boolean wasConsuming = false;

    public ChameleonMorph morph;

    public Animator(ChameleonMorph morph)
    {
        this.morph = morph;
        this.refresh();
    }

    public void refresh()
    {
        ActionsConfig actions = this.morph.actions;

        this.idle = this.createAction(this.idle, actions.getConfig("idle"), true);
        this.running = this.createAction(this.running, actions.getConfig("running"), true);
        this.sprinting = this.createAction(this.sprinting, actions.getConfig("sprinting"), true);
        this.crouching = this.createAction(this.crouching, actions.getConfig("crouching"), true);
        this.crouchingIdle = this.createAction(this.crouchingIdle, actions.getConfig("crouching_idle"), true);
        this.swimming = this.createAction(this.swimming, actions.getConfig("swimming"), true);
        this.swimmingIdle = this.createAction(this.swimmingIdle, actions.getConfig("swimming_idle"), true);
        this.flying = this.createAction(this.flying, actions.getConfig("flying"), true);
        this.flyingIdle = this.createAction(this.flyingIdle, actions.getConfig("flying_idle"), true);
        this.riding = this.createAction(this.riding, actions.getConfig("riding"), true);
        this.ridingIdle = this.createAction(this.ridingIdle, actions.getConfig("riding_idle"), true);
        this.dying = this.createAction(this.dying, actions.getConfig("dying"), false);
        this.falling = this.createAction(this.falling, actions.getConfig("falling"), true);
        this.sleeping = this.createAction(this.sleeping, actions.getConfig("sleeping"), true);

        this.swipe = this.createAction(this.swipe, actions.getConfig("swipe"), false);
        this.jump = this.createAction(this.jump, actions.getConfig("jump"), false, 2);
        this.hurt = this.createAction(this.hurt, actions.getConfig("hurt"), false, 3);
        this.land = this.createAction(this.land, actions.getConfig("land"), false);
        this.shoot = this.createAction(this.shoot, actions.getConfig("shoot"), true);
        this.consume = this.createAction(this.consume, actions.getConfig("consume"), true);

        this.animation = this.createAction(this.animation, actions.getConfig("animation"), false);
    }

    /**
     * Create an action with default priority
     */
    public ActionPlayback createAction(ActionPlayback old, ActionConfig config, boolean looping)
    {
        return this.createAction(old, config, looping, 1);
    }

    /**
     * Create an action playback based on given arguments. This method
     * is used for creating actions so it was easier to tell which
     * actions are missing. Beside that, you can pass an old action so
     * in morph merging situation it wouldn't interrupt animation.
     */
    public ActionPlayback createAction(ActionPlayback old, ActionConfig config, boolean looping, int priority)
    {
        ChameleonModel model = this.morph.getModel();
        Animations animations = model == null ? null : model.animations;

        if (animations == null)
        {
            return null;
        }

        Animation action = animations.get(config.name);

        /* If given action is missing, then omit creation of ActionPlayback */
        if (action == null)
        {
            return null;
        }

        /* If old is the same, then there is no point creating a new one */
        if (old != null && old.action == action)
        {
            old.config = config;
            old.setSpeed(1);

            return old;
        }

        return new ActionPlayback(action, config, looping, priority);
    }

    /**
     * Update animator. This method is responsible for updating action 
     * pipeline and also change current actions based on entity's state.
     */
    public void update(EntityLivingBase target)
    {
        /* Fix issue with morphs sudden running action */
        if (this.prevX == Float.MAX_VALUE)
        {
            this.prevX = target.posX;
            this.prevZ = target.posZ;
        }

        this.controlActions(target);

        /* Update primary actions */
        if (this.active != null)
        {
            this.active.update();
        }

        if (this.lastActive != null)
        {
            this.lastActive.update();
        }

        /* Update secondary actions */
        Iterator<ActionPlayback> it = this.actions.iterator();

        while (it.hasNext())
        {
            ActionPlayback action = it.next();

            action.update();

            if (action.finishedFading() && action.isFadingModeOut())
            {
                action.stopFade();
                it.remove();
            }
        }
    }

    /**
     * This method is designed specifically to isolate any controlling 
     * code (i.e. the ones that is responsible for switching between 
     * actions).
     */
    protected void controlActions(EntityLivingBase target)
    {
        double dx = target.posX - this.prevX;
        double dz = target.posZ - this.prevZ;
        boolean creativeFlying = target instanceof EntityPlayer && ((EntityPlayer) target).capabilities.isFlying;
        boolean wet = target.isInWater();
        final float threshold = creativeFlying ? 0.1F : (wet ? 0.025F : 0.01F);
        boolean moves = Math.abs(dx) > threshold || Math.abs(dz) > threshold;

        if (target.getHealth() <= 0)
        {
            this.setActiveAction(this.dying);
        }
        else if (target.isPlayerSleeping())
        {
            this.setActiveAction(this.sleeping);
        }
        else if (wet)
        {
            this.setActiveAction(!moves ? this.swimmingIdle : this.swimming);
        }
        else if (target.isRiding())
        {
            Entity riding = target.getRidingEntity();
            moves = Math.abs(riding.posX - this.prevX) > threshold || Math.abs(riding.posZ - this.prevZ) > threshold;

            this.prevX = riding.posX;
            this.prevZ = riding.posZ;
            this.setActiveAction(!moves ? this.ridingIdle : this.riding);
        }
        else if (creativeFlying || target.isElytraFlying())
        {
            this.setActiveAction(!moves ? this.flyingIdle : this.flying);
        }
        else
        {
            if (target.isSneaking())
            {
                this.setActiveAction(!moves ? this.crouchingIdle : this.crouching);
            }
            else if (!target.onGround && target.motionY < 0 && target.fallDistance > 1.25)
            {
                this.setActiveAction(this.falling);
            }
            else if (target.isSprinting() && this.sprinting != null)
            {
                this.setActiveAction(this.sprinting);
            }
            else
            {
                this.setActiveAction(!moves ? this.idle : this.running);
            }

            if (target.onGround && !this.wasOnGround && !target.isSprinting() && this.prevMY < -0.5)
            {
                this.addAction(this.land);
            }
        }

        if (!target.onGround && this.wasOnGround && Math.abs(target.motionY) > 0.2F)
        {
            this.addAction(this.jump);
            this.wasOnGround = false;
        }

        /* Bow and consumables */
        boolean shooting = this.wasShooting;
        boolean consuming = this.wasConsuming;
        ItemStack stack = target.getHeldItemMainhand();

        if (!stack.isEmpty())
        {
            if (target.getItemInUseCount() > 0)
            {
                EnumAction action = stack.getItemUseAction();

                if (action == EnumAction.BOW)
                {
                    if (!this.actions.contains(this.shoot))
                    {
                        this.addAction(this.shoot);
                    }

                    this.wasShooting = true;
                }
                else if (action == EnumAction.DRINK || action == EnumAction.EAT)
                {
                    if (!this.actions.contains(this.consume))
                    {
                        this.addAction(this.consume);
                    }

                    this.wasConsuming = true;
                }
            }
            else
            {
                this.wasShooting = false;
                this.wasConsuming = false;
            }
        }
        else
        {
            this.wasShooting = false;
            this.wasConsuming = false;
        }

        if (shooting && !this.wasShooting && this.shoot != null)
        {
            this.shoot.fadeOut();
        }

        if (consuming && !this.wasConsuming && this.consume != null)
        {
            this.consume.fadeOut();
        }

        if (target.hurtTime == target.maxHurtTime - 1)
        {
            this.addAction(this.hurt);
        }

        if (target.isSwingInProgress && target.swingProgress == 0 && !target.isPlayerSleeping())
        {
            this.addAction(this.swipe);
        }

        this.prevX = target.posX;
        this.prevZ = target.posZ;
        this.prevMY = target.motionY;

        this.wasOnGround = target.onGround;
    }

    /**
     * Set current active (primary) action 
     */
    public void setActiveAction(ActionPlayback action)
    {
        if (this.active == action || action == null)
        {
            return;
        }

        if (this.active != null && action.priority < this.active.priority)
        {
            return;
        }

        if (this.active != null)
        {
            this.lastActive = this.active;
        }

        this.active = action;
        this.active.reset();
        this.active.fadeIn();
    }

    /**
     * Add an additional secondary action to the playback 
     */
    public void addAction(ActionPlayback action)
    {
        if (action == null)
        {
            return;
        }

        if (this.actions.contains(action))
        {
            action.reset();

            return;
        }

        action.reset();
        action.fadeIn();
        this.actions.add(action);
    }

    /**
     * Apply currently running action pipeline onto given armature
     */
    public void applyActions(EntityLivingBase target, Model armature, float partialTicks)
    {
        if (this.animation != null && this.morph.isActionPlayer)
        {
            float ticks = this.morph.animation.getFactor(partialTicks) * this.morph.animation.duration;
            boolean doFade = this.morph.lastAnimAction != null;

            if (doFade)
            {
                this.applyAnimation(this.morph.lastAnimAction, target, armature, ticks, Fade.OUT);
                this.applyAnimation(this.animation, target, armature, ticks, Fade.IN);
            }
            else
            {
                this.applyAnimation(this.animation, target, armature, ticks, Fade.FINISHED);
            }

            return;
        }

        if (this.lastActive != null && this.active.isFading())
        {
            this.lastActive.apply(target, armature, partialTicks, 1F, false);
        }

        if (this.active != null)
        {
            float fade = this.active.isFading() ? this.active.getFadeFactor(partialTicks) : 1F;

            this.active.apply(target, armature, partialTicks, fade, false);
        }

        for (ActionPlayback action : this.actions)
        {
            if (action.isFading())
            {
                action.apply(target, armature, partialTicks, action.getFadeFactor(partialTicks), true);
            }
            else
            {
                action.apply(target, armature, partialTicks, 1F, true);
            }
        }
    }

    public void applyAnimation(ActionPlayback animation, EntityLivingBase target, Model armature, float ticks, Fade fade)
    {
        float progress = ticks * Math.abs(animation.config.speed);
        float fadeFactor = animation.config.fade < 0.0001F ? 1F : MathHelper.clamp(progress / animation.config.fade, 0F, 1F);

        if (fade == Fade.FINISHED)
        {
            fadeFactor = 1F;
        }
        else if (fade == Fade.OUT)
        {
            fadeFactor = fadeFactor >= 0.999F ? 0F : 1F;
        }

        if (fadeFactor < 0.0001F)
        {
            return;
        }

        progress += animation.config.clamp ? animation.config.tick : 0F;

        if (animation.config.speed < 0)
        {
            progress = (float) (animation.action.length) - progress;
        }

        animation.apply(target, armature, animation.config.speed == 0F ? 0F : progress / animation.config.speed, fadeFactor, false);
    }
}

==================================================

--- Файл №8 ---
Путь: main\java\mchorse\chameleon\client\ChameleonPack.java
--------------------
package mchorse.chameleon.client;

import com.google.common.collect.ImmutableSet;
import net.minecraft.client.resources.IResourcePack;
import net.minecraft.client.resources.data.IMetadataSection;
import net.minecraft.client.resources.data.MetadataSerializer;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Set;

@SideOnly(Side.CLIENT)
public class ChameleonPack implements IResourcePack
{
    private static final Set<String> DOMAINS = ImmutableSet.of("c.s");

    public File file;

    public ChameleonPack(File file)
    {
        this.file = file;
    }

    @Override
    public InputStream getInputStream(ResourceLocation location) throws IOException
    {
        return new FileInputStream(new File(this.file, location.getResourcePath()));
    }

    @Override
    public boolean resourceExists(ResourceLocation location)
    {
        return new File(this.file, location.getResourcePath()).exists();
    }

    @Override
    public Set<String> getResourceDomains()
    {
        return DOMAINS;
    }

    @Nullable
    @Override
    public <T extends IMetadataSection> T getPackMetadata(MetadataSerializer metadataSerializer, String metadataSectionName) throws IOException
    {
        return null;
    }

    @Override
    public BufferedImage getPackImage() throws IOException
    {
        return null;
    }

    @Override
    public String getPackName()
    {
        return "Chameleon's skin pack";
    }
}

==================================================

--- Файл №9 ---
Путь: main\java\mchorse\chameleon\lib\ChameleonAnimator.java
--------------------
package mchorse.chameleon.lib;

import mchorse.chameleon.ClientProxy;
import mchorse.chameleon.lib.data.animation.Animation;
import mchorse.chameleon.lib.data.animation.AnimationChannel;
import mchorse.chameleon.lib.data.animation.AnimationPart;
import mchorse.chameleon.lib.data.animation.AnimationVector;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelTransform;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.EnumFacing;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Vector3d;
import java.util.List;

@SideOnly(Side.CLIENT)
public class ChameleonAnimator
{
    public static void resetPose(Model model)
    {
        for (ModelBone bone : model.bones)
        {
            bone.reset();
        }
    }

    public static void animate(EntityLivingBase target, Model model, Animation animation, float frame, float blend, boolean skipInitial)
    {
        MolangHelper.setMolangVariables(ClientProxy.parser, target, frame);

        for (ModelBone bone : model.bones)
        {
            animateBone(bone, animation, frame, blend, skipInitial);
        }
    }

    private static void animateBone(ModelBone bone, Animation animation, float frame, float blend, boolean skipInitial)
    {
        boolean applied = false;

        AnimationPart part = animation.parts.get(bone.id);

        if (part != null)
        {
            applyBoneAnimation(bone, part, frame, blend);

            applied = true;
        }

        if (!applied && !skipInitial)
        {
            ModelTransform initial = bone.initial;
            ModelTransform current = bone.current;

            current.translate.x = Interpolations.lerp(current.translate.x, initial.translate.x, blend);
            current.translate.y = Interpolations.lerp(current.translate.y, initial.translate.y, blend);
            current.translate.z = Interpolations.lerp(current.translate.z, initial.translate.z, blend);

            current.scale.x = Interpolations.lerp(current.scale.x, initial.scale.x, blend);
            current.scale.y = Interpolations.lerp(current.scale.y, initial.scale.y, blend);
            current.scale.z = Interpolations.lerp(current.scale.z, initial.scale.z, blend);

            current.rotation.x = Interpolations.lerp(current.rotation.x, initial.rotation.x, blend);
            current.rotation.y = Interpolations.lerp(current.rotation.y, initial.rotation.y, blend);
            current.rotation.z = Interpolations.lerp(current.rotation.z, initial.rotation.z, blend);
        }

        for (ModelBone childBone : bone.children)
        {
            animateBone(childBone, animation, frame, blend, skipInitial);
        }
    }

    private static void applyBoneAnimation(ModelBone bone, AnimationPart animation, float frame, float blend)
    {
        Vector3d pos = interpolateList(animation.position, frame, MolangHelper.Component.POSITION);
        Vector3d rot = interpolateList(animation.rotation, frame, MolangHelper.Component.ROTATION);
        Vector3d scale = interpolateList(animation.scale, frame, MolangHelper.Component.SCALE);

        ModelTransform initial = bone.initial;
        ModelTransform current = bone.current;

        current.translate.x = Interpolations.lerp(current.translate.x, (float) pos.x + initial.translate.x, blend);
        current.translate.y = Interpolations.lerp(current.translate.y, (float) pos.y + initial.translate.y, blend);
        current.translate.z = Interpolations.lerp(current.translate.z, (float) pos.z + initial.translate.z, blend);

        current.scale.x = Interpolations.lerp(current.scale.x, (float) scale.x + initial.scale.x, blend);
        current.scale.y = Interpolations.lerp(current.scale.y, (float) scale.y + initial.scale.y, blend);
        current.scale.z = Interpolations.lerp(current.scale.z, (float) scale.z + initial.scale.z, blend);

        current.rotation.x = Interpolations.lerp(current.rotation.x, (float) rot.x + initial.rotation.x, blend);
        current.rotation.y = Interpolations.lerp(current.rotation.y, (float) rot.y + initial.rotation.y, blend);
        current.rotation.z = Interpolations.lerp(current.rotation.z, (float) rot.z + initial.rotation.z, blend);
    }

    private static Vector3d interpolateList(AnimationChannel channel, float frame, MolangHelper.Component component)
    {
        return interpolate(channel, frame, component);
    }

    private static Vector3d interpolate(AnimationChannel channel, float frame, MolangHelper.Component component)
    {
        Vector3d output = new Vector3d();
        List<AnimationVector> keyframes = channel.keyframes;

        if (keyframes.isEmpty())
        {
            output.set(0, 0, 0);

            return output;
        }

        AnimationVector first = keyframes.get(0);

        if (frame < first.time * 20)
        {
            output.x = MolangHelper.getValue(first.getStart(EnumFacing.Axis.X), component, EnumFacing.Axis.X);
            output.y = MolangHelper.getValue(first.getStart(EnumFacing.Axis.Y), component, EnumFacing.Axis.Y);
            output.z = MolangHelper.getValue(first.getStart(EnumFacing.Axis.Z), component, EnumFacing.Axis.Z);

            return output;
        }

        double duration = first.time * 20;

        for (AnimationVector vector : keyframes)
        {
            double length = vector.getLengthInTicks();

            if (frame >= duration && frame < duration + length)
            {
                double factor = (frame - duration) / length;

                output.x = vector.interp.interpolate(vector, component, EnumFacing.Axis.X, factor);
                output.y = vector.interp.interpolate(vector, component, EnumFacing.Axis.Y, factor);
                output.z = vector.interp.interpolate(vector, component, EnumFacing.Axis.Z, factor);

                return output;
            }

            duration += length;
        }

        AnimationVector last = keyframes.get(keyframes.size() - 1);

        output.x = MolangHelper.getValue(last.getStart(EnumFacing.Axis.X), component, EnumFacing.Axis.X);
        output.y = MolangHelper.getValue(last.getStart(EnumFacing.Axis.Y), component, EnumFacing.Axis.Y);
        output.z = MolangHelper.getValue(last.getStart(EnumFacing.Axis.Z), component, EnumFacing.Axis.Z);

        return output;
    }
}


==================================================

--- Файл №10 ---
Путь: main\java\mchorse\chameleon\lib\ChameleonLoader.java
--------------------
package mchorse.chameleon.lib;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.chameleon.lib.data.animation.Animations;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.lib.parsing.AnimationParser;
import mchorse.chameleon.lib.parsing.ModelParser;
import mchorse.mclib.math.molang.MolangParser;
import net.minecraft.util.JsonUtils;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.IOUtils;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

@SideOnly(Side.CLIENT)
public class ChameleonLoader
{
    public void loadAllAnimations(MolangParser parser, File file, Animations animations)
    {
        JsonObject json = this.loadFile(file);

        if (json != null)
        {
            for (Map.Entry<String, JsonElement> entry : this.getAnimations(json).entrySet())
            {
                String key = entry.getKey();

                try
                {
                    animations.add(AnimationParser.parse(parser, key, entry.getValue().getAsJsonObject()));
                }
                catch (Exception e)
                {
                    System.err.println("An error happened when parsing animation file: " + file.getAbsolutePath());
                    e.printStackTrace();
                }
            }
        }
    }

    private Map<String, JsonElement> getAnimations(JsonObject json)
    {
        Map<String, JsonElement> map = new HashMap<String, JsonElement>();

        if (json.has("animations") && json.get("animations").isJsonObject())
        {
            for (Map.Entry<String, JsonElement> entry : json.get("animations").getAsJsonObject().entrySet())
            {
                map.put(entry.getKey(), entry.getValue());
            }
        }

        return map;
    }

    public Model loadModel(File file)
    {
        try
        {
            return ModelParser.parse(this.loadFile(file));
        }
        catch (Exception e)
        {
            System.err.println("An error happened when parsing model file: " + file.getAbsolutePath());
            e.printStackTrace();
        }

        return null;
    }

    private JsonObject loadFile(File file)
    {
        try
        {
            return JsonUtils.fromJson(new Gson(), new StringReader(this.loadStringFile(file)), JsonObject.class);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    private String loadStringFile(File file) throws IOException
    {
        InputStream stream = new FileInputStream(file);
        String content = IOUtils.toString(stream, StandardCharsets.UTF_8);

        stream.close();

        return content;
    }
}

==================================================

--- Файл №11 ---
Путь: main\java\mchorse\chameleon\lib\ChameleonModel.java
--------------------
package mchorse.chameleon.lib;

import mchorse.chameleon.lib.data.animation.Animations;
import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.Model;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import com.google.common.collect.ImmutableList;

@SideOnly(Side.CLIENT)
public class ChameleonModel
{
    public Model model;
    public Animations animations;
    public long lastUpdate;

    private List<String> boneNames;
    private boolean isStatic;
    private List<File> files;

    public ChameleonModel(Model model, Animations animations, List<File> files, long lastUpdate)
    {
        this.model = model;
        this.animations = animations;
        this.files = files;
        this.lastUpdate = lastUpdate;
        this.isStatic = animations == null || animations.getAll().isEmpty();
    }

    public List<String> getBoneNames()
    {
        if (this.boneNames != null)
        {
            return this.boneNames;
        }

        return this.boneNames = this.getBoneNames(new ArrayList<String>(), this.model.bones);
    }

    public List<String> getChildren(String parent)
    {
        List<String> children = new ArrayList<String>();

        for (ModelBone bone : this.model.bones)
        {
            if (Objects.equals(bone.id, parent))
            {
                this.getBoneNames(children, ImmutableList.of(bone));

                break;
            }
        }

        return children;
    }

    private List<String> getBoneNames(List<String> boneNames, List<ModelBone> bones)
    {
        for (ModelBone bone : bones)
        {
            boneNames.add(bone.id);

            this.getBoneNames(boneNames, bone.children);
        }

        return boneNames;
    }

    public boolean isStatic()
    {
        return this.isStatic;
    }

    public boolean isStillPresent()
    {
        for (File file : this.files)
        {
            if (!file.exists())
            {
                return false;
            }
        }

        return true;
    }
}


==================================================

--- Файл №12 ---
Путь: main\java\mchorse\chameleon\lib\MolangHelper.java
--------------------
package mchorse.chameleon.lib;

import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.ActiveRenderInfo;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class MolangHelper
{
    public static void registerVars(MolangParser parser)
    {
        parser.register(new Variable("query.anim_time", 0));
        parser.register(new Variable("query.life_time", 0));
        parser.register(new Variable("query.actor_count", 0));
        parser.register(new Variable("query.time_of_day", 0));
        parser.register(new Variable("query.moon_phase", 0));
        parser.register(new Variable("query.distance_from_camera", 0));
        parser.register(new Variable("query.is_on_ground", 0));
        parser.register(new Variable("query.is_in_water", 0));
        parser.register(new Variable("query.is_in_water_or_rain", 0));
        parser.register(new Variable("query.health", 0));
        parser.register(new Variable("query.max_health", 0));
        parser.register(new Variable("query.is_on_fire", 0));
        parser.register(new Variable("query.ground_speed", 0));
        parser.register(new Variable("query.yaw_speed", 0));
    }

    public static void setMolangVariables(MolangParser parser, EntityLivingBase target, float frame)
    {
        parser.setValue("query.anim_time", frame / 20);
        parser.setValue("query.life_time", frame / 20);

        Minecraft mc = Minecraft.getMinecraft();
        float partialTick = mc.getRenderPartialTicks();

        parser.setValue("query.actor_count", mc.world.loadedEntityList.size());
        parser.setValue("query.time_of_day", normalizeTime(mc.world.getTotalWorldTime()));
        parser.setValue("query.moon_phase", mc.world.getMoonPhase());

        Entity camera = mc.getRenderViewEntity();
        Vec3d entityCamera = new Vec3d(
            camera.prevPosX + (camera.posX - camera.prevPosX) * partialTick,
            camera.prevPosY + (camera.posY - camera.prevPosY) * partialTick,
            camera.prevPosZ + (camera.posZ - camera.prevPosZ) * partialTick
        );
        Vec3d entityPosition = new Vec3d(
            target.prevPosX + (target.posX - target.prevPosX) * partialTick,
            target.prevPosY + (target.posY - target.prevPosY) * partialTick,
            target.prevPosZ + (target.posZ - target.prevPosZ) * partialTick
        );
        double distance = entityCamera.add(ActiveRenderInfo.getCameraPosition()).distanceTo(entityPosition);

        parser.setValue("query.distance_from_camera", distance);
        parser.setValue("query.is_on_ground", booleanToDouble(target.onGround));
        parser.setValue("query.is_in_water", booleanToDouble(target.isInWater()));
        parser.setValue("query.is_in_water_or_rain", booleanToDouble(target.isWet()));

        parser.setValue("query.health", target.getHealth());
        parser.setValue("query.max_health", target.getMaxHealth());
        parser.setValue("query.is_on_fire", booleanToDouble(target.isBurning()));

        double dx = target.motionX;
        double dz = target.motionZ;
        float groundSpeed = MathHelper.sqrt((dx * dx) + (dz * dz));
        parser.setValue("query.ground_speed", groundSpeed);

        parser.setValue("query.yaw_speed", target.rotationYawHead - target.prevRotationYawHead);

        /* Chameleon specific queries */
        float yaw = Interpolations.lerp(target.prevRotationYawHead, target.rotationYawHead, partialTick);
        float bodyYaw = Interpolations.lerp(target.prevRenderYawOffset, target.renderYawOffset, partialTick);

        parser.setValue("query.head_yaw", yaw - bodyYaw);
        parser.setValue("query.head_pitch", Interpolations.lerp(target.prevRotationPitch, target.rotationPitch, partialTick));

        double velocity = Math.sqrt(target.motionX * target.motionX + target.motionY * target.motionY + target.motionZ * target.motionZ);
        float limbSwingAmount = Interpolations.lerp(target.prevLimbSwingAmount, target.limbSwingAmount, partialTick);
        float limbSwing = target.limbSwing - target.limbSwingAmount * (1.0F - partialTick);

        /* There is still a tiny bit of vertical velocity (gravity) when an
         * entity stands still, so set it to zero in that case */
        if (target.onGround && target.motionY < 0 && (Math.abs(target.motionX) < 0.001 || Math.abs(target.motionZ) < 0.001))
        {
            velocity = 0;
        }

        if (limbSwingAmount > 1.0F)
        {
            limbSwingAmount = 1.0F;
        }

        parser.setValue("query.velocity", velocity);
        parser.setValue("query.limb_swing", limbSwing);
        parser.setValue("query.limb_swing_amount", limbSwingAmount);
        parser.setValue("query.age", target.ticksExisted + partialTick);
    }

    private static double normalizeTime(long totalWorldTime)
    {
        return totalWorldTime / 24000D;
    }

    private static double booleanToDouble(boolean bool)
    {
        return bool ? 1D : 0D;
    }

    /**
     * Get value from given value of a keyframe (end or start)
     *
     * This method is responsible for processing keyframe value, because
     * for some reason constant values are exported in radians, while molang
     * expressions are in degrees
     *
     * Plus X and Y axis of rotation are inverted for some reason ...
     */
    public static double getValue(MolangExpression value, Component component, EnumFacing.Axis axis)
    {
        double out = value.get();

        if (component == Component.ROTATION)
        {
            if (axis == EnumFacing.Axis.X || axis == EnumFacing.Axis.Y)
            {
                out *= -1;
            }
        }
        else if (component == Component.SCALE)
        {
            out = out - 1;
        }

        return out;
    }

    /**
     * Component enum determines which part of the animation is being
     * calculated
     */
    public static enum Component
    {
        POSITION, ROTATION, SCALE
    }
}

==================================================

--- Файл №13 ---
Путь: main\java\mchorse\chameleon\lib\data\animation\Animation.java
--------------------
package mchorse.chameleon.lib.data.animation;

import java.util.HashMap;
import java.util.Map;

public class Animation
{
    public final String id;

    /**
     * Animation length in seconds
     */
    public double length;

    public Map<String, AnimationPart> parts = new HashMap<String, AnimationPart>();

    public Animation(String id)
    {
        this.id = id;
    }

    public void setLength(double length)
    {
        this.length = length;
    }

    public int getLengthInTicks()
    {
        return (int) Math.floor(this.length * 20);
    }
}

==================================================

--- Файл №14 ---
Путь: main\java\mchorse\chameleon\lib\data\animation\AnimationChannel.java
--------------------
package mchorse.chameleon.lib.data.animation;

import java.util.ArrayList;
import java.util.List;

public class AnimationChannel
{
    public List<AnimationVector> keyframes = new ArrayList<AnimationVector>();

    public void sort()
    {
        this.keyframes.sort((a, b) ->
        {
            double diff = a.time - b.time;

            return diff < 0 ? -1 : (diff >= 0 ? 1 : 0);
        });

        AnimationVector previous = null;

        for (AnimationVector vector : this.keyframes)
        {
            if (previous != null)
            {
                previous.next = vector;
                vector.prev = previous;
            }

            previous = vector;
        }
    }
}

==================================================

--- Файл №15 ---
Путь: main\java\mchorse\chameleon\lib\data\animation\AnimationInterpolation.java
--------------------
package mchorse.chameleon.lib.data.animation;

import mchorse.chameleon.lib.MolangHelper;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.Interpolations;
import net.minecraft.util.EnumFacing;

import java.util.Objects;

public enum AnimationInterpolation
{
    LINEAR(null, Interpolation.LINEAR), HERMITE()
    {
        @Override
        public double interpolate(AnimationVector vector, MolangHelper.Component component, EnumFacing.Axis axis, double factor)
        {
            double start = MolangHelper.getValue(vector.getStart(axis), component, axis);
            double destination = MolangHelper.getValue(vector.getEnd(axis), component, axis);

            double pre = start;
            double post = destination;

            if (vector.prev != null)
            {
                pre = MolangHelper.getValue(vector.prev.getStart(axis), component, axis);
            }

            if (vector.next != null)
            {
                post = MolangHelper.getValue(vector.next.getEnd(axis), component, axis);
            }

            return Interpolations.cubicHermite(pre, start, destination, post, factor);
        }
    },
    SINE_IN("easeInSine", Interpolation.SINE_IN), SINE_OUT("easeOutSine", Interpolation.SINE_OUT), SINE_INOUT("easeInOutSine", Interpolation.SINE_INOUT),
    QUAD_IN("easeInQuad", Interpolation.QUAD_IN), QUAD_OUT("easeOutQuad", Interpolation.QUAD_OUT), QUAD_INOUT("easeInOutQuad", Interpolation.QUAD_INOUT),
    CUBIC_IN("easeInCubic", Interpolation.CUBIC_IN), CUBIC_OUT("easeOutCubic", Interpolation.CUBIC_OUT), CUBIC_INOUT("easeInOutCubic", Interpolation.CUBIC_INOUT),
    QUART_IN("easeInQuart", Interpolation.QUART_IN), QUART_OUT("easeOutQuart", Interpolation.QUART_OUT), QUART_INOUT("easeInOutQuart", Interpolation.QUART_INOUT),
    QUINT_IN("easeInQuint", Interpolation.QUINT_IN), QUINT_OUT("easeOutQuint", Interpolation.QUINT_OUT), QUINT_INOUT("easeInOutQuint", Interpolation.QUINT_INOUT),
    EXP_IN("easeInExpo", Interpolation.EXP_IN), EXP_OUT("easeOutExpo", Interpolation.EXP_OUT), EXP_INOUT("easeInOutExpo", Interpolation.EXP_INOUT),
    CIRCLE_IN("easeInCirc", Interpolation.CIRCLE_IN), CIRCLE_OUT("easeOutCirc", Interpolation.CIRCLE_OUT), CIRCLE_INOUT("easeInOutCirc", Interpolation.CIRCLE_INOUT),
    BACK_IN("easeInBack", Interpolation.BACK_IN), BACK_OUT("easeOutBack", Interpolation.BACK_OUT), BACK_INOUT("easeInOutBack", Interpolation.BACK_INOUT),
    /* These are inverted (i.e. in and out swapped places) because that's how the GeckoLib plugin shows */
    ELASTIC_IN("easeInElastic", Interpolation.ELASTIC_OUT), ELASTIC_OUT("easeOutElastic", Interpolation.ELASTIC_IN), ELASTIC_INOUT("easeInOutElastic", Interpolation.ELASTIC_INOUT),
    BOUNCE_IN("easeInBounce", Interpolation.BOUNCE_OUT), BOUNCE_OUT("easeOutBounce", Interpolation.BOUNCE_IN), BOUNCE_INOUT("easeInOutBounce", Interpolation.BOUNCE_INOUT);

    public final String name;
    public final Interpolation interp;

    public static AnimationInterpolation byName(String easing)
    {
        for (AnimationInterpolation interp : values())
        {
            if (Objects.equals(interp.name, easing))
            {
                return interp;
            }
        }

        return LINEAR;
    }

    private AnimationInterpolation(String name, Interpolation interp)
    {
        this.name = name;
        this.interp = interp;
    }

    private AnimationInterpolation()
    {
        this.name = null;
        this.interp = null;
    }

    public double interpolate(AnimationVector vector, MolangHelper.Component component, EnumFacing.Axis axis, double factor)
    {
        if (vector.next != null && vector.next.interp != null && vector.next.interp.interp != null)
        {
            factor = vector.next.interp.interp.interpolate(0, 1, factor);
        }

        double start = MolangHelper.getValue(vector.getStart(axis), component, axis);
        double destination = MolangHelper.getValue(vector.getEnd(axis), component, axis);

        return Interpolations.lerp(start, destination, factor);
    }
}

==================================================

--- Файл №16 ---
Путь: main\java\mchorse\chameleon\lib\data\animation\AnimationPart.java
--------------------
package mchorse.chameleon.lib.data.animation;

public class AnimationPart
{
    public AnimationChannel position = new AnimationChannel();
    public AnimationChannel scale = new AnimationChannel();
    public AnimationChannel rotation = new AnimationChannel();
}


==================================================

--- Файл №17 ---
Путь: main\java\mchorse\chameleon\lib\data\animation\Animations.java
--------------------
package mchorse.chameleon.lib.data.animation;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;

public class Animations
{
    public Map<String, Animation> animations = new HashMap<String, Animation>();

    public Collection<Animation> getAll()
    {
        return this.animations.values();
    }

    public void add(Animation animation)
    {
        this.animations.put(animation.id, animation);
    }

    public Animation get(String id)
    {
        return this.animations.get(id);
    }
}

==================================================

--- Файл №18 ---
Путь: main\java\mchorse\chameleon\lib\data\animation\AnimationVector.java
--------------------
package mchorse.chameleon.lib.data.animation;

import mchorse.mclib.math.molang.expressions.MolangExpression;
import net.minecraft.util.EnumFacing;

public class AnimationVector
{
    public AnimationVector prev;
    public AnimationVector next;

    public double time;
    public AnimationInterpolation interp = AnimationInterpolation.LINEAR;
    public MolangExpression x;
    public MolangExpression y;
    public MolangExpression z;

    public MolangExpression preX;
    public MolangExpression preY;
    public MolangExpression preZ;

    public double getLengthInTicks()
    {
        return this.next == null ? 0 : (this.next.time - this.time) * 20D;
    }

    public MolangExpression getStart(EnumFacing.Axis axis)
    {
        if (axis == EnumFacing.Axis.X)
        {
            return this.x;
        }
        else if (axis == EnumFacing.Axis.Y)
        {
            return this.y;
        }

        return this.z;
    }

    public MolangExpression getEnd(EnumFacing.Axis axis)
    {
        if (axis == EnumFacing.Axis.X)
        {
            return this.next == null ? this.x : this.next.preX;
        }
        else if (axis == EnumFacing.Axis.Y)
        {
            return this.next == null ? this.y : this.next.preY;
        }

        return this.next == null ? this.z : this.next.preZ;
    }
}

==================================================

--- Файл №19 ---
Путь: main\java\mchorse\chameleon\lib\data\model\Model.java
--------------------
package mchorse.chameleon.lib.data.model;

import java.util.ArrayList;
import java.util.List;

public class Model
{
    public String id;
    public int textureWidth;
    public int textureHeight;

    public List<ModelBone> bones = new ArrayList<ModelBone>();
}


==================================================

--- Файл №20 ---
Путь: main\java\mchorse\chameleon\lib\data\model\ModelBone.java
--------------------
package mchorse.chameleon.lib.data.model;

import java.util.ArrayList;
import java.util.List;

import mchorse.mclib.utils.Color;

public class ModelBone
{
    public final String id;
    public List<ModelBone> children = new ArrayList<ModelBone>();
    public List<ModelCube> cubes = new ArrayList<ModelCube>();
    public boolean visible = true;

    public boolean absoluteBrightness = false;
    public float glow = 0F;
    public Color color = new Color(1F, 1F, 1F, 1F);

    public ModelTransform initial = new ModelTransform();
    public ModelTransform current = new ModelTransform();

    public ModelBone(String id)
    {
        this.id = id;
    }

    public void reset()
    {
        this.current.translate.set(this.initial.translate);
        this.current.scale.set(this.initial.scale);
        this.current.rotation.set(this.initial.rotation);
        this.absoluteBrightness = false;
        this.glow = 0F;
        this.color.set(1F, 1F, 1F, 1F);

        for (ModelBone childBone : this.children)
        {
            childBone.reset();
        }
    }
}

==================================================

--- Файл №21 ---
Путь: main\java\mchorse\chameleon\lib\data\model\ModelCube.java
--------------------
package mchorse.chameleon.lib.data.model;

import javax.vecmath.Vector2f;
import javax.vecmath.Vector3f;
import java.util.ArrayList;
import java.util.List;

public class ModelCube
{
    public List<ModelQuad> quads = new ArrayList<ModelQuad>();
    public Vector3f origin = new Vector3f();
    public Vector3f size = new Vector3f();
    public Vector3f pivot = new Vector3f();
    public Vector3f rotation = new Vector3f();
    public float inflate;

    /* Texture mapping */
    public ModelUV north;
    public ModelUV east;
    public ModelUV south;
    public ModelUV west;
    public ModelUV up;
    public ModelUV down;

    public void setupBoxUV(Vector2f boxUV, boolean mirror)
    {
        /* North */
        float w = (float) Math.floor(this.size.x);
        float h = (float) Math.floor(this.size.y);
        float d = (float) Math.floor(this.size.z);
        float tMinX = boxUV.x + d;
        float tMinY = boxUV.y + d;
        float tMaxX = tMinX + w;
        float tMaxY = tMinY + h;

        if (mirror)
        {
            float tmp = tMaxX;

            tMaxX = tMinX;
            tMinX = tmp;
        }

        this.north = ModelUV.from(tMinX, tMinY, tMaxX, tMaxY);

        /* East */
        tMinX = boxUV.x;
        tMinY = boxUV.y + d;
        tMaxX = tMinX + d;
        tMaxY = tMinY + h;

        if (mirror)
        {
            tMinX = boxUV.x + d + w;
            tMinY = boxUV.y + d;
            tMaxX = tMinX + d;
            tMaxY = tMinY + h;

            float tmp = tMinX;

            tMinX = tMaxX;
            tMaxX = tmp;
        }

        this.east = ModelUV.from(tMinX, tMinY, tMaxX, tMaxY);

        /* South */
        tMinX = boxUV.x + d * 2 + w;
        tMinY = boxUV.y + d;
        tMaxX = tMinX + w;
        tMaxY = tMinY + h;

        if (mirror)
        {
            float tmp = tMaxX;

            tMaxX = tMinX;
            tMinX = tmp;
        }

        this.south = ModelUV.from(tMinX, tMinY, tMaxX, tMaxY);

        /* West */
        tMinX = boxUV.x + d + w;
        tMinY = boxUV.y + d;
        tMaxX = tMinX + d;
        tMaxY = tMinY + h;

        if (mirror)
        {
            tMinX = boxUV.x;
            tMinY = boxUV.y + d;
            tMaxX = tMinX + d;
            tMaxY = tMinY + h;

            float tmp = tMinX;

            tMinX = tMaxX;
            tMaxX = tmp;
        }

        this.west = ModelUV.from(tMinX, tMinY, tMaxX, tMaxY);

        /* Up */
        tMinX = boxUV.x + d;
        tMinY = boxUV.y;
        tMaxX = tMinX + w;
        tMaxY = tMinY + d;

        if (mirror)
        {
            float tmp = tMaxX;

            tMaxX = tMinX;
            tMinX = tmp;
        }

        this.up = ModelUV.from(tMinX, tMinY, tMaxX, tMaxY);

        /* Down */
        tMinX = boxUV.x + d + w;
        tMinY = boxUV.y + d;
        tMaxX = tMinX + w;
        tMaxY = boxUV.y;

        if (mirror)
        {
            float tmp = tMaxX;

            tMaxX = tMinX;
            tMinX = tmp;
        }

        this.down = ModelUV.from(tMinX, tMinY, tMaxX, tMaxY);
    }

    public void generateQuads(Model model)
    {
        ModelUV uv;
        float tw = 1F / model.textureWidth;
        float th = 1F / model.textureHeight;

        float minX = (this.origin.x - this.size.x - this.inflate) / 16F;
        float minY = (this.origin.y - this.inflate) / 16F;
        float minZ = (this.origin.z - this.inflate) / 16F;

        float maxX = (this.origin.x + this.inflate) / 16F;
        float maxY = (this.origin.y + this.size.y + this.inflate) / 16F;
        float maxZ = (this.origin.z + this.size.z + this.inflate) / 16F;

        if (this.north != null)
        {
            uv = this.north;

            this.quads.add(new ModelQuad()
                .vertex(maxX, minY, minZ, uv.sx() * tw, uv.ey() * th)
                .vertex(minX, minY, minZ, uv.ex() * tw, uv.ey() * th)
                .vertex(minX, maxY, minZ, uv.ex() * tw, uv.sy() * th)
                .vertex(maxX, maxY, minZ, uv.sx() * tw, uv.sy() * th)
                .normal(0, 0, -1));
        }

        if (this.east != null)
        {
            uv = this.east;

            this.quads.add(new ModelQuad()
                .vertex(maxX, minY, maxZ, uv.sx() * tw, uv.ey() * th)
                .vertex(maxX, minY, minZ, uv.ex() * tw, uv.ey() * th)
                .vertex(maxX, maxY, minZ, uv.ex() * tw, uv.sy() * th)
                .vertex(maxX, maxY, maxZ, uv.sx() * tw, uv.sy() * th)
                .normal(1, 0, 0));
        }

        if (this.south != null)
        {
            uv = this.south;

            this.quads.add(new ModelQuad()
                .vertex(minX, minY, maxZ, uv.sx() * tw, uv.ey() * th)
                .vertex(maxX, minY, maxZ, uv.ex() * tw, uv.ey() * th)
                .vertex(maxX, maxY, maxZ, uv.ex() * tw, uv.sy() * th)
                .vertex(minX, maxY, maxZ, uv.sx() * tw, uv.sy() * th)
                .normal(0, 0, 1));
        }

        if (this.west != null)
        {
            uv = this.west;

            this.quads.add(new ModelQuad()
                .vertex(minX, minY, minZ, uv.sx() * tw, uv.ey() * th)
                .vertex(minX, minY, maxZ, uv.ex() * tw, uv.ey() * th)
                .vertex(minX, maxY, maxZ, uv.ex() * tw, uv.sy() * th)
                .vertex(minX, maxY, minZ, uv.sx() * tw, uv.sy() * th)
                .normal(-1, 0, 0));
        }

        if (this.up != null)
        {
            uv = this.up;

            this.quads.add(new ModelQuad()
                .vertex(maxX, maxY, minZ, uv.sx() * tw, uv.ey() * th)
                .vertex(minX, maxY, minZ, uv.ex() * tw, uv.ey() * th)
                .vertex(minX, maxY, maxZ, uv.ex() * tw, uv.sy() * th)
                .vertex(maxX, maxY, maxZ, uv.sx() * tw, uv.sy() * th)
                .normal(0, 1, 0));
        }

        if (this.down != null)
        {
            uv = this.down;

            this.quads.add(new ModelQuad()
                .vertex(minX, minY, minZ, uv.ex() * tw, uv.sy() * th)
                .vertex(maxX, minY, minZ, uv.sx() * tw, uv.sy() * th)
                .vertex(maxX, minY, maxZ, uv.sx() * tw, uv.ey() * th)
                .vertex(minX, minY, maxZ, uv.ex() * tw, uv.ey() * th)
                .normal(0, -1, 0));
        }
    }
}

==================================================

--- Файл №22 ---
Путь: main\java\mchorse\chameleon\lib\data\model\ModelQuad.java
--------------------
package mchorse.chameleon.lib.data.model;

import javax.vecmath.Vector3f;
import java.util.ArrayList;
import java.util.List;

public class ModelQuad
{
    public List<ModelVertex> vertices = new ArrayList<ModelVertex>();
    public Vector3f normal = new Vector3f();

    public ModelQuad normal(float x, float y, float z)
    {
        this.normal.set(x, y, z);

        return this;
    }

    public ModelQuad vertex(float x, float y, float z, float u, float v)
    {
        ModelVertex vertex = new ModelVertex();

        vertex.position.set(x, y, z);
        vertex.uv.set(u, v);
        this.vertices.add(vertex);

        return this;
    }
}

==================================================

--- Файл №23 ---
Путь: main\java\mchorse\chameleon\lib\data\model\ModelTransform.java
--------------------
package mchorse.chameleon.lib.data.model;

import javax.vecmath.Vector3f;

public class ModelTransform
{
    public Vector3f translate = new Vector3f();
    public Vector3f scale = new Vector3f(1, 1, 1);
    public Vector3f rotation = new Vector3f();
}

==================================================

--- Файл №24 ---
Путь: main\java\mchorse\chameleon\lib\data\model\ModelUV.java
--------------------
package mchorse.chameleon.lib.data.model;

import javax.vecmath.Vector2f;

public class ModelUV
{
    public Vector2f origin = new Vector2f();
    public Vector2f size = new Vector2f();

    public static ModelUV from(float x1, float y1, float x2, float y2)
    {
        ModelUV uv = new ModelUV();

        uv.origin.x = x1;
        uv.origin.y = y1;
        uv.size.x = x2 - x1;
        uv.size.y = y2 - y1;

        return uv;
    }

    public float sx()
    {
        return this.origin.x;
    }

    public float sy()
    {
        return this.origin.y;
    }

    public float ex()
    {
        return this.origin.x + this.size.x;
    }

    public float ey()
    {
        return this.origin.y + this.size.y;
    }
}

==================================================

--- Файл №25 ---
Путь: main\java\mchorse\chameleon\lib\data\model\ModelVertex.java
--------------------
package mchorse.chameleon.lib.data.model;

import javax.vecmath.Vector2f;
import javax.vecmath.Vector3f;

public class ModelVertex
{
    public Vector2f uv = new Vector2f();
    public Vector3f position = new Vector3f();
}


==================================================

--- Файл №26 ---
Путь: main\java\mchorse\chameleon\lib\parsing\AnimationParser.java
--------------------
package mchorse.chameleon.lib.parsing;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import mchorse.chameleon.lib.data.animation.Animation;
import mchorse.chameleon.lib.data.animation.AnimationChannel;
import mchorse.chameleon.lib.data.animation.AnimationInterpolation;
import mchorse.chameleon.lib.data.animation.AnimationPart;
import mchorse.chameleon.lib.data.animation.AnimationVector;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.molang.MolangParser;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangValue;

import java.util.Map;

public class AnimationParser
{
    public static Animation parse(MolangParser parser, String key, JsonObject object) throws Exception
    {
        Animation animation = new Animation(key);

        if (object.has("animation_length"))
        {
            animation.setLength(object.get("animation_length").getAsDouble());
        }

        if (object.has("bones"))
        {
            for (Map.Entry<String, JsonElement> entry : object.get("bones").getAsJsonObject().entrySet())
            {
                animation.parts.put(entry.getKey(), parsePart(parser, entry.getValue().getAsJsonObject()));
            }
        }

        return animation;
    }

    private static AnimationPart parsePart(MolangParser parser, JsonObject object) throws Exception
    {
        AnimationPart part = new AnimationPart();

        if (object.has("position"))
        {
            parseChannel(parser, part.position, object.get("position"));
        }

        if (object.has("scale"))
        {
            parseChannel(parser, part.scale, object.get("scale"));
        }

        if (object.has("rotation"))
        {
            parseChannel(parser, part.rotation, object.get("rotation"));
        }

        return part;
    }

    private static void parseChannel(MolangParser parser, AnimationChannel channel, JsonElement element) throws Exception
    {
        if (element.isJsonArray())
        {
            AnimationVector vector = parseAnimationVector(parser, element);

            if (vector != null)
            {
                channel.keyframes.add(vector);
                channel.sort();
            }

            return;
        }

        if (!element.isJsonObject())
        {
            return;
        }

        JsonObject object = element.getAsJsonObject();

        if (object.has("vector"))
        {
            channel.keyframes.add(parseAnimationVector(parser, object));
        }
        else
        {
            for (Map.Entry<String, JsonElement> entry : object.entrySet())
            {
                double time;

                try
                {
                    time = Double.parseDouble(entry.getKey());
                }
                catch (Exception e)
                {
                    continue;
                }

                AnimationVector vector = parseAnimationVector(parser, entry.getValue());

                if (vector != null)
                {
                    vector.time = time;
                    channel.keyframes.add(vector);
                }
            }
        }

        channel.sort();
    }

    private static AnimationVector parseAnimationVector(MolangParser parser, JsonElement element) throws Exception
    {
        JsonArray array = element.isJsonArray() ? element.getAsJsonArray() : null;
        JsonArray pre = element.isJsonArray() ? element.getAsJsonArray() : null;

        if (array == null)
        {
            JsonObject object = element.getAsJsonObject();

            if (object.has("vector"))
            {
                array = element.getAsJsonObject().get("vector").getAsJsonArray();
            }
            else if (object.has("post"))
            {
                if (object.get("post").isJsonArray())
                {
                    array = object.get("post").getAsJsonArray();
                }
                else if (object.get("post").isJsonObject() && object.get("post").getAsJsonObject().has("vector"))
                {
                    array = object.get("post").getAsJsonObject().get("vector").getAsJsonArray();
                }

                if (object.has("pre"))
                {
                    if (object.get("pre").isJsonArray())
                    {
                        pre = object.get("pre").getAsJsonArray();
                    }
                    else if (object.get("pre").isJsonObject() && object.get("pre").getAsJsonObject().has("vector"))
                    {
                        pre = object.get("pre").getAsJsonObject().get("vector").getAsJsonArray();
                    }
                }
            }
        }

        if (pre == null)
        {
            pre = array;
        }

        AnimationVector vector = new AnimationVector();

        vector.x = parseValue(parser, array.get(0));
        vector.y = parseValue(parser, array.get(1));
        vector.z = parseValue(parser, array.get(2));
        vector.preX = parseValue(parser, pre.get(0));
        vector.preY = parseValue(parser, pre.get(1));
        vector.preZ = parseValue(parser, pre.get(2));

        if (element.isJsonObject())
        {
            JsonObject object = element.getAsJsonObject();

            /* Hermite support */
            if (object.has("lerp_mode") && object.get("lerp_mode").isJsonPrimitive() && object.get("lerp_mode").getAsString().equals("catmullrom"))
            {
                vector.interp = AnimationInterpolation.HERMITE;
            }
            /* GeckoLib's partial easing support */
            else if (object.has("easing") && object.get("easing").isJsonPrimitive())
            {
                vector.interp = AnimationInterpolation.byName(object.get("easing").getAsString());
            }
        }

        return vector;
    }

    private static MolangExpression parseValue(MolangParser parser, JsonElement element) throws Exception
    {
        JsonPrimitive primitive = element.getAsJsonPrimitive();

        if (primitive.isNumber())
        {
            return new MolangValue(parser, new Constant(primitive.getAsDouble()));
        }

        return parser.parseExpression(primitive.getAsString());
    }
}

==================================================

--- Файл №27 ---
Путь: main\java\mchorse\chameleon\lib\parsing\ModelParser.java
--------------------
package mchorse.chameleon.lib.parsing;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelCube;
import mchorse.chameleon.lib.data.model.ModelUV;
import net.minecraft.client.util.JsonException;

import javax.vecmath.Vector2f;
import javax.vecmath.Vector3f;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class ModelParser
{
    public static Model parse(JsonObject object) throws JsonException
    {
        Model model = new Model();

        object = object.get("minecraft:geometry").getAsJsonArray().get(0).getAsJsonObject();

        if (object.has("description"))
        {
            parseDescription(model, object.get("description").getAsJsonObject());
        }

        if (object.has("bones"))
        {
            parseBones(model, object.get("bones").getAsJsonArray());
        }

        return model;
    }

    private static void parseDescription(Model model, JsonObject object)
    {
        if (object.has("identifier"))
        {
            model.id = object.get("identifier").getAsString();
        }

        if (object.has("texture_width"))
        {
            model.textureWidth = object.get("texture_width").getAsInt();
        }

        if (object.has("texture_height"))
        {
            model.textureHeight = object.get("texture_height").getAsInt();
        }
    }

    private static void parseBones(Model model, JsonArray bones)
    {
        Map<String, List<String>> hierarchy = new HashMap<String, List<String>>();
        Map<String, ModelBone> flatBones = new HashMap<String, ModelBone>();

        for (JsonElement element : bones)
        {
            JsonObject boneElement = element.getAsJsonObject();
            ModelBone bone = new ModelBone(boneElement.get("name").getAsString());

            /* Fill hierarchy information */
            String parent = boneElement.has("parent") ? boneElement.get("parent").getAsString() : "";
            List<String> list = hierarchy.computeIfAbsent(parent, (a) -> new ArrayList<String>());

            list.add(bone.id);

            /* Setup initial transformations */
            if (boneElement.has("pivot"))
            {
                parseVector(boneElement.get("pivot"), bone.initial.translate);
            }

            if (boneElement.has("scale"))
            {
                parseVector(boneElement.get("scale"), bone.initial.scale);
            }

            if (boneElement.has("rotation"))
            {
                parseVector(boneElement.get("rotation"), bone.initial.rotation);

                bone.initial.rotation.x *= -1;
                bone.initial.rotation.y *= -1;
            }

            bone.initial.translate.x *= -1;

            /* Setup cubes */
            if (boneElement.has("cubes"))
            {
                parseCubes(model, bone, boneElement.get("cubes").getAsJsonArray());
            }

            flatBones.put(bone.id, bone);
        }

        /* Setup hierarchy */
        for (Map.Entry<String, List<String>> entry : hierarchy.entrySet())
        {
            if (entry.getKey().isEmpty())
            {
                continue;
            }

            ModelBone bone = flatBones.get(entry.getKey());

            for (String child : entry.getValue())
            {
                bone.children.add(flatBones.get(child));
            }
        }

        List<String> topLevel = hierarchy.get("");

        if (topLevel != null)
        {
            for (String topLevelBone : topLevel)
            {
                model.bones.add(flatBones.get(topLevelBone));
            }
        }
    }

    private static void parseCubes(Model model, ModelBone bone, JsonArray cubes)
    {
        for (JsonElement element : cubes)
        {
            bone.cubes.add(parseCube(model, element.getAsJsonObject()));
        }
    }

    private static ModelCube parseCube(Model model, JsonObject object)
    {
        ModelCube cube = new ModelCube();

        if (object.has("inflate"))
        {
            cube.inflate = object.get("inflate").getAsFloat();
        }

        parseVector(object.get("origin"), cube.origin);
        parseVector(object.get("size"), cube.size);

        if (object.has("pivot"))
        {
            parseVector(object.get("pivot"), cube.pivot);
        }
        else
        {
            cube.pivot.set(cube.origin);
        }

        cube.origin.x *= -1;
        cube.pivot.x *= -1;

        if (object.has("rotation"))
        {
            parseVector(object.get("rotation"), cube.rotation);

            cube.rotation.x *= -1;
            cube.rotation.y *= -1;
        }

        if (object.has("uv"))
        {
            boolean mirror = object.has("mirror") && object.get("mirror").getAsBoolean();

            parseUV(cube, object.get("uv"), mirror);
        }

        cube.generateQuads(model);

        return cube;
    }

    private static void parseUV(ModelCube cube, JsonElement element, boolean mirror)
    {
        if (element.isJsonArray())
        {
            Vector2f boxUV = new Vector2f();

            parseVector(element.getAsJsonArray(), boxUV);
            cube.setupBoxUV(boxUV, mirror);
        }
        else if (element.isJsonObject())
        {
            JsonObject sides = element.getAsJsonObject();

            if (sides.has("north")) cube.north = parseUVSide(sides.get("north").getAsJsonObject());
            if (sides.has("east")) cube.east = parseUVSide(sides.get("east").getAsJsonObject());
            if (sides.has("south")) cube.south = parseUVSide(sides.get("south").getAsJsonObject());
            if (sides.has("west")) cube.west = parseUVSide(sides.get("west").getAsJsonObject());
            if (sides.has("up")) cube.up = parseUVSide(sides.get("up").getAsJsonObject());
            if (sides.has("down")) cube.down = parseUVSide(sides.get("down").getAsJsonObject());
        }
    }

    private static ModelUV parseUVSide(JsonObject uvSide)
    {
        ModelUV uv = new ModelUV();

        parseVector(uvSide.get("uv"), uv.origin);
        parseVector(uvSide.get("uv_size"), uv.size);

        return uv;
    }

    private static void parseVector(JsonElement element, Vector3f vector)
    {
        JsonArray array = element.getAsJsonArray();

        vector.x = array.get(0).getAsFloat();
        vector.y = array.get(1).getAsFloat();
        vector.z = array.get(2).getAsFloat();
    }

    private static void parseVector(JsonElement element, Vector2f vector)
    {
        JsonArray array = element.getAsJsonArray();

        vector.x = array.get(0).getAsFloat();
        vector.y = array.get(1).getAsFloat();
    }
}

==================================================

--- Файл №28 ---
Путь: main\java\mchorse\chameleon\lib\render\ChameleonAxisRenderer.java
--------------------
package mchorse.chameleon.lib.render;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.mclib.client.Draw;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

@SideOnly(Side.CLIENT)
public class ChameleonAxisRenderer implements IChameleonRenderProcessor
{
    @Override
    public boolean renderBone(BufferBuilder builder, MatrixStack stack, ModelBone bone)
    {
        GlStateManager.pushMatrix();
        ChameleonPostRenderer.multiplyMatrix(stack, bone);

        Draw.axis(0.2F);

        GlStateManager.popMatrix();

        return false;
    }
}

==================================================

--- Файл №29 ---
Путь: main\java\mchorse\chameleon\lib\render\ChameleonCubeRenderer.java
--------------------
package mchorse.chameleon.lib.render;

import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelCube;
import mchorse.chameleon.lib.data.model.ModelQuad;
import mchorse.chameleon.lib.data.model.ModelVertex;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.chameleon.metamorph.pose.AnimatedPose;
import mchorse.chameleon.metamorph.pose.AnimatedPoseTransform;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Cube renderer
 *
 * Renders given bones from the model as cubes, fully
 */
@SideOnly(Side.CLIENT)
public class ChameleonCubeRenderer implements IChameleonRenderProcessor
{
    private float r;
    private float g;
    private float b;
    private float a;

    /* Temporary variables to avoid allocating and GC vectors */
    private Vector3f normal = new Vector3f();
    private Vector4f vertex = new Vector4f();

    @Override
    public boolean renderBone(BufferBuilder builder, MatrixStack stack, ModelBone bone)
    {
        int lightX = (int) OpenGlHelper.lastBrightnessX;
        int lightY = (int) OpenGlHelper.lastBrightnessY;

        this.r = bone.color.r;
        this.g = bone.color.g;
        this.b = bone.color.b;
        this.a = bone.color.a;

        if (bone.absoluteBrightness)
        {
            lightX = 0;
        }

        lightX = (int) Interpolation.LINEAR.interpolate(lightX, 240, bone.glow);

        for (ModelCube cube : bone.cubes)
        {
            renderCube(builder, stack, cube, lightX, lightY);
        }

        return false;
    }

    private void renderCube(BufferBuilder builder, MatrixStack stack, ModelCube cube, int lightX, int lightY)
    {
        stack.push();
        stack.moveToCubePivot(cube);
        stack.rotateCube(cube);
        stack.moveBackFromCubePivot(cube);

        for (ModelQuad quad : cube.quads)
        {
            this.normal.set(quad.normal.x, quad.normal.y, quad.normal.z);
            stack.getNormalMatrix().transform(this.normal);

            /* For 0 sized cubes on either axis, to avoid getting dark shading on models
             * which didn't correctly setup the UV faces.
             *
             * For example two wings, first wing uses top face for texturing the flap,
             * and second wing uses bottom face as a flap. In the end, the second wing
             * will appear dark shaded without this fix.
             */
            if (this.normal.getX() < 0 && (cube.size.y == 0 || cube.size.z == 0)) this.normal.x *= -1;
            if (this.normal.getY() < 0 && (cube.size.x == 0 || cube.size.z == 0)) this.normal.y *= -1;
            if (this.normal.getZ() < 0 && (cube.size.x == 0 || cube.size.y == 0)) this.normal.z *= -1;

            for (ModelVertex vertex : quad.vertices)
            {
                this.vertex.set(vertex.position);
                this.vertex.w = 1;
                stack.getModelMatrix().transform(this.vertex);

                builder.pos(this.vertex.x, this.vertex.y, this.vertex.z)
                    .color(this.r, this.g, this.b, this.a)
                    .tex(vertex.uv.x, vertex.uv.y)
                    .lightmap(lightY, lightX)
                    .normal(this.normal.x, this.normal.y, this.normal.z)
                    .endVertex();
            }
        }

        stack.pop();
    }
}

==================================================

--- Файл №30 ---
Путь: main\java\mchorse\chameleon\lib\render\ChameleonPostRenderer.java
--------------------
package mchorse.chameleon.lib.render;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelTransform;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;

/**
 * Post render processor
 *
 * This render processors is responsible for applying given bone's transformation
 * onto OpenGL's matrix stack. Make sure you push before and pop after the matrix
 * stack when you using this!
 */
@SideOnly(Side.CLIENT)
public class ChameleonPostRenderer implements IChameleonRenderProcessor
{
    private static Matrix4f matrix = new Matrix4f();

    private String boneName = "";

    /**
     * Multiply given matrix stack onto OpenGL's matrix stack
     */
    public static void multiplyMatrix(MatrixStack stack, ModelBone bone)
    {
        matrix.set(stack.getModelMatrix());
        matrix.transpose();

        MatrixUtils.matrixToFloat(MatrixUtils.floats, matrix);
        MatrixUtils.buffer.clear();
        MatrixUtils.buffer.put(MatrixUtils.floats);
        MatrixUtils.buffer.flip();

        Vector3f pivot = bone.initial.translate;

        GlStateManager.multMatrix(MatrixUtils.buffer);
        GlStateManager.translate(pivot.x / 16F, pivot.y / 16F, pivot.z / 16F);
    }

    public void setBoneName(String boneName)
    {
        this.boneName = boneName;
    }

    @Override
    public boolean renderBone(BufferBuilder builder, MatrixStack stack, ModelBone bone)
    {
        if (bone.id.equals(this.boneName))
        {
            multiplyMatrix(stack, bone);

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №31 ---
Путь: main\java\mchorse\chameleon\lib\render\ChameleonRenderer.java
--------------------
package mchorse.chameleon.lib.render;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.chameleon.metamorph.pose.AnimatedPose;
import mchorse.mclib.client.render.VertexBuilder;
import mchorse.mclib.utils.files.GlobalTree;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

@SideOnly(Side.CLIENT)
public class ChameleonRenderer
{
    private static final MatrixStack MATRIX_STACK = new MatrixStack();
    private static final ChameleonCubeRenderer CUBE_RENDERER = new ChameleonCubeRenderer();
    private static final ChameleonPostRenderer POST_RENDERER = new ChameleonPostRenderer();
    private static final ChameleonAxisRenderer AXIS_RENDERER = new ChameleonAxisRenderer();

    /* Specific utility methods */

    /**
     * Just render given model
     *
     * The texture should be bind beforehand
     */
    public static void render(Model model)
    {
        GlStateManager.disableCull();
        GlStateManager.enableRescaleNormal();
        GlStateManager.enableBlend();

        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        BufferBuilder builder = Tessellator.getInstance().getBuffer();
        builder.begin(GL11.GL_QUADS, VertexBuilder.getFormat(true, true, true, true));

        processRenderModel(CUBE_RENDERER, builder, MATRIX_STACK, model);

        Tessellator.getInstance().draw();

        GlStateManager.disableBlend();
        GlStateManager.disableRescaleNormal();
        GlStateManager.enableCull();

        GlStateManager.disableLighting();
        GlStateManager.disableTexture2D();
        GlStateManager.disableDepth();

        // processRenderModel(AXIS_RENDERER, null, MATRIX_STACK, model);

        GlStateManager.enableDepth();
        GlStateManager.enableTexture2D();
        GlStateManager.enableLighting();
    }

    /**
     * Post render (multiply the current matrix stack by bone's
     * transformations by given name)
     */
    public static boolean postRender(Model model, String boneName)
    {
        POST_RENDERER.setBoneName(boneName);

        /* Buffer builder isn't used in this render processor, but just in case */
        return processRenderModel(POST_RENDERER, Tessellator.getInstance().getBuffer(), MATRIX_STACK, model);
    }

    /* Generic render methods */

    /**
     * Process/render given model
     *
     * This method recursively goes through all bones in the model, and
     * applies given render processor. Processor may return true from its
     * sole method which means that iteration should be halted
     */
    public static boolean processRenderModel(IChameleonRenderProcessor renderProcessor, BufferBuilder builder, MatrixStack stack, Model model)
    {
        for (ModelBone bone : model.bones)
        {
            if (processRenderRecursively(renderProcessor, builder, stack, bone))
            {
                return true;
            }
        }

        return false;
    }

    /**
     * Apply the render processor, recursively
     */
    private static boolean processRenderRecursively(IChameleonRenderProcessor renderProcessor, BufferBuilder builder, MatrixStack stack, ModelBone bone)
    {
        stack.push();
        stack.translateBone(bone);
        stack.moveToBonePivot(bone);
        stack.rotateBone(bone);
        stack.scaleBone(bone);
        stack.moveBackFromBonePivot(bone);

        if (bone.visible)
        {
            if (renderProcessor.renderBone(builder, stack, bone))
            {
                stack.pop();

                return true;
            }

            for (ModelBone childBone : bone.children)
            {
                if (processRenderRecursively(renderProcessor, builder, stack, childBone))
                {
                    stack.pop();

                    return true;
                }
            }
        }

        stack.pop();

        return false;
    }
}

==================================================

--- Файл №32 ---
Путь: main\java\mchorse\chameleon\lib\render\IChameleonRenderProcessor.java
--------------------
package mchorse.chameleon.lib.render;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.utils.MatrixStack;
import net.minecraft.client.renderer.BufferBuilder;

public interface IChameleonRenderProcessor
{
    public boolean renderBone(BufferBuilder builder, MatrixStack stack, ModelBone bone);
}

==================================================

--- Файл №33 ---
Путь: main\java\mchorse\chameleon\lib\utils\MatrixStack.java
--------------------
package mchorse.chameleon.lib.utils;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelCube;

import javax.vecmath.Matrix3f;
import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3f;
import java.util.Stack;

/**
 * Simple implementation of a matrix stack
 */
public class MatrixStack
{
    private Stack<Matrix4f> model = new Stack<Matrix4f>();
    private Stack<Matrix3f> normal = new Stack<Matrix3f>();

    private Matrix4f tempModelMatrix = new Matrix4f();
    private Matrix3f tempNormalMatrix = new Matrix3f();

    public MatrixStack()
    {
        Matrix4f model = new Matrix4f();
        Matrix3f normal = new Matrix3f();

        model.setIdentity();
        normal.setIdentity();

        this.model.add(model);
        this.normal.add(normal);
    }

    public Matrix4f getModelMatrix()
    {
        return this.model.peek();
    }

    public Matrix3f getNormalMatrix()
    {
        return this.normal.peek();
    }

    public void push()
    {
        this.model.add(new Matrix4f(this.model.peek()));
        this.normal.add(new Matrix3f(this.normal.peek()));
    }

    public void pop()
    {
        if (this.model.size() == 1)
        {
            throw new IllegalStateException("A one level stack can't be popped!");
        }

        this.model.pop();
        this.normal.pop();
    }

    /* Translate */

    public void translate(float x, float y, float z)
    {
        this.translate(new Vector3f(x, y, z));
    }

    public void translate(Vector3f vec)
    {
        this.tempModelMatrix.setIdentity();
        this.tempModelMatrix.setTranslation(vec);

        this.model.peek().mul(this.tempModelMatrix);
    }

    public void moveToCubePivot(ModelCube cube)
    {
        Vector3f pivot = cube.pivot;

        this.translate(pivot.x / 16F, pivot.y / 16F, pivot.z / 16F);
    }

    public void moveBackFromCubePivot(ModelCube cube)
    {
        Vector3f pivot = cube.pivot;

        this.translate(-pivot.x / 16F, -pivot.y / 16F, -pivot.z / 16F);
    }

    public void moveToBonePivot(ModelBone bone)
    {
        Vector3f pivot = bone.initial.translate;

        this.translate(pivot.x / 16F, pivot.y / 16F, pivot.z / 16F);
    }

    public void moveBackFromBonePivot(ModelBone bone)
    {
        Vector3f pivot = bone.initial.translate;

        this.translate(-pivot.x / 16F, -pivot.y / 16F, -pivot.z / 16F);
    }

    public void translateBone(ModelBone bone)
    {
        Vector3f translate = bone.current.translate;
        Vector3f pivot = bone.initial.translate;

        this.translate(-(translate.x - pivot.x) / 16F, (translate.y - pivot.y) / 16F, (translate.z - pivot.z) / 16F);
    }

    /* Scale */

    public void scale(float x, float y, float z)
    {
        this.tempModelMatrix.setIdentity();
        this.tempModelMatrix.setM00(x);
        this.tempModelMatrix.setM11(y);
        this.tempModelMatrix.setM22(z);

        this.model.peek().mul(this.tempModelMatrix);

        if (x < 0 || y < 0 || z < 0)
        {
            this.tempNormalMatrix.setIdentity();
            this.tempNormalMatrix.setM00(x < 0 ? -1 : 1);
            this.tempNormalMatrix.setM11(y < 0 ? -1 : 1);
            this.tempNormalMatrix.setM22(z < 0 ? -1 : 1);

            this.normal.peek().mul(this.tempNormalMatrix);
        }
    }

    public void scaleBone(ModelBone bone)
    {
        this.scale(bone.current.scale.x, bone.current.scale.y, bone.current.scale.z);
    }

    /* Rotate */

    public void rotateX(float radian)
    {
        this.tempModelMatrix.setIdentity();
        this.tempModelMatrix.rotX(radian);

        this.tempNormalMatrix.setIdentity();
        this.tempNormalMatrix.rotX(radian);

        this.model.peek().mul(this.tempModelMatrix);
        this.normal.peek().mul(this.tempNormalMatrix);
    }

    public void rotateY(float radian)
    {
        this.tempModelMatrix.setIdentity();
        this.tempModelMatrix.rotY(radian);

        this.tempNormalMatrix.setIdentity();
        this.tempNormalMatrix.rotY(radian);

        this.model.peek().mul(this.tempModelMatrix);
        this.normal.peek().mul(this.tempNormalMatrix);
    }

    public void rotateZ(float radian)
    {
        this.tempModelMatrix.setIdentity();
        this.tempModelMatrix.rotZ(radian);

        this.tempNormalMatrix.setIdentity();
        this.tempNormalMatrix.rotZ(radian);

        this.model.peek().mul(this.tempModelMatrix);
        this.normal.peek().mul(this.tempNormalMatrix);
    }

    public void rotateBone(ModelBone bone)
    {
        final float degreesToPi = (float) (Math.PI / 180D);

        float z = bone.current.rotation.z;
        float y = bone.current.rotation.y;
        float x = bone.current.rotation.x;

        if (z != 0F) this.rotateZ(z * degreesToPi);
        if (y != 0F) this.rotateY(y * degreesToPi);
        if (x != 0F) this.rotateX(x * degreesToPi);
    }

    public void rotateCube(ModelCube bone)
    {
        final float degreesToPi = (float) (Math.PI / 180D);

        Vector3f rotation = bone.rotation;
        Matrix4f matrix4f = new Matrix4f();
        Matrix3f matrix3f = new Matrix3f();

        this.tempModelMatrix.setIdentity();
        matrix4f.rotZ(rotation.z * degreesToPi);
        this.tempModelMatrix.mul(matrix4f);

        matrix4f.rotY(rotation.y * degreesToPi);
        this.tempModelMatrix.mul(matrix4f);

        matrix4f.rotX(rotation.x * degreesToPi);
        this.tempModelMatrix.mul(matrix4f);

        this.tempNormalMatrix.setIdentity();
        matrix3f.rotZ(rotation.z * degreesToPi);
        this.tempNormalMatrix.mul(matrix3f);

        matrix3f.rotY(rotation.y * degreesToPi);
        this.tempNormalMatrix.mul(matrix3f);

        matrix3f.rotX(rotation.x * degreesToPi);
        this.tempNormalMatrix.mul(matrix3f);

        this.model.peek().mul(this.tempModelMatrix);
        this.normal.peek().mul(this.tempNormalMatrix);
    }
}


==================================================

--- Файл №34 ---
Путь: main\java\mchorse\chameleon\mclib\ChameleonTree.java
--------------------
package mchorse.chameleon.mclib;

import mchorse.mclib.utils.files.FileTree;
import mchorse.mclib.utils.files.entries.FolderImageEntry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;

@SideOnly(Side.CLIENT)
public class ChameleonTree extends FileTree
{
    public ChameleonTree(File folder)
    {
        this.root = new FolderImageEntry("c.s", folder, null);
    }
}

==================================================

--- Файл №35 ---
Путь: main\java\mchorse\chameleon\mclib\ValueButtons.java
--------------------
package mchorse.chameleon.mclib;

import mchorse.chameleon.ClientProxy;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.config.values.ValueGUI;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueButtons extends ValueGUI
{
    public ValueButtons(String id)
    {
        super(id);
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel config)
    {
        GuiButtonElement models = new GuiButtonElement(mc, IKey.lang("chameleon.gui.config.models"), (button) -> GuiUtils.openFolder(ClientProxy.modelsFile.getAbsolutePath()));
        GuiButtonElement tutorial = new GuiButtonElement(mc, IKey.lang("chameleon.gui.config.tutorial"), (button) -> GuiUtils.openWebLink(this.getTutorialURL()));
        GuiButtonElement discord = new GuiButtonElement(mc, IKey.lang("chameleon.gui.config.discord"), (button) -> GuiUtils.openWebLink(this.getDiscordURL()));
        GuiButtonElement wiki = new GuiButtonElement(mc, IKey.lang("chameleon.gui.config.wiki"), (button) -> GuiUtils.openWebLink(this.getWikiURL()));

        GuiElement first = Elements.row(mc, 5, 0, 20, models, tutorial);
        GuiElement second = Elements.row(mc, 5, 0, 20, discord, wiki);

        return Arrays.asList(first, second);
    }

    @SideOnly(Side.CLIENT)
    private String getTutorialURL()
    {
        return this.getLangOrDefault("chameleon.gui.url.tutorial", "https://www.youtube.com/playlist?list=PLLnllO8nnzE94k_xh3tqX58_tJzx92NcG");
    }

    @SideOnly(Side.CLIENT)
    private String getDiscordURL()
    {
        return this.getLangOrDefault("chameleon.gui.url.discord", "https://discord.gg/qfxrqUF");
    }

    @SideOnly(Side.CLIENT)
    private String getWikiURL()
    {
        return this.getLangOrDefault("chameleon.gui.url.wiki", "https://github.com/mchorse/chameleon/wiki");
    }

    @SideOnly(Side.CLIENT)
    private String getLangOrDefault(String key, String def)
    {
        String string = I18n.format(key);

        return key.equals(key) ? def : key;
    }
}

==================================================

--- Файл №36 ---
Путь: main\java\mchorse\chameleon\metamorph\ChameleonFactory.java
--------------------
package mchorse.chameleon.metamorph;

import mchorse.chameleon.metamorph.editor.GuiChameleonMorph;
import mchorse.metamorph.api.IMorphFactory;
import mchorse.metamorph.api.MorphManager;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;

import java.util.List;

/**
 * Chameleon morph factory
 *
 * This factory is responsible for adding all custom modeled morphs provided by
 * a user (in his config folder)
 */
public class ChameleonFactory implements IMorphFactory
{
    public ChameleonSection section;

    @Override
    public void register(MorphManager manager)
    {
        manager.list.register(this.section = new ChameleonSection("chameleon"));
    }

    @Override
    public void registerMorphEditors(Minecraft mc, List<GuiAbstractMorph> editors)
    {
        editors.add(new GuiChameleonMorph(mc));
    }

    @Override
    public AbstractMorph getMorphFromNBT(NBTTagCompound tag)
    {
        ChameleonMorph morph = new ChameleonMorph();

        morph.fromNBT(tag);

        return morph;
    }

    @Override
    public boolean hasMorph(String morph)
    {
        return morph.startsWith("chameleon.");
    }
}

==================================================

--- Файл №37 ---
Путь: main\java\mchorse\chameleon\metamorph\ChameleonMorph.java
--------------------
package mchorse.chameleon.metamorph;

import mchorse.chameleon.ClientProxy;
import mchorse.chameleon.animation.ActionPlayback;
import mchorse.chameleon.animation.ActionsConfig;
import mchorse.chameleon.animation.Animator;
import mchorse.chameleon.lib.ChameleonAnimator;
import mchorse.chameleon.lib.ChameleonModel;
import mchorse.chameleon.lib.data.model.Model;
import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelTransform;
import mchorse.chameleon.lib.render.ChameleonRenderer;
import mchorse.chameleon.metamorph.pose.AnimatedPose;
import mchorse.chameleon.metamorph.pose.AnimatedPoseTransform;
import mchorse.chameleon.metamorph.pose.PoseAnimation;
import mchorse.mclib.client.render.RenderLightmap;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.api.models.IMorphProvider;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.api.morphs.utils.Animation;
import mchorse.metamorph.api.morphs.utils.IAnimationProvider;
import mchorse.metamorph.api.morphs.utils.IMorphGenerator;
import mchorse.metamorph.api.morphs.utils.ISyncableMorph;
import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.BodyPartManager;
import mchorse.metamorph.bodypart.IBodyPartProvider;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.util.Constants;
import net.minecraftforge.fml.common.FMLCommonHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Objects;

public class ChameleonMorph extends AbstractMorph implements IBodyPartProvider, ISyncableMorph, IAnimationProvider, IMorphGenerator
{
    public ResourceLocation skin;
    public AnimatedPose pose;
    public ActionsConfig actions = new ActionsConfig();
    public BodyPartManager parts = new BodyPartManager();

    public float scale = 1F;
    public float scaleGui = 1F;
    private float lastScale = 1F;

    public PoseAnimation animation = new PoseAnimation();

    /* Syncable action */
    public boolean isActionPlayer;

    public ActionPlayback lastAnimAction;

    /**
     * Cached key value
     */
    private String key;

    @SideOnly(Side.CLIENT)
    private Animator animator;

    private boolean updateAnimator = false;
    private long lastUpdate;

    public float getScale(float partialTick)
    {
        if (this.animation.isInProgress())
        {
            return this.animation.interp.interpolate(this.lastScale, this.scale, this.animation.getFactor(partialTick));
        }

        return this.scale;
    }

    @SideOnly(Side.CLIENT)
    protected Animator getAnimator()
    {
        if (this.animator == null)
        {
            this.animator = new Animator(this);
        }

        return this.animator;
    }

    @Override
    public void pause(AbstractMorph previous, int offset)
    {
        this.animation.pause(offset);

        while (previous instanceof IMorphProvider)
        {
            previous = ((IMorphProvider) previous).getMorph();
        }

        AnimatedPose pose = null;

        if (previous instanceof ChameleonMorph)
        {
            ChameleonMorph morph = (ChameleonMorph) previous;

            pose = morph.pose;

            if (pose != null)
            {
                pose = pose.clone();
            }

            this.lastScale = morph.scale;

            if (FMLCommonHandler.instance().getEffectiveSide() == Side.CLIENT && this.isActionPlayer && morph.isActionPlayer)
            {
                morph.checkAnimator();

                if (morph.animator != null && morph.actions.getConfig("animation") != null)
                {
                    this.lastAnimAction = morph.animator.createAction(morph.animator.animation, morph.actions.getConfig("animation").clone(), false);
                }
                else
                {
                    this.lastAnimAction = null;
                }

                if (this.lastAnimAction != null)
                {
                    this.lastAnimAction.config.tick += morph.animation.getFactor(0F) * morph.animation.duration * Math.abs(this.lastAnimAction.config.speed);
                }
            }
        }

        this.animation.last = pose == null ? (previous == null ? this.pose : new AnimatedPose()) : pose;
        this.parts.pause(previous, offset);
        
        this.updateAnimator = true;
    }

    @Override
    public boolean isPaused()
    {
        return this.animation.paused;
    }

    @Override
    public Animation getAnimation()
    {
        return this.animation;
    }

    @Override
    public BodyPartManager getBodyPart()
    {
        return this.parts;
    }

    @Override
    public boolean canGenerate()
    {
        return this.animation.isInProgress();
    }

    @Override
    public AbstractMorph genCurrentMorph(float partialTicks)
    {
        ChameleonMorph morph = (ChameleonMorph) this.copy();

        morph.pose = this.getCurrentPose(partialTicks);
        morph.animation.duration = this.animation.progress;

        morph.parts.parts.clear();

        for (BodyPart part : this.parts.parts)
        {
            morph.parts.parts.add(part.genCurrentBodyPart(this, partialTicks));
        }

        return morph.copy();
    }

    public String getKey()
    {
        if (this.key == null)
        {
            this.key = this.name.replaceAll("^chameleon\\.", "");
        }

        return this.key;
    }

    @SideOnly(Side.CLIENT)
    public void updateAnimator()
    {
        this.updateAnimator = true;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void renderOnScreen(EntityPlayer target, int x, int y, float scale, float alpha)
    {
        scale *= this.scaleGui;

        GlStateManager.enableDepth();
        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, 0);
        GlStateManager.scale(scale, scale, scale);
        GlStateManager.rotate(45.0F, -1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(135.0F, 0.0F, -1.0F, 0.0F);
        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);

        RenderHelper.enableStandardItemLighting();

        this.renderModel(target, 0F);

        RenderHelper.disableStandardItemLighting();

        GlStateManager.popMatrix();
        GlStateManager.disableDepth();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public void render(EntityLivingBase target, double x, double y, double z, float entityYaw, float partialTicks)
    {
        float scale = this.getScale(partialTicks);

        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, z);

        boolean captured = MatrixUtils.captureMatrix();

        GlStateManager.scale(scale, scale, scale);

        float renderYawOffset = Interpolations.lerp(target.prevRenderYawOffset, target.renderYawOffset, partialTicks);

        GlStateManager.rotate(-renderYawOffset + 180, 0, 1, 0);
        GlStateManager.color(1, 1, 1, 1);

        this.renderModel(target, partialTicks);

        if (captured)
        {
            MatrixUtils.releaseMatrix();
        }

        GlStateManager.popMatrix();
    }

    @SideOnly(Side.CLIENT)
    private void renderModel(EntityLivingBase target, float partialTicks)
    {
        GlStateManager.enableBlend();
        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);
        GlStateManager.enableAlpha();

        ChameleonModel chameleonModel = this.getModel();

        if (chameleonModel == null)
        {
            return;
        }

        this.checkAnimator();

        Model model = chameleonModel.model;

        ChameleonAnimator.resetPose(model);

        if (!chameleonModel.isStatic())
        {
            this.getAnimator().applyActions(target, model, partialTicks);
        }

        this.applyPose(model, partialTicks);

        /* Render the model */
        if (this.skin != null)
        {
            Minecraft.getMinecraft().renderEngine.bindTexture(this.skin);
        }

        boolean hurtLight = RenderLightmap.set(target, partialTicks);

        ChameleonRenderer.render(model);

        if (hurtLight)
        {
            RenderLightmap.unset();
        }

        /* Render body parts */
        GlStateManager.color(1, 1, 1);

        this.parts.initBodyParts();

        for (BodyPart part : this.parts.parts)
        {
            GlStateManager.pushMatrix();

            if (ChameleonRenderer.postRender(model, part.limb))
            {
                part.render(this, target, partialTicks);
            }

            GlStateManager.popMatrix();
        }
    }

    @SideOnly(Side.CLIENT)
    private void checkAnimator()
    {
        if (this.updateAnimator)
        {
            this.updateAnimator = false;
            this.getAnimator().refresh();
        }
    }

    @SideOnly(Side.CLIENT)
    private void applyPose(Model model, float partialTicks)
    {
        AnimatedPose pose = this.pose;
        boolean inProgress = this.animation.isInProgress();

        if (inProgress)
        {
            pose = this.animation.calculatePose(this.pose, this.getModel(), partialTicks);
        }

        for (ModelBone bone : model.bones)
        {
            this.applyPose(bone, pose);
        }
    }

    @SideOnly(Side.CLIENT)
    private void applyPose(ModelBone bone, AnimatedPose pose)
    {
        if (pose != null && pose.bones.containsKey(bone.id))
        {
            AnimatedPoseTransform transform = pose.bones.get(bone.id);
            ModelTransform initial = bone.initial;
            ModelTransform current = bone.current;
            float factor = transform.fixed * pose.animated;
            final float piToDegrees = (float) (180D / Math.PI);

            current.translate.x = Interpolations.lerp(initial.translate.x, current.translate.x, factor) + transform.x;
            current.translate.y = Interpolations.lerp(initial.translate.y, current.translate.y, factor) + transform.y;
            current.translate.z = Interpolations.lerp(initial.translate.z, current.translate.z, factor) + transform.z;

            current.rotation.x = Interpolations.lerp(initial.rotation.x, current.rotation.x, factor) + transform.rotateX * piToDegrees;
            current.rotation.y = Interpolations.lerp(initial.rotation.y, current.rotation.y, factor) + transform.rotateY * piToDegrees;
            current.rotation.z = Interpolations.lerp(initial.rotation.z, current.rotation.z, factor) + transform.rotateZ * piToDegrees;

            current.scale.x = Interpolations.lerp(initial.scale.x, current.scale.x, factor) + (transform.scaleX - 1);
            current.scale.y = Interpolations.lerp(initial.scale.y, current.scale.y, factor) + (transform.scaleY - 1);
            current.scale.z = Interpolations.lerp(initial.scale.z, current.scale.z, factor) + (transform.scaleZ - 1);

            bone.absoluteBrightness = transform.absoluteBrightness;
            bone.glow = transform.glow;
            bone.color.copy(transform.color);
        }

        for (ModelBone childBone : bone.children)
        {
            this.applyPose(childBone, pose);
        }
    }

    private AnimatedPose getCurrentPose(float partialTicks)
    {
        if (this.getModel() == null)
        {
            return this.pose == null ? new AnimatedPose() : this.pose.clone();
        }
        else
        {
            return this.animation.calculatePose(this.pose, this.getModel(), partialTicks).clone();
        }
    }

    @SideOnly(Side.CLIENT)
    public ChameleonModel getModel()
    {
        return ClientProxy.chameleonModels.get(this.getKey());
    }

    @Override
    public void update(EntityLivingBase target)
    {
        this.animation.update();
        this.parts.updateBodyLimbs(this, target);

        super.update(target);

        if (target.world.isRemote)
        {
            this.updateClient(target);
        }
    }

    @SideOnly(Side.CLIENT)
    private void updateClient(EntityLivingBase target)
    {
        ChameleonModel model = getModel();

        if (model == null || model.isStatic())
        {
            return;
        }

        if (this.lastUpdate < model.lastUpdate)
        {
            this.lastUpdate = model.lastUpdate;
            this.updateAnimator = true;
        }

        this.checkAnimator();
        this.getAnimator().update(target);
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof ChameleonMorph)
        {
            ChameleonMorph morph = (ChameleonMorph) obj;

            result = result && Objects.equals(morph.skin, this.skin);
            result = result && Objects.equals(morph.pose, this.pose);
            result = result && Objects.equals(morph.parts, this.parts);
            result = result && Objects.equals(morph.actions, this.actions);
            result = result && Objects.equals(morph.animation, this.animation);
            result = result && morph.scale == this.scale;
            result = result && morph.scaleGui == this.scaleGui;
            result = result && morph.isActionPlayer == this.isActionPlayer;
        }

        return result;
    }

    @Override
    public boolean canMerge(AbstractMorph morph)
    {
        if (morph instanceof ChameleonMorph)
        {
            ChameleonMorph animated = (ChameleonMorph) morph;

            if (Objects.equals(this.getKey(), animated.getKey()))
            {
                this.mergeBasic(morph);

                this.lastScale = this.getScale(0);
                this.animation.paused = false;
                this.animation.last = this.pose == null ? new AnimatedPose() : this.pose.clone();

                if (FMLCommonHandler.instance().getEffectiveSide() == Side.CLIENT && this.isActionPlayer && animated.isActionPlayer)
                {
                    this.checkAnimator();

                    if (this.animator != null && this.actions.getConfig("animation") != null)
                    {
                        this.lastAnimAction = this.animator.createAction(this.animator.animation, this.actions.getConfig("animation").clone(), false);
                    }
                    else
                    {
                        this.lastAnimAction = null;
                    }

                    if (this.lastAnimAction != null)
                    {
                        this.lastAnimAction.config.tick += this.animation.getFactor(0F) * this.animation.duration * Math.abs(this.lastAnimAction.config.speed);
                    }
                }

                this.isActionPlayer = animated.isActionPlayer;

                this.skin = RLUtils.clone(animated.skin);
                this.pose = animated.pose == null ? null : animated.pose.clone();
                this.actions.copy(animated.actions);
                this.parts.merge(animated.parts);
                this.animation.merge(animated.animation);
                this.scale = animated.scale;
                this.scaleGui = animated.scaleGui;
                
                this.updateAnimator = true;

                return true;
            }
        }

        return false;
    }

    @Override
    public void afterMerge(AbstractMorph morph)
    {
        super.afterMerge(morph);

        while (morph instanceof IMorphProvider)
        {
            morph = ((IMorphProvider) morph).getMorph();
        }

        if (morph instanceof IBodyPartProvider)
        {
            this.recursiveAfterMerge(this, (IBodyPartProvider) morph);
        }

        if (morph instanceof ChameleonMorph)
        {
            ChameleonMorph animated = (ChameleonMorph) morph;

            if (Objects.equals(this.getKey(), animated.getKey()))
            {
                this.animation.last = this.pose == null ? new AnimatedPose() : this.pose.clone();

                if (FMLCommonHandler.instance().getEffectiveSide() == Side.CLIENT && this.isActionPlayer && animated.isActionPlayer)
                {
                    animated.checkAnimator();

                    if (animated.animator != null && animated.actions.getConfig("animation") != null)
                    {
                        this.lastAnimAction = animated.animator.createAction(animated.animator.animation, animated.actions.getConfig("animation").clone(), false);
                    }
                    else
                    {
                        this.lastAnimAction = null;
                    }

                    if (this.lastAnimAction != null)
                    {
                        this.lastAnimAction.config.tick += animated.animation.getFactor(0F) * animated.animation.duration * Math.abs(this.lastAnimAction.config.speed);
                    }
                }

                if (animated.animator != null)
                {
                    this.animator = animated.animator;
                    this.animator.morph = this;
                    this.updateAnimator = true;
                }
            }
        }
    }

    private void recursiveAfterMerge(IBodyPartProvider target, IBodyPartProvider destination)
    {
        for (int i = 0, c = target.getBodyPart().parts.size(); i < c; i++)
        {
            if (i >= destination.getBodyPart().parts.size())
            {
                break;
            }

            AbstractMorph a = target.getBodyPart().parts.get(i).morph.get();
            AbstractMorph b = destination.getBodyPart().parts.get(i).morph.get();

            if (a != null)
            {
                a.afterMerge(b);
            }
        }
    }

    @Override
    public AbstractMorph create()
    {
        return new ChameleonMorph();
    }

    @Override
    public void copy(AbstractMorph from)
    {
        super.copy(from);

        if (from instanceof ChameleonMorph)
        {
            ChameleonMorph morph = (ChameleonMorph) from;

            this.skin = RLUtils.clone(morph.skin);

            if (morph.pose != null)
            {
                this.pose = morph.pose.clone();
            }

            this.actions.copy(morph.actions);
            this.parts.copy(morph.parts);
            this.animation.copy(morph.animation);
            this.scale = morph.scale;
            this.scaleGui = morph.scaleGui;
            this.isActionPlayer = morph.isActionPlayer;
        }
    }

    @Override
    public float getWidth(EntityLivingBase target)
    {
        return 0.6F;
    }

    @Override
    public float getHeight(EntityLivingBase target)
    {
        return 1.8F;
    }

    @Override
    public void reset()
    {
        super.reset();

        this.key = null;
        this.skin = null;
        this.pose = null;
        this.actions = new ActionsConfig();
        this.parts.reset();

        this.scale = this.scaleGui = this.lastScale = 1;

        this.isActionPlayer = false;

        this.updateAnimator = true;
    }

    @Override
    public void toNBT(NBTTagCompound tag)
    {
        super.toNBT(tag);

        if (this.skin != null)
        {
            tag.setTag("Skin", RLUtils.writeNbt(this.skin));
        }

        if (this.pose != null)
        {
            tag.setTag("Pose", this.pose.toNBT());
        }

        NBTTagList bodyParts = this.parts.toNBT();

        if (bodyParts != null)
        {
            tag.setTag("BodyParts", bodyParts);
        }

        NBTTagCompound animation = this.animation.toNBT();

        if (!animation.hasNoTags())
        {
            tag.setTag("Transition", animation);
        }

        NBTTagCompound actions = this.actions.toNBT();

        if (actions != null)
        {
            tag.setTag("Actions", actions);
        }

        if (this.scale != 1F)
        {
            tag.setFloat("Scale", this.scale);
        }

        if (this.scaleGui != 1F)
        {
            tag.setFloat("ScaleGUI", this.scaleGui);
        }

        if (this.isActionPlayer)
        {
            tag.setBoolean("ActionPlayer", this.isActionPlayer);
        }
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("Skin"))
        {
            this.skin = RLUtils.create(tag.getTag("Skin"));
        }

        if (tag.hasKey("Pose", Constants.NBT.TAG_COMPOUND))
        {
            this.pose = new AnimatedPose();
            this.pose.fromNBT(tag.getCompoundTag("Pose"));
        }

        if (tag.hasKey("BodyParts", 9))
        {
            this.parts.fromNBT(tag.getTagList("BodyParts", 10));
        }

        if (tag.hasKey("Transition"))
        {
            this.animation.fromNBT(tag.getCompoundTag("Transition"));
        }

        if (tag.hasKey("Actions"))
        {
            this.actions.fromNBT(tag.getCompoundTag("Actions"));
        }

        if (tag.hasKey("Scale"))
        {
            this.scale = tag.getFloat("Scale");
        }

        if (tag.hasKey("ScaleGUI"))
        {
            this.scaleGui = tag.getFloat("ScaleGUI");
        }

        if (tag.hasKey("ActionPlayer"))
        {
            this.isActionPlayer = tag.getBoolean("ActionPlayer");
        }
    }
}

==================================================

--- Файл №38 ---
Путь: main\java\mchorse\chameleon\metamorph\ChameleonSection.java
--------------------
package mchorse.chameleon.metamorph;

import mchorse.chameleon.Chameleon;
import mchorse.chameleon.ClientProxy;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.metamorph.api.creative.categories.MorphCategory;
import mchorse.metamorph.api.creative.sections.MorphSection;
import net.minecraft.world.World;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.HashMap;
import java.util.Map;

public class ChameleonSection extends MorphSection
{
    public ChameleonSection(String title)
    {
        super(title);
    }

    @Override
    public void update(World world)
    {
        /* Reload models */
        Chameleon.proxy.reloadModels();

        this.categories.clear();

        Map<String, ChameleonCategory> categories = new HashMap<String, ChameleonCategory>();

        for (String key : Chameleon.proxy.getModelKeys())
        {
            ChameleonMorph morph = new ChameleonMorph();
            FolderEntry skins = ClientProxy.tree.getByPath(key + "/skins/", null);

            if (skins != null)
            {
                for (AbstractEntry entry : skins.getEntries())
                {
                    if (entry instanceof FileEntry)
                    {
                        morph.skin = ((FileEntry) entry).resource;

                        break;
                    }
                }
            }

            morph.name = "chameleon." + key;

            String categoryKey = key.contains("/") ? key.substring(0, key.lastIndexOf("/")) : "";
            ChameleonCategory category = categories.get(categoryKey);

            if (category == null)
            {
                category = new ChameleonCategory(this, "chameleon", categoryKey);
                categories.put(categoryKey, category);
            }

            category.add(morph);
        }

        for (ChameleonCategory category : categories.values())
        {
            category.sort();
            this.categories.add(category);
        }

        this.categories.sort((a, b) -> a.getTitle().compareTo(b.getTitle()));
    }

    public static class ChameleonCategory extends MorphCategory
    {
        private String subtitle;

        public ChameleonCategory(MorphSection parent, String title, String subtitle)
        {
            super(parent, title);

            this.subtitle = subtitle;
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getTitle()
        {
            return super.getTitle() + (this.subtitle == null || this.subtitle.isEmpty() ? "" : " (" + this.subtitle + ")");
        }
    }
}

==================================================

--- Файл №39 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\GuiActionsPanel.java
--------------------
package mchorse.chameleon.metamorph.editor;

import mchorse.chameleon.animation.ActionConfig;
import mchorse.chameleon.lib.data.animation.Animation;
import mchorse.chameleon.metamorph.ChameleonMorph;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringSearchListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiActionsPanel extends GuiMorphPanel<ChameleonMorph, GuiChameleonMorph>
{
    public static final String[] ACTIONS = new String[] {"Idle", "Running", "Sprinting", "Crouching", "CrouchingIdle", "Swimming", "SwimmingIdle", "Flying", "FlyingIdle", "Riding", "RidingIdle", "Dying", "Falling", "Sleeping", "Jump", "Swipe", "Hurt", "Land", "Shoot", "Consume", "Animation"};

    public ActionConfig config;

    public GuiStringListElement configs;
    public GuiElement fields;
    public GuiStringSearchListElement action;
    public GuiToggleElement clamp;
    public GuiToggleElement reset;
    public GuiTrackpadElement speed;
    public GuiTrackpadElement fade;
    public GuiTrackpadElement tick;

    private IKey actionsTitle = IKey.lang("chameleon.gui.editor.actions.actions");
    private IKey actionTitle = IKey.lang("chameleon.gui.editor.actions.action");

    public GuiActionsPanel(Minecraft mc, GuiChameleonMorph editor)
    {
        super(mc, editor);

        this.configs = new GuiStringListElement(mc, (str) -> this.selectAction(str.get(0)));

        for (String action : ACTIONS)
        {
            this.configs.add(action);
        }

        this.fields = new GuiElement(mc).noCulling();
        this.configs.sort();
        this.configs.flex().relative(this).set(10, 22, 110, 90).h(1, -35);

        this.action = new GuiStringSearchListElement(mc, (value) -> 
        {
            this.config.name = value.get(0);
            this.morph.updateAnimator();
        });
        this.clamp = new GuiToggleElement(mc, IKey.lang("chameleon.gui.editor.actions.clamp"), false, (b) -> this.config.clamp = b.isToggled());
        this.reset = new GuiToggleElement(mc, IKey.lang("chameleon.gui.editor.actions.reset"), false, (b) -> this.config.reset = b.isToggled());
        this.speed = new GuiTrackpadElement(mc, (value) -> this.config.speed = value.floatValue());
        this.speed.tooltip(IKey.lang("chameleon.gui.editor.actions.speed"));
        this.fade = new GuiTrackpadElement(mc, (value) -> this.config.fade = value.intValue());
        this.fade.tooltip(IKey.lang("chameleon.gui.editor.actions.fade"));
        this.fade.limit(0, Integer.MAX_VALUE, true);
        this.tick = new GuiTrackpadElement(mc, (value) -> this.config.tick = value.intValue());
        this.tick.tooltip(IKey.lang("chameleon.gui.editor.actions.tick"));
        this.tick.limit(0, Integer.MAX_VALUE, true);

        GuiElement fields = new GuiElement(mc);

        fields.flex().relative(this).xy(1F, 1F).w(130).anchor(1, 1).column(5).vertical().stretch().padding(10);
        fields.add(this.clamp, this.reset, this.speed, this.fade, this.tick);

        this.action.flex().relative(this.area).x(1F, -10).y(22).w(110).hTo(fields.area, 5).anchorX(1F);
        this.action.createContextMenu(null);

        this.fields.add(fields, this.action);
        this.fields.setVisible(false);

        this.add(this.configs, this.fields);
    }

    private void selectAction(String name)
    {
        name = this.morph.actions.toKey(name);

        ActionConfig config = this.morph.actions.actions.get(name);

        if (config == null)
        {
            config = this.morph.actions.actions.get(name);
            config = config == null ? new ActionConfig(name) : config.clone();

            this.morph.actions.actions.put(name, config);
        }

        this.config = config;
        this.fields.setVisible(true);
        this.fillFields(config);
    }

    @Override
    public void fillData(ChameleonMorph morph)
    {
        super.fillData(morph);

        this.action.list.clear();

        for (Animation animation : morph.getModel().animations.getAll())
        {
            this.action.list.add(animation.id);
        }

        this.action.list.sort();

        this.action.list.setCurrent("");
        this.fields.setVisible(false);
        this.configs.setCurrent("");
    }

    private void fillFields(ActionConfig config)
    {
        this.action.list.setCurrentScroll(config.name);
        this.clamp.toggled(config.clamp);
        this.reset.toggled(config.reset);
        this.speed.setValue(config.speed);
        this.fade.setValue((int) config.fade);
        this.tick.setValue(config.tick);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.configs.area.draw(0x88000000);
        this.font.drawStringWithShadow(this.actionsTitle.get(), this.configs.area.x, this.configs.area.y - 12, 0xffffff);

        if (this.fields.isVisible())
        {
            this.font.drawStringWithShadow(this.actionTitle.get(), this.action.area.x, this.action.area.y - 12, 0xffffff);
            this.action.area.draw(0x88000000);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №40 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\GuiChameleonMainPanel.java
--------------------
package mchorse.chameleon.metamorph.editor;

import mchorse.chameleon.lib.ChameleonModel;
import mchorse.chameleon.metamorph.ChameleonMorph;
import mchorse.chameleon.metamorph.pose.AnimatedPose;
import mchorse.chameleon.metamorph.pose.AnimatedPoseTransform;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.resources.RLUtils;
import mchorse.metamorph.client.gui.editor.GuiAnimation;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;

import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

/**
 * Custom model morph panel which allows editing custom textures for materials of the custom model morph
 */
public class GuiChameleonMainPanel extends GuiMorphPanel<ChameleonMorph, GuiChameleonMorph> implements IBonePicker
{
    /* Materials */
    public GuiButtonElement skin;
    public GuiTexturePicker picker;

    public GuiButtonElement createPose;
    public GuiStringListElement bones;
    public GuiToggleElement absoluteBrightness;
    public GuiTrackpadElement glow;
    public GuiColorElement color;
    public GuiToggleElement fixed;
    public GuiToggleElement animated;
    public GuiPoseTransformations transforms;
    public GuiAnimation animation;
    public GuiToggleElement player;

    public GuiTrackpadElement scale;
    public GuiTrackpadElement scaleGui;

    private IKey createLabel = IKey.lang("chameleon.gui.editor.create_pose");
    private IKey resetLabel = IKey.lang("chameleon.gui.editor.reset_pose");

    private AnimatedPoseTransform transform;

    public static GuiContextMenu createCopyPasteMenu(Runnable copy, Consumer<AnimatedPose> paste)
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        AnimatedPose pose = null;

        try
        {
            NBTTagCompound tag = JsonToNBT.getTagFromJson(GuiScreen.getClipboardString());
            AnimatedPose loaded = new AnimatedPose();

            loaded.fromNBT(tag);

            pose = loaded;
        }
        catch (Exception e)
        {
        }

        menu.action(Icons.COPY, IKey.lang("chameleon.gui.editor.context.copy"), copy);

        if (pose != null)
        {
            final AnimatedPose innerPose = pose;

            menu.action(Icons.PASTE, IKey.lang("chameleon.gui.editor.context.paste"), () -> paste.accept(innerPose));
        }

        return menu;
    }

    public GuiChameleonMainPanel(Minecraft mc, GuiChameleonMorph editor)
    {
        super(mc, editor);

        /* Materials view */
        this.skin = new GuiButtonElement(mc, IKey.lang("chameleon.gui.editor.pick_skin"), (b) ->
        {
            this.picker.refresh();
            this.picker.fill(this.morph.skin);
            this.add(this.picker);
            this.picker.resize();
        });
        this.picker = new GuiTexturePicker(mc, (rl) -> this.morph.skin = RLUtils.clone(rl));

        this.createPose = new GuiButtonElement(mc, this.createLabel, this::createResetPose);
        this.bones = new GuiStringListElement(mc, this::pickBone);
        this.bones.background().context(() -> createCopyPasteMenu(this::copyCurrentPose, this::pastePose));
        this.absoluteBrightness = new GuiToggleElement(mc, IKey.lang("chameleon.gui.editor.absolute_brightness"), this::toggleAbsoluteBrightness);
        this.glow = new GuiTrackpadElement(mc, this::setGlow).limit(0, 1).values(0.01, 0.1, 0.001);
        this.glow.tooltip(IKey.lang("chameleon.gui.editor.glow"));
        this.color = new GuiColorElement(mc, this::setColor).direction(Direction.RIGHT);
        this.color.tooltip(IKey.lang("chameleon.gui.editor.color"));
        this.color.picker.editAlpha();
        this.fixed = new GuiToggleElement(mc, IKey.lang("chameleon.gui.editor.fixed"), this::toggleFixed);
        this.animated = new GuiToggleElement(mc, IKey.lang("chameleon.gui.editor.animated"), this::toggleAnimated);
        this.transforms = new GuiPoseTransformations(mc);
        this.animation = new GuiAnimation(mc, false);
        this.player = new GuiToggleElement(mc, IKey.lang("chameleon.gui.editor.player"), this::togglePlayer);

        this.scale = new GuiTrackpadElement(mc, (value) -> this.morph.scale = value.floatValue());
        this.scale.tooltip(IKey.lang("chameleon.gui.editor.scale"));
        this.scaleGui = new GuiTrackpadElement(mc, (value) -> this.morph.scaleGui = value.floatValue());
        this.scaleGui.tooltip(IKey.lang("chameleon.gui.editor.scale_gui"));

        this.skin.flex().relative(this).set(10, 10, 110, 20);
        this.picker.flex().relative(this).wh(1F, 1F);

        this.createPose.flex().relative(this.skin).y(1F, 5).w(1F).h(20);
        this.bones.flex().relative(this.createPose).y(1F, 5).w(1F).hTo(this.absoluteBrightness.flex(), -10);
        this.animated.flex().relative(this).x(10).y(1F, -10).w(110).anchorY(1);
        this.fixed.flex().relative(this.animated).y(-1F, -5).w(1F);
        this.color.flex().relative(this.fixed).y(-1F, -10).w(1F);
        this.glow.flex().relative(this.color).y(-1F, -10).w(1F);
        this.absoluteBrightness.flex().relative(this.glow).y(-1F, -10).w(1F);
        this.transforms.flex().relative(this).set(0, 0, 256, 70).x(0.5F, -128).y(1, -80);
        this.animation.flex().relative(this).x(1F, -130).w(130);

        this.player.flex().relative(this.animation.pickInterpolation).x(0F).y(1F, 5).w(1F);
        this.player.tooltip(IKey.lang("chameleon.gui.editor.player_tooltip"));
        this.animation.addBefore(this.animation.interpolations, this.player);

        GuiSimpleContextMenu abMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        GuiSimpleContextMenu glowMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        GuiSimpleContextMenu colorMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());
        GuiSimpleContextMenu fixateMenu = new GuiSimpleContextMenu(Minecraft.getMinecraft());

        abMenu.action(IKey.lang("chameleon.gui.editor.context.children"), this.applyToChildren((p, c) -> c.absoluteBrightness = p.absoluteBrightness));
        glowMenu.action(IKey.lang("chameleon.gui.editor.context.children"), this.applyToChildren((p, c) -> c.glow = p.glow));
        colorMenu.action(IKey.lang("chameleon.gui.editor.context.children"), this.applyToChildren((p, c) -> c.color.copy(p.color)));
        fixateMenu.action(IKey.lang("chameleon.gui.editor.context.children"), this.applyToChildren((p, c) -> c.fixed = p.fixed));

        this.absoluteBrightness.context(() -> abMenu);
        this.glow.context(() -> glowMenu);
        this.color.context(() -> colorMenu);
        this.fixed.context(() -> fixateMenu);

        GuiElement lowerBottom = new GuiElement(mc);

        lowerBottom.flex().relative(this).xy(1F, 1F).w(130).anchor(1F, 1F).column(5).vertical().stretch().padding(10);
        lowerBottom.add(this.scale, this.scaleGui);

        this.add(this.skin, this.createPose, this.animated, this.fixed, this.color, this.glow, this.absoluteBrightness, this.bones, this.transforms, this.animation, lowerBottom);
    }

    private void copyCurrentPose()
    {
        GuiScreen.setClipboardString(this.morph.pose.toNBT().toString());
    }

    private void pastePose(AnimatedPose pose)
    {
        this.morph.pose.copy(pose);
        this.transforms.set(this.transforms.trans);
    }

    private Runnable applyToChildren(BiConsumer<AnimatedPoseTransform, AnimatedPoseTransform> apply)
    {
        return () ->
        {
            String bone = this.bones.getCurrentFirst();
            AnimatedPoseTransform anim = this.morph.pose.bones.get(bone);
            List<String> children = this.morph.getModel().getChildren(bone);

            for (String child : children)
            {
                AnimatedPoseTransform childAnim = this.morph.pose.bones.get(child);

                apply.accept(anim, childAnim);
            }
        };
    }

    private void createResetPose(GuiButtonElement button)
    {
        if (this.morph.pose == null)
        {
            AnimatedPose pose = new AnimatedPose();
            List<String> bones = this.morph.getModel().getBoneNames();

            for (String bone : bones)
            {
                pose.bones.put(bone, new AnimatedPoseTransform(bone));
            }

            this.morph.pose = pose;
        }
        else
        {
            this.morph.pose = null;
            this.editor.chameleonModelRenderer.boneName = "";
        }

        this.setPoseEditorVisible();
    }

    private void pickBone(List<String> bone)
    {
        this.pickBone(bone.get(0));
    }

    @Override
    public void pickBone(String bone)
    {
        if (this.morph.pose == null)
        {
            return;
        }

        this.transform = this.morph.pose.bones.get(bone);

        if (this.transform == null)
        {
            this.transform = new AnimatedPoseTransform(bone);
            this.morph.pose.bones.put(bone, this.transform);
        }

        this.bones.setCurrentScroll(bone);
        this.animated.toggled(this.morph.pose.animated == AnimatedPoseTransform.ANIMATED);
        this.fixed.toggled(this.transform.fixed == AnimatedPoseTransform.FIXED);
        this.color.picker.setColor(this.transform.color.getRGBAColor());
        this.absoluteBrightness.toggled(this.transform.absoluteBrightness);
        this.glow.setValue(this.transform.glow);
        this.transforms.set(this.transform);
        this.editor.chameleonModelRenderer.boneName = bone;
    }

    private void toggleAbsoluteBrightness(GuiToggleElement toggle)
    {
        this.transform.absoluteBrightness = toggle.isToggled();
    }

    private void setGlow(Double value)
    {
        this.transform.glow = value.floatValue();
    }

    private void setColor(int color)
    {
        this.transform.color.set(color);
    }

    private void toggleFixed(GuiToggleElement toggle)
    {
        this.transform.fixed = toggle.isToggled() ? AnimatedPoseTransform.FIXED : AnimatedPoseTransform.ANIMATED;
    }

    private void toggleAnimated(GuiToggleElement toggle)
    {
        this.morph.pose.animated = toggle.isToggled() ? AnimatedPoseTransform.ANIMATED : AnimatedPoseTransform.FIXED;
    }

    private void togglePlayer(GuiToggleElement toggle)
    {
        this.morph.isActionPlayer = toggle.isToggled();
    }

    @Override
    public void fillData(ChameleonMorph morph)
    {
        super.fillData(morph);

        this.picker.removeFromParent();
        this.setPoseEditorVisible();

        this.animation.fill(morph.animation);
        this.scale.setValue(morph.scale);
        this.scaleGui.setValue(morph.scaleGui);
        this.player.toggled(morph.isActionPlayer);
    }

    @Override
    public void finishEditing()
    {
        this.picker.close();
    }

    private void setPoseEditorVisible()
    {
        ChameleonModel model = this.morph.getModel();
        AnimatedPose pose = this.morph.pose;

        this.createPose.setVisible(model != null && !model.getBoneNames().isEmpty());
        this.createPose.label = pose == null ? this.createLabel : this.resetLabel;
        this.bones.setVisible(model != null && pose != null);
        this.absoluteBrightness.setVisible(model != null && pose != null);
        this.glow.setVisible(model != null && pose != null);
        this.color.setVisible(model != null && pose != null);
        this.fixed.setVisible(model != null && pose != null);
        this.animated.setVisible(model != null && pose != null);
        this.transforms.setVisible(model != null && pose != null);

        if (model != null)
        {
            this.bones.clear();
            this.bones.add(model.getBoneNames());
            this.bones.sort();

            if (this.morph.pose != null)
            {
                this.pickBone(model.getBoneNames().get(0));
            }
        }
    }

    public static class GuiPoseTransformations extends GuiTransformations
    {
        public AnimatedPoseTransform trans;

        public GuiPoseTransformations(Minecraft mc)
        {
            super(mc);
        }

        @Override
        protected void localTranslate(double x, double y, double z)
        {
            this.trans.addTranslation(x, y, z, GuiStaticTransformOrientation.getOrientation());

            this.fillT(this.trans.x, this.trans.y, this.trans.z);
        }

        public void set(AnimatedPoseTransform trans)
        {
            this.trans = trans;

            if (trans != null)
            {
                this.fillT(-trans.x, trans.y, trans.z);
                this.fillS(trans.scaleX, trans.scaleY, trans.scaleZ);
                this.fillR(trans.rotateX / (float) Math.PI * 180, trans.rotateY / (float) Math.PI * 180, trans.rotateZ / (float) Math.PI * 180);
            }
        }

        @Override
        public void setT(double x, double y, double z)
        {
            this.trans.x = (float) -x;
            this.trans.y = (float) y;
            this.trans.z = (float) z;
        }

        @Override
        public void setS(double x, double y, double z)
        {
            this.trans.scaleX = (float) x;
            this.trans.scaleY = (float) y;
            this.trans.scaleZ = (float) z;
        }

        @Override
        public void setR(double x, double y, double z)
        {
            /* That was a bad idea... */
            this.trans.rotateX = (float) (x / 180F * (float) Math.PI);
            this.trans.rotateY = (float) (y / 180F * (float) Math.PI);
            this.trans.rotateZ = (float) (z / 180F * (float) Math.PI);
        }
    }
}


==================================================

--- Файл №41 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\GuiChameleonModelRenderer.java
--------------------
package mchorse.chameleon.metamorph.editor;

import mchorse.chameleon.lib.ChameleonModel;
import mchorse.chameleon.lib.render.ChameleonRenderer;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.chameleon.metamorph.ChameleonMorph;
import mchorse.chameleon.metamorph.editor.render.ChameleonHighlightRenderer;
import mchorse.chameleon.metamorph.editor.render.ChameleonStencilRenderer;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.metamorph.client.gui.creative.GuiMorphRenderer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import java.util.List;

@SideOnly(Side.CLIENT)
public class GuiChameleonModelRenderer extends GuiMorphRenderer
{
    private static final MatrixStack MATRIX_STACK = new MatrixStack();
    private static final ChameleonStencilRenderer STENCIL_RENDERER = new ChameleonStencilRenderer();
    private static final ChameleonHighlightRenderer HIGHLIGHT_RENDERER = new ChameleonHighlightRenderer();

    public String boneName = "";

    public GuiChameleonModelRenderer(Minecraft mc)
    {
        super(mc);
    }

    @Override
    protected void drawUserModel(GuiContext context)
    {
        super.drawUserModel(context);
        this.drawHighlight(context);
        this.tryPicking(context);
    }

    private void drawHighlight(GuiContext context)
    {
        if (!(this.morph instanceof ChameleonMorph))
        {
            return;
        }

        ChameleonModel model = ((ChameleonMorph) this.morph).getModel();

        if (model == null || this.boneName.isEmpty())
        {
            return;
        }

        float scale = ((ChameleonMorph) this.morph).scale;

        GlStateManager.enableBlend();
        GlStateManager.disableLighting();
        GlStateManager.disableTexture2D();
        GlStateManager.disableDepth();
        GlStateManager.pushMatrix();
        GlStateManager.color(0, 0.5F, 1, 0.33F);
        GlStateManager.rotate(180 - (this.customEntity ? this.entityYawBody : 0), 0, 1, 0);
        GlStateManager.scale(scale, scale, scale);

        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        HIGHLIGHT_RENDERER.setBoneName(this.boneName);

        ChameleonRenderer.processRenderModel(HIGHLIGHT_RENDERER, Tessellator.getInstance().getBuffer(), MATRIX_STACK, model.model);

        GlStateManager.popMatrix();
        GlStateManager.enableTexture2D();
        GlStateManager.enableDepth();
        GlStateManager.enableLighting();
        GlStateManager.disableBlend();
    }

    @Override
    protected void drawForStencil(GuiContext context)
    {
        if (!(this.morph instanceof ChameleonMorph))
        {
            return;
        }

        ChameleonModel model = ((ChameleonMorph) this.morph).getModel();

        if (model == null)
        {
            return;
        }

        float scale = ((ChameleonMorph) this.morph).scale;

        if (((ChameleonMorph) this.morph).skin != null)
        {
            Minecraft.getMinecraft().renderEngine.bindTexture(((ChameleonMorph) this.morph).skin);
        }

        GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);

        GlStateManager.enableDepth();
        GlStateManager.disableCull();
        GlStateManager.pushMatrix();
        GlStateManager.color(1, 1, 1, 1);
        GlStateManager.rotate(180 - (this.customEntity ? this.entityYawBody : 0), 0, 1, 0);
        GlStateManager.scale(scale, scale, scale);

        STENCIL_RENDERER.setBones(model.getBoneNames());

        ChameleonRenderer.processRenderModel(STENCIL_RENDERER, Tessellator.getInstance().getBuffer(), MATRIX_STACK, model.model);

        GlStateManager.popMatrix();
        GlStateManager.enableCull();
    }

    @Override
    protected String getStencilValue(int value)
    {
        if (value == 0)
        {
            return null;
        }

        value -= 1;

        if (this.morph instanceof ChameleonMorph)
        {
            ChameleonMorph morph = (ChameleonMorph) this.morph;
            ChameleonModel model = morph.getModel();

            if (model != null)
            {
                List<String> bones = model.getBoneNames();

                if (value >= 0 && value < bones.size())
                {
                    return bones.get(value);
                }
            }
        }

        return super.getStencilValue(value);
    }
}

==================================================

--- Файл №42 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\GuiChameleonMorph.java
--------------------
package mchorse.chameleon.metamorph.editor;

import mchorse.chameleon.ClientProxy;
import mchorse.chameleon.lib.ChameleonModel;
import mchorse.chameleon.metamorph.ChameleonMorph;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiModelRenderer;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.metamorph.api.morphs.AbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import mchorse.metamorph.client.gui.editor.GuiMorphPanel;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@SideOnly(Side.CLIENT)
public class GuiChameleonMorph extends GuiAbstractMorph<ChameleonMorph>
{
    public GuiActionsPanel actionsPanel;
    public GuiCustomBodyPartEditor bodyPart;
    public GuiChameleonMainPanel mainPanel;
    public GuiChameleonModelRenderer chameleonModelRenderer;

    public GuiChameleonMorph(Minecraft mc)
    {
        super(mc);

        this.mainPanel = new GuiChameleonMainPanel(mc, this);
        this.bodyPart = new GuiCustomBodyPartEditor(mc, this);
        this.actionsPanel = new GuiActionsPanel(mc, this);
        this.defaultPanel = this.mainPanel;

        this.registerPanel(this.actionsPanel, IKey.lang("chameleon.gui.editor.actions.actions"), Icons.MORE);
        this.registerPanel(this.bodyPart, IKey.lang("metamorph.gui.body_parts.parts"), Icons.LIMB);
        this.registerPanel(this.mainPanel, IKey.lang("chameleon.gui.editor.main"), Icons.GEAR);

        this.keys().register(IKey.lang("chameleon.gui.editor.pick_skin"), Keyboard.KEY_P, () ->
        {
            this.setPanel(this.mainPanel);

            this.mainPanel.skin.clickItself(GuiBase.getCurrent());
        }).held(Keyboard.KEY_LSHIFT);
    }

    @Override
    protected GuiModelRenderer createMorphRenderer(Minecraft mc)
    {
        this.chameleonModelRenderer = new GuiChameleonModelRenderer(mc);
        this.chameleonModelRenderer.picker(this::pickLimb);

        return this.chameleonModelRenderer;
    }

    private void pickLimb(String limb)
    {
        if (this.view.delegate instanceof IBonePicker)
        {
            ((IBonePicker) this.view.delegate).pickBone(limb);
        }
    }

    @Override
    public boolean canEdit(AbstractMorph morph)
    {
        return morph instanceof ChameleonMorph;
    }

    @Override
    public void startEdit(ChameleonMorph morph)
    {
        super.startEdit(morph);

        ChameleonModel model = morph.getModel();

        morph.parts.reinitBodyParts();

        if (model == null)
        {
            this.bodyPart.setLimbs(Collections.emptyList());
        }
        else
        {
            this.bodyPart.setLimbs(model.getBoneNames());
        }
    }

    @Override
    public void setPanel(GuiMorphPanel panel)
    {
        this.chameleonModelRenderer.boneName = "";

        super.setPanel(panel);
    }

    @Override
    public List<Label<NBTTagCompound>> getPresets(ChameleonMorph morph)
    {
        List<Label<NBTTagCompound>> list = new ArrayList<Label<NBTTagCompound>>();
        String key = morph.getKey();

        this.addSkins(morph, list, "Skin", ClientProxy.tree.getByPath(key + "/skins", null));

        return list;
    }

    public void addSkins(AbstractMorph morph, List<Label<NBTTagCompound>> list, String name, FolderEntry entry)
    {
        if (entry == null)
        {
            return;
        }

        for (AbstractEntry childEntry : entry.getEntries())
        {
            if (childEntry instanceof FileEntry)
            {
                ResourceLocation location = ((FileEntry) childEntry).resource;
                String label = location.getResourcePath();
                int index = label.indexOf("/skins/");

                if (index != -1)
                {
                    label = label.substring(index + 7);
                }

                this.addPreset(morph, list, name, label, location);
            }
            else if (childEntry instanceof FolderEntry)
            {
                FolderEntry childFolder = (FolderEntry) childEntry;

                if (!childFolder.isTop())
                {
                    this.addSkins(morph, list, name, childFolder);
                }
            }
        }
    }

    public void addPreset(AbstractMorph morph, List<Label<NBTTagCompound>> list, String name, String label, ResourceLocation skin)
    {
        try
        {
            NBTTagCompound tag = morph.toNBT();

            tag.setString(name, skin.toString());
            list.add(new Label<>(IKey.str(label), tag));
        }
        catch (Exception e)
        {}
    }

}


==================================================

--- Файл №43 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\GuiCustomBodyPartEditor.java
--------------------
package mchorse.chameleon.metamorph.editor;

import mchorse.metamorph.bodypart.BodyPart;
import mchorse.metamorph.bodypart.GuiBodyPartEditor;
import mchorse.metamorph.client.gui.editor.GuiAbstractMorph;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class GuiCustomBodyPartEditor extends GuiBodyPartEditor implements IBonePicker
{
    public GuiCustomBodyPartEditor(Minecraft mc, GuiAbstractMorph editor)
    {
        super(mc, editor);
    }

    @Override
    protected void setPart(BodyPart part)
    {
        super.setPart(part);

        if (part != null)
        {
            GuiChameleonMorph parent = (GuiChameleonMorph) this.editor;

            parent.chameleonModelRenderer.boneName = part.limb;
        }
    }

    @Override
    protected void setupNewBodyPart(BodyPart part)
    {
        super.setupNewBodyPart(part);

        part.rotate.x = 0;
        part.rotate.y = 180;
    }

    @Override
    protected void pickLimb(String limbName)
    {
        GuiChameleonMorph parent = (GuiChameleonMorph) this.editor;

        super.pickLimb(limbName);
        parent.chameleonModelRenderer.boneName = limbName;
    }

    @Override
    public void pickBone(String limb)
    {
        try
        {
            this.pickLimb(limb);
            this.limbs.setCurrent(limb);
        }
        catch (Exception e)
        {}
    }
}


==================================================

--- Файл №44 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\IBonePicker.java
--------------------
package mchorse.chameleon.metamorph.editor;

public interface IBonePicker
{
    public void pickBone(String bone);
}

==================================================

--- Файл №45 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\render\ChameleonHighlightRenderer.java
--------------------
package mchorse.chameleon.metamorph.editor.render;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelCube;
import mchorse.chameleon.lib.data.model.ModelQuad;
import mchorse.chameleon.lib.data.model.ModelVertex;
import mchorse.chameleon.lib.render.ChameleonPostRenderer;
import mchorse.chameleon.lib.render.IChameleonRenderProcessor;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.mclib.client.Draw;
import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.RenderingUtils;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector4f;
import java.nio.FloatBuffer;

/**
 * Highlight renderer
 *
 * This bad boy is responsible for rendering given model's bone
 * as a blue box highlight (in addition with axes identifiers)
 */
@SideOnly(Side.CLIENT)
public class ChameleonHighlightRenderer implements IChameleonRenderProcessor
{
    private String boneName;
    private Vector4f vertex = new Vector4f();

    public void setBoneName(String boneName)
    {
        this.boneName = boneName;
    }

    @Override
    public boolean renderBone(BufferBuilder builder, MatrixStack stack, ModelBone bone)
    {
        if (bone.id.equals(this.boneName))
        {
            builder.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION);

            for (ModelCube cube : bone.cubes)
            {
                this.renderCubeForHighlight(builder, stack, cube);
            }

            Tessellator.getInstance().draw();

            GlStateManager.pushMatrix();
            ChameleonPostRenderer.multiplyMatrix(stack, bone);

            if (GuiTransformations.GuiStaticTransformOrientation.getOrientation() == GuiTransformations.TransformOrientation.GLOBAL)
            {
                Vector3d rotation = new Vector3d(bone.current.rotation);
                rotation.x = Math.toRadians(rotation.x);
                rotation.y = Math.toRadians(rotation.y);
                rotation.z = Math.toRadians(rotation.z);

                RenderingUtils.glRevertRotationScale(rotation, new Vector3d(bone.current.scale), MatrixUtils.RotationOrder.XYZ);
            }

            Draw.axis(0.25F * 1.5F);

            GlStateManager.popMatrix();

            return true;
        }

        return false;
    }

    private void renderCubeForHighlight(BufferBuilder builder, MatrixStack stack, ModelCube cube)
    {
        stack.push();
        stack.moveToCubePivot(cube);
        stack.rotateCube(cube);
        stack.moveBackFromCubePivot(cube);

        for (ModelQuad quad : cube.quads)
        {
            for (ModelVertex vertex : quad.vertices)
            {
                this.vertex.set(vertex.position);
                this.vertex.w = 1;
                stack.getModelMatrix().transform(this.vertex);

                builder.pos(this.vertex.getX(), this.vertex.getY(), this.vertex.getZ()).endVertex();
            }
        }

        stack.pop();
    }
}

==================================================

--- Файл №46 ---
Путь: main\java\mchorse\chameleon\metamorph\editor\render\ChameleonStencilRenderer.java
--------------------
package mchorse.chameleon.metamorph.editor.render;

import mchorse.chameleon.lib.data.model.ModelBone;
import mchorse.chameleon.lib.data.model.ModelCube;
import mchorse.chameleon.lib.data.model.ModelQuad;
import mchorse.chameleon.lib.data.model.ModelVertex;
import mchorse.chameleon.lib.render.IChameleonRenderProcessor;
import mchorse.chameleon.lib.utils.MatrixStack;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;

import javax.vecmath.Vector4f;
import java.util.List;

/**
 * Stencil render processor
 *
 * This bad boy is responsible for rendering given GeoModel for
 * stencil limb picking
 */
@SideOnly(Side.CLIENT)
public class ChameleonStencilRenderer implements IChameleonRenderProcessor
{
    private List<String> bones;
    private Vector4f vertex = new Vector4f();
    private float r;
    private float g;
    private float b;
    private float a;

    public void setBones(List<String> bones)
    {
        this.bones = bones;
    }

    @Override
    public boolean renderBone(BufferBuilder builder, MatrixStack stack, ModelBone bone)
    {
        this.r = bone.color.r;
        this.g = bone.color.g;
        this.b = bone.color.b;
        this.a = bone.color.a;

        GL11.glStencilFunc(GL11.GL_ALWAYS, this.bones.indexOf(bone.id) + 1, -1);

        builder.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX_COLOR);

        for (ModelCube cube : bone.cubes)
        {
            renderCube(builder, stack, cube);
        }

        Tessellator.getInstance().draw();

        return false;
    }

    private void renderCube(BufferBuilder builder, MatrixStack stack, ModelCube cube)
    {
        stack.push();
        stack.moveToCubePivot(cube);
        stack.rotateCube(cube);
        stack.moveBackFromCubePivot(cube);

        for (ModelQuad quad : cube.quads)
        {
            for (ModelVertex vertex : quad.vertices)
            {
                this.vertex.set(vertex.position);
                this.vertex.w = 1;
                stack.getModelMatrix().transform(this.vertex);

                builder.pos(this.vertex.getX(), this.vertex.getY(), this.vertex.getZ())
                    .tex(vertex.uv.x, vertex.uv.y)
                    .color(this.r, this.g, this.b, this.a)
                    .endVertex();
            }
        }

        stack.pop();
    }
}

==================================================

--- Файл №47 ---
Путь: main\java\mchorse\chameleon\metamorph\pose\AnimatedPose.java
--------------------
package mchorse.chameleon.metamorph.pose;

import net.minecraft.nbt.NBTTagCompound;

import java.util.HashMap;
import java.util.Map;

public class AnimatedPose
{
    public final Map<String, AnimatedPoseTransform> bones = new HashMap<String, AnimatedPoseTransform>();
    public float animated = AnimatedPoseTransform.ANIMATED;

    public void copy(AnimatedPose pose)
    {
        for (Map.Entry<String, AnimatedPoseTransform> entry : this.bones.entrySet())
        {
            AnimatedPoseTransform transform = pose.bones.get(entry.getKey());

            if (transform != null)
            {
                entry.getValue().copy(transform);
            }
        }
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof AnimatedPose)
        {
            AnimatedPose pose = (AnimatedPose) obj;

            return this.bones.equals(pose.bones)
                && this.animated == pose.animated;
        }

        return super.equals(obj);
    }

    public AnimatedPose clone()
    {
        AnimatedPose pose = new AnimatedPose();

        for (Map.Entry<String, AnimatedPoseTransform> entry : this.bones.entrySet())
        {
            pose.bones.put(entry.getKey(), entry.getValue().clone());
        }

        pose.animated = this.animated;

        return pose;
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Pose"))
        {
            NBTTagCompound pose = tag.getCompoundTag("Pose");

            for (String key : pose.getKeySet())
            {
                AnimatedPoseTransform config = new AnimatedPoseTransform(key);

                config.fromNBT(pose.getCompoundTag(key));
                this.bones.put(key, config);
            }
        }

        if (tag.hasKey("Animated"))
        {
            this.animated = tag.getBoolean("Animated") ? AnimatedPoseTransform.ANIMATED : AnimatedPoseTransform.FIXED;
        }
    }

    public NBTTagCompound toNBT()
    {
        NBTTagCompound tag = new NBTTagCompound();
        NBTTagCompound pose = new NBTTagCompound();

        for (Map.Entry<String, AnimatedPoseTransform> entry : this.bones.entrySet())
        {
            pose.setTag(entry.getKey(), entry.getValue().toNBT(null));
        }

        tag.setTag("Pose", pose);

        if (this.animated != AnimatedPoseTransform.ANIMATED)
        {
            tag.setBoolean("Animated", false);
        }

        return tag;
    }
}

==================================================

--- Файл №48 ---
Путь: main\java\mchorse\chameleon\metamorph\pose\AnimatedPoseTransform.java
--------------------
package mchorse.chameleon.metamorph.pose;

import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.util.Constants.NBT;

public class AnimatedPoseTransform extends AnimatedTransform
{
    public static final int FIXED = 0;
    public static final int ANIMATED = 1;

    public float fixed = ANIMATED;

    public boolean absoluteBrightness = false;
    public float glow = 0.0f;
    public Color color = new Color(1f, 1f, 1f, 1f);

    public AnimatedPoseTransform(String name)
    {
        super(name);
    }

    public AnimatedPoseTransform clone()
    {
        AnimatedPoseTransform item = new AnimatedPoseTransform(this.boneName);

        item.copy(this);

        return item;
    }

    public void copy(AnimatedPoseTransform transform)
    {
        this.x = transform.x;
        this.y = transform.y;
        this.z = transform.z;
        this.scaleX = transform.scaleX;
        this.scaleY = transform.scaleY;
        this.scaleZ = transform.scaleZ;
        this.rotateX = transform.rotateX;
        this.rotateY = transform.rotateY;
        this.rotateZ = transform.rotateZ;
        this.fixed = transform.fixed;
        this.absoluteBrightness = transform.absoluteBrightness;
        this.glow = transform.glow;
        this.color.copy(transform.color);
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof AnimatedPoseTransform)
        {
            result = result && this.fixed == ((AnimatedPoseTransform) obj).fixed;
            result = result && this.absoluteBrightness == ((AnimatedPoseTransform) obj).absoluteBrightness;
            result = result && Math.abs(this.glow - ((AnimatedPoseTransform) obj).glow) < 0.0001;
            result = result && this.color.equals(((AnimatedPoseTransform) obj).color);
        }

        return result;
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        super.fromNBT(tag);

        if (tag.hasKey("F", NBT.TAG_BYTE)) this.fixed = tag.getBoolean("F") ? ANIMATED : FIXED;
        if (tag.hasKey("AB", NBT.TAG_BYTE)) this.absoluteBrightness = tag.getBoolean("AB");
        if (tag.hasKey("G", NBT.TAG_FLOAT)) this.glow = tag.getFloat("G");
        if (tag.hasKey("C", NBT.TAG_INT)) this.color.set(tag.getInteger("C"));
    }

    @Override
    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        tag = super.toNBT(tag);

        if (this.fixed != ANIMATED) tag.setBoolean("F", false);
        if (this.absoluteBrightness) tag.setBoolean("AB", this.absoluteBrightness);
        if (this.glow > 0.0001) tag.setFloat("G", this.glow);
        if (this.color.getRGBAColor() != 0xFFFFFFFF) tag.setInteger("C", this.color.getRGBAColor());

        return tag;
    }

    @Override
    public void interpolate(AnimatedTransform a, AnimatedTransform b, float x, Interpolation interp)
    {
        super.interpolate(a, b, x, interp);

        float glow = 0.0f;
        float cr, cg, cb, ca;
        cr = cg = cb = ca = 1.0f;

        if (a instanceof AnimatedPoseTransform)
        {
            AnimatedPoseTransform l = (AnimatedPoseTransform) a;
            glow = l.glow;
            cr = l.color.r;
            cg = l.color.g;
            cb = l.color.b;
            ca = l.color.a;
        }

        if (b instanceof AnimatedPoseTransform)
        {
            AnimatedPoseTransform l = (AnimatedPoseTransform) b;
            glow = interp.interpolate(glow, l.glow, x);
            cr = interp.interpolate(cr, l.color.r, x);
            cg = interp.interpolate(cg, l.color.g, x);
            cb = interp.interpolate(cb, l.color.b, x);
            ca = interp.interpolate(ca, l.color.a, x);

            this.absoluteBrightness = l.absoluteBrightness;
        }
        else
        {
            glow = interp.interpolate(glow, 0.0f, x);
            cr = interp.interpolate(cr, 1.0f, x);
            cg = interp.interpolate(cg, 1.0f, x);
            cb = interp.interpolate(cb, 1.0f, x);
            ca = interp.interpolate(ca, 1.0f, x);

            this.absoluteBrightness = false;
        }

        this.glow = glow;
        this.color.set(cr, cg, cb, ca);
    }
}

==================================================

--- Файл №49 ---
Путь: main\java\mchorse\chameleon\metamorph\pose\AnimatedTransform.java
--------------------
package mchorse.chameleon.metamorph.pose;

import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;
import mchorse.mclib.utils.ITransformationObject;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.common.util.Constants.NBT;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector4f;

/**
 * Configuration class for general transformation
 */
public class AnimatedTransform implements ITransformationObject
{
    public String boneName;

    /* Translate */
    public float x;
    public float y;
    public float z;

    /* Scale */
    public float scaleX = 1;
    public float scaleY = 1;
    public float scaleZ = 1;

    /* Rotate */
    public float rotateX;
    public float rotateY;
    public float rotateZ;

    public AnimatedTransform(String name)
    {
        this.boneName = name;
    }

    public void interpolate(AnimatedTransform a, AnimatedTransform b, float x, Interpolation interp)
    {
        this.x = interp.interpolate(a.x, b.x, x);
        this.y = interp.interpolate(a.y, b.y, x);
        this.z = interp.interpolate(a.z, b.z, x);
        this.scaleX = interp.interpolate(a.scaleX, b.scaleX, x);
        this.scaleY = interp.interpolate(a.scaleY, b.scaleY, x);
        this.scaleZ = interp.interpolate(a.scaleZ, b.scaleZ, x);
        this.rotateX = interp.interpolate(a.rotateX, b.rotateX, x);
        this.rotateY = interp.interpolate(a.rotateY, b.rotateY, x);
        this.rotateZ = interp.interpolate(a.rotateZ, b.rotateZ, x);
    }

    @Override
    public void addTranslation(double x, double y, double z, GuiTransformations.TransformOrientation transformOrientation)
    {
        Vector4f trans = new Vector4f((float) x,(float) y,(float) z, 1);

        if (transformOrientation == GuiTransformations.TransformOrientation.LOCAL)
        {
            MatrixUtils.getRotationMatrix(this.rotateX, -this.rotateY, -this.rotateZ, MatrixUtils.RotationOrder.XYZ).transform(trans);
        }

        this.x += trans.x;
        this.y += trans.y;
        this.z += trans.z;
    }

    /**
     * Clone this object 
     */
    @Override
    public AnimatedTransform clone()
    {
        AnimatedTransform item = new AnimatedTransform(this.boneName);

        item.x = this.x;
        item.y = this.y;
        item.z = this.z;
        item.scaleX = this.scaleX;
        item.scaleY = this.scaleY;
        item.scaleZ = this.scaleZ;
        item.rotateX = this.rotateX;
        item.rotateY = this.rotateY;
        item.rotateZ = this.rotateZ;

        return item;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof AnimatedTransform)
        {
            AnimatedTransform config = (AnimatedTransform) obj;

            boolean result = config.x == this.x && config.y == this.y && config.z == this.z;

            result = result && config.scaleX == this.scaleX && config.scaleY == this.scaleY && config.scaleZ == this.scaleZ;
            result = result && config.rotateX == this.rotateX && config.rotateY == this.rotateY && config.rotateZ == this.rotateZ;

            return result;
        }

        return super.equals(obj);
    }

    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("X", NBT.TAG_ANY_NUMERIC))
        {
            this.x = tag.getFloat("X");
        }

        if (tag.hasKey("Y", NBT.TAG_ANY_NUMERIC))
        {
            this.y = tag.getFloat("Y");
        }

        if (tag.hasKey("Z", NBT.TAG_ANY_NUMERIC))
        {
            this.z = tag.getFloat("Z");
        }

        if (tag.hasKey("SX", NBT.TAG_ANY_NUMERIC))
        {
            this.scaleX = tag.getFloat("SX");
        }

        if (tag.hasKey("SY", NBT.TAG_ANY_NUMERIC))
        {
            this.scaleY = tag.getFloat("SY");
        }

        if (tag.hasKey("SZ", NBT.TAG_ANY_NUMERIC))
        {
            this.scaleZ = tag.getFloat("SZ");
        }

        if (tag.hasKey("RX", NBT.TAG_ANY_NUMERIC))
        {
            this.rotateX = tag.getFloat("RX");
        }

        if (tag.hasKey("RY", NBT.TAG_ANY_NUMERIC))
        {
            this.rotateY = tag.getFloat("RY");
        }

        if (tag.hasKey("RZ", NBT.TAG_ANY_NUMERIC))
        {
            this.rotateZ = tag.getFloat("RZ");
        }
    }

    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        if (tag == null)
        {
            tag = new NBTTagCompound();
        }

        if (this.x != 0) tag.setFloat("X", this.x);
        if (this.y != 0) tag.setFloat("Y", this.y);
        if (this.z != 0) tag.setFloat("Z", this.z);
        if (this.scaleX != 1) tag.setFloat("SX", this.scaleX);
        if (this.scaleY != 1) tag.setFloat("SY", this.scaleY);
        if (this.scaleZ != 1) tag.setFloat("SZ", this.scaleZ);
        if (this.rotateX != 0) tag.setFloat("RX", this.rotateX);
        if (this.rotateY != 0) tag.setFloat("RY", this.rotateY);
        if (this.rotateZ != 0) tag.setFloat("RZ", this.rotateZ);

        return tag;
    }
}

==================================================

--- Файл №50 ---
Путь: main\java\mchorse\chameleon\metamorph\pose\PoseAnimation.java
--------------------
package mchorse.chameleon.metamorph.pose;

import mchorse.chameleon.lib.ChameleonModel;
import mchorse.metamorph.api.morphs.utils.Animation;

/**
 * Animation details
 */
public class PoseAnimation extends Animation
{
    public static final AnimatedPoseTransform ZERO = new AnimatedPoseTransform("");

    public AnimatedPose last;
    public AnimatedPose pose = new AnimatedPose();

    @Override
    public void merge(Animation animation)
    {
        super.merge(animation);
        this.progress = 0;
        this.pose.bones.clear();
    }

    public AnimatedPose calculatePose(AnimatedPose pose, ChameleonModel model, float partialTicks)
    {
        float factor = this.getFactor(partialTicks);

        for (String key : model.getBoneNames())
        {
            AnimatedPoseTransform trans = this.pose.bones.get(key);
            AnimatedPoseTransform last = this.last == null ? null : this.last.bones.get(key);
            AnimatedPoseTransform current = pose == null ? null : pose.bones.get(key);

            if (trans == null)
            {
                trans = new AnimatedPoseTransform(key);
                this.pose.bones.put(key, trans);
            }

            if (last == null) last = ZERO;
            if (current == null) current = ZERO;

            trans.fixed = this.interp.interpolate(last.fixed, current.fixed, factor);
            trans.interpolate(last, current, factor, this.interp);
        }

        float lastAnimated = this.last == null ? AnimatedPoseTransform.ANIMATED : this.last.animated;
        float poseAnimated = pose == null ? AnimatedPoseTransform.ANIMATED : pose.animated;

        this.pose.animated = this.interp.interpolate(lastAnimated, poseAnimated, factor);

        return this.pose;
    }
}

==================================================

--- Файл №51 ---
Путь: main\resources\mcmod.info
--------------------
[
    {
        "modid": "chameleon_morph",
        "name": "Chameleon",
        "description": "Loads animated Blockbench models as Metamorph morphs",
        "version": "${version}",
        "mcversion": "${mcversion}",
        "url": "",
        "updateUrl": "https://raw.githubusercontent.com/mchorse/chameleon/master/version.json",
        "authorList": ["mchorse"],
        "credits": "Gecko and Eliot Lash for GeckoLib, and Jannis for Blockbench",
        "logoFile": "",
        "screenshots": [],
        "dependencies": []
    }
]


==================================================

--- Файл №52 ---
Путь: main\resources\pack.mcmeta
--------------------
{
    "pack": {
        "description": "Chameleon resources",
        "pack_format": 3,
        "_comment": "A pack_format of 3 should be used starting with Minecraft 1.11. All resources, including language files, should be lowercase (eg: en_us.lang). A pack_format of 2 will load your mod resources with LegacyV2Adapter, which requires language files to have uppercase letters (eg: en_US.lang)."
    }
}


==================================================

--- Файл №53 ---
Путь: main\resources\assets\chameleon\lang\en_us.lang
--------------------
#PARSE_ESCAPES

# Config
chameleon.config.title=Chameleon

chameleon.config.general.title=General
chameleon.config.general.tooltip=General options

# GUI
chameleon.gui.editor.pick_skin=Pick skin
chameleon.gui.editor.main=Main panel
chameleon.gui.editor.create_pose=Create pose
chameleon.gui.editor.reset_pose=Reset pose
chameleon.gui.editor.absolute_brightness=Absolute Brightness
chameleon.gui.editor.glow=Limb Glow
chameleon.gui.editor.color=Limb Color
chameleon.gui.editor.fixed=Fixate movement
chameleon.gui.editor.animated=Animated pose
chameleon.gui.editor.context.copy=Copy pose
chameleon.gui.editor.context.paste=Paste pose
chameleon.gui.editor.context.children=Apply to children

chameleon.gui.editor.scale=Global scale
chameleon.gui.editor.scale_gui=GUI scale

chameleon.gui.editor.player=Action player mode
chameleon.gui.editor.player_tooltip=It will let this morph to play the synchronizable action "Animated"

chameleon.gui.editor.actions.actions=Actions
chameleon.gui.editor.actions.action=Action

chameleon.gui.editor.actions.clamp=Clamp
chameleon.gui.editor.actions.reset=Reset
chameleon.gui.editor.actions.speed=Speed
chameleon.gui.editor.actions.fade=Fade
chameleon.gui.editor.actions.tick=Tick

chameleon.gui.config.models=Open models...
chameleon.gui.config.tutorial=Video tutorials
chameleon.gui.config.discord=Discord
chameleon.gui.config.wiki=Wiki

# Morph stuff
morph.section.chameleon=Chameleon
morph.category.chameleon=Animated models

==================================================

--- Файл №54 ---
Путь: main\resources\assets\chameleon\lang\ru_ru.lang
--------------------
#PARSE_ESCAPES

# Config
chameleon.config.title=Хамелеон

chameleon.config.general.title=Общие
chameleon.config.general.tooltip=Общие опции

# GUI
chameleon.gui.editor.pick_skin=Выбрать скин
chameleon.gui.editor.main=Главная панель
chameleon.gui.editor.create_pose=Создать позу
chameleon.gui.editor.reset_pose=Сбросить позу
chameleon.gui.editor.fixed=Фиксировать движение
chameleon.gui.editor.animated=Анимированная поза
chameleon.gui.editor.context.copy=Скопировать позу
chameleon.gui.editor.context.paste=Вставить позу

chameleon.gui.editor.scale=Глобальный масштаб
chameleon.gui.editor.scale_gui=Размер в интерфейсе

chameleon.gui.editor.actions.actions=Действия
chameleon.gui.editor.actions.action=Действие

chameleon.gui.editor.actions.clamp=Закольцовывание
chameleon.gui.editor.actions.reset=Сбросить
chameleon.gui.editor.actions.speed=Скорость
chameleon.gui.editor.actions.fade=Затухание
chameleon.gui.editor.actions.tick=Тик

chameleon.gui.config.models=Открыть модели...
chameleon.gui.config.tutorial=Видеоуроки
chameleon.gui.config.discord=Дискорд
chameleon.gui.config.wiki=Вики

# Morph stuff
morph.section.chameleon=Chameleon
morph.category.chameleon=Анимированные модели

==================================================

--- Файл №55 ---
Путь: main\resources\assets\chameleon\lang\uk_ua.lang
--------------------
#PARSE_ESCAPES

# Config
chameleon.config.title=Хамелеон

chameleon.config.general.title=Загальне
chameleon.config.general.tooltip=Загальні налаштування

# GUI
chameleon.gui.editor.pick_skin=Обрати скін
chameleon.gui.editor.main=Головна панель
chameleon.gui.editor.create_pose=Створити позу
chameleon.gui.editor.reset_pose=Скинути позу
chameleon.gui.editor.fixed=Зафіксувати рух
chameleon.gui.editor.animated=Анімована поза
chameleon.gui.editor.context.copy=Скопіювати позу
chameleon.gui.editor.context.paste=Вставити позу

chameleon.gui.editor.scale=Загальний розмір
chameleon.gui.editor.scale_gui=Розмір у інтерфейсі

chameleon.gui.editor.actions.actions=Дії
chameleon.gui.editor.actions.action=Дія

chameleon.gui.editor.actions.clamp=Зациклення
chameleon.gui.editor.actions.reset=Скинути
chameleon.gui.editor.actions.speed=Швидкість
chameleon.gui.editor.actions.fade=Перехід
chameleon.gui.editor.actions.tick=Тік

chameleon.gui.config.models=Відкрити моделі...
chameleon.gui.config.tutorial=Відеоуроки
chameleon.gui.config.discord=Діскорд
chameleon.gui.config.wiki=Вікі

# Morph stuff
morph.section.chameleon=Хамелеон
morph.category.chameleon=Анімовані моделі

==================================================

--- Файл №56 ---
Путь: main\resources\assets\chameleon\lang\zh_cn.lang
--------------------
#PARSE_ESCAPES

# Config
chameleon.config.title=Chameleon

chameleon.config.general.title=常规
chameleon.config.general.tooltip=常规选项

# GUI
chameleon.gui.editor.pick_skin=选择皮肤
chameleon.gui.editor.main=主面板
chameleon.gui.editor.create_pose=创建姿势
chameleon.gui.editor.reset_pose=重置姿势
chameleon.gui.editor.absolute_brightness=绝对亮度
chameleon.gui.editor.glow=肢体发光
chameleon.gui.editor.color=肢体颜色
chameleon.gui.editor.fixed=固定动作
chameleon.gui.editor.animated=动画姿势
chameleon.gui.editor.context.copy=拷贝姿势
chameleon.gui.editor.context.paste=粘贴姿势
chameleon.gui.editor.context.children=应用至子肢体

chameleon.gui.editor.scale=全局缩放
chameleon.gui.editor.scale_gui=GUI 缩放

chameleon.gui.editor.player=动作播放模式
chameleon.gui.editor.player_tooltip=这会使当前伪装播放可同步的 “Animation” 动作

chameleon.gui.editor.actions.actions=动作
chameleon.gui.editor.actions.action=动作

chameleon.gui.editor.actions.clamp=回卷
chameleon.gui.editor.actions.reset=归位
chameleon.gui.editor.actions.speed=速度
chameleon.gui.editor.actions.fade=缓入缓出
chameleon.gui.editor.actions.tick=Tick

chameleon.gui.config.models=打开模型文件夹...
chameleon.gui.config.tutorial=视频教程
chameleon.gui.config.discord=Discord
chameleon.gui.config.wiki=Wiki

# Morph stuff
morph.section.chameleon=Chameleon
morph.category.chameleon=动画模型

==================================================

--- Файл №57 ---
Путь: main\resources\assets\chameleon\lang\zh_tw.lang
--------------------
#PARSE_ESCAPES

# Config
chameleon.config.title=Chameleon

chameleon.config.general.title=常規
chameleon.config.general.tooltip=常規選項

# GUI
chameleon.gui.editor.pick_skin=選擇皮膚
chameleon.gui.editor.main=主面板
chameleon.gui.editor.create_pose=創建姿勢
chameleon.gui.editor.reset_pose=重置姿勢
chameleon.gui.editor.absolute_brightness=絕對亮度
chameleon.gui.editor.glow=肢體發光
chameleon.gui.editor.color=肢體顔色
chameleon.gui.editor.fixed=固定動作
chameleon.gui.editor.animated=動畫姿勢
chameleon.gui.editor.context.copy=拷貝姿勢
chameleon.gui.editor.context.paste=粘貼姿勢
chameleon.gui.editor.context.children=應用至子肢體

chameleon.gui.editor.scale=全局縮放
chameleon.gui.editor.scale_gui=GUI 縮放

chameleon.gui.editor.player=動作播放模式
chameleon.gui.editor.player_tooltip=這會使當前偽裝播放可同步的 “Animation” 動作

chameleon.gui.editor.actions.actions=動作
chameleon.gui.editor.actions.action=動作

chameleon.gui.editor.actions.clamp=回捲
chameleon.gui.editor.actions.reset=歸位
chameleon.gui.editor.actions.speed=速度
chameleon.gui.editor.actions.fade=緩入緩出
chameleon.gui.editor.actions.tick=Tick

chameleon.gui.config.models=打開模型文件夾...
chameleon.gui.config.tutorial=視頻教程
chameleon.gui.config.discord=Discord
chameleon.gui.config.wiki=Wiki

# Morph stuff
morph.section.chameleon=Chameleon
morph.category.chameleon=動畫模型

==================================================

