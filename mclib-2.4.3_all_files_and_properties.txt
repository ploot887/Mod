Анализ содержимого папки: C:\Users\User\Desktop\mody\mclib-2.4.3\src
==================================================

--- Файл №1 ---
Путь: main\java\mchorse\mclib\ClientProxy.java
--------------------
package mchorse.mclib;

import mchorse.mclib.client.KeyboardHandler;
import mchorse.mclib.client.InputRenderer;
import mchorse.mclib.client.gui.utils.KeybindConfig;
import mchorse.mclib.client.gui.utils.keys.LangKey;
import mchorse.mclib.events.RenderingHandler;
import mchorse.mclib.utils.ReflectionUtils;
import mchorse.mclib.utils.resources.MultiResourceLocation;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.resources.IReloadableResourceManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

@SideOnly(Side.CLIENT)
public class ClientProxy extends CommonProxy
{
    public static KeybindConfig keybinds;

    @Override
    public void preInit(FMLPreInitializationEvent event)
    {
        super.preInit(event);

        MinecraftForge.EVENT_BUS.register(new KeyboardHandler());
        MinecraftForge.EVENT_BUS.register(new InputRenderer());
        MinecraftForge.EVENT_BUS.register(new RenderingHandler());

        keybinds = new KeybindConfig();
    }

    @Override
    public void init(FMLInitializationEvent event)
    {
        super.init(event);

        Minecraft mc = Minecraft.getMinecraft();

        /* OMG, thank you very much Forge! */
        if (!mc.getFramebuffer().isStencilEnabled())
        {
            mc.getFramebuffer().enableStencil();
        }

        ((IReloadableResourceManager) mc.getResourceManager()).registerReloadListener((manager) ->
        {
            LangKey.lastTime = System.currentTimeMillis();

            if (McLib.multiskinClear.get())
            {
                mc.addScheduledTask(this::clearMultiTextures);
            }
        });

        this.configs.modules.put(keybinds.id, keybinds);
    }

    private void clearMultiTextures()
    {
        Minecraft mc = Minecraft.getMinecraft();
        Map<ResourceLocation, ITextureObject> map = ReflectionUtils.getTextures(mc.renderEngine);
        List<ResourceLocation> toClear = new ArrayList<ResourceLocation>();

        for (ResourceLocation location : map.keySet())
        {
            if (location instanceof MultiResourceLocation)
            {
                toClear.add(location);
            }
        }

        for (ResourceLocation location : toClear)
        {
            mc.renderEngine.deleteTexture(location);
        }
    }
}

==================================================

--- Файл №2 ---
Путь: main\java\mchorse\mclib\CommonProxy.java
--------------------
package mchorse.mclib;

import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.config.ConfigHandler;
import mchorse.mclib.config.ConfigManager;
import mchorse.mclib.events.EventHandler;
import mchorse.mclib.events.RegisterPermissionsEvent;
import mchorse.mclib.network.mclib.Dispatcher;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;

import java.io.File;

public class CommonProxy
{
    public ConfigManager configs = new ConfigManager();
    public File configFolder;

    public void preInit(FMLPreInitializationEvent event)
    {
        this.configFolder = event.getModConfigurationDirectory();

        Dispatcher.register();

        MinecraftForge.EVENT_BUS.register(new ConfigHandler());
    }

    public void init(FMLInitializationEvent event)
    {
        this.configs.register(this.configFolder);

        RegisterPermissionsEvent permissions = new RegisterPermissionsEvent();

        /* let the mods register their permissions */
        McLib.EVENT_BUS.post(permissions);

        permissions.loadPermissions();

        Icons.register();

        MinecraftForge.EVENT_BUS.register(new EventHandler());
    }
}

==================================================

--- Файл №3 ---
Путь: main\java\mchorse\mclib\McLib.java
--------------------
package mchorse.mclib;

import mchorse.mclib.client.gui.utils.ValueColors;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.commands.CommandMcLib;
import mchorse.mclib.commands.CommandCheats;
import mchorse.mclib.commands.utils.L10n;
import mchorse.mclib.events.RegisterPermissionsEvent;
import mchorse.mclib.permissions.McLibPermissions;
import mchorse.mclib.config.ConfigBuilder;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueRL;
import mchorse.mclib.events.RegisterConfigEvent;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.MathBuilder;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.Operator;
import mchorse.mclib.math.Variable;
import mchorse.mclib.permissions.PermissionCategory;
import mchorse.mclib.permissions.PermissionFactory;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.PayloadASM;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.SidedProxy;
import net.minecraftforge.fml.common.event.FMLInitializationEvent;
import net.minecraftforge.fml.common.event.FMLPreInitializationEvent;
import net.minecraftforge.fml.common.event.FMLServerStartingEvent;
import net.minecraftforge.fml.common.eventhandler.EventBus;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.network.NetworkCheckHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.server.permission.DefaultPermissionLevel;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.util.Map;

/**
 * McLib mod
 * 
 * All it does is provides common code for McHorse's mods.
 */
@Mod.EventBusSubscriber
@Mod(modid = McLib.MOD_ID, name = "McLib", version = McLib.VERSION, updateJSON = "https://raw.githubusercontent.com/mchorse/mclib/1.12/version.json")
public class McLib
{
    public static final String MOD_ID = "mclib";
    public static final String VERSION = "%VERSION%";

    /* Proxies */
    public static final String CLIENT_PROXY = "mchorse.mclib.ClientProxy";
    public static final String SERVER_PROXY = "mchorse.mclib.CommonProxy";

    @SidedProxy(clientSide = CLIENT_PROXY, serverSide = SERVER_PROXY)
    public static CommonProxy proxy;

    public static final EventBus EVENT_BUS = new EventBus();

    public static final Logger LOGGER = LogManager.getLogger(McLib.MOD_ID);

    public static L10n l10n = new L10n(MOD_ID);

    /**
     * A factory containing all permissions that have been registered through the {@link RegisterPermissionsEvent}.
     */
    public static final PermissionFactory permissionFactory = new PermissionFactory();

    /* Configuration */
    public static ValueBoolean opDropItems;

    public static ValueBoolean debugPanel;
    public static ValueColors favoriteColors;
    public static ValueInt primaryColor;
    public static ValueBoolean enableBorders;
    public static ValueBoolean enableCheckboxRendering;
    public static ValueBoolean enableTrackpadIncrements;
    public static ValueBoolean enableGridRendering;
    public static ValueInt userIntefaceScale;
    public static ValueInt tooltipStyle;
    public static ValueInt trackpadDecimalPlaces;
    public static ValueBoolean renderTranslateTextColors;

    public static ValueBoolean enableCursorRendering;
    public static ValueBoolean enableMouseButtonRendering;
    public static ValueBoolean enableKeystrokeRendering;
    public static ValueInt keystrokeOffset;
    public static ValueInt keystrokeMode;

    public static ValueRL backgroundImage;
    public static ValueInt backgroundColor;

    public static ValueBoolean scrollbarFlat;
    public static ValueInt scrollbarShadow;
    public static ValueInt scrollbarWidth;

    public static ValueBoolean multiskinMultiThreaded;
    public static ValueBoolean multiskinClear;

    public static ValueInt maxPacketSize;

    @SubscribeEvent
    public void onConfigRegister(RegisterConfigEvent event)
    {
        opDropItems = event.opAccess.category(MOD_ID).getBoolean("drop_items", true);

        /* McLib's options */
        ConfigBuilder builder = event.createBuilder(MOD_ID);

        /* Appearance category */
        debugPanel = builder.category("appearance").getBoolean("debug_panel", false);
        debugPanel.invisible();
        primaryColor = builder.getInt("primary_color", 0x0088ff).color();
        enableBorders = builder.getBoolean("enable_borders", false);
        enableCheckboxRendering = builder.getBoolean("enable_checkbox_rendering", false);
        enableTrackpadIncrements = builder.getBoolean("enable_trackpad_increments", true);
        trackpadDecimalPlaces = builder.getInt("trackpad_decimal_places", 6, 3, 31);
        enableGridRendering = builder.getBoolean("enable_grid_rendering", true);
        userIntefaceScale = builder.getInt("user_interface_scale", 2, 0, 4);
        tooltipStyle = builder.getInt("tooltip_style", 1).modes(
            IKey.lang("mclib.tooltip_style.light"),
            IKey.lang("mclib.tooltip_style.dark")
        );
        renderTranslateTextColors = builder.getBoolean("render_translation_text_colours", false);

        favoriteColors = new ValueColors("favorite_colors");
        builder.register(favoriteColors);

        builder.getCategory().markClientSide();

        /* Tutorials category */
        enableCursorRendering = builder.category("tutorials").getBoolean("enable_mouse_rendering", false);
        enableMouseButtonRendering = builder.getBoolean("enable_mouse_buttons_rendering", false);
        enableKeystrokeRendering = builder.getBoolean("enable_keystrokes_rendering", false);
        keystrokeOffset = builder.getInt("keystroke_offset", 10, 0, 20);
        keystrokeMode = builder.getInt("keystroke_position", 1).modes(
            IKey.lang("mclib.keystrokes_position.auto"),
            IKey.lang("mclib.keystrokes_position.bottom_left"),
            IKey.lang("mclib.keystrokes_position.bottom_right"),
            IKey.lang("mclib.keystrokes_position.top_right"),
            IKey.lang("mclib.keystrokes_position.top_left")
        );

        builder.getCategory().markClientSide();

        /* Background category */
        backgroundImage = builder.category("background").getRL("image",  null);
        backgroundColor = builder.getInt("color",  0xcc000000).colorAlpha();

        builder.getCategory().markClientSide();

        /* Scrollbars category */
        scrollbarFlat = builder.category("scrollbars").getBoolean("flat", false);
        scrollbarShadow = builder.getInt("shadow", ColorUtils.HALF_BLACK).colorAlpha();
        scrollbarWidth = builder.getInt("width", 4, 2, 10);

        builder.getCategory().markClientSide();

        /* Multiskin category */
        multiskinMultiThreaded = builder.category("multiskin").getBoolean("multithreaded", true);
        multiskinClear = builder.getBoolean("clear", true);

        builder.getCategory().markClientSide();

        /* Vanilla category */
        maxPacketSize = builder.category("vanilla").getInt("max_packet_size", PayloadASM.MIN_SIZE, PayloadASM.MIN_SIZE, Integer.MAX_VALUE / 4);
        maxPacketSize.syncable();
    }

    @SubscribeEvent
    public void onPermissionRegister(RegisterPermissionsEvent event)
    {
        event.registerMod(MOD_ID, DefaultPermissionLevel.OP);

        event.registerPermission(McLibPermissions.configEdit = new PermissionCategory("edit_config"));

        event.registerCategory(new PermissionCategory("gui"));
        event.registerPermission(McLibPermissions.accessGui = new PermissionCategory("access_gui"));

        event.endMod();
    }

    @Mod.EventHandler
    public void preInit(FMLPreInitializationEvent event)
    {
        proxy.preInit(event);

        EVENT_BUS.register(this);
    }

    @Mod.EventHandler
    public void init(FMLInitializationEvent event)
    {
        proxy.init(event);
    }

    @NetworkCheckHandler
    public boolean checkModDependencies(Map<String, String> map, Side side)
    {
        return true;
    }

    @Mod.EventHandler
    public void serverInit(FMLServerStartingEvent event)
    {
        if (event.getServer().isSinglePlayer())
        {
            event.registerServerCommand(new CommandCheats());
        }

        event.registerServerCommand(new CommandMcLib());
    }

    public static void main(String[] args) throws Exception
    {
        Operator.DEBUG = true;
        MathBuilder builder = new MathBuilder();

        test(builder, "1 - 2 * 3 + 4 ", 1 - 2 * 3 + 4  );
        test(builder, "2 * 3 - 8 + 7 ", 2 * 3 - 8 + 7  );
        test(builder, "3 - 7 + 2 * 4 ", 3 - 7 + 2 * 4  );
        test(builder, "8 / 4 - 3 * 10", 8 / 4 - 3 * 10 );
        test(builder, "2 - 4 * 5 / 8 ", 2 - 4 * 5 / 8D );
        test(builder, "3 / 4 * 8 - 10", 3 / 4D * 8 - 10);
        test(builder, "2 * 3 / 4 * 5 ", 2D * 3 / 4 * 5 );
        test(builder, "2 + 3 - 4 + 5 ", 2 + 3 - 4 + 5  );
        test(builder, "7 - 2 ^ 4 - 4 * 5 + 15 ^ 2", 7 - Math.pow(2, 4) - 4 * 5 + Math.pow(15, 2));
        test(builder, "5 -(10 + 20)", 5 -(10 + 20));
        test(builder, "1 << 4 - 1", 1 << 4 - 1);
        test(builder, "256 >> 4 + 2", 256 >> 4 + 2);
        test(builder, "255 & 7 + 1", 255 & 7 + 1);
        test(builder, "256 | 7 + 1", 256 | 7 + 1);
        test(builder, "5 % 2 + 1 == 0 * 2", 5 % 2 + 1 == 0 * 2 ? 1 : 0);

        builder.variables.put("abc", new Variable("abc", 1));
        IValue test = builder.parse("- (40 + 2) / -2");

        System.out.println(test.isNumber() + " " + test.stringValue() + " " + test.booleanValue() + " " + test.doubleValue());
    }

    public static void test(MathBuilder builder, String expression, double result) throws Exception
    {
        IValue value = builder.parse(expression);

        System.out.println(expression + " = " + value.get() + " (" + result + ") is " + Operation.equals(value.get().doubleValue(), result));
        System.out.println(value.toString() + "\n");
    }
}

==================================================

--- Файл №4 ---
Путь: main\java\mchorse\mclib\client\Draw.java
--------------------
package mchorse.mclib.client;

import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import org.lwjgl.opengl.GL11;

public class Draw
{
    public static void axis(float length)
    {
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        GL11.glLineWidth(5);
        buffer.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(0, 0, 0).color(0, 0, 0, 1F).endVertex();
        buffer.pos(length, 0, 0).color(0, 0, 0, 1F).endVertex();
        buffer.pos(0, 0, 0).color(0, 0, 0, 1F).endVertex();
        buffer.pos(0, length, 0).color(0, 0, 0, 1F).endVertex();
        buffer.pos(0, 0, 0).color(0, 0, 0, 1F).endVertex();
        buffer.pos(0, 0, length).color(0, 0, 0, 1F).endVertex();
        tessellator.draw();

        GL11.glLineWidth(3);
        buffer.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(0, 0, 0).color(1F, 0, 0, 1F).endVertex();
        buffer.pos(length, 0, 0).color(1F, 0, 0, 1F).endVertex();
        buffer.pos(0, 0, 0).color(0, 1F, 0, 1F).endVertex();
        buffer.pos(0, length, 0).color(0, 1F, 0, 1F).endVertex();
        buffer.pos(0, 0, 0).color(0, 0, 1F, 1F).endVertex();
        buffer.pos(0, 0, length).color(0, 0, 1F, 1F).endVertex();
        tessellator.draw();
        GL11.glLineWidth(1);

        point(0, 0, 0);
    }

    public static void point(double x, double y, double z)
    {
        GL11.glPointSize(12);
        GL11.glBegin(GL11.GL_POINTS);
        GL11.glColor3d(0, 0, 0);
        GL11.glVertex3d(0, 0, 0);
        GL11.glEnd();

        GL11.glPointSize(10);
        GL11.glBegin(GL11.GL_POINTS);
        GL11.glColor3d(1, 1, 1);
        GL11.glVertex3d(0, 0, 0);
        GL11.glEnd();
        GL11.glPointSize(1);
    }

    public static void cube(double minX, double minY, double minZ, double maxX, double maxY, double maxZ, float red, float green, float blue, float alpha)
    {
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
        cube(buffer, minX, minY, minZ, maxX, maxY, maxZ, red, green, blue, alpha);
        tessellator.draw();
    }

    public static void cube(BufferBuilder buffer, double minX, double minY, double minZ, double maxX, double maxY, double maxZ, float red, float green, float blue, float alpha)
    {
        /* Top */
        buffer.pos(minX, maxY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, maxY, minZ).color(red, green, blue, alpha).endVertex();

        /* Bottom */
        buffer.pos(minX, minY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, minY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, minY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, minY, maxZ).color(red, green, blue, alpha).endVertex();

        /* Left */
        buffer.pos(minX, maxY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, minY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, minY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, maxY, maxZ).color(red, green, blue, alpha).endVertex();

        /* Right */
        buffer.pos(maxX, maxY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, minY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, minY, minZ).color(red, green, blue, alpha).endVertex();

        /* Front */
        buffer.pos(minX, maxY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, maxY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, minY, minZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, minY, minZ).color(red, green, blue, alpha).endVertex();

        /* Back */
        buffer.pos(minX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(minX, minY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, minY, maxZ).color(red, green, blue, alpha).endVertex();
        buffer.pos(maxX, maxY, maxZ).color(red, green, blue, alpha).endVertex();
    }
}

==================================================

--- Файл №5 ---
Путь: main\java\mchorse\mclib\client\InputRenderer.java
--------------------
package mchorse.mclib.client;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.events.RenderOverlayEvent;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.Keys;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraftforge.client.event.GuiScreenEvent;
import net.minecraftforge.client.event.GuiScreenEvent.DrawScreenEvent;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.GL11;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
 * Mouse renderer
 * 
 * This class is responsible for rendering a mouse pointer on the screen 
 */
@SideOnly(Side.CLIENT)
public class InputRenderer
{
    public static boolean disabledForFrame = false;

    private List<PressedKey> pressedKeys = new ArrayList<PressedKey>();
    private float lastQX = 1;
    private float lastQY = 0;
    private float currentQX = 0;
    private float currentQY = 1;
    private long lastDWheelTime;
    private int lastDWheelScroll;

    public static void disable()
    {
        disabledForFrame = true;
    }

    /**
     * Called by ASM
     */
    public static void preRenderOverlay()
    {
        Minecraft mc = Minecraft.getMinecraft();
        ScaledResolution resolution = new ScaledResolution(mc);

        setupOrthoProjection(resolution);

        McLib.EVENT_BUS.post(new RenderOverlayEvent.Pre(mc, resolution));
    }

    /**
     * Called by ASM
     */
    public static void postRenderOverlay()
    {
        Minecraft mc = Minecraft.getMinecraft();
        ScaledResolution resolution = new ScaledResolution(mc);

        setupOrthoProjection(resolution);

        McLib.EVENT_BUS.post(new RenderOverlayEvent.Post(mc, resolution));
    }

    /* Shift -6 and -8 to get it into the center */
    public static void renderMouseButtons(int x, int y, int scroll, boolean left, boolean right, boolean middle, boolean isScrolling)
    {
        /* Outline */
        Gui.drawRect(x - 1, y, x + 13, y + 16, 0xff000000);
        Gui.drawRect(x, y - 1, x + 12, y + 17, 0xff000000);
        /* Background */
        Gui.drawRect(x, y + 1, x + 12, y + 15, 0xffffffff);
        Gui.drawRect(x + 1, y, x + 11, y + 1, 0xffffffff);
        Gui.drawRect(x + 1, y + 15, x + 11, y + 16, 0xffffffff);
        /* Over outline */
        Gui.drawRect(x, y + 7, x + 12, y + 8, 0xffeeeeee);

        if (left)
        {
            Gui.drawRect(x + 1, y, x + 6, y + 7, 0xffcccccc);
            Gui.drawRect(x, y + 1, x + 1, y + 7, 0xffaaaaaa);
        }

        if (right)
        {
            Gui.drawRect(x + 6, y, x + 11, y + 7, 0xffaaaaaa);
            Gui.drawRect(x + 11, y + 1, x + 12, y + 7, 0xff888888);
        }

        if (middle || isScrolling)
        {
            int offset = 0;

            if (isScrolling)
            {
                offset = scroll < 0 ? 1 : -1;
            }

            Gui.drawRect(x + 4, y, x + 8, y + 6, 0x20000000);
            Gui.drawRect(x + 5, y + 1 + offset, x + 7, y + 5 + offset, 0xff444444);
            Gui.drawRect(x + 5, y + 4 + offset, x + 7, y + 5 + offset, 0xff333333);
        }
    }

    public static void renderMouseWheel(int x, int y, int scroll, long current)
    {
        int color = McLib.primaryColor.get();

        GuiDraw.drawDropShadow(x, y, x + 4, y + 16, 2, ColorUtils.HALF_BLACK + color, color);
        Gui.drawRect(x, y, x + 4, y + 16, 0xff111111);
        Gui.drawRect(x + 1, y, x + 3, y + 15, 0xff2a2a2a);

        int offset = (int) ((current % 1000 / 50) % 4);

        if (scroll >= 0)
        {
            offset = 3 - offset;
        }

        for (int i = 0; i < 4; i++)
        {
            Gui.drawRect(x, y + offset, x + 4, y + offset + 1, 0x88555555);

            y += 4;
        }
    }

    private static void setupOrthoProjection(ScaledResolution resolution)
    {
        GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);
        GlStateManager.matrixMode(GL11.GL_PROJECTION);
        GlStateManager.loadIdentity();
        GlStateManager.ortho(0, resolution.getScaledWidth_double(), resolution.getScaledHeight_double(), 0, 1000D, 3000D);
        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
        GlStateManager.loadIdentity();
        GlStateManager.translate(0, 0, -2000F);
    }

    @SubscribeEvent
    public void onDrawEvent(DrawScreenEvent.Post event)
    {
        if (disabledForFrame)
        {
            disabledForFrame = false;

            return;
        }

        int x = event.getMouseX();
        int y = event.getMouseY();

        this.renderMouse(x, y);

        if (McLib.enableKeystrokeRendering.get())
        {
            this.renderKeys(event.getGui(), x, y);
        }
    }

    /**
     * Draw mouse cursor
     */
    private void renderMouse(int x, int y)
    {
        GlStateManager.disableLighting();
        GlStateManager.pushMatrix();
        GlStateManager.translate(0, 0, 1000);
        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);
        GlStateManager.enableAlpha();

        if (McLib.enableCursorRendering.get())
        {
            Icons.CURSOR.render(x, y);
        }

        if (McLib.enableMouseButtonRendering.get())
        {
            boolean left = Mouse.isButtonDown(0);
            boolean right = Mouse.isButtonDown(1);
            boolean middle = Mouse.isButtonDown(2);

            int scroll = Mouse.getDWheel();
            long current = System.currentTimeMillis();
            boolean isScrolling = scroll != 0 || current - this.lastDWheelTime < 500;

            if (scroll != 0)
            {
                this.lastDWheelTime = current;
                this.lastDWheelScroll = scroll;
            }

            if (scroll == 0 && isScrolling)
            {
                scroll = this.lastDWheelScroll;
            }

            x += 16;
            y += 2;

            if (left || right || middle || isScrolling)
            {
                renderMouseButtons(x, y, scroll, left, right, middle, isScrolling);
            }

            if (isScrolling)
            {
                x += 16;

                renderMouseWheel(x, y, scroll, current);
            }
        }

        GlStateManager.disableAlpha();
        GlStateManager.popMatrix();
    }

    /**
     * Render pressed key strokes
     */
    private void renderKeys(GuiScreen screen, int mouseX, int mouseY)
    {
        float lqx = Math.round(mouseX / (float) screen.width);
        float lqy = Math.round(mouseY / (float) screen.height);
        int mode = McLib.keystrokeMode.get();

        if (lqx == this.currentQX && lqy == this.currentQY)
        {
            this.currentQX = this.lastQX;
            this.currentQY = this.lastQY;
        }

        if (mode == 1)
        {
            this.currentQX = 0;
            this.currentQY = 1;
        }
        else if (mode == 2)
        {
            this.currentQX = 1;
            this.currentQY = 1;
        }
        else if (mode == 3)
        {
            this.currentQX = 1;
            this.currentQY = 0;
        }
        else if (mode == 4)
        {
            this.currentQX = 0;
            this.currentQY = 0;
        }

        float qx = this.currentQX;
        float qy = this.currentQY;

        int fy = qy > 0.5F ? 1 : -1;
        int offset = McLib.keystrokeOffset.get();
        int mx = offset + (int) (qx * (screen.width - offset * 2));
        int my = offset + (int) (qy * (screen.height - 20 - offset * 2));

        FontRenderer font = Minecraft.getMinecraft().fontRenderer;
        Iterator<PressedKey> it = this.pressedKeys.iterator();

        GlStateManager.disableLighting();
        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);

        while (it.hasNext())
        {
            PressedKey key = it.next();

            if (key.expired())
            {
                it.remove();
            }
            else
            {
                int x = mx + (qx < 0.5F ? key.x : -(key.x + key.width + 10));
                int y = my + (int) (Interpolation.EXP_INOUT.interpolate(0, 1, key.getFactor()) * 50 * fy) + (key.i % 2 == 0 ? -1 : 0);

                GuiDraw.drawDropShadow(x, y, x + 10 + key.width, y + 20, 4, 0x44000000, 0);
                Gui.drawRect(x, y, x + 10 + key.width, y + 20, 0xff000000 + McLib.primaryColor.get());
                font.drawStringWithShadow(key.getLabel(), x + 5, y + 6, 0xffffff);
            }
        }

        this.lastQX = lqx;
        this.lastQY = lqy;
    }

    @SubscribeEvent
    public void onKeyPressedInGUI(GuiScreenEvent.KeyboardInputEvent.Post event)
    {
        boolean inputFocused = GuiBase.getCurrent() == null || GuiBase.getCurrent().activeElement == null;

        if (Keyboard.getEventKeyState() && inputFocused)
        {
            int key = Keyboard.getEventKey() == 0 ? Keyboard.getEventCharacter() + 256 : Keyboard.getEventKey();

            if (key >= 256 || key < 0)
            {
                return;
            }

            PressedKey last = null;
            int offset = -1000;

            for (PressedKey pressed : this.pressedKeys)
            {
                if (pressed.key == key)
                {
                    offset = pressed.increment();
                }
                else if (offset != -1000)
                {
                    pressed.x += offset;
                }

                last = pressed;
            }

            if (offset != -1000)
            {
                return;
            }

            offset = McLib.keystrokeOffset.get();
            int x = last == null ? 0 : last.x + last.width + 5;
            PressedKey newKey = new PressedKey(key, x);

            if (newKey.x + newKey.width + offset > event.getGui().width - offset * 2)
            {
                newKey.x = 0;
            }

            this.pressedKeys.add(newKey);
        }
    }

    /**
     * Release the matrix at the end of frame to avoid messing
     * up matrix capture even more
     */
    @SubscribeEvent
    public void onRenderLast(RenderWorldLastEvent event)
    {
        MatrixUtils.releaseMatrix();
    }

    /**
     * Information about pressed key strokes
     */
    @SideOnly(Side.CLIENT)
    public static class PressedKey
    {
        public static int INDEX = 0;

        public int key;
        public long time;
        public int x;

        public String name;
        public int width;
        public int i;
        public int times = 1;

        public PressedKey(int key, int x)
        {
            this.key = key;
            this.time = System.currentTimeMillis();
            this.x = x;

            this.name = Keys.getKeyName(key);
            this.width = Minecraft.getMinecraft().fontRenderer.getStringWidth(this.name);
            this.i = INDEX ++;
        }

        public float getFactor()
        {
            return (System.currentTimeMillis() - this.time - 500) / 1000F;
        }

        public boolean expired()
        {
            if (Keyboard.isKeyDown(this.key))
            {
                this.time = System.currentTimeMillis();
            }

            return System.currentTimeMillis() - this.time > 1500;
        }

        public String getLabel()
        {
            if (this.times > 1)
            {
                return this.name + " (" + this.times + ")";
            }

            return this.name;
        }

        public int increment()
        {
            int lastWidth = this.width;

            this.times ++;
            this.width = Minecraft.getMinecraft().fontRenderer.getStringWidth(this.getLabel());

            return this.width - lastWidth;
        }
    }
}

==================================================

--- Файл №6 ---
Путь: main\java\mchorse\mclib\client\KeyboardHandler.java
--------------------
package mchorse.mclib.client;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.utils.GuiInventoryElement;
import mchorse.mclib.client.gui.mclib.GuiAbstractDashboard;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.config.values.ValueRL;
import mchorse.mclib.events.RemoveDashboardPanels;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiMainMenu;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.settings.KeyBinding;
import net.minecraftforge.client.event.GuiOpenEvent;
import net.minecraftforge.fml.client.registry.ClientRegistry;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.InputEvent;
import org.lwjgl.input.Keyboard;

public class KeyboardHandler
{
    public KeyBinding dashboard;

    private int lastGuiScale = -1;

    public KeyboardHandler()
    {
        this.dashboard = new KeyBinding("key.mclib.dashboard", Keyboard.KEY_0, "key.mclib.category");

        ClientRegistry.registerKeyBinding(this.dashboard);
    }

    @SubscribeEvent
    public void onKeyboardInput(InputEvent.KeyInputEvent event)
    {
        if (this.dashboard.isPressed())
        {
            GuiDashboard dashboard = GuiDashboard.get();

            Minecraft.getMinecraft().displayGuiScreen(dashboard);

            if (GuiScreen.isCtrlKeyDown())
            {
                dashboard.panels.setPanel(dashboard.config);
            }
        }
    }

    @SubscribeEvent
    public void onGuiOpen(GuiOpenEvent event)
    {
        if (event.getGui() instanceof GuiBase)
        {
            if (this.lastGuiScale == -1)
            {
                this.lastGuiScale = Minecraft.getMinecraft().gameSettings.guiScale;

                int scale = McLib.userIntefaceScale.get();

                if (scale > 0)
                {
                    Minecraft.getMinecraft().gameSettings.guiScale = scale;
                }
            }
        }
        else
        {
            if (this.lastGuiScale != -1)
            {
                Minecraft.getMinecraft().gameSettings.guiScale = this.lastGuiScale;
                this.lastGuiScale = -1;
            }

            if (Minecraft.getMinecraft().world == null)
            {
                GuiDashboard.dashboard = null;
                ValueRL.picker = null;
                GuiInventoryElement.container = null;

                McLib.proxy.configs.resetServerValues();
                McLib.EVENT_BUS.post(new RemoveDashboardPanels());
            }
        }
    }
}

==================================================

--- Файл №7 ---
Путь: main\java\mchorse\mclib\client\gui\framework\GuiBase.java
--------------------
package mchorse.mclib.client.gui.framework;

import jline.internal.Nullable;
import mchorse.mclib.client.gui.framework.elements.IViewport;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.IViewportStack;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;

import java.io.IOException;
import java.util.List;

/**
 * Base class for GUI screens using this framework
 */
@SideOnly(Side.CLIENT)
public class GuiBase extends GuiScreen
{
    private static GuiContext current;

    public GuiElement root;
    public GuiContext context = new GuiContext(this);
    public Area viewport = new Area();

    public static GuiContext getCurrent()
    {
        return current;
    }

    public GuiBase()
    {
        current = this.context;

        this.context.mc = Minecraft.getMinecraft();
        this.context.font = this.context.mc.fontRenderer;

        this.root = new GuiRootElement(this.context.mc);
        this.root.markContainer().flex().relative(this.viewport).wh(1F, 1F);
        this.root.keys().register(IKey.lang("mclib.gui.keys.list"), Keyboard.KEY_F9, () -> this.context.keybinds.toggleVisible());

        this.context.keybinds.flex().relative(this.viewport).wh(0.5F, 1F);

        Keyboard.enableRepeatEvents(false);
    }

    /**
     *
     * @param clazz the class to search for in the children of this screen.root
     * @param <T>
     * @return null if GuiBase.screen or GuiBase.screen.root is null or if the children List is empty.
     */
    @Nullable
    public static <T> List<T> getCurrentChildren(Class<T> clazz)
    {
        if (GuiBase.getCurrent() != null && GuiBase.getCurrent().screen != null && GuiBase.getCurrent().screen.root != null)
        {
            List<T> childList = GuiBase.getCurrent().screen.root.getChildren(clazz);

            return (childList.isEmpty()) ? null : childList;
        }

        return null;
    }

    @Override
    public void updateScreen()
    {
        this.context.tick += 1;
    }

    @Override
    public void initGui()
    {
        current = this.context;

        if (!this.context.keybinds.hasParent())
        {
            this.root.add(this.context.keybinds);
        }

        this.viewport.set(0, 0, this.width, this.height);
        this.viewportSet();

        this.context.pushViewport(this.viewport);
        this.root.resize();
        this.context.popViewport();
    }

    protected void viewportSet()
    {}

    @Override
    public void onGuiClosed()
    {
        current = null;
    }

    @Override
    public void handleMouseInput() throws IOException
    {
        int x = Mouse.getEventX() * this.width / this.mc.displayWidth;
        int y = this.height - Mouse.getEventY() * this.height / this.mc.displayHeight - 1;

        super.handleMouseInput();

        int scroll = -Mouse.getEventDWheel();

        if (scroll == 0)
        {
            return;
        }

        this.mouseScrolled(x, y, scroll);
    }

    @Override
    protected void mouseClicked(int mouseX, int mouseY, int mouseButton) throws IOException
    {
        this.context.setMouse(mouseX, mouseY, mouseButton);

        if (this.root.isEnabled())
        {
            this.context.pushViewport(this.viewport);
            this.root.mouseClicked(this.context);
            this.context.popViewport();
        }
    }

    protected void mouseScrolled(int x, int y, int scroll)
    {
        this.context.setMouseWheel(x, y, scroll);

        if (this.root.isEnabled())
        {
            this.context.pushViewport(this.viewport);
            this.root.mouseScrolled(this.context);
            this.context.popViewport();
        }
    }

    @Override
    protected void mouseReleased(int mouseX, int mouseY, int state)
    {
        this.context.setMouse(mouseX, mouseY, state);

        if (this.root.isEnabled())
        {
            this.context.pushViewport(this.viewport);
            this.root.mouseReleased(this.context);
            this.context.popViewport();
        }
    }

    @Override
    protected void keyTyped(char typedChar, int keyCode) throws IOException
    {
        this.context.setKey(typedChar, keyCode);

        if (this.root.isEnabled() && this.root.keyTyped(this.context))
        {
            return;
        }

        this.context.pushViewport(this.viewport);
        this.keyPressed(typedChar, keyCode);
        this.context.popViewport();


        if (keyCode == 1)
        {
            this.closeScreen();
        }
    }

    /**
     * This method is getting called when there are no active text 
     * fields in the GUI (this can be used for handling shortcuts)
     */
    public void keyPressed(char typedChar, int keyCode)
    {}

    /**
     * This method is called when this screen is about to get closed
     */
    protected void closeScreen()
    {
        this.mc.displayGuiScreen(null);

        if (this.mc.currentScreen == null)
        {
            this.mc.setIngameFocus();
        }

        Keyboard.enableRepeatEvents(false);
    }

    public void closeThisScreen()
    {
        this.closeScreen();
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        this.context.setMouse(mouseX, mouseY);
        this.context.partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();

        if (this.root.isVisible())
        {
            this.context.reset();
            this.context.pushViewport(this.viewport);

            this.root.draw(this.context);

            this.context.popViewport();
            this.context.drawTooltip();
            this.context.postRenderCallbacks.forEach((element) ->
            {
                element.accept(this.context);
            });
        }
    }

    public static class GuiRootElement extends GuiElement implements IViewport
    {
        public GuiRootElement(Minecraft mc)
        {
            super(mc);
        }

        @Override
        public void apply(IViewportStack stack)
        {
            stack.pushViewport(this.area);
        }

        @Override
        public void unapply(IViewportStack stack)
        {
            stack.popViewport();
        }
    }
}

==================================================

--- Файл №8 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiCollapseSection.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.framework.elements.utils.IconContainer;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;

import java.util.function.Supplier;

public class GuiCollapseSection extends GuiElement
{
    protected GuiLabel title;
    protected GuiElement fields;
    protected boolean collapsed;
    protected IconContainer collapsedIcon = new IconContainer(Icons.MOVE_RIGHT, 14, 10, 0.5F, 0.5F, -2, -2);
    protected IconContainer openedIcon = new IconContainer(Icons.MOVE_DOWN, 14, 10, 0.5F, 0.5F, -2, 0);

    /**
     * @param mc
     * @param title
     * @param titleBackground the background color of the title as Supplier to allow changes of the color through configurations.
     * @param collapsed true if it should be collapsed by default, false if it should display its fields.
     */
    public GuiCollapseSection(Minecraft mc, IKey title, Supplier<Integer> titleBackground, boolean collapsed)
    {
        super(mc);

        this.title = Elements.label(title).background(titleBackground);
        this.title.setLeftIconContainer(this.collapsedIcon);
        this.fields = new GuiElement(mc);
        this.fields.flex().relative(this).column(5).stretch().vertical().height(20);

        this.flex().column(5).stretch().vertical();
        super.add(this.title);

        if (!collapsed)
        {
            super.add(this.fields);
            this.title.setLeftIconContainer(this.openedIcon);
        }

        this.collapsed = collapsed;
    }

    public GuiCollapseSection(Minecraft mc, IKey title, Supplier<Integer> titleBackground)
    {
        this(mc, title, titleBackground, false);
    }

    public GuiCollapseSection(Minecraft mc, IKey title)
    {
        this(mc, title, () -> ColorUtils.HALF_BLACK + McLib.primaryColor.get());
    }

    public void setCollapsed(boolean collapsed)
    {
        if (this.collapsed != collapsed)
        {
            this.updateCollapse();
        }
    }

    public boolean isCollapsed()
    {
        return this.collapsed;
    }

    @Deprecated
    public void addField(GuiElement element)
    {
        this.fields.add(element);
    }

    @Deprecated
    public void addFields(GuiElement... element)
    {
        this.fields.add(element);
    }

    @Override
    public void add(IGuiElement... elements)
    {
        this.fields.add(elements);
    }

    @Override
    public void add(IGuiElement element)
    {
        this.fields.add(element);
    }

    public GuiLabel getTitle()
    {
        return this.title;
    }

    protected void updateCollapse()
    {
        if (!this.collapsed)
        {
            this.fields.removeFromParent();
            this.title.setLeftIconContainer(this.collapsedIcon);

            this.collapsed = true;
        }
        else
        {
            super.add(this.fields);
            this.title.setLeftIconContainer(this.openedIcon);

            this.collapsed = false;
        }
    }

    /**
     * Toggle visibility of the field section
     */
    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.title.area.isInside(context))
        {
            this.updateCollapse();
            GuiElement element = this.getRoot();

            if (element != null) element.resize();

            return true;
        }

        return false;
    }
}


==================================================

--- Файл №9 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiConfirmationScreen.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.modals.GuiConfirmModal;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

import java.util.function.Consumer;

public class GuiConfirmationScreen extends GuiBase
{
    private Consumer<Boolean> callback;
    private boolean value;

    public GuiConfirmationScreen(IKey label, Consumer<Boolean> callback)
    {
        super();

        this.callback = callback;

        this.root.add(GuiConfirmModal.createTemplate(Minecraft.getMinecraft(), this.viewport, label, (value) ->
        {
            this.value = value;
            closeScreen();
        }));
    }

    @Override
    public boolean doesGuiPauseGame()
    {
        return false;
    }

    @Override
    protected void closeScreen()
    {
        this.callback.accept(this.value);
        super.closeScreen();
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        this.drawDefaultBackground();

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}


==================================================

--- Файл №10 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiDelegateElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

/**
 * Delegated {@link IGuiElement}
 */
@SideOnly(Side.CLIENT)
public class GuiDelegateElement<T extends GuiElement> extends GuiElement
{
    public T delegate;

    public GuiDelegateElement(Minecraft mc, T element)
    {
        super(mc);
        this.delegate = element;

        if (this.delegate != null)
        {
            this.delegate.parent = this;
        }
    }

    public void setDelegate(T element)
    {
        this.delegate = element;

        if (this.delegate != null)
        {
            this.delegate.parent = this;
        }

        this.resize();
    }

    private void unsupported()
    {
        throw new IllegalStateException("Following method is unsupported by delegate element!");
    }

    @Override
    public List<IGuiElement> getChildren()
    {
        return this.delegate == null ? Collections.emptyList() : Arrays.asList(this.delegate);
    }

    @Override
    public void removeAll()
    {
        this.unsupported();
    }

    @Override
    public void add(IGuiElement element)
    {
        this.unsupported();
    }

    @Override
    public void add(IGuiElement... elements)
    {
        this.unsupported();
    }

    @Override
    public void remove(GuiElement element)
    {
        if (this.delegate != null && this.delegate == element)
        {
            this.delegate.parent = null;
            this.delegate = null;
        }
    }

    @Override
    public boolean isEnabled()
    {
        return this.delegate != null && this.delegate.isEnabled();
    }

    @Override
    public boolean isVisible()
    {
        return this.delegate == null || this.delegate.isVisible();
    }

    @Override
    public void resize()
    {
        /* In case in another GUI */
        if (this.delegate != null && this.delegate.parent != this)
        {
            this.delegate.removeFromParent();
            this.delegate.parent = this;
        }

        if (this.resizer != null)
        {
            this.resizer.apply(this.area);
        }

        if (this.delegate != null)
        {
            this.delegate.resizer = this.resizer;
            this.delegate.flex().link(this.flex());
            this.delegate.resize();
        }

        if (this.resizer != null)
        {
            this.resizer.postApply(this.area);
        }
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        return this.delegate != null && this.delegate.mouseClicked(context);
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        return this.delegate == null ? super.createContextMenu(context) : this.delegate.createContextMenu(context);
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return this.delegate != null && this.delegate.mouseScrolled(context);
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        if (this.delegate != null)
        {
            this.delegate.mouseReleased(context);
        }
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        return this.delegate != null && this.delegate.keyTyped(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.delegate != null)
        {
            this.delegate.draw(context);
        }
    }
}

==================================================

--- Файл №11 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.tooltips.ITooltip;
import mchorse.mclib.client.gui.framework.tooltips.LabelTooltip;
import mchorse.mclib.client.gui.utils.KeybindManager;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.client.gui.utils.resizers.IResizer;
import mchorse.mclib.client.gui.utils.resizers.Flex;
import mchorse.mclib.client.gui.utils.resizers.Margin;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.function.Supplier;

@SideOnly(Side.CLIENT)
public class GuiElement extends Gui implements IGuiElement
{
    /**
     * Area of this element (i.e. position and size) 
     */
    public Area area = new Area();

    /**
     * Element's margin (it's used only by layout resizers)
     */
    public final Margin margin = new Margin();

    /**
     * Resizer of this class
     */
    protected IResizer resizer;

    /**
     * Flex resizer of this class
     */
    protected Flex flex;

    /**
     * Tooltip instance
     */
    public ITooltip tooltip;

    /**
     * Keybind manager
     */
    public KeybindManager keybinds;

    /**
     * Context menu supplier
     */
    public Supplier<GuiContextMenu> contextMenu;

    /**
     * Hide tooltip
     */
    public boolean hideTooltip;

    /**
     * Whether this element should be ignored by post resizers
     */
    public boolean ignored;

    /**
     * Whether this element can be culled if it's out of viewport
     */
    public boolean culled = true;

    /**
     * Whether this element is a container
     */
    protected boolean container;

    /**
     * Parent GUI element
     */
    protected GuiElement parent;

    /**
     * Children elements
     */
    private GuiElements<IGuiElement> children;

    /**
     * Whether this element is enabled (can handle any input) 
     */
    protected boolean enabled = true;

    /**
     * Whether this element is visible 
     */
    protected boolean visible = true;

    /* Useful references */
    protected Minecraft mc;
    protected FontRenderer font;

    /**
     * Initiate GUI element with Minecraft's instance 
     */
    public GuiElement(Minecraft mc)
    {
        this.mc = mc;
        this.font = mc.fontRenderer;
    }

    /* Hierarchy management */

    public GuiBase.GuiRootElement getRoot()
    {
        GuiElement element = this;

        while (element.getParent() != null)
        {
            element = element.getParent();
        }

        return element instanceof GuiBase.GuiRootElement ? (GuiBase.GuiRootElement) element : null;
    }

    public GuiElement getParent()
    {
        return this.parent;
    }

    public boolean hasParent()
    {
        return this.parent != null;
    }

    public boolean isDescendant(GuiElement element)
    {
        if (this == element)
        {
            return false;
        }

        while (element != null)
        {
            if (element.parent == this)
            {
                return true;
            }

            element = element.parent;
        }

        return false;
    }

    public List<IGuiElement> getChildren()
    {
        if (this.children == null)
        {
            return Collections.emptyList();
        }

        return this.children.elements;
    }

    public <T> List<T> getChildren(Class<T> clazz)
    {
        return getChildren(clazz, new ArrayList<T>());
    }

    public <T> List<T> getChildren(Class<T> clazz, List<T> list)
    {
        return getChildren(clazz, list, false);
    }

    public <T> List<T> getChildren(Class<T> clazz, List<T> list, boolean includeItself)
    {
        if (includeItself && clazz.isAssignableFrom(this.getClass()))
        {
            list.add(clazz.cast(this));
        }

        for (IGuiElement element : this.getChildren())
        {
            if (clazz.isAssignableFrom(element.getClass()))
            {
                list.add(clazz.cast(element));
            }

            if (element instanceof GuiElement)
            {
                ((GuiElement) element).getChildren(clazz, list, includeItself);
            }
        }

        return list;
    }

    public void prepend(IGuiElement element)
    {
        if (this.children == null)
        {
            this.children = new GuiElements<IGuiElement>(this);
        }

        this.markChild(element);
        this.children.prepend(element);
    }

    public void add(IGuiElement element)
    {
        if (this.children == null)
        {
            this.children = new GuiElements<IGuiElement>(this);
        }

        this.markChild(element);
        this.children.add(element);
    }

    public void add(IGuiElement... elements)
    {
        if (this.children == null)
        {
            this.children = new GuiElements<IGuiElement>(this);
        }

        for (IGuiElement element : elements)
        {
            this.markChild(element);
            this.children.add(element);
        }
    }

    public void addAfter(IGuiElement target, IGuiElement element)
    {
        if (this.children == null)
        {
            return;
        }

        if (this.children.addAfter(target, element))
        {
            this.markChild(element);
        }
    }

    public void addBefore(IGuiElement target, IGuiElement element)
    {
        if (this.children == null)
        {
            return;
        }

        if (this.children.addBefore(target, element))
        {
            this.markChild(element);
        }
    }

    private void markChild(IGuiElement element)
    {
        if (element instanceof GuiElement)
        {
            GuiElement child = (GuiElement) element;

            child.parent = this;

            if (this.resizer != null)
            {
                this.resizer.add(this, child);
            }
        }
    }

    public void removeAll()
    {
        if (this.children == null)
        {
            return;
        }

        for (IGuiElement element : this.children.elements)
        {
            if (element instanceof GuiElement)
            {
                if (this.resizer != null)
                {
                    this.resizer.remove(this, (GuiElement) element);
                }

                ((GuiElement) element).parent = null;
            }
        }

        this.children.clear();
    }

    public void removeFromParent()
    {
        if (this.hasParent())
        {
            this.parent.remove(this);
        }
    }

    public void remove(GuiElement element)
    {
        if (this.children.elements.remove(element))
        {
            if (this.resizer != null)
            {
                this.resizer.remove(this, element);
            }

            element.parent = null;
        }
    }

    /* Setters */

    public GuiElement removeTooltip()
    {
        this.tooltip = null;

        return this;
    }

    public GuiElement tooltip(ITooltip tooltip)
    {
        this.tooltip = tooltip;

        return this;
    }

    public GuiElement tooltip(IKey label)
    {
        this.tooltip = new LabelTooltip(label, Direction.BOTTOM);

        return this;
    }

    public GuiElement tooltip(IKey label, Direction direction)
    {
        this.tooltip = new LabelTooltip(label, direction);

        return this;
    }

    public GuiElement tooltip(IKey label, int width, Direction direction)
    {
        this.tooltip = new LabelTooltip(label, width, direction);

        return this;
    }

    public GuiElement hideTooltip()
    {
        this.hideTooltip = true;

        return this;
    }

    public GuiElement noCulling()
    {
        this.culled = false;

        return this;
    }

    /* Keybind manager */

    public KeybindManager keys()
    {
        if (this.keybinds == null)
        {
            this.keybinds = new KeybindManager();
        }

        return this.keybinds;
    }

    /* Container stuff */

    public GuiElement markContainer()
    {
        this.container = true;

        return this;
    }

    public GuiElement markIgnored()
    {
        this.ignored = true;

        return this;
    }

    public boolean isContainer()
    {
        return this.container;
    }

    public GuiElement getParentContainer()
    {
        GuiElement element = this.getParent();

        while (element != null && !element.isContainer())
        {
            element = element.getParent();
        }

        return element;
    }

    public GuiElement context(Supplier<GuiContextMenu> supplier)
    {
        this.contextMenu = supplier;

        return this;
    }

    /* Resizer methods */

    /**
     * This method assigns a {@link Flex} to this element and sets it as the main resizer.
     *
     * Flex isn't necessary when you place this element into an element with column, row or
     * grid layouts. Use this to avoid manually calculating the position and scale.
     *
     * @return the {@link Flex} object that is assigned to the main resizer.
     */
    public Flex flex()
    {
        if (this.flex == null)
        {
            this.flex = new Flex(this);

            if (this.resizer == null)
            {
                this.resizer = this.flex;
            }
        }

        return this.flex;
    }

    public void flex(Flex flex)
    {
        if (flex != null)
        {
            this.flex = flex;
        }
    }

    public IResizer resizer()
    {
        return this.resizer;
    }

    public GuiElement resizer(IResizer resizer)
    {
        this.resizer = resizer;

        return this;
    }

    /* Margin */

    public GuiElement margin(int all)
    {
        return this.margin(all, all);
    }

    public GuiElement margin(int horizontal, int vertical)
    {
        return this.margin(horizontal, vertical, horizontal, vertical);
    }

    public GuiElement margin(int left, int top, int right, int bottom)
    {
        this.margin.all(left, top, right, bottom);

        return this;
    }

    public GuiElement marginLeft(int left)
    {
        this.margin.left(left);

        return this;
    }

    public GuiElement marginTop(int top)
    {
        this.margin.top(top);

        return this;
    }

    public GuiElement marginRight(int right)
    {
        this.margin.right(right);

        return this;
    }

    public GuiElement marginBottom(int bottom)
    {
        this.margin.bottom(bottom);

        return this;
    }

    /* Enabled methods */

    @Override
    public boolean isEnabled()
    {
        return this.enabled && this.visible;
    }

    public void setEnabled(boolean enabled)
    {
        this.enabled = enabled;
    }

    @Override
    public boolean isVisible()
    {
        return this.visible;
    }

    public void setVisible(boolean visible)
    {
        this.visible = visible;
    }

    public void toggleVisible()
    {
        this.visible = !this.visible;
    }

    /**
     * Whether element can be seen on the screen
     */
    public boolean canBeSeen()
    {
        if (!this.hasParent() || !this.isVisible())
        {
            return false;
        }

        GuiElement element = this;

        while (true)
        {
            if (!element.isVisible())
            {
                return false;
            }

            GuiElement parent = element.getParent();

            if (parent instanceof GuiDelegateElement && ((GuiDelegateElement) parent).delegate != element)
            {
                return false;
            }

            if (parent == null)
            {
                break;
            }

            element = parent;
        }

        return element instanceof GuiBase.GuiRootElement;
    }

    /* Overriding those methods so it would be much easier to 
     * override only needed methods in subclasses */

    @Override
    public void resize()
    {
        if (this.resizer != null)
        {
            this.resizer.apply(this.area);
        }

        if (this.children != null)
        {
            this.children.resize();
        }

        if (this.resizer != null)
        {
            this.resizer.postApply(this.area);
        }
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (this.children != null && this.children.mouseClicked(context))
        {
            return true;
        }

        if (!context.awaitsRightClick && this.area.isInside(context) && context.mouseButton == 1)
        {
            if (!context.hasContextMenu())
            {
                GuiContextMenu menu = this.createContextMenu(context);

                if (menu != null)
                {
                    context.setContextMenu(menu);

                    return true;
                }
            }
        }

        return false;
    }

    public void clickItself(GuiContext context)
    {
        this.clickItself(context, 0);
    }

    public void clickItself(GuiContext context, int mouseButton)
    {
        if (!this.isEnabled())
        {
            return;
        }

        int mouseX = context.mouseX;
        int mouseY = context.mouseY;
        int button = context.mouseButton;

        context.mouseX = this.area.x + 1;
        context.mouseY = this.area.y + 1;
        context.mouseButton = mouseButton;

        this.mouseClicked(context);

        context.mouseX = mouseX;
        context.mouseY = mouseY;
        context.mouseButton = button;
    }

    /**
     * Create a context menu instance
     *
     * Some subclasses of GuiElement might want to override this method in order to create their
     * own context menus.
     */
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        return this.contextMenu == null ? null : this.contextMenu.get();
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return this.children != null && this.children.mouseScrolled(context);
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        if (this.children != null)
        {
            this.children.mouseReleased(context);
        }
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (this.children != null && this.children.keyTyped(context))
        {
            return true;
        }

        if (this.keybinds != null && this.keybinds.check(context, this.area.isInside(context)))
        {
            return true;
        }

        return false;
    }

    @Override
    public boolean canBeDrawn(Area viewport)
    {
        return !this.culled || viewport.intersects(this.area);
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.keybinds != null && this.isEnabled())
        {
            this.keybinds.add(context, this.area.isInside(context));
        }

        if (this.tooltip != null && this.area.isInside(context))
        {
            context.tooltip.set(context, this);
        }
        else if ((this.hideTooltip || this.container) && this.area.isInside(context))
        {
            context.resetTooltip();
        }

        if (this.children != null)
        {
            this.children.draw(context);
        }
    }

    public void drawTooltip(GuiContext context, Area area)
    {
        context.tooltip.draw(this.tooltip, context);
    }
}

==================================================

--- Файл №12 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiElements.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;

import java.util.ArrayList;
import java.util.List;

/**
 * GUI elements collection
 * 
 * This class is responsible for handling a collection of elements
 */
public class GuiElements<T extends IGuiElement> implements IGuiElement
{
    /**
     * List of elements 
     */
    public List<T> elements = new ArrayList<T>();

    /**
     * Whether this element is enabled (can handle any input) 
     */
    protected boolean enabled = true;

    /**
     * Whether this element is visible 
     */
    protected boolean visible = true;

    /**
     * Parent of this elements collection
     */
    private GuiElement parent;

    public GuiElements(GuiElement parent)
    {
        this.parent = parent;
    }

    public void clear()
    {
        this.elements.clear();
    }

    public void prepend(T element)
    {
        if (element != null)
        {
            this.elements.add(0, element);
        }
    }

    public void add(T element)
    {
        if (element != null)
        {
            this.elements.add(element);
        }
    }

    public boolean addAfter(T target, T element)
    {
        int index = this.elements.indexOf(target);

        if (index != -1 && element != null)
        {
            if (index + 1 >= this.elements.size())
            {
                this.elements.add(element);
            }
            else
            {
                this.elements.add(index + 1, element);
            }

            return true;
        }

        return false;
    }

    public boolean addBefore(T target, T element)
    {
        int index = this.elements.indexOf(target);

        if (index != -1 && element != null)
        {
            this.elements.add(index, element);

            return true;
        }

        return false;
    }

    public void add(T... elements)
    {
        for (T element : elements)
        {
            if (element != null) this.elements.add(element);
        }
    }

    @Override
    public void resize()
    {
        for (T element : this.elements)
        {
            element.resize();
        }
    }

    @Override
    public boolean isEnabled()
    {
        return this.enabled && this.visible;
    }

    public void setEnabled(boolean enabled)
    {
        this.enabled = enabled;
    }

    @Override
    public boolean isVisible()
    {
        return this.visible;
    }

    public void setVisible(boolean visible)
    {
        this.visible = visible;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        for (int i = this.elements.size() - 1; i >= 0; i--)
        {
            T element = this.elements.get(i);

            if (element.isEnabled() && element.mouseClicked(context))
            {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        for (int i = this.elements.size() - 1; i >= 0; i--)
        {
            T element = this.elements.get(i);

            if (element.isEnabled() && element.mouseScrolled(context))
            {
                return true;
            }
        }

        return false;
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        for (int i = this.elements.size() - 1; i >= 0; i--)
        {
            T element = this.elements.get(i);

            if (element.isEnabled())
            {
                element.mouseReleased(context);
            }
        }
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        for (int i = this.elements.size() - 1; i >= 0; i--)
        {
            T element = this.elements.get(i);

            if (element.isEnabled() && element.keyTyped(context))
            {
                return true;
            }
        }

        return false;
    }

    @Override
    public boolean canBeDrawn(Area viewport)
    {
        return true;
    }

    @Override
    public void draw(GuiContext context)
    {
        for (T element : this.elements)
        {
            if (element.isVisible() && element.canBeDrawn(context.getViewport()))
            {
                element.draw(context);
            }
        }
    }
}

==================================================

--- Файл №13 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiModelRenderer.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.utils.DummyEntity;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.block.state.IBlockState;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.BlockRendererDispatcher;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.texture.TextureMap;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.Blocks;

import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;
import org.lwjgl.util.glu.Project;

import javax.vecmath.Matrix3d;
import javax.vecmath.Matrix4d;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;
import java.nio.ByteBuffer;
import java.util.function.Consumer;

/**
 * Model renderer GUI element
 * 
 * This base class can be used for full screen model viewer. 
 */
public abstract class GuiModelRenderer extends GuiElement
{
    private static boolean rendering;
    private static Vector3d vec = new Vector3d();
    private static Matrix3d mat = new Matrix3d();
    protected Matrix4d cameraMatrix = new Matrix4d();

    protected EntityLivingBase entity;
    protected IBlockState block = Blocks.GRASS.getDefaultState();

    protected int timer;
    protected boolean dragging;
    protected boolean position;
    protected Vector3f temp = new Vector3f();

    public float fov = 70.0F;
    public float scale;
    public float yaw;
    public float pitch;
    public Vector3f pos = new Vector3f();
    public boolean flight;

    public boolean hideModel;
    public boolean fullScreen;

    public Consumer<GuiContext> beforeRender;
    public Consumer<GuiContext> afterRender;

    public boolean customEntity;
    public float entityPitch;
    public float entityYawHead;
    public float entityYawBody;
    public int entityTicksExisted;

    protected float lastX;
    protected float lastY;

    /* Picking */
    protected boolean tryPicking;
    protected Consumer<String> callback;

    private long tick;

    public static boolean isRendering()
    {
        return rendering;
    }

    public static void disableRenderingFlag()
    {
        rendering = false;
    }

    public GuiModelRenderer(Minecraft mc)
    {
        super(mc);

        this.entity = new DummyEntity(mc.world);
        this.entity.rotationYaw = this.entity.prevRotationYaw = 0.0F;
        this.entity.rotationPitch = this.entity.prevRotationPitch = 0.0F;
        this.entity.rotationYawHead = this.entity.prevRotationYawHead = 0.0F;
        this.entity.renderYawOffset = this.entity.prevRenderYawOffset = 0.0F;
        this.entity.onGround = true;
        this.reset();
    }

    public Matrix4d getCameraMatrix()
    {
        return new Matrix4d(this.cameraMatrix);
    }

    public GuiModelRenderer picker(Consumer<String> callback)
    {
        this.callback = callback;

        return this;
    }

    public void setRotation(float yaw, float pitch)
    {
        this.yaw = yaw;
        this.pitch = pitch;
    }

    public void setPosition(float x, float y, float z)
    {
        this.pos.set(x, y, z);
    }

    public void setScale(float scale)
    {
        this.scale = scale;
    }

    public EntityLivingBase getEntity()
    {
        return this.entity;
    }

    public void reset()
    {
        this.yaw = 0;
        this.pitch = 0;
        this.scale = 2;
        this.pos = new Vector3f(0, 1, 0);

        this.hideModel = false;
        this.fullScreen = false;

        this.beforeRender = null;
        this.afterRender = null;

        this.customEntity = false;
        this.entityPitch = 0F;
        this.entityYawHead = 0F;
        this.entityYawBody = 0F;
        this.entityTicksExisted = 0;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.area.isInside(context) && (context.mouseButton == 0 || context.mouseButton == 2))
        {
            this.dragging = true;
            this.flight = false;
            this.position = GuiScreen.isShiftKeyDown() || context.mouseButton == 2;
            this.lastX = context.mouseX;
            this.lastY = context.mouseY;

            if (GuiScreen.isCtrlKeyDown())
            {
                this.tryPicking = true;
                this.dragging = false;
            }
        }

        return this.area.isInside(context);
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        if (super.mouseScrolled(context))
        {
            return true;
        }

        if (this.area.isInside(context))
        {
            this.scale += Math.copySign(this.getZoomFactor(), context.mouseWheel);
            this.scale = MathUtils.clamp(this.scale, 0, 100);
        }

        return this.area.isInside(context);
    }

    protected float getZoomFactor()
    {
        if (this.scale < 1) return 0.05F;
        if (this.scale > 30) return 5F;
        if (this.scale > 10) return 1F;
        if (this.scale > 3) return 0.5F;

        return 0.1F;
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        this.dragging = false;
        this.tryPicking = false;

        if (this.flight)
        {
            this.flight = false;

            vec.set(0, 0, -this.scale);
            this.rotateVector(vec);

            this.pos.x -= vec.x;
            this.pos.y -= vec.y;
            this.pos.z -= vec.z;
        }

        super.mouseReleased(context);
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (this.dragging && !this.position)
        {
            if (context.keyCode == Keyboard.KEY_W || context.keyCode == Keyboard.KEY_S || context.keyCode == Keyboard.KEY_A ||
                    context.keyCode == Keyboard.KEY_D || context.keyCode == Keyboard.KEY_LSHIFT || context.keyCode == Keyboard.KEY_SPACE)
            {
                if (!this.flight)
                {
                    this.flight = true;

                    vec.set(0, 0, -this.scale);
                    this.rotateVector(vec);

                    this.pos.x += vec.x;
                    this.pos.y += vec.y;
                    this.pos.z += vec.z;
                }

                return true;
            }
        }

        return super.keyTyped(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.updateLogic(context);

        rendering = true;

        GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);
        this.drawModel(context);
        GuiDraw.unscissor(context);

        rendering = false;

        super.draw(context);

        this.updatePosition(context);
    }

    private void updateLogic(GuiContext context)
    {
        long i = context.tick - this.tick;

        if (i > 10)
        {
            i = 10;
        }

        while (i > 0)
        {
            this.update();
            i --;
        }

        this.tick = context.tick;
    }

    /**
     * Update logic
     */
    protected void update()
    {
        this.timer = this.mc.player != null ? this.mc.player.ticksExisted : this.timer + 1;
        this.entity.ticksExisted = this.timer;
    }

    /**
     * Draw currently edited model
     */
    private void drawModel(GuiContext context)
    {
        this.setupViewport(context);
        this.setupPosition(context);
        this.setupEntity();

        /* Enable rendering states */
        RenderHelper.enableStandardItemLighting();
        GlStateManager.enableAlpha();
        GlStateManager.enableRescaleNormal();
        GlStateManager.enableDepth();
        GlStateManager.disableCull();
        GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);

        /* Setup transformations */
        GlStateManager.pushMatrix();
        GlStateManager.loadIdentity();
        GlStateManager.rotate(this.pitch, 1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(this.yaw, 0.0F, 1.0F, 0.0F);
        GlStateManager.translate(-this.temp.x, -this.temp.y, -this.temp.z);
        this.cameraMatrix = MatrixUtils.readModelViewDouble();

        /* Custom render settings */
        if (this.hideModel)
        {
            GlStateManager.depthFunc(GL11.GL_NEVER);
        }

        /* Drawing begins */
        this.drawGround();

        if (this.beforeRender != null)
        {
            this.beforeRender.accept(context);
        }

        this.drawUserModel(context);

        if (this.afterRender != null)
        {
            this.afterRender.accept(context);
        }

        /* Reset custom settings */
        if (this.hideModel)
        {
            GlStateManager.depthFunc(GL11.GL_LEQUAL);
        }

        GlStateManager.popMatrix();

        /* Disable rendering states */
        GlStateManager.enableCull();
        GlStateManager.disableDepth();
        GlStateManager.disableRescaleNormal();
        GlStateManager.disableAlpha();
        RenderHelper.disableStandardItemLighting();

        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);

        /* Return back to orthographic projection */
        GlStateManager.viewport(0, 0, this.mc.displayWidth, this.mc.displayHeight);
        GlStateManager.matrixMode(GL11.GL_PROJECTION);
        GlStateManager.loadIdentity();
        GlStateManager.ortho(0.0D, context.screen.width, context.screen.height, 0.0D, 1000.0D, 3000000.0D);
        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
    }

    protected void updatePosition(GuiContext context)
    {
        int mouseX = context.mouseX;
        int mouseY = context.mouseY;

        if (this.dragging)
        {
            if (this.position)
            {
                float x = this.pos.x;
                float y = this.pos.y;
                float z = this.pos.z;

                double xx = -(this.lastX - mouseX) / 60F;
                double yy = -(this.lastY - mouseY) / 60F;
                float factor = this.getZoomFactor();

                xx *= factor / 0.1F;
                yy *= factor / 0.1F;

                if (xx != 0 || yy != 0)
                {
                    vec.set(xx, yy, 0);
                    this.rotateVector(vec);

                    x += vec.x;
                    y += vec.y;
                    z += vec.z;

                    this.pos.set(x, y, z);
                }
            }
            else
            {
                this.yaw -= this.lastX - mouseX;
                this.pitch -= this.lastY - mouseY;
            }

            this.lastX = mouseX;
            this.lastY = mouseY;
        }

        if (this.dragging && !this.position)
        {
            float multiplier = 4F / Math.max(Minecraft.getDebugFPS(), 1);

            if (Keyboard.isKeyDown(Keyboard.KEY_LCONTROL))
            {
                multiplier *= 5;
            }
            else if (Keyboard.isKeyDown(Keyboard.KEY_LMENU))
            {
                multiplier *= 0.2F;
            }

            vec.set(0, 0, 0);

            if (Keyboard.isKeyDown(Keyboard.KEY_W))
            {
                vec.z++;
            }

            if (Keyboard.isKeyDown(Keyboard.KEY_S))
            {
                vec.z--;
            }

            if (Keyboard.isKeyDown(Keyboard.KEY_A))
            {
                vec.x++;
            }

            if (Keyboard.isKeyDown(Keyboard.KEY_D))
            {
                vec.x--;
            }

            mat.rotY((180 - this.yaw) / 180 * (float) Math.PI);
            mat.transform(vec);

            if (Keyboard.isKeyDown(Keyboard.KEY_SPACE))
            {
                vec.y++;
            }

            if (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))
            {
                vec.y--;
            }

            if (vec.length() > 0)
            {
                vec.normalize();
            }

            this.pos.x += vec.x * multiplier;
            this.pos.y += vec.y * multiplier;
            this.pos.z += vec.z * multiplier;
        }
    }

    protected void setupPosition(GuiContext context)
    {
        this.temp = new Vector3f(this.pos);

        if (this.flight)
        {
            return;
        }

        vec.set(0, 0, -this.scale);
        this.rotateVector(vec);

        this.temp.x += vec.x;
        this.temp.y += vec.y;
        this.temp.z += vec.z;
    }

    private void rotateVector(Vector3d vec)
    {
        mat.rotX(this.pitch / 180 * (float) Math.PI);
        mat.transform(vec);
        mat.rotY((180 - this.yaw) / 180 * (float) Math.PI);
        mat.transform(vec);
    }

    protected void setupViewport(GuiContext context)
    {
        /* Changing projection mode to perspective. In order for this to
         * work, depth buffer must also be cleared. Thanks to Gegy for
         * pointing this out (depth buffer)! */
        GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);

        float rx = (float) Math.ceil(mc.displayWidth / (double) context.screen.width);
        float ry = (float) Math.ceil(mc.displayHeight / (double) context.screen.height);

        int vx = this.fullScreen ? 0 : (int) (this.area.x * rx);
        int vy = this.fullScreen ? 0 : (int) (this.mc.displayHeight - (this.area.y + this.area.h) * ry);
        int vw = this.fullScreen ? this.mc.displayWidth : (int) (this.area.w * rx);
        int vh = this.fullScreen ? this.mc.displayHeight : (int) (this.area.h * ry);

        GlStateManager.viewport(vx, vy, vw, vh);
        GlStateManager.matrixMode(GL11.GL_PROJECTION);
        GlStateManager.loadIdentity();
        Project.gluPerspective(this.fov, (float) vw / (float) vh, 0.05F, 1000);
        GlStateManager.matrixMode(GL11.GL_MODELVIEW);
    }

    protected void setupEntity()
    {
        if (this.customEntity)
        {
            this.entity.prevRotationPitch = this.entity.rotationPitch = this.entityPitch;
            this.entity.prevRotationYawHead = this.entity.rotationYawHead = this.entityYawHead;
            this.entity.prevRenderYawOffset = this.entity.renderYawOffset = this.entityYawBody;
            this.entity.ticksExisted = this.entityTicksExisted;
        }
        else
        {
            this.entity.prevRotationPitch = this.entity.rotationPitch = 0;
            this.entity.prevRotationYawHead = this.entity.rotationYawHead = 0;
            this.entity.prevRenderYawOffset = this.entity.renderYawOffset = 0;
        }
    }

    /**
     * Draw your model here 
     */
    protected abstract void drawUserModel(GuiContext context);

    /**
     * IMPORTANT: this method should be called manually by the subclass right
     * after rendering the model
     */
    protected void tryPicking(GuiContext context)
    {
        if (!this.tryPicking)
        {
            return;
        }

        float rx = (float) Math.ceil(mc.displayWidth / (double) context.screen.width);
        float ry = (float) Math.ceil(mc.displayHeight / (double) context.screen.height);

        int x = (int) (context.mouseX * rx);
        int y = (int) (this.mc.displayHeight - (context.mouseY) * ry);

        GL11.glClearStencil(0);
        GL11.glClear(GL11.GL_STENCIL_BUFFER_BIT);

        GL11.glEnable(GL11.GL_STENCIL_TEST);
        GL11.glStencilOp(GL11.GL_KEEP, GL11.GL_KEEP, GL11.GL_REPLACE);

        if (this.hideModel)
        {
            GlStateManager.depthFunc(GL11.GL_LEQUAL);
        }

        GL11.glColorMask(false, false, false, false);
        this.drawForStencil(context);
        GL11.glColorMask(true, true, true, true);

        if (this.hideModel)
        {
            GlStateManager.depthFunc(GL11.GL_NEVER);
        }

        ByteBuffer buffer = ByteBuffer.allocateDirect(1);
        GL11.glReadPixels(x, y, 1, 1, GL11.GL_STENCIL_INDEX, GL11.GL_UNSIGNED_BYTE, buffer);

        buffer.rewind();

        if (this.callback != null)
        {
            int value = buffer.get();

            if (value > 0)
            {
                this.callback.accept(this.getStencilValue(value));
            }
        }

        this.tryPicking = false;
    }

    /**
     * Here you should draw your own things into stencil
     */
    protected void drawForStencil(GuiContext context)
    {}

    protected String getStencilValue(int value)
    {
        return null;
    }

    /**
     * Render block of grass under the model (which signify where 
     * located the ground below the model) 
     */
    protected void drawGround()
    {
        if (McLib.enableGridRendering.get())
        {
            Tessellator tessellator = Tessellator.getInstance();
            BufferBuilder buffer = tessellator.getBuffer();

            GL11.glLineWidth(3);
            GlStateManager.disableTexture2D();
            GlStateManager.enableAlpha();
            GlStateManager.enableBlend();
            GlStateManager.disableLighting();
            buffer.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

            for (int x = 0; x <= 10; x ++)
            {
                if (x == 0)
                {
                    buffer.pos(x - 5, 0, -5).color(0F, 0F, 1F, 0.75F).endVertex();
                    buffer.pos(x - 5, 0, 5).color(0F, 0F, 1F, 0.75F).endVertex();
                }
                else
                {
                    buffer.pos(x - 5, 0, -5).color(0.25F, 0.25F, 0.25F, 0.75F).endVertex();
                    buffer.pos(x - 5, 0, 5).color(0.25F, 0.25F, 0.25F, 0.75F).endVertex();
                }
            }

            for (int x = 0; x <= 10; x ++)
            {
                if (x == 10)
                {
                    buffer.pos(-5, 0, x - 5).color(1F, 0F, 0F, 0.75F).endVertex();
                    buffer.pos(5, 0, x - 5).color(1F, 0F, 0F, 0.75F).endVertex();
                }
                else
                {
                    buffer.pos(-5, 0, x - 5).color(0.25F, 0.25F, 0.25F, 0.75F).endVertex();
                    buffer.pos(5, 0, x - 5).color(0.25F, 0.25F, 0.25F, 0.75F).endVertex();
                }
            }

            tessellator.draw();

            GlStateManager.enableLighting();
            GlStateManager.enableTexture2D();
        }
        else
        {
            BlockRendererDispatcher renderer = this.mc.getBlockRendererDispatcher();

            this.mc.renderEngine.bindTexture(TextureMap.LOCATION_BLOCKS_TEXTURE);

            GlStateManager.pushMatrix();
            GlStateManager.translate(0, -0.5F, 0);
            GlStateManager.rotate(-90.0F, 0.0F, 1.0F, 0.0F);
            GlStateManager.translate(-0.5F, -0.5F, 0.5F);
            renderer.renderBlockBrightness(this.block, 1.0F);
            GlStateManager.translate(0.0F, 0.0F, 1.0F);
            GlStateManager.popMatrix();
        }
    }
}

==================================================

--- Файл №14 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiPanelBase.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDrawable;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.Keybind;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.client.gui.utils.resizers.Flex.Measure;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;

import java.util.ArrayList;
import java.util.List;

/**
 * Panel base GUI
 * 
 * With this base class, you can add multi panel elements which could be 
 * switched between using buttons.
 */
public class GuiPanelBase<T extends GuiElement> extends GuiElement
{
    public GuiDelegateElement<T> view;
    public GuiElements<GuiIconElement> buttons;
    public List<T> panels = new ArrayList<T>();
    public Direction direction;

    public GuiPanelBase(Minecraft mc)
    {
        this(mc, Direction.BOTTOM);
    }

    public GuiPanelBase(Minecraft mc, Direction direction)
    {
        super(mc);

        this.direction = direction == null ? Direction.BOTTOM : direction;
        this.view = new GuiDelegateElement<T>(mc, null);
        this.view.flex().relative(this).w(1F).h(1F, -20);

        if (this.direction == Direction.TOP)
        {
            this.view.flex().y(20);
        }
        else if (this.direction == Direction.LEFT)
        {
            this.view.flex().x(20).w(1, -20).h(1, 0);
        }
        else if (this.direction == Direction.RIGHT)
        {
            this.view.flex().w(1, -20).h(1, 0);
        }

        this.buttons = new GuiElements<GuiIconElement>(this);
        this.add(this.view, new GuiDrawable(this::drawOverlay), this.buttons);
    }

    public GuiIconElement getButton(T panel)
    {
        int index = this.panels.indexOf(panel);

        return index < 0 ? null : this.buttons.elements.get(index);
    }

    /**
     * Register a panel with given texture and tooltip 
     */
    public GuiIconElement registerPanel(T panel, IKey tooltip, Icon icon)
    {
        GuiIconElement button = new GuiIconElement(this.mc, icon, (b) -> this.setPanel(panel));

        if (tooltip != null && !tooltip.get().isEmpty())
        {
            button.tooltip(tooltip, this.direction.opposite());
        }

        panel.markContainer();
        this.setupButtonResizer(button);
        this.panels.add(panel);
        this.buttons.add(button);

        return button;
    }

    public Keybind registerKeybind(GuiIconElement element, IKey label, int key)
    {
        return this.keys().register(label, key, () -> element.clickItself(GuiBase.getCurrent()));
    }

    /**
     * Here subclasses can override the logic for how the buttons should 
     * be setup 
     */
    protected void setupButtonResizer(GuiIconElement button)
    {
        if (this.buttons.elements.isEmpty())
        {
            if (this.direction.isHorizontal())
            {
                button.flex().relative(this).set(2, 2, 16, 16);

                if (this.direction == Direction.RIGHT)
                {
                    button.flex().x(1, -18);
                }
            }
            else
            {
                boolean bottom = this.direction == Direction.BOTTOM;

                button.flex().relative(this).set(0, 0, 16, 16).x(1, -18).y(bottom ? 1 : 0, bottom ? -18 : 2);
            }
        }
        else
        {
            GuiIconElement last = this.buttons.elements.get(this.buttons.elements.size() - 1);

            int x = this.direction.isVertical() ? -20 : 0;
            int y = this.direction.isHorizontal() ? 20 : 0;

            button.flex().relative(last).set(x, y, 16, 16);
        }
    }

    /**
     * Switch current panel to given one
     */
    public void setPanel(T panel)
    {
        this.view.setDelegate(panel);
    }

    protected void drawOverlay(GuiContext context)
    {
        if (this.direction == Direction.TOP)
        {
            this.drawBackground(context, this.area.x, this.area.y, this.area.w, 20);
        }
        else if (this.direction == Direction.BOTTOM)
        {
            this.drawBackground(context, this.area.x, this.area.ey() - 20, this.area.w, 20);
        }
        else if (this.direction == Direction.LEFT)
        {
            this.drawBackground(context, this.area.x, this.area.y, 20, this.area.h);
        }
        else
        {
            this.drawBackground(context, this.area.ex() - 20, this.area.y, 20, this.area.h);
        }

        for (int i = 0, c = this.panels.size(); i < c; i++)
        {
            if (this.view.delegate == this.panels.get(i))
            {
                Area area = this.buttons.elements.get(i).area;

                Gui.drawRect(area.x - 2, area.y - 2, area.ex() + 2, area.ey() + 2, 0xaa000000 + McLib.primaryColor.get());
            }
        }
    }

    protected void drawBackground(GuiContext context, int x, int y, int w, int h)
    {}
}

==================================================

--- Файл №15 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\GuiScrollElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.elements.utils.GuiViewportStack;
import mchorse.mclib.client.gui.framework.elements.utils.IViewportStack;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;

/**
 * Scroll area GUI class
 * 
 * This bad boy allows to scroll stuff
 */
public class GuiScrollElement extends GuiElement implements IViewport
{
    public ScrollArea scroll;

    public GuiScrollElement(Minecraft mc)
    {
        this(mc, ScrollDirection.VERTICAL);
    }

    public GuiScrollElement(Minecraft mc, ScrollDirection direction)
    {
        super(mc);

        this.area = this.scroll = new ScrollArea(0);
        this.scroll.direction = direction;
        this.scroll.scrollSpeed = 20;
    }

    public GuiScrollElement cancelScrollEdge()
    {
        this.scroll.cancelScrollEdge = true;

        return this;
    }

    @Override
    public void apply(IViewportStack stack)
    {
        stack.pushViewport(this.area);

        if (this.scroll.direction == ScrollDirection.VERTICAL)
        {
            stack.shiftY(this.scroll.scroll);
        }
        else
        {
            stack.shiftX(this.scroll.scroll);
        }
    }

    @Override
    public void unapply(IViewportStack stack)
    {
        if (this.scroll.direction == ScrollDirection.VERTICAL)
        {
            stack.shiftY(-this.scroll.scroll);
        }
        else
        {
            stack.shiftX(-this.scroll.scroll);
        }

        stack.popViewport();
    }

    @Override
    public void resize()
    {
        super.resize();

        this.scroll.clamp();
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        this.apply(context);
        boolean result = super.mouseClicked(context);
        this.unapply(context);

        if (!this.area.isInside(context))
        {
            if (context.isFocused() && this.isDescendant((GuiElement) context.activeElement))
            {
                context.unfocus();
            }

            return false;
        }

        if (this.scroll.mouseClicked(context))
        {
            return true;
        }

        return result;
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        if (!this.area.isInside(context))
        {
            if (context.isFocused() && this.isDescendant((GuiElement) context.activeElement))
            {
                context.unfocus();
            }

            return false;
        }

        this.apply(context);
        boolean result = super.mouseScrolled(context);
        this.unapply(context);

        if (result)
        {
            return true;
        }

        return this.scroll.mouseScroll(context);
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        this.scroll.mouseReleased(context);

        this.apply(context);
        super.mouseReleased(context);
        this.unapply(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        GuiElement lastTooltip = context.tooltip.element;

        this.scroll.drag(context.mouseX, context.mouseY);

        GuiDraw.scissor(this.scroll.x, this.scroll.y, this.scroll.w, this.scroll.h, context);

        GlStateManager.pushMatrix();

        /* Translate the contents using OpenGL (scroll) */
        if (this.scroll.direction == ScrollDirection.VERTICAL)
        {
            GlStateManager.translate(0, -this.scroll.scroll, 0);
        }
        else
        {
            GlStateManager.translate(-this.scroll.scroll, 0, 0);
        }

        this.apply(context);
        this.preDraw(context);

        super.draw(context);

        this.postDraw(context);
        this.unapply(context);

        GlStateManager.popMatrix();

        this.scroll.drawScrollbar();

        GuiDraw.unscissor(context);

        /* Clear tooltip in case if it was set outside of scroll area within the scroll */
        if (!this.area.isInside(context) && context.tooltip.element != lastTooltip)
        {
            context.tooltip.set(context, null);
        }
    }

    protected void preDraw(GuiContext context)
    {}

    protected void postDraw(GuiContext context)
    {}
}

==================================================

--- Файл №16 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\IFocusedGuiElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;

public interface IFocusedGuiElement
{
    public boolean isFocused();

    public void focus(GuiContext context);

    public void unfocus(GuiContext context);

    public void selectAll(GuiContext context);

    public void unselect(GuiContext context);
}

==================================================

--- Файл №17 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\IGuiElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public interface IGuiElement
{
    /**
     * Should be called when position has to be recalculated
     */
    public void resize();

    /**
     * Whether this element is enabled (and can accept any input) 
     */
    public boolean isEnabled();

    /**
     * Whether this element is visible
     */
    public boolean isVisible();

    /**
     * Mouse was clicked
     */
    public boolean mouseClicked(GuiContext context);

    /**
     * Mouse wheel was scrolled
     */
    public boolean mouseScrolled(GuiContext context);

    /**
     * Mouse was released
     */
    public void mouseReleased(GuiContext context);

    /**
     * Key was typed
     */
    public boolean keyTyped(GuiContext context);

    /**
     * Determines whether this element can be drawn on the screen
     */
    public boolean canBeDrawn(Area viewport);

    /**
     * Draw its components on the screen
     */
    public void draw(GuiContext context);
}

==================================================

--- Файл №18 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\IViewport.java
--------------------
package mchorse.mclib.client.gui.framework.elements;

import mchorse.mclib.client.gui.framework.elements.utils.IViewportStack;

public interface IViewport
{
    public void apply(IViewportStack stack);

    public void unapply(IViewportStack stack);
}

==================================================

--- Файл №19 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\buttons\GuiButtonElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.buttons;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.elements.utils.ITextColoring;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;

import java.util.function.Consumer;

public class GuiButtonElement extends GuiClickElement<GuiButtonElement> implements ITextColoring
{
    public IKey label;

    public int textColor = 0xffffff;
    public boolean textShadow = true;

    public boolean custom;
    public int customColor;
    public boolean background = true;

    public GuiButtonElement(Minecraft mc, IKey label, Consumer<GuiButtonElement> callback)
    {
        super(mc, callback);

        this.label = label;
        this.flex().h(20);
    }

    public GuiButtonElement color(int color)
    {
        this.custom = true;
        this.customColor = color & 0xffffff;

        return this;
    }

    public GuiButtonElement textColor(int color, boolean shadow)
    {
        this.textColor = color;
        this.textShadow = shadow;

        return this;
    }

    public GuiButtonElement background(boolean background)
    {
        this.background = background;

        return this;
    }

    @Override
    public void setColor(int color, boolean shadow)
    {
        this.textColor = color;
        this.textShadow = shadow;
    }

    @Override
    protected GuiButtonElement get()
    {
        return this;
    }

    @Override
    protected void drawSkin(GuiContext context)
    {
        int color = 0xff000000 + (this.custom ? this.customColor : McLib.primaryColor.get());

        if (this.hover)
        {
            color = ColorUtils.multiplyColor(color, 0.85F);
        }

        if (this.background)
        {
            GuiDraw.drawBorder(this.area, color);
        }

        String label = this.label.get();
        int x = this.area.mx(this.font.getStringWidth(label));
        int y = this.area.my(this.font.FONT_HEIGHT - 1);

        this.font.drawString(label, x, y, ColorUtils.multiplyColor(this.textColor, this.hover ? 0.9F : 1F), this.textShadow);

        GuiDraw.drawLockedArea(this);
    }
}

==================================================

--- Файл №20 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\buttons\GuiCirculateElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.buttons;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Consumer;

public class GuiCirculateElement extends GuiClickElement<GuiCirculateElement>
{
    public boolean custom;
    public int customColor;

    protected List<IKey> labels = new ArrayList<IKey>();
    protected Set<Integer> disabled = new HashSet<Integer>();
    protected int value = 0;

    public GuiCirculateElement(Minecraft mc, Consumer<GuiCirculateElement> callback)
    {
        super(mc, callback);

        this.flex().h(20);
    }

    public GuiCirculateElement color(int color)
    {
        this.custom = true;
        this.customColor = color & 0xffffff;

        return this;
    }

    public List<IKey> getLabels()
    {
        return this.labels;
    }

    public void addLabel(IKey label)
    {
        this.labels.add(label);
    }

    public void disable(int value)
    {
        if (this.disabled.size() < this.labels.size())
        {
            this.disabled.add(value);
        }
    }

    public int getValue()
    {
        return this.value;
    }

    public String getLabel()
    {
        return this.labels.get(this.value).get();
    }

    public void setValue(int value)
    {
        this.setValue(value, 1);
    }

    public void setValue(int value, int direction)
    {
        this.value = value;

        if (this.disabled.contains(value))
        {
            this.setValue(value + direction, direction);

            return;
        }

        if (this.value > this.labels.size() - 1)
        {
            this.value = 0;
        }

        if (this.value < 0)
        {
            this.value = this.labels.size() - 1;
        }
    }

    @Override
    protected boolean isAllowed(int mouseButton)
    {
        return mouseButton == 0 || mouseButton == 1;
    }

    @Override
    protected void click(int mouseButton)
    {
        int direction = mouseButton == 0 ? 1 : -1;

        this.setValue(this.value + direction, direction);

        super.click(mouseButton);
    }

    @Override
    protected GuiCirculateElement get()
    {
        return this;
    }

    @Override
    protected void drawSkin(GuiContext context)
    {
        int color = 0xff000000 + (this.custom ? this.customColor : McLib.primaryColor.get());

        if (this.hover)
        {
            color = ColorUtils.multiplyColor(color, 0.85F);
        }

        GuiDraw.drawBorder(this.area, color);

        String label = this.getLabel();
        int x = this.area.mx(this.font.getStringWidth(label));
        int y = this.area.my(this.font.FONT_HEIGHT - 1);

        this.font.drawStringWithShadow(label, x, y, this.hover ? 16777120 : 0xffffff);

        GuiDraw.drawLockedArea(this);
    }
}


==================================================

--- Файл №21 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\buttons\GuiClickElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.buttons;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.GuiUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.audio.PositionedSoundRecord;
import net.minecraft.init.SoundEvents;

import java.util.function.Consumer;

public abstract class GuiClickElement<T> extends GuiElement
{
    public Consumer<T> callback;

    protected boolean hover;
    protected boolean pressed;

    public GuiClickElement(Minecraft mc, Consumer<T> callback)
    {
        super(mc);

        this.callback = callback;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (context.mouseButton == 1 && context.awaitsRightClick)
        {
            return false;
        }

        if (this.isAllowed(context.mouseButton) && this.area.isInside(context))
        {
            this.pressed = true;
            GuiUtils.playClick();
            this.click(context.mouseButton);

            return true;
        }

        return false;
    }

    protected boolean isAllowed(int mouseButton)
    {
        return mouseButton == 0;
    }

    protected void click(int mouseButton)
    {
        if (this.callback != null)
        {
            this.callback.accept(this.get());
        }
    }

    protected abstract T get();

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);
        this.pressed = false;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.hover = this.area.isInside(context);

        this.drawSkin(context);
        super.draw(context);
    }

    protected abstract void drawSkin(GuiContext context);
}

==================================================

--- Файл №22 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\buttons\GuiIconElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.buttons;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;

import java.util.function.Consumer;

public class GuiIconElement extends GuiClickElement<GuiIconElement>
{
    public Icon icon;
    public int iconColor = 0xffffffff;
    public Icon hoverIcon;
    public int hoverColor = 0xffaaaaaa;

    public int disabledColor = 0x80404040;

    public GuiIconElement(Minecraft mc, Icon icon, Consumer<GuiIconElement> callback)
    {
        super(mc, callback);

        this.icon = icon;
        this.hoverIcon = icon;
        this.flex().wh(20, 20);
    }

    public GuiIconElement both(Icon icon)
    {
        this.icon = this.hoverIcon = icon;

        return this;
    }

    public GuiIconElement icon(Icon icon)
    {
        this.icon = icon;

        return this;
    }

    public GuiIconElement hovered(Icon icon)
    {
        this.hoverIcon = icon;

        return this;
    }

    public GuiIconElement iconColor(int color)
    {
        this.iconColor = color;

        return this;
    }

    public GuiIconElement hoverColor(int color)
    {
        this.hoverColor = color;

        return this;
    }

    public GuiIconElement disabledColor(int color)
    {
        this.disabledColor = color;

        return this;
    }

    @Override
    protected GuiIconElement get()
    {
        return this;
    }

    @Override
    protected void drawSkin(GuiContext context)
    {
        Icon icon = this.hover ? this.hoverIcon : this.icon;
        int color = this.hover ? this.hoverColor : this.iconColor;

        if (this.isEnabled())
        {
            ColorUtils.bindColor(color);
            icon.render(this.area.mx(), this.area.my(), 0.5F, 0.5F);
        }
        else
        {
            ColorUtils.bindColor(this.disabledColor);
            icon.render(this.area.mx(), this.area.my(), 0.5F, 0.5F);
        }
    }
}

==================================================

--- Файл №23 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\buttons\GuiSlotElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.buttons;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.elements.utils.GuiInventoryElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketDropItem;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.util.ResourceLocation;

import java.util.function.Consumer;

public class GuiSlotElement extends GuiClickElement<ItemStack>
{
    public static final ResourceLocation SHIELD = new ResourceLocation("minecraft:textures/items/empty_armor_slot_shield.png");
    public static final ResourceLocation BOOTS = new ResourceLocation("minecraft:textures/items/empty_armor_slot_boots.png");
    public static final ResourceLocation LEGGINGS = new ResourceLocation("minecraft:textures/items/empty_armor_slot_leggings.png");
    public static final ResourceLocation CHESTPLATE = new ResourceLocation("minecraft:textures/items/empty_armor_slot_chestplate.png");
    public static final ResourceLocation HELMET = new ResourceLocation("minecraft:textures/items/empty_armor_slot_helmet.png");

    public GuiInventoryElement inventory;
    public final int slot;

    private ItemStack stack = ItemStack.EMPTY;

    public boolean drawDisabled = true;
    public int lastSlot;

    public GuiSlotElement(Minecraft mc, int slot, Consumer<ItemStack> callback)
    {
        super(mc, callback);

        this.slot = slot;
        this.inventory = new GuiInventoryElement(mc, this);

        this.flex().wh(24, 24);
    }

    public ItemStack getStack()
    {
        return this.stack;
    }

    public void setStack(ItemStack stack)
    {
        this.lastSlot = -1;
        this.stack = stack.copy();

        if (this.inventory.hasParent())
        {
            this.inventory.updateInventory();
        }
    }

    public void acceptStack(ItemStack stack, int slot)
    {
        this.lastSlot = slot;
        this.stack = stack.copy();

        if (this.callback != null)
        {
            this.callback.accept(stack);
        }
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        if (this.contextMenu == null)
        {
            return this.createDefaultSlotContextMenu();
        }

        return super.createContextMenu(context);
    }

    public GuiSimpleContextMenu createDefaultSlotContextMenu()
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(this.mc).action(Icons.COPY, IKey.lang("mclib.gui.item_slot.context.copy"), this::copyNBT);

        try
        {
            ItemStack stack = new ItemStack(JsonToNBT.getTagFromJson(GuiScreen.getClipboardString()));

            if (!stack.isEmpty())
            {
                menu.action(Icons.PASTE, IKey.lang("mclib.gui.item_slot.context.paste"), () -> this.pasteItem(stack));
            }
        }
        catch (Exception e)
        {}

        return menu
            .action(Icons.DOWNLOAD, IKey.lang("mclib.gui.item_slot.context.drop"), this::dropItem)
            .action(Icons.CLOSE, IKey.lang("mclib.gui.item_slot.context.clear"), this::clearItem);
    }

    private void copyNBT()
    {
        if (!this.stack.isEmpty())
        {
            GuiScreen.setClipboardString(this.stack.serializeNBT().toString());
        }
    }

    private void pasteItem(ItemStack stack)
    {
        this.acceptStack(stack, -1);
    }

    private void dropItem()
    {
        if (!this.stack.isEmpty())
        {
            Dispatcher.sendToServer(new PacketDropItem(this.stack));
        }
    }

    private void clearItem()
    {
        this.acceptStack(ItemStack.EMPTY, -1);
    }

    @Override
    protected void click(int mouseButton)
    {
        this.inventory.removeFromParent();

        GuiContext context = GuiBase.getCurrent();

        this.inventory.flex().relative(context.screen.root).xy(0.5F, 0.5F).anchor(0.5F, 0.5F);
        this.inventory.resize();
        this.inventory.updateInventory();

        context.screen.root.add(this.inventory);
    }

    @Override
    protected ItemStack get()
    {
        return this.stack;
    }

    @Override
    protected void drawSkin(GuiContext context)
    {
        int border = this.inventory.hasParent() ? 0xff000000 + McLib.primaryColor.get() : 0xffffffff;

        if (McLib.enableBorders.get())
        {
            Gui.drawRect(this.area.x + 1, this.area.y, this.area.ex() - 1, this.area.ey(), 0xff000000);
            Gui.drawRect(this.area.x, this.area.y + 1, this.area.ex(), this.area.ey() - 1, 0xff000000);
            Gui.drawRect(this.area.x + 1, this.area.y + 1, this.area.ex() - 1, this.area.ey() - 1, border);
            Gui.drawRect(this.area.x + 2, this.area.y + 2, this.area.ex() - 2, this.area.ey() - 2, 0xffc6c6c6);
        }
        else
        {
            Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), border);
            Gui.drawRect(this.area.x + 1, this.area.y + 1, this.area.ex() - 1, this.area.ey() - 1, 0xffc6c6c6);
        }

        int x = this.area.mx() - 8;
        int y = this.area.my() - 8;

        if (this.stack.isEmpty() && this.slot != 0)
        {
            GlStateManager.enableAlpha();
            GlStateManager.color(1, 1, 1, 1);

            if (this.slot == 1)
            {
                Minecraft.getMinecraft().renderEngine.bindTexture(SHIELD);
            }
            else if (this.slot == 2)
            {
                Minecraft.getMinecraft().renderEngine.bindTexture(BOOTS);
            }
            else if (this.slot == 3)
            {
                Minecraft.getMinecraft().renderEngine.bindTexture(LEGGINGS);
            }
            else if (this.slot == 4)
            {
                Minecraft.getMinecraft().renderEngine.bindTexture(CHESTPLATE);
            }
            else if (this.slot == 5)
            {
                Minecraft.getMinecraft().renderEngine.bindTexture(HELMET);
            }

            Gui.drawModalRectWithCustomSizedTexture(x, y, 0, 0, 16, 16, 16, 16);
        }
        else
        {
            RenderHelper.enableGUIStandardItemLighting();
            OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240.0F, 240.0F);
            GlStateManager.enableDepth();

            GuiInventoryElement.drawItemStack(this.stack, x, y, null);

            if (this.area.isInside(context))
            {
                context.tooltip.set(context, this);
            }

            GlStateManager.disableDepth();
            RenderHelper.disableStandardItemLighting();
        }

        if (this.drawDisabled)
        {
            GuiDraw.drawLockedArea(this, McLib.enableBorders.get() ? 1 : 0);
        }
    }

    @Override
    public void drawTooltip(GuiContext context, Area area)
    {
        super.drawTooltip(context, area);

        GuiInventoryElement.drawItemTooltip(this.stack, this.mc.player, this.font, context.mouseX, context.mouseY);

        GlStateManager.disableLighting();
    }
}

==================================================

--- Файл №24 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\buttons\GuiToggleElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.buttons;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.elements.utils.ITextColoring;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;

import javax.annotation.Nullable;
import java.util.function.Consumer;

public class GuiToggleElement extends GuiClickElement<GuiToggleElement> implements ITextColoring
{
    public IKey label;
    public int color = 0xffffff;
    public boolean textShadow = true;
    private boolean state;

    public GuiToggleElement(Minecraft mc, ValueBoolean value)
    {
        this(mc, value, null);
    }

    public GuiToggleElement(Minecraft mc, ValueBoolean value, @Nullable Consumer<GuiToggleElement> callback)
    {
        this(mc, IKey.lang(value.getLabelKey()), value.get(), callback == null ? (toggle) -> value.set(toggle.isToggled()) : (toggle) ->
        {
            value.set(toggle.isToggled());
            callback.accept(toggle);
        });
        this.tooltip(IKey.lang(value.getCommentKey()));
    }

    public GuiToggleElement(Minecraft mc, IKey label, @Nullable Consumer<GuiToggleElement> callback)
    {
        this(mc, label, false, callback);
    }

    public GuiToggleElement(Minecraft mc, IKey label, boolean state, @Nullable Consumer<GuiToggleElement> callback)
    {
        super(mc, callback);

        this.label = label;
        this.state = state;
        this.flex().h(14);
    }

    @Override
    public void setColor(int color, boolean shadow)
    {
        this.color(color, shadow);
    }

    public GuiToggleElement label(IKey label)
    {
        this.label = label;

        return this;
    }

    public GuiToggleElement toggled(boolean state)
    {
        this.state = state;

        return this;
    }

    public GuiToggleElement color(int color)
    {
        return this.color(color, true);
    }

    public GuiToggleElement color(int color, boolean textShadow)
    {
        this.color = color;
        this.textShadow = textShadow;

        return this;
    }

    public boolean isToggled()
    {
        return this.state;
    }

    @Override
    protected void click(int mouseWheel)
    {
        this.state = !this.state;

        super.click(mouseWheel);
    }

    @Override
    protected GuiToggleElement get()
    {
        return this;
    }

    @Override
    protected void drawSkin(GuiContext context)
    {
        if (McLib.enableCheckboxRendering.get())
        {
            int y = this.area.my(this.font.FONT_HEIGHT - 1);

            Gui.drawRect(this.area.x, y - 3, this.area.x + 11, y + 8, 0xff000000 + McLib.primaryColor.get());

            if (McLib.enableBorders.get())
            {
                GuiDraw.drawOutline(this.area.x, y - 3, this.area.x + 11, y + 8, 0xff000000);
            }

            if (this.state)
            {
                this.font.drawString("x", this.area.x + 3, y - 2, 0xffffff, this.textShadow);
            }

            this.font.drawString(this.label.get(), this.area.x + 14, y, this.color, this.textShadow);

            if (!this.isEnabled())
            {
                Gui.drawRect(this.area.x, y - 3, this.area.x + 11, y + 8, ColorUtils.HALF_BLACK);
                GuiDraw.drawOutlinedIcon(Icons.LOCKED, this.area.x + 5, y + 2, 0xffffffff, 0.5F, 0.5F);
            }
        }
        else
        {
            this.font.drawString(this.label.get(), this.area.x, this.area.my(this.font.FONT_HEIGHT - 1), this.color, this.textShadow);

            /* Draw toggle switch */
            int w = 16;
            int h = 10;
            int x = this.area.ex() - w - 2;
            int y = this.area.my();
            int color = McLib.primaryColor.get();

            if (this.hover)
            {
                color = ColorUtils.multiplyColor(color, 0.85F);
            }

            /* Draw toggle background */
            Gui.drawRect(x, y - h / 2, x + w, y - h / 2 + h, 0xff000000);
            Gui.drawRect(x + 1, y - h / 2 + 1, x + w - 1, y - h / 2 + h - 1, 0xff000000 + (this.state ? color : (this.hover ? 0x3a3a3a : 0x444444)));

            if (this.state)
            {
                GuiDraw.drawHorizontalGradientRect(x + 1, y - h / 2 + 1, x + w / 2, y - h / 2 + h - 1, 0x66ffffff, 0x00ffffff);
            }
            else
            {
                GuiDraw.drawHorizontalGradientRect(x + w / 2, y - h / 2 + 1, x + w - 1, y - h / 2 + h - 1, 0x00000000, 0x66000000);
            }

            if (!this.isEnabled())
            {
                Gui.drawRect(x, y - h / 2, x + w, y - h / 2 + h, ColorUtils.HALF_BLACK);
            }

            x += this.state ? w - 2 : 2;

            /* Draw toggle switch */
            Gui.drawRect(x - 4, y - 8, x + 4, y + 8, 0xff000000);
            Gui.drawRect(x - 3, y - 7, x + 3, y + 7, 0xffffffff);
            Gui.drawRect(x - 2, y - 6, x + 3, y + 7, 0xff888888);
            Gui.drawRect(x - 2, y - 6, x + 2, y + 6, 0xffbbbbbb);

            if (!this.isEnabled())
            {
                Gui.drawRect(x - 4, y - 8, x + 4, y + 8, ColorUtils.HALF_BLACK);

                GuiDraw.drawOutlinedIcon(Icons.LOCKED, this.area.ex() - w / 2 - 2, y, 0xffffffff, 0.5F, 0.5F);
            }
        }
    }
}

==================================================

--- Файл №25 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\context\GuiContextMenu.java
--------------------
package mchorse.mclib.client.gui.framework.elements.context;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import net.minecraft.client.Minecraft;

public abstract class GuiContextMenu extends GuiElement
{
    public GuiContextMenu(Minecraft mc)
    {
        super(mc);

        this.hideTooltip();
    }

    /**
     * Set mouse coordiante
     *
     * In this method for subclasses, you should setup the resizer
     */
    public abstract void setMouse(GuiContext context);

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (!this.area.isInside(context))
        {
            this.removeFromParent();
        }

        return false;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.area.draw(0xff000000);

        super.draw(context);
    }
}

==================================================

--- Файл №26 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\context\GuiSimpleContextMenu.java
--------------------
package mchorse.mclib.client.gui.framework.elements.context;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;

import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;

public class GuiSimpleContextMenu extends GuiContextMenu
{
    public GuiListElement<Action> actions;

    private boolean shadow;

    public GuiSimpleContextMenu(Minecraft mc)
    {
        super(mc);

        this.actions = new GuiActionListElement(mc, (action) ->
        {
            if (action.get(0).runnable != null)
            {
                action.get(0).runnable.run();
            }

            this.removeFromParent();
        });

        this.actions.flex().relative(this).w(1, 0).h(1, 0);
        this.add(this.actions);
    }

    public GuiSimpleContextMenu shadow()
    {
        this.shadow = true;

        return this;
    }

    public GuiSimpleContextMenu action(IKey label, Runnable runnable)
    {
        return this.action(Icons.NONE, label, runnable);
    }

    public GuiSimpleContextMenu action(Icon icon, IKey label, Runnable runnable)
    {
        if (icon == null || label == null)
        {
            return this;
        }

        return this.action(new Action(icon, label, runnable));
    }

    public GuiSimpleContextMenu action(Icon icon, IKey label, Runnable runnable, int color)
    {
        if (icon == null || label == null)
        {
            return this;
        }

        return this.action(new ColorfulAction(icon, label, runnable, color));
    }

    public GuiSimpleContextMenu action(Action action)
    {
        this.actions.add(action);

        return this;
    }

    @Override
    public void setMouse(GuiContext context)
    {
        int w = 100;

        for (Action action : this.actions.getList())
        {
            w = Math.max(action.getWidth(this.font), w);
        }

        Supplier<Float> h = () ->
        {
            return (float) Math.min(this.actions.scroll.scrollSize, context.screen.height - 10);
        };

        this.flex().set(context.mouseX(), context.mouseY(), w, 0).h(h).bounds(context.screen.root, 5);
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.shadow)
        {
            int color = McLib.primaryColor.get();

            GuiDraw.drawDropShadow(this.area.x, this.area.y, this.area.ex(), this.area.ey(), 10, 0x44000000 + color, color);
        }

        super.draw(context);
    }

    public static class GuiActionListElement extends GuiListElement<Action>
    {
        public GuiActionListElement(Minecraft mc, Consumer<List<Action>> callback)
        {
            super(mc, callback);

            this.scroll.scrollItemSize = 20;
        }

        @Override
        public void drawListElement(Action element, int i, int x, int y, boolean hover, boolean selected)
        {
            int h = this.scroll.scrollItemSize;

            element.draw(this.font, x, y, this.scroll.w, h, hover, selected);
        }
    }

    public static class Action
    {
        public Icon icon;
        public IKey label;
        public Runnable runnable;

        public Action(Icon icon, IKey label, Runnable runnable)
        {
            this.icon = icon;
            this.label = label;
            this.runnable = runnable;
        }

        public int getWidth(FontRenderer font)
        {
            return 28 + font.getStringWidth(this.label.get());
        }

        public void draw(FontRenderer font, int x, int y, int w, int h, boolean hover, boolean selected)
        {
            this.drawBackground(font, x, y, w, h, hover, selected);

            GlStateManager.color(1, 1, 1, 1);
            this.icon.render(x + 2, y + h / 2, 0, 0.5F);
            font.drawString(this.label.get(), x + 22, y + (h - font.FONT_HEIGHT) / 2 + 1, 0xffffff);
        }

        protected void drawBackground(FontRenderer font, int x, int y, int w, int h, boolean hover, boolean selected)
        {
            if (hover)
            {
                Gui.drawRect(x, y, x + w, y + h, ColorUtils.HALF_BLACK + McLib.primaryColor.get());
            }
        }
    }

    public static class ColorfulAction extends Action
    {
        public int color;

        public ColorfulAction(Icon icon, IKey label, Runnable runnable, int color)
        {
            super(icon, label, runnable);

            this.color = color;
        }

        @Override
        protected void drawBackground(FontRenderer font, int x, int y, int w, int h, boolean hover, boolean selected)
        {
            super.drawBackground(font, x, y, w, h, hover, selected);

            drawRect(x, y, x + 2, y + h, 0xff000000 + this.color);
            GuiDraw.drawHorizontalGradientRect(x + 2, y, x + 24, y + h, 0x44000000 + this.color, this.color);
        }
    }
}

==================================================

--- Файл №27 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiBaseTextElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IFocusedGuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.utils.Color;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiTextField;
import org.lwjgl.input.Keyboard;

public abstract class GuiBaseTextElement extends GuiElement implements IFocusedGuiElement
{
    public GuiTextField field;

    public GuiBaseTextElement(Minecraft mc)
    {
        super(mc);

        this.field = new GuiTextField(0, this.font, 0, 0, 0, 0);
    }

    @Override
    public void setEnabled(boolean enabled)
    {
        super.setEnabled(enabled);
        this.field.setEnabled(enabled);
    }

    @Override
    public void setVisible(boolean visible)
    {
        super.setVisible(visible);
        this.field.setVisible(visible);
    }

    public void setTextColor(Color color)
    {
        this.field.setTextColor(color.getRGBAColor());
    }

    public void setTextColor(int color)
    {
        this.field.setTextColor(color);
    }

    public void setText(String textIn)
    {
        this.field.setText(textIn);
    }

    @Override
    public boolean isFocused()
    {
        return this.field.isFocused();
    }

    @Override
    public void focus(GuiContext context)
    {
        this.field.setFocused(true);
        Keyboard.enableRepeatEvents(true);
    }

    @Override
    public void unfocus(GuiContext context)
    {
        this.field.setFocused(false);
        Keyboard.enableRepeatEvents(false);
    }

    @Override
    public void selectAll(GuiContext context)
    {
        this.field.setCursorPosition(0);
        this.field.setSelectionPos(this.field.getText().length());
    }

    @Override
    public void unselect(GuiContext context)
    {
        this.field.setSelectionPos(this.field.getCursorPosition());
    }
}

==================================================

--- Файл №28 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiColorElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.color.GuiColorPicker;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;

import java.util.function.Consumer;

/**
 * Color GUI element
 *
 * This class is responsible for providing a way to edit colors, this element
 * itself is not editing the color, the picker element is the one that does color editing
 */
public class GuiColorElement extends GuiElement
{
    public GuiColorPicker picker;
    public boolean label = true;
    public Direction direction;
    public GuiElement target;

    public GuiColorElement(Minecraft mc, ValueInt value)
    {
        this(mc, value, null);
    }

    public GuiColorElement(Minecraft mc, ValueInt value, Consumer<Integer> callback)
    {
        this(mc, callback == null ? value::set : (integer) ->
        {
            value.set(integer);
            callback.accept(integer);
        });
        this.tooltip(IKey.lang(value.getCommentKey()));

        if (value.getSubtype() == ValueInt.Subtype.COLOR_ALPHA)
        {
            this.picker.editAlpha();
        }

        this.picker.setColor(value.get());
    }

    public GuiColorElement(Minecraft mc, Consumer<Integer> callback)
    {
        super(mc);

        this.picker = new GuiColorPicker(mc, (color) ->
        {
            if (callback != null)
            {
                callback.accept(color);
            }
        });
        this.picker.markIgnored().flex().wh(200, 85).bounds(this, 2);

        this.direction(Direction.BOTTOM).flex().h(20);
    }

    public GuiColorElement direction(Direction direction)
    {
        this.direction = direction;
        this.picker.flex().anchor(1 - direction.anchorX, 1 - direction.anchorY);

        return this;
    }

    public GuiColorElement onTop()
    {
        return this.direction(Direction.TOP);
    }

    public GuiColorElement noLabel()
    {
        this.label = false;

        return this;
    }

    public GuiColorElement target(GuiElement target)
    {
        this.target = target;
        this.picker.flex().bounds(null, 0).target = target;

        return this;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.area.isInside(context))
        {
            if (!this.picker.hasParent())
            {
                int x = context.globalX(this.area.x(this.direction.anchorX) + 2 * this.direction.factorX);
                int y = context.globalY(this.area.y(this.direction.anchorY) + 2 * this.direction.factorY);

                (this.target == null ? this.getParentContainer() : this.target).add(this.picker);
                this.picker.setup(x, y);
                this.picker.resize();
            }
            else
            {
                this.picker.removeFromParent();
            }

            return true;
        }

        return false;
    }

    @Override
    public void draw(GuiContext context)
    {
        int padding = 0;

        if (McLib.enableBorders.get())
        {
            this.area.draw(0xff000000);

            GlStateManager.color(1, 1, 1);
            this.picker.drawRect(this.area.x + 1, this.area.y + 1, this.area.ex() - 1, this.area.ey() - 1);

            padding = 1;
        }
        else
        {
            this.picker.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey());
        }

        if (this.area.isInside(context))
        {
            this.area.draw(0x22000000, padding);
        }

        if (this.label)
        {
            String label = this.picker.color.stringify(this.picker.editAlpha);

            GuiDraw.drawTextBackground(this.font, label, this.area.mx(this.font.getStringWidth(label)), this.area.my(this.font.FONT_HEIGHT - 1), 0xffffff, 0x55000000, 1);
        }

        GuiDraw.drawLockedArea(this);

        super.draw(context);
    }
}

==================================================

--- Файл №29 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiKeybindElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueInt.Subtype;
import mchorse.mclib.utils.Keys;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;

import java.util.LinkedHashSet;
import java.util.Set;
import java.util.function.Consumer;

import org.lwjgl.input.Keyboard;

public class GuiKeybindElement extends GuiElement
{
    public int keybind;
    public boolean enabled;
    public boolean comboKey;
    public Set<Integer> holding;
    public Consumer<Integer> callback;

    public GuiKeybindElement(Minecraft mc, ValueInt value)
    {
        this(mc, value, null);
    }

    public GuiKeybindElement(Minecraft mc, ValueInt value, Consumer<Integer> callback)
    {
        this(mc, callback == null ? value::set : (integer) ->
        {
            value.set(integer);
            callback.accept(integer);
        });
        this.setKeybind(value.get());
        this.tooltip(IKey.lang(value.getCommentKey()));

        if (value.getSubtype() == Subtype.COMBOKEY)
        {
            this.comboKey = true;
            this.holding = new LinkedHashSet<Integer>();
        }
    }

    public GuiKeybindElement(Minecraft mc, Consumer<Integer> callback)
    {
        super(mc);

        this.callback = callback;
        this.flex().h(20);
    }

    public void setKeybind(int keybind)
    {
        this.keybind = keybind;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.area.isInside(context) && context.mouseButton == 0)
        {
            this.enabled = true;
        }

        return this.area.isInside(context);
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (this.enabled)
        {
            if (this.comboKey && Keys.MODIFIERS.contains(context.keyCode))
            {
                this.holding.add(context.keyCode);
            }
            else
            {
                if (context.keyCode == Keyboard.KEY_ESCAPE)
                {
                    this.keybind = Keyboard.KEY_NONE;
                }
                else
                {
                    if (this.comboKey)
                    {
                        this.keybind = Keys.getComboKeyCode(this.holding.stream().mapToInt(Integer::valueOf).toArray(), context.keyCode);
                        this.holding.clear();
                    }
                    else
                    {
                        this.keybind = context.keyCode;
                    }
                }

                this.enabled = false;

                if (this.callback != null)
                {
                    this.callback.accept(this.keybind);
                }
            }

            return true;
        }

        return false;
    }

    public void checkHolding()
    {
        for (int key : this.holding)
        {
            if (!Keys.isKeyDown(key))
            {
                this.keybind = Keys.getComboKeyCode(this.holding.stream().mapToInt(Integer::valueOf).toArray(), key);
                this.enabled = false;
                this.holding.clear();

                if (this.callback != null)
                {
                    this.callback.accept(this.keybind);
                }

                return;
            }
        }
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.enabled)
        {
            GuiDraw.drawBorder(this.area, 0xff000000 + McLib.primaryColor.get());

            int x = this.area.mx();
            int y = this.area.my();
            int a = (int) (Math.sin((context.tick + context.partialTicks) / 2D) * 127.5 + 127.5) << 24;

            Gui.drawRect(x - 1, y - 6, x + 1, y + 6, a + 0xffffff);

            if (this.comboKey)
            {
                this.checkHolding();
            }
        }
        else
        {
            this.area.draw(0xff000000);

            this.drawCenteredString(this.font, Keys.getComboKeyName(this.keybind), this.area.mx(), this.area.my() - this.font.FONT_HEIGHT / 2, 0xffffff);
        }

        super.draw(context);
    }
}

==================================================

--- Файл №30 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiKeybinds.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Keybind;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class GuiKeybinds extends GuiScrollElement
{
    public Map<String, KeybindCategory> keybinds = new HashMap<String, KeybindCategory>();

    public GuiKeybinds(Minecraft mc)
    {
        super(mc);

        this.hideTooltip();
        this.scroll.opposite = true;
    }

    public void addKeybind(Keybind keybind)
    {
        KeybindCategory category = this.keybinds.get(keybind.category.get());

        if (category == null)
        {
            category = new KeybindCategory(keybind.category);
            this.keybinds.put(keybind.category.get(), category);
        }

        category.add(keybind);
    }

    @Override
    public void draw(GuiContext context)
    {
        int cx = 40;
        Gui.drawRect(this.area.x, this.area.y, cx, this.area.ey(), 0xdd000000);
        GuiDraw.drawHorizontalGradientRect(cx, this.area.y, this.area.ex(), this.area.ey(), 0xdd000000, 0);

        super.draw(context);
    }

    @Override
    protected void preDraw(GuiContext context)
    {
        super.preDraw(context);

        int x = this.area.x + 10;
        int y = this.area.y + 10;
        int i = 0;

        KeybindCategory general = this.keybinds.get("");

        i = general.draw(context, x, y, i) + 10;

        for (KeybindCategory category : this.keybinds.values())
        {
            if (category != general)
            {
                i = category.draw(context, x, y, i) + 10;
            }
        }

        this.keybinds.clear();
        this.scroll.scrollSize = i + 3;
        this.scroll.clamp();
    }

    public static class KeybindCategory
    {
        public IKey title;
        public List<Keybind> keybinds = new ArrayList<Keybind>();
        public boolean shouldClean;

        public KeybindCategory(IKey title)
        {
            this.title = title;
        }

        public void add(Keybind keybind)
        {
            if (this.shouldClean)
            {
                this.keybinds.clear();
                this.shouldClean = false;
            }

            this.keybinds.add(keybind);
        }

        public int draw(GuiContext context, int x, int y, int i)
        {
            int color = 0xff000000 + McLib.primaryColor.get();

            String title = this.title.get();

            if (!title.isEmpty())
            {
                Gui.drawRect(x - 10, y + i - 2, x + context.font.getStringWidth(title) + 2, y + i + context.font.FONT_HEIGHT + 2, color);
                context.font.drawString(title, x, y + i, 0xffffff);
                i += 14;
            }

            for (Keybind keybind : this.keybinds)
            {
                String combo = keybind.getKeyCombo();
                int w = context.font.getStringWidth(combo);

                Gui.drawRect(x - 2, y + i - 2, x + w + 2, y + i + context.font.FONT_HEIGHT + 2, color);
                context.font.drawString(combo, x, y + i, 0xffffff);
                context.font.drawStringWithShadow(keybind.label.get(), x + w + 5, y + i, 0xffffff);
                i += 14;
            }

            return i;
        }
    }
}

==================================================

--- Файл №31 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiTextElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import com.google.common.base.Predicate;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.elements.utils.ITextColoring;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueString;
import mchorse.mclib.utils.Patterns;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiPageButtonList.GuiResponder;
import net.minecraft.client.gui.GuiScreen;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.input.Keyboard;

import java.util.function.Consumer;
import java.util.regex.Pattern;

/**
 * GUI text element
 * 
 * This element is a wrapper for the text field class
 */
@SideOnly(Side.CLIENT)
public class GuiTextElement extends GuiBaseTextElement implements GuiResponder, ITextColoring
{
    public static final Predicate<String> FILENAME_PREDICATE = (s) -> Patterns.FILENAME.matcher(s).find();

    public Consumer<String> callback;

    public GuiTextElement(Minecraft mc, ValueString value)
    {
        this(mc, value, null);
    }

    public GuiTextElement(Minecraft mc, ValueString value, Consumer<String> callback)
    {
        this(mc, callback == null ? value::set : (string) ->
        {
            value.set(string);
            callback.accept(string);
        });
        this.setText(value.get());
        this.tooltip(IKey.lang(value.getConfig().getValueLabelKey(value)));
    }

    public GuiTextElement(Minecraft mc, int maxLength, Consumer<String> callback)
    {
        this(mc, callback);
        this.field.setMaxStringLength(maxLength);
    }

    public GuiTextElement(Minecraft mc, Consumer<String> callback)
    {
        super(mc);

        this.field.setGuiResponder(this);
        this.callback = callback;

        this.flex().h(20);
    }

    public GuiTextElement filename()
    {
        return this.validator(FILENAME_PREDICATE);
    }

    public GuiTextElement validator(Predicate<String> validator)
    {
        this.field.setValidator(validator);

        return this;
    }

    public GuiTextElement background(boolean background)
    {
        this.field.setEnableBackgroundDrawing(background);
        this.resize();

        return this;
    }

    public void setText(String text)
    {
        if (text == null)
        {
            text = "";
        }

        this.field.setText(text);
        this.field.setCursorPositionZero();
    }

    @Override
    public void setEntryValue(int id, boolean value)
    {}

    @Override
    public void setEntryValue(int id, float value)
    {}

    @Override
    public void setEntryValue(int id, String value)
    {
        if (this.callback != null)
        {
            this.callback.accept(value);
        }
    }

    @Override
    public void setColor(int color, boolean shadow)
    {
        this.field.setTextColor(color);
    }

    @Override
    public void resize()
    {
        super.resize();

        this.field.x = this.area.x + 1;
        this.field.y = this.area.y + 1;
        this.field.width = this.area.w - 2;
        this.field.height = this.area.h - 2;

        if (!this.field.getEnableBackgroundDrawing())
        {
            this.field.x += 4;
            this.field.y += ((this.area.h - this.font.FONT_HEIGHT) / 2);
            this.field.width -= 8;
            this.field.height = this.font.FONT_HEIGHT;
        }
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        boolean wasFocused = this.field.isFocused();

        this.field.mouseClicked(context.mouseX, context.mouseY, context.mouseButton);

        if (wasFocused != this.field.isFocused())
        {
            context.focus(wasFocused ? null : this);
        }

        return context.mouseButton == 0 && this.area.isInside(context);
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (this.isFocused())
        {
            if (context.keyCode == Keyboard.KEY_TAB)
            {
                context.focus(this, -1, GuiScreen.isShiftKeyDown() ? -1 : 1);

                return true;
            }
            else if (context.keyCode == Keyboard.KEY_ESCAPE)
            {
                context.unfocus();

                return true;
            }
        }

        return this.field.textboxKeyTyped(context.typedChar, context.keyCode) || super.keyTyped(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.field.drawTextBox();

        GuiDraw.drawLockedArea(this);

        super.draw(context);
    }
}

==================================================

--- Файл №32 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiTexturePicker.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.multiskin.GuiMultiSkinEditor;
import mchorse.mclib.client.gui.framework.elements.list.GuiFolderEntryListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Timer;
import mchorse.mclib.utils.files.FileTree;
import mchorse.mclib.utils.files.GlobalTree;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import mchorse.mclib.utils.resources.FilteredResourceLocation;
import mchorse.mclib.utils.resources.MultiResourceLocation;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ChatAllowedCharacters;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.input.Keyboard;
import org.lwjgl.opengl.GL11;

import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

/**
 * Texture picker GUI
 * 
 * This bad boy allows picking a texture from the file browser, and also 
 * it allows creating multi-skins. See {@link MultiResourceLocation} for 
 * more information.
 */
public class GuiTexturePicker extends GuiElement
{
    public GuiElement right;
    public GuiTextElement text;
    public GuiButtonElement close;
    public GuiButtonElement folder;
    public GuiFolderEntryListElement picker;

    public GuiButtonElement multi;
    public GuiFRLListElement multiList;
    public GuiMultiSkinEditor editor;

    public GuiElement buttons;
    public GuiIconElement add;
    public GuiIconElement remove;
    public GuiIconElement edit;

    public Consumer<ResourceLocation> callback;

    public MultiResourceLocation multiRL;
    public FilteredResourceLocation currentFRL;
    public ResourceLocation current;
    public FileTree tree = GlobalTree.TREE;

    private Timer lastTyped = new Timer(1000);
    private Timer lastChecked = new Timer(1000);
    private String typed = "";

    public GuiTexturePicker(Minecraft mc, Consumer<ResourceLocation> callback)
    {
        super(mc);

        this.right = new GuiElement(mc);
        this.text = new GuiTextElement(mc, 1000, (str) -> this.selectCurrent(str.isEmpty() ? null : RLUtils.create(str)));
        this.text.context(() ->
        {
            GuiSimpleContextMenu menu = new GuiSimpleContextMenu(mc);
            ResourceLocation location = this.parseRL();

            menu.action(Icons.COPY, IKey.lang("mclib.gui.context.multi_skin.copy"), this::copyRL);

            if (location != null)
            {
                menu.action(Icons.PASTE, IKey.lang("mclib.gui.context.multi_skin.paste"), () -> this.pasteRL(location));
            }

            return menu;
        });
        this.close = new GuiButtonElement(mc, IKey.str("X"), (b) -> this.close());
        this.folder = new GuiButtonElement(mc, IKey.lang("mclib.gui.open_folder"), (b) -> this.openFolder());
        this.picker = new GuiFolderEntryListElement(mc, (entry) ->
        {
            ResourceLocation rl = entry.resource;

            this.selectCurrent(rl);
            this.text.setText(rl == null ? "" : rl.toString());
        }) {
            @Override
            public void setFolder(FolderEntry folder)
            {
                super.setFolder(folder);

                GuiTexturePicker.this.updateFolderButton();
            }
        };
        this.picker.cancelScrollEdge();

        this.multi = new GuiButtonElement(mc, IKey.lang("mclib.gui.multi_skin"), (b) -> this.toggleMultiSkin());
        this.multiList = new GuiFRLListElement(mc, (list) -> this.setFRL(list.get(0)));

        this.editor = new GuiMultiSkinEditor(mc, this);
        this.editor.setVisible(false);

        this.buttons = new GuiElement(mc);
        this.add = new GuiIconElement(mc, Icons.ADD, (b) -> this.addMultiSkin());
        this.remove = new GuiIconElement(mc, Icons.REMOVE, (b) -> this.removeMultiSkin());
        this.edit = new GuiIconElement(mc, Icons.EDIT, (b) -> this.toggleEditor());

        this.right.flex().relative(this).wh(1F, 1F);
        this.text.flex().relative(this.multi).x(1F, 20).wTo(this.close.flex(), -5).h(20);
        this.close.flex().relative(this).set(0, 10, 20, 20).x(1, -30);
        this.folder.flex().relative(this.right).set(0, 0, 80, 20).x(1, -10).y(1, -10).anchor(1F, 1F);
        this.picker.flex().relative(this.right).set(10, 30, 0, 0).w(1, -10).h(1, -30);

        this.multi.flex().relative(this).set(10, 10, 100, 20);
        this.multiList.flex().relative(this).set(10, 35, 100, 0).hTo(this.buttons.flex());
        this.editor.flex().relative(this).set(120, 0, 0, 0).w(1F, -120).h(1F);

        this.buttons.flex().relative(this).y(1F, -20).wTo(this.right.area).h(20);
        this.add.flex().relative(this.buttons).set(0, 0, 20, 20);
        this.remove.flex().relative(this.add).set(20, 0, 20, 20);
        this.edit.flex().relative(this.buttons).wh(20, 20).x(1F, -20);

        this.right.add(this.text, this.picker, this.folder);
        this.buttons.add(this.add, this.remove, this.edit);
        this.add(this.multi, this.multiList, this.close, this.right, this.editor, this.buttons);

        this.callback = callback;

        this.fill(null);
        this.markContainer();
    }

    private ResourceLocation parseRL()
    {
        ResourceLocation location = null;

        try
        {
            NBTTagCompound compound = JsonToNBT.getTagFromJson(GuiScreen.getClipboardString());

            location = RLUtils.create(compound.getTag("RL"));
        }
        catch (Exception e)
        {}

        return location;
    }

    private void copyRL()
    {
        NBTBase location = RLUtils.writeNbt(this.multiRL != null ? this.multiRL : this.current);

        if (location == null)
        {
            GuiScreen.setClipboardString("");
        }
        else
        {
            NBTTagCompound tag = new NBTTagCompound();

            tag.setTag("RL", location);

            GuiScreen.setClipboardString(tag.toString());
        }
    }

    private void pasteRL(ResourceLocation location)
    {
        this.setMultiSkin(location, true);
    }

    public void close()
    {
        boolean wasVisible = this.getParent() != null;

        this.editor.close();
        this.removeFromParent();

        if (this.callback != null && wasVisible)
        {
            if (this.multiRL != null)
            {
                this.multiRL.recalculateId();
            }

            this.callback.accept(this.multiRL != null ? this.multiRL : this.current);
        }
    }

    public void refresh()
    {
        this.picker.update();
        this.updateFolderButton();
    }

    public void openFolder()
    {
        if (this.picker.parent != null && this.picker.parent.file != null)
        {
            mchorse.mclib.client.gui.utils.GuiUtils.openFolder(this.picker.parent.file.getAbsolutePath());
        }
    }

    public void updateFolderButton()
    {
        this.folder.setEnabled(this.picker.parent != null && this.picker.parent.file != null);
    }

    public void fill(ResourceLocation skin)
    {
        this.setMultiSkin(skin, false);
    }

    /**
     * Add a {@link ResourceLocation} to the multiRL 
     */
    private void addMultiSkin()
    {
        FilteredResourceLocation rl = this.currentFRL.copy();

        this.multiList.add(rl);
        this.multiList.setIndex(this.multiList.getList().size() - 1);
        this.setFRL(this.multiList.getCurrent().get(0));
    }

    /**
     * Remove currently selected {@link ResourceLocation} from multiRL 
     */
    private void removeMultiSkin()
    {
        int index = this.multiList.getIndex();

        if (index >= 0 && this.multiList.getList().size() > 1)
        {
            this.multiList.getList().remove(index);
            this.multiList.update();
            this.multiList.setIndex(index - 1);

            if (this.multiList.getIndex() >= 0)
            {
                this.setFRL(this.multiList.getCurrent().get(0));
            }
        }
    }

    private void setFRL(FilteredResourceLocation location)
    {
        this.currentFRL = location;
        this.displayCurrent(location.path);
        this.editor.setLocation(location);
    }

    private void toggleEditor()
    {
        this.editor.toggleVisible();
        this.right.setVisible(!this.editor.isVisible());

        if (this.editor.isVisible())
        {
            this.editor.resetView();
        }
    }

    /**
     * Display current resource location (it's just for visual, not 
     * logic)
     */
    protected void displayCurrent(ResourceLocation rl)
    {
        this.current = rl;
        this.picker.rl = rl;
        this.text.setText(rl == null ? "" : rl.toString());
        this.text.field.setCursorPositionZero();

        if (this.tree != null)
        {
            FolderEntry folder = this.tree.getByPath(rl == null ? "" : rl.getResourceDomain() + "/" + rl.getResourcePath());

            if (folder != this.tree.root || this.picker.getList().isEmpty())
            {
                this.picker.setList(folder.getEntries());
                this.picker.parent = folder;
                this.picker.setCurrent(rl);
                this.picker.update();

                this.updateFolderButton();
            }
        }
    }

    /**
     * Select current resource location
     */
    protected void selectCurrent(ResourceLocation rl)
    {
        try
        {
            /* If this code causes an exception, that means that there 
             * is some issue with the texture, so we should rather not 
             * use it */
            if (rl != null)
            {
                this.mc.renderEngine.bindTexture(rl);
            }
        }
        catch (Exception e)
        {
            return;
        }

        this.current = rl;

        if (this.multiRL != null)
        {
            if (rl == null && this.multiRL.children.size() == 1)
            {
                this.currentFRL.path = rl;
                this.toggleMultiSkin();
            }
            else
            {
                this.currentFRL.path = rl;
            }
        }
        else if (this.callback != null)
        {
            this.callback.accept(rl);
        }

        this.picker.rl = rl;
    }

    protected void toggleMultiSkin()
    {
        if (this.multiRL != null)
        {
            this.setMultiSkin(this.multiRL.children.get(0).path, true);
        }
        else if (this.current != null)
        {
            this.setMultiSkin(new MultiResourceLocation(this.current.toString()), true);
        }
        else
        {
            ResourceLocation rl = this.picker.getCurrentResource();

            if (rl != null)
            {
                this.setMultiSkin(rl, true);
            }
        }
    }

    protected void setMultiSkin(ResourceLocation skin, boolean notify)
    {
        if (this.editor.isVisible())
        {
            this.toggleEditor();
        }

        boolean show = skin instanceof MultiResourceLocation;

        if (show)
        {
            this.multiRL = (MultiResourceLocation) ((MultiResourceLocation) skin).copy();
            this.setFRL(this.multiRL.children.get(0));

            this.multiList.setIndex(this.multiRL.children.isEmpty() ? -1 : 0);;
            this.multiList.setList(this.multiRL.children);

            if (this.current != null)
            {
                this.multiList.setIndex(0);
            }

            this.right.flex().x(120).w(1F, -120);
        }
        else
        {
            this.multiRL = null;

            this.right.flex().x(0).w(1F);
            this.displayCurrent(skin);
        }

        if (notify)
        {
            if (show && this.callback != null)
            {
                this.multiRL.recalculateId();
                this.callback.accept(skin);
            }
            else
            {
                this.selectCurrent(skin);
            }
        }

        this.multiList.setVisible(show);
        this.buttons.setVisible(show);

        this.resize();
        this.updateFolderButton();
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        /* Necessary measure to avoid triggering buttons when you press 
         * on a text field, for example */
        return super.mouseClicked(context) || (this.isVisible() && this.area.isInside(context));
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        int keyCode = context.keyCode;

        if (keyCode == Keyboard.KEY_RETURN)
        {
            List<AbstractEntry> selected = this.picker.getCurrent();
            AbstractEntry entry = selected.isEmpty() ? null : selected.get(0);

            if (entry instanceof FolderEntry)
            {
                this.picker.setFolder((FolderEntry) entry);
            }
            else if (entry instanceof FileEntry)
            {
                this.selectCurrent(((FileEntry) entry).resource);
            }

            this.typed = "";

            return true;
        }
        else if (keyCode == Keyboard.KEY_UP)
        {
            return this.moveCurrent(-1, GuiScreen.isShiftKeyDown());
        }
        else if (keyCode == Keyboard.KEY_DOWN)
        {
            return this.moveCurrent(1, GuiScreen.isShiftKeyDown());
        }
        else if (keyCode == Keyboard.KEY_ESCAPE)
        {
            this.close();

            return true;
        }

        return this.pickByTyping(context.typedChar);
    }

    protected boolean moveCurrent(int factor, boolean top)
    {
        int index = this.picker.getIndex() + factor;
        int length = this.picker.getList().size();

        if (index < 0) index = length - 1;
        else if (index >= length) index = 0;

        if (top) index = factor > 0 ? length - 1 : 0;

        this.picker.setIndex(index);
        this.picker.scroll.scrollIntoView(index * this.picker.scroll.scrollItemSize);
        this.typed = "";

        return true;
    }

    protected boolean pickByTyping(char typedChar)
    {
        if (!ChatAllowedCharacters.isAllowedCharacter(typedChar))
        {
            return false;
        }

        if (this.lastTyped.checkReset())
        {
            this.typed = "";
        }

        this.typed += Character.toString(typedChar);
        this.lastTyped.mark();

        for (AbstractEntry entry : this.picker.getList())
        {
            if (entry.title.startsWith(this.typed))
            {
                this.picker.setCurrentScroll(entry);

                return true;
            }
        }

        return true;
    }

    @Override
    public void draw(GuiContext context)
    {
        /* Refresh the list */
        if (this.lastChecked.checkRepeat())
        {
            FolderEntry folder = this.picker.parent;

            if (folder != null && folder.isTop())
            {
                folder = folder.top;
            }

            if (folder != null && folder.hasChanged())
            {
                this.picker.setDirectFolder(folder);
            }
        }

        /* Draw the background */
        drawGradientRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), ColorUtils.HALF_BLACK, 0xff000000);

        if (this.multiList.isVisible())
        {
            drawRect(this.area.x, this.area.y, this.area.x + 120, this.area.ey(), 0xff181818);
            drawRect(this.area.x, this.area.y, this.area.x + 120, this.area.y + 30, 0x44000000);
            drawGradientRect(this.area.x, this.area.ey() - 20, this.buttons.area.ex(), this.area.ey(), 0, ColorUtils.HALF_BLACK);
        }

        if (this.editor.isVisible())
        {
            this.edit.area.draw(ColorUtils.HALF_BLACK + McLib.primaryColor.get());
        }

        super.draw(context);

        /* Draw the overlays */
        if (this.right.isVisible())
        {
            if (this.picker.getList().isEmpty())
            {
                this.drawCenteredString(this.font, I18n.format("mclib.gui.no_data"), this.picker.area.mx(), this.picker.area.my() - 8, 0xffffff);
            }

            if (!this.lastTyped.check() && this.lastTyped.enabled)
            {
                int w = this.font.getStringWidth(this.typed);
                int x = this.text.area.x;
                int y = this.text.area.ey();

                Gui.drawRect(x, y, x + w + 4, y + 4 + this.font.FONT_HEIGHT, ColorUtils.HALF_BLACK + McLib.primaryColor.get());
                this.font.drawStringWithShadow(this.typed, x + 2, y + 2, 0xffffff);
            }

            ResourceLocation loc = this.current;

            /* Draw preview */
            if (loc != null)
            {
                GlStateManager.color(1, 1, 1, 1);
                this.mc.renderEngine.bindTexture(loc);

                int w = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
                int h = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);

                int x = this.area.ex();
                int y = this.area.ey();
                int fw = w;
                int fh = h;

                if (fw > 128 || fh > 128)
                {
                    fw = fh = 128;

                    if (w > h)
                    {
                        fh = (int) ((h / (float) w) * fw);
                    }
                    else if (h > w)
                    {
                        fw = (int) ((w / (float) h) * fh);
                    }
                }

                x -= fw + 10;
                y -= fh + 35;

                Icons.CHECKBOARD.renderArea(x, y, fw, fh);

                GlStateManager.enableAlpha();
                this.mc.renderEngine.bindTexture(loc);
                GuiDraw.drawBillboard(x, y, 0, 0, fw, fh, fw, fh);
            }
        }
    }

    public static class GuiFRLListElement extends GuiListElement<FilteredResourceLocation>
    {
        public GuiFRLListElement(Minecraft mc, Consumer<List<FilteredResourceLocation>> callback)
        {
            super(mc, callback);

            this.scroll.scrollItemSize = 16;
        }

        @Override
        protected boolean sortElements()
        {
            Collections.sort(this.list, (a, b) -> a.toString().compareToIgnoreCase(b.toString()));

            return true;
        }
    }
}

==================================================

--- Файл №33 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiTrackpadElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.values.ValueDouble;
import mchorse.mclib.config.values.ValueFloat;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueLong;
import mchorse.mclib.math.MathBuilder;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.Timer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import org.lwjgl.input.Keyboard;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.GL11;

import javax.annotation.Nullable;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.function.Consumer;

public class GuiTrackpadElement extends GuiBaseTextElement
{
    public static final DecimalFormat FORMAT;

    public Consumer<Double> callback;

    public double value;

    /* Trackpad options */
    public double strong = 1D;
    public double normal = 0.25D;
    public double weak = 0.05D;
    public double increment = 1;
    public double min = Double.NEGATIVE_INFINITY;
    public double max = Double.POSITIVE_INFINITY;
    public boolean integer;

    /* Value dragging fields */
    private boolean dragging;
    private int shiftX;
    private int initialX;
    private int initialY;
    private double lastValue;
    private double valueBeforeDrag;

    private Timer changed = new Timer(30);

    private long time;
    private Area plusOne = new Area();
    private Area minusOne = new Area();
    private int decimalPlaces;
    private DecimalFormat rounding;

    static
    {
        FORMAT = new DecimalFormat("#.###");
        FORMAT.setRoundingMode(RoundingMode.HALF_EVEN);
    }

    {
        this.decimalPlaces = McLib.trackpadDecimalPlaces.get();

        this.getRoundingFormat(true);
    }

    public GuiTrackpadElement(Minecraft mc, ValueInt value)
    {
        this(mc, value, null);
    }

    public GuiTrackpadElement(Minecraft mc, ValueInt value, @Nullable Consumer<Double> callback)
    {
        this(mc, callback == null ? (v) -> value.set(v.intValue()) : (v) ->
        {
            value.set(v.intValue());
            callback.accept(v);
        });
        this.limit(value.getMin(), value.getMax(), true);
        this.setValue(value.get());
        this.tooltip(IKey.lang(value.getCommentKey()));
    }

    public GuiTrackpadElement(Minecraft mc, ValueLong value)
    {
        this(mc, value, null);
    }

    public GuiTrackpadElement(Minecraft mc, ValueLong value, @Nullable Consumer<Double> callback)
    {
        this(mc, callback == null ? (v) -> value.set(v.longValue()) : (v) ->
        {
            value.set(v.longValue());
            callback.accept(v);
        });
        this.limit(value.getMin(), value.getMax(), true);
        this.setValue(value.get());
        this.tooltip(IKey.lang(value.getCommentKey()));
    }

    public GuiTrackpadElement(Minecraft mc, ValueFloat value)
    {
        this(mc, value, null);
    }

    public GuiTrackpadElement(Minecraft mc, ValueFloat value, @Nullable Consumer<Double> callback)
    {
        this(mc, callback == null ? (v) -> value.set(v.floatValue()) : (v) ->
        {
            value.set(v.floatValue());
            callback.accept(v);
        });
        this.limit(value.getMin(), value.getMax());
        this.setValue(value.get());
        this.tooltip(IKey.lang(value.getCommentKey()));
    }

    public GuiTrackpadElement(Minecraft mc, ValueDouble value)
    {
        this(mc, value, null);
    }

    public GuiTrackpadElement(Minecraft mc, ValueDouble value, @Nullable Consumer<Double> callback)
    {
        this(mc, callback == null ? value::set : (v) ->
        {
            value.set(v);
            callback.accept(v);
        });
        this.limit(value.getMin(), value.getMax());
        this.setValue(value.get());
        this.tooltip(IKey.lang(value.getCommentKey()));
    }

    public GuiTrackpadElement(Minecraft mc, @Nullable Consumer<Double> callback)
    {
        super(mc);

        this.callback = callback;

        this.field.setEnableBackgroundDrawing(false);
        this.setValue(0);

        this.flex().h(20);
    }

    public GuiTrackpadElement max(double max)
    {
        this.max = max;

        return this;
    }

    public GuiTrackpadElement limit(double min)
    {
        this.min = min;

        return this;
    }

    public GuiTrackpadElement limit(double min, double max)
    {
        this.min = min;
        this.max = max;

        return this;
    }

    public GuiTrackpadElement limit(double min, double max, boolean integer)
    {
        this.integer = integer;

        return this.limit(min, max);
    }

    public GuiTrackpadElement integer()
    {
        this.integer = true;

        return this;
    }

    public GuiTrackpadElement increment(double increment)
    {
        this.increment = increment;

        return this;
    }

    public GuiTrackpadElement values(double normal)
    {
        this.normal = normal;
        this.weak = normal / 5D;
        this.strong = normal * 5D;

        return this;
    }

    public GuiTrackpadElement values(double normal, double weak, double strong)
    {
        this.normal = normal;
        this.weak = weak;
        this.strong = strong;

        return this;
    }

    /* Values presets */

    public GuiTrackpadElement degrees()
    {
        return this.increment(15D).values(1D, 0.1D, 5D);
    }

    public GuiTrackpadElement block()
    {
        return this.increment(1 / 16D).values(1 / 32D, 1 / 128D, 1 / 2D);
    }

    public GuiTrackpadElement metric()
    {
        return this.values(0.1D, 0.01D, 1);
    }

    /**
     * Whether this trackpad is dragging
     */
    public boolean isDragging()
    {
        return this.dragging;
    }

    public boolean isDraggingTime()
    {
        return this.isDragging() && System.currentTimeMillis() - this.time > 150;
    }

    /**
     * Set the value of the field. The input value would be rounded up to 3
     * decimal places.
     */
    public void setValue(double value)
    {
        this.setValueInternal(value);
        this.field.setText(this.integer ? String.valueOf((int) this.value) : FORMAT.format(this.value));
        this.field.setCursorPositionZero();
    }

    private void setValueInternal(double value)
    {
        value = Double.valueOf(this.getRoundingFormat().format(value));
        value = MathUtils.clamp(value, this.min, this.max);

        if (this.integer)
        {
            value = (int) value;
        }

        this.value = value;
    }

    /**
     * Set value of this field and also notify the trackpad listener so it
     * could detect the value change.
     */
    public void setValueAndNotify(double value)
    {
        this.setValue(value);

        if (this.callback != null)
        {
            this.callback.accept(this.value);
        }
    }

    @Override
    public void unfocus(GuiContext context)
    {
        super.unfocus(context);

        /* Reset the value in case it's out of range */
        this.setValue(this.value);

        this.field.setText(this.integer ? String.valueOf((int) this.value) : FORMAT.format(this.value));
    }

    @Override
    public void focus(GuiContext context)
    {
        super.focus(context);

        int valueint = (int) this.value;

        this.field.setText(this.integer ? String.valueOf(valueint) : (this.value % 1 == 0) ? String.valueOf(valueint) : String.valueOf(this.value));
        this.field.setCursorPositionZero();
    }

    /**
     * Update the bounding box of this GUI field
     */
    @Override
    public void resize()
    {
        super.resize();

        this.plusOne.copy(this.area);
        this.minusOne.copy(this.area);
        this.plusOne.w = this.minusOne.w = 20;
        this.plusOne.x = this.area.ex() - 20;
    }

    /**
     * Delegates mouse click to text field and initiate value dragging if the
     * cursor inside of trackpad's bounding box.
     */
    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (context.mouseButton == 0)
        {
            boolean wasFocused = this.field.isFocused();

            this.field.mouseClicked(context.mouseX, context.mouseY, context.mouseButton);

            if (wasFocused != this.field.isFocused())
            {
                context.focus(wasFocused ? null : this);
            }

            if (this.area.isInside(context))
            {
                if (Keyboard.isKeyDown(Keyboard.KEY_LCONTROL))
                {
                    this.setValueAndNotify(Math.round(this.value));

                    return true;
                }

                if (!this.field.isFocused() && !(this.plusOne.isInside(context) || this.minusOne.isInside(context)))
                {
                    context.focus(this);
                }

                if (!this.dragging)
                {
                    valueBeforeDrag = this.value;
                }

                this.dragging = true;
                context.awaitsRightClick = true;
                this.initialX = context.mouseX;
                this.initialY = context.mouseY;
                this.lastValue = this.value;
                this.time = System.currentTimeMillis();
            }
        }

        /* release dragging and reset to what was before dragging, when right clicking */
        if (context.mouseButton == 1 && this.dragging)
        {
            this.setValueAndNotify(this.valueBeforeDrag);

            this.stopDragging(context);

            return true;
        }

        return context.mouseButton == 0 && this.area.isInside(context);
    }

    /**
     * Reset value dragging
     */
    @Override
    public void mouseReleased(GuiContext context)
    {
        if (this.dragging && !this.isDraggingTime() && context.mouseButton == 0 && McLib.enableTrackpadIncrements.get())
        {
            if (this.plusOne.isInside(context))
            {
                this.setValueAndNotify(this.value + this.increment);
            }
            else if (this.minusOne.isInside(context))
            {
                this.setValueAndNotify(this.value - this.increment);
            }
        }

        this.stopDragging(context);

        super.mouseReleased(context);
    }

    protected void stopDragging(GuiContext context)
    {
        this.dragging = false;
        this.shiftX = 0;
        context.awaitsRightClick = false;
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (this.isFocused())
        {
            if (context.keyCode == Keyboard.KEY_UP)
            {
                this.setValueAndNotify(this.value + this.getValueModifier());

                return true;
            }
            else if (context.keyCode == Keyboard.KEY_DOWN)
            {
                this.setValueAndNotify(this.value - this.getValueModifier());

                return true;
            }
            else if (context.keyCode == Keyboard.KEY_TAB)
            {
                context.focus(this, -1, GuiScreen.isShiftKeyDown() ? -1 : 1);

                return true;
            }
            else if (context.keyCode == Keyboard.KEY_ESCAPE)
            {
                context.unfocus();

                return true;
            }
            else if (context.keyCode == Keyboard.KEY_RETURN && GuiScreen.isAltKeyDown())
            {
                try
                {
                    MathBuilder builder = new MathBuilder();

                    this.setValueAndNotify(builder.parse(this.field.getText()).get().doubleValue());
                }
                catch (Exception e)
                {}
            }
        }

        String old = this.field.getText();
        boolean result = this.field.textboxKeyTyped(context.typedChar, context.keyCode);
        String text = this.field.getText();

        if (this.field.isFocused() && !text.equals(old))
        {
            try
            {
                this.setValueInternal(text.isEmpty() ? 0 : Double.parseDouble(text));

                if (this.callback != null)
                {
                    this.callback.accept(this.value);
                }
            }
            catch (Exception e)
            {}
        }

        return result;
    }

    /**
     * Draw the trackpad
     *
     * This method will not only draw the text box, background and title label,
     * but also dragging the numerical value based on the mouse input.
     */
    @Override
    public void draw(GuiContext context)
    {
        int x = this.area.x;
        int y = this.area.y;
        int w = this.area.w;
        int h = this.area.h;
        int padding = McLib.enableBorders.get() ? 1 : 0;

        this.area.draw(0xff000000);

        boolean dragging = this.isDraggingTime();
        boolean plus = !dragging && this.plusOne.isInside(context);
        boolean minus = !dragging && this.minusOne.isInside(context);

        if (dragging)
        {
            /* Draw filling background */
            int color = McLib.primaryColor.get();
            int fx = MathUtils.clamp(context.mouseX, this.area.x + padding, this.area.ex() - padding);

            Gui.drawRect(Math.min(fx, this.initialX), this.area.y + padding, Math.max(fx, this.initialX), this.area.ey() - padding, 0xff000000 + color);
        }

        if (McLib.enableTrackpadIncrements.get())
        {
            GlStateManager.alphaFunc(GL11.GL_GREATER, 0);
            this.plusOne.draw(plus ? 0x22ffffff : 0x0affffff, padding);
            this.minusOne.draw(minus ? 0x22ffffff : 0x0affffff, padding);
            GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);

            GlStateManager.enableBlend();
            ColorUtils.bindColor(minus ? 0xffffffff : 0x80ffffff);
            Icons.MOVE_LEFT.render(x + 5, y + (h - 16) / 2);
            ColorUtils.bindColor(plus ? 0xffffffff : 0x80ffffff);
            Icons.MOVE_RIGHT.render(x + w - 13, y + (h - 16) / 2);
            GlStateManager.disableBlend();
        }

        int width = MathUtils.clamp(this.font.getStringWidth(this.field.getText()), 0, w - 16);

        this.field.x = this.area.mx(width);
        this.field.y = this.area.my() - 4;
        this.field.width = width + 6;
        this.field.height = 9;
        this.field.drawTextBox();

        if (dragging)
        {
            double factor = Math.ceil(this.mc.displayWidth / (double) context.screen.width);
            int mouseX = context.globalX(context.mouseX);

            /* Mouse doesn't change immediately the next frame after Mouse.setCursorPosition(),
             * so this is a hack that stops for double shifting */
            if (this.changed.isTime())
            {
                final int border = 5;
                final int borderPadding = border + 1;
                boolean stop = false;

                if (mouseX <= border)
                {
                    Mouse.setCursorPosition(this.mc.displayWidth - (int) (factor * borderPadding), Mouse.getY());

                    this.shiftX -= context.screen.width - borderPadding * 2;
                    this.changed.mark();
                    stop = true;
                }
                else if (mouseX >= context.screen.width - border)
                {
                    Mouse.setCursorPosition((int) (factor * borderPadding), Mouse.getY());

                    this.shiftX += context.screen.width - borderPadding * 2;
                    this.changed.mark();
                    stop = true;
                }

                if (!stop)
                {
                    if (this.isFocused())
                    {
                        context.unfocus();
                    }

                    int dx = (this.shiftX + context.mouseX) - this.initialX;

                    if (dx != 0)
                    {
                        double value = this.getValueModifier();

                        double diff = (Math.abs(dx) - 3) * value;
                        double newValue = this.lastValue + (dx < 0 ? -diff : diff);

                        newValue = diff < 0 ? this.lastValue : Double.valueOf(this.getRoundingFormat().format(newValue));;

                        if (this.value != newValue)
                        {
                            this.setValueAndNotify(MathUtils.clamp(newValue, this.min, this.max));
                        }
                    }
                }
            }

            /* Draw active element */
            GuiDraw.drawOutlineCenter(this.initialX, this.initialY, 4, 0xffffffff);
        }

        GuiDraw.drawLockedArea(this);

        super.draw(context);
    }

    protected double getValueModifier()
    {
        double value = this.normal;

        if (Keyboard.isKeyDown(Keyboard.KEY_LSHIFT))
        {
            value = this.strong;
        }
        else if (Keyboard.isKeyDown(Keyboard.KEY_LCONTROL))
        {
            value = this.increment;
        }
        else if (Keyboard.isKeyDown(Keyboard.KEY_LMENU))
        {
            value = this.weak;
        }

        return value;
    }

    public DecimalFormat getRoundingFormat()
    {
        return this.getRoundingFormat(false);
    }

    /**
     * Get the rounding format according to McLib's configuration of trackpadDecimalPlaces
     * @param force true to recalculate the rounding format forcefully
     * @return the rounding format
     */
    private DecimalFormat getRoundingFormat(boolean force)
    {
        if (this.decimalPlaces != McLib.trackpadDecimalPlaces.get() || force) //to save performance
        {
            String decimals = "";

            for(int i = 0; i < McLib.trackpadDecimalPlaces.get(); i++)
            {
                decimals += "#";
            }

            this.rounding = new DecimalFormat("#."+decimals);
            this.decimalPlaces = McLib.trackpadDecimalPlaces.get();

            this.rounding.setRoundingMode(RoundingMode.HALF_EVEN);
        }

        return this.rounding;
    }
}

==================================================

--- Файл №34 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\GuiTransformations.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input;

import java.util.function.Consumer;

import javax.vecmath.Matrix4f;
import javax.vecmath.Vector3d;
import javax.vecmath.Vector3f;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.MatrixUtils.Transformation;
import mchorse.mclib.utils.MatrixUtils.RotationOrder;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.resources.I18n;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagDouble;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.common.util.Constants;

/**
 * Transformation editor GUI
 * 
 * Must be exactly 190 by 70 (with extra 12 on top for labels)
 */
public class GuiTransformations extends GuiElement
{
    public GuiTrackpadElement tx;
    public GuiTrackpadElement ty;
    public GuiTrackpadElement tz;
    public GuiTrackpadElement localtx;
    public GuiTrackpadElement localty;
    public GuiTrackpadElement localtz;
    public GuiTrackpadElement sx;
    public GuiTrackpadElement sy;
    public GuiTrackpadElement sz;
    public GuiTrackpadElement rx;
    public GuiTrackpadElement ry;
    public GuiTrackpadElement rz;
    public GuiToggleElement one;
    
    public GuiTrackpadElement drx;
    public GuiTrackpadElement dry;
    public GuiTrackpadElement drz;
    public GuiToggleElement origin;
    public GuiCirculateElement orientation;

    /**
     * Used to update the fields when the static orientation changes.
     */
    protected TransformOrientation orientationCache;
    protected GuiElement first;
    protected GuiElement second;
    protected GuiElement third;

    public GuiTransformations(Minecraft mc)
    {
        super(mc);

        this.tx = new GuiTrackpadElement(mc, (value) -> this.internalSetT(value, this.ty.value, this.tz.value)).block();
        this.tx.tooltip(IKey.lang("mclib.gui.transforms.x"));
        this.ty = new GuiTrackpadElement(mc, (value) -> this.internalSetT(this.tx.value, value, this.tz.value)).block();
        this.ty.tooltip(IKey.lang("mclib.gui.transforms.y"));
        this.tz = new GuiTrackpadElement(mc, (value) -> this.internalSetT(this.tx.value, this.ty.value, value)).block();
        this.tz.tooltip(IKey.lang("mclib.gui.transforms.z"));

        this.sx = new GuiTrackpadElement(mc, (value) ->
        {
            boolean one = this.one.isToggled();

            this.internalSetS(value, one ? value : this.sy.value, one ? value : this.sz.value);
        });
        this.sx.tooltip(IKey.lang("mclib.gui.transforms.x"));
        this.sy = new GuiTrackpadElement(mc, (value) -> this.internalSetS(this.sx.value, value, this.sz.value));
        this.sy.tooltip(IKey.lang("mclib.gui.transforms.y"));
        this.sz = new GuiTrackpadElement(mc, (value) -> this.internalSetS(this.sx.value, this.sy.value, value));
        this.sz.tooltip(IKey.lang("mclib.gui.transforms.z"));

        this.rx = new GuiTrackpadElement(mc, (value) -> this.internalSetR(value, this.ry.value, this.rz.value)).degrees();
        this.rx.tooltip(IKey.lang("mclib.gui.transforms.x"));
        this.ry = new GuiTrackpadElement(mc, (value) -> this.internalSetR(this.rx.value, value, this.rz.value)).degrees();
        this.ry.tooltip(IKey.lang("mclib.gui.transforms.y"));
        this.rz = new GuiTrackpadElement(mc, (value) -> this.internalSetR(this.rx.value, this.ry.value, value)).degrees();
        this.rz.tooltip(IKey.lang("mclib.gui.transforms.z"));
        this.one = new GuiToggleElement(mc, IKey.EMPTY, false, (b) ->
        {
            boolean one = b.isToggled();

            this.updateScaleFields();

            if (!one)
            {
                this.sy.setValueAndNotify(this.sx.value);
                this.sz.setValueAndNotify(this.sx.value);
            }
        });

        this.one.flex().relative(this.sx).x(1F).y(-13).wh(11, 11).anchorX(1F);
        
        this.drx = new GuiRelativeTrackpadElement(mc, (value) -> this.deltaRotate(value, 0, 0), IKey.str("Rx")).degrees();
        this.dry = new GuiRelativeTrackpadElement(mc, (value) -> this.deltaRotate(0, value, 0), IKey.str("Ry")).degrees();
        this.drz = new GuiRelativeTrackpadElement(mc, (value) -> this.deltaRotate(0, 0, value), IKey.str("Rz")).degrees();
        this.origin = new GuiToggleElement(mc, IKey.EMPTY, false, null);
        this.origin.flex().relative(this.drx).x(1F).y(-13).wh(11, 11).anchorX(1F);
        this.origin.tooltip(IKey.lang("mclib.gui.transforms.delta.origin"));

        this.localtx = new GuiRelativeTrackpadElement(mc, (value) -> this.localTranslate(value, 0, 0), IKey.str("X")).block();
        this.localty = new GuiRelativeTrackpadElement(mc, (value) -> this.localTranslate(0, value, 0), IKey.str("Y")).block();
        this.localtz = new GuiRelativeTrackpadElement(mc, (value) -> this.localTranslate(0, 0, value), IKey.str("Z")).block();
        this.orientation = new GuiStaticTransformOrientation(mc, (value) ->
        {
            this.updateFields();
        });
        this.orientation.addLabel(IKey.lang("mclib.gui.transforms.orientation.global"));
        this.orientation.addLabel(IKey.lang("mclib.gui.transforms.orientation.local"));
        this.orientation.tooltip(IKey.lang("mclib.gui.transforms.orientation.tooltip"));
        this.orientation.flex().relative(this.tx).set(0, -44, 60, 20);
        
        this.first = new GuiElement(mc);
        this.second = new GuiElement(mc);
        this.third = new GuiElement(mc);

        this.first.flex().relative(this).w(1.25F).h(20).row(5).height(20);
        this.first.add(this.tx, sx, rx, drx);

        this.second.flex().relative(this).y(0.5F, -10).w(1.25F).h(20).row(5).height(20);
        this.second.add(this.ty, sy, ry, dry);

        this.third.flex().relative(this).y(1F, -20).w(1.25F).h(20).row(5).height(20);
        this.third.add(this.tz, sz, rz, drz);

        this.add(this.first, this.second, this.third, this.orientation, this.one, this.origin);
    }

    protected void updateFields()
    {
        this.tx.removeFromParent();
        this.ty.removeFromParent();
        this.tz.removeFromParent();
        this.localtx.removeFromParent();
        this.localty.removeFromParent();
        this.localtz.removeFromParent();

        if (GuiStaticTransformOrientation.getOrientation() == TransformOrientation.GLOBAL)
        {
            this.first.addBefore(this.sx, this.tx);
            this.second.addBefore(this.sy, this.ty);
            this.third.addBefore(this.sz, this.tz);
        }
        else if (GuiStaticTransformOrientation.getOrientation() == TransformOrientation.LOCAL)
        {
            this.first.addBefore(this.sx, this.localtx);
            this.second.addBefore(this.sy, this.localty);
            this.third.addBefore(this.sz, this.localtz);
        }

        this.parent.resize();
    }

    public void resetScale()
    {
        this.one.toggled(false);
        this.updateScaleFields();
    }

    public void updateScaleFields()
    {
        this.sy.setVisible(!this.one.isToggled());
        this.sz.setVisible(!this.one.isToggled());
    }

    public void fillSetT(double x, double y, double z)
    {
        this.fillT(x, y, z);
        this.setT(x, y, z);
    }

    public void fillSetS(double x, double y, double z)
    {
        this.fillS(x, y, z);
        this.setS(x, y, z);
    }

    public void fillSetR(double x, double y, double z)
    {
        this.fillR(x, y, z);
        this.setR(x, y, z);
    }

    public void fillT(double x, double y, double z)
    {
        this.tx.setValue(x);
        this.ty.setValue(y);
        this.tz.setValue(z);
    }

    public void fillS(double x, double y, double z)
    {
        this.resetScale();

        this.sx.setValue(x);
        this.sy.setValue(y);
        this.sz.setValue(z);
    }

    public void fillR(double x, double y, double z)
    {
        this.rx.setValue(x);
        this.ry.setValue(y);
        this.rz.setValue(z);
    }
    
    private void internalSetT(double x, double y, double z)
    {
        try
        {
            this.setT(x, y, z);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private void internalSetS(double x, double y, double z)
    {
        try
        {
            this.setS(x, y, z);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private void internalSetR(double x, double y, double z)
    {
        try
        {
            this.setR(x, y, z);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    public void setT(double x, double y, double z)
    {}

    public void setS(double x, double y, double z)
    {}

    public void setR(double x, double y, double z)
    {}

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(context.mc);
        NBTTagList transforms = null;

        try
        {
            NBTTagCompound tag = JsonToNBT.getTagFromJson("{Transforms:"+ GuiScreen.getClipboardString()+"}");
            NBTTagList list = tag.getTagList("Transforms", Constants.NBT.TAG_DOUBLE);

            if (list.tagCount() >= 9)
            {
                transforms = list;
            }
        }
        catch (Exception e)
        {}

        menu.action(Icons.COPY, IKey.lang("mclib.gui.transforms.context.copy"), () -> this.copyTransformations());

        if (transforms != null)
        {
            final NBTTagList innerList = transforms;

            menu.action(Icons.PASTE, IKey.lang("mclib.gui.transforms.context.paste"), () -> this.pasteAll(innerList));
            menu.action(Icons.ALL_DIRECTIONS, IKey.lang("mclib.gui.transforms.context.paste_translation"), () -> this.pasteTranslation(innerList));
            menu.action(Icons.MAXIMIZE, IKey.lang("mclib.gui.transforms.context.paste_scale"), () -> this.pasteScale(innerList));
            menu.action(Icons.REFRESH, IKey.lang("mclib.gui.transforms.context.paste_rotation"), () -> this.pasteRotation(innerList));
        }

        menu.action(Icons.CLOSE, IKey.lang("mclib.gui.transforms.context.reset"), this::reset);

        return menu;
    }

    private void copyTransformations()
    {
        NBTTagList list = new NBTTagList();

        list.appendTag(new NBTTagDouble(this.tx.value));
        list.appendTag(new NBTTagDouble(this.ty.value));
        list.appendTag(new NBTTagDouble(this.tz.value));
        list.appendTag(new NBTTagDouble(this.sx.value));
        list.appendTag(new NBTTagDouble(this.sy.value));
        list.appendTag(new NBTTagDouble(this.sz.value));
        list.appendTag(new NBTTagDouble(this.rx.value));
        list.appendTag(new NBTTagDouble(this.ry.value));
        list.appendTag(new NBTTagDouble(this.rz.value));

        GuiScreen.setClipboardString(list.toString());
    }

    public void pasteAll(NBTTagList list)
    {
        this.pasteTranslation(list);
        this.pasteScale(list);
        this.pasteRotation(list);
    }

    public void pasteTranslation(NBTTagList list)
    {
        Vector3d translation = this.getVector(list, 0);

        this.tx.setValue(translation.x);
        this.ty.setValue(translation.y);
        this.tz.setValueAndNotify(translation.z);
    }

    public void pasteScale(NBTTagList list)
    {
        Vector3d scale = this.getVector(list, 3);

        this.sz.setValue(scale.z);
        this.sy.setValue(scale.y);
        this.sx.setValueAndNotify(scale.x);
    }

    public void pasteRotation(NBTTagList list)
    {
        Vector3d rotation = this.getVector(list, 6);

        this.rx.setValue(rotation.x);
        this.ry.setValue(rotation.y);
        this.rz.setValueAndNotify(rotation.z);
    }

    private Vector3d getVector(NBTTagList list, int offset)
    {
        Vector3d result = new Vector3d();

        result.x = list.getDoubleAt(offset);
        result.y = list.getDoubleAt(offset + 1);
        result.z = list.getDoubleAt(offset + 2);

        return result;
    }

    protected void reset()
    {
        this.fillSetT(0, 0, 0);
        this.fillSetS(1, 1, 1);
        this.fillSetR(0, 0, 0);
    }
    
    protected void prepareRotation(Matrix4f mat)
    {
        Matrix4f rot = new Matrix4f();
        rot.rotZ((float) Math.toRadians(this.rz.value));
        mat.mul(rot);
        rot.rotY((float) Math.toRadians(this.ry.value));
        mat.mul(rot);
        rot.rotX((float) Math.toRadians(this.rx.value));
        mat.mul(rot);
    }
    
    protected void postRotation(Transformation transform)
    {
        Vector3f result = transform.getRotation(RotationOrder.XYZ, new Vector3f((float) this.rx.value, (float) this.ry.value, (float) this.rz.value));
        this.rx.setValueAndNotify(result.x);
        this.ry.setValueAndNotify(result.y);
        this.rz.setValueAndNotify(result.z);
    }

    protected void localTranslate(double x, double y, double z)
    { }

    protected void deltaRotate(double x, double y, double z)
    {
        Matrix4f mat = new Matrix4f();
        mat.setIdentity();
        if (this.origin.isToggled())
        {
            mat.m03 = (float) this.tx.value;
            mat.m13 = (float) this.ty.value;
            mat.m23 = (float) this.tz.value;
        }
        Matrix4f rot = new Matrix4f();
        rot.rotZ((float) Math.toRadians(z));
        mat.mul(rot, mat);
        rot.rotY((float) Math.toRadians(y));
        mat.mul(rot, mat);
        rot.rotX((float) Math.toRadians(x));
        mat.mul(rot, mat);
        prepareRotation(mat);
        Transformation transform = MatrixUtils.extractTransformations(null, mat);
        if (this.origin.isToggled())
        {
            Vector3f result = transform.getTranslation3f();
            this.tx.setValueAndNotify(result.x);
            this.ty.setValueAndNotify(result.y);
            this.tz.setValueAndNotify(result.z);
        }
        postRotation(transform);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.font.drawStringWithShadow(I18n.format("mclib.gui.transforms.translate"), this.tx.area.x, this.tx.area.y - 12, 0xffffff);
        this.font.drawStringWithShadow(I18n.format("mclib.gui.transforms.scale"), this.sx.area.x, this.sx.area.y - 12, 0xffffff);
        this.font.drawStringWithShadow(I18n.format("mclib.gui.transforms.rotate"), this.rx.area.x, this.rx.area.y - 12, 0xffffff);

        if (this.orientationCache != GuiStaticTransformOrientation.getOrientation())
        {
            this.updateFields();
        }

        this.orientationCache = GuiStaticTransformOrientation.getOrientation();

        if (McLib.renderTranslateTextColors.get())
        {
            this.tx.setTextColor(new Color(1,0.5F,0.5F));
            this.ty.setTextColor(new Color(0.5F,1,0.5F));
            this.tz.setTextColor(new Color(0.5F,0.5F,1));

            this.localtx.setTextColor(new Color(1,0.5F,0.5F));
            this.localty.setTextColor(new Color(0.5F,1,0.5F));
            this.localtz.setTextColor(new Color(0.5F,0.5F,1));
        }
        else
        {
            Color color = new Color(14737632);

            this.tx.setTextColor(color);
            this.ty.setTextColor(color);
            this.tz.setTextColor(color);
            this.localtx.setTextColor(color);
            this.localty.setTextColor(color);
            this.localtz.setTextColor(color);
        }

        super.draw(context);
    }
    
    public static class GuiRelativeTrackpadElement extends GuiTrackpadElement
    {
        public IKey label;
        public double lastValue;
        
        public GuiRelativeTrackpadElement(Minecraft mc, Consumer<Double> callback, IKey label)
        {
            super(mc, callback);
            this.label = label;
            this.setText(label.get());
            this.setTextColor(0xE0E0E0);
        }

        @Override
        public void mouseReleased(GuiContext context)
        {
            super.mouseReleased(context);
            this.lastValue = 0;
            this.setValue(0);
            this.setText(this.label.get());
        }

        @Override
        public void setValueAndNotify(double value)
        {
            this.setValue(value);

            if (this.callback != null)
            {
                this.callback.accept(this.value - this.lastValue);
                this.lastValue = this.value;
            }
        }
    }

    /**
     * A GuiCirculateElement that has a static value. This class overrides the methods that access the value attribute
     */
    public static class GuiStaticTransformOrientation extends GuiCirculateElement
    {
        protected static int value = 0;

        public GuiStaticTransformOrientation(Minecraft mc, Consumer<GuiCirculateElement> callback)
        {
            super(mc, callback);
        }

        public static TransformOrientation getOrientation()
        {
            return TransformOrientation.values()[value];
        }

        @Override
        public int getValue()
        {
            return value;
        }

        @Override
        public String getLabel()
        {
            return this.labels.get(value).get();
        }

        @Override
        public void setValue(int newValue, int direction)
        {
            value = newValue;

            if (this.disabled.contains(newValue))
            {
                this.setValue(newValue + direction, direction);

                return;
            }

            if (value > this.labels.size() - 1)
            {
                value = 0;
            }

            if (value < 0)
            {
                value = this.labels.size() - 1;
            }
        }

        @Override
        protected void click(int mouseButton)
        {
            int direction = mouseButton == 0 ? 1 : -1;

            this.setValue(value + direction, direction);

            if (this.callback != null)
            {
                this.callback.accept(this.get());
            }
        }
    }

    public enum TransformOrientation
    {
        GLOBAL,
        LOCAL
    }
}

==================================================

--- Файл №35 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\color\GuiColorPalette.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input.color;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;

import java.util.List;
import java.util.function.Consumer;

/**
 * Color palette GUI element
 *
 * This element allows to provide a way to select a color from a grid like
 * list
 */
public class GuiColorPalette extends GuiElement
{
    public List<Color> colors;
    public Consumer<Color> callback;
    public int cellSize = 10;

    public GuiColorPalette(Minecraft mc, Consumer<Color> callback)
    {
        super(mc);

        this.callback = callback;
    }

    public GuiColorPalette colors(List<Color> colors)
    {
        this.colors = colors;

        return this;
    }

    public GuiColorPalette cellSize(int cellSize)
    {
        this.cellSize = cellSize;

        return this;
    }

    public int getHeight(int width)
    {
        return MathUtils.gridRows(this.colors.size(), this.cellSize, width) * this.cellSize;
    }

    public boolean hasColor(int index)
    {
        return index >= 0 && index < this.colors.size();
    }

    public int getIndex(GuiContext context)
    {
        return this.colors.size() - 1 - this.area.getIndex(context.mouseX, context.mouseY, this.cellSize);
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.area.isInside(context) && context.mouseButton == 0)
        {
            int index = this.getIndex(context);

            if (this.hasColor(index) && this.callback != null)
            {
                this.callback.accept(this.colors.get(index));
            }

            return true;
        }

        return false;
    }

    @Override
    public void draw(GuiContext context)
    {
        /* Draw recent colors panel */
        int count = this.colors.size();

        if (count > 0)
        {
            int elements = this.area.w / this.cellSize;

            if (this.area.h > this.cellSize)
            {
                Icons.CHECKBOARD.renderArea(this.area.x, this.area.y, this.area.w, this.area.h - this.cellSize);
            }

            Icons.CHECKBOARD.renderArea(this.area.x, this.area.ey() - this.cellSize, count % elements * this.cellSize, this.cellSize);

            for (int i = count - 1, j = 0; i >= 0; i--, j++)
            {
                Color c = this.colors.get(i);
                int x = this.area.x + j % elements * this.cellSize;
                int y = this.area.y + j / elements * this.cellSize;

                GuiColorPicker.drawAlphaPreviewQuad(x, y, x + this.cellSize, y + this.cellSize, c);
            }
        }

        super.draw(context);
    }
}


==================================================

--- Файл №36 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\color\GuiColorPicker.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input.color;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import org.lwjgl.opengl.GL11;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

/**
 * Color picker element
 *
 * This is the one that is responsible for picking colors
 */
public class GuiColorPicker extends GuiElement
{
    public static final int COLOR_SLIDER_HEIGHT = 50;
    public static final IKey FAVORITE = IKey.lang("mclib.gui.color.favorite");
    public static final IKey RECENT = IKey.lang("mclib.gui.color.recent");

    public static List<Color> recentColors = new ArrayList<Color>();

    public Color color = new Color();
    public Consumer<Integer> callback;

    public GuiTextElement input;
    public GuiColorPalette recent;
    public GuiColorPalette favorite;

    public boolean editAlpha;

    public Area red = new Area();
    public Area green = new Area();
    public Area blue = new Area();
    public Area alpha = new Area();
    public Area preview = new Area();

    public int dragging = -1;

    public static void drawAlphaPreviewQuad(int x1, int y1, int x2, int y2, Color color)
    {
        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder vertexbuffer = tessellator.getBuffer();
        vertexbuffer.begin(GL11.GL_TRIANGLES, DefaultVertexFormats.POSITION_COLOR);
        vertexbuffer.pos(x1, y1, 0).color(color.r, color.g, color.b, 1).endVertex();
        vertexbuffer.pos(x1, y2, 0).color(color.r, color.g, color.b, 1).endVertex();
        vertexbuffer.pos(x2, y1, 0).color(color.r, color.g, color.b, 1).endVertex();
        vertexbuffer.pos(x2, y1, 0).color(color.r, color.g, color.b, color.a).endVertex();
        vertexbuffer.pos(x1, y2, 0).color(color.r, color.g, color.b, color.a).endVertex();
        vertexbuffer.pos(x2, y2, 0).color(color.r, color.g, color.b, color.a).endVertex();
        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.enableTexture2D();
    }

    public GuiColorPicker(Minecraft mc, Consumer<Integer> callback)
    {
        super(mc);

        this.callback = callback;

        this.input = new GuiTextElement(mc, 7, (string) ->
        {
            this.setValue(ColorUtils.parseColor(string));
            this.callback();
        });

        this.recent = new GuiColorPalette(mc, (color) ->
        {
            this.setColor(color.getRGBAColor());
            this.updateColor();
        }).colors(recentColors);

        this.recent.context(() ->
        {
            GuiContext context = GuiBase.getCurrent();
            int index = this.recent.getIndex(context);

            if (!this.recent.hasColor(index))
            {
                return null;
            }

            return new GuiSimpleContextMenu(Minecraft.getMinecraft())
                .action(Icons.FAVORITE, IKey.lang("mclib.gui.color.context.favorites.add"), () -> this.addToFavorites(this.recent.colors.get(index)));
        });

        this.favorite = new GuiColorPalette(mc, (color) ->
        {
            this.setColor(color.getRGBAColor());
            this.updateColor();
        }).colors(McLib.favoriteColors.getCurrentColors());

        this.favorite.context(() ->
        {
            GuiContext context = GuiBase.getCurrent();
            int index = this.favorite.getIndex(context);

            if (!this.favorite.hasColor(index))
            {
                return null;
            }

            return new GuiSimpleContextMenu(Minecraft.getMinecraft())
                .action(Icons.REMOVE, IKey.lang("mclib.gui.color.context.favorites.remove"), () -> this.removeFromFavorites(index));
        });

        this.input.flex().relative(this).set(5, 5, 0, 20).w(1, -35);
        this.favorite.flex().relative(this).xy(5, 95).w(1F, -10);
        this.recent.flex().relative(this.favorite).w(1F);

        this.hideTooltip().add(this.input, this.favorite, this.recent);
    }

    public GuiColorPicker editAlpha()
    {
        this.editAlpha = true;
        this.input.field.setMaxStringLength(9);

        return this;
    }

    public void updateField()
    {
        this.input.setText(this.color.stringify(this.editAlpha));
    }

    public void updateColor()
    {
        this.updateField();
        this.callback();
    }

    protected void callback()
    {
        if (this.callback != null)
        {
            this.callback.accept(this.editAlpha ? this.color.getRGBAColor() : this.color.getRGBColor());
        }
    }

    public void setColor(float r, float g, float b, float a)
    {
        this.color.set(r, g, b, a);
        this.updateField();
    }

    public void setColor(int color)
    {
        this.setValue(color);
        this.updateField();
    }

    public void setValue(int color)
    {
        this.color.set(color, this.editAlpha);
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        if (!this.preview.isInside(context))
        {
            return super.createContextMenu(context);
        }

        return new GuiSimpleContextMenu(this.mc)
            .action(Icons.FAVORITE, IKey.lang("mclib.gui.color.context.favorites.add"), () -> this.addToFavorites(this.color));
    }

    public void setup(int x, int y)
    {
        this.flex().xy(x, y);
        this.setupSize();
    }

    private void setupSize()
    {
        int width = 200;
        int recent = this.recent.colors.isEmpty() ? 0 : this.recent.getHeight(width - 10);
        int favorite = this.favorite.colors.isEmpty() ? 0 : this.favorite.getHeight(width - 10);
        int base = 85;

        base += favorite > 0 ? favorite + 15 : 0;
        base += recent > 0 ? recent + 15 : 0;

        this.flex().h(base);
        this.favorite.flex().h(favorite);
        this.recent.flex().h(recent);

        if (favorite > 0)
        {
            this.recent.flex().y(1F, 15);
        }
        else
        {
            this.recent.flex().y(0);
        }
    }

    /* Managing recent and favorite colors */

    private void addToRecent()
    {
        this.addColor(recentColors, this.color);
    }

    private void addToFavorites(Color color)
    {
        this.addColor(McLib.favoriteColors.getCurrentColors(), color);
        McLib.favoriteColors.saveLater();

        this.setupSize();
        this.resize();
    }

    private void removeFromFavorites(int index)
    {
        McLib.favoriteColors.getCurrentColors().remove(index);
        McLib.favoriteColors.saveLater();

        this.setupSize();
        this.resize();
    }

    private void addColor(List<Color> colors, Color color)
    {
        int i = colors.indexOf(color);

        if (i == -1)
        {
            colors.add(color.copy());
        }
        else
        {
            colors.add(colors.remove(i));
        }
    }

    /* GuiElement overrides */

    @Override
    public void resize()
    {
        super.resize();

        int c = this.editAlpha ? 4 : 3;
        int h = COLOR_SLIDER_HEIGHT / c;
        int w = this.area.w - 10;
        int remainder = COLOR_SLIDER_HEIGHT - h * c;
        int y = this.area.y + 30;

        this.preview.setPoints(this.area.ex() - 25, this.area.y + 5, this.area.ex() - 5, this.area.y + 25);
        this.red.set(this.area.x + 5, y, w, h);

        if (this.editAlpha)
        {
            this.green.set(this.area.x + 5, y + h, w, h);
            this.blue.set(this.area.x + 5, y + h + h, w, h + remainder);
            this.alpha.set(this.area.x + 5, y + COLOR_SLIDER_HEIGHT - h, w, h);
        }
        else
        {
            this.green.set(this.area.x + 5, y + h, w, h + remainder);
            this.blue.set(this.area.x + 5, y + COLOR_SLIDER_HEIGHT - h, w, h);
        }
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.red.isInside(context))
        {
            this.dragging = 1;

            return true;
        }
        else if (this.green.isInside(context))
        {
            this.dragging = 2;

            return true;
        }
        else if (this.blue.isInside(context))
        {
            this.dragging = 3;

            return true;
        }
        else if (this.alpha.isInside(context) && this.editAlpha)
        {
            this.dragging = 4;

            return true;
        }

        if (!this.area.isInside(context))
        {
            this.removeFromParent();
            this.addToRecent();

            return false;
        }
        else
        {
            return true;
        }
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);
        this.dragging = -1;
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.dragging >= 0)
        {
            float factor = (context.mouseX - (this.red.x + 7)) / (float) (this.red.w - 14);

            this.color.set(MathUtils.clamp(factor, 0, 1), this.dragging);
            this.updateColor();
        }

        int padding = GuiDraw.drawBorder(this.area, 0xffffffff);

        this.area.draw(0xffc6c6c6, padding + 1);
        this.drawRect(this.area.ex() - 25, this.area.y + 5, this.area.ex() - 5, this.area.y + 25);

        GuiDraw.drawOutline(this.area.ex() - 25, this.area.y + 5, this.area.ex() - 5, this.area.y + 25, 0x44000000);

        if (this.editAlpha)
        {
            Icons.CHECKBOARD.renderArea(this.alpha.x, this.red.y, this.alpha.w, this.alpha.ey() - this.red.y);
        }

        Color color = new Color();

        /* Draw red slider */
        color.copy(this.color);
        color.r = 0;
        int left = color.getRGBAColor();

        color.copy(this.color);
        color.r = 1;
        int right = color.getRGBAColor();

        GuiDraw.drawHorizontalGradientRect(this.red.x, this.red.y, this.red.ex(), this.red.ey(), left, right);

        /* Draw green slider */
        color.copy(this.color);
        color.g = 0;
        left = color.getRGBAColor();

        color.copy(this.color);
        color.g = 1;
        right = color.getRGBAColor();

        GuiDraw.drawHorizontalGradientRect(this.green.x, this.green.y, this.green.ex(), this.green.ey(), left, right);

        /* Draw blue slider */
        color.copy(this.color);
        color.b = 0;
        left = color.getRGBAColor();

        color.copy(this.color);
        color.b = 1;
        right = color.getRGBAColor();

        GuiDraw.drawHorizontalGradientRect(this.blue.x, this.blue.y, this.blue.ex(), this.blue.ey(), left, right);

        if (this.editAlpha)
        {
            /* Draw alpha slider */
            color.copy(this.color);
            color.a = 0;
            left = color.getRGBAColor();

            color.copy(this.color);
            color.a = 1;
            right = color.getRGBAColor();

            GuiDraw.drawHorizontalGradientRect(this.alpha.x, this.alpha.y, this.alpha.ex(), this.alpha.ey(), left, right);
        }

        GuiDraw.drawOutline(this.red.x, this.red.y, this.red.ex(), this.editAlpha ? this.alpha.ey() : this.blue.ey(), 0x44000000);

        this.drawMarker(this.red.x + 7 + (int) ((this.red.w - 14) * this.color.r), this.red.my());
        this.drawMarker(this.green.x + 7 + (int) ((this.green.w - 14) * this.color.g), this.green.my());
        this.drawMarker(this.blue.x + 7 + (int) ((this.blue.w - 14) * this.color.b), this.blue.my());

        if (this.editAlpha)
        {
            this.drawMarker(this.alpha.x + 7 + (int) ((this.alpha.w - 14) * this.color.a), this.alpha.my());
        }

        if (!this.favorite.colors.isEmpty())
        {
            this.font.drawString(FAVORITE.get(), this.favorite.area.x, this.favorite.area.y - 10, 0x888888);
        }

        if (!this.recent.colors.isEmpty())
        {
            this.font.drawString(RECENT.get(), this.recent.area.x, this.recent.area.y - 10, 0x888888);
        }

        super.draw(context);
    }

    public void drawRect(int x1, int y1, int x2, int y2)
    {
        if (this.editAlpha)
        {
            Icons.CHECKBOARD.renderArea(x1, y1,x2 - x1, y2 - y1);
            drawAlphaPreviewQuad(x1, y1, x2, y2, this.color);
        }
        else
        {
            Gui.drawRect(x1, y1, x2, y2, this.color.getRGBAColor());
        }
    }

    private void drawMarker(int x, int y)
    {
        Gui.drawRect(x - 4, y - 4, x + 4, y + 4, 0xff000000);
        Gui.drawRect(x - 3, y - 3, x + 3, y + 3, 0xffffffff);
        Gui.drawRect(x - 2, y - 2, x + 2, y + 2, 0xffc6c6c6);
    }
}

==================================================

--- Файл №37 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\input\multiskin\GuiMultiSkinEditor.java
--------------------
package mchorse.mclib.client.gui.framework.elements.input.multiskin;

import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiCanvasEditor;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.resources.FilteredResourceLocation;
import mchorse.mclib.utils.shaders.Shader;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import org.apache.commons.io.IOUtils;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL13;
import org.lwjgl.opengl.GL20;

import java.nio.charset.StandardCharsets;

public class GuiMultiSkinEditor extends GuiCanvasEditor
{
    public static Shader shader;
    public static int uTexture;
    public static int uTextureBackground;
    public static int uSize;
    public static int uFilters;
    public static int uColor;

    public GuiTexturePicker picker;
    public FilteredResourceLocation location;

    public GuiToggleElement autoSize;
    public GuiTrackpadElement sizeW;
    public GuiTrackpadElement sizeH;

    public GuiColorElement color;
    public GuiTrackpadElement scale;
    public GuiToggleElement scaleToLargest;
    public GuiTrackpadElement shiftX;
    public GuiTrackpadElement shiftY;

    public GuiTrackpadElement pixelate;
    public GuiToggleElement erase;

    public GuiMultiSkinEditor(Minecraft mc, GuiTexturePicker picker)
    {
        super(mc);

        this.picker = picker;

        this.autoSize = new GuiToggleElement(mc, IKey.lang("mclib.gui.multiskin.auto_size"), (toggle) ->
        {
            this.location.autoSize = toggle.isToggled();
            this.resizeCanvas();
        });
        this.autoSize.tooltip(IKey.lang("mclib.gui.multiskin.auto_size_tooltip"));
        this.sizeW = new GuiTrackpadElement(mc, (value) ->
        {
            this.location.sizeW = value.intValue();
            this.resizeCanvas();
        });
        this.sizeW.integer().limit(0).tooltip(IKey.lang("mclib.gui.multiskin.size_w"));
        this.sizeH = new GuiTrackpadElement(mc, (value) ->
        {
            this.location.sizeH = value.intValue();
            this.resizeCanvas();
        });
        this.sizeH.integer().limit(0).tooltip(IKey.lang("mclib.gui.multiskin.size_h"));

        this.color = new GuiColorElement(mc, (value) -> this.location.color = value);
        this.color.picker.editAlpha();
        this.color.direction(Direction.TOP).tooltip(IKey.lang("mclib.gui.multiskin.color"));
        this.scale = new GuiTrackpadElement(mc, (value) -> this.location.scale = value.floatValue());
        this.scale.limit(0).metric();
        this.scaleToLargest = new GuiToggleElement(mc, IKey.lang("mclib.gui.multiskin.scale_to_largest"), (toggle) -> this.location.scaleToLargest = toggle.isToggled());
        this.shiftX = new GuiTrackpadElement(mc, (value) -> this.location.shiftX = value.intValue());
        this.shiftX.integer();
        this.shiftY = new GuiTrackpadElement(mc, (value) -> this.location.shiftY = value.intValue());
        this.shiftY.integer();

        this.pixelate = new GuiTrackpadElement(mc, (value) -> this.location.pixelate = value.intValue());
        this.pixelate.integer().limit(1);
        this.erase = new GuiToggleElement(mc, IKey.lang("mclib.gui.multiskin.erase"), (toggle) -> this.location.erase = toggle.isToggled());
        this.erase.tooltip(IKey.lang("mclib.gui.multiskin.erase_tooltip"), Direction.TOP);

        this.editor.add(this.color);
        this.editor.add(Elements.label(IKey.lang("mclib.gui.multiskin.scale")).background(), this.scale, this.scaleToLargest);
        this.editor.add(Elements.label(IKey.lang("mclib.gui.multiskin.shift")).background(), this.shiftX, this.shiftY);
        this.editor.add(Elements.label(IKey.lang("mclib.gui.multiskin.pixelate")).background(), this.pixelate, this.erase);
        this.editor.add(Elements.label(IKey.lang("mclib.gui.multiskin.custom_size")).background(), this.autoSize, this.sizeW, this.sizeH);

        if (shader == null)
        {
            try
            {
                String vert = IOUtils.toString(this.getClass().getResourceAsStream("/assets/mclib/shaders/preview.vert"), StandardCharsets.UTF_8);
                String frag = IOUtils.toString(this.getClass().getResourceAsStream("/assets/mclib/shaders/preview.frag"), StandardCharsets.UTF_8);

                shader = new Shader();
                shader.compile(vert, frag, true);

                uTexture = GL20.glGetUniformLocation(shader.programId, "texture");
                uTextureBackground = GL20.glGetUniformLocation(shader.programId, "texture_background");
                uSize = GL20.glGetUniformLocation(shader.programId, "size");
                uFilters = GL20.glGetUniformLocation(shader.programId, "filters");
                uColor = GL20.glGetUniformLocation(shader.programId, "color");
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }

    public void resetView()
    {
        int w = 0;
        int h = 0;

        for (FilteredResourceLocation child : this.picker.multiRL.children)
        {
            this.mc.renderEngine.bindTexture(child.path);
            w = Math.max(w, child.getWidth(GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH)));
            h = Math.max(h, child.getHeight(GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT)));
        }

        this.setSize(w, h);
        this.color.picker.removeFromParent();
    }

    private void resizeCanvas()
    {
        int w = 0;
        int h = 0;

        for (FilteredResourceLocation child : this.picker.multiRL.children)
        {
            this.mc.renderEngine.bindTexture(child.path);
            w = Math.max(w, child.getWidth(GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH)));
            h = Math.max(h, child.getHeight(GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT)));
        }

        if (w != this.getWidth() || h != this.getHeight())
        {
            this.setSize(w, h);
        }
    }

    public void close()
    {
        this.color.picker.removeFromParent();
    }

    public void setLocation(FilteredResourceLocation location)
    {
        this.location = location;

        this.color.picker.setColor(location.color);
        this.scale.setValue(location.scale);
        this.scaleToLargest.toggled(location.scaleToLargest);
        this.shiftX.setValue(location.shiftX);
        this.shiftY.setValue(location.shiftY);

        this.pixelate.setValue(location.pixelate);
        this.erase.toggled(location.erase);

        this.autoSize.toggled(location.autoSize);
        this.sizeW.setValue(location.sizeW);
        this.sizeH.setValue(location.sizeH);
    }

    @Override
    protected void startDragging(GuiContext context)
    {
        super.startDragging(context);

        if (this.mouse == 0)
        {
            this.lastT = this.location.shiftX;
            this.lastV = this.location.shiftY;
        }
    }

    @Override
    protected void dragging(GuiContext context)
    {
        super.dragging(context);

        if (this.dragging && this.mouse == 0)
        {
            double dx = (context.mouseX - this.lastX) / this.scaleX.getZoom();
            double dy = (context.mouseY - this.lastY) / this.scaleY.getZoom();

            if (GuiScreen.isShiftKeyDown()) dx = 0;
            if (GuiScreen.isCtrlKeyDown()) dy = 0;

            this.location.shiftX = (int) (dx) + (int) this.lastT;
            this.location.shiftY = (int) (dy) + (int) this.lastV;

            this.shiftX.setValue(this.location.shiftX);
            this.shiftY.setValue(this.location.shiftY);
        }
    }

    @Override
    protected boolean shouldDrawCanvas(GuiContext context)
    {
        return this.picker.multiRL != null;
    }

    @Override
    protected void drawCanvasFrame(GuiContext context)
    {
        for (FilteredResourceLocation child : this.picker.multiRL.children)
        {
            this.mc.renderEngine.bindTexture(child.path);

            int ow = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_WIDTH);
            int oh = GL11.glGetTexLevelParameteri(GL11.GL_TEXTURE_2D, 0, GL11.GL_TEXTURE_HEIGHT);
            int ww = ow;
            int hh = oh;

            if (child.scaleToLargest)
            {
                ww = this.w;
                hh = this.h;
            }
            else if (child.scale != 1)
            {
                ww = (int) (ww * child.scale);
                hh = (int) (hh * child.scale);
            }

            if (ww > 0 && hh > 0)
            {
                Area area = this.calculate(-this.w / 2 + child.shiftX, -this.h / 2 + child.shiftY, -this.w / 2 + child.shiftX + ww, -this.h / 2 + child.shiftY + hh);

                if (child == this.picker.currentFRL)
                {
                    Gui.drawRect(area.x, area.y, area.ex(), area.ey(), 0x44ff0000);
                    GlStateManager.enableBlend();
                    GlStateManager.enableAlpha();
                }

                ColorUtils.bindColor(child.color);

                if (child.pixelate > 1 || child.erase)
                {
                    shader.bind();
                    GL20.glUniform1i(uTexture, 0);
                    GL20.glUniform1i(uTextureBackground, 5);
                    GL20.glUniform2f(uSize, ow, oh);
                    GL20.glUniform4f(uFilters, (float) child.pixelate, child.erase ? 1F : 0F, 0, 0);
                    GL20.glUniform4f(uColor, ColorUtils.COLOR.r, ColorUtils.COLOR.g, ColorUtils.COLOR.b, ColorUtils.COLOR.a);
                }

                GlStateManager.setActiveTexture(GL13.GL_TEXTURE5);
                this.mc.renderEngine.bindTexture(Icons.ICONS);
                GlStateManager.setActiveTexture(GL13.GL_TEXTURE0);

                GuiDraw.drawBillboard(area.x, area.y, 0, 0, area.w, area.h, area.w, area.h);

                if (child.pixelate > 1 || child.erase)
                {
                    shader.unbind();
                }
            }
        }
    }
}

==================================================

--- Файл №38 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\GuiDopeSheet.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.utils.keyframes.Keyframe;
import mchorse.mclib.utils.keyframes.KeyframeEasing;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.client.shader.Framebuffer;
import org.lwjgl.opengl.GL11;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

/**
 * Dope sheet editor
 *
 * This GUI element is responsible for editing mutliple keyframe channels
 * at the same time (however without editing the Y values of these individual
 * channels)
 */
public class GuiDopeSheet extends GuiKeyframeElement
{
    public static final int TOP_MARGIN = 15;

    public List<GuiSheet> sheets = new ArrayList<GuiSheet>();

    public GuiDopeSheet(Minecraft mc, Consumer<Keyframe> callback)
    {
        super(mc, callback);
    }

    /* Implementation of setters */

    @Override
    public void setTick(double tick, boolean opposite)
    {
        if (this.isMultipleSelected())
        {
            if (this.which == Selection.KEYFRAME)
            {
                tick = (long) tick;
            }

            double dx = tick - this.which.getX(this.getCurrent());

            for (GuiSheet sheet : this.sheets)
            {
                sheet.setTick(dx, this.which, opposite);
            }
        }
        else
        {
            this.which.setX(this.getCurrent(), tick, opposite);
        }

        this.sliding = true;
    }

    @Override
    public void setValue(double value, boolean opposite)
    {
        if (this.isMultipleSelected())
        {
            double dy = value - this.which.getY(this.getCurrent());

            for (GuiSheet sheet : this.sheets)
            {
                sheet.setValue(dy, this.which, opposite);
            }
        }
        else
        {
            this.which.setY(this.getCurrent(), value, opposite);
        }
    }

    @Override
    public void setInterpolation(KeyframeInterpolation interp)
    {
        for (GuiSheet sheet : this.sheets)
        {
            sheet.setInterpolation(interp);
        }
    }

    @Override
    public void setEasing(KeyframeEasing easing)
    {
        for (GuiSheet sheet : this.sheets)
        {
            sheet.setEasing(easing);
        }
    }

    /* Graphing code */

    @Override
    public void resetView()
    {
        int c = 0;

        this.scaleX.set(0, 2);

        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;

        /* Find minimum and maximum */
        for (GuiSheet sheet : this.sheets)
        {
            for (Keyframe frame : sheet.channel.getKeyframes())
            {
                min = Integer.min((int) frame.tick, min);
                max = Integer.max((int) frame.tick, max);
            }

            c = Math.max(c, sheet.channel.getKeyframes().size());
        }

        if (c <= 1)
        {
            if (c == 0)
            {
                min = 0;
            }

            max = this.duration;
        }

        if (Math.abs(max - min) > 0.01F)
        {
            this.scaleX.viewOffset(min, max, this.area.w, 20);
        }
    }

    @Override
    public Keyframe getCurrent()
    {
        GuiSheet current = this.getCurrentSheet();

        return current == null ? null : current.getKeyframe();
    }

    @Override
    public List<GuiSheet> getSheets()
    {
        return this.sheets;
    }

    @Override
    public GuiSheet getSheet(int mouseY)
    {
        int sheetCount = this.sheets.size();
        int h = (this.area.h - TOP_MARGIN) / sheetCount;

        for (int i = 0; i < sheetCount; i++)
        {
            GuiSheet sheet = this.sheets.get(i);
            int y = this.area.y + h * i + TOP_MARGIN;

            if (mouseY >= y && mouseY < y + h)
            {
                return sheet;
            }
        }

        return null;
    }

    @Override
    public void selectAll()
    {
        for (GuiSheet sheet : this.sheets)
        {
            sheet.selectAll();
        }

        this.which = Selection.KEYFRAME;
        this.setKeyframe(this.getCurrent());
    }

    public GuiSheet getCurrentSheet()
    {
        for (GuiSheet sheet : this.sheets)
        {
            if (!sheet.selected.isEmpty())
            {
                return sheet;
            }
        }

        return null;
    }

    @Override
    public int getSelectedCount()
    {
        int i = 0;

        for (GuiSheet sheet : this.sheets)
        {
            i += sheet.getSelectedCount();
        }

        return i;
    }

    @Override
    public void clearSelection()
    {
        this.which = Selection.NOT_SELECTED;

        for (GuiSheet sheet : this.sheets)
        {
            sheet.clearSelection();
        }
    }

    @Override
    public void addCurrent(int mouseX, int mouseY)
    {
        int sheetCount = this.sheets.size();
        int h = (this.area.h - TOP_MARGIN) / sheetCount;
        int i = (mouseY - (this.area.ey() - h * sheetCount)) / h;

        if (i < 0 || i >= sheetCount)
        {
            return;
        }

        GuiSheet sheet = this.sheets.get(i);
        KeyframeEasing easing = KeyframeEasing.IN;
        KeyframeInterpolation interp = KeyframeInterpolation.LINEAR;
        Keyframe frame = this.getCurrent();
        long tick = (long) this.fromGraphX(mouseX);
        long oldTick = tick;

        if (frame != null)
        {
            easing = frame.easing;
            interp = frame.interp;
            oldTick = frame.tick;
        }

        sheet.selected.clear();
        sheet.selected.add(sheet.channel.insert(tick, sheet.channel.interpolate(tick)));
        frame = this.getCurrent();

        if (oldTick != tick)
        {
            frame.setEasing(easing);
            frame.setInterpolation(interp);
        }

        this.addedDoubleClick(frame, tick, mouseX, mouseY);
    }

    protected void addedDoubleClick(Keyframe frame, long tick, int mouseX, int mouseY)
    {}

    @Override
    public void removeCurrent()
    {
        Keyframe frame = this.getCurrent();

        if (frame == null)
        {
            return;
        }

        GuiSheet current = this.getCurrentSheet();

        current.channel.remove(current.selected.get(0));
        current.selected.clear();
        this.which = Selection.NOT_SELECTED;
    }

    @Override
    public void removeSelectedKeyframes()
    {
        for (GuiSheet sheet : this.sheets)
        {
            sheet.removeSelectedKeyframes();
        }

        this.setKeyframe(null);
        this.which = Selection.NOT_SELECTED;
    }

    /* Mouse input handling */

    @Override
    protected void duplicateKeyframe(GuiContext context, int mouseX, int mouseY)
    {
        long offset = (long) this.fromGraphX(mouseX);

        for (GuiSheet sheet : this.sheets)
        {
            sheet.duplicate(offset);
        }

        this.setKeyframe(this.getCurrent());
    }

    @Override
    protected boolean pickKeyframe(GuiContext context, int mouseX, int mouseY, boolean shift)
    {
        int sheetCount = this.sheets.size();
        int h = (this.area.h - TOP_MARGIN) / sheetCount;
        int y = this.area.ey() - h * sheetCount;
        boolean alt = GuiScreen.isAltKeyDown();
        boolean finished = false;
        boolean isMultiSelect = this.isMultipleSelected();

        for (GuiSheet sheet : this.sheets)
        {
            int index = 0;
            int count = sheet.channel.getKeyframes().size();
            Keyframe prev = null;

            for (Keyframe frame : sheet.channel.getKeyframes())
            {
                boolean left = sheet.handles && prev != null && prev.interp == KeyframeInterpolation.BEZIER && this.isInside(this.toGraphX(frame.tick - frame.lx), y + h / 2, mouseX, mouseY);
                boolean right = sheet.handles && frame.interp == KeyframeInterpolation.BEZIER && this.isInside(this.toGraphX(frame.tick + frame.rx), y + h / 2, mouseX, mouseY) && index != count - 1;
                boolean point = this.isInside(this.toGraphX(frame.tick), alt ? mouseY : y + h / 2, mouseX, mouseY);

                if (left || right || point)
                {
                    int key = sheet.selected.indexOf(index);

                    if (!shift && key == -1 && !alt)
                    {
                        this.clearSelection();
                    }

                    Selection which = left ? Selection.LEFT_HANDLE : (right ? Selection.RIGHT_HANDLE : Selection.KEYFRAME);

                    if (!shift || which == this.which)
                    {
                        this.which = which;

                        if (shift && isMultiSelect && key != -1)
                        {
                            sheet.selected.remove(key);
                            frame = this.getCurrent();
                        }
                        else if (key == -1)
                        {
                            sheet.selected.add(index);
                            frame = isMultiSelect ? this.getCurrent() : frame;
                        }
                        else
                        {
                            frame = this.getCurrent();
                        }

                        this.setKeyframe(frame);
                    }

                    if (frame != null)
                    {
                        this.lastT = left ? frame.tick - frame.lx : (right ? frame.tick + frame.rx : frame.tick);
                        this.lastV = left ? frame.value + frame.ly : (right ? frame.value + frame.ry : frame.value);
                    }

                    if (alt)
                    {
                        if (frame != null)
                        {
                            finished = true;
                        }
                    }
                    else
                    {
                        return true;
                    }
                }

                prev = frame;
                index++;
            }

            y += h;
        }

        return finished;
    }

    private boolean isInside(double x, double y, int mouseX, int mouseY)
    {
        double d = Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2);

        return Math.sqrt(d) < 4;
    }

    @Override
    protected void postSlideSort(GuiContext context)
    {
        /* Resort after dragging the tick thing */
        for (GuiSheet sheet : this.sheets)
        {
            if (!sheet.selected.isEmpty())
            {
                sheet.sort();
            }
        }

        this.sliding = false;
    }

    @Override
    protected void resetMouseReleased(GuiContext context)
    {
        if (this.isGrabbing())
        {
            /* Multi select */
            Area area = new Area();

            area.setPoints(this.lastX, this.lastY, context.mouseX, context.mouseY, 3);

            int count = this.sheets.size();
            int h = (this.area.h - TOP_MARGIN) / count;
            int y = this.area.ey() - h * count;
            int c = 0;

            for (GuiSheet sheet : this.sheets)
            {
                int i = 0;

                for (Keyframe keyframe : sheet.channel.getKeyframes())
                {
                    if (area.isInside(this.toGraphX(keyframe.tick), y + h / 2) && !sheet.selected.contains(i))
                    {
                        sheet.selected.add(i);
                        c++;
                    }

                    i++;
                }

                y += h;
            }

            if (c > 0)
            {
                this.which = Selection.KEYFRAME;
                this.setKeyframe(this.getCurrent());
            }
        }

        super.resetMouseReleased(context);
    }

    /* Rendering */

    @Override
    protected void drawGraph(GuiContext context, int mouseX, int mouseY)
    {
        /* Draw dope sheet */
        int sheetCount = this.sheets.size();
        int h = (this.area.h - TOP_MARGIN) / sheetCount;
        int y = this.area.ey() - h * sheetCount;

        BufferBuilder vb = Tessellator.getInstance().getBuffer();

        for (GuiSheet sheet : this.sheets)
        {
            COLOR.set(sheet.color, false);

            vb.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);
            vb.pos(this.area.x, y + h / 2, 0).color(COLOR.r, COLOR.g, COLOR.b, 0.65F).endVertex();
            vb.pos(this.area.ex(), y + h / 2, 0).color(COLOR.r, COLOR.g, COLOR.b, 0.65F).endVertex();

            Tessellator.getInstance().draw();

            /* Draw points */
            vb.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

            int index = 0;
            int count = sheet.channel.getKeyframes().size();
            Keyframe prev = null;

            for (Keyframe frame : sheet.channel.getKeyframes())
            {
                this.drawRect(vb, this.toGraphX(frame.tick), y + h / 2, 3, sheet.hasSelected(index) ? 0xffffff : sheet.color);

                if (frame.interp == KeyframeInterpolation.BEZIER && sheet.handles && index != count - 1)
                {
                    this.drawRect(vb, this.toGraphX(frame.tick + frame.rx), y + h / 2, 2, sheet.hasSelected(index) ? 0xffffff : sheet.color);
                }

                if (prev != null && prev.interp == KeyframeInterpolation.BEZIER && sheet.handles)
                {
                    this.drawRect(vb, this.toGraphX(frame.tick - frame.lx), y + h / 2, 2, sheet.hasSelected(index) ? 0xffffff : sheet.color);
                }

                prev = frame;
                index++;
            }

            index = 0;
            prev = null;

            for (Keyframe frame : sheet.channel.getKeyframes())
            {
                this.drawRect(vb, this.toGraphX(frame.tick), y + h / 2, 2, this.which == Selection.KEYFRAME && sheet.hasSelected(index) ? 0x0080ff : 0);

                if (frame.interp == KeyframeInterpolation.BEZIER && sheet.handles && index != count - 1)
                {
                    this.drawRect(vb, this.toGraphX(frame.tick + frame.rx), y + h / 2, 1, this.which == Selection.RIGHT_HANDLE && sheet.hasSelected(index) ? 0x0080ff : 0);
                }

                if (prev != null && prev.interp == KeyframeInterpolation.BEZIER && sheet.handles)
                {
                    this.drawRect(vb, this.toGraphX(frame.tick - frame.lx), y + h / 2, 1, this.which == Selection.LEFT_HANDLE && sheet.hasSelected(index) ? 0x0080ff : 0);
                }

                prev = frame;
                index++;
            }

            Tessellator.getInstance().draw();

            int lw = this.font.getStringWidth(sheet.title.get()) + 10;
            GuiDraw.drawHorizontalGradientRect(this.area.ex() - lw - 10, y, this.area.ex(), y + h, sheet.color, 0xaa000000 + sheet.color, 0);
            this.font.drawStringWithShadow(sheet.title.get(), this.area.ex() - lw + 5, y + (h - this.font.FONT_HEIGHT) / 2 + 1, 0xffffff);

            GlStateManager.disableTexture2D();

            y += h;
        }
    }

    /* Handling dragging */

    @Override
    protected Keyframe moving(GuiContext context, int mouseX, int mouseY)
    {
        Keyframe frame = this.getCurrent();
        double x = this.fromGraphX(mouseX);

        if (this.which == Selection.NOT_SELECTED)
        {
            this.moveNoKeyframe(context, frame, x, 0);
        }
        else
        {
            if (this.isMultipleSelected())
            {
                int dx = mouseX - this.lastX;
                int xx = this.toGraphX(this.lastT);

                x = this.fromGraphX(xx + dx);
            }

            if (this.which == Selection.LEFT_HANDLE)
            {
                x = (int) -(x - frame.tick);
            }
            else if (this.which == Selection.RIGHT_HANDLE)
            {
                x = (int) x - frame.tick;
            }

            this.setTick(x, !GuiScreen.isAltKeyDown());
        }

        return frame;
    }
}

==================================================

--- Файл №39 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\GuiGraphView.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import com.google.common.collect.ImmutableList;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Scale;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.keyframes.Keyframe;
import mchorse.mclib.utils.keyframes.KeyframeChannel;
import mchorse.mclib.utils.keyframes.KeyframeEasing;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import org.lwjgl.opengl.GL11;

import java.util.List;
import java.util.function.Consumer;

/**
 * Graph view
 *
 * This GUI element is responsible for displaying and editing of
 * keyframe channel (keyframes and its bezier handles)
 */
public class GuiGraphView extends GuiKeyframeElement
{
    public GuiSheet sheet = new GuiSheet("main", IKey.str(""), 0, null);
    
    private Scale scaleY;

    public GuiGraphView(Minecraft mc, Consumer<Keyframe> callback)
    {
        super(mc, callback);

        this.scaleY = new Scale(this.area, ScrollDirection.VERTICAL, true);
        this.scaleY.anchor(0.5F);
    }

    public Scale getScaleY()
    {
        return this.scaleY;
    }

    public void setChannel(KeyframeChannel channel, int color)
    {
        this.sheet.channel = channel;
        this.sheet.color = color;
        this.resetView();
    }

    public void setColor(int color)
    {
        this.sheet.color = color;
    }

    /* Implementation of setters */

    @Override
    public void setTick(double tick, boolean opposite)
    {
        if (this.isMultipleSelected())
        {
            if (this.which == Selection.KEYFRAME)
            {
                tick = (long) tick;
            }

            this.sheet.setTick(tick - this.which.getX(this.getCurrent()), this.which, opposite);
        }
        else
        {
            this.which.setX(this.getCurrent(), tick, opposite);
        }

        this.sliding = true;
    }

    @Override
    public void setValue(double value, boolean opposite)
    {
        if (this.isMultipleSelected())
        {
            this.sheet.setValue(value - this.which.getY(this.getCurrent()), this.which, opposite);
        }
        else
        {
            this.which.setY(this.getCurrent(), value, opposite);
        }
    }

    @Override
    public void setInterpolation(KeyframeInterpolation interp)
    {
        this.sheet.setInterpolation(interp);
    }

    @Override
    public void setEasing(KeyframeEasing easing)
    {
        this.sheet.setEasing(easing);
    }

    /* Graphing code */

    public int toGraphY(double value)
    {
        return (int) this.scaleY.to(value);
    }

    public double fromGraphY(int mouseY)
    {
        return this.scaleY.from(mouseY);
    }

    @Override
    public void resetView()
    {
        this.scaleX.set(0, 2);
        this.scaleY.set(0, 2);

        KeyframeChannel channel = this.sheet.channel;
        int c = channel.getKeyframes().size();

        double minX = Double.POSITIVE_INFINITY;
        double maxX = Double.NEGATIVE_INFINITY;
        double minY = Double.POSITIVE_INFINITY;
        double maxY = Double.NEGATIVE_INFINITY;

        if (c > 1)
        {
            for (Keyframe frame : channel.getKeyframes())
            {
                minX = Math.min(minX, frame.tick);
                minY = Math.min(minY, frame.value);
                maxX = Math.max(maxX, frame.tick);
                maxY = Math.max(maxY, frame.value);
            }
        }
        else
        {
            minX = 0;
            maxX = this.duration;
            minY = -10;
            maxY = 10;

            if (c == 1)
            {
                Keyframe first = channel.get(0);

                minX = Math.min(0, first.tick);
                maxX = Math.max(this.duration, first.tick);
                minY = maxY = first.value;
            }
        }

        if (Math.abs(maxY - minY) < 0.01F)
        {
            /* Centerize */
            this.scaleY.setShift(minY);
        }
        else
        {
            /* Spread apart vertically */
            this.scaleY.viewOffset(minY, maxY, this.area.h, 20);
        }

        /* Spread apart horizontally */
        this.scaleX.viewOffset(minX, maxX, this.area.w, 20);
    }

    @Override
    public Keyframe getCurrent()
    {
        return this.sheet.getKeyframe();
    }

    @Override
    public List<GuiSheet> getSheets()
    {
        return ImmutableList.of(this.sheet);
    }

    @Override
    public GuiSheet getSheet(int mouseY)
    {
        return this.sheet;
    }

    @Override
    public void selectAll()
    {
        this.sheet.selectAll();
        this.which = Selection.KEYFRAME;
        this.setKeyframe(this.getCurrent());
    }

    @Override
    public int getSelectedCount()
    {
        return this.sheet.getSelectedCount();
    }

    @Override
    public void clearSelection()
    {
        this.which = Selection.NOT_SELECTED;
        this.sheet.clearSelection();
    }

    @Override
    public void addCurrent(int mouseX, int mouseY)
    {
        long tick = (long) this.fromGraphX(mouseX);
        double value = this.fromGraphY(mouseY);

        KeyframeEasing easing = KeyframeEasing.IN;
        KeyframeInterpolation interp = KeyframeInterpolation.LINEAR;
        Keyframe frame = this.getCurrent();
        long oldTick = tick;

        if (frame != null)
        {
            easing = frame.easing;
            interp = frame.interp;
            oldTick = frame.tick;
        }

        this.sheet.selected.clear();
        this.sheet.selected.add(this.sheet.channel.insert(tick, value));

        if (oldTick != tick)
        {
            frame = this.getCurrent();
            frame.setEasing(easing);
            frame.setInterpolation(interp);
        }
    }

    @Override
    public void removeCurrent()
    {
        Keyframe frame = this.getCurrent();

        if (frame == null)
        {
            return;
        }

        this.sheet.channel.remove(this.sheet.selected.get(0));
        this.sheet.clearSelection();
        this.which = Selection.NOT_SELECTED;
    }

    @Override
    public void removeSelectedKeyframes()
    {
        this.sheet.removeSelectedKeyframes();
        this.setKeyframe(null);
        this.which = Selection.NOT_SELECTED;
    }

    /**
     * Make current keyframe by given duration
     */
    public void selectByDuration(long duration)
    {
        if (this.sheet.channel == null)
        {
            return;
        }

        int i = 0;
        this.sheet.selected.clear();

        for (Keyframe frame : this.sheet.channel.getKeyframes())
        {
            if (frame.tick >= duration)
            {
                this.sheet.selected.add(i);

                break;
            }

            i++;
        }

        this.setKeyframe(this.getCurrent());
    }

    /* Mouse input handling */

    @Override
    protected void duplicateKeyframe(GuiContext context, int mouseX, int mouseY)
    {
        this.sheet.duplicate((long) this.fromGraphX(mouseX));
        this.setKeyframe(this.getCurrent());
    }

    @Override
    protected boolean pickKeyframe(GuiContext context, int mouseX, int mouseY, boolean shift)
    {
        int index = 0;
        int count = this.sheet.channel.getKeyframes().size();
        Keyframe prev = null;

        for (Keyframe frame : this.sheet.channel.getKeyframes())
        {
            boolean left = prev != null && prev.interp == KeyframeInterpolation.BEZIER && this.isInside(frame.tick - frame.lx, frame.value + frame.ly, mouseX, mouseY);
            boolean right = frame.interp == KeyframeInterpolation.BEZIER && this.isInside(frame.tick + frame.rx, frame.value + frame.ry, mouseX, mouseY) && index != count - 1;
            boolean point = this.isInside(frame.tick, frame.value, mouseX, mouseY);

            if (left || right || point)
            {
                int key = this.sheet.selected.indexOf(index);

                if (!shift && key == -1)
                {
                    this.clearSelection();
                }

                Selection which = left ? Selection.LEFT_HANDLE : (right ? Selection.RIGHT_HANDLE : Selection.KEYFRAME);

                if (!shift || which == this.which)
                {
                    this.which = which;

                    if (shift && this.isMultipleSelected() && key != -1)
                    {
                        this.sheet.selected.remove(key);
                        frame = this.getCurrent();
                    }
                    else if (key == -1)
                    {
                        this.sheet.selected.add(index);
                        frame = this.isMultipleSelected() ? this.getCurrent() : frame;
                    }
                    else
                    {
                        frame = this.getCurrent();
                    }

                    this.setKeyframe(frame);
                }

                if (frame != null)
                {
                    this.lastT = left ? frame.tick - frame.lx : (right ? frame.tick + frame.rx : frame.tick);
                    this.lastV = left ? frame.value + frame.ly : (right ? frame.value + frame.ry : frame.value);
                }

                return true;
            }

            prev = frame;
            index++;
        }

        return false;
    }

    private boolean isInside(double tick, double value, int mouseX, int mouseY)
    {
        int x = this.toGraphX(tick);
        int y = this.toGraphY(value);
        double d = Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2);

        return d < 16;
    }

    @Override
    protected void setupScrolling(GuiContext context, int mouseX, int mouseY)
    {
        super.setupScrolling(context, mouseX, mouseY);

        this.lastV = this.scaleY.getShift();
    }

    @Override
    protected void zoom(int scroll, int mouseX, int mouseY)
    {
        boolean x = GuiScreen.isShiftKeyDown();
        boolean y = GuiScreen.isCtrlKeyDown();
        boolean none = !x && !y;

        /* Scaling X */
        if (x && !y || none)
        {
            this.scaleX.setShift(this.scaleX.from(mouseX));
            this.scaleX.zoom(Math.copySign(this.scaleX.getZoomFactor(), scroll), this.minZoom, this.maxZoom);
            this.scaleX.setShift(2 * this.scaleX.getShift() - this.scaleX.from(mouseX));
        }

        /* Scaling Y */
        if (y && !x || none)
        {
            this.scaleY.setShift(this.scaleY.from(mouseY));
            this.scaleY.zoom(Math.copySign(this.scaleY.getZoomFactor(), scroll), this.minZoom, this.maxZoom);
            this.scaleY.setShift(2 * this.scaleY.getShift() - this.scaleY.from(mouseY));
        }
    }

    @Override
    protected void postSlideSort(GuiContext context)
    {
        /* Resort after dragging the tick thing */
        this.sheet.sort();
        this.sliding = false;
    }

    @Override
    protected void resetMouseReleased(GuiContext context)
    {
        if (this.isGrabbing())
        {
            /* Multi select */
            Area area = new Area();
            KeyframeChannel channel = this.sheet.channel;

            area.setPoints(this.lastX, this.lastY, context.mouseX, context.mouseY, 3);

            for (int i = 0, c = channel.getKeyframes().size(); i < c; i ++)
            {
                Keyframe keyframe = channel.get(i);

                if (area.isInside(this.toGraphX(keyframe.tick), this.toGraphY(keyframe.value)) && !this.sheet.selected.contains(i))
                {
                    this.sheet.selected.add(i);
                }
            }

            if (!this.sheet.selected.isEmpty())
            {
                this.which = Selection.KEYFRAME;
                this.setKeyframe(this.getCurrent());
            }
        }

        super.resetMouseReleased(context);
    }

    /* Rendering */

    @Override
    protected void drawGrid(GuiContext context)
    {
        super.drawGrid(context);

        /* Draw vertical grid */
        int ty = (int) this.fromGraphY(this.area.ey());
        int by = (int) this.fromGraphY(this.area.y - 12);

        int min = Math.min(ty, by) - 1;
        int max = Math.max(ty, by) + 1;
        int mult = this.scaleY.getMult();

        min -= min % mult + mult;
        max -= max % mult - mult;

        for (int j = 0, c = (max - min) / mult; j < c; j++)
        {
            int y = this.toGraphY(min + j * mult);

            if (y > this.area.ey())
            {
                continue;
            }

            Gui.drawRect(this.area.x, y, this.area.ex(), y + 1, 0x44ffffff);
            this.font.drawString(String.valueOf(min + j * mult), this.area.x + 4, y + 4, 0xffffff);
        }
    }

    /**
     * Render the graph
     */
    @Override
    protected void drawGraph(GuiContext context, int mouseX, int mouseY)
    {
        if (this.sheet.channel == null || this.sheet.channel.isEmpty())
        {
            return;
        }

        BufferBuilder vb = Tessellator.getInstance().getBuffer();
        KeyframeChannel channel = this.sheet.channel;

        /* Colorize the graph for given channel */
        COLOR.set(this.sheet.color, false);
        float r = COLOR.r;
        float g = COLOR.g;
        float b = COLOR.b;

        GlStateManager.color(1, 1, 1, 1);

        /* Draw the graph */
        vb.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

        int index = 0;
        int count = channel.getKeyframes().size();
        Keyframe prev = null;

        for (Keyframe frame : channel.getKeyframes())
        {
            if (prev != null)
            {
                int px = this.toGraphX(prev.tick);
                int fx = this.toGraphX(frame.tick);

                if (prev.interp == KeyframeInterpolation.LINEAR)
                {
                    vb.pos(px, this.toGraphY(prev.value), 0).color(r, g, b, 1).endVertex();
                    vb.pos(fx, this.toGraphY(frame.value), 0).color(r, g, b, 1).endVertex();
                }
                else
                {
                    float seg = 10;

                    if (prev.interp == KeyframeInterpolation.BOUNCE || prev.interp == KeyframeInterpolation.ELASTIC)
                    {
                        seg = 30;
                    }

                    for (int i = 0; i < seg; i++)
                    {
                        vb.pos(px + (fx - px) * (i / seg), this.toGraphY(prev.interpolate(frame, i / seg)), 0).color(r, g, b, 1).endVertex();
                        vb.pos(px + (fx - px) * ((i + 1) / seg), this.toGraphY(prev.interpolate(frame, (i + 1) / seg)), 0).color(r, g, b, 1).endVertex();
                    }
                }

                if (prev.interp == KeyframeInterpolation.BEZIER)
                {
                    vb.pos(this.toGraphX(frame.tick - frame.lx), this.toGraphY(frame.value + frame.ly), 0).color(r, g, b, 0.6F).endVertex();
                    vb.pos(this.toGraphX(frame.tick), this.toGraphY(frame.value), 0).color(r, g, b, 0.6F).endVertex();
                }
            }

            if (prev == null)
            {
                vb.pos(0, this.toGraphY(frame.value), 0).color(r, g, b, 1).endVertex();
                vb.pos(this.toGraphX(frame.tick), this.toGraphY(frame.value), 0).color(r, g, b, 1).endVertex();
            }

            if (frame.interp == KeyframeInterpolation.BEZIER && index != count - 1)
            {
                vb.pos(this.toGraphX(frame.tick), this.toGraphY(frame.value), 0).color(r, g, b, 0.6F).endVertex();
                vb.pos(this.toGraphX(frame.tick + frame.rx), this.toGraphY(frame.value + frame.ry), 0).color(r, g, b, 0.6F).endVertex();
            }

            prev = frame;
            index++;
        }

        vb.pos(this.toGraphX(prev.tick), this.toGraphY(prev.value), 0).color(r, g, b, 1).endVertex();
        vb.pos(this.area.ex(), this.toGraphY(prev.value), 0).color(r, g, b, 1).endVertex();

        Tessellator.getInstance().draw();

        /* Draw points */
        vb.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

        index = 0;
        prev = null;

        for (Keyframe frame : channel.getKeyframes())
        {
            this.drawRect(vb, this.toGraphX(frame.tick), this.toGraphY(frame.value), 3, 0xffffff);

            if (frame.interp == KeyframeInterpolation.BEZIER && index != count - 1)
            {
                this.drawRect(vb, this.toGraphX(frame.tick + frame.rx), this.toGraphY(frame.value + frame.ry), 3, 0xffffff);
            }

            if (prev != null && prev.interp == KeyframeInterpolation.BEZIER)
            {
                this.drawRect(vb, this.toGraphX(frame.tick - frame.lx), this.toGraphY(frame.value + frame.ly), 3, 0xffffff);
            }

            prev = frame;
            index++;
        }

        index = 0;
        prev = null;

        for (Keyframe frame : channel.getKeyframes())
        {
            boolean has = this.sheet.selected.contains(index);

            this.drawRect(vb, this.toGraphX(frame.tick), this.toGraphY(frame.value), 2, has && this.which == Selection.KEYFRAME ? 0x0080ff : 0);

            if (frame.interp == KeyframeInterpolation.BEZIER && index != count - 1)
            {
                this.drawRect(vb, this.toGraphX(frame.tick + frame.rx), this.toGraphY(frame.value + frame.ry), 2, has && this.which == Selection.RIGHT_HANDLE ? 0x0080ff : 0);
            }

            if (prev != null && prev.interp == KeyframeInterpolation.BEZIER)
            {
                this.drawRect(vb, this.toGraphX(frame.tick - frame.lx), this.toGraphY(frame.value + frame.ly), 2, has && this.which == Selection.LEFT_HANDLE ? 0x0080ff : 0);
            }

            prev = frame;
            index++;
        }

        Tessellator.getInstance().draw();
    }

    /* Handling dragging */

    @Override
    protected void scrolling(int mouseX, int mouseY)
    {
        super.scrolling(mouseX, mouseY);

        this.scaleY.setShift((mouseY - this.lastY) / this.scaleY.getZoom() + this.lastV);
    }

    @Override
    protected Keyframe moving(GuiContext context, int mouseX, int mouseY)
    {
        Keyframe frame = this.getCurrent();
        double x = this.fromGraphX(mouseX);
        double y = this.fromGraphY(mouseY);

        if (this.which == Selection.NOT_SELECTED)
        {
            this.moveNoKeyframe(context, frame, x, y);
        }
        else
        {
            if (this.isMultipleSelected())
            {
                int dx = mouseX - this.lastX;
                int dy = mouseY - this.lastY;

                int xx = this.toGraphX(this.lastT);
                int yy = this.toGraphY(this.lastV);

                x = this.fromGraphX(xx + dx);
                y = this.fromGraphY(yy + dy);
            }

            if (GuiScreen.isShiftKeyDown()) x = this.lastT;
            if (GuiScreen.isCtrlKeyDown()) y = this.lastV;

            if (this.which == Selection.LEFT_HANDLE)
            {
                x = -(x - frame.tick);
                y = y - frame.value;
            }
            else if (this.which == Selection.RIGHT_HANDLE)
            {
                x = x - frame.tick;
                y = y - frame.value;
            }

            this.setTick(x, !GuiScreen.isAltKeyDown());
            this.setValue(y, !GuiScreen.isAltKeyDown());
        }

        return frame;
    }
}

==================================================

--- Файл №40 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\GuiKeyframeElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Scale;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.keyframes.Keyframe;
import mchorse.mclib.utils.keyframes.KeyframeEasing;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;

import java.util.List;
import java.util.function.Consumer;

public abstract class GuiKeyframeElement extends GuiElement
{
    public static final Color COLOR = new Color();

    public Consumer<Keyframe> callback;
    public Selection which = Selection.NOT_SELECTED;
    public int duration;

    public double minZoom = 0.01D;
    public double maxZoom = 1000D;

    /**
     * Sliding flag, whether keyframes should be sorted after
     * dragging keyframes around
     */
    public boolean sliding;

    /**
     * Dragging flag, whether dragging got initiated (it might be possible
     * that there are 0 keyframes selected)
     */
    public boolean dragging;

    /**
     * Moving flag, whether the user dragged 3 pixels away from the original
     * place (also could have 0 keyframes selected)
     */
    protected boolean moving;

    /**
     * Scrolling flag, whether the user was navigating by dragging with
     * middle mouse held
     */
    protected boolean scrolling;

    /**
     * Grabbing flag, whether the user selected an area with Shift + click dragging
     * in order to select multiple keyframes
     */
    protected boolean grabbing;

    protected int lastX;
    protected int lastY;
    protected double lastT;
    protected double lastV;

    protected Scale scaleX;

    protected IAxisConverter converter;

    public GuiKeyframeElement(Minecraft mc, Consumer<Keyframe> callback)
    {
        super(mc);

        this.callback = callback;
        this.scaleX = new Scale(this.area, false);
        this.scaleX.anchor(0.5F);
    }

    public void setConverter(IAxisConverter converter)
    {
        this.converter = converter;
    }

    public Scale getScaleX()
    {
        return this.scaleX;
    }

    protected void setKeyframe(Keyframe current)
    {
        if (this.callback != null)
        {
            this.callback.accept(current);
        }
    }

    /* Setters */

    public abstract void setTick(double tick, boolean opposite);

    public abstract void setValue(double value, boolean opposite);

    public abstract void setInterpolation(KeyframeInterpolation interp);

    public abstract void setEasing(KeyframeEasing easing);

    public void setDuration(long duration)
    {
        this.duration = (int) duration;
    }

    /* Graphing code */

    public abstract void resetView();

    public int toGraphX(double tick)
    {
        return (int) (this.scaleX.to(tick));
    }

    public double fromGraphX(int mouseX)
    {
        return this.scaleX.from(mouseX);
    }

    /* Abstract methods */

    public abstract Keyframe getCurrent();

    public abstract List<GuiSheet> getSheets();

    public abstract GuiSheet getSheet(int mouseY);

    public boolean isGrabbing()
    {
        return this.dragging && this.moving && this.grabbing;
    }

    public void selectByDuration(long duration)
    {}

    public abstract void selectAll();

    public abstract int getSelectedCount();

    public boolean isMultipleSelected()
    {
        return this.getSelectedCount() > 1;
    }

    public boolean hasSelected()
    {
        return this.getSelectedCount() > 0;
    }

    public abstract void clearSelection();

    public void doubleClick(int mouseX, int mouseY)
    {
        if (this.which == Selection.NOT_SELECTED)
        {
            this.addCurrent(mouseX, mouseY);
        }
        else if (this.which == Selection.KEYFRAME && !this.isMultipleSelected())
        {
            this.removeCurrent();
        }
    }

    public abstract void addCurrent(int mouseX, int mouseY);

    public abstract void removeCurrent();

    public abstract void removeSelectedKeyframes();

    /* Common hooks */

    protected void updateMoved()
    {}

    protected void moveNoKeyframe(GuiContext context, Keyframe frame, double x, double y)
    {}

    protected void drawCursor(GuiContext context)
    {}

    /* Mouse input handling */

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        int mouseX = context.mouseX;
        int mouseY = context.mouseY;

        /* Select current point with a mouse click */
        if (this.area.isInside(mouseX, mouseY))
        {
            if (context.mouseButton == 0)
            {
                boolean shift = GuiScreen.isShiftKeyDown();

                /* Duplicate the keyframe */
                if (GuiScreen.isAltKeyDown() && !shift && this.which == Selection.KEYFRAME)
                {
                    this.duplicateKeyframe(context, mouseX, mouseY);

                    return false;
                }

                this.lastX = mouseX;
                this.lastY = mouseY;

                if (shift)
                {
                    this.grabbing = true;
                }

                if (!this.pickKeyframe(context, mouseX, mouseY, shift) && !shift)
                {
                    this.clearSelection();
                    this.setKeyframe(null);
                }

                this.dragging = true;
                this.pickedKeyframe(this.getSelectedCount());
            }
            else if (context.mouseButton == 2)
            {
                this.setupScrolling(context, mouseX, mouseY);
            }
        }

        return false;
    }

    protected void pickedKeyframe(int amount)
    {}

    protected abstract void duplicateKeyframe(GuiContext context, int mouseX, int mouseY);

    protected abstract boolean pickKeyframe(GuiContext context, int mouseX, int mouseY, boolean multi);

    protected void setupScrolling(GuiContext context, int mouseX, int mouseY)
    {
        this.scrolling = true;
        this.lastX = mouseX;
        this.lastY = mouseY;
        this.lastT = this.scaleX.getShift();
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        if (super.mouseScrolled(context))
        {
            return true;
        }

        if (this.area.isInside(context.mouseX, context.mouseY) && !this.scrolling)
        {
            int scroll = context.mouseWheel;

            if (!Minecraft.IS_RUNNING_ON_MAC)
            {
                scroll = -scroll;
            }

            this.zoom(scroll, context.mouseX, context.mouseY);

            return true;
        }

        return false;
    }

    protected void zoom(int scroll, int mouseX, int mouseY)
    {
        this.scaleX.setShift(this.scaleX.from(mouseX));
        this.scaleX.zoom(Math.copySign(this.scaleX.getZoomFactor(), scroll), this.minZoom, this.maxZoom);
        this.scaleX.setShift(2 * this.scaleX.getShift() - this.scaleX.from(mouseX));
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);

        if (this.which == Selection.KEYFRAME)
        {
            if (this.sliding)
            {
                this.postSlideSort(context);
            }

            if (this.moving)
            {
                this.updateMoved();
            }
        }

        this.resetMouseReleased(context);
    }

    protected void postSlideSort(GuiContext context)
    {}

    protected void resetMouseReleased(GuiContext context)
    {
        this.grabbing = false;
        this.dragging = false;
        this.moving = false;
        this.scrolling = false;
    }

    /* Rendering */

    @Override
    public void draw(GuiContext context)
    {
        this.handleMouse(context, context.mouseX, context.mouseY);
        this.drawBackground(context);

        GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);

        this.drawGrid(context);
        this.drawCursor(context);

        /* Draw graph of the keyframe channel */
        GlStateManager.glLineWidth(Minecraft.getMinecraft().gameSettings.guiScale * 1.5F);
        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        this.drawGraph(context, context.mouseX, context.mouseY);

        /* Draw selection box */
        if (this.isGrabbing())
        {
            Gui.drawRect(this.lastX, this.lastY, context.mouseX, context.mouseY, 0x440088ff);
        }

        GlStateManager.disableBlend();
        GlStateManager.enableTexture2D();

        GuiDraw.unscissor(context);

        super.draw(context);
    }

    protected void drawBackground(GuiContext context)
    {
        this.area.draw(ColorUtils.HALF_BLACK);

        if (this.duration > 0)
        {
            int leftBorder = this.toGraphX(0);
            int rightBorder = this.toGraphX(this.duration);

            if (leftBorder > this.area.x) Gui.drawRect(this.area.x, this.area.y, leftBorder, this.area.y + this.area.h, ColorUtils.HALF_BLACK);
            if (rightBorder < this.area.ex()) Gui.drawRect(rightBorder, this.area.y, this.area.ex() , this.area.y + this.area.h, ColorUtils.HALF_BLACK);
        }
    }

    protected void drawGrid(GuiContext context)
    {
        /* Draw scaling grid */
        int mult = this.scaleX.getMult();
        int hx = this.duration / mult;
        int ht = (int) this.fromGraphX(this.area.x);

        for (int j = Math.max(ht / mult, 0); j <= hx; j++)
        {
            int x = this.toGraphX(j * mult);

            if (x >= this.area.ex())
            {
                break;
            }

            String label = this.converter == null ? String.valueOf(j * mult) : this.converter.format(j * mult);

            Gui.drawRect(x, this.area.y, x + 1, this.area.ey(), 0x44ffffff);
            this.font.drawString(label, x + 4, this.area.y + 4, 0xffffff);
        }
    }

    protected abstract void drawGraph(GuiContext context, int mouseX, int mouseY);

    protected void drawRect(BufferBuilder builder, int x, int y, int offset, int c)
    {
        COLOR.set(c, false);

        builder.pos(x - offset, y + offset, 0.0D).color(COLOR.r, COLOR.g, COLOR.b, 1F).endVertex();
        builder.pos(x + offset, y + offset, 0.0D).color(COLOR.r, COLOR.g, COLOR.b, 1F).endVertex();
        builder.pos(x + offset, y - offset, 0.0D).color(COLOR.r, COLOR.g, COLOR.b, 1F).endVertex();
        builder.pos(x - offset, y - offset, 0.0D).color(COLOR.r, COLOR.g, COLOR.b, 1F).endVertex();
    }

    /* Handling dragging */

    protected void handleMouse(GuiContext context, int mouseX, int mouseY)
    {
        if (this.dragging && !this.moving && (Math.abs(this.lastX - mouseX) > 3 || Math.abs(this.lastY - mouseY) > 3))
        {
            this.moving = true;
            this.sliding = true;
        }

        if (this.scrolling)
        {
            this.scrolling(mouseX, mouseY);
        }
        /* Move the current keyframe */
        else if (this.moving && !this.grabbing)
        {
            this.setKeyframe(this.moving(context, mouseX, mouseY));
            this.keepMoving();
        }
    }

    protected void keepMoving()
    {}

    protected void scrolling(int mouseX, int mouseY)
    {
        this.scaleX.setShift(-(mouseX - this.lastX) / this.scaleX.getZoom() + this.lastT);
    }

    protected Keyframe moving(GuiContext context, int mouseX, int mouseY)
    {
        return null;
    }
}

==================================================

--- Файл №41 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\GuiKeyframeInterpolationsList.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;

import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

/**
 * Interpolations list
 */
public class GuiKeyframeInterpolationsList extends GuiListElement<KeyframeInterpolation>
{
    public GuiKeyframeInterpolationsList(Minecraft mc, Consumer<List<KeyframeInterpolation>> callback)
    {
        super(mc, callback);

        this.scroll.scrollItemSize = 16;

        for (KeyframeInterpolation interp : KeyframeInterpolation.values())
        {
            this.add(interp);
        }

        this.sort();
        this.background();
    }

    @Override
    protected boolean sortElements()
    {
        Collections.sort(this.list, (o1, o2) -> o1.key.compareTo(o2.key));

        return true;
    }

    @Override
    protected String elementToString(KeyframeInterpolation element)
    {
        return I18n.format(element.getKey());
    }
}

==================================================

--- Файл №42 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\GuiKeyframesEditor.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.tooltips.InterpolationTooltip;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.InterpolationRenderer;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.IInterpolation;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.keyframes.Keyframe;
import mchorse.mclib.utils.keyframes.KeyframeEasing;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.nbt.JsonToNBT;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.common.util.Constants;
import org.lwjgl.input.Keyboard;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public abstract class GuiKeyframesEditor<T extends GuiKeyframeElement> extends GuiElement
{
    public GuiElement frameButtons;
    public GuiTrackpadElement tick;
    public GuiTrackpadElement value;
    public GuiButtonElement interp;
    public GuiListElement<KeyframeInterpolation> interpolations;
    public GuiCirculateElement easing;

    public T graph;

    private int clicks;
    private long clickTimer;

    private IAxisConverter converter;

    public GuiKeyframesEditor(Minecraft mc)
    {
        super(mc);

        InterpolationTooltip tooltip = new InterpolationTooltip(0F, 0F, () ->
        {
            Keyframe keyframe = this.graph.getCurrent();

            if (keyframe == null)
            {
                return null;
            }

            return keyframe.interp.from(keyframe.easing);
        }, null);

        this.frameButtons = new GuiElement(mc);
        this.frameButtons.flex().relative(this).x(1F, -10).y(10).w(170).h(50).anchorX(1F);
        this.frameButtons.setVisible(false);
        this.tick = new GuiTrackpadElement(mc, this::setTick);
        this.tick.limit(Integer.MIN_VALUE, Integer.MAX_VALUE, true).tooltip(IKey.lang("mclib.gui.keyframes.tick"));
        this.value = new GuiTrackpadElement(mc, this::setValue);
        this.value.tooltip(IKey.lang("mclib.gui.keyframes.value"));
        this.interp = new GuiButtonElement(mc, IKey.lang(""), (b) -> this.interpolations.toggleVisible());
        this.interp.tooltip(tooltip);
        this.interpolations = new GuiKeyframeInterpolationsList(mc, (interp) -> this.pickInterpolation(interp.get(0)));
        this.interpolations.tooltip(tooltip).setVisible(false);

        this.easing = new GuiCirculateElement(mc, (b) -> this.changeEasing());
        this.easing.tooltip(tooltip);

        for (KeyframeEasing easing : KeyframeEasing.values())
        {
            this.easing.addLabel(IKey.lang(easing.getKey()));
        }

        this.graph = this.createElement(mc);

        /* Position the elements */
        this.tick.flex().relative(this).set(0, 10, 80, 20).x(1, -90);
        this.value.flex().relative(this).set(0, 35, 80, 20).x(1, -90);

        this.interp.flex().relative(this.tick).set(-90, 0, 80, 20);
        this.easing.flex().relative(this.value).set(-90, 0, 80, 20);
        this.interpolations.flex().relative(this).set(0, 30, 80, 20).x(1, -180).h(1, -30).maxH(16 * 7);
        this.graph.flex().relative(this).set(0, 0, 0, 0).w(1, 0).h(1, 0);

        /* Add all elements */
        this.add(this.graph, this.frameButtons);
        this.frameButtons.add(this.tick, this.value, this.interp, this.easing, this.interpolations);

        this.keys().register(IKey.lang("mclib.gui.keyframes.context.maximize"), Keyboard.KEY_HOME, this::resetView).inside();
        this.keys().register(IKey.lang("mclib.gui.keyframes.context.select_all"), Keyboard.KEY_A, this::selectAll).held(Keyboard.KEY_LCONTROL).inside();
    }

    protected abstract T createElement(Minecraft mc);

    protected void toggleInterpolation()
    {
        Keyframe keyframe = this.graph.getCurrent();

        if (keyframe == null)
        {
            return;
        }

        KeyframeInterpolation interp = keyframe.interp;
        int factor = GuiScreen.isShiftKeyDown() ? -1 : 1;
        int index = MathUtils.cycler(interp.ordinal() + factor, 0, KeyframeInterpolation.values().length - 1);

        this.pickInterpolation(KeyframeInterpolation.values()[index]);
        this.interpolations.setCurrent(interp);
        GuiUtils.playClick();
    }

    protected void toggleEasing()
    {
        this.easing.clickItself(GuiBase.getCurrent(), GuiScreen.isShiftKeyDown() ? 1 : 0);
    }

    public void setConverter(IAxisConverter converter)
    {
        this.converter = converter;
        this.graph.setConverter(converter);

        if (converter != null)
        {
            converter.updateField(this.tick);
        }

        this.fillData(this.graph.getCurrent());
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        int mouseX = context.mouseX;
        int mouseY = context.mouseY;

        if (this.area.isInside(mouseX, mouseY))
        {
            /* On double click add or remove a keyframe */
            if (context.mouseButton == 0)
            {
                long time = System.currentTimeMillis();

                if (time - this.clickTimer < 175)
                {
                    this.clicks++;

                    if (this.clicks >= 1)
                    {
                        this.clicks = 0;
                        this.doubleClick(mouseX, mouseY);
                    }
                }
                else
                {
                    this.clicks = 0;
                }

                this.clickTimer = time;
            }
        }

        return this.area.isInside(mouseX, mouseY);
    }

    @Override
    public GuiContextMenu createContextMenu(GuiContext context)
    {
        GuiSimpleContextMenu menu = new GuiSimpleContextMenu(this.mc);

        menu.action(Icons.MAXIMIZE, IKey.lang("mclib.gui.keyframes.context.maximize"), this::resetView);
        menu.action(Icons.FULLSCREEN, IKey.lang("mclib.gui.keyframes.context.select_all"), this::selectAll);

        if (this.graph.which != Selection.NOT_SELECTED)
        {
            menu.action(Icons.REMOVE, IKey.lang("mclib.gui.keyframes.context.remove"), this::removeSelectedKeyframes);
            menu.action(Icons.COPY, IKey.lang("mclib.gui.keyframes.context.copy"), this::copyKeyframes);
        }

        Map<String, List<Keyframe>> pasted = this.parseKeyframes();

        if (pasted != null)
        {
            final Map<String, List<Keyframe>> keyframes = pasted;
            double offset = this.graph.scaleX.from(context.mouseX);
            int mouseY = context.mouseY;

            menu.action(Icons.PASTE, IKey.lang("mclib.gui.keyframes.context.paste"), () -> this.pasteKeyframes(keyframes, (long) offset, mouseY));
        }

        if (this.graph.which != Selection.NOT_SELECTED && this.graph.isMultipleSelected())
        {
            menu.action(Icons.LEFT_HANDLE, IKey.lang("mclib.gui.keyframes.context.to_left"), () -> this.graph.which = Selection.LEFT_HANDLE);
            menu.action(Icons.MAIN_HANDLE, IKey.lang("mclib.gui.keyframes.context.to_main"), () -> this.graph.which = Selection.KEYFRAME);
            menu.action(Icons.RIGHT_HANDLE, IKey.lang("mclib.gui.keyframes.context.to_right"), () -> this.graph.which = Selection.RIGHT_HANDLE);
        }

        return menu;
    }

    /**
     * Parse keyframes from clipboard
     */
    private Map<String, List<Keyframe>> parseKeyframes()
    {
        try
        {
            NBTTagCompound tag = JsonToNBT.getTagFromJson(GuiScreen.getClipboardString());
            Map<String, List<Keyframe>> temp = new HashMap<String, List<Keyframe>>();

            for (String key : tag.getKeySet())
            {
                NBTTagList list = tag.getTagList(key, Constants.NBT.TAG_COMPOUND);

                for (int i = 0, c = list.tagCount(); i < c; i++)
                {
                    List<Keyframe> keyframes = temp.get(key);

                    if (keyframes == null)
                    {
                        keyframes = new ArrayList<Keyframe>();

                        temp.put(key, keyframes);
                    }

                    Keyframe keyframe = new Keyframe();

                    keyframe.fromNBT(list.getCompoundTagAt(i));
                    keyframes.add(keyframe);
                }
            }

            if (!temp.isEmpty())
            {
                return temp;
            }
        }
        catch (Exception e)
        {}

        return null;
    }

    /**
     * Copy keyframes to clipboard
     */
    private void copyKeyframes()
    {
        NBTTagCompound keyframes = new NBTTagCompound();

        for (GuiSheet sheet : this.graph.getSheets())
        {
            int c = sheet.getSelectedCount();

            if (c > 0)
            {
                NBTTagList list = new NBTTagList();

                for (int i = 0; i < c; i++)
                {
                    Keyframe keyframe = sheet.channel.get(sheet.selected.get(i));

                    list.appendTag(keyframe.toNBT());
                }

                if (list.tagCount() > 0)
                {
                    keyframes.setTag(sheet.id, list);
                }
            }
        }

        GuiScreen.setClipboardString(keyframes.toString());
    }

    /**
     * Paste copied keyframes to clipboard
     */
    protected void pasteKeyframes(Map<String, List<Keyframe>> keyframes, long offset, int mouseY)
    {
        List<GuiSheet> sheets = this.graph.getSheets();

        this.graph.clearSelection();

        if (keyframes.size() == 1)
        {
            GuiSheet current = this.graph.getSheet(mouseY);

            if (current == null)
            {
                current =  sheets.get(0);
            }

            this.pasteKeyframesTo(current, keyframes.get(keyframes.keySet().iterator().next()), offset);

            return;
        }

        for (Map.Entry<String, List<Keyframe>> entry : keyframes.entrySet())
        {
            for (GuiSheet sheet : sheets)
            {
                if (!sheet.id.equals(entry.getKey()))
                {
                    continue;
                }

                this.pasteKeyframesTo(sheet, entry.getValue(), offset);
            }
        }
    }

    private void pasteKeyframesTo(GuiSheet sheet, List<Keyframe> keyframes, long offset)
    {
        long firstX = keyframes.get(0).tick;
        List<Keyframe> toSelect = new ArrayList<Keyframe>();

        if (GuiScreen.isCtrlKeyDown())
        {
            offset = firstX;
        }

        for (Keyframe keyframe : keyframes)
        {
            keyframe.tick = keyframe.tick - firstX + offset;

            int index = sheet.channel.insert(keyframe.tick, keyframe.value);
            Keyframe inserted = sheet.channel.get(index);

            inserted.copy(keyframe);
            toSelect.add(inserted);
        }

        for (Keyframe select : toSelect)
        {
            sheet.selected.add(sheet.channel.getKeyframes().indexOf(select));
        }

        this.graph.which = Selection.KEYFRAME;
        this.graph.setKeyframe(this.graph.getCurrent());
    }

    protected void doubleClick(int mouseX, int mouseY)
    {
        this.graph.doubleClick(mouseX, mouseY);
        this.fillData(this.graph.getCurrent());
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return super.mouseScrolled(context) || this.area.isInside(context.mouseX, context.mouseY);
    }

    public void resetView()
    {
        this.graph.resetView();
    }

    public void selectAll()
    {
        this.graph.selectAll();
    }

    public void removeSelectedKeyframes()
    {
        this.graph.removeSelectedKeyframes();
    }

    public void setTick(double tick)
    {
        this.graph.setTick(this.converter == null ? tick : this.converter.from(tick), false);
    }

    public void setValue(double value)
    {
        this.graph.setValue(value, false);
    }

    public void pickInterpolation(KeyframeInterpolation interp)
    {
        this.graph.setInterpolation(interp);
        this.interp.label.set(interp.getKey());
    }

    public void changeEasing()
    {
        this.graph.setEasing(KeyframeEasing.values()[this.easing.getValue()]);
    }

    public void fillData(Keyframe frame)
    {
        boolean show = frame != null && this.graph.which != Selection.NOT_SELECTED;

        this.frameButtons.setVisible(show);

        if (!show)
        {
            return;
        }

        double tick = this.graph.which.getX(frame);
        boolean forceInteger = this.graph.which == Selection.KEYFRAME;

        this.tick.integer = this.converter == null ? forceInteger : this.converter.forceInteger(frame, this.graph.which, forceInteger);
        this.tick.setValue(this.converter == null ? tick : this.converter.to(tick));
        this.value.setValue(this.graph.which.getY(frame));
        this.interp.label.set(frame.interp.getKey());
        this.interpolations.setCurrent(frame.interp);
        this.easing.setValue(frame.easing.ordinal());
    }
}

==================================================

--- Файл №43 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\GuiSheet.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.keyframes.Keyframe;
import mchorse.mclib.utils.keyframes.KeyframeChannel;
import mchorse.mclib.utils.keyframes.KeyframeEasing;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class GuiSheet
{
    public final String id;
    public IKey title;
    public int color;
    public KeyframeChannel channel;
    public List<Integer> selected = new ArrayList<Integer>();
    public boolean handles = true;

    public GuiSheet(String id, IKey title, int color, KeyframeChannel channel, boolean handles)
    {
        this(id, title, color, channel);

        this.handles = handles;
    }

    public GuiSheet(String id, IKey title, int color, KeyframeChannel channel)
    {
        this.id = id;
        this.title = title;
        this.color = color;
        this.channel = channel;
    }

    public void sort()
    {
        List<Keyframe> keyframes = new ArrayList<Keyframe>();

        for (int index : this.selected)
        {
            Keyframe keyframe = this.channel.get(index);

            if (keyframe != null)
            {
                keyframes.add(keyframe);
            }
        }

        this.channel.sort();
        this.selected.clear();

        for (Keyframe keyframe : keyframes)
        {
            this.selected.add(this.channel.getKeyframes().indexOf(keyframe));
        }
    }

    public void setTick(double dx, Selection selection, boolean opposite)
    {
        for (int index : this.selected)
        {
            Keyframe keyframe = this.channel.get(index);

            if (keyframe != null)
            {
                selection.setX(keyframe, selection.getX(keyframe) + dx, opposite);
            }
        }
    }

    public void setValue(double dy, Selection selection, boolean opposite)
    {
        for (int index : this.selected)
        {
            Keyframe keyframe = this.channel.get(index);

            if (keyframe != null)
            {
                selection.setY(keyframe, selection.getY(keyframe) + dy, opposite);
            }
        }
    }

    public void setInterpolation(KeyframeInterpolation interp)
    {
        for (int index : this.selected)
        {
            Keyframe keyframe = this.channel.get(index);

            if (keyframe != null)
            {
                keyframe.setInterpolation(interp);
            }
        }
    }

    public void setEasing(KeyframeEasing easing)
    {
        for (int index : this.selected)
        {
            Keyframe keyframe = this.channel.get(index);

            if (keyframe != null)
            {
                keyframe.setEasing(easing);
            }
        }
    }

    public Keyframe getKeyframe()
    {
        if (this.selected.isEmpty())
        {
            return null;
        }

        return this.channel.get(this.selected.get(0));
    }

    public boolean hasSelected(int i)
    {
        return this.selected.contains(i);
    }

    public void clearSelection()
    {
        this.selected.clear();
    }

    public int getSelectedCount()
    {
        return this.selected.size();
    }

    public void removeSelectedKeyframes()
    {
        List<Integer> sorted = new ArrayList<Integer>(this.selected);

        Collections.sort(sorted);
        Collections.reverse(sorted);

        this.clearSelection();

        for (int index : sorted)
        {
            this.channel.remove(index);
        }

        this.clearSelection();
    }

    public void duplicate(long tick)
    {
        List<Keyframe> selected = new ArrayList<Keyframe>();
        List<Keyframe> created = new ArrayList<Keyframe>();

        long minTick = Integer.MAX_VALUE;

        for (int index : this.selected)
        {
            Keyframe keyframe = this.channel.get(index);

            if (keyframe != null)
            {
                selected.add(keyframe);
                minTick = Math.min(keyframe.tick, minTick);
            }
        }

        selected.sort(Comparator.comparingLong(a -> a.tick));

        long diff = tick - minTick;

        for (Keyframe keyframe : selected)
        {
            long fin = keyframe.tick + diff;
            int index = this.channel.insert(fin, keyframe.value);
            Keyframe current = this.channel.get(index);

            current.copy(keyframe);
            current.tick = fin;
            created.add(current);
        }

        this.clearSelection();

        for (Keyframe keyframe : created)
        {
            this.selected.add(this.channel.getKeyframes().indexOf(keyframe));
        }
    }

    public void selectAll()
    {
        this.clearSelection();

        for (int i = 0, c = this.channel.getKeyframes().size(); i < c; i++)
        {
            this.selected.add(i);
        }
    }
}


==================================================

--- Файл №44 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\IAxisConverter.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.utils.keyframes.Keyframe;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public interface IAxisConverter
{
    public String format(double value);

    public double from(double x);

    public double to(double x);

    @SideOnly(Side.CLIENT)
    public void updateField(GuiTrackpadElement element);

    @SideOnly(Side.CLIENT)
    public boolean forceInteger(Keyframe keyframe, Selection selection, boolean forceInteger);
}

==================================================

--- Файл №45 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\keyframes\Selection.java
--------------------
package mchorse.mclib.client.gui.framework.elements.keyframes;

import mchorse.mclib.utils.keyframes.Keyframe;

public enum Selection
{
    NOT_SELECTED
    {
        @Override
        public double getX(Keyframe keyframe)
        {
            throw new IllegalStateException("Not supported by NOT_SELECTED!");
        }

        @Override
        public double getY(Keyframe keyframe)
        {
            throw new IllegalStateException("Not supported by NOT_SELECTED!");
        }

        @Override
        public void setX(Keyframe keyframe, double x, boolean opposite)
        {
            throw new IllegalStateException("Not supported by NOT_SELECTED!");
        }

        @Override
        public void setY(Keyframe keyframe, double y, boolean opposite)
        {
            throw new IllegalStateException("Not supported by NOT_SELECTED!");
        }
    },
    KEYFRAME
    {
        @Override
        public double getX(Keyframe keyframe)
        {
            return keyframe.tick;
        }

        @Override
        public double getY(Keyframe keyframe)
        {
            return keyframe.value;
        }

        @Override
        public void setX(Keyframe keyframe, double x, boolean opposite)
        {
            keyframe.setTick((long) x);
        }

        @Override
        public void setY(Keyframe keyframe, double y, boolean opposite)
        {
            keyframe.setValue(y);
        }
    },
    LEFT_HANDLE
    {
        @Override
        public double getX(Keyframe keyframe)
        {
            return keyframe.lx;
        }

        @Override
        public double getY(Keyframe keyframe)
        {
            return keyframe.ly;
        }

        @Override
        public void setX(Keyframe keyframe, double x, boolean opposite)
        {
            keyframe.lx = (float) x;

            if (opposite)
            {
                keyframe.rx = keyframe.lx;
            }
        }

        @Override
        public void setY(Keyframe keyframe, double y, boolean opposite)
        {
            keyframe.ly = (float) y;

            if (opposite)
            {
                keyframe.ry = -keyframe.ly;
            }
        }
    },
    RIGHT_HANDLE
    {
        @Override
        public double getX(Keyframe keyframe)
        {
            return keyframe.rx;
        }

        @Override
        public double getY(Keyframe keyframe)
        {
            return keyframe.ry;
        }

        @Override
        public void setX(Keyframe keyframe, double x, boolean opposite)
        {
            keyframe.rx = (float) x;

            if (opposite)
            {
                keyframe.lx = keyframe.rx;
            }
        }

        @Override
        public void setY(Keyframe keyframe, double y, boolean opposite)
        {
            keyframe.ry = (float) y;

            if (opposite)
            {
                keyframe.ly = -keyframe.ry;
            }
        }
    };

    public abstract double getX(Keyframe keyframe);

    public abstract double getY(Keyframe keyframe);

    public abstract void setX(Keyframe keyframe, double x, boolean opposite);

    public abstract void setY(Keyframe keyframe, double y, boolean opposite);
}

==================================================

--- Файл №46 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiFolderEntryListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import java.util.List;
import java.util.function.Consumer;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.util.ResourceLocation;

/**
 * Folder entry list GUI
 * 
 * This GUI list element allows to navigate through the file tree 
 * entries. 
 */
public class GuiFolderEntryListElement extends GuiListElement<AbstractEntry>
{
    public Consumer<FileEntry> fileCallback;
    public ResourceLocation rl;
    public FolderEntry parent;

    public GuiFolderEntryListElement(Minecraft mc, Consumer<FileEntry> fileCallback)
    {
        super(mc, null);

        this.callback = (list) ->
        {
            AbstractEntry entry = list.get(0);

            if (entry instanceof FileEntry)
            {
                if (this.fileCallback != null)
                {
                    this.fileCallback.accept(((FileEntry) entry));
                }
            }
            else if (entry.isFolder())
            {
                this.setFolder((FolderEntry) entry);
            }
        };
        this.fileCallback = fileCallback;
        this.scroll.scrollItemSize = 16;
        this.scroll.scrollSpeed = 16;
    }

    /**
     * Set current folder
     */
    public void setFolder(FolderEntry folder)
    {
        /* Quick jump to children folder that has only one folder */
        if (folder.getEntries().size() <= 2 && !folder.isTop())
        {
            for (AbstractEntry subEntry : folder.getEntries())
            {
                if (subEntry.isFolder())
                {
                    FolderEntry subFolder = (FolderEntry) subEntry;

                    if (!subFolder.isTop())
                    {
                        this.setFolder(subFolder);

                        return;
                    }
                }
            }
        }

        this.setDirectFolder(folder);
    }

    public void setDirectFolder(FolderEntry folder)
    {
        List<AbstractEntry> entries = folder.getEntries();
        List<AbstractEntry> current = this.getCurrent();

        this.parent = folder;
        this.setList(entries);
        this.setCurrent(current.isEmpty() ? null : current.get(0));

        if (this.current.isEmpty())
        {
            this.setCurrent(this.rl);
        }
    }

    public ResourceLocation getCurrentResource()
    {
        List<AbstractEntry> entry = this.getCurrent();

        if (!entry.isEmpty() && entry.get(0) instanceof FileEntry)
        {
            return ((FileEntry) entry.get(0)).resource;
        }

        return null;
    }

    public void setCurrent(ResourceLocation rl)
    {
        this.setIndex(-1);

        if (rl == null)
        {
            return;
        }

        for (int i = 0, c = this.list.size(); i < c; i++)
        {
            AbstractEntry entry = this.list.get(i);

            if (entry instanceof FileEntry && ((FileEntry) entry).resource.equals(rl))
            {
                this.setIndex(i);
                break;
            }
        }
    }

    @Override
    protected void drawElementPart(AbstractEntry element, int i, int x, int y, boolean hover, boolean selected)
    {
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();
        this.mc.renderEngine.bindTexture(GuiBase.ICONS);

        GlStateManager.color(1, 1, 1, hover ? 0.8F : 0.6F);

        (element instanceof FolderEntry ? Icons.FOLDER : Icons.SERVER).render(x + 2, y);

        this.font.drawStringWithShadow(element.title, x + 20, y + 4, hover ? 16777120 : 0xffffff);
    }
}

==================================================

--- Файл №47 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiInterpolationList.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import mchorse.mclib.utils.Interpolation;
import net.minecraft.client.Minecraft;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;

/**
 * Interpolations list
 */
public class GuiInterpolationList extends GuiListElement<Interpolation>
{
    public GuiInterpolationList(Minecraft mc, Consumer<List<Interpolation>> callback)
    {
        super(mc, callback);

        this.scroll.scrollItemSize = 16;

        for (Interpolation interp : Interpolation.values())
        {
            this.add(interp);
        }

        this.background().cancelScrollEdge().sort();
    }

    @Override
    protected boolean sortElements()
    {
        Collections.sort(this.list, Comparator.comparing(o -> o.key));

        return true;
    }

    @Override
    protected String elementToString(Interpolation element)
    {
        return element.getName();
    }
}

==================================================

--- Файл №48 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiLabelListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;

import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

public class GuiLabelListElement <T> extends GuiListElement<Label<T>>
{
    public GuiLabelListElement(Minecraft mc, Consumer<List<Label<T>>> callback)
    {
        super(mc, callback);

        this.scroll.scrollItemSize = 16;
    }

    public void add(IKey title, T value)
    {
        this.add(new Label<T>(title, value));
    }

    public void setCurrentTitle(String title)
    {
        for (int i = 0; i < this.list.size(); i ++)
        {
            if (this.list.get(i).title.equals(title))
            {
                this.setIndex(i);

                return;
            }
        }
    }

    public void setCurrentValue(T value)
    {
        for (int i = 0; i < this.list.size(); i ++)
        {
            if (this.list.get(i).value.equals(value))
            {
                this.setIndex(i);

                return;
            }
        }
    }

    @Override
    protected boolean sortElements()
    {
        Collections.sort(this.list, (a, b) -> a.title.get().compareToIgnoreCase(b.title.get()));

        return true;
    }

    @Override
    protected String elementToString(Label<T> element)
    {
        return element.title.get();
    }
}

==================================================

--- Файл №49 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiLabelSearchListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import mchorse.mclib.client.gui.utils.Label;
import net.minecraft.client.Minecraft;

import java.util.List;
import java.util.function.Consumer;

public class GuiLabelSearchListElement <T> extends GuiSearchListElement<Label<T>>
{
    public GuiLabelSearchListElement(Minecraft mc, Consumer<List<Label<T>>> callback)
    {
        super(mc, callback);
    }

    @Override
    protected GuiListElement<Label<T>> createList(Minecraft mc, Consumer<List<Label<T>>> callback)
    {
        return new GuiLabelListElement<T>(mc, callback);
    }
}

==================================================

--- Файл №50 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.function.Consumer;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;

/**
 * Abstract GUI list element
 * 
 * This element allows managing scrolling vertical lists much easier
 */
public abstract class GuiListElement<T> extends GuiElement
{
    /**
     * List of elements 
     */
    protected List<T> list = new ArrayList<T>();

    /**
     * List for copying
     */
    private List<T> copy = new ArrayList<T>();

    /**
     * Scrolling area
     */
    public ScrollArea scroll;

    /**
     * Callback which gets invoked when user selects an element
     */
    public Consumer<List<T>> callback;

    /**
     * Selected elements
     */
    public List<Integer> current = new ArrayList<Integer>();

    /**
     * Whether this list supports multi selection
     */
    public boolean multi;

    /**
     * Whether this list supports reordering
     */
    public boolean sorting;

    public boolean background;
    public int color = ColorUtils.HALF_BLACK;
    protected boolean postDraw;

    private String filter = "";
    private List<Pair<T>> filtered = new ArrayList<Pair<T>>();

    private int dragging = -1;
    private long dragTime;

    public GuiListElement(Minecraft mc, Consumer<List<T>> callback)
    {
        super(mc);

        this.callback = callback;
        this.area = this.scroll = new ScrollArea(20);
    }

    /* List element settings */

    public GuiListElement<T> background()
    {
        this.background = true;

        return this;
    }

    public GuiListElement<T> background(int color)
    {
        return this.background(true, color);
    }

    public GuiListElement<T> background(boolean background, int color)
    {
        this.background = background;
        this.color = color;

        return this;
    }

    public GuiListElement<T> multi()
    {
        this.multi = true;

        return this;
    }

    public GuiListElement<T> sorting()
    {
        this.sorting = true;

        return this;
    }

    public GuiListElement<T> horizontal()
    {
        this.scroll.direction = ScrollDirection.HORIZONTAL;

        return this;
    }

    public GuiListElement<T> cancelScrollEdge()
    {
        this.scroll.cancelScrollEdge = true;

        return this;
    }

    public boolean isHorizontal()
    {
        return this.scroll.direction == ScrollDirection.HORIZONTAL;
    }

    /* Filtering elements */

    public void filter(String filter)
    {
        filter = filter.toLowerCase();

        if (this.filter.equals(filter))
        {
            return;
        }

        this.filter = filter;
        this.filtered.clear();

        if (filter.isEmpty())
        {
            this.update();

            return;
        }

        for (int i = 0; i < this.list.size(); i ++)
        {
            T element = this.list.get(i);

            if (this.elementToString(element).toLowerCase().contains(filter))
            {
                this.filtered.add(new Pair<T>(element, i));
            }
        }

        this.update();
    }

    public boolean isFiltering()
    {
        return !this.filter.isEmpty();
    }

    /* Index and current value(s) methods */

    public boolean isDeselected()
    {
        if (this.current.isEmpty())
        {
            return true;
        }

        for (Integer index : this.current)
        {
            if (this.exists(index))
            {
                return false;
            }
        }

        return true;
    }

    public List<T> getCurrent()
    {
        this.copy.clear();

        for (Integer integer : this.current)
        {
            if (this.exists(integer))
            {
                this.copy.add(this.list.get(integer));
            }
        }

        return this.copy;
    }

    public T getCurrentFirst()
    {
        if (!this.current.isEmpty())
        {
            int index = this.current.get(0);

            if (this.exists(index))
            {
                return this.list.get(index);
            }
        }

        return null;
    }

    public int getIndex()
    {
        if (this.current.isEmpty())
        {
            return -1;
        }

        int index = this.current.get(0);

        return this.exists(index) ? index : -1;
    }

    public void setIndex(int index)
    {
        this.current.clear();
        this.addIndex(index);
    }

    public void addIndex(int index)
    {
        if (this.exists(index) && this.current.indexOf(index) == -1)
        {
            this.current.add(index);
        }
    }

    public void toggleIndex(int index)
    {
        if (this.exists(index))
        {
            int i = this.current.indexOf(index);

            if (i == -1)
            {
                this.current.add(index);
            }
            else
            {
                this.current.remove(i);
            }
        }
    }

    public void setCurrent(T element)
    {
        this.current.clear();

        int index = this.list.indexOf(element);

        if (this.exists(index))
        {
            this.current.add(index);
        }
    }

    public void setCurrentDirect(T element)
    {
        this.current.clear();

        for (int i = 0; i < this.list.size(); i ++)
        {
            if (this.list.get(i) == element)
            {
                this.current.add(i);

                return;
            }
        }
    }

    public void setCurrent(List<T> elements)
    {
        if (!this.multi && !elements.isEmpty())
        {
            this.setCurrent(elements.get(0));

            return;
        }

        this.current.clear();

        for (T element : elements)
        {
            int index = this.list.indexOf(element);

            if (this.exists(index))
            {
                this.current.add(index);
            }
        }
    }

    public void setCurrentScroll(T element)
    {
        this.setCurrent(element);

        if (!this.current.isEmpty())
        {
            this.scroll.scrollTo(this.current.get(0) * this.scroll.scrollItemSize);
        }
    }

    public void selectAll()
    {
        if (!this.multi)
        {
            return;
        }

        this.current.clear();

        for (int i = 0; i < this.list.size(); i ++)
        {
            this.current.add(i);
        }
    }

    public List<T> getList()
    {
        return this.list;
    }

    /* Content management */

    public void clear()
    {
        this.filter("");

        this.current.clear();
        this.list.clear();
        this.update();
    }

    public void add(T element)
    {
        this.list.add(element);
        this.update();
    }

    public void add(Collection<T> elements)
    {
        this.list.addAll(elements);
        this.update();
    }

    public void replace(T element)
    {
        int index = this.current.size() == 1 ? this.current.get(0) : -1;

        if (this.exists(index))
        {
            this.list.set(index, element);
        }
    }

    public void setList(List<T> list)
    {
        if (list == null)
        {
            return;
        }

        this.list = list;
        this.update();
    }

    public void remove(T element)
    {
        this.list.remove(element);
        this.update();
    }

    /**
     * Sort elements in this array, the subsclasses should implement
     * the other sorting method in order for it to work
     */
    public final void sort()
    {
        List<T> current = this.getCurrent();

        if (this.sortElements())
        {
            this.current.clear();

            for (T element : current)
            {
                this.current.add(this.list.indexOf(element));
            }
        }
    }

    /**
     * Sort elements
     */
    protected boolean sortElements()
    {
        return false;
    }

    /* Miscellaneous methods */

    public void update()
    {
        this.scroll.setSize(this.isFiltering() ? this.filtered.size() : this.list.size());
        this.scroll.clamp();
    }

    public boolean exists(int index)
    {
        return this.exists(this.list, index);
    }

    public boolean exists(List list, int index)
    {
        return index >= 0 && index < list.size();
    }

    public boolean isDragging()
    {
        return this.exists(this.dragging) && System.currentTimeMillis() - this.dragTime > 100;
    }

    public int getDraggingIndex()
    {
        return this.dragging;
    }

    @Override
    public void resize()
    {
        super.resize();

        this.scroll.clamp();
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.scroll.mouseClicked(context))
        {
            return true;
        }

        if (this.scroll.isInside(context) && context.mouseButton < 2)
        {
            int index = this.scroll.getIndex(context.mouseX, context.mouseY);
            boolean filtering = this.isFiltering();

            if (filtering)
            {
                index = this.exists(this.filtered, index) ? this.filtered.get(index).index : -1;
            }

            if (this.exists(index))
            {
                if (this.multi && GuiScreen.isShiftKeyDown())
                {
                    this.toggleIndex(index);
                }
                else
                {
                    this.setIndex(index);
                }

                if (!filtering && this.sorting && this.current.size() == 1)
                {
                    this.dragging = index;
                    this.dragTime = System.currentTimeMillis();
                }

                if (this.callback != null)
                {
                    this.callback.accept(this.getCurrent());

                    return context.mouseButton == 0;
                }
            }
        }

        return false;
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return super.mouseScrolled(context) || this.scroll.mouseScroll(context);
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        if (this.sorting && !this.isFiltering())
        {
            if (this.isDragging())
            {
                int index = this.scroll.getIndex(context.mouseX, context.mouseY);

                if (index == -2)
                {
                    index = this.getList().size() - 1;
                }

                if (index != this.dragging && this.exists(index))
                {
                    T value = this.list.remove(this.dragging);

                    this.list.add(index, value);
                    this.setIndex(index);
                }
            }

            this.dragging = -1;
        }

        this.scroll.mouseReleased(context);
        super.mouseReleased(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.scroll.drag(context);

        if (this.background)
        {
            this.area.draw(this.color);
        }

        GuiDraw.scissor(this.scroll.x, this.scroll.y, this.scroll.w, this.scroll.h, context);
        this.drawList(context);
        this.scroll.drawScrollbar();
        GuiDraw.unscissor(context);

        GuiDraw.drawLockedArea(this);

        super.draw(context);

        if (this.exists(this.dragging) && this.isDragging())
        {
            this.drawListElement(this.list.get(this.dragging), this.dragging, context.mouseX + 6, context.mouseY - this.scroll.scrollItemSize / 2, true, true);
        }
    }

    public void drawList(GuiContext context)
    {
        int i = 0;

        if (this.isFiltering())
        {
            for (Pair<T> element : this.filtered)
            {
                i = this.drawElement(context, element.value, i, element.index, false);

                if (i == -1)
                {
                    break;
                }
            }

            if (this.postDraw)
            {
                i = 0;

                for (Pair<T> element : this.filtered)
                {
                    i = this.drawElement(context, element.value, i, element.index, true);

                    if (i == -1)
                    {
                        break;
                    }
                }
            }
        }
        else
        {
            for (T element : this.list)
            {
                i = this.drawElement(context, element, i, i, false);

                if (i == -1)
                {
                    break;
                }
            }

            if (this.postDraw)
            {
                i = 0;

                for (T element : this.list)
                {
                    i = this.drawElement(context, element, i, i, true);

                    if (i == -1)
                    {
                        break;
                    }
                }
            }
        }
    }

    public int drawElement(GuiContext context, T element, int i, int index, boolean postDraw)
    {
        int mouseX = context.mouseX;
        int mouseY = context.mouseY;
        int s = this.scroll.scrollItemSize;

        int xSide = this.isHorizontal() ? this.scroll.scrollItemSize : this.scroll.w;
        int ySide = this.isHorizontal() ? this.scroll.h : this.scroll.scrollItemSize;

        int x = this.scroll.x;
        int y = this.scroll.y + i * s - this.scroll.scroll;

        int axis = y;
        int low = this.scroll.y;
        int high = this.scroll.ey();

        if (this.isHorizontal())
        {
            x = this.scroll.x + i * s - this.scroll.scroll;
            y = this.scroll.y;

            axis = x;
            low = this.scroll.x;
            high = this.scroll.ex();
        }

        if (axis + s < low || (!this.isFiltering() && this.isDragging() && this.dragging == i))
        {
            return i + 1;
        }

        if (axis >= high)
        {
            return -1;
        }

        boolean hover = mouseX >= x && mouseY >= y && mouseX < x + xSide && mouseY < y + ySide;
        boolean selected = this.current.indexOf(index) != -1;

        if (postDraw)
        {
            this.drawPostListElement(element, index, x, y, hover, selected);
        }
        else
        {
            this.drawListElement(element, index, x, y, hover, selected);
        }

        return i + 1;
    }

    /**
     * Draw second pass of individual list element
     */
    public void drawPostListElement(T element, int i, int x, int y, boolean hover, boolean selected)
    {}

    /**
     * Draw individual element (with selection)
     */
    public void drawListElement(T element, int i, int x, int y, boolean hover, boolean selected)
    {
        if (selected)
        {
            if (this.isHorizontal())
            {
                Gui.drawRect(x, y, x + this.scroll.scrollItemSize, y + this.scroll.h, ColorUtils.HALF_BLACK + McLib.primaryColor.get());
            }
            else
            {
                Gui.drawRect(x, y, x + this.scroll.w, y + this.scroll.scrollItemSize, ColorUtils.HALF_BLACK + McLib.primaryColor.get());
            }
        }

        this.drawElementPart(element, i, x, y, hover, selected);
    }

    /**
     * Draw only the main part (without selection or any hover elements)
     */
    protected void drawElementPart(T element, int i, int x, int y, boolean hover, boolean selected)
    {
        this.font.drawStringWithShadow(this.elementToString(element), x + 4, y + this.scroll.scrollItemSize / 2 - this.font.FONT_HEIGHT / 2, hover ? 16777120 : 0xffffff);
    }

    /**
     * Convert element to string
     */
    protected String elementToString(T element)
    {
        return element.toString();
    }

    public static class Pair<T>
    {
        public T value;
        public int index;

        public Pair(T value, int index)
        {
            this.value = value;
            this.index = index;
        }
    }
}

==================================================

--- Файл №51 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiResourceLocationListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.function.Consumer;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.list.GuiListElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.util.ResourceLocation;

/**
 * Similar to {@link GuiStringListElement}, but uses {@link ResourceLocation}s 
 */
public class GuiResourceLocationListElement extends GuiListElement<ResourceLocation>
{
    public GuiResourceLocationListElement(Minecraft mc, Consumer<List<ResourceLocation>> callback)
    {
        super(mc, callback);

        this.scroll.scrollItemSize = 16;
    }

    @Override
    protected boolean sortElements()
    {
        Collections.sort(this.list, (a, b) -> a.toString().compareToIgnoreCase(b.toString()));

        return true;
    }
}

==================================================

--- Файл №52 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiSearchListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public abstract class GuiSearchListElement<T> extends GuiElement
{
    public GuiTextElement search;
    public GuiListElement<T> list;
    public IKey label = IKey.EMPTY;

    public GuiSearchListElement(Minecraft mc, Consumer<List<T>> callback)
    {
        super(mc);

        this.search = new GuiTextElement(mc, 100, (str) -> this.filter(str, false));
        this.search.flex().relative(this).set(0, 0, 0, 20).w(1, 0);

        this.list = this.createList(mc, callback);
        this.list.flex().relative(this).set(0, 20, 0, 0).w(1, 0).h(1, -20);

        this.add(this.search, this.list);
    }

    public GuiSearchListElement<T> label(IKey label)
    {
        this.label = label;

        return this;
    }

    protected abstract GuiListElement<T> createList(Minecraft mc, Consumer<List<T>> callback);

    public void filter(String str, boolean fill)
    {
        if (fill)
        {
            this.search.setText(str);
        }

        this.list.filter(str);
    }

    @Override
    public void draw(GuiContext context)
    {
        super.draw(context);

        if (!this.search.field.isFocused() && this.search.field.getText().isEmpty())
        {
            this.font.drawStringWithShadow(this.label.get(), this.search.area.x + 5, this.search.area.y + 6, 0x888888);
        }
    }
}

==================================================

--- Файл №53 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiStringListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import java.util.Collections;
import java.util.List;
import java.util.function.Consumer;

import mchorse.mclib.McLib;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;

public class GuiStringListElement extends GuiListElement<String>
{
    public GuiStringListElement(Minecraft mc, Consumer<List<String>> callback)
    {
        super(mc, callback);

        this.scroll.scrollItemSize = 16;
    }

    @Override
    protected boolean sortElements()
    {
        Collections.sort(this.list);

        return true;
    }

    @Override
    protected String elementToString(String element)
    {
        return element;
    }
}

==================================================

--- Файл №54 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\list\GuiStringSearchListElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.list;

import java.util.List;
import java.util.function.Consumer;

import net.minecraft.client.Minecraft;

public class GuiStringSearchListElement extends GuiSearchListElement<String>
{
    public GuiStringSearchListElement(Minecraft mc, Consumer<List<String>> callback)
    {
        super(mc, callback);
    }

    @Override
    protected GuiListElement<String> createList(Minecraft mc, Consumer<List<String>> callback)
    {
        return new GuiStringListElement(mc, callback);
    }
}

==================================================

--- Файл №55 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\modals\GuiConfirmModal.java
--------------------
package mchorse.mclib.client.gui.framework.elements.modals;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

import java.util.function.Consumer;

public class GuiConfirmModal extends GuiModal
{
    public GuiButtonElement confirm;
    public GuiButtonElement cancel;

    public Consumer<Boolean> callback;

    public GuiConfirmModal(Minecraft mc, IKey label, Consumer<Boolean> callback)
    {
        super(mc, label);

        this.callback = callback;

        this.confirm = new GuiButtonElement(mc, IKey.lang("mclib.gui.ok"), (b) -> this.close(true));
        this.cancel = new GuiButtonElement(mc, IKey.lang("mclib.gui.cancel"), (b) -> this.close(false));

        this.bar.add(this.confirm, this.cancel);
    }

    public static GuiConfirmModal createTemplate(Minecraft mc, GuiElement parent, IKey label, Consumer<Boolean> callback)
    {
        GuiConfirmModal modal = new GuiConfirmModal(mc, label, callback);

        modal.flex().relative(parent).xy(0.5F, 0.5F).wh(160, 180).anchor(0.5F, 0.5F);

        return modal;
    }

    public static GuiConfirmModal createTemplate(Minecraft mc, Area area, IKey label, Consumer<Boolean> callback)
    {
        GuiConfirmModal modal = new GuiConfirmModal(mc, label, callback);

        modal.flex().relative(area).xy(0.5F, 0.5F).wh(160, 180).anchor(0.5F, 0.5F);

        return modal;
    }

    public void close(boolean confirmed)
    {
        if (this.callback != null)
        {
            this.callback.accept(confirmed);
        }

        this.removeFromParent();
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (context.keyCode == Keyboard.KEY_RETURN || context.keyCode == Keyboard.KEY_ESCAPE)
        {
            (context.keyCode == Keyboard.KEY_RETURN ? this.confirm : this.cancel).clickItself(context);

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №56 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\modals\GuiListModal.java
--------------------
package mchorse.mclib.client.gui.framework.elements.modals;

import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiStringListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import org.lwjgl.input.Keyboard;

import java.util.Collection;
import java.util.List;
import java.util.function.Consumer;

public class GuiListModal extends GuiModal
{
    public Consumer<List<String>> callback;
    public String label;

    public GuiButtonElement pick;
    public GuiButtonElement cancel;
    public GuiStringListElement list;

    public GuiListModal(Minecraft mc, IKey label, Consumer<String> callback)
    {
        super(mc, label);

        this.callback = (list) ->
        {
            if (callback != null)
            {
                callback.accept(this.list.getIndex() == 0 ? "" : this.list.getCurrentFirst());
            }
        };

        this.pick = new GuiButtonElement(mc, IKey.lang("mclib.gui.ok"), (b) -> this.send());
        this.cancel = new GuiButtonElement(mc, IKey.lang("mclib.gui.cancel"), (b) -> this.removeFromParent());
        this.list = new GuiStringListElement(mc, null);

        this.list.flex().set(10, 0, 0, 0).relative(this.area).y(0.4F, 0).w(1, -20).h(0.6F, -35);
        this.list.add(I18n.format("mclib.gui.none"));
        this.list.setIndex(0);

        this.bar.add(this.pick, this.cancel);
        this.add(this.list);
    }

    public GuiListModal callback(Consumer<List<String>> callback)
    {
        this.callback = callback;

        return this;
    }

    public GuiListModal setValue(String value)
    {
        if (value.isEmpty())
        {
            this.list.setIndex(0);
        }
        else
        {
            this.list.setCurrent(value);
        }

        return this;
    }

    public GuiListModal addValues(Collection<String> values)
    {
        this.list.add(values);

        return this;
    }

    public void send()
    {
        if (this.list.isDeselected())
        {
            return;
        }

        this.removeFromParent();

        if (this.callback != null)
        {
            this.callback.accept(this.list.getCurrent());
        }
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (context.keyCode == Keyboard.KEY_RETURN)
        {
            this.send();

            return true;
        }
        else if (context.keyCode == Keyboard.KEY_ESCAPE)
        {
            this.removeFromParent();

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №57 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\modals\GuiMessageModal.java
--------------------
package mchorse.mclib.client.gui.framework.elements.modals;

import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

public class GuiMessageModal extends GuiModal
{
    public GuiButtonElement button;

    public GuiMessageModal(Minecraft mc, IKey label)
    {
        super(mc, label);

        this.button = new GuiButtonElement(mc, IKey.lang("mclib.gui.ok"), (b) -> this.removeFromParent());

        this.bar.add(this.button);
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (context.keyCode == Keyboard.KEY_RETURN || context.keyCode == Keyboard.KEY_ESCAPE)
        {
            this.button.clickItself(context);

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №58 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\modals\GuiModal.java
--------------------
package mchorse.mclib.client.gui.framework.elements.modals;

import mchorse.mclib.client.gui.framework.elements.GuiDelegateElement;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IGuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;

import java.util.function.Supplier;

/**
 * Parent class for all modals
 * 
 * Best to be used with {@link GuiDelegateElement}.
 */
public abstract class GuiModal extends GuiElement
{
    public IKey label;
    public int y;

    public GuiElement bar;

    public static boolean hasModal(GuiElement parent)
    {
        for (IGuiElement element : parent.getChildren())
        {
            if (element instanceof GuiModal)
            {
                return true;
            }
        }

        return false;
    }

    public static boolean addModal(GuiElement parent, Supplier<GuiModal> supplier)
    {
        if (hasModal(parent) || supplier == null)
        {
            return false;
        }

        GuiModal modal = supplier.get();

        modal.resize();
        parent.add(modal);

        return true;
    }

    public static boolean addFullModal(GuiElement parent, Supplier<GuiModal> supplier)
    {
        if (hasModal(parent) || supplier == null)
        {
            return false;
        }

        GuiModal modal = supplier.get();

        modal.flex().relative(parent).wh(1F, 1F);
        modal.resize();
        parent.add(modal);

        return true;
    }

    public GuiModal(Minecraft mc, IKey label)
    {
        super(mc);

        this.bar = new GuiElement(mc);
        this.bar.flex().relative(this).y(1F).w(1F).h(40).anchorY(1F).row(10).padding(10);
        this.add(this.bar);

        this.label = label;
        this.markContainer();
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        return super.mouseClicked(context) || this.area.isInside(context);
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return super.mouseScrolled(context) || this.area.isInside(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), 0xcc000000);
        GlStateManager.enableAlpha();

        this.y = 0;
        int y = this.area.y + 10;

        for (String line : this.font.listFormattedStringToWidth(this.label.get(), this.area.w - 20))
        {
            this.font.drawStringWithShadow(line, this.area.x + 10, y + this.y, 0xffffff);
            this.y += 11;
        }

        super.draw(context);
    }
}

==================================================

--- Файл №59 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\modals\GuiPopUpModal.java
--------------------
package mchorse.mclib.client.gui.framework.elements.modals;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;
import mchorse.mclib.utils.Timer;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraft.client.renderer.GlStateManager;
import org.lwjgl.opengl.GL11;

public class GuiPopUpModal extends GuiModal
{
    private Color backgroundColorDefault = new Color(0F, 0F, 0F, 0F);
    private Color textColorDefault = new Color(1F, 1F, 1F, 0F);
    private float shadowAlphaDefault = 0.26666668F;
    private float alphaDefault = 1F;

    private boolean init = false;
    private int x0;
    private int y0;
    private Timer timer;

    /* Colours */
    private float shadowAlpha;
    private float textAlpha;
    private float backgroundAlpha;

    private Color shadowColor;
    private Color backgroundColor;
    private Color textColor;

    /**
     * fade duration in milliseconds
     */
    private int duration = 300;

    public GuiPopUpModal(Minecraft mc, IKey label)
    {
        super(mc, label);

        this.defaultColors();
    }

    /**
     * Set the duration for the fading animation if it hadn't already begun
     *
     * @param duration in milliseconds
     */
    public void setFadeDuration(int duration)
    {
        if (this.timer == null)
        {
            this.duration = duration;
        }
    }

    @Override
    public void draw(GuiContext context)
    {
        if (!this.init)
        {
            this.x0 = context.mouseX() - this.area.w / 4;
            this.y0 = context.mouseY() - this.area.h / 2;

            this.x0 = this.x0 < 0 ? 0 : this.x0;
            this.y0 = this.y0 < 0 ? 0 : this.y0;

            if (Minecraft.getMinecraft().currentScreen.width < this.x0 + this.area.w)
            {
                this.x0 = Minecraft.getMinecraft().currentScreen.width - this.area.w;
            }

            if (Minecraft.getMinecraft().currentScreen.height < this.y0 + this.area.h)
            {
                this.y0 = Minecraft.getMinecraft().currentScreen.height - this.area.h;
            }

            this.init = true;
        }

        this.area.x = this.x0;
        this.area.y = this.y0;

        GlStateManager.enableBlend();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.alphaFunc(GL11.GL_GREATER, 0);

        int shadowAlpha = (int)(this.shadowAlpha * 255F) << 24;
        int textAlpha = (int)(this.textAlpha * 255F) << 24;
        int backgroundAlpha = (int)(this.backgroundAlpha * 255F) << 24;

        GuiDraw.drawDropShadow(this.area.x, this.area.y, this.area.ex(), this.area.ey(), 6, shadowAlpha + this.shadowColor.getRGBColor(), this.shadowColor.getRGBColor());
        Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), backgroundAlpha + this.backgroundColor.getRGBAColor());

        this.y = 0;

        for (String line : this.font.listFormattedStringToWidth(this.label.get(), this.area.w - 20))
        {
            this.font.drawStringWithShadow(line, this.area.x + 10, this.area.y + 10 + this.y, textAlpha + this.textColor.getRGBAColor());

            this.y += 11;
        }

        if (!this.area.isInside(context))
        {
            if (this.timer == null)
            {
                this.timer = new Timer(this.duration);

                this.timer.mark();
            }

            float x = ((float)this.duration - this.timer.getRemaining()) / this.duration;

            this.backgroundAlpha = this.fadeAlpha(this.alphaDefault, 0F, x);
            this.textAlpha = this.fadeAlpha(this.alphaDefault, 0F, x);
            this.shadowAlpha = this.fadeAlpha(this.shadowAlphaDefault, 0F,  MathUtils.clamp(x * 1.7F, 0, 1));

            if(this.timer.check())
            {
                context.postRenderCallbacks.add((c) ->
                {
                    this.removeFromParent();
                });
            }
        }
        else if (this.timer != null && !this.timer.check()) //if the mouse came back before the timer ended
        {
            this.timer = null;

            this.defaultColors();
        }

        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
    }

    public void defaultColors()
    {
        this.shadowAlpha = this.shadowAlphaDefault;
        this.textAlpha = this.alphaDefault;
        this.backgroundAlpha = this.alphaDefault;

        this.shadowColor = new Color(McLib.primaryColor.get());
        this.backgroundColor = this.backgroundColorDefault.copy();
        this.textColor = this.textColorDefault.copy();
    }

    private float fadeAlpha(float a, float b, float x)
    {
        return Interpolations.lerp(a, b, x);
    }
}


==================================================

--- Файл №60 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\modals\GuiPromptModal.java
--------------------
package mchorse.mclib.client.gui.framework.elements.modals;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import org.lwjgl.input.Keyboard;

import java.util.function.Consumer;

public class GuiPromptModal extends GuiModal
{
    public Consumer<String> callback;

    public GuiTextElement text;
    public GuiButtonElement confirm;
    public GuiButtonElement cancel;

    public GuiPromptModal(Minecraft mc, IKey label, Consumer<String> callback)
    {
        super(mc, label);

        this.callback = callback;
        this.text = new GuiTextElement(mc, (Consumer<String>) null);
        this.text.flex().relative(this).set(10, 0, 0, 20).y(1, -55).w(1, -20);
        GuiBase.getCurrent().focus(this.text);

        this.confirm = new GuiButtonElement(mc, IKey.lang("mclib.gui.ok"), (b) -> this.send());
        this.cancel = new GuiButtonElement(mc, IKey.lang("mclib.gui.cancel"), (b) -> this.removeFromParent());

        this.bar.add(this.confirm, this.cancel);
        this.add(this.text);
    }

    public GuiPromptModal filename()
    {
        this.text.filename();

        return this;
    }

    public GuiPromptModal setValue(String value)
    {
        this.text.setText(value);

        return this;
    }

    public void send()
    {
        String text = this.text.field.getText();

        if (!text.isEmpty())
        {
            this.removeFromParent();

            if (this.callback != null)
            {
                this.callback.accept(text);
            }
        }
    }

    @Override
    public boolean keyTyped(GuiContext context)
    {
        if (super.keyTyped(context))
        {
            return true;
        }

        if (context.keyCode == Keyboard.KEY_RETURN)
        {
            this.confirm.clickItself(context);

            return true;
        }
        else if (context.keyCode == Keyboard.KEY_ESCAPE)
        {
            this.cancel.clickItself(context);

            return true;
        }

        return false;
    }
}

==================================================

--- Файл №61 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiCanvas.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Scale;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import net.minecraft.client.Minecraft;

public class GuiCanvas extends GuiElement
{
    public Scale scaleX;
    public Scale scaleY;

    public boolean dragging;
    public int mouse;

    protected int lastX;
    protected int lastY;
    protected double lastT;
    protected double lastV;

    public GuiCanvas(Minecraft mc)
    {
        super(mc);

        this.scaleX = new Scale(this.area, false);
        this.scaleX.anchor(0.5F);
        this.scaleY = new Scale(this.area, ScrollDirection.VERTICAL, false);
        this.scaleY.anchor(0.5F);
    }

    public int toX(double x)
    {
        return (int) Math.round(this.scaleX.to(x));
    }

    public double fromX(int mouseX)
    {
        return this.scaleX.from(mouseX);
    }

    public int toY(double y)
    {
        return (int) Math.round(this.scaleY.to(y));
    }

    public double fromY(int mouseY)
    {
        return this.scaleY.from(mouseY);
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (this.area.isInside(context))
        {
            this.dragging = true;
            this.mouse = context.mouseButton;

            this.lastX = context.mouseX;
            this.lastY = context.mouseY;

            this.startDragging(context);

            return true;
        }

        return false;
    }

    protected void startDragging(GuiContext context)
    {
        this.lastT = this.scaleX.getShift();
        this.lastV = this.scaleY.getShift();
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        if (super.mouseScrolled(context))
        {
            return true;
        }

        if (this.area.isInside(context.mouseX, context.mouseY) && !this.dragging)
        {
            int scroll = context.mouseWheel;

            if (!Minecraft.IS_RUNNING_ON_MAC)
            {
                scroll = -scroll;
            }

            this.zoom(scroll);

            return true;
        }

        return false;
    }

    protected void zoom(int scroll)
    {
        this.scaleX.zoom(Math.copySign(this.scaleX.getZoomFactor(), scroll), 0.001, 1000);
        this.scaleY.zoom(Math.copySign(this.scaleY.getZoomFactor(), scroll), 0.001, 1000);
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);

        this.dragging = false;
    }

    @Override
    public void draw(GuiContext context)
    {
        this.dragging(context);

        GuiDraw.scissor(this.area.x, this.area.y, this.area.w, this.area.h, context);
        this.drawCanvas(context);
        GuiDraw.unscissor(context);

        super.draw(context);
    }

    protected void dragging(GuiContext context)
    {
        if (this.dragging && this.mouse == 2)
        {
            float y = this.scaleY.inverse ? 1 : -1;

            this.scaleX.setShift(-(context.mouseX - this.lastX) / this.scaleX.getZoom() + this.lastT);
            this.scaleY.setShift(y * (context.mouseY - this.lastY) / this.scaleY.getZoom() + this.lastV);
        }
    }

    protected void drawCanvas(GuiContext context)
    {}
}

==================================================

--- Файл №62 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiCanvasEditor.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;
import org.lwjgl.opengl.GL11;

public abstract class GuiCanvasEditor extends GuiCanvas
{
    private static Area processed = new Area();

    public GuiElement editor;

    /* Width and height of the frame that being currently edited */
    protected int w;
    protected int h;

    public GuiCanvasEditor(Minecraft mc)
    {
        super(mc);

        this.editor = new GuiElement(mc);
        this.editor.flex().relative(this).xy(1F, 1F).w(130).anchor(1F, 1F).column(5).stretch().vertical().padding(10);
        this.add(this.editor);
    }

    public int getWidth()
    {
        return this.w;
    }

    public int getHeight()
    {
        return this.h;
    }

    public void setSize(int w, int h)
    {
        this.w = w;
        this.h = h;

        this.scaleX.set(0, 2);
        this.scaleY.set(0, 2);
        this.scaleX.viewOffset(-this.w / 2, this.w / 2, 20);
        this.scaleY.viewOffset(-this.h / 2, this.h / 2, 20);

        double min = Math.min(this.scaleX.getZoom(), this.scaleY.getZoom());

        this.scaleX.setZoom(min);
        this.scaleY.setZoom(min);
    }

    @Override
    protected void drawCanvas(GuiContext context)
    {
        this.drawBackground(context);

        Area area = this.calculate(-this.w / 2, -this.h / 2, this.w / 2, this.h / 2);

        Gui.drawRect(area.x - 1, area.y - 1, area.ex() + 1, area.ey() + 1, 0xff181818);
        GlStateManager.color(1, 1, 1, 1);

        if (!this.shouldDrawCanvas(context))
        {
            return;
        }

        GuiDraw.scissor(area.x, area.y, area.w, area.h, context);

        int ox = (this.area.x - area.x) % 16;
        int oy = (this.area.y - area.y) % 16;

        processed.copy(this.area);
        processed.offsetX(ox < 0 ? 16 + ox : ox);
        processed.offsetY(oy < 0 ? 16 + oy : oy);
        processed.clamp(area);
        Icons.CHECKBOARD.renderArea(area.x, area.y, area.w, area.h);

        GlStateManager.alphaFunc(GL11.GL_GREATER, 0);
        GlStateManager.enableBlend();
        GlStateManager.enableAlpha();

        this.drawCanvasFrame(context);

        GlStateManager.color(1F, 1F, 1F);
        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
        GuiDraw.unscissor(context);
    }

    protected void drawBackground(GuiContext context)
    {
        this.area.draw(0xff2f2f2f);
    }

    protected abstract void drawCanvasFrame(GuiContext context);

    protected boolean shouldDrawCanvas(GuiContext context)
    {
        return true;
    }

    protected Area calculateRelative(int a, int b, int c, int d)
    {
        return this.calculate(-this.w / 2 + a, -this.h / 2 + b, -this.w / 2 + c, -this.h / 2 + d);
    }

    protected Area calculate(int ix1, int iy1, int ix2, int iy2)
    {
        int x1 = this.toX(ix1);
        int y1 = this.toY(iy1);
        int x2 = this.toX(ix2);
        int y2 = this.toY(iy2);

        int x = x1;
        int y = y1;
        int fw = x2 - x;
        int fh = y2 - y;

        Area.SHARED.set(x, y, fw, fh);

        return Area.SHARED;
    }
}


==================================================

--- Файл №63 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiContext.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.tooltips.GuiTooltip;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IFocusedGuiElement;
import mchorse.mclib.client.gui.framework.elements.IGuiElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiKeybinds;
import mchorse.mclib.client.gui.utils.Area;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

public class GuiContext implements IViewportStack
{
    public Minecraft mc;
    public FontRenderer font;

    /* GUI elements */
    public final GuiBase screen;
    public final GuiTooltip tooltip;
    public final GuiKeybinds keybinds;
    public IFocusedGuiElement activeElement;
    public GuiContextMenu contextMenu;

    /* Mouse states */
    public int mouseX;
    public int mouseY;
    public int mouseButton;
    public int mouseWheel;
    /**
     * If this is true, no other element should be right clicked
     * Example: dragging something awaits right click to abort the dragging process. In that time
     * no other Gui element should respond to right click.
     */
    public boolean awaitsRightClick;

    /* Keyboard states */
    public char typedChar;
    public int keyCode;

    /* Render states */
    public float partialTicks;
    public long tick;

    public List<Consumer<GuiContext>> postRenderCallbacks = new ArrayList<>();
    public GuiViewportStack viewportStack = new GuiViewportStack();

    public GuiContext(GuiBase screen)
    {
        this.screen = screen;
        this.tooltip = new GuiTooltip();
        this.keybinds = new GuiKeybinds(Minecraft.getMinecraft());
        this.keybinds.setVisible(false);
    }

    public void setMouse(int mouseX, int mouseY)
    {
        this.mouseX = mouseX;
        this.mouseY = mouseY;
        this.viewportStack.reset();
    }

    public void setMouse(int mouseX, int mouseY, int mouseButton)
    {
        this.setMouse(mouseX, mouseY);
        this.mouseButton = mouseButton;
    }

    public void setMouseWheel(int mouseX, int mouseY, int mouseWheel)
    {
        this.setMouse(mouseX, mouseY);
        this.mouseWheel = mouseWheel;
    }

    public void setKey(char typedChar, int keyCode)
    {
        this.typedChar = typedChar;
        this.keyCode = keyCode;
    }

    public void reset()
    {
        this.viewportStack.reset();

        this.resetTooltip();
    }

    public void resetTooltip()
    {
        this.tooltip.set(null, null);

        if (this.activeElement instanceof GuiElement && !((GuiElement) this.activeElement).canBeSeen())
        {
            this.unfocus();
        }
    }

    /* Tooltip */

    public void drawTooltip()
    {
        this.tooltip.drawTooltip(this);
    }

    /* Element focusing */

    public boolean isFocused()
    {
        return this.activeElement != null;
    }

    public void focus(IFocusedGuiElement element)
    {
        this.focus(element, false);
    }

    public void focus(IFocusedGuiElement element, boolean select)
    {
        if (this.activeElement == element)
        {
            return;
        }

        if (this.activeElement != null)
        {
            this.activeElement.unfocus(this);

            if (select)
            {
                this.activeElement.unselect(this);
            }
        }

        this.activeElement = element;

        if (this.activeElement != null)
        {
            this.activeElement.focus(this);

            if (select)
            {
                this.activeElement.selectAll(this);
            }
        }
    }

    public void unfocus()
    {
        this.focus(null);
    }

    public boolean focus(GuiElement parent, int index, int factor)
    {
        return this.focus(parent, index, factor, false);
    }

    /**
     * Focus next focusable GUI element
     */
    public boolean focus(GuiElement parent, int index, int factor, boolean stop)
    {
        List<IGuiElement> children = parent.getChildren();

        factor = factor >= 0 ? 1 : -1;
        index += factor;

        for (; index >= 0 && index < children.size(); index += factor)
        {
            IGuiElement child = children.get(index);

            if (!child.isEnabled())
            {
                continue;
            }

            if (child instanceof IFocusedGuiElement)
            {
                this.focus((IFocusedGuiElement) child, true);

                return true;
            }
            else if (child instanceof GuiElement)
            {
                int start = factor > 0 ? -1 : ((GuiElement) child).getChildren().size();

                if (this.focus((GuiElement) child, start, factor, true))
                {
                    return true;
                }
            }
        }

        GuiElement grandparent = parent.getParent();
        boolean isRoot = grandparent == this.screen.root;

        if (grandparent != null && !stop && (isRoot || grandparent.canBeSeen()))
        {
            /* Forgive me for this heresy, but I have no idea what other name I could give
             * to this variable */
            List<IGuiElement> childs = grandparent.getChildren();

            if (this.focus(grandparent, childs.indexOf(parent), factor))
            {
                return true;
            }

            if (isRoot)
            {
                if (this.focus(grandparent, factor > 0 ? -1 : childs.size() - 1, factor))
                {
                    return true;
                }
            }
        }

        return false;
    }

    /* Context menu */

    public boolean hasContextMenu()
    {
        if (this.contextMenu == null)
        {
            return false;
        }

        if (!this.contextMenu.hasParent())
        {
            this.contextMenu = null;
        }

        return this.contextMenu != null;
    }

    public void setContextMenu(GuiContextMenu menu)
    {
        if (this.hasContextMenu() || menu == null)
        {
            return;
        }

        menu.setMouse(this);
        menu.resize();

        this.contextMenu = menu;
        this.screen.root.add(menu);
    }

    public void replaceContextMenu(GuiContextMenu menu)
    {
        if (menu == null)
        {
            return;
        }

        if (this.contextMenu != null)
        {
            this.contextMenu.removeFromParent();
        }

        menu.setMouse(this);
        menu.resize();

        this.contextMenu = menu;
        this.screen.root.add(menu);
    }

    /* Viewport */

    /**
     * Get absolute X coordinate of the mouse without the
     * scrolling areas applied
     */
    public int mouseX()
    {
        return this.globalX(this.mouseX);
    }

    /**
     * Get absolute Y coordinate of the mouse without the
     * scrolling areas applied
     */
    public int mouseY()
    {
        return this.globalY(this.mouseY);
    }

    @Override
    public int getShiftX()
    {
        return this.mouseX;
    }

    @Override
    public int getShiftY()
    {
        return this.mouseY;
    }

    @Override
    public int globalX(int x)
    {
        return this.viewportStack.globalX(x);
    }

    @Override
    public int globalY(int y)
    {
        return this.viewportStack.globalY(y);
    }

    @Override
    public int localX(int x)
    {
        return this.viewportStack.localX(x);
    }

    @Override
    public int localY(int y)
    {
        return this.viewportStack.localY(y);
    }

    @Override
    public void shiftX(int x)
    {
        this.mouseX += x;
        this.viewportStack.shiftX(x);
    }

    @Override
    public void shiftY(int y)
    {
        this.mouseY += y;
        this.viewportStack.shiftY(y);
    }

    @Override
    public void pushViewport(Area viewport)
    {
        this.viewportStack.pushViewport(viewport);
    }

    @Override
    public void popViewport()
    {
        this.viewportStack.popViewport();
    }

    @Override
    public Area getViewport()
    {
        return this.viewportStack.getViewport();
    }
}

==================================================

--- Файл №64 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiDraw.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import net.minecraft.util.ResourceLocation;
import org.lwjgl.opengl.GL11;

import java.util.List;
import java.util.Stack;

public class GuiDraw
{
    private final static Stack<Area> scissors = new Stack<Area>();

    public static void scissor(int x, int y, int w, int h, GuiContext context)
    {
        scissor(context.globalX(x), context.globalY(y), w, h, context.screen.width, context.screen.height);
    }

    /**
     * Scissor (clip) the screen
     */
    public static void scissor(int x, int y, int w, int h, int sw, int sh)
    {
        Area scissor = scissors.isEmpty() ? null : scissors.peek();

        /* If it was scissored before, then clamp to the bounds of the last one */
        if (scissor != null)
        {
            w += Math.min(x - scissor.x, 0);
            h += Math.min(y - scissor.y, 0);
            x = MathUtils.clamp(x, scissor.x, scissor.ex());
            y = MathUtils.clamp(y, scissor.y, scissor.ey());
            w = MathUtils.clamp(w, 0, scissor.ex() - x);
            h = MathUtils.clamp(h, 0, scissor.ey() - y);
        }

        scissor = new Area(x, y, w, h);
        scissorArea(x, y, w, h, sw, sh);
        scissors.add(scissor);
    }

    private static void scissorArea(int x, int y, int w, int h, int sw, int sh)
    {
        /* Clipping area around scroll area */
        Minecraft mc = Minecraft.getMinecraft();

        float rx = (float) Math.ceil(mc.displayWidth / (double) sw);
        float ry = (float) Math.ceil(mc.displayHeight / (double) sh);

        int xx = (int) (x * rx);
        int yy = (int) (mc.displayHeight - (y + h) * ry);
        int ww = (int) (w * rx);
        int hh = (int) (h * ry);

        GL11.glEnable(GL11.GL_SCISSOR_TEST);

        if (ww == 0 || hh == 0)
        {
            GL11.glScissor(0, 0, 1, 1);
        }
        else
        {
            GL11.glScissor(xx, yy, ww, hh);
        }
    }

    public static void unscissor(GuiContext context)
    {
        unscissor(context.screen.width, context.screen.height);
    }

    public static void unscissor(int sw, int sh)
    {
        scissors.pop();

        if (scissors.isEmpty())
        {
            GL11.glDisable(GL11.GL_SCISSOR_TEST);
        }
        else
        {
            Area area = scissors.peek();

            scissorArea(area.x, area.y, area.w, area.h, sw, sh);
        }
    }

    public static void drawHorizontalGradientRect(int left, int top, int right, int bottom, int startColor, int endColor)
    {
        drawHorizontalGradientRect(left, top, right, bottom, startColor, endColor, 0);
    }

    /**
     * Draws a rectangle with a horizontal gradient between with specified
     * colors, the code is borrowed form drawGradient()
     */
    public static void drawHorizontalGradientRect(int left, int top, int right, int bottom, int startColor, int endColor, float zLevel)
    {
        float a1 = (startColor >> 24 & 255) / 255.0F;
        float r1 = (startColor >> 16 & 255) / 255.0F;
        float g1 = (startColor >> 8 & 255) / 255.0F;
        float b1 = (startColor & 255) / 255.0F;
        float a2 = (endColor >> 24 & 255) / 255.0F;
        float r2 = (endColor >> 16 & 255) / 255.0F;
        float g2 = (endColor >> 8 & 255) / 255.0F;
        float b2 = (endColor & 255) / 255.0F;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(right, top, zLevel).color(r2, g2, b2, a2).endVertex();
        buffer.pos(left, top, zLevel).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left, bottom, zLevel).color(r1, g1, b1, a1).endVertex();
        buffer.pos(right, bottom, zLevel).color(r2, g2, b2, a2).endVertex();

        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableTexture2D();
    }

    public static void drawVerticalGradientRect(int left, int top, int right, int bottom, int startColor, int endColor)
    {
        drawVerticalGradientRect(left, top, right, bottom, startColor, endColor, 0);
    }

    /**
     * Draws a rectangle with a vertical gradient between with specified
     * colors
     */
    public static void drawVerticalGradientRect(int left, int top, int right, int bottom, int startColor, int endColor, float zLevel)
    {
        float a1 = (startColor >> 24 & 255) / 255.0F;
        float r1 = (startColor >> 16 & 255) / 255.0F;
        float g1 = (startColor >> 8 & 255) / 255.0F;
        float b1 = (startColor & 255) / 255.0F;
        float a2 = (endColor >> 24 & 255) / 255.0F;
        float r2 = (endColor >> 16 & 255) / 255.0F;
        float g2 = (endColor >> 8 & 255) / 255.0F;
        float b2 = (endColor & 255) / 255.0F;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(right, top, zLevel).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left, top, zLevel).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left, bottom, zLevel).color(r2, g2, b2, a2).endVertex();
        buffer.pos(right, bottom, zLevel).color(r2, g2, b2, a2).endVertex();

        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableTexture2D();
    }

    public static void drawBillboard(int x, int y, int u, int v, int w, int h, int textureW, int textureH)
    {
        drawBillboard(x, y, u, v, w, h, textureW, textureH, 0);
    }

    /**
     * Draw a textured quad with given UV, dimensions and custom texture size
     */
    public static void drawBillboard(int x, int y, int u, int v, int w, int h, int textureW, int textureH, float z)
    {
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
        drawBillboard(buffer, x, y, u, v, w, h, textureW, textureH, z);
        tessellator.draw();
    }

    public static void drawBillboard(BufferBuilder buffer, int x, int y, int u, int v, int w, int h, int textureW, int textureH, float z)
    {
        float tw = 1F / textureW;
        float th = 1F / textureH;

        buffer.pos(x, y + h, z).tex(u * tw, (v + h) * th).endVertex();
        buffer.pos(x + w, y + h, z).tex((u + w) * tw, (v + h) * th).endVertex();
        buffer.pos(x + w, y, z).tex((u + w) * tw, v * th).endVertex();
        buffer.pos(x, y, z).tex(u * tw, v * th).endVertex();
    }

    public static void drawBillboard(int x, int y, int u, int v, int w, int h, int textureW, int textureH, int tu, int tv)
    {
        drawBillboard(x, y, u, v, w, h, textureW, textureH, tu, tv, 0);
    }

    /**
     * Draw a textured quad with given UV, dimensions and custom texture size
     */
    public static void drawBillboard(int x, int y, int u, int v, int w, int h, int textureW, int textureH, int tu, int tv, float z)
    {
        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);
        drawBillboard(buffer, x, y, u, v, w, h, textureW, textureH, tu, tv, z);
        tessellator.draw();
    }

    public static void drawBillboard(BufferBuilder buffer, int x, int y, int u, int v, int w, int h, int textureW, int textureH, int tu, int tv, float z)
    {
        float tw = 1F / textureW;
        float th = 1F / textureH;

        buffer.pos(x, y + h, z).tex(u * tw, tv * th).endVertex();
        buffer.pos(x + w, y + h, z).tex(tu * tw, tv * th).endVertex();
        buffer.pos(x + w, y, z).tex(tu * tw, v * th).endVertex();
        buffer.pos(x, y, z).tex(u * tw, v * th).endVertex();
    }

    public static int drawBorder(Area area, int color)
    {
        if (!McLib.enableBorders.get())
        {
            area.draw(color);

            return 0;
        }

        area.draw(0xff000000);
        area.draw(color, 1);

        return 1;
    }

    public static void drawOutlineCenter(int x, int y, int offset, int color)
    {
        drawOutlineCenter(x, y, offset, color, 1);
    }

    public static void drawOutlineCenter(int x, int y, int offset, int color, int border)
    {
        drawOutline(x - offset, y - offset, x + offset, y + offset, color, border);
    }

    public static void drawOutline(int left, int top, int right, int bottom, int color)
    {
        drawOutline(left, top, right, bottom, color, 1);
    }

    /**
     * Draw rectangle outline with given border
     */
    public static void drawOutline(int left, int top, int right, int bottom, int color, int border)
    {
        Gui.drawRect(left, top, left + border, bottom, color);
        Gui.drawRect(right - border, top, right, bottom, color);
        Gui.drawRect(left + border, top, right - border, top + border, color);
        Gui.drawRect(left + border, bottom - border, right - border, bottom, color);
    }

    public static void drawOutlinedIcon(Icon icon, int x, int y, int color)
    {
        drawOutlinedIcon(icon, x, y, color, 0F, 0F);
    }

    /**
     * Draw an icon with a black outline
     */
    public static void drawOutlinedIcon(Icon icon, int x, int y, int color, float ax, float ay)
    {
        GlStateManager.color(0, 0, 0, 1);
        icon.render(x - 1, y, ax, ay);
        icon.render(x + 1, y, ax, ay);
        icon.render(x, y - 1, ax, ay);
        icon.render(x, y + 1, ax, ay);
        ColorUtils.bindColor(color);
        icon.render(x, y, ax, ay);
    }

    public static void drawLockedArea(GuiElement element)
    {
        drawLockedArea(element, 0);
    }

    /**
     * Generic method for drawing locked (disabled) state of
     * an input field
     */
    public static void drawLockedArea(GuiElement element, int padding)
    {
        if (!element.isEnabled())
        {
            element.area.draw(ColorUtils.HALF_BLACK, padding);

            GuiDraw.drawOutlinedIcon(Icons.LOCKED, element.area.mx(), element.area.my(), 0xffffffff, 0.5F, 0.5F);
        }
    }

    public static void drawDropShadow(int left, int top, int right, int bottom, int offset, int opaque, int shadow)
    {
        left -= offset;
        top -= offset;
        right += offset;
        bottom += offset;

        float a1 = (opaque >> 24 & 255) / 255.0F;
        float r1 = (opaque >> 16 & 255) / 255.0F;
        float g1 = (opaque >> 8 & 255) / 255.0F;
        float b1 = (opaque & 255) / 255.0F;
        float a2 = (shadow >> 24 & 255) / 255.0F;
        float r2 = (shadow >> 16 & 255) / 255.0F;
        float g2 = (shadow >> 8 & 255) / 255.0F;
        float b2 = (shadow & 255) / 255.0F;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

        /* Draw opaque part */
        buffer.pos(right - offset, top + offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left + offset, top + offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left + offset, bottom - offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(right - offset, bottom - offset, 0).color(r1, g1, b1, a1).endVertex();

        /* Draw top shadow */
        buffer.pos(right, top, 0).color(r2, g2, b2, a2).endVertex();
        buffer.pos(left, top, 0).color(r2, g2, b2, a2).endVertex();
        buffer.pos(left + offset, top + offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(right - offset, top + offset, 0).color(r1, g1, b1, a1).endVertex();

        /* Draw bottom shadow */
        buffer.pos(right - offset, bottom - offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left + offset, bottom - offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left, bottom, 0).color(r2, g2, b2, a2).endVertex();
        buffer.pos(right, bottom, 0).color(r2, g2, b2, a2).endVertex();

        /* Draw left shadow */
        buffer.pos(left + offset, top + offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(left, top, 0).color(r2, g2, b2, a2).endVertex();
        buffer.pos(left, bottom, 0).color(r2, g2, b2, a2).endVertex();
        buffer.pos(left + offset, bottom - offset, 0).color(r1, g1, b1, a1).endVertex();

        /* Draw right shadow */
        buffer.pos(right, top, 0).color(r2, g2, b2, a2).endVertex();
        buffer.pos(right - offset, top + offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(right - offset, bottom - offset, 0).color(r1, g1, b1, a1).endVertex();
        buffer.pos(right, bottom, 0).color(r2, g2, b2, a2).endVertex();

        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableTexture2D();
    }

    public static void drawDropCircleShadow(int x, int y, int radius, int segments, int opaque, int shadow)
    {
        float a1 = (opaque >> 24 & 255) / 255.0F;
        float r1 = (opaque >> 16 & 255) / 255.0F;
        float g1 = (opaque >> 8 & 255) / 255.0F;
        float b1 = (opaque & 255) / 255.0F;
        float a2 = (shadow >> 24 & 255) / 255.0F;
        float r2 = (shadow >> 16 & 255) / 255.0F;
        float g2 = (shadow >> 8 & 255) / 255.0F;
        float b2 = (shadow & 255) / 255.0F;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_TRIANGLE_FAN, DefaultVertexFormats.POSITION_COLOR);

        buffer.pos(x, y, 0).color(r1, g1, b1, a1).endVertex();

        for (int i = 0; i <= segments; i ++)
        {
            double a = i / (double) segments * Math.PI * 2 - Math.PI / 2;

            buffer.pos(x - Math.cos(a) * radius, y + Math.sin(a) * radius, 0).color(r2, g2, b2, a2).endVertex();
        }

        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableTexture2D();
    }

    public static void drawDropCircleShadow(int x, int y, int radius, int offset, int segments, int opaque, int shadow)
    {
        if (offset >= radius)
        {
            drawDropCircleShadow(x, y, radius, segments, opaque, shadow);

            return;
        }

        float a1 = (opaque >> 24 & 255) / 255.0F;
        float r1 = (opaque >> 16 & 255) / 255.0F;
        float g1 = (opaque >> 8 & 255) / 255.0F;
        float b1 = (opaque & 255) / 255.0F;
        float a2 = (shadow >> 24 & 255) / 255.0F;
        float r2 = (shadow >> 16 & 255) / 255.0F;
        float g2 = (shadow >> 8 & 255) / 255.0F;
        float b2 = (shadow & 255) / 255.0F;

        GlStateManager.disableTexture2D();
        GlStateManager.enableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.tryBlendFuncSeparate(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA, GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ZERO);
        GlStateManager.shadeModel(GL11.GL_SMOOTH);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        /* Draw opaque base */
        buffer.begin(GL11.GL_TRIANGLE_FAN, DefaultVertexFormats.POSITION_COLOR);
        buffer.pos(x, y, 0).color(r1, g1, b1, a1).endVertex();

        for (int i = 0; i <= segments; i ++)
        {
            double a = i / (double) segments * Math.PI * 2 - Math.PI / 2;

            buffer.pos(x - Math.cos(a) * offset, y + Math.sin(a) * offset, 0).color(r1, g1, b1, a1).endVertex();
        }

        tessellator.draw();

        /* Draw outer shadow */
        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_COLOR);

        for (int i = 0; i < segments; i ++)
        {
            double alpha1 = i / (double) segments * Math.PI * 2 - Math.PI / 2;
            double alpha2 = (i + 1) / (double) segments * Math.PI * 2 - Math.PI / 2;

            buffer.pos(x - Math.cos(alpha2) * offset, y + Math.sin(alpha2) * offset, 0).color(r1, g1, b1, a1).endVertex();
            buffer.pos(x - Math.cos(alpha1) * offset, y + Math.sin(alpha1) * offset, 0).color(r1, g1, b1, a1).endVertex();
            buffer.pos(x - Math.cos(alpha1) * radius, y + Math.sin(alpha1) * radius, 0).color(r2, g2, b2, a2).endVertex();
            buffer.pos(x - Math.cos(alpha2) * radius, y + Math.sin(alpha2) * radius, 0).color(r2, g2, b2, a2).endVertex();
        }

        tessellator.draw();

        GlStateManager.shadeModel(GL11.GL_FLAT);
        GlStateManager.disableBlend();
        GlStateManager.enableAlpha();
        GlStateManager.enableTexture2D();
    }

    public static int drawMultiText(FontRenderer font, String text, int x, int y, int color, int width)
    {
        return drawMultiText(font, text, x, y, color, width, 12);
    }

    public static int drawMultiText(FontRenderer font, String text, int x, int y, int color, int width, int lineHeight)
    {
        return drawMultiText(font, text, x, y, color, width, lineHeight, 0F, 0F);
    }

    public static int drawMultiText(FontRenderer font, String text, int x, int y, int color, int width, int lineHeight, float ax, float ay)
    {
        List<String> list = font.listFormattedStringToWidth(text, width);
        int h = (lineHeight * (list.size() - 1)) + font.FONT_HEIGHT;

        y -= h * ay;

        for (String string : list)
        {
            font.drawStringWithShadow(string, x + (width - font.getStringWidth(string)) * ax, y, color);

            y += lineHeight;
        }

        return h;
    }

    public static void drawTextBackground(FontRenderer font, String text, int x, int y, int color, int background)
    {
        drawTextBackground(font, text, x, y, color, background, 3);
    }

    public static void drawTextBackground(FontRenderer font, String text, int x, int y, int color, int background, int offset)
    {
        drawTextBackground(font, text, x, y, color, background, offset, true);
    }

    public static void drawTextBackground(FontRenderer font, String text, int x, int y, int color, int background, int offset, boolean shadow)
    {
        int a = background >> 24 & 0xff;

        if (a != 0)
        {
            Gui.drawRect(x - offset, y - offset, x + font.getStringWidth(text) + offset, y + font.FONT_HEIGHT + offset, background);
        }

        font.drawString(text, x, y, color, shadow);
    }

    public static void drawCustomBackground(int x, int y, int width, int height)
    {
        ResourceLocation background = McLib.backgroundImage.get();
        int color = McLib.backgroundColor.get();

        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();
        GlStateManager.blendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);

        if (background == null)
        {
            Gui.drawRect(x, y, x + width, y + height, color);
        }
        else
        {
            Minecraft.getMinecraft().renderEngine.bindTexture(background);
            ColorUtils.bindColor(color);
            GlStateManager.enableAlpha();
            GuiDraw.drawBillboard(x, y, 0, 0, width, height, width, height);
        }
    }

    public static void drawRepeatBillboard(int x, int y, int w, int h, int u, int v, int tileW, int tileH, int tw, int th)
    {
        int countX = ((w - 1) / tileW) + 1;
        int countY = ((h - 1) / tileH) + 1;
        int fillerX = w - (countX - 1) * tileW;
        int fillerY = h - (countY - 1) * tileH;

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        buffer.begin(GL11.GL_QUADS, DefaultVertexFormats.POSITION_TEX);

        for (int i = 0, c = countX * countY; i < c; i ++)
        {
            int ix = i % countX;
            int iy = i / countX;
            int xx = x + ix * tileW;
            int yy = y + iy * tileH;
            int xw = ix == countX - 1 ? fillerX : tileW;
            int yh = iy == countY - 1 ? fillerY : tileH;

            drawBillboard(buffer, xx, yy, u, v, xw, yh, tw, th, 0);
        }

        tessellator.draw();
    }
}

==================================================

--- Файл №65 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiDrawable.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import java.util.function.Consumer;

import mchorse.mclib.client.gui.framework.elements.IGuiElement;
import mchorse.mclib.client.gui.utils.Area;

public class GuiDrawable implements IGuiElement
{
    public Consumer<GuiContext> callback;

    public GuiDrawable(Consumer<GuiContext> callback)
    {
        this.callback = callback;
    }

    @Override
    public void resize()
    {}

    @Override
    public boolean isEnabled()
    {
        return false;
    }

    @Override
    public boolean isVisible()
    {
        return true;
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        return false;
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return false;
    }

    @Override
    public void mouseReleased(GuiContext context)
    {}

    @Override
    public boolean keyTyped(GuiContext context)
    {
        return false;
    }

    @Override
    public boolean canBeDrawn(Area viewport)
    {
        return true;
    }

    @Override
    public void draw(GuiContext context)
    {
        if (this.callback != null)
        {
            this.callback.accept(context);
        }
    }
}

==================================================

--- Файл №66 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiInventoryElement.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.ScrollArea;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.FontRenderer;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.gui.GuiScreen;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.RenderItem;
import net.minecraft.client.util.ITooltipFlag;
import net.minecraft.client.util.SearchTreeManager;
import net.minecraft.item.ItemStack;
import net.minecraft.util.NonNullList;
import net.minecraft.util.text.TextFormatting;
import org.lwjgl.opengl.GL11;

import java.util.List;

public class GuiInventoryElement extends GuiElement
{
    public static NonNullList<ItemStack> container;

    public GuiTrackpadElement count;
    public GuiIconElement toggle;
    public GuiTextElement search;

    public GuiSlotElement slot;
    protected ScrollArea inventory = new ScrollArea(20);
    protected Area hotbar = new Area();

    private ItemStack active = ItemStack.EMPTY;
    private boolean searching;

    public static void drawItemStack(ItemStack stack, int x, int y, String altText)
    {
        drawItemStack(stack, x, y, 200, altText);
    }

    /**
     * Draws an ItemStack.
     *
     * The z index is increased by 32 (and not decreased afterwards), and the item is then rendered at z=200.
     */
    public static void drawItemStack(ItemStack stack, int x, int y, int z, String altText)
    {
        RenderItem itemRender = Minecraft.getMinecraft().getRenderItem();

        GlStateManager.pushMatrix();
        GlStateManager.translate(0.0F, 0.0F, 32.0F);
        itemRender.zLevel = z;

        FontRenderer font = null;
        if (!stack.isEmpty()) font = stack.getItem().getFontRenderer(stack);
        if (font == null) font = Minecraft.getMinecraft().fontRenderer;

        itemRender.renderItemAndEffectIntoGUI(stack, x, y);
        itemRender.renderItemOverlayIntoGUI(font, stack, x, y, altText);
        itemRender.zLevel = 0.0F;
        GlStateManager.popMatrix();
    }

    /**
     * Draw item tooltip
     */
    public static void drawItemTooltip(ItemStack stack, EntityPlayerSP player, FontRenderer providedFont, int x, int y)
    {
        if (stack.isEmpty())
        {
            return;
        }

        List<String> list = stack.getTooltip(player, Minecraft.getMinecraft().gameSettings.advancedItemTooltips ? ITooltipFlag.TooltipFlags.ADVANCED : ITooltipFlag.TooltipFlags.NORMAL);
        FontRenderer font = stack.getItem().getFontRenderer(stack);

        for (int i = 0; i < list.size(); ++i)
        {
            if (i == 0)
            {
                list.set(i, stack.getRarity().rarityColor + list.get(i));
            }
            else
            {
                list.set(i, TextFormatting.GRAY + list.get(i));
            }
        }   

        GuiScreen screen = Minecraft.getMinecraft().currentScreen;

        net.minecraftforge.fml.client.config.GuiUtils.preItemToolTip(stack);
        net.minecraftforge.fml.client.config.GuiUtils.drawHoveringText(list, x, y, screen.width, screen.height, -1, font == null ? providedFont : font);
        net.minecraftforge.fml.client.config.GuiUtils.postItemToolTip();
    }

    public GuiInventoryElement(Minecraft mc, GuiSlotElement slot)
    {
        super(mc);

        this.count = new GuiTrackpadElement(mc, (v) -> this.setCount(v.intValue()));
        this.count.limit(1).integer();
        this.toggle = new GuiIconElement(mc, Icons.SEARCH, this::toggleList);
        this.search = new GuiTextElement(mc, (t) -> this.updateList());
        this.search.setVisible(false);

        this.slot = slot;
        this.flex().wh(10 * 20, 7 * 20);

        this.count.flex().relative(this).x(10).y(10).w(1F, -40);
        this.search.flex().relative(this).x(10).y(10).w(1F, -40);
        this.toggle.flex().relative(this).x(1F, -30).y(10);

        this.add(this.count, this.toggle, this.search);

        this.inventory.scrollSpeed = 20;
    }

    private void setCount(int count)
    {
        ItemStack stack = this.slot.getStack().copy();

        stack.setCount(count);
        this.slot.acceptStack(stack, this.slot.lastSlot);
    }

    private void toggleList(GuiIconElement element)
    {
        this.searching = !this.searching;

        this.updateElements();
        this.updateList();
    }

    private void updateElements()
    {
        this.count.setVisible(!this.searching && !this.slot.getStack().isEmpty());
        this.search.setVisible(this.searching);
        this.inventory.h = this.searching ? 100 : 60;
    }

    private void updateList()
    {
        if (container == null)
        {
            container = NonNullList.create();
        }

        container.clear();
        container.addAll(this.mc.getSearchTree(SearchTreeManager.ITEMS).search(this.search.field.getText().toLowerCase()));

        this.inventory.scroll = 0;
        this.inventory.scrollSize = (int) (Math.ceil(container.size() / 9D) * this.inventory.scrollItemSize);
    }

    private void setStack(ItemStack stack, int slot)
    {
        this.slot.acceptStack(stack, slot);

        this.updateElements();
        this.fillStack(this.slot.getStack());
    }

    public void updateInventory()
    {
        this.inventory.scroll = 0;

        this.searching = false;
        this.fillStack(this.slot.getStack());
        this.updateElements();
    }

    private void fillStack(ItemStack stack)
    {
        this.count.setVisible(!stack.isEmpty());
        this.count.limit(1, stack.getMaxStackSize());
        this.count.setValue(stack.getCount());
    }

    @Override
    public void resize()
    {
        super.resize();

        int tile = 20;
        int row = 9 * tile;
        int fourth = this.area.h / 4;

        this.inventory.set(this.area.mx(row), this.area.ey() - (fourth + tile) / 2 - tile * 4, row, (this.searching ? 5 : 3) * tile);
        this.hotbar.set(this.area.mx(row), this.area.ey() - (fourth + tile) / 2, row, tile);
    }

    @Override
    public boolean mouseClicked(GuiContext context)
    {
        if (super.mouseClicked(context))
        {
            return true;
        }

        if (!this.area.isInside(context))
        {
            this.removeFromParent();

            return false;
        }

        if (this.searching && this.inventory.mouseClicked(context))
        {
            return true;
        }

        boolean inventory = this.inventory.isInside(context);
        boolean hotbar = this.hotbar.isInside(context);

        if ((inventory || hotbar) && context.mouseButton == 0)
        {
            Area area = inventory ? this.inventory : this.hotbar;

            int x = (context.mouseX - area.x - 2) / 20;
            int y = (context.mouseY - area.y - 2) / 20;

            if (inventory && !this.searching)
            {
                y += 1;
            }

            if (x >= 9 || y >= (this.inventory.h / 20) + 1 || x < 0 || y < 0 || !this.isVisible())
            {
                return true;
            }

            int index = x + y * 9;

            if (this.slot != null)
            {
                NonNullList<ItemStack> items = this.searching ? container : this.mc.player.inventory.mainInventory;

                if (this.searching)
                {
                    index += this.inventory.scroll / 20 * 9;
                }

                if (index < items.size())
                {
                    this.setStack(items.get(index), this.searching ? -1 : index);
                    this.removeFromParent();
                }

                return true;
            }
        }

        return false;
    }

    @Override
    public boolean mouseScrolled(GuiContext context)
    {
        return super.mouseScrolled(context) || (this.searching && this.inventory.mouseScroll(context));
    }

    @Override
    public void mouseReleased(GuiContext context)
    {
        super.mouseReleased(context);

        this.inventory.mouseReleased(context);
    }

    @Override
    public void draw(GuiContext context)
    {
        this.active = null;

        /* Background rendering */
        GlStateManager.clear(GL11.GL_DEPTH_BUFFER_BIT);

        int border = 0xffffffff;
        int fourth = this.area.y(0.75F);

        if (McLib.enableBorders.get())
        {
            Gui.drawRect(this.area.x + 1, this.area.y, this.area.ex() - 1, this.area.ey(), 0xff000000);
            Gui.drawRect(this.area.x, this.area.y + 1, this.area.ex(), this.area.ey() - 1, 0xff000000);
            Gui.drawRect(this.area.x + 1, this.area.y + 1, this.area.ex() - 1, this.area.ey() - 1, border);
            Gui.drawRect(this.area.x + 2, this.area.y + 2, this.area.ex() - 2, this.area.ey() - 2, 0xffc6c6c6);

            if (!this.searching)
            {
                Gui.drawRect(this.area.x + 1, fourth, this.area.ex() - 1, this.area.ey() - 1, 0xff222222);
            }
        }
        else
        {
            Gui.drawRect(this.area.x, this.area.y, this.area.ex(), this.area.ey(), border);
            Gui.drawRect(this.area.x + 1, this.area.y + 1, this.area.ex() - 1, this.area.ey() - 1, 0xffc6c6c6);

            if (!this.searching)
            {
                Gui.drawRect(this.area.x, fourth, this.area.ex(), this.area.ey(), 0xff222222);
            }
        }

        GuiDraw.drawDropCircleShadow(this.toggle.area.mx(), this.toggle.area.my(), 10, 4, 8, 0x18000000, 0);

        GlStateManager.enableDepth();
        RenderHelper.enableGUIStandardItemLighting();
        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, 240.0F, 240.0F);

        if(this.searching)
        {
            int scroll = 0;

            if (container.size() > 45)
            {
                int rows = (int) Math.ceil(container.size() / 9F);
                float factor = this.inventory.scroll / (float) this.inventory.scrollSize;
                scroll = (int) (factor * rows);
                scroll *= 9;
            }

            int index = this.drawGrid(context, this.inventory, container, -1, scroll, scroll + this.inventory.h / 20 * 9);

            if (index != -1)
            {
                this.active = container.get(index);
            }
        }
        else
        {
            NonNullList<ItemStack> inventory = this.mc.player.inventory.mainInventory;

            int index = this.drawGrid(context, this.inventory, inventory, -1, 9, inventory.size());
            index = this.drawGrid(context, this.hotbar, inventory, index, 0, 9);

            if (index != -1)
            {
                this.active = inventory.get(index);
            }
        }

        if (this.active != null)
        {
            context.tooltip.set(context, this);
        }

        GlStateManager.disableDepth();
        RenderHelper.disableStandardItemLighting();

        GuiDraw.drawLockedArea(this, McLib.enableBorders.get() ? 1 : 0);

        if (this.searching)
        {
            this.inventory.drag(context);

            GuiDraw.scissor(this.inventory.x, this.inventory.y, this.inventory.w, this.inventory.h, context);
            this.inventory.drawScrollbar();
            GuiDraw.unscissor(context);
        }

        super.draw(context);
    }

    private int drawGrid(GuiContext context, Area area, NonNullList<ItemStack> inventory, int index, int i, int c)
    {
        for (int j = 0; j < c - i; j ++)
        {
            int k = i + j;

            if (k >= inventory.size())
            {
                return index;
            }

            ItemStack stack = inventory.get(k);

            int x = j % 9;
            int y = j / 9;

            x = area.x + 2 + 20 * x;
            y = area.y + 2 + 20 * y;

            int diffX = context.mouseX - x;
            int diffY = context.mouseY - y;

            boolean hover = diffX >= 0 && diffX < 18 && diffY >= 0 && diffY < 18;

            Gui.drawRect(x - 1, y - 1, x + 17, y + 17, area == this.hotbar ? 0xaa000000 : 0x44000000);

            drawItemStack(stack, x, y, null);

            if (hover)
            {
                Gui.drawRect(x - 2, y - 2, x + 18, y + 18, 0xcc000000 + McLib.primaryColor.get());
                index = k;
            }
        }

        return index;
    }

    @Override
    public void drawTooltip(GuiContext context, Area area)
    {
        super.drawTooltip(context, area);

        GuiInventoryElement.drawItemTooltip(this.active, this.mc.player, this.font, context.mouseX, context.mouseY);
    }
}

==================================================

--- Файл №67 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiLabel.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ColorUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.GlStateManager;

import javax.annotation.Nullable;
import java.util.function.Supplier;

public class GuiLabel extends GuiElement implements ITextColoring
{
    public IKey label;
    public int color;
    public boolean textShadow = true;
    public float anchorX;
    public float anchorY;
    public int background;
    public Supplier<Integer> backgroundColor;
    private IconContainer leftIcon;
    private IconContainer rightIcon;

    public GuiLabel(Minecraft mc, IKey label)
    {
        this(mc, label, 0xffffff);
    }

    public GuiLabel(Minecraft mc, IKey label, int color)
    {
        this(mc, label, 0xffffff, (IconContainer) null, null);
    }

    public GuiLabel(Minecraft mc, IKey label, int color, @Nullable Icon leftIcon, @Nullable Icon rightIcon)
    {
        super(mc);

        this.label = label;
        this.color = color;
        this.leftIcon = leftIcon != null ? new IconContainer(leftIcon) : null;
        this.rightIcon = rightIcon != null ? new IconContainer(rightIcon) : null;
    }

    public GuiLabel(Minecraft mc, IKey label, int color, @Nullable IconContainer leftIcon, @Nullable IconContainer rightIcon)
    {
        super(mc);

        this.label = label;
        this.color = color;
        this.leftIcon = leftIcon;
        this.rightIcon = rightIcon;
    }

    public GuiLabel(Minecraft mc, IKey label, @Nullable Icon leftIcon, @Nullable Icon rightIcon)
    {
        this(mc, label, 0xffffff, leftIcon, rightIcon);
    }

    public IconContainer getLeftIcon()
    {
        return this.leftIcon;
    }

    public void setLeftIcon(Icon leftIcon)
    {
        if (this.leftIcon != null)
        {
            this.leftIcon.setIcon(leftIcon);
        }
        else
        {
            this.leftIcon = new IconContainer(leftIcon);
        }
    }

    public IconContainer getRightIcon()
    {
        return this.rightIcon;
    }

    public void setRightIcon(Icon rightIcon)
    {
        if (this.rightIcon != null)
        {
            this.rightIcon.setIcon(rightIcon);
        }
        else
        {
            this.rightIcon = new IconContainer(rightIcon);
        }
    }

    public void setRightIconContainer(IconContainer rightIcon)
    {
        this.rightIcon = rightIcon;
    }

    public void setLeftIconContainer(IconContainer leftIcon)
    {
        this.leftIcon = leftIcon;
    }

    @Override
    public void setColor(int color, boolean shadow)
    {
        this.color(color, shadow);
    }

    public GuiLabel color(int color)
    {
        return this.color(color, true);
    }

    public GuiLabel color(int color, boolean textShadow)
    {
        this.textShadow = textShadow;
        this.color = color;

        return this;
    }

    public GuiLabel background()
    {
        return this.background(ColorUtils.HALF_BLACK);
    }

    public GuiLabel background(int color)
    {
        this.background = color;

        return this;
    }

    public GuiLabel background(Supplier<Integer> color)
    {
        this.backgroundColor = color;

        return this;
    }

    public GuiLabel anchor(float x, float y)
    {
        this.anchorX = x;
        this.anchorY = y;

        return this;
    }

    public int getColor()
    {
        return this.backgroundColor == null ? this.background : this.backgroundColor.get();
    }

    @Override
    public void draw(GuiContext context)
    {
        int offset = 3;
        int leftIconW = this.leftIcon != null ? this.leftIcon.getW() : 0;
        int rightIconW = this.rightIcon != null ? this.rightIcon.getW() : 0;
        int textWidth = this.font.getStringWidth(this.label.get());
        int width = textWidth + rightIconW + leftIconW;
        int x0 = this.area.x(this.anchorX, width);
        int x1 = x0 + width;
        int y = this.area.y(this.anchorY, this.font.FONT_HEIGHT);

        int xText = x0 + leftIconW;

        int a = this.getColor() >> 24 & 0xff;

        if (a != 0)
        {
            Gui.drawRect(x0, y - offset, x1 + 2 * offset, y + font.FONT_HEIGHT, this.getColor());

            x0 += offset;
            xText += offset;
        }

        GlStateManager.color(1,1,1,1);

        if (this.leftIcon != null)
        {
            this.leftIcon.render(x0, y, 0.5F, 0.5F);
        }

        if (this.rightIcon != null)
        {
            this.rightIcon.render(xText + textWidth, y, 0.5F, 0.5F);
        }

        this.font.drawString(this.label.get(), xText, y, this.color, this.textShadow);

        super.draw(context);
    }
}

==================================================

--- Файл №68 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\GuiViewportStack.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IViewport;
import mchorse.mclib.client.gui.utils.Area;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

/**
 * Viewport stack
 *
 * This class is responsible for calculating and keeping track of
 * embedded (into each other) scrolling areas
 */
public class GuiViewportStack implements IViewportStack
{
    private Stack<Area> viewportStack = new Stack<Area>();
    private List<Area> viewportAreas = new ArrayList<Area>();
    private int shiftX;
    private int shiftY;

    public static GuiViewportStack fromElement(GuiElement element)
    {
        GuiViewportStack stack = new GuiViewportStack();

        stack.applyFromElement(element);

        return stack;
    }

    public void applyFromElement(GuiElement element)
    {
        List<IViewport> elements = new ArrayList<IViewport>();

        while (element != null)
        {
            if (element instanceof IViewport)
            {
                elements.add((IViewport) element);
            }

            element = element.getParent();
        }

        for (int i = elements.size() - 1; i >= 0; i--)
        {
            elements.get(i).apply(this);
        }
    }

    @Override
    public void reset()
    {
        this.shiftX = 0;
        this.shiftY = 0;

        this.viewportStack.clear();
    }

    @Override
    public Area getViewport()
    {
        return this.viewportStack.peek();
    }

    @Override
    public void pushViewport(Area area)
    {
        if (this.viewportStack.isEmpty())
        {
            Area child = this.getCurrentViewportArea();

            child.copy(area);
            this.viewportStack.push(child);
        }
        else
        {
            Area current = this.viewportStack.peek();
            Area child = this.getCurrentViewportArea();

            child.copy(area);
            current.clamp(child);
            this.viewportStack.push(child);
        }
    }

    private Area getCurrentViewportArea()
    {
        while (this.viewportAreas.size() < this.viewportStack.size() + 1)
        {
            this.viewportAreas.add(new Area());
        }

        return this.viewportAreas.get(this.viewportStack.size());
    }

    @Override
    public void popViewport()
    {
        this.viewportStack.pop();
    }

    @Override
    public int getShiftX()
    {
        return this.shiftX;
    }

    @Override
    public int getShiftY()
    {
        return this.shiftY;
    }

    /**
     * Get global X (relative to root element/screen)
     */
    @Override
    public int globalX(int x)
    {
        return x - this.shiftX;
    }

    /**
     * Get global Y (relative to root element/screen)
     */
    @Override
    public int globalY(int y)
    {
        return y - this.shiftY;
    }

    /**
     * Get current local X (relative to current viewport)
     */
    @Override
    public int localX(int x)
    {
        return x + this.shiftX;
    }

    /**
     * Get current local Y (relative to current viewport)
     */
    @Override
    public int localY(int y)
    {
        return y + this.shiftY;
    }

    @Override
    public void shiftX(int x)
    {
        this.shiftX += x;

        if (!this.viewportStack.isEmpty())
        {
            this.viewportStack.peek().x += x;
        }
    }

    @Override
    public void shiftY(int y)
    {
        this.shiftY += y;

        if (!this.viewportStack.isEmpty())
        {
            this.viewportStack.peek().y += y;
        }
    }
}

==================================================

--- Файл №69 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\IconContainer.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.utils.Icon;

public class IconContainer
{
    private Icon icon;
    private int w;
    private int h;
    /**
     * anchor where to place the nested icon
     */
    private float ax;
    private float ay;
    private int offsetX;
    private int offsetY;

    /**
     * @param icon
     * @param w the width of the icon or the icon wrapper
     * @param h the height of the icon or the icon wrapper
     * @param ax the anchor point of the icon to render inside the wrapper
     * @param ay the anchor point of the icon to render inside the wrapper
     */
    public IconContainer(Icon icon, int w, int h, float ax, float ay, int offsetX, int offsetY)
    {
        this.icon = icon;
        this.w = w;
        this.h = h;
        this.ax = ax;
        this.ay = ay;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
    }

    /**
     * @param icon
     * @param w the width of the icon or the icon wrapper
     * @param h the height of the icon or the icon wrapper
     * @param ax the anchor point of the icon to render inside the wrapper
     * @param ay the anchor point of the icon to render inside the wrapper
     */
    public IconContainer(Icon icon, int w, int h, float ax, float ay)
    {
        this.icon = icon;
        this.w = w;
        this.h = h;
        this.ax = ax;
        this.ay = ay;
    }

    public IconContainer(Icon icon, int w, int h)
    {
        this(icon, w, h, 0, 0);
    }

    public IconContainer(Icon icon)
    {
        this(icon, icon.w, icon.h);
    }

    public Icon getIcon()
    {
        return this.icon;
    }

    public IconContainer setIcon(Icon icon)
    {
        this.icon = icon;

        return this;
    }

    public int getW()
    {
        return this.w;
    }

    public IconContainer setW(int w)
    {
        this.w = w;

        return this;
    }

    public int getH()
    {
        return this.h;
    }

    public int getOffsetX()
    {
        return this.offsetX;
    }

    public int getOffsetY()
    {
        return this.offsetY;
    }

    public IconContainer setOffsetX(int offsetX)
    {
        this.offsetX = offsetX;

        return this;
    }

    public IconContainer setOffsetY(int offsetY)
    {
        this.offsetY = offsetY;

        return this;
    }

    public IconContainer setH(int h)
    {
        this.h = h;

        return this;
    }

    public float getAx()
    {
        return this.ax;
    }

    public IconContainer setAnchor(float ax, float ay)
    {
        this.ax = ax;
        this.ay = ay;

        return this;
    }

    public float getAy()
    {
        return this.ay;
    }

    public void render(int x, int y)
    {
        this.render(x, y, 0, 0);
    }

    public void render(int x, int y, float ax, float ay)
    {
        x += this.w * this.ax + this.offsetX;
        y += this.h * this.ay + this.offsetY;

        this.icon.render(x, y, ax, ay);
    }
}


==================================================

--- Файл №70 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\ITextColoring.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

public interface ITextColoring
{
    public void setColor(int color, boolean shadow);
}


==================================================

--- Файл №71 ---
Путь: main\java\mchorse\mclib\client\gui\framework\elements\utils\IViewportStack.java
--------------------
package mchorse.mclib.client.gui.framework.elements.utils;

import mchorse.mclib.client.gui.utils.Area;

/**
 * General interface for viewport stack
 */
public interface IViewportStack
{
    public void reset();

    public Area getViewport();

    public void pushViewport(Area area);

    public void popViewport();

    public int getShiftX();

    public int getShiftY();

    /**
     * Get global X (relative to root element/screen)
     */
    public int globalX(int x);

    /**
     * Get global Y (relative to root element/screen)
     */
    public int globalY(int y);

    /**
     * Get current local X (relative to current viewport)
     */
    public int localX(int x);

    /**
     * Get current local Y (relative to current viewport)
     */
    public int localY(int y);

    public void shiftX(int x);

    public void shiftY(int y);
}

==================================================

--- Файл №72 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\GuiTooltip.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.gui.Gui;

import java.util.List;

public class GuiTooltip
{
    public GuiElement element;
    public Area area = new Area();

    public void set(GuiContext context, GuiElement element)
    {
        this.element = element;

        if (element != null)
        {
            this.area.copy(element.area);
            this.area.x = context.globalX(this.area.x);
            this.area.y = context.globalY(this.area.y);
        }
    }

    public void draw(ITooltip tooltip, GuiContext context)
    {
        if (this.element == null || tooltip == null)
        {
            return;
        }

        tooltip.drawTooltip(context);
    }

    public void drawTooltip(GuiContext context)
    {
        if (this.element != null)
        {
            this.element.drawTooltip(context, this.area);
        }
    }
}

==================================================

--- Файл №73 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\InterpolationTooltip.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.InterpolationRenderer;
import mchorse.mclib.utils.IInterpolation;

import java.util.function.Supplier;

public class InterpolationTooltip implements ITooltip
{
    public float ax;
    public float ay;
    public Supplier<IInterpolation> interpolation;
    public Supplier<Integer> duration;
    public int margin = 10;

    public InterpolationTooltip(float ax, float ay, Supplier<IInterpolation> interpolation, Supplier<Integer> duration)
    {
        this.ax = ax;
        this.ay = ay;
        this.interpolation = interpolation;
        this.duration = duration;
    }

    public InterpolationTooltip margin(int margin)
    {
        this.margin = margin;

        return this;
    }

    @Override
    public void drawTooltip(GuiContext context)
    {
        Area area = context.tooltip.area;
        IInterpolation interpolation = this.interpolation == null ? null : this.interpolation.get();
        int duration = this.duration == null ? 40 : this.duration.get();

        float fx = (this.ax - 0.5F) * 2;

        int x = area.x(this.ax) + (int) (this.margin * fx);
        int y = area.y(this.ay);

        InterpolationRenderer.drawInterpolationPreview(interpolation, context, x, y, 1 - this.ax, this.ay, duration);
    }
}

==================================================

--- Файл №74 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\ITooltip.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;

public interface ITooltip
{
    public void drawTooltip(GuiContext context);
}


==================================================

--- Файл №75 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\LabelTooltip.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips;

import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.tooltips.styles.TooltipStyle;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.gui.Gui;

import java.util.List;

public class LabelTooltip implements ITooltip
{
    public IKey label;
    public int width = 200;
    public Direction direction;

    public LabelTooltip(IKey label, Direction direction)
    {
        this.label = label;
        this.direction = direction;
    }

    public LabelTooltip(IKey label, int width, Direction direction)
    {
        this(label, direction);
        this.width = width;
    }

    public void drawTooltip(GuiContext context)
    {
        String label = this.label.get();

        if (label.isEmpty())
        {
            return;
        }

        List<String> strings = context.font.listFormattedStringToWidth(label, this.width);

        if (strings.isEmpty())
        {
            return;
        }

        TooltipStyle style = TooltipStyle.get();
        Direction dir = this.direction;
        Area area = context.tooltip.area;

        this.calculate(context, strings, dir, area, Area.SHARED);

        if (Area.SHARED.intersects(area))
        {
            this.calculate(context, strings, dir.opposite(), area, Area.SHARED);
        }

        Area.SHARED.offset(3);
        style.drawBackground(Area.SHARED);
        Area.SHARED.offset(-3);

        for (String line : strings)
        {
            context.font.drawString(line, Area.SHARED.x, Area.SHARED.y, style.getTextColor());
            Area.SHARED.y += context.font.FONT_HEIGHT + 3;
        }
    }

    private void calculate(GuiContext context, List<String> strings, Direction dir, Area elementArea, Area targetArea)
    {
        int w = strings.size() == 1 ? context.font.getStringWidth(strings.get(0)) : this.width;
        int h = (context.font.FONT_HEIGHT + 3) * strings.size() - 3;
        int x = elementArea.x(dir.anchorX) - (int) (w * (1 - dir.anchorX)) + 6 * dir.factorX;
        int y = elementArea.y(dir.anchorY) - (int) (h * (1 - dir.anchorY)) + 6 * dir.factorY;

        x = MathUtils.clamp(x, 3, context.screen.width - w - 3);
        y = MathUtils.clamp(y, 3, context.screen.height - h - 3);

        targetArea.set(x, y, w, h);
    }
}


==================================================

--- Файл №76 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\styles\DarkTooltipStyle.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips.styles;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;

public class DarkTooltipStyle extends TooltipStyle
{
    @Override
    public void drawBackground(Area area)
    {
        int color = McLib.primaryColor.get();

        GuiDraw.drawDropShadow(area.x, area.y, area.ex(), area.ey(), 6, 0x44000000 + color, color);
        area.draw(0xff000000);
    }

    @Override
    public int getTextColor()
    {
        return 0xffffff;
    }

    @Override
    public int getForegroundColor()
    {
        return McLib.primaryColor.get();
    }
}

==================================================

--- Файл №77 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\styles\LightTooltipStyle.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips.styles;

import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.utils.ColorUtils;

public class LightTooltipStyle extends TooltipStyle
{
    @Override
    public void drawBackground(Area area)
    {
        GuiDraw.drawDropShadow(area.x, area.y, area.ex(), area.ey(), 4, ColorUtils.HALF_BLACK, 0);
        area.draw(0xffffffff);
    }

    @Override
    public int getTextColor()
    {
        return 0;
    }

    @Override
    public int getForegroundColor()
    {
        return 0;
    }
}

==================================================

--- Файл №78 ---
Путь: main\java\mchorse\mclib\client\gui\framework\tooltips\styles\TooltipStyle.java
--------------------
package mchorse.mclib.client.gui.framework.tooltips.styles;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.utils.Area;

public abstract class TooltipStyle
{
    public static final TooltipStyle LIGHT = new LightTooltipStyle();
    public static final TooltipStyle DARK = new DarkTooltipStyle();

    public static TooltipStyle get()
    {
        return get(McLib.tooltipStyle.get());
    }

    public static TooltipStyle get(int style)
    {
        if (style == 0)
        {
            return LIGHT;
        }

        return DARK;
    }

    public abstract void drawBackground(Area area);

    public abstract int getTextColor();

    public abstract int getForegroundColor();
}

==================================================

--- Файл №79 ---
Путь: main\java\mchorse\mclib\client\gui\mclib\GuiAbstractDashboard.java
--------------------
package mchorse.mclib.client.gui.mclib;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.utils.Keybind;
import mchorse.mclib.events.RegisterDashboardPanels;
import mchorse.mclib.permissions.PermissionUtils;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;

import java.util.function.Consumer;

public abstract class GuiAbstractDashboard extends GuiBase
{
    public GuiDashboardPanels panels;
    public GuiDashboardPanel defaultPanel;

    private boolean wasClosed = true;
    private int opLevel = -1;

    public GuiAbstractDashboard(Minecraft mc)
    {
        this.panels = this.createDashboardPanels(mc);

        this.panels.flex().relative(this.viewport).wh(1F, 1F);
        this.registerPanels(mc);

        McLib.EVENT_BUS.post(new RegisterDashboardPanels(this));

        this.root.add(this.panels);
    }

    protected abstract GuiDashboardPanels createDashboardPanels(Minecraft mc);

    protected abstract void registerPanels(Minecraft mc);

    @Override
    public boolean doesGuiPauseGame()
    {
        return false;
    }

    @Override
    public void onGuiClosed()
    {
        this.close();
        super.onGuiClosed();
    }

    private void close()
    {
        this.panels.close();
        this.wasClosed = true;
    }

    @Override
    public void setWorldAndResolution(Minecraft mc, int width, int height)
    {
        this.checkPermissions();

        if (this.wasClosed)
        {
            this.wasClosed = false;
            this.panels.open();
            this.panels.setPanel(this.panels.view.delegate);
        }

        super.setWorldAndResolution(mc, width, height);
    }

    private void checkPermissions()
    {
        int newOpLevel = OpHelper.getPlayerOpLevel();

        for (GuiDashboardPanel panel : this.panels.panels)
        {
            GuiIconElement button = this.panels.getButton(panel);

            Consumer<Boolean> task = (enabled) ->
            {
                button.setEnabled(enabled);

                for (Keybind keybind : this.panels.keys().keybinds)
                {
                    keybind.active(enabled);
                }
            };

            if (panel.getRequiredPermission() != null)
            {
                PermissionUtils.hasPermission(Minecraft.getMinecraft().player, panel.getRequiredPermission(), task);
            }
            else
            {
                task.accept(true);
            }
        }

        GuiDashboardPanel current = this.panels.view.delegate;

        if (current != null && current.getRequiredPermission() != null)
        {
            this.panels.setPanel(null);

            PermissionUtils.hasPermission(Minecraft.getMinecraft().player, current.getRequiredPermission(), (allowed) ->
            {
                if (allowed)
                {
                    this.panels.setPanel(current);
                }
                else
                {
                    this.panels.setPanel(this.defaultPanel);
                }
            });
        }
        else if (current == null)
        {
            this.panels.setPanel(null);
        }

        this.opLevel = newOpLevel;
    }

    @Override
    public void drawScreen(int mouseX, int mouseY, float partialTicks)
    {
        if (this.panels.view.delegate != null && this.panels.view.delegate.needsBackground())
        {
            GuiDraw.drawCustomBackground(0, 0, this.width, this.height);
        }
        else
        {
            this.drawGradientRect(0, 0, this.width, this.height / 8, 0x44000000, 0);
            this.drawGradientRect(0, this.height - this.height / 8, this.width, this.height, 0, 0x44000000);
        }

        super.drawScreen(mouseX, mouseY, partialTicks);
    }
}

==================================================

--- Файл №80 ---
Путь: main\java\mchorse\mclib\client\gui\mclib\GuiDashboard.java
--------------------
package mchorse.mclib.client.gui.mclib;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import net.minecraft.client.Minecraft;

public class GuiDashboard extends GuiAbstractDashboard
{
    public static GuiDashboard dashboard;

    public GuiConfigPanel config;

    public static GuiDashboard get()
    {
        if (dashboard == null)
        {
            dashboard = new GuiDashboard(Minecraft.getMinecraft());
        }

        return dashboard;
    }

    public GuiDashboard(Minecraft mc)
    {
        super(mc);

        this.panels.registerPanel(new GuiGraphPanel(mc, this), IKey.lang("mclib.gui.graph.tooltip"), Icons.GRAPH);
    }

    @Override
    protected GuiDashboardPanels createDashboardPanels(Minecraft mc)
    {
        return new GuiDashboardPanels(mc);
    }

    @Override
    protected void registerPanels(Minecraft mc)
    {
        this.panels.registerPanel(this.config = new GuiConfigPanel(mc, this), IKey.lang("mclib.gui.config.tooltip"), Icons.GEAR);
        this.defaultPanel = this.config;

        if (McLib.debugPanel.get())
        {
            this.panels.registerPanel(new GuiDebugPanel(mc, this), IKey.str("Debug"), Icons.POSE);
        }

        this.panels.setPanel(this.config);
    }
}

==================================================

--- Файл №81 ---
Путь: main\java\mchorse\mclib\client\gui\mclib\GuiDashboardPanel.java
--------------------
package mchorse.mclib.client.gui.mclib;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.permissions.PermissionCategory;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;

public class GuiDashboardPanel <T extends GuiAbstractDashboard> extends GuiElement
{
    public final T dashboard;

    public GuiDashboardPanel(Minecraft mc, T dashboard)
    {
        super(mc);

        this.dashboard = dashboard;
        this.markContainer();
    }

    @Deprecated
    public boolean canBeOpened(int opLevel)
    {
        return this.isClientSideOnly() || OpHelper.isOp(opLevel);
    }

    public PermissionCategory getRequiredPermission()
    {
        return null;
    }

    public boolean isClientSideOnly()
    {
        return false;
    }

    public boolean needsBackground()
    {
        return true;
    }

    public void appear()
    {}

    public void disappear()
    {}

    public void open()
    {}

    public void close()
    {}
}

==================================================

--- Файл №82 ---
Путь: main\java\mchorse\mclib\client\gui\mclib\GuiDashboardPanels.java
--------------------
package mchorse.mclib.client.gui.mclib;

import mchorse.mclib.client.gui.framework.GuiBase;
import mchorse.mclib.client.gui.framework.elements.GuiPanelBase;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icon;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.permissions.PermissionUtils;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import org.lwjgl.input.Keyboard;

import java.util.function.Consumer;

public class GuiDashboardPanels extends GuiPanelBase<GuiDashboardPanel>
{
    public GuiDashboardPanels(Minecraft mc)
    {
        super(mc, Direction.LEFT);
    }

    public void open()
    {
        for (GuiDashboardPanel panel : this.panels)
        {
            Consumer<Boolean> task = (enabled) ->
            {
                if (enabled)
                {
                    panel.open();
                }
            };

            if (panel.getRequiredPermission() != null)
            {
                PermissionUtils.hasPermission(Minecraft.getMinecraft().player, panel.getRequiredPermission(), task);
            }
            else
            {
                task.accept(true);
            }
        }
    }

    public void close()
    {
        for (GuiDashboardPanel panel : this.panels)
        {
            panel.close();
        }
    }

    @Override
    public void setPanel(GuiDashboardPanel panel)
    {
        if (this.view.delegate != null)
        {
            this.view.delegate.disappear();
        }

        super.setPanel(panel);

        if (this.view.delegate != null)
        {
            this.view.delegate.appear();
        }
    }

    @Override
    public GuiIconElement registerPanel(GuiDashboardPanel panel, IKey tooltip, Icon icon)
    {
        GuiIconElement element = super.registerPanel(panel, tooltip, icon);

        int key = this.getKeybind();

        if (key != -1)
        {
            element.keys()
                .register(IKey.comp(IKey.lang("mclib.gui.dashboard.open_panel"), tooltip), key, () -> element.clickItself(GuiBase.getCurrent()))
                .category(IKey.lang("mclib.gui.dashboard.category"));
        }

        return element;
    }

    protected int getKeybind()
    {
        int size = this.panels.size();

        switch (size)
        {
            case 1: return Keyboard.KEY_NUMPAD0;
            case 2: return Keyboard.KEY_NUMPAD1;
            case 3: return Keyboard.KEY_NUMPAD2;
            case 4: return Keyboard.KEY_NUMPAD3;
            case 5: return Keyboard.KEY_NUMPAD4;
            case 6: return Keyboard.KEY_NUMPAD5;
            case 7: return Keyboard.KEY_NUMPAD6;
            case 8: return Keyboard.KEY_NUMPAD7;
            case 9: return Keyboard.KEY_NUMPAD8;
            case 10: return Keyboard.KEY_NUMPAD9;
        }

        return -1;
    }

    @Override
    protected void drawBackground(GuiContext context, int x, int y, int w, int h)
    {
        Gui.drawRect(x, y, x + w, y + h, 0xff111111);
    }
}

==================================================

--- Файл №83 ---
Путь: main\java\mchorse\mclib\client\gui\mclib\GuiDebugPanel.java
--------------------
package mchorse.mclib.client.gui.mclib;

import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiSlotElement;
import mchorse.mclib.client.gui.framework.elements.context.GuiSimpleContextMenu;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.keyframes.GuiDopeSheet;
import mchorse.mclib.client.gui.framework.elements.keyframes.GuiGraphView;
import mchorse.mclib.client.gui.framework.elements.keyframes.GuiKeyframesEditor;
import mchorse.mclib.client.gui.framework.elements.keyframes.GuiSheet;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.keyframes.Keyframe;
import mchorse.mclib.utils.keyframes.KeyframeChannel;
import mchorse.mclib.utils.keyframes.KeyframeInterpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.init.Items;
import net.minecraft.item.ItemStack;

public class GuiDebugPanel extends GuiDashboardPanel<GuiAbstractDashboard>
{
    public GuiKeyframesEditor<GuiDopeSheet> dopesheet;
    public GuiKeyframesEditor<GuiGraphView> graph;

    public GuiButtonElement play;
    public GuiSlotElement slot;
    public GuiTextElement text;

    public GuiDebugPanel(Minecraft mc, GuiAbstractDashboard dashboard)
    {
        super(mc, dashboard);

        this.dopesheet = new GuiKeyframesEditor<GuiDopeSheet>(mc)
        {
            @Override
            protected GuiDopeSheet createElement(Minecraft mc)
            {
                return new GuiDopeSheet(mc, this::fillData);
            }
        };

        this.graph = new GuiKeyframesEditor<GuiGraphView>(mc)
        {
            @Override
            protected GuiGraphView createElement(Minecraft mc)
            {
                return new GuiGraphView(mc, this::fillData);
            }
        };

        KeyframeChannel channel = new KeyframeChannel();

        channel.insert(0, 10);
        Keyframe a = channel.get(channel.insert(20, 10));
        channel.get(channel.insert(80, 0));
        channel.get(channel.insert(100, 0));

        a.interp = KeyframeInterpolation.BEZIER;

        for (int i = 0; i < 5; i++)
        {
            KeyframeChannel c = new KeyframeChannel();

            c.copy(channel);

            this.dopesheet.graph.sheets.add(new GuiSheet("" + i, IKey.str("Test " + i), new Color((float) Math.random(), (float) Math.random(), (float) Math.random()).getRGBColor(), c));
        }

        this.dopesheet.graph.duration = 100;
        this.graph.graph.setChannel(channel, 0x0088ff);
        this.graph.graph.duration = 100;

        this.dopesheet.flex().relative(this).y(0).wh(1F, 0.5F);
        this.graph.flex().relative(this).y(0.5F).wh(1F, 0.5F);

        this.slot = new GuiSlotElement(mc, 0, (t) -> {});
        this.slot.flex().relative(this).x(0.5F).y(20).anchorX(0.5F);
        this.slot.setStack(new ItemStack(Items.BAKED_POTATO, 42));

        this.play = new GuiButtonElement(mc, IKey.str("Play me!"), null).background(false);
        this.play.flex().relative(this).xy(10, 10).w(80);

        this.text = new GuiTextElement(mc, 1000, null).background(false);
        this.text.flex().relative(this).xy(10, 40).w(80);

        this.add(this.graph, this.dopesheet);
        this.add(this.slot, this.play, this.text);

        this.context(() ->
        {
            GuiSimpleContextMenu contextMenu = new GuiSimpleContextMenu(mc);

            for (int i = 0; i < 100; i++)
            {
                contextMenu.action(Icons.POSE, IKey.str("I came §8" + (i + 1)), null);
            }

            return contextMenu;
        });
    }

    @Override
    public boolean isClientSideOnly()
    {
        return true;
    }

    @Override
    public void resize()
    {
        super.resize();
    }

    @Override
    public void draw(GuiContext context)
    {
        super.draw(context);

        this.text.background(System.currentTimeMillis() % 2000 < 1000);
    }
}

==================================================

--- Файл №84 ---
Путь: main\java\mchorse\mclib\client\gui\mclib\GuiGraphPanel.java
--------------------
package mchorse.mclib.client.gui.mclib;

import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiCanvas;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.GuiUtils;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.MathBuilder;
import mchorse.mclib.math.Variable;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Direction;
import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import org.lwjgl.input.Mouse;
import org.lwjgl.opengl.GL11;

public class GuiGraphPanel extends GuiDashboardPanel<GuiDashboard>
{
    public GuiGraphCanvas canvas;
    public GuiTextElement expression;
    public GuiIconElement help;

    public GuiGraphPanel(Minecraft mc, GuiDashboard dashboard)
    {
        super(mc, dashboard);

        this.canvas = new GuiGraphCanvas(mc);
        this.expression = new GuiTextElement(mc, 10000, this.canvas::parseExpression);
        this.help = new GuiIconElement(mc, Icons.HELP, (b) -> GuiUtils.openWebLink("https://github.com/mchorse/aperture/wiki/Math-Expressions"));
        this.help.tooltip(IKey.lang("mclib.gui.graph.help"), Direction.TOP);

        String first = "sin(x)";

        this.expression.setText(first);
        this.canvas.parseExpression(first);

        this.expression.flex().relative(this).x(10).y(1F, -30).w(1F, -20).h(20);
        this.canvas.flex().relative(this).wh(1F, 1F);
        this.help.flex().relative(this.expression).x(1F, -19).y(1).wh(18, 18);

        this.expression.add(this.help);
        this.add(this.canvas, this.expression);
    }

    @Override
    public boolean isClientSideOnly()
    {
        return true;
    }

    public static class GuiGraphCanvas extends GuiCanvas
    {
        private MathBuilder builder;
        private Variable x;
        private boolean first = true;

        public IValue expression;

        public GuiGraphCanvas(Minecraft mc)
        {
            super(mc);

            this.builder = new MathBuilder();
            this.builder.register(this.x = new Variable("x", 0));

            this.scaleY.inverse = true;
        }

        public void parseExpression(String expression)
        {
            try
            {
                this.expression = this.builder.parse(expression);
            }
            catch (Exception e)
            {
                this.expression = null;
            }
        }

        @Override
        public void resize()
        {
            super.resize();

            if (this.first)
            {
                this.scaleX.view(-10, 10);
                this.scaleX.calculateMultiplier();
                this.scaleY.view(-10, 10);
                this.scaleY.calculateMultiplier();

                this.first = false;
            }
        }

        @Override
        protected void drawCanvas(GuiContext context)
        {
            this.area.draw(ColorUtils.HALF_BLACK);

            this.drawVerticalGrid(context);
            this.drawHorizontalGridAndGraph(context);
        }

        private void drawVerticalGrid(GuiContext context)
        {
            /* Draw vertical grid */
            int ty = (int) this.scaleY.from(this.area.ey());
            int by = (int) this.scaleY.from(this.area.y - 12);

            int min = Math.min(ty, by) - 1;
            int max = Math.max(ty, by) + 1;
            int mult = this.scaleY.getMult();

            min -= min % mult + mult;
            max -= max % mult - mult;

            for (int j = 0, c = (max - min) / mult; j < c; j++)
            {
                int y = (int) this.scaleY.to(min + j * mult);

                if (y >= this.area.ey())
                {
                    continue;
                }

                Gui.drawRect(this.area.x, y, this.area.ex(), y + 1, 0x44ffffff);
                this.font.drawString(String.valueOf(min + j * mult), this.area.x + 4, y + 4, 0xffffff);
            }
        }

        private void drawHorizontalGridAndGraph(GuiContext context)
        {
            /* Draw scaling grid */
            int tx = (int) this.scaleX.from(this.area.ex());
            int bx = (int) this.scaleX.from(this.area.x);

            int min = Math.min(tx, bx) - 1;
            int max = Math.max(tx, bx) + 1;
            int mult = this.scaleX.getMult();

            min -= min % mult + mult;
            max -= max % mult - mult;

            for (int j = 0, c = (max - min) / mult; j < c; j++)
            {
                int x = (int) this.scaleX.to(min + j * mult);

                if (x >= this.area.ex())
                {
                    break;
                }

                Gui.drawRect(x, this.area.y, x + 1, this.area.ey(), 0x44ffffff);
                this.font.drawString(String.valueOf(min + j * mult), x + 4, this.area.y + 4, 0xffffff);
            }

            if (this.expression == null)
            {
                return;
            }

            if (Mouse.isButtonDown(0) && !context.isFocused())
            {
                int mouseX = context.mouseX;
                double x = this.scaleX.from(mouseX);

                this.x.set(x);

                double y = this.expression.get().doubleValue();
                int y1 = context.mouseY;
                int y2 = (int) this.scaleY.to(y) + 1;
                boolean isNaN = Double.isNaN(y);

                if (y1 < y2)
                {
                    y1 -= 12;
                }

                String coordinate = "(" + GuiTrackpadElement.FORMAT.format(x) + ", " + (isNaN ? "undefined" : GuiTrackpadElement.FORMAT.format(y)) + ")";

                if (!isNaN)
                {
                    Gui.drawRect(mouseX, Math.min(y1, y2), mouseX + 1, Math.max(y1, y2), 0xff57f52a);
                }

                int y3 = y1 < y2 ? y1 : y1 - 12;
                int w = this.font.getStringWidth(coordinate);

                mouseX += 1;

                Gui.drawRect(mouseX, y3, mouseX + w + 4, y3 + 12, 0xffffffff);
                this.font.drawString(coordinate, mouseX + 2, y3 + 2, 0);
            }

            GlStateManager.glLineWidth(4);
            GlStateManager.disableTexture2D();
            BufferBuilder builder = Tessellator.getInstance().getBuffer();

            builder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

            int sub = 40;
            int gap = (max - min) * sub;

            for (int j = 1; j < gap; j++)
            {
                double previous = min + (j - 1) / (double) sub;
                double current = min + j / (double) sub;

                this.x.set(previous);
                double y1 = this.expression.get().doubleValue();

                this.x.set(current);
                double y2 = this.expression.get().doubleValue();

                double fx1 = this.scaleX.to(previous);
                double fy1 = this.scaleY.to(y1);
                double fx2 = this.scaleX.to(current);
                double fy2 = this.scaleY.to(y2);

                builder.pos(fx1, fy1, 0).color(0, 0.5F, 1F, 1F).endVertex();
                builder.pos(fx2, fy2, 0).color(0, 0.5F, 1F, 1F).endVertex();
            }

            Tessellator.getInstance().draw();
            GlStateManager.glLineWidth(1);
        }
    }
}


==================================================

--- Файл №85 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Area.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.resizers.IResizer;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.gui.Gui;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Utility class for boxes
 *
 * Used in GUI for rendering and locating cursor inside of the box purposes.
 */
public class Area implements IResizer
{
    /**
     * Shared area which could be used for calculations without creating new
     * instances
     */
    public static final Area SHARED = new Area();

    /**
     * X position coordinate of the box
     */
    public int x;

    /**
     * Y position coordinate of the box
     */
    public int y;

    /**
     * Width of the box
     */
    public int w;

    /**
     * Height of the box
     */
    public int h;

    public Area()
    {}

    public Area(int x, int y, int w, int h)
    {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    public int getIndex(int x, int y, int size)
    {
        return MathUtils.gridIndex(x - this.x, y - this.y, size, this.w);
    }

    public int getRows(int count, int size)
    {
        return MathUtils.gridRows(count, size, this.w);
    }

    @SideOnly(Side.CLIENT)
    public boolean isInside(GuiContext context)
    {
        return this.isInside(context.mouseX, context.mouseY);
    }

    /**
     * Check whether given position is inside of the rect
     */
    public boolean isInside(int x, int y)
    {
        return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
    }

    /**
     * Check whether given rect intersects this rect
     */
    public boolean intersects(Area area)
    {
        return this.x < area.x + area.w && this.y < area.y + area.h
            && area.x < this.x + this.w && area.y < this.y + this.h;
    }

    /**
     * Clamp given area inside of this one
     */
    public void clamp(Area area)
    {
        int x1 = area.x;
        int y1 = area.y;
        int x2 = area.ex();
        int y2 = area.ey();

        x1 = MathUtils.clamp(x1, this.x, this.ex());
        y1 = MathUtils.clamp(y1, this.y, this.ey());
        x2 = MathUtils.clamp(x2, this.x, this.ex());
        y2 = MathUtils.clamp(y2, this.y, this.ey());

        area.setPoints(x1, y1, x2, y2);
    }

    /**
     * Expand the area either inwards or outwards
     */
    public void offset(int offset)
    {
        this.offsetX(offset);
        this.offsetY(offset);
    }

    /**
     * Expand the area either inwards or outwards (horizontally)
     */
    public void offsetX(int offset)
    {
        this.x -= offset;
        this.w += offset * 2;
    }

    /**
     * Expand the area either inwards or outwards (horizontally)
     */
    public void offsetY(int offset)
    {
        this.y -= offset;
        this.h += offset * 2;
    }

    /**
     * Set all values
     */
    public void set(int x, int y, int w, int h)
    {
        this.setPos(x, y);
        this.setSize(w, h);
    }

    /**
     * Set the position
     */
    public void setPos(int x, int y)
    {
        this.x = x;
        this.y = y;
    }

    /**
     * Set the size
     */
    public void setSize(int w, int h)
    {
        this.w = w;
        this.h = h;
    }

    public void setPoints(int x1, int y1, int x2, int y2)
    {
        this.setPoints(x1, y1, x2, y2, 0);
    }

    public void setPoints(int x1, int y1, int x2, int y2, int offset)
    {
        int mx = Math.max(x1, x2);
        int my = Math.max(y1, y2);
        int nx = Math.min(x1, x2);
        int ny = Math.min(y1, y2);

        this.x = nx - offset;
        this.y = ny - offset;
        this.w = mx - nx + offset;
        this.h = my - ny + offset;
    }

    /**
     * Copy properties from other area 
     */
    public void copy(Area area)
    {
        this.x = area.x;
        this.y = area.y;
        this.w = area.w;
        this.h = area.h;
    }

    /**
     * Calculate X based on anchor value
     */
    public int x(float anchor)
    {
        return this.x + (int) (this.w * anchor);
    }

    /**
     * Calculate X based on anchor value with additional value
     */
    public int x(float anchor, int value)
    {
        return this.x + (int) ((this.w - value) * anchor);
    }

    /**
     * Calculate mid point X value
     */
    public int mx()
    {
        return this.x + (int) (this.w * 0.5F);
    }

    /**
     * Calculate mid point X value
     */
    public int mx(int value)
    {
        return this.x + (int) ((this.w - value) * 0.5F);
    }

    /**
     * Calculate end point X (right) value
     */
    public int ex()
    {
        return this.x + this.w;
    }

    /**
     * Calculate Y based on anchor value
     */
    public int y(float anchor)
    {
        return this.y + (int) (this.h * anchor);
    }

    /**
     * Calculate Y based on anchor value
     */
    public int y(float anchor, int value)
    {
        return this.y + (int) ((this.h - value) * anchor);
    }

    /**
     * Calculate mid point Y value
     */
    public int my()
    {
        return this.y + (int) (this.h * 0.5F);
    }

    /**
     * Calculate mid point Y value
     */
    public int my(int value)
    {
        return this.y + (int) ((this.h - value) * 0.5F);
    }

    /**
     * Calculate end point Y (bottom) value
     */
    public int ey()
    {
        return this.y + this.h;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Area)
        {
            Area area = (Area) obj;

            return this.x == area.x && this.y == area.y && this.w == area.w && this.h == area.h;
        }

        return super.equals(obj);
    }

    /**
     * Draw a rect within the bound of this rect
     */
    @SideOnly(Side.CLIENT)
    public void draw(int color)
    {
        this.draw(color, 0, 0, 0, 0);
    }

    /**
     * Draw a rect within the bound of this rect
     */
    @SideOnly(Side.CLIENT)
    public void draw(int color, int offset)
    {
        this.draw(color, offset, offset, offset, offset);
    }

    /**
     * Draw a rect within the bound of this rect
     */
    @SideOnly(Side.CLIENT)
    public void draw(int color, int horizontal, int vertical)
    {
        this.draw(color, horizontal, vertical, horizontal, vertical);
    }

    /**
     * Draw a rect within the bound of this rect
     */
    @SideOnly(Side.CLIENT)
    public void draw(int color, int lx, int ty, int rx, int by)
    {
        Gui.drawRect(this.x + lx, this.y + ty, this.ex() - rx, this.ey() - by, color);
    }

    /* IResizer implementation */

    @Override
    public void preApply(Area area)
    {}

    @Override
    public void apply(Area area)
    {
        area.copy(this);
    }

    @Override
    public void postApply(Area area)
    {}

    @Override
    @SideOnly(Side.CLIENT)
    public void add(GuiElement parent, GuiElement child)
    {}

    @Override
    @SideOnly(Side.CLIENT)
    public void remove(GuiElement parent, GuiElement child)
    {}

    @Override
    public int getX()
    {
        return this.x;
    }

    @Override
    public int getY()
    {
        return this.y;
    }

    @Override
    public int getW()
    {
        return this.w;
    }

    @Override
    public int getH()
    {
        return this.h;
    }
}

==================================================

--- Файл №86 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Elements.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.keys.IKey;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@SideOnly(Side.CLIENT)
public class Elements
{
    public static GuiElement row(Minecraft mc, int margin, GuiElement... elements)
    {
        return row(mc, margin, 0, elements);
    }

    public static GuiElement row(Minecraft mc, int margin, int padding, GuiElement... elements)
    {
        return row(mc, margin, padding, 0, elements);
    }

    public static GuiElement row(Minecraft mc, int margin, int padding, int height, GuiElement... elements)
    {
        GuiElement element = new GuiElement(mc);

        element.flex().row(margin).padding(padding).height(height);
        element.add(elements);

        return element;
    }

    public static GuiElement column(Minecraft mc, int margin, GuiElement... elements)
    {
        return column(mc, margin, 0, elements);
    }

    public static GuiElement column(Minecraft mc, int margin, int padding, GuiElement... elements)
    {
        return column(mc, margin, padding, 0, elements);
    }

    public static GuiElement column(Minecraft mc, int margin, int padding, int height, GuiElement... elements)
    {
        GuiElement element = new GuiElement(mc);

        element.flex().column(margin).vertical().stretch().padding(padding).height(height);
        element.add(elements);

        return element;
    }

    public static GuiLabel label(IKey label)
    {
        return label(label, Minecraft.getMinecraft().fontRenderer.FONT_HEIGHT);
    }

    public static GuiLabel label(IKey label, Icon leftIcon, Icon rightIcon)
    {
        return label(label, Minecraft.getMinecraft().fontRenderer.FONT_HEIGHT, leftIcon, rightIcon);
    }

    public static GuiLabel label(IKey label, int height)
    {
        return label(label, height, 0xffffff);
    }

    public static GuiLabel label(IKey label, int height, Icon leftIcon, Icon rightIcon)
    {
        return label(label, height, 0xffffff, leftIcon, rightIcon);
    }

    public static GuiLabel label(IKey label, int height, int color)
    {
        return label(label, height, color, null, null);
    }

    public static GuiLabel label(IKey label, int height, int color, Icon leftIcon, Icon rightIcon)
    {
        GuiLabel element = new GuiLabel(Minecraft.getMinecraft(), label, color, leftIcon, rightIcon);

        element.flex().h(height);

        return element;
    }
}

==================================================

--- Файл №87 ---
Путь: main\java\mchorse\mclib\client\gui\utils\GuiUtils.java
--------------------
package mchorse.mclib.client.gui.utils;

import net.minecraft.client.Minecraft;
import net.minecraft.client.audio.PositionedSoundRecord;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.OpenGlHelper;
import net.minecraft.client.renderer.RenderHelper;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.boss.EntityDragon;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.SoundEvents;
import net.minecraft.util.Util;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.File;
import java.io.IOException;
import java.net.URI;

import org.lwjgl.Sys;

/**
 * GUI utilities
 */
@SideOnly(Side.CLIENT)
public class GuiUtils
{
    public static void drawModel(ModelBase model, EntityPlayer player, int x, int y, float scale)
    {
        drawModel(model, player, x, y, scale, 1.0F);
    }

    /**
     * Draw a {@link ModelBase} without using the {@link RenderManager} (which 
     * adds a lot of useless transformations and stuff to the screen rendering).
     */
    public static void drawModel(ModelBase model, EntityPlayer player, int x, int y, float scale, float alpha)
    {
        float factor = 0.0625F;

        GlStateManager.enableColorMaterial();
        GlStateManager.pushMatrix();
        GlStateManager.translate(x, y, 50.0F);
        GlStateManager.scale((-scale), scale, scale);
        GlStateManager.rotate(45.0F, -1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(45.0F, 0.0F, -1.0F, 0.0F);
        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);
        GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);

        RenderHelper.enableStandardItemLighting();

        GlStateManager.pushMatrix();
        GlStateManager.disableCull();

        GlStateManager.enableRescaleNormal();
        GlStateManager.scale(-1.0F, -1.0F, 1.0F);
        GlStateManager.translate(0.0F, -1.501F, 0.0F);

        GlStateManager.enableAlpha();

        model.setLivingAnimations(player, 0, 0, 0);
        model.setRotationAngles(0, 0, player.ticksExisted, 0, 0, factor, player);

        GlStateManager.enableDepth();
        GlStateManager.color(1.0F, 1.0F, 1.0F, alpha);

        model.render(player, 0, 0, 0, 0, 0, factor);

        GlStateManager.disableDepth();

        GlStateManager.disableRescaleNormal();
        GlStateManager.disableAlpha();
        GlStateManager.popMatrix();

        GlStateManager.popMatrix();

        RenderHelper.disableStandardItemLighting();

        GlStateManager.disableRescaleNormal();
        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
    }

    /**
     * Draw an entity on the screen.
     *
     * Taken <s>stolen</s> from minecraft's class GuiInventory. I wonder what's
     * the license of minecraft's decompiled code?
     * @param alpha 
     */
    public static void drawEntityOnScreen(int posX, int posY, float scale, EntityLivingBase ent, float alpha)
    {
        GlStateManager.enableDepth();
        GlStateManager.disableBlend();
        GlStateManager.enableColorMaterial();
        GlStateManager.pushMatrix();
        GlStateManager.translate(posX, posY, 100.0F);
        GlStateManager.scale((-scale), scale, scale);
        GlStateManager.rotate(45.0F, -1.0F, 0.0F, 0.0F);
        GlStateManager.rotate(45.0F, 0.0F, -1.0F, 0.0F);
        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);

        boolean render = ent.getAlwaysRenderNameTag();

        if (ent instanceof EntityDragon)
        {
            GlStateManager.rotate(180.0F, 0.0F, 1.0F, 0.0F);
        }

        RenderHelper.enableStandardItemLighting();

        GlStateManager.enableRescaleNormal();
        GlStateManager.color(1.0F, 1.0F, 1.0F, alpha);

        float f = ent.renderYawOffset;
        float f1 = ent.rotationYaw;
        float f2 = ent.rotationPitch;
        float f3 = ent.prevRotationYawHead;
        float f4 = ent.rotationYawHead;

        ent.renderYawOffset = 0;
        ent.rotationYaw = 0;
        ent.rotationPitch = 0;
        ent.rotationYawHead = ent.rotationYaw;
        ent.prevRotationYawHead = ent.rotationYaw;
        ent.setAlwaysRenderNameTag(false);

        GlStateManager.translate(0.0F, 0.0F, 0.0F);

        RenderManager rendermanager = Minecraft.getMinecraft().getRenderManager();
        rendermanager.setPlayerViewY(180.0F);
        rendermanager.setRenderShadow(false);
        rendermanager.renderEntity(ent, 0.0D, 0.0D, 0.0D, 0.0F, 1.0F, false);
        rendermanager.setRenderShadow(true);

        ent.renderYawOffset = f;
        ent.rotationYaw = f1;
        ent.rotationPitch = f2;
        ent.prevRotationYawHead = f3;
        ent.rotationYawHead = f4;

        ent.setAlwaysRenderNameTag(render);

        GlStateManager.popMatrix();

        RenderHelper.disableStandardItemLighting();

        GlStateManager.disableRescaleNormal();

        GlStateManager.disableBlend();
        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
        GlStateManager.disableDepth();
    }

    /**
     * Draw an entity on the screen.
     *
     * Taken <s>stolen</s> from minecraft's class GuiInventory. I wonder what's
     * the license of minecraft's decompiled code?
     */
    public static void drawEntityOnScreen(int posX, int posY, int scale, int mouseX, int mouseY, EntityLivingBase ent)
    {
        GlStateManager.enableColorMaterial();
        GlStateManager.pushMatrix();
        GlStateManager.translate(posX, posY, 100.0F);
        GlStateManager.scale((-scale), scale, scale);
        GlStateManager.rotate(180.0F, 0.0F, 0.0F, 1.0F);

        float f = ent.renderYawOffset;
        float f1 = ent.rotationYaw;
        float f2 = ent.rotationPitch;
        float f3 = ent.prevRotationYawHead;
        float f4 = ent.rotationYawHead;

        ent.renderYawOffset = (float) Math.atan(mouseX / 40.0F) * 20.0F;
        ent.rotationYaw = (float) Math.atan(mouseX / 40.0F) * 40.0F;
        ent.rotationPitch = -((float) Math.atan(mouseY / 40.0F)) * 20.0F;
        ent.rotationYawHead = ent.rotationYaw;
        ent.prevRotationYawHead = ent.rotationYaw;

        GlStateManager.translate(0.0F, 0.0F, 0.0F);

        RenderManager rendermanager = Minecraft.getMinecraft().getRenderManager();
        rendermanager.setPlayerViewY(180.0F);
        rendermanager.setRenderShadow(false);
        rendermanager.renderEntity(ent, 0.0D, 0.0D, 0.0D, 0.0F, 1.0F, false);
        rendermanager.setRenderShadow(true);

        ent.renderYawOffset = f;
        ent.rotationYaw = f1;
        ent.rotationPitch = f2;
        ent.prevRotationYawHead = f3;
        ent.rotationYawHead = f4;

        GlStateManager.popMatrix();
        RenderHelper.disableStandardItemLighting();
        GlStateManager.disableRescaleNormal();
        GlStateManager.setActiveTexture(OpenGlHelper.lightmapTexUnit);
        GlStateManager.disableTexture2D();
        GlStateManager.setActiveTexture(OpenGlHelper.defaultTexUnit);
    }


    /**
     * Open web link
     */
    public static void openWebLink(String address)
    {
        try
        {
            openWebLink(new URI(address));
        }
        catch (Exception e)
        {}
    }

    /**
     * Open a URL
     */
    public static void openWebLink(URI uri)
    {
        try
        {
            Class<?> clazz = Class.forName("java.awt.Desktop");
            Object object = clazz.getMethod("getDesktop", new Class[0]).invoke(null);

            clazz.getMethod("browse", new Class[] {URI.class}).invoke(object, new Object[] {uri});
        }
        catch (Throwable t)
        {}
    }

    public static void playClick()
    {
        Minecraft.getMinecraft().getSoundHandler().playSound(PositionedSoundRecord.getMasterRecord(SoundEvents.UI_BUTTON_CLICK, 1.0F));
    }

    /**
     * Open a Folder<br>
     * Referenced from {@link net.minecraft.client.renderer.OpenGlHelper.openFile(File)}
     */
    public static void openFolder(String url)
    {
        File file = new File(url);

        switch (Util.getOSType())
        {
            case WINDOWS:
                try
                {
                    Runtime.getRuntime().exec(new String[]
                    {
                        "cmd.exe", "/C", "start", "\"Open file\"", file.getAbsolutePath()
                    });

                    return;
                }
                catch (IOException ioexception)
                {
                    ioexception.printStackTrace();

                    break;
                }

            case OSX:
                try
                {
                    Runtime.getRuntime().exec(new String[]
                    {
                            "/usr/bin/open", file.getAbsolutePath()
                    });

                    return;
                }
                catch (IOException ioexception1)
                {
                    ioexception1.printStackTrace();
                }

            default:
                break;
        }

        boolean failed = false;

        try
        {
            Class<?> clazz = Class.forName("java.awt.Desktop");
            Object object = clazz.getMethod("getDesktop", new Class[0]).invoke(null);

            clazz.getMethod("browse", new Class[] {URI.class}).invoke(object, new Object[] {file.toURI()});
        }
        catch (Throwable throwable1)
        {
            throwable1.printStackTrace();
            failed = true;
        }

        if (failed)
        {
            Sys.openURL("file://" + file.getAbsolutePath());
        }
    }
}

==================================================

--- Файл №88 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Icon.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class Icon
{
    public final ResourceLocation location;
    public final int x;
    public final int y;
    public final int w;
    public final int h;
    public int textureW = 256;
    public int textureH = 256;

    public Icon(ResourceLocation location, int x, int y)
    {
        this(location, x, y, 16, 16);
    }

    public Icon(ResourceLocation location, int x, int y, int w, int h)
    {
        this.location = location;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }

    public Icon(ResourceLocation location, int x, int y, int w, int h, int textureW, int textureH)
    {
        this(location, x, y, w, h);
        this.textureW = textureW;
        this.textureH = textureH;
    }

    @SideOnly(Side.CLIENT)
    public void render(int x, int y)
    {
        this.render(x, y, 0, 0);
    }

    @SideOnly(Side.CLIENT)
    public void render(int x, int y, float ax, float ay)
    {
        if (this.location == null)
        {
            return;
        }

        x -= ax * this.w;
        y -= ay * this.h;

        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();
        Minecraft.getMinecraft().renderEngine.bindTexture(this.location);
        GuiDraw.drawBillboard(x, y, this.x, this.y, this.w, this.h, this.textureW, this.textureH);
        GlStateManager.disableBlend();
        GlStateManager.disableAlpha();
    }

    @SideOnly(Side.CLIENT)
    public void renderArea(int x, int y, int w, int h)
    {
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();
        Minecraft.getMinecraft().renderEngine.bindTexture(this.location);
        GuiDraw.drawRepeatBillboard(x, y, w, h, this.x, this.y, this.w, this.h, this.textureW, this.textureH);
        GlStateManager.disableBlend();
        GlStateManager.disableAlpha();
    }
}

==================================================

--- Файл №89 ---
Путь: main\java\mchorse\mclib\client\gui\utils\IconRegistry.java
--------------------
package mchorse.mclib.client.gui.utils;

import java.util.HashMap;
import java.util.Map;

/**
 * This class connects Icons with Strings.
 * It is used in Mappet's UI API
 */
public class IconRegistry
{
    public static final Map<String, Icon> icons = new HashMap<String, Icon>();

    public static Icon register(String key, Icon icon)
    {
        if (icons.containsKey(key))
        {
            try
            {
                throw new IllegalStateException("[Icons] Icon " + key + " was already registered prior...");
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
        else
        {
            icons.put(key, icon);
        }

        return icon;
    }
}

==================================================

--- Файл №90 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Icons.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.McLib;
import net.minecraft.util.ResourceLocation;

public class Icons
{
    /**
     * Icons texture used across all dashboard panels
     */
    public static final ResourceLocation ICONS = new ResourceLocation(McLib.MOD_ID, "textures/gui/icons.png");

    public static final Icon NONE = new Icon(null, 0, 0);

    public static final Icon GEAR = new Icon(ICONS, 0, 0);
    public static final Icon MORE = new Icon(ICONS, 16, 0);
    public static final Icon SAVED = new Icon(ICONS, 32, 0);
    public static final Icon SAVE = new Icon(ICONS, 48, 0);
    public static final Icon ADD = new Icon(ICONS, 64, 0);
    public static final Icon DUPE = new Icon(ICONS, 80, 0);
    public static final Icon REMOVE = new Icon(ICONS, 96, 0);
    public static final Icon POSE = new Icon(ICONS, 112, 0);
    public static final Icon FILTER = new Icon(ICONS, 128, 0);
    public static final Icon MOVE_UP = new Icon(ICONS, 144, 0, 16, 8);
    public static final Icon MOVE_DOWN = new Icon(ICONS, 144, 8, 16, 8);
    public static final Icon LOCKED = new Icon(ICONS, 160, 0);
    public static final Icon UNLOCKED = new Icon(ICONS, 176, 0);
    public static final Icon COPY = new Icon(ICONS, 192, 0);
    public static final Icon PASTE = new Icon(ICONS, 208, 0);
    public static final Icon CUT = new Icon(ICONS, 224, 0);
    public static final Icon REFRESH = new Icon(ICONS, 240, 0);

    public static final Icon DOWNLOAD = new Icon(ICONS, 0, 16);
    public static final Icon UPLOAD = new Icon(ICONS, 16, 16);
    public static final Icon SERVER = new Icon(ICONS, 32, 16);
    public static final Icon FOLDER = new Icon(ICONS, 48, 16);
    public static final Icon IMAGE = new Icon(ICONS, 64, 16);
    public static final Icon EDIT = new Icon(ICONS, 80, 16);
    public static final Icon MATERIAL = new Icon(ICONS, 96, 16);
    public static final Icon CLOSE = new Icon(ICONS, 112, 16);
    public static final Icon LIMB = new Icon(ICONS, 128, 16);
    public static final Icon CODE = new Icon(ICONS, 144, 16);
    public static final Icon MOVE_LEFT = new Icon(ICONS, 144, 16, 8, 16);
    public static final Icon MOVE_RIGHT = new Icon(ICONS, 152, 16, 8, 16);
    public static final Icon HELP = new Icon(ICONS, 160, 16);
    public static final Icon LEFT_HANDLE = new Icon(ICONS, 176, 16);
    public static final Icon MAIN_HANDLE = new Icon(ICONS, 192, 16);
    public static final Icon RIGHT_HANDLE = new Icon(ICONS, 208, 16);
    public static final Icon REVERSE = new Icon(ICONS, 224, 16);
    public static final Icon BLOCK = new Icon(ICONS, 240, 16);

    public static final Icon FAVORITE = new Icon(ICONS, 0, 32);
    public static final Icon VISIBLE = new Icon(ICONS, 16, 32);
    public static final Icon INVISIBLE = new Icon(ICONS, 32, 32);
    public static final Icon PLAY = new Icon(ICONS, 48, 32);
    public static final Icon PAUSE = new Icon(ICONS, 64, 32);
    public static final Icon MAXIMIZE = new Icon(ICONS, 80, 32);
    public static final Icon MINIMIZE = new Icon(ICONS, 96, 32);
    public static final Icon STOP = new Icon(ICONS, 112, 32);
    public static final Icon FULLSCREEN = new Icon(ICONS, 128, 32);
    public static final Icon ALL_DIRECTIONS = new Icon(ICONS, 144, 32);
    public static final Icon SPHERE = new Icon(ICONS, 160, 32);
    public static final Icon SHIFT_TO = new Icon(ICONS, 176, 32);
    public static final Icon SHIFT_FORWARD = new Icon(ICONS, 192, 32);
    public static final Icon SHIFT_BACKWARD = new Icon(ICONS, 208, 32);
    public static final Icon MOVE_TO = new Icon(ICONS, 224, 32);
    public static final Icon GRAPH = new Icon(ICONS, 240, 32);

    public static final Icon WRENCH = new Icon(ICONS, 0, 48);
    public static final Icon EXCLAMATION = new Icon(ICONS, 16, 48);
    public static final Icon LEFTLOAD = new Icon(ICONS, 32, 48);
    public static final Icon RIGHTLOAD = new Icon(ICONS, 48, 48);
    public static final Icon BUBBLE = new Icon(ICONS, 64, 48);
    public static final Icon FILE = new Icon(ICONS, 80, 48);
    public static final Icon PROCESSOR = new Icon(ICONS, 96, 48);
    public static final Icon MAZE = new Icon(ICONS, 112, 48);
    public static final Icon BOOKMARK = new Icon(ICONS, 128, 48);
    public static final Icon SOUND = new Icon(ICONS, 144, 48);
    public static final Icon SEARCH = new Icon(ICONS, 160, 48);

    public static final Icon CHECKBOARD = new Icon(ICONS, 0, 240);
    public static final Icon DISABLED = new Icon(ICONS, 16, 240);
    public static final Icon CURSOR = new Icon(ICONS, 32, 240);

    public static void register()
    {
        IconRegistry.register("gear", GEAR);
        IconRegistry.register("more", MORE);
        IconRegistry.register("saved", SAVED);
        IconRegistry.register("save", SAVE);
        IconRegistry.register("add", ADD);
        IconRegistry.register("dupe", DUPE);
        IconRegistry.register("remove", REMOVE);
        IconRegistry.register("pose", POSE);
        IconRegistry.register("filter", FILTER);
        IconRegistry.register("move_up", MOVE_UP);
        IconRegistry.register("move_down", MOVE_DOWN);
        IconRegistry.register("locked", LOCKED);
        IconRegistry.register("unlocked", UNLOCKED);
        IconRegistry.register("copy", COPY);
        IconRegistry.register("paste", PASTE);
        IconRegistry.register("cut", CUT);
        IconRegistry.register("refresh", REFRESH);
        
        IconRegistry.register("download", DOWNLOAD);
        IconRegistry.register("upload", UPLOAD);
        IconRegistry.register("server", SERVER);
        IconRegistry.register("folder", FOLDER);
        IconRegistry.register("image", IMAGE);
        IconRegistry.register("edit", EDIT);
        IconRegistry.register("material", MATERIAL);
        IconRegistry.register("close", CLOSE);
        IconRegistry.register("limb", LIMB);
        IconRegistry.register("code", CODE);
        IconRegistry.register("move_left", MOVE_LEFT);
        IconRegistry.register("move_right", MOVE_RIGHT);
        IconRegistry.register("help", HELP);
        IconRegistry.register("left_handle", LEFT_HANDLE);
        IconRegistry.register("main_handle", MAIN_HANDLE);
        IconRegistry.register("right_handle", RIGHT_HANDLE);
        IconRegistry.register("reverse", REVERSE);
        IconRegistry.register("block", BLOCK);
        IconRegistry.register("favorite", FAVORITE);
        IconRegistry.register("visible", VISIBLE);
        IconRegistry.register("invisible", INVISIBLE);
        IconRegistry.register("play", PLAY);
        IconRegistry.register("pause", PAUSE);
        IconRegistry.register("maximize", MAXIMIZE);
        IconRegistry.register("minimize", MINIMIZE);
        IconRegistry.register("stop", STOP);
        IconRegistry.register("fullscreen", FULLSCREEN);
        IconRegistry.register("all_directions", ALL_DIRECTIONS);
        IconRegistry.register("sphere", SPHERE);
        IconRegistry.register("shift_to", SHIFT_TO);
        IconRegistry.register("shift_forward", SHIFT_FORWARD);
        IconRegistry.register("shift_backward", SHIFT_BACKWARD);
        IconRegistry.register("move_to", MOVE_TO);
        IconRegistry.register("graph", GRAPH);
        IconRegistry.register("wrench", WRENCH);
        IconRegistry.register("exclamation", EXCLAMATION);
        IconRegistry.register("leftload", LEFTLOAD);
        IconRegistry.register("rightload", RIGHTLOAD);
        IconRegistry.register("bubble", BUBBLE);
        IconRegistry.register("file", FILE);
        IconRegistry.register("processor", PROCESSOR);
        IconRegistry.register("maze", MAZE);
        IconRegistry.register("bookmark", BOOKMARK);
        IconRegistry.register("sound", SOUND);
        IconRegistry.register("search", SEARCH);
        IconRegistry.register("checkboard", CHECKBOARD);
        IconRegistry.register("disabled", DISABLED);
        IconRegistry.register("cursor", CURSOR);
    }
}

==================================================

--- Файл №91 ---
Путь: main\java\mchorse\mclib\client\gui\utils\InterpolationRenderer.java
--------------------
package mchorse.mclib.client.gui.utils;

import com.google.common.collect.ImmutableList;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.client.gui.framework.tooltips.styles.TooltipStyle;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.IInterpolation;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.gui.Gui;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.client.renderer.vertex.DefaultVertexFormats;
import org.lwjgl.opengl.GL11;

import java.util.List;

public class InterpolationRenderer
{
    public static void drawInterpolationPreview(IInterpolation interp, GuiContext context, int x, int y, float anchorX, float anchorY, int duration)
    {
        if (interp == null)
        {
            return;
        }

        final float iterations = 40;
        final float padding = 50;

        int w = 140;
        int h = 130;

        TooltipStyle style = TooltipStyle.get();
        String tooltip = interp.getTooltip();
        List<String> lines = tooltip.isEmpty() ? ImmutableList.of() : context.font.listFormattedStringToWidth(tooltip, w - 20);
        int ah = lines.isEmpty() ? 0 : lines.size() * (context.font.FONT_HEIGHT + 4);

        y = MathUtils.clamp(y, 0, context.screen.height - h - ah);

        x -= (int) (w * anchorX);
        y -= (int) (h * anchorY);

        Area.SHARED.set(x, y, w, h + ah);
        style.drawBackground(Area.SHARED);

        Color fg = ColorUtils.COLOR.set(style.getForegroundColor(), false);
        int font = style.getTextColor();

        context.font.drawString(interp.getName(), x + 10, y + 10, font);

        for (int i = 0; i < lines.size(); i++)
        {
            context.font.drawString(lines.get(i), x + 10, y + h - 5 + i * (context.font.FONT_HEIGHT + 4), font);
        }

        BufferBuilder builder = Tessellator.getInstance().getBuffer();

        GlStateManager.color(1F, 1F, 1F, 1F);
        GlStateManager.disableTexture2D();
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();
        GlStateManager.glLineWidth(2F);

        builder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

        builder.pos(x + 10, y + 20, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + 10, y + h - 10, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w / 2, y + 20, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w / 2, y + h - 10, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w - 10, y + 20, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w - 10, y + h - 10, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();

        builder.pos(x + 10, y + 20, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w - 10, y + 20, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + 10, y + 20 + (h - 30) / 2, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w - 10, y + 20 + (h - 30) / 2, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + 10, y + h - 10, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();
        builder.pos(x + w - 10, y + h - 10, 0).color(fg.r, fg.g, fg.b, 0.2F).endVertex();

        builder.pos(x + 10, y + h - 10 - padding / 2, 0).color(fg.r, fg.g, fg.b, 0.11F).endVertex();
        builder.pos(x + w - 10, y + h - 10 - padding / 2, 0).color(fg.r, fg.g, fg.b, 0.11F).endVertex();
        builder.pos(x + 10, y + 20 + padding / 2, 0).color(fg.r, fg.g, fg.b, 0.11F).endVertex();
        builder.pos(x + w - 10, y + 20 + padding / 2, 0).color(fg.r, fg.g, fg.b, 0.11F).endVertex();

        Tessellator.getInstance().draw();

        GlStateManager.glLineWidth(3F);
        builder.begin(GL11.GL_LINES, DefaultVertexFormats.POSITION_COLOR);

        for (int i = 1; i <= iterations; i++)
        {
            float factor0 = (i - 1) / iterations;
            float value0 = 1 - interp.interpolate(0, 1, factor0);
            float factor1 = i / iterations;
            float value1 = 1 - interp.interpolate(0, 1, factor1);

            float x1 = x + 10 + factor1 * (w - 20);
            float x2 = x + 10 + factor0 * (w - 20);
            float y1 = y + 20 + padding / 2 + value1 * (h - 30 - padding);
            float y2 = y + 20 + padding / 2 + value0 * (h - 30 - padding);

            builder.pos(x1, y1, 0).color(fg.r, fg.g, fg.b, 1F).endVertex();
            builder.pos(x2, y2, 0).color(fg.r, fg.g, fg.b, 1F).endVertex();
        }

        Tessellator.getInstance().draw();

        GlStateManager.enableTexture2D();

        context.font.drawString("A", x + 14, (int)(y + h - 10 - padding / 2) + 4, font);
        context.font.drawString("B", x + w - 19, (int)(y + 20 + padding / 2) - context.font.FONT_HEIGHT - 4, font);

        float tick = ((context.tick + context.partialTicks) % (duration + 20)) / (float) duration;
        float factor = MathUtils.clamp(tick, 0, 1);
        int px = x + w - 5;
        int py = y + 20 + (int) (padding / 2) + (int) ((1 - interp.interpolate(0, 1, factor)) * (h - 30 - padding));

        Gui.drawRect(px - 2, py - 2, px + 2, py + 2, 0xff000000 + fg.getRGBColor());
    }
}

==================================================

--- Файл №92 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Keybind.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.ClientProxy;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.client.gui.utils.keys.KeyParser;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.utils.Keys;

import java.util.function.Supplier;

/**
 * Keybind class
 */
public class Keybind
{
    public String modid;
    public IKey label;
    public IKey category = IKey.EMPTY;
    public int keyCode;
    public Runnable callback;
    public boolean inside;
    public boolean active = true;
    public Supplier<Boolean> activeSupplier;

    public String labelToken = "";
    public String categoryToken = "";

    public Keybind(String modid, IKey label, int keyCode, Runnable callback)
    {
        this.modid = modid;
        this.label = label;
        this.keyCode = keyCode;
        this.callback = callback;

        this.labelToken = KeyParser.toJson(label);

        ClientProxy.keybinds.addKeybind(this);
    }

    public Keybind held(int... keys)
    {
        this.keyCode = Keys.getComboKeyCode(keys, keyCode);

        ClientProxy.keybinds.addKeybind(this);

        return this;
    }

    public Keybind inside()
    {
        this.inside = true;

        return this;
    }

    public Keybind active(Supplier<Boolean> active)
    {
        this.activeSupplier = active;

        return this;
    }

    public Keybind active(boolean active)
    {
        this.active = active;

        return this;
    }

    public Keybind category(IKey category)
    {
        ClientProxy.keybinds.updateCategory(this, category);

        return this;
    }

    public void setCategory(IKey category)
    {
        this.category = category;
        this.categoryToken = KeyParser.toJson(category);
    }

    public String getKeyCombo()
    {
        ValueInt config = ClientProxy.keybinds.getKeybind(this.modid, this.categoryToken, this.labelToken);

        if (config != null)
        {
            return Keys.getComboKeyName(config.get());
        }
        else
        {
            return Keys.getComboKeyName(this.keyCode);
        }
    }

    public boolean check(int keyCode, boolean inside)
    {
        ValueInt config = ClientProxy.keybinds.getKeybind(this.modid, this.categoryToken, this.labelToken);
        int check = config == null ? this.keyCode : config.get();

        if (Keys.getMainKey(check) != keyCode || !Keys.checkModifierKeys(check))
        {
            return false;
        }

        if (this.inside)
        {
            return inside;
        }

        return true;
    }

    public boolean isActive()
    {
        if (this.activeSupplier != null)
        {
            return this.activeSupplier.get();
        }

        return this.active;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Keybind)
        {
            Keybind keybind = (Keybind) obj;

            return this.keyCode == keybind.keyCode && this.inside == keybind.inside;
        }

        return super.equals(obj);
    }
}

==================================================

--- Файл №93 ---
Путь: main\java\mchorse\mclib\client\gui\utils\KeybindConfig.java
--------------------
package mchorse.mclib.client.gui.utils;

import java.io.File;
import java.util.Map;

import org.lwjgl.input.Keyboard;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.json.ConfigParser;
import mchorse.mclib.config.values.Value;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.utils.Keys;
import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.common.ModContainer;

public class KeybindConfig extends Config
{
    public transient Map<String, IKey> keyMap;

    public KeybindConfig()
    {
        super("keybinds", new File(McLib.proxy.configFolder, "mclib/keybinds.json"));

        this.load();
    }

    public void addKeybind(Keybind key)
    {
        if (Keys.getMainKey(key.keyCode) == Keyboard.KEY_ESCAPE)
        {
            return;
        }

        String modid = key.modid;
        ModKeybinds mod = (ModKeybinds) this.values.get(modid);
        
        mod.addKeybind(key);
    }

    public void updateCategory(Keybind key, IKey categoryKey)
    {
        if (key.category != IKey.EMPTY)
        {
            return;
        }

        Value category = this.values.get(key.modid).getSubValue("");

        category.removeSubValue(key.labelToken);
        key.setCategory(categoryKey);
        this.addKeybind(key);
    }

    public ValueInt getKeybind(String modid, String categoryId, String id)
    {
        Value category = this.get(modid, categoryId);

        if (category != null)
        {
            return (ValueInt) category.getSubValue(id);
        }
        else
        {
            return null;
        }
    }

    public void load()
    {
        for (ModContainer container : Loader.instance().getActiveModList())
        {
            Value mod = new ModKeybinds(container);

            mod.setConfig(this);

            this.values.put(mod.id, mod);
        }
        ModKeybinds modKeybinds = new ModKeybinds(null);

        modKeybinds.setConfig(this);

        this.values.put("", modKeybinds);

        ConfigParser.fromJson(this, this.file);
    }

    @Override
    public String getCategoryTitleKey(Value value)
    {
        return value.getLabelKey();
    }

    @Override
    public String getCategoryTooltipKey(Value value)
    {
        return "";
    }

    @Override
    public String getValueLabelKey(Value value)
    {
        return "";
    }

    @Override
    public String getValueCommentKey(Value value)
    {
        return "";
    }
}


==================================================

--- Файл №94 ---
Путь: main\java\mchorse\mclib\client\gui\utils\KeybindManager.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.client.gui.framework.elements.input.GuiKeybinds;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.utils.ModHelper;
import net.minecraftforge.fml.common.ModContainer;

import java.util.ArrayList;
import java.util.List;

/**
 * Keybind manager
 */
public class KeybindManager
{
    public List<Keybind> keybinds = new ArrayList<Keybind>();
    public boolean focus = true;

    public Keybind register(IKey label, int key, Runnable callback)
    {
        ModContainer mod = ModHelper.getCallerMod();
        String modid = mod == null ? "" : mod.getModId();

        return this.register(modid, label, key, callback);
    }

    public Keybind registerInside(IKey label, int key, Runnable callback)
    {
        ModContainer mod = ModHelper.getCallerMod();
        String modid = mod == null ? "" : mod.getModId();

        return this.register(modid, label, key, callback).inside();
    }

    private Keybind register(String modid, IKey label, int key, Runnable callback)
    {
        Keybind keybind = new Keybind(modid, label, key, callback);

        this.keybinds.add(keybind);

        return keybind;
    }

    public KeybindManager ignoreFocus()
    {
        this.focus = false;

        return this;
    }

    public void add(GuiContext context, boolean inside)
    {
        if (this.focus && context.isFocused())
        {
            return;
        }

        GuiKeybinds keybinds = context.keybinds;

        if (!keybinds.isVisible())
        {
            return;
        }

        for (Keybind keybind : this.keybinds)
        {
            if (keybind.isActive() && (!keybind.inside || inside))
            {
                keybinds.addKeybind(keybind);
            }
        }
    }

    public boolean check(GuiContext context, boolean inside)
    {
        if (this.focus && context.isFocused())
        {
            return false;
        }

        int keyCode = context.keyCode;

        for (Keybind keybind : this.keybinds)
        {
            if (keybind.isActive() && keybind.check(keyCode, inside) && keybind.callback != null)
            {
                keybind.callback.run();

                return true;
            }
        }

        return false;
    }
}

==================================================

--- Файл №95 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Label.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.client.gui.utils.keys.IKey;

import java.util.Objects;

public class Label<T>
{
    public IKey title;
    public T value;

    public Label(IKey title, T value)
    {
        this.title = title;
        this.value = value;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Label)
        {
            Label label = (Label) obj;

            return Objects.equals(this.title, label.title) && Objects.equals(this.value, label.value);
        }

        return super.equals(obj);
    }
}


==================================================

--- Файл №96 ---
Путь: main\java\mchorse\mclib\client\gui\utils\ModKeybinds.java
--------------------
package mchorse.mclib.client.gui.utils;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;

import com.google.gson.JsonElement;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiKeybindElement;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.client.gui.utils.keys.KeyParser;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.config.values.IConfigGuiProvider;
import mchorse.mclib.config.values.Value;
import mchorse.mclib.config.values.ValueInt;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.common.ModContainer;

public class ModKeybinds extends Value
{
    public ModContainer mod;

    public ModKeybinds(ModContainer mod)
    {
        super(mod == null ? "" : mod.getModId());

        this.mod = mod;
        this.clientSide();
    }

    public void addKeybind(Keybind key)
    {
        String categoryId = key.categoryToken;
        String id = key.labelToken;

        Value category = this.getSubValue(categoryId);

        if (category == null)
        {
            category = new KeybindCategory(categoryId);
            category.setConfig(this.getConfig());

            this.addSubValue(category);
        }

        if (category.getSubValue(id) != null)
        {
            ValueInt old = (ValueInt) category.getSubValue(id);

            if (old.hasChanged())
            {
                return;
            }
        }

        ValueInt keybind = new ValueInt(id, key.keyCode).comboKey();

        keybind.setConfig(this.getConfig());
        category.addSubValue(keybind);
    }

    @Override
    public boolean isVisible()
    {
        int n = 0;

        for (Value value : this.getSubValues())
        {
            n += value.getSubValues().size();
        }

        return n != 0;
    }

    @Override
    public String getLabelKey()
    {
        if (this.mod == null)
        {
            return "keybinds.config.unknown_mod";
        }
        else
        {
            String key = this.id + ".config.title";

            if (I18n.hasKey(key))
            {
                return key;
            }
            else
            {
                return this.mod.getName() + ' ';
            }
        }
    }

    @Override
    public void setConfig(Config config)
    {
        super.setConfig(config);

        Value category = new KeybindCategory("");

        category.setConfig(this.getConfig());
        this.addSubValue(category);
    }

    @Override
    public void fromJSON(JsonElement element)
    {
        if (element.isJsonObject())
        {
            for (Entry<String, JsonElement> entry : element.getAsJsonObject().entrySet())
            {
                String category = entry.getKey();
                Value value = this.getSubValue(category);

                if (value == null)
                {
                    value = new KeybindCategory(category);
                    value.setConfig(this.getConfig());

                    this.addSubValue(value);
                }

                JsonElement children = entry.getValue();

                if (children.isJsonObject())
                {
                    for (Entry<String, JsonElement> keybind : children.getAsJsonObject().entrySet())
                    {
                        JsonElement keyCode = keybind.getValue();

                        if (keyCode.isJsonPrimitive() && keyCode.getAsJsonPrimitive().isNumber())
                        {
                            ValueInt key = new ValueInt(keybind.getKey(), -1).comboKey();

                            key.set(keyCode.getAsInt());
                            key.setConfig(this.getConfig());

                            value.addSubValue(key);
                        }
                    }
                }
            }
        }
    }

    public static class KeybindCategory extends Value implements IConfigGuiProvider
    {
        public static final IKey NO_CATEGORY = IKey.lang("keybinds.config.no_category");

        public KeybindCategory(String id)
        {
            super(id);
        }

        @Override
        public boolean isVisible()
        {
            return !this.getSubValues().isEmpty();
        }

        @Override
        public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
        {
            List<GuiElement> elements = new ArrayList<GuiElement>();

            GuiElement label = Elements.label(this.id.isEmpty() ? NO_CATEGORY : KeyParser.fromJson(this.id)).background();

            label.margin.top(20);
            elements.add(label);

            for (Value value : this.getSubValues())
            {
                GuiElement element = new GuiElement(mc);

                element.flex().row(0).preferred(0).height(20);
                element.add(Elements.label(KeyParser.fromJson(value.id), 0).anchor(0, 0.5F));

                GuiKeybindElement keybind = new GuiKeybindElement(mc, (ValueInt) value);

                keybind.flex().w(90);
                element.add(keybind.removeTooltip());

                elements.add(element);
            }

            return elements;
        }
    }
}


==================================================

--- Файл №97 ---
Путь: main\java\mchorse\mclib\client\gui\utils\Scale.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;

/**
 * This class represents a scale of an axis 
 */
public class Scale
{
    protected double shift = 0;
    protected double zoom = 1;
    protected int mult = 1;
    public boolean inverse;

    public Area area;
    public ScrollDirection direction = ScrollDirection.HORIZONTAL;
    public float anchor;

    protected boolean lockViewport;
    protected double lockMin;
    protected double lockMax;

    public Scale(Area area, ScrollDirection direction, boolean inverse)
    {
        this(area, inverse);

        this.direction = direction;
    }

    public Scale(Area area, boolean inverse)
    {
        this(inverse);

        this.area = area;
    }

    public Scale(boolean inverse)
    {
        this.inverse = inverse;
    }

    /* Convenience methods */

    public void set(double shift, double zoom)
    {
        this.setShift(shift);
        this.setZoom(zoom);
    }

    public void anchor(float anchor)
    {
        this.anchor = anchor;
    }

    public void lock(double min, double max)
    {
        this.lockViewport = true;
        this.lockMin = Math.min(min, max);
        this.lockMax = Math.max(min, max);
    }

    public void unlock()
    {
        this.lockViewport = false;
    }

    public double getLockMin()
    {
        return this.lockMin;
    }

    public double getLockMax()
    {
        return this.lockMax;
    }

    public void calculateMultiplier()
    {
        this.mult = this.recalcMultiplier(this.zoom);
    }

    protected int recalcMultiplier(double zoom)
    {
        int factor = (int) (60F / zoom);

        /* Hardcoded caps */
        if (factor > 10000) factor = 10000;
        else if (factor > 5000) factor = 5000;
        else if (factor > 2500) factor = 2500;
        else if (factor > 1000) factor = 1000;
        else if (factor > 500) factor = 500;
        else if (factor > 250) factor = 250;
        else if (factor > 100) factor = 100;
        else if (factor > 50) factor = 50;
        else if (factor > 25) factor = 25;
        else if (factor > 10) factor = 10;
        else if (factor > 5) factor = 5;

        return factor <= 0 ? 1 : factor;
    }

    /* Getters/setters */

    public void setShift(double shift)
    {
        if (this.lockViewport)
        {
            double distance = this.getMaxValue() - this.getMinValue();

            this.shift = shift;

            double min = this.getMinValue();
            double max = this.getMaxValue();

            if (min < this.lockMin)
            {
                this.shift(this.lockMin, this.lockMin + distance);
            }
            else if (max > this.lockMax)
            {
                this.shift(this.lockMax - distance, this.lockMax);
            }

            min = this.getMinValue();
            max = this.getMaxValue();

            if (min < this.lockMin || max > this.lockMax)
            {
                double lockMin = Math.max(this.lockMin, min);
                double lockMax = Math.min(this.lockMax, max);

                this.view(lockMin, lockMax);
            }
        }
        else
        {
            this.shift = shift;
        }
    }

    public double getShift()
    {
        return this.shift;
    }

    public void setZoom(double zoom)
    {
        if (this.lockViewport)
        {
            this.zoom = zoom;

            double min = this.getMinValue();
            double max = this.getMaxValue();

            if (min < this.lockMin || max > this.lockMax)
            {
                this.view(Math.max(min, this.lockMin), Math.min(max, this.lockMax));
            }
        }
        else
        {
            this.zoom = zoom;
        }

        this.calculateMultiplier();
    }

    public double getZoom()
    {
        return this.zoom;
    }

    public int getMult()
    {
        return this.mult;
    }

    /* Graphing code */

    /**
     * Convert the value to on-screen coordinate
     */
    public double to(double value)
    {
        double factor = (!this.inverse ? value - this.shift : -value + this.shift) * this.zoom;

        if (this.area != null)
        {
            factor += this.direction.getPosition(this.area, this.anchor);
        }

        return factor;
    }

    /**
     * Convert on-screen coordinate to value
     */
    public double from(double coordinate)
    {
        if (this.area != null)
        {
            coordinate -= this.direction.getPosition(this.area, this.anchor);
        }

        return this.inverse ? -(coordinate / this.zoom - this.shift) : coordinate / this.zoom + this.shift;
    }

    public double getMinValue()
    {
        this.assertArea();

        return this.from(this.direction.getPosition(this.area, this.inverse ? 1 : 0));
    }

    public double getMaxValue()
    {
        this.assertArea();

        return this.from(this.direction.getPosition(this.area, this.inverse ? 0 : 1));
    }

    /* Viewport manipulation methods */

    public void view(double min, double max)
    {
        this.assertArea();
        this.view(min, max, this.direction.getSide(this.area));
    }

    public void view(double min, double max, double length)
    {
        this.viewOffset(min, max, length, 0);
    }

    public void viewOffset(double min, double max, double offset)
    {
        this.assertArea();
        this.viewOffset(min, max, this.direction.getSide(this.area), offset);
    }

    public void viewOffset(double min, double max, double length, double offset)
    {
        if (length <= 0)
        {
            return;
        }

        this.zoom = 1 / ((max - min) / length);

        if (offset != 0)
        {
            min -= offset / this.zoom;
            max += offset / this.zoom;
        }

        if (this.lockViewport && (min < this.lockMin || max > this.lockMax))
        {
            min = Math.max(min, this.lockMin);
            max = Math.min(max, this.lockMax);
        }

        this.zoom = 1 / ((max - min) / length);
        this.shift(min, max);

        this.calculateMultiplier();
    }

    public void shift(double min, double max)
    {
        this.shift = Interpolations.lerp(min, max, this.inverse ? 1 - this.anchor : this.anchor);
    }

    public void shiftInto(double value)
    {
        this.shiftInto(value, 0);
    }

    public void shiftInto(double value, double offset)
    {
        double min = this.getMinValue();
        double max = this.getMaxValue();
        double distance = max - min;

        if (value < min)
        {
            this.shift(value, value + distance);
        }
        else if (value > max)
        {
            value -= offset;

            this.shift(value - distance, value);
        }
    }

    public void zoom(double amount, double min, double max)
    {
        this.setZoom(MathUtils.clamp(this.zoom + amount, min, max));
    }

    public double getZoomFactor()
    {
        return this.getZoomFactor(this.zoom);
    }

    public double getZoomFactor(double zoom)
    {
        double factor = 5D;

        if (zoom < 0.2D) factor = 0.005D;
        else if (zoom < 1) factor = 0.025D;
        else if (zoom < 2) factor = 0.1D;
        else if (zoom < 15) factor = 0.5D;
        else if (zoom <= 50) factor = 1D;
        else if (zoom <= 250) factor = 2.5D;

        return factor;
    }

    protected void assertArea()
    {
        if (this.area == null)
        {
            throw new IllegalStateException("This operation isn't possible without area present!");
        }
    }
}

==================================================

--- Файл №98 ---
Путь: main\java\mchorse\mclib\client\gui\utils\ScrollArea.java
--------------------
package mchorse.mclib.client.gui.utils;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.gui.Gui;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Scrollable area
 * 
 * This class is responsible for storing information for scrollable one 
 * directional objects. 
 */
public class ScrollArea extends Area
{
    /**
     * Size of an element/item in the scroll area
     */
    public int scrollItemSize;

    /**
     * Size of the scrolling area 
     */
    public int scrollSize;

    /**
     * Scroll position 
     */
    public int scroll;

    /**
     * Whether this scroll area gets dragged 
     */
    public boolean dragging;

    /**
     * Speed of how fast shit's scrolling  
     */
    public int scrollSpeed = 10;

    /**
     * Scroll direction, used primarily in the {@link #clamp()} method 
     */
    public ScrollDirection direction = ScrollDirection.VERTICAL;

    /**
     * Whether the scrollbar should be on opposite side (default is right
     * for vertical and bottom for horizontal)
     */
    public boolean opposite;

    /**
     * Width of scroll bar
     */
    public int scrollbarWidth = -1;

    /**
     * Whether this scroll area should cancel mouse events when mouse scroll
     * reaches the end
     */
    public boolean cancelScrollEdge = false;

    public ScrollArea(int x, int y, int w, int h)
    {
        super(x, y, w, h);
    }

    public ScrollArea()
    {}

    public ScrollArea(int itemSize)
    {
        this.scrollItemSize = itemSize;
    }

    public int getScrollbarWidth()
    {
        return this.scrollbarWidth <= 0 ? McLib.scrollbarWidth.get() : this.scrollbarWidth;
    }

    public void setSize(int items)
    {
        this.scrollSize = items * this.scrollItemSize;
    }

    /**
     * Scroll by relative amount 
     */
    public void scrollBy(int x)
    {
        this.scroll += x;
        this.clamp();
    }

    /**
     * Scroll to the position in the scroll area 
     */
    public void scrollTo(int x)
    {
        this.scroll = x;
        this.clamp();
    }

    public void scrollIntoView(int x)
    {
        this.scrollIntoView(x, this.scrollItemSize, 0);
    }

    public void scrollIntoView(int x, int bottomOffset)
    {
        this.scrollIntoView(x, bottomOffset, 0);
    }

    public void scrollIntoView(int x, int bottomOffset, int topOffset)
    {
        if (this.scroll + topOffset > x)
        {
            this.scrollTo(x - topOffset);
        }
        else if (x > this.scroll + this.direction.getSide(this) - bottomOffset)
        {
            this.scrollTo(x - this.direction.getSide(this) + bottomOffset);
        }
    }

    /**
     * Clamp scroll to the bounds of the scroll size; 
     */
    public void clamp()
    {
        int size = this.direction.getSide(this);

        if (this.scrollSize <= size)
        {
            this.scroll = 0;
        }
        else
        {
            this.scroll = MathUtils.clamp(this.scroll, 0, this.scrollSize - size);
        }
    }

    /**
     * Get index of the cursor based on the {@link #scrollItemSize}.  
     */
    public int getIndex(int x, int y)
    {
        int axis = this.direction.getScroll(this, x, y);
        int index = axis / this.scrollItemSize;

        if (axis < 0)
        {
            return -1;
        }
        else if (axis > this.scrollSize)
        {
            return -2;
        }

        return index > this.scrollSize / this.scrollItemSize ? -1 : index;
    }

    /**
     * Calculates scroll bar's height 
     */
    public int getScrollBar(int size)
    {
        int maxSize = this.direction.getSide(this);

        if (this.scrollSize < size)
        {
            return 0;
        }

        return (int) ((1.0F - ((this.scrollSize - maxSize) / (float) this.scrollSize)) * size);
    }

    /* GUI code for easier manipulations */

    @SideOnly(Side.CLIENT)
    public boolean mouseClicked(GuiContext context)
    {
        return this.mouseClicked(context.mouseX, context.mouseY);
    }

    /**
     * This method should be invoked to register dragging 
     */
    public boolean mouseClicked(int x, int y)
    {
        boolean isInside = this.isInside(x, y) && this.scrollSize > this.h;

        if (isInside)
        {
            int scrollbar = this.getScrollbarWidth();

            if (this.opposite)
            {
                isInside = this.direction == ScrollDirection.VERTICAL ? x <= this.x + scrollbar : y <= this.y + scrollbar;
            }
            else
            {
                isInside = this.direction == ScrollDirection.VERTICAL ? x >= this.ex() - scrollbar : y >= this.ey() - scrollbar;
            }
        }

        if (isInside)
        {
            this.dragging = true;
        }

        return isInside;
    }

    @SideOnly(Side.CLIENT)
    public boolean mouseScroll(GuiContext context)
    {
        return this.mouseScroll(context.mouseX, context.mouseY, context.mouseWheel);
    }

    /**
     * This method should be invoked when mouse wheel is scrolling 
     */
    public boolean mouseScroll(int x, int y, int scroll)
    {
        boolean isInside = this.isInside(x, y);
        int lastScroll = this.scroll;

        if (isInside)
        {
            this.scrollBy((int) Math.copySign(this.scrollSpeed, scroll));
        }

        return isInside && (this.cancelScrollEdge || lastScroll != this.scroll);
    }

    @SideOnly(Side.CLIENT)
    public void mouseReleased(GuiContext context)
    {
        this.mouseReleased(context.mouseX, context.mouseY);
    }

    /**
     * When mouse button gets released
     */
    public void mouseReleased(int x, int y)
    {
        this.dragging = false;
    }

    @SideOnly(Side.CLIENT)
    public void drag(GuiContext context)
    {
        this.drag(context.mouseX, context.mouseY);
    }

    /**
     * This should be invoked in a drawing or and update method. It's 
     * responsible for scrolling through this view when dragging. 
     */
    public void drag(int x, int y)
    {
        if (this.dragging)
        {
            float progress = this.direction.getProgress(this, x, y);

            this.scrollTo((int) (progress * (this.scrollSize - this.direction.getSide(this) + this.getScrollbarWidth())));
        }
    }

    /**
     * This method is responsible for drawing a scroll bar 
     */
    @SideOnly(Side.CLIENT)
    public void drawScrollbar()
    {
        int side = this.direction.getSide(this);

        if (this.scrollSize <= side)
        {
            return;
        }

        int scrollbar = this.getScrollbarWidth();
        int h = this.getScrollBar(side / 2);
        int x = this.opposite ? this.x : this.ex() - scrollbar;
        /* Sometimes I don't understand how I come up with such clever
         * formulas, but it's all ratios, y'all */
        int y = this.y + (int) ((this.scroll / (float) (this.scrollSize - this.h)) * (this.h - h));
        int rx = x + scrollbar;
        int ry = y + h;

        if (this.direction == ScrollDirection.HORIZONTAL)
        {
            y = this.opposite ? this.y : this.ey() - scrollbar;
            x = this.x + (int) ((this.scroll / (float) (this.scrollSize - this.w)) * (this.w - h));
            rx = x + h;
            ry = y + scrollbar;
        }

        if (McLib.scrollbarFlat.get())
        {
            Gui.drawRect(x, y, rx, ry, -6250336);
        }
        else
        {
            int color = McLib.scrollbarShadow.get();

            GuiDraw.drawDropShadow(x, y, rx, ry, 5, color, ColorUtils.setAlpha(color, 0F));

            Gui.drawRect(x, y, rx, ry, 0xffeeeeee);
            Gui.drawRect(x + 1, y + 1, rx, ry, 0xff666666);
            Gui.drawRect(x + 1, y + 1, rx - 1, ry - 1, 0xffaaaaaa);
        }
    }
}

==================================================

--- Файл №99 ---
Путь: main\java\mchorse\mclib\client\gui\utils\ScrollDirection.java
--------------------
package mchorse.mclib.client.gui.utils;

/**
 * Scroll direction
 */
public enum ScrollDirection
{
    VERTICAL()
    {
        @Override
        public int getPosition(Area area, float x)
        {
            return area.y(x);
        }

        @Override
        public int getSide(Area area)
        {
            return area.h;
        }

        @Override
        public int getScroll(ScrollArea area, int x, int y)
        {
            return y - area.y + area.scroll;
        }

        @Override
        public float getProgress(Area area, int x, int y)
        {
            return (y - area.y) / (float) area.h;
        }
    },
    HORIZONTAL()
    {
        @Override
        public int getPosition(Area area, float x)
        {
            return area.x(x);
        }

        @Override
        public int getSide(Area area)
        {
            return area.w;
        }

        @Override
        public int getScroll(ScrollArea area, int x, int y)
        {
            return x - area.x + area.scroll;
        }

        @Override
        public float getProgress(Area area, int x, int y)
        {
            return (x - area.x) / (float) area.w;
        }
    };

    /**
     * Get position of the area, x = 0 minimum corner, x = 1 maximum corner
     */
    public abstract int getPosition(Area area,  float x);

    /**
     * Get dominant side for this scrolling direction
     */
    public abstract int getSide(Area area);

    /**
     * Get scrolled amount for given mouse position
     */
    public abstract int getScroll(ScrollArea area, int x, int y);

    /**
     * Get progress scalar between 0 and 1 which identifies how much
     * it is near the maximum side
     */
    public abstract float getProgress(Area area, int x, int y);
}


==================================================

--- Файл №100 ---
Путь: main\java\mchorse\mclib\client\gui\utils\TabCompleter.java
--------------------
package mchorse.mclib.client.gui.utils;

import java.util.ArrayList;
import java.util.List;

import com.google.common.collect.Lists;

import net.minecraft.client.gui.GuiTextField;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * This class was brutally stolen from net.minecraft.util.
 *
 * It was also refactored so I could use {@code List<String>} instead of
 * {@code String[]}, and it doesn't require server. It's local tab completer!
 */
@SideOnly(Side.CLIENT)
public class TabCompleter
{
    protected GuiTextField textField;

    protected List<String> allCompletions = Lists.<String> newArrayList();
    protected List<String> completions = Lists.<String> newArrayList();

    protected boolean didComplete;
    protected int index;

    public TabCompleter(GuiTextField textField)
    {
        this.textField = textField;
    }

    public List<String> getCompletions()
    {
        return this.completions;
    }

    public GuiTextField getField()
    {
        return this.textField;
    }

    public void setField(GuiTextField textField)
    {
        this.textField = textField;
    }

    /**
     * Called when tab key pressed. If it's the first time we tried to complete this string, we ask the server for
     * completions. When the server responds, this method gets called again (via setCompletions).
     */
    public void complete()
    {
        int size = this.completions.size();

        if (size != 0 && this.index >= 0 && this.index < size)
        {
            this.textField.setText(this.completions.get(this.index));
        }

        if (this.didComplete)
        {
            this.index++;

            if (this.index >= this.completions.size())
            {
                this.index = 0;
            }
        }
        else
        {
            this.requestCompletions(this.textField.getText());
        }
    }

    private void requestCompletions(String prefix)
    {
        List<String> completions = new ArrayList<String>();

        for (String str : this.allCompletions)
        {
            if (str.toLowerCase().startsWith(prefix.toLowerCase()) || prefix.isEmpty())
            {
                completions.add(str);
            }
        }

        this.setCompletions(completions);
    }

    public void setAllCompletions(List<String> words)
    {
        this.allCompletions.clear();
        this.allCompletions.addAll(words);
    }

    /**
     * Only actually sets completions if they were requested (via requestCompletions)
     */
    public void setCompletions(List<String> words)
    {
        this.didComplete = false;

        this.completions.clear();
        this.completions.addAll(words);
        this.index = 0;

        if (!this.completions.isEmpty())
        {
            this.didComplete = true;
            this.complete();
        }
    }

    /**
     * Called when new text is entered, or backspace pressed
     */
    public void resetDidComplete()
    {
        this.didComplete = false;
        this.completions.clear();
    }
}

==================================================

--- Файл №101 ---
Путь: main\java\mchorse\mclib\client\gui\utils\ValueColors.java
--------------------
package mchorse.mclib.client.gui.utils;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.config.values.IServerValue;
import mchorse.mclib.config.values.Value;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.ColorUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;

public class ValueColors extends Value implements IServerValue
{
    private List<Color> colors = new ArrayList<Color>();
    private List<Color> serverColors;

    public ValueColors(String id)
    {
        super(id);
    }

    @Override
    public Object getValue()
    {
        return this.getColors();
    }

    @Override
    public void setValue(Object value)
    {
        if (value instanceof List)
        {
            List list = (List) value;

            if (list.isEmpty())
            {
                return;
            }

            this.colors.clear();

            for (Object object : list)
            {
                if (object instanceof Color)
                {
                    this.colors.add((Color) object);
                }
            }
        }
    }

    public List<Color> getCurrentColors()
    {
        return this.colors;
    }

    public List<Color> getColors()
    {
        return this.serverColors == null ? this.colors : this.serverColors;
    }

    @Override
    public void reset()
    {
        this.colors.clear();
    }

    @Override
    public void resetServer()
    {
        this.serverColors = null;
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        if (!element.isJsonArray())
        {
            return;
        }

        JsonArray array = element.getAsJsonArray();

        for (JsonElement color : array)
        {
            if (color.isJsonPrimitive())
            {
                this.colors.add(new Color().set(color.getAsInt(), true));
            }
        }
    }

    @Override
    public JsonElement valueToJSON()
    {
        JsonArray array = new JsonArray();

        for (Color color : this.colors)
        {
            array.add(new JsonPrimitive(color.getRGBAColor()));
        }

        return array;
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        String[] splits = value.split(",");
        List<Color> colors = new ArrayList<Color>();

        for (String split : splits)
        {
            try
            {
                int color = ColorUtils.parseColorWithException(split.trim());

                colors.add(new Color().set(color, true));
            }
            catch (Exception e)
            {
                return false;
            }
        }

        this.colors.clear();
        this.colors.addAll(colors);
        this.saveLater();

        return true;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueColors)
        {
            this.colors.clear();
            this.colors.addAll(((ValueColors) value).colors);
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueColors)
        {
            this.serverColors = ((ValueColors) value).colors;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        super.fromBytes(buffer);

        this.colors.clear();

        for (int i = 0, c = buffer.readInt(); i < c; i++)
        {
            this.colors.add(new Color().set(buffer.readInt(), true));
        }
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        super.toBytes(buffer);

        buffer.writeInt(this.colors.size());

        for (Color color : this.colors)
        {
            buffer.writeInt(color.getRGBAColor());
        }
    }

    @Override
    public String toString()
    {
        StringJoiner joiner = new StringJoiner(", ");

        for (Color color : this.colors)
        {
            joiner.add("#" + Integer.toHexString(color.getRGBAColor()));
        }

        return joiner.toString();
    }
}

==================================================

--- Файл №102 ---
Путь: main\java\mchorse\mclib\client\gui\utils\keys\CompoundKey.java
--------------------
package mchorse.mclib.client.gui.utils.keys;

public class CompoundKey implements IKey
{
    public static long lastTime;

    public IKey[] keys;
    public String string;
    public long time = -1;

    public CompoundKey(IKey... keys)
    {
        this.keys = keys;
    }

    @Override
    public String get()
    {
        if (lastTime > time)
        {
            this.time = lastTime;
            this.construct();
        }

        return this.string;
    }

    private void construct()
    {
        StringBuilder builder = new StringBuilder();

        for (IKey key : this.keys)
        {
            builder.append(key.get());
        }

        this.string = builder.toString();
    }

    @Override
    public void set(String string)
    {
        throw new IllegalStateException("Not implemented!");
    }

    public void set(IKey... keys)
    {
        this.keys = keys;
        this.construct();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (super.equals(obj))
        {
            return true;
        }

        if (obj instanceof CompoundKey)
        {
            return this.get().equals(((CompoundKey) obj).get());
        }

        return false;
    }

    @Override
    public String toString()
    {
        return this.get();
    }
}

==================================================

--- Файл №103 ---
Путь: main\java\mchorse\mclib\client\gui\utils\keys\IKey.java
--------------------
package mchorse.mclib.client.gui.utils.keys;

import java.io.Serializable;

public interface IKey extends Serializable
{
    public static final IKey EMPTY = new StringKey("");

    public static IKey lang(String key)
    {
        return new LangKey(key);
    }

    public static IKey format(String key, Object... args)
    {
        return new LangKey(key).args(args);
    }

    public static IKey str(String key)
    {
        return new StringKey(key);
    }

    public static IKey comp(IKey... keys)
    {
        return new CompoundKey(keys);
    }

    public String get();

    public void set(String string);
}

==================================================

--- Файл №104 ---
Путь: main\java\mchorse\mclib\client\gui\utils\keys\KeyParser.java
--------------------
package mchorse.mclib.client.gui.utils.keys;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonPrimitive;
import com.google.gson.JsonSerializationContext;
import com.google.gson.JsonSerializer;

public class KeyParser
{
    public static final Gson JSON_PARSER = new GsonBuilder()
            .registerTypeHierarchyAdapter(IKey.class, new KeyJsonAdapter())
            .serializeNulls()
            .create();

    public static IKey keyFromBytes(ByteBuf buffer)
    {
        byte type = buffer.readByte();

        if (type == 0)
        {
            return IKey.str(ByteBufUtils.readUTF8String(buffer));
        }
        else if (type == 1)
        {
            String key = ByteBufUtils.readUTF8String(buffer);
            List<Object> args = new ArrayList<Object>();

            for (int i = 0, c = buffer.readInt(); i < c; i++)
            {
                byte argType = buffer.readByte();

                if (argType == 0)
                {
                    args.add(ByteBufUtils.readUTF8String(buffer));
                }
                else if (argType == 1)
                {
                    args.add(keyFromBytes(buffer));
                }
            }

            return args.isEmpty() ? IKey.lang(key) : IKey.format(key, args.toArray(new Object[args.size()]));
        }
        else if (type == 2)
        {
            List<IKey> keys = new ArrayList<>();

            for (int i = 0, c = buffer.readInt(); i < c; i++)
            {
                IKey key = keyFromBytes(buffer);

                if (key != null)
                {
                    keys.add(key);
                }
            }

            return IKey.comp(keys.toArray(new IKey[keys.size()]));
        }

        return null;
    }

    public static void keyToBytes(ByteBuf buffer, IKey key)
    {
        if (key instanceof StringKey)
        {
            buffer.writeByte(0);
            ByteBufUtils.writeUTF8String(buffer, ((StringKey) key).string);
        }
        else if (key instanceof LangKey)
        {
            LangKey lang = (LangKey) key;

            buffer.writeByte(1);
            ByteBufUtils.writeUTF8String(buffer, lang.key);
            buffer.writeInt(lang.args.length);

            for (Object arg : lang.args)
            {
                if (arg instanceof String)
                {
                    buffer.writeByte(0);
                    ByteBufUtils.writeUTF8String(buffer, (String) arg);
                }
                else if (arg instanceof IKey)
                {
                    buffer.writeByte(1);
                    keyToBytes(buffer, (IKey) arg);
                }
                else
                {
                    buffer.writeByte(0);
                    ByteBufUtils.writeUTF8String(buffer, arg.toString());
                }
            }
        }
        else if (key instanceof CompoundKey)
        {
            CompoundKey compound = (CompoundKey) key;

            buffer.writeByte(2);
            buffer.writeInt(compound.keys.length);

            for (IKey childKey : compound.keys)
            {
                keyToBytes(buffer, childKey);
            }
        }
        else
        {
            /* Just some random value */
            buffer.writeByte(100);
        }
    }

    public static IKey fromJson(String json)
    {
        IKey key = JSON_PARSER.fromJson(json, IKey.class);

        if (key == null)
        {
            key = IKey.EMPTY;
        }

        return key;
    }

    public static String toJson(IKey key)
    {
        if (key == null || IKey.EMPTY.equals(key))
        {
            return "";
        }

        return JSON_PARSER.toJson(key);
    }

    public static class KeyJsonAdapter implements JsonDeserializer<IKey>, JsonSerializer<IKey>
    {
        @Override
        public JsonElement serialize(IKey src, Type typeOfSrc, JsonSerializationContext context)
        {
            if (src instanceof LangKey)
            {
                LangKey lang = (LangKey) src;
                JsonObject obj = new JsonObject();
                JsonArray arr = new JsonArray();

                for (Object arg : lang.args)
                {
                    arr.add(context.serialize(arg));
                }

                obj.add(lang.key, arr);

                return obj;
            }
            else if (src instanceof CompoundKey)
            {
                CompoundKey compound = (CompoundKey) src;
                JsonArray arr = new JsonArray();

                for (IKey key : compound.keys)
                {
                    arr.add(context.serialize(key, IKey.class));
                }

                return arr;
            }
            else
            {
                return new JsonPrimitive(String.valueOf(src));
            }
        }

        @Override
        public IKey deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException
        {
            if (json.isJsonObject())
            {
                JsonObject obj = json.getAsJsonObject();

                String key = obj.entrySet().iterator().next().getKey();
                LangKey lang = new LangKey(key);
                JsonElement element = obj.get(key);

                if (element instanceof JsonArray)
                {
                    List<Object> args = new ArrayList<Object>();

                    for (JsonElement child : element.getAsJsonArray())
                    {
                        args.add(context.deserialize(child, child.isJsonPrimitive() ? Object.class : IKey.class));
                    }

                    lang.args = args.toArray();
                }

                return lang;
            }
            else if (json.isJsonArray())
            {
                JsonArray arr = json.getAsJsonArray();
                CompoundKey compound = new CompoundKey();
                List<IKey> keys = new ArrayList<IKey>();

                for (JsonElement key : arr)
                {
                    keys.add(context.deserialize(key, IKey.class));
                }

                compound.keys = keys.toArray(new IKey[0]);

                return compound;
            }
            else if (json.isJsonNull())
            {
                return IKey.EMPTY;
            }
            else
            {
                return new StringKey(json.toString());
            }
        }
    }
}


==================================================

--- Файл №105 ---
Путь: main\java\mchorse\mclib\client\gui\utils\keys\LangKey.java
--------------------
package mchorse.mclib.client.gui.utils.keys;

import net.minecraft.client.resources.I18n;

public class LangKey implements IKey
{
    public static long lastTime;

    public String key;
    public String string;
    public long time = -1;
    public Object[] args = new Object[0];

    public LangKey(String key)
    {
        this.key = key;
    }

    public LangKey args(Object... args)
    {
        this.args = args;

        return this;
    }

    public String update()
    {
        this.time = -1;

        return this.get();
    }

    @Override
    public String get()
    {
        if (lastTime > time)
        {
            this.time = lastTime;
            this.string = I18n.format(this.key, this.args);
        }

        return this.string;
    }

    @Override
    public void set(String string)
    {
        this.key = string;
        this.string = I18n.format(this.key);
    }

    @Override
    public boolean equals(Object obj)
    {
        if (super.equals(obj))
        {
            return true;
        }

        if (obj instanceof LangKey)
        {
            return this.get().equals(((LangKey) obj).get());
        }

        return false;
    }

    @Override
    public String toString()
    {
        return this.get();
    }
}

==================================================

--- Файл №106 ---
Путь: main\java\mchorse\mclib\client\gui\utils\keys\StringKey.java
--------------------
package mchorse.mclib.client.gui.utils.keys;

public class StringKey implements IKey
{
    public String string;

    public StringKey(String string)
    {
        this.string = string;
    }

    @Override
    public String get()
    {
        return this.string;
    }

    @Override
    public void set(String string)
    {
        this.string = string;
    }

    @Override
    public boolean equals(Object obj)
    {
        if (super.equals(obj))
        {
            return true;
        }

        if (obj instanceof StringKey)
        {
            return this.string.equals(((StringKey) obj).string);
        }

        return false;
    }

    @Override
    public String toString()
    {
        return this.string;
    }
}

==================================================

--- Файл №107 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\AutomaticResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.IGuiElement;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public abstract class AutomaticResizer extends BaseResizer
{
    public GuiElement parent;
    public int margin;
    public int padding;
    public int height;

    public AutomaticResizer(GuiElement parent, int margin)
    {
        this.parent = parent;
        this.margin = margin;

        this.setup();
    }

    /* Standard properties */

    public AutomaticResizer padding(int padding)
    {
        this.padding = padding;

        return this;
    }

    public AutomaticResizer height(int height)
    {
        this.height = height;

        return this;
    }

    public void reset()
    {
        /* ¯\_(ツ)_/¯ */
    }

    /* Child management */

    public void setup()
    {
        for (IGuiElement child : this.parent.getChildren())
        {
            if (child instanceof GuiElement)
            {
                GuiElement element = (GuiElement) child;

                element.resizer(this.child(element));
            }
        }
    }

    public IResizer child(GuiElement element)
    {
        ChildResizer child = new ChildResizer(this, element);

        return child;
    }

    public List<ChildResizer> getResizers()
    {
        List<ChildResizer> resizers = new ArrayList<ChildResizer>();

        for (IGuiElement element : this.parent.getChildren())
        {
            if (element instanceof GuiElement)
            {
                GuiElement elem = (GuiElement) element;

                if (elem.resizer() instanceof ChildResizer)
                {
                    resizers.add((ChildResizer) elem.resizer());
                }
            }
        }

        return resizers;
    }

    /* Miscellaneous */

    @Override
    public void add(GuiElement parent, GuiElement child)
    {
        if (child.ignored)
        {
            return;
        }

        child.resizer(this.child(child));
    }

    @Override
    public void remove(GuiElement parent, GuiElement child)
    {
        if (child.ignored)
        {
            return;
        }

        IResizer resizer = child.resizer();

        if (resizer instanceof ChildResizer)
        {
            child.resizer(((ChildResizer) resizer).resizer);
        }
    }

    @Override
    public int getX()
    {
        return 0;
    }

    @Override
    public int getY()
    {
        return 0;
    }

    @Override
    public int getW()
    {
        return 0;
    }

    @Override
    public int getH()
    {
        return 0;
    }
}

==================================================

--- Файл №108 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\BaseResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;

public abstract class BaseResizer implements IResizer, IParentResizer
{
    @Override
    public void preApply(Area area)
    {}

    @Override
    public void apply(Area area)
    {}

    @Override
    public void apply(Area area, IResizer resizer, ChildResizer child)
    {}

    @Override
    public void postApply(Area area)
    {}

    @Override
    public void add(GuiElement parent, GuiElement child)
    {}

    @Override
    public void remove(GuiElement parent, GuiElement child)
    {}
}

==================================================

--- Файл №109 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\ChildResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;

public class ChildResizer extends DecoratedResizer
{
    public IParentResizer parent;
    public GuiElement element;
    private int x;
    private int y;
    private int w;
    private int h;

    public ChildResizer(IParentResizer parent, GuiElement element)
    {
        super(element.flex());
        this.parent = parent;
        this.element = element;
    }

    @Override
    public void apply(Area area)
    {
        if (this.resizer != null)
        {
            this.resizer.apply(area);
        }

        this.parent.apply(area, this.resizer, this);
        this.x = area.x;
        this.y = area.y;
        this.w = area.w;
        this.h = area.h;
    }

    @Override
    public void postApply(Area area)
    {
        if (this.resizer != null)
        {
            this.resizer.postApply(area);
        }
    }

    @Override
    public void add(GuiElement parent, GuiElement child)
    {
        if (this.resizer != null)
        {
            this.resizer.add(parent, child);
        }
    }

    @Override
    public void remove(GuiElement parent, GuiElement child)
    {
        if (this.resizer != null)
        {
            this.resizer.remove(parent, child);
        }
    }

    @Override
    public int getX()
    {
        return this.x;
    }

    @Override
    public int getY()
    {
        return this.y;
    }

    @Override
    public int getW()
    {
        return this.w;
    }

    @Override
    public int getH()
    {
        return this.h;
    }
}


==================================================

--- Файл №110 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\DecoratedResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

public abstract class DecoratedResizer extends BaseResizer
{
    public IResizer resizer;

    public DecoratedResizer(IResizer resizer)
    {
        this.resizer = resizer;
    }
}

==================================================

--- Файл №111 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\Flex.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.resizers.constraint.BoundsResizer;
import mchorse.mclib.client.gui.utils.resizers.layout.ColumnResizer;
import mchorse.mclib.client.gui.utils.resizers.layout.GridResizer;
import mchorse.mclib.client.gui.utils.resizers.layout.RowResizer;

import java.util.function.Supplier;

/**
 * Flex class
 * 
 * This class is used to define resizing behavior for a 
 * {@link GuiElement}.
 */
public class Flex implements IResizer
{
    public Unit x = new Unit();
    public Unit y = new Unit();
    public Unit w = new Unit();
    public Unit h = new Unit();

    public IResizer relative;
    public IResizer post;

    public final GuiElement parent;

    public Flex(GuiElement parent)
    {
        this.parent = parent;
    }

    public Flex reset()
    {
        this.x = new Unit();
        this.y = new Unit();
        this.w = new Unit();
        this.h = new Unit();

        this.relative = this.post = null;

        return this;
    }

    public void link(Flex flex)
    {
        this.x = flex.x;
        this.y = flex.y;
        this.w = flex.w;
        this.h = flex.h;

        this.relative = flex.relative;
        this.post = flex.post;
    }

    public Flex set(float x, float y, float w, float h)
    {
        return this.set(x, y, w, h, Measure.PIXELS);
    }

    public Flex set(float x, float y, float w, float h, Measure measure)
    {
        this.x.set(x, measure);
        this.y.set(y, measure);
        this.w.set(w, measure);
        this.h.set(h, measure);

        return this;
    }

    /* X */

    public Flex x(int value)
    {
        this.x.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex x(float value)
    {
        this.x.set(value, Measure.RELATIVE);

        return this;
    }

    public Flex x(float value, int offset)
    {
        this.x.set(value, Measure.RELATIVE, offset);

        return this;
    }

    public Flex x(Supplier<Float> value)
    {
        this.x.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex x(Supplier<Float> value, int offset)
    {
        this.x.set(value, Measure.PIXELS, offset);

        return this;
    }

    /* Y */

    public Flex y(int value)
    {
        this.y.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex y(float value)
    {
        this.y.set(value, Measure.RELATIVE, 0);

        return this;
    }

    public Flex y(float value, int offset)
    {
        this.y.set(value, Measure.RELATIVE, offset);

        return this;
    }

    public Flex y(Supplier<Float> value)
    {
        this.y.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex y(Supplier<Float> value, int offset)
    {
        this.y.set(value, Measure.PIXELS, offset);

        return this;
    }

    /* Width */

    public Flex w(int value)
    {
        this.w.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex w(float value)
    {
        this.w.set(value, Measure.RELATIVE, 0);

        return this;
    }

    public Flex w(float value, int offset)
    {
        this.w.set(value, Measure.RELATIVE, offset);

        return this;
    }

    public Flex w(Supplier<Float> value)
    {
        this.w.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex w(Supplier<Float> value, int offset)
    {
        this.w.set(value, Measure.PIXELS, offset);

        return this;
    }

    public Flex wTo(IResizer flex)
    {
        this.w.target = flex;

        return this;
    }

    public Flex wTo(IResizer flex, int offset)
    {
        this.w.target = flex;
        this.w.offset = offset;

        return this;
    }

    public Flex wTo(IResizer flex, float anchor)
    {
        this.w.target = flex;
        this.w.targetAnchor = anchor;

        return this;
    }

    public Flex wTo(IResizer flex, float anchor, int offset)
    {
        this.w.target = flex;
        this.w.targetAnchor = anchor;
        this.w.offset = offset;

        return this;
    }

    /* Height */

    public Flex h(int value)
    {
        this.h.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex h(float value)
    {
        this.h.set(value, Measure.RELATIVE, 0);

        return this;
    }

    public Flex h(float value, int offset)
    {
        this.h.set(value, Measure.RELATIVE, offset);

        return this;
    }

    public Flex h(Supplier<Float> value)
    {
        this.h.set(value, Measure.PIXELS, 0);

        return this;
    }

    public Flex h(Supplier<Float> value, int offset)
    {
        this.h.set(value, Measure.PIXELS, offset);

        return this;
    }

    public Flex hTo(IResizer target)
    {
        return this.hTo(target, 0);
    }

    public Flex hTo(IResizer target, int offset)
    {
        return this.hTo(target, 0F, offset);
    }

    public Flex hTo(IResizer target, float anchor)
    {
        return this.hTo(target, anchor, 0);
    }

    public Flex hTo(IResizer target, float anchor, int offset)
    {
        this.h.target = target;
        this.h.targetAnchor = anchor;
        this.h.offset = offset;

        return this;
    }

    /* Other variations */

    public Flex xy(int x, int y)
    {
        this.x.set(x, Measure.PIXELS);
        this.y.set(y, Measure.PIXELS);

        return this;
    }

    public Flex xy(float x, float y)
    {
        this.x.set(x, Measure.RELATIVE);
        this.y.set(y, Measure.RELATIVE);

        return this;
    }

    public Flex wh(int w, int h)
    {
        this.w.set(w, Measure.PIXELS);
        this.h.set(h, Measure.PIXELS);

        return this;
    }

    public Flex wh(float w, float h)
    {
        this.w.set(w, Measure.RELATIVE);
        this.h.set(h, Measure.RELATIVE);

        return this;
    }

    public Flex maxW(int max)
    {
        this.w.max = max;

        return this;
    }

    public Flex maxH(int max)
    {
        this.h.max = max;

        return this;
    }

    public Flex anchor(float x, float y)
    {
        this.x.anchor = x;
        this.y.anchor = y;

        return this;
    }

    public Flex anchorX(float x)
    {
        this.x.anchor = x;

        return this;
    }

    public Flex anchorY(float y)
    {
        this.y.anchor = y;

        return this;
    }

    /* Convenience methods */

    public Flex above(Flex flex, int offset)
    {
        return this.relative(flex).y(0, offset).anchorY(1);
    }

    public Flex under(Flex flex, int offset)
    {
        return this.relative(flex).y(1, offset);
    }

    public Flex left(Flex flex, int offset)
    {
        return this.relative(flex).x(0, offset).anchorX(1);
    }

    public Flex right(Flex flex, int offset)
    {
        return this.relative(flex).x(1, offset);
    }

    /* Post resizers convenience methods
     * TODO: remove child resizers when switching to another post method */

    public RowResizer row(int margin)
    {
        if (this.post instanceof RowResizer)
        {
            return (RowResizer) this.post;
        }

        return RowResizer.apply(this.parent, margin);
    }

    public ColumnResizer column(int margin)
    {
        if (this.post instanceof ColumnResizer)
        {
            return (ColumnResizer) this.post;
        }

        return ColumnResizer.apply(this.parent, margin);
    }

    public GridResizer grid(int margin)
    {
        if (this.post instanceof GridResizer)
        {
            return (GridResizer) this.post;
        }

        return GridResizer.apply(this.parent, margin);
    }

    public BoundsResizer bounds(GuiElement target, int margin)
    {
        if (this.post instanceof BoundsResizer)
        {
            return (BoundsResizer) this.post;
        }

        return BoundsResizer.apply(this.parent, target, margin);
    }

    /* Hierarchy */

    /**
     * This method assigns the element.area as the relative target.
     * @param element {@link GuiElement} to which this is relative to.
     * @return this
     */
    public Flex relative(GuiElement element)
    {
        this.relative = element.area;

        return this;
    }

   public Flex relative(IResizer relative)
    {
        this.relative = relative;

        return this;
    }

    public Flex post(IResizer post)
    {
        this.post = post;

        return this;
    }

    /* IResizer implementation */

    @Override
    public void preApply(Area area)
    {}

    @Override
    public void apply(Area area)
    {
        if (this.post != null)
        {
            this.post.preApply(area);
        }

        area.w = this.getW();
        area.h = this.getH();
        area.x = this.getX();
        area.y = this.getY();

        if (this.post != null)
        {
            this.post.apply(area);
        }
    }

    @Override
    public void postApply(Area area)
    {
        if (this.post != null)
        {
            this.post.postApply(area);
        }
    }

    @Override
    public void add(GuiElement parent, GuiElement child)
    {
        if (this.post != null)
        {
            this.post.add(parent, child);
        }
    }

    @Override
    public void remove(GuiElement parent, GuiElement child)
    {
        if (this.post != null)
        {
            this.post.remove(parent, child);
        }
    }

    public int getX()
    {
        int value = (int) this.x.getValue();

        if (this.relative != null)
        {
            value += this.relative.getX();

            if (this.x.unit == Measure.RELATIVE)
            {
                value = this.relative.getX() + (int) (this.relative.getW() * this.x.getValue());
            }
        }

        value += this.x.offset;

        if (this.x.anchor != 0)
        {
            value -= this.x.anchor * this.getW();
        }

        return value;
    }

    public int getY()
    {
        int value = (int) this.y.getValue();

        if (this.relative != null)
        {
            value += this.relative.getY();

            if (this.y.unit == Measure.RELATIVE)
            {
                value = this.relative.getY() + (int) (this.relative.getH() * this.y.getValue());
            }
        }

        value += this.y.offset;

        if (this.y.anchor != 0)
        {
            value -= this.y.anchor * this.getH();
        }

        return value;
    }

    public int getW()
    {
        if (this.w.target != null)
        {
            int w = this.w.targetAnchor == 0 ? 0 : (int) (this.w.target.getW() * this.w.targetAnchor);

            return this.w.normalize((this.w.target.getX() + w) - this.getX() + this.w.offset);
        }

        int value = this.post == null ? 0 : this.post.getW();

        if (value != 0)
        {
            return value;
        }

        value = (int) this.w.getValue();

        if (this.relative != null && this.w.unit == Measure.RELATIVE)
        {
            value = (int) (this.relative.getW() * this.w.getValue());
        }

        value = value + this.w.offset;

        if (this.w.max > 0)
        {
            value = Math.min(value, this.w.max);
        }

        return value;
    }

    public int getH()
    {
        if (this.h.target != null)
        {
            int h = this.h.targetAnchor == 0 ? 0 : (int) (this.h.target.getH() * this.h.targetAnchor);

            return this.h.normalize((this.h.target.getY() + h) - this.getY() + this.h.offset);
        }

        int value = this.post == null ? 0 : this.post.getH();

        if (value != 0)
        {
            return value;
        }

        value = (int) this.h.getValue();

        if (this.relative != null && this.h.unit == Measure.RELATIVE)
        {
            value = (int) (this.relative.getH() * this.h.getValue());
        }

        value = value + this.h.offset;

        if (this.h.max > 0)
        {
            value = Math.min(value, this.h.max);
        }

        return value;
    }

    /**
     * Unit class
     */
    public static class Unit
    {
        private float value;
        private Supplier<Float> valueConsumer;
        public int offset;
        public int max;
        public float anchor;
        public Measure unit = Measure.PIXELS;
        public IResizer target;
        public float targetAnchor;

        public void set(Supplier<Float> value, Measure unit)
        {
            this.set(value, unit, 0);
        }

        public void set(Supplier<Float> value, Measure unit, int offset)
        {
            this.valueConsumer = value;
            this.unit = unit;
            this.offset = offset;

            /* Reset the value and target */
            this.value = 0;
            this.target = null;
            this.targetAnchor = 0;
        }

        public void set(float value, Measure unit)
        {
            this.set(value, unit, 0);
        }

        public void set(float value, Measure unit, int offset)
        {
            this.value = value;
            this.unit = unit;
            this.offset = offset;

            /* Reset target */
            this.target = null;
            this.targetAnchor = 0;
        }

        public float getValue()
        {
            return this.valueConsumer == null ? this.value : this.valueConsumer.get();
        }

        public int normalize(int value)
        {
            return this.max > 0 ? Math.min(value, this.max) : value;
        }
    }

    /**
     * Unit measurement for sizer class. This determines logic for 
     * calculating units.
     * 
     * {@link Measure#PIXELS} are absolute. Meanwhile 
     * {@link Measure#RELATIVE} are percentage (or rather a scalar 
     * between 0 and 1 equaling to 0% to 100%). 
     */
    public enum Measure
    {
        PIXELS, RELATIVE
    }
}

==================================================

--- Файл №112 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\IParentResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

import mchorse.mclib.client.gui.utils.Area;

public interface IParentResizer
{
    public void apply(Area area, IResizer resizer, ChildResizer child);
}


==================================================

--- Файл №113 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\IResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public interface IResizer
{
    public void preApply(Area area);

    public void apply(Area area);

    public void postApply(Area area);

    @SideOnly(Side.CLIENT)
    public void add(GuiElement parent, GuiElement child);

    @SideOnly(Side.CLIENT)
    public void remove(GuiElement parent, GuiElement child);

    public int getX();

    public int getY();

    public int getW();

    public int getH();
}

==================================================

--- Файл №114 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\Margin.java
--------------------
package mchorse.mclib.client.gui.utils.resizers;

public class Margin
{
    public int left;
    public int top;
    public int right;
    public int bottom;

    public Margin all(int all)
    {
        return this.all(all, all);
    }

    public Margin all(int horizontal, int vertical)
    {
        return this.all(horizontal, vertical, horizontal, vertical);
    }

    public Margin all(int left, int top, int right, int bottom)
    {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;

        return this;
    }

    public Margin left(int left)
    {
        this.left = left;

        return this;
    }

    public Margin top(int top)
    {
        this.top = top;

        return this;
    }

    public Margin right(int right)
    {
        this.right = right;

        return this;
    }

    public Margin bottom(int bottom)
    {
        this.bottom = bottom;

        return this;
    }

    public int vertical()
    {
        return this.top + this.bottom;
    }

    public int horizontal()
    {
        return this.left + this.right;
    }
}

==================================================

--- Файл №115 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\constraint\BoundsResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers.constraint;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiViewportStack;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.resizers.DecoratedResizer;
import mchorse.mclib.client.gui.utils.resizers.IResizer;
import mchorse.mclib.utils.MathUtils;

/**
 * Bounds resizer
 *
 * This resizer class allows to keep the element within the bounds of
 * current viewport
 */
public class BoundsResizer extends DecoratedResizer
{
    public GuiElement target;
    public int padding;

    private GuiViewportStack viewport = new GuiViewportStack();

    public static BoundsResizer apply(GuiElement element, GuiElement target, int padding)
    {
        BoundsResizer resizer = new BoundsResizer(element.resizer(), target, padding);

        element.flex().post(resizer);

        return resizer;
    }

    protected BoundsResizer(IResizer resizer, GuiElement target, int padding)
    {
        super(resizer);

        this.target = target;
        this.padding = padding;
    }

    @Override
    public void apply(Area area)
    {
        this.viewport.applyFromElement(this.target);

        Area viewport = this.viewport.getViewport();

        area.x = MathUtils.clamp(area.x, this.viewport.globalX(viewport.x) + this.padding, this.viewport.globalX(viewport.ex()) - area.w - this.padding);
        area.y = MathUtils.clamp(area.y, this.viewport.globalY(viewport.y) + this.padding, this.viewport.globalY(viewport.ey()) - area.h - this.padding);

        this.viewport.reset();
    }

    @Override
    public int getX()
    {
        return 0;
    }

    @Override
    public int getY()
    {
        return 0;
    }

    @Override
    public int getW()
    {
        return 0;
    }

    @Override
    public int getH()
    {
        return 0;
    }
}

==================================================

--- Файл №116 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\layout\ColumnResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers.layout;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.ScrollArea;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import mchorse.mclib.client.gui.utils.resizers.AutomaticResizer;
import mchorse.mclib.client.gui.utils.resizers.ChildResizer;
import mchorse.mclib.client.gui.utils.resizers.Flex;
import mchorse.mclib.client.gui.utils.resizers.IResizer;
import mchorse.mclib.client.gui.utils.resizers.Margin;

public class ColumnResizer extends AutomaticResizer
{
    private int x;
    private int y;
    private int w;

    /**
     * Default width
     */
    private int width;

    /**
     * Keeps on adding elements vertically without shifting them into
     * the next row and resize the height of the element
     */
    private boolean vertical;

    /**
     * Stretch column to the full width of the parent element
     */
    private boolean stretch;

    /**
     * Scroll mode, this will automatically calculate the scroll area
     */
    private boolean scroll;

    /**
     * Place elements after it reached the bottom on the left, instead of the right
     */
    private boolean flip;

    public static ColumnResizer apply(GuiElement element, int margin)
    {
        ColumnResizer resizer = new ColumnResizer(element, margin);

        element.flex().post(resizer);

        return resizer;
    }

    protected ColumnResizer(GuiElement element, int margin)
    {
        super(element, margin);
    }

    public ColumnResizer width(int width)
    {
        this.width = width;

        return this;
    }

    public ColumnResizer vertical()
    {
        this.vertical = true;

        return this;
    }

    public ColumnResizer stretch()
    {
        this.stretch = true;

        return this;
    }

    public ColumnResizer scroll()
    {
        this.scroll = true;

        return this;
    }

    public ColumnResizer flip()
    {
        this.flip = true;

        return this;
    }

    @Override
    public void apply(Area area)
    {
        this.x = 0;
        this.y = 0;
        this.w = 0;
    }

    @Override
    public void apply(Area area, IResizer resizer, ChildResizer child)
    {
        Margin margin = child.element.margin;
        int w = resizer == null ? this.width : resizer.getW();
        int h = resizer == null ? this.height : resizer.getH();

        if (w == 0)
        {
            w = this.width;
        }

        if (h == 0)
        {
            h = this.height;
        }

        if (this.stretch)
        {
            w = this.parent.area.w - this.padding * 2;
        }

        int marginTop = margin.top;

        if (!this.vertical && this.y + h + marginTop > this.parent.area.h - this.padding * 2)
        {
            this.x += (this.w + this.padding) * (this.flip ? -1 : 1);
            this.y = this.w = 0;

            marginTop = 0;
        }

        int x = this.parent.area.x + this.x + this.padding + margin.left;
        int y = this.parent.area.y + this.y + this.padding + marginTop;

        area.set(x, y, w, h);

        this.w = Math.max(this.w, w + margin.horizontal());
        this.y += h + this.margin + marginTop + margin.bottom;
    }

    @Override
    public void postApply(Area area)
    {
        if (this.scroll && this.parent.area instanceof ScrollArea)
        {
            ScrollArea scroll = (ScrollArea) this.parent.area;

            if (this.vertical && scroll.direction == ScrollDirection.VERTICAL)
            {
                scroll.scrollSize = this.y - this.margin + this.padding * 2;
            }
            else if (!this.vertical && scroll.direction == ScrollDirection.HORIZONTAL)
            {
                scroll.scrollSize = this.x + this.w + this.padding * 2;
            }

            scroll.clamp();
        }
    }

    @Override
    public int getH()
    {
        if (this.vertical && !this.scroll)
        {
            int y = this.padding * 2;

            for (ChildResizer child : this.getResizers())
            {
                int h = child.resizer == null ? 0 : child.resizer.getH();

                y += (h == 0 ? this.height : h) + this.margin + child.element.margin.vertical();
            }

            return y - this.margin;
        }

        return super.getH();
    }
}

==================================================

--- Файл №117 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\layout\GridResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers.layout;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.resizers.AutomaticResizer;
import mchorse.mclib.client.gui.utils.resizers.ChildResizer;
import mchorse.mclib.client.gui.utils.resizers.IResizer;

public class GridResizer extends AutomaticResizer
{
    private int i;
    private int x;
    private int y;
    private int h;

    /**
     * How many elements in a row
     */
    private int items = 2;

    /**
     * If above zero, what is the width of every cell should be,
     * instead of items per row
     */
    private int width = 0;

    /**
     * Whether this resizes changes the bounds of the area
     */
    private boolean resizes = true;

    public static GridResizer apply(GuiElement element, int margin)
    {
        GridResizer resizer = new GridResizer(element, margin);

        element.flex().post(resizer);

        return resizer;
    }

    protected GridResizer(GuiElement parent, int margin)
    {
        super(parent, margin);
    }

    public GridResizer resizes(boolean resizes)
    {
        this.resizes = resizes;

        return this;
    }

    public GridResizer items(int items)
    {
        this.items = items;

        return this;
    }

    /**
     * If you use this feature, make sure to resize the elements twice, as
     * the it needs parent's width, and it's not available on the first
     * layout resizing pass
     *
     * TODO: maybe fix it?
     */
    public GridResizer width(int width)
    {
        this.width = width;

        return this;
    }

    @Override
    public void apply(Area area)
    {
        this.i = this.x = this.y = this.h = 0;
    }

    @Override
    public void apply(Area area, IResizer resizer, ChildResizer child)
    {
        int w;
        int h;
        int x;
        int y;

        if (this.width > 0)
        {
            if (this.x + this.width > this.parent.area.w - this.padding * 2)
            {
                this.y += this.h + this.margin;
                this.h = 0;
                this.x = 0;
            }

            w = this.width;
            h = resizer == null ? 0 : resizer.getH();
            x = this.parent.area.x + this.padding + this.x;
            y = this.parent.area.y + this.padding + this.y;

            if (h <= 0)
            {
                h = this.height;
            }

            if (h <= 0)
            {
                h = w;
            }

            this.h = Math.max(this.h, h);

            area.set(x, y, w, h);

            this.x += this.width + this.margin;
        }
        else
        {
            if (this.i != 0 && this.i % this.items == 0)
            {
                this.y += this.h + this.margin;
                this.h = 0;
                this.i = 0;
            }

            w = (this.parent.area.w - this.padding * 2 - this.margin * (this.items - 1)) / this.items;
            h = resizer == null ? 0 : resizer.getH();
            x = this.parent.area.x + this.padding + (w + this.margin) * this.i;
            y = this.parent.area.y + this.padding + this.y;

            if (h <= 0)
            {
                h = this.height;
            }

            if (h <= 0)
            {
                h = w;
            }

            this.h = Math.max(this.h, h);
            this.i ++;

            area.set(x, y, w, h);
        }
    }

    @Override
    public int getH()
    {
        if (this.resizes)
        {
            int i = 0;
            int x = 0;
            int y = 0;
            int maxH = 0;
            int width = this.parent.area.w;

            if (this.width > 0)
            {
                for (ChildResizer child : this.getResizers())
                {
                    if (x + this.width > width - this.padding * 2)
                    {
                        y += maxH + this.margin;
                        maxH = 0;
                        x = 0;
                    }

                    int w = this.width;
                    int h = child.resizer == null ? 0 : child.resizer.getH();

                    if (h <= 0)
                    {
                        h = this.height;
                    }

                    if (h <= 0)
                    {
                        h = w;
                    }

                    maxH = Math.max(maxH, h);
                    x += this.width + this.margin;
                }
            }
            else
            {
                for (ChildResizer child : this.getResizers())
                {
                    if (i != 0 && i % this.items == 0)
                    {
                        y += maxH + this.margin;
                        maxH = 0;
                        i = 0;
                    }

                    int w = (width - this.padding * 2 - this.margin * (this.items - 1)) / this.items;
                    int h = child.resizer == null ? 0 : child.resizer.getH();

                    if (h <= 0)
                    {
                        h = this.height;
                    }

                    if (h <= 0)
                    {
                        h = w;
                    }

                    maxH = Math.max(maxH, h);

                    i++;
                }
            }

            return y + maxH + this.padding * 2;
        }

        return super.getH();
    }
}

==================================================

--- Файл №118 ---
Путь: main\java\mchorse\mclib\client\gui\utils\resizers\layout\RowResizer.java
--------------------
package mchorse.mclib.client.gui.utils.resizers.layout;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.utils.Area;
import mchorse.mclib.client.gui.utils.resizers.AutomaticResizer;
import mchorse.mclib.client.gui.utils.resizers.ChildResizer;
import mchorse.mclib.client.gui.utils.resizers.IResizer;

import java.util.List;

public class RowResizer extends AutomaticResizer
{
    private int i;
    private int x;
    private int w;
    private int count;

    /**
     * Preferred element to use in the row for the width adjustments caused by
     * integer arithmetics, -1 = to the size() / 2
     */
    private int preferred = -1;

    /**
     * Default width for row elements if not specified by resizer
     */
    private int width;

    /**
     * Whether the area should be resized according to the sum or row elements
     */
    private boolean resize;

    /**
     * Whether the elements would be placed from right to left
     */
    private boolean reverse;

    public static RowResizer apply(GuiElement element, int margin)
    {
        RowResizer resizer = new RowResizer(element, margin);

        element.flex().post(resizer);

        return resizer;
    }

    protected RowResizer(GuiElement parent, int margin)
    {
        super(parent, margin);
    }

    public RowResizer preferred(int index)
    {
        this.preferred = i;

        return this;
    }

    public RowResizer width(int width)
    {
        this.width = width;

        return this;
    }

    public RowResizer resize()
    {
        this.resize = true;

        return this;
    }

    public RowResizer reverse()
    {
        this.reverse = true;

        return this;
    }

    @Override
    public void apply(Area area)
    {
        List<ChildResizer> resizers = this.getResizers();

        this.i = this.x = this.w = 0;
        this.count = resizers.size();

        for (ChildResizer resizer : resizers)
        {
            int w = Math.max(resizer.resizer == null ? 0 : resizer.resizer.getW(), 0);

            if (w > 0)
            {
                this.w += w;
                this.count --;
            }
        }
    }

    @Override
    public void apply(Area area, IResizer resizer, ChildResizer child)
    {
        List<ChildResizer> resizers = this.getResizers();
        int c = resizers.size();
        int original = this.parent.area.w - this.padding * 2 - this.margin * (c - 1);
        int w = this.count > 0 ? (original - this.w) / this.count : 0;
        int x = this.parent.area.x + this.padding + this.x + child.element.margin.left;

        /* If it's reverse, start adding from the right side */
        if (this.reverse)
        {
            x = this.parent.area.ex() - this.padding - this.x - child.element.margin.right;
        }

        /* If resizer specifies its custom width, use that one instead */
        int cw = resizer == null ? 0 : resizer.getW();
        int ch = resizer == null ? this.height : resizer.getH();

        if (this.width > 0)
        {
            cw = this.width;
        }

        cw = cw > 0 ? cw : w;

        /* Readjust the middle element width to balance out int imprecision */
        int preferred = this.preferred == -1 ? c / 2 : this.preferred;

        if (this.i == preferred && !this.resize && this.width <= 0)
        {
            int diff = original - this.w - w * this.count;

            if (diff > 0)
            {
                cw += diff;
            }
        }

        /* Subtract the width from the X position */
        if (this.reverse)
        {
            x -= cw;
        }

        area.set(x, this.parent.area.y + this.padding + child.element.margin.top, cw, ch > 0 ? ch : this.parent.area.h - this.padding * 2);

        this.x += cw + this.margin + child.element.margin.horizontal();
        this.i ++;
    }

    @Override
    public int getW()
    {
        if (this.resize)
        {
            List<ChildResizer> resizers = this.getResizers();
            int w = resizers.isEmpty() ? 0 : -this.margin;

            for (ChildResizer resizer : resizers)
            {
                int cw = resizer.resizer == null ? 0 : resizer.resizer.getW();

                if (cw == 0 && this.width > 0)
                {
                    cw = this.width;
                }

                w += Math.max(cw, 0) + this.margin + resizer.element.margin.horizontal();
            }

            return w + this.padding * 2;
        }

        return 0;
    }

    @Override
    public int getH()
    {
        List<ChildResizer> resizers = this.getResizers();
        int h = 0;

        for (ChildResizer child : resizers)
        {
            h = Math.max(h, child.resizer == null ? 0 : child.resizer.getH() + child.element.margin.vertical());
        }

        if (h == 0)
        {
            h = this.height;
        }

        return h + this.padding * 2;
    }
}

==================================================

--- Файл №119 ---
Путь: main\java\mchorse\mclib\client\render\RenderLightmap.java
--------------------
package mchorse.mclib.client.render;

import net.minecraft.client.Minecraft;
import net.minecraft.client.model.ModelBase;
import net.minecraft.client.renderer.entity.RenderLivingBase;
import net.minecraft.client.renderer.entity.RenderManager;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Render brightness
 * 
 * This class is a workaround class which allows using lightmap methods 
 * without having to resort to straight copy-pasting the code.
 */
@SideOnly(Side.CLIENT)
public class RenderLightmap extends RenderLivingBase<EntityLivingBase>
{
    /**
     * Private instance 
     */
    private static RenderLightmap instance;

    public static RenderLightmap getInstance()
    {
        if (instance == null)
        {
            instance = new RenderLightmap(Minecraft.getMinecraft().getRenderManager(), null, 0);
        }

        return instance;
    }

    public static boolean canRenderNamePlate(EntityLivingBase entity)
    {
        return getInstance().canRenderName(entity);
    }

    public static boolean set(EntityLivingBase entity, float partialTicks)
    {
        return getInstance().setBrightness(entity, partialTicks, true);
    }

    public static void unset()
    {
        getInstance().unsetBrightness();
    }

    public RenderLightmap(RenderManager renderManagerIn, ModelBase modelBaseIn, float shadowSizeIn)
    {
        super(renderManagerIn, modelBaseIn, shadowSizeIn);
    }

    @Override
    protected int getColorMultiplier(EntityLivingBase entitylivingbaseIn, float lightBrightness, float partialTickTime)
    {
        return 0;
    }

    @Override
    protected ResourceLocation getEntityTexture(EntityLivingBase entity)
    {
        return null;
    }
}

==================================================

--- Файл №120 ---
Путь: main\java\mchorse\mclib\client\render\VertexBuilder.java
--------------------
package mchorse.mclib.client.render;

import java.lang.reflect.Field;
import java.nio.ByteBuffer;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import javax.vecmath.Point2f;
import javax.vecmath.Point3f;
import javax.vecmath.Vector2f;
import javax.vecmath.Vector3f;
import javax.vecmath.Vector4f;

import org.lwjgl.opengl.GL11;

import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.vertex.VertexFormat;
import net.minecraft.client.renderer.vertex.VertexFormatElement;
import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumType;
import net.minecraft.client.renderer.vertex.VertexFormatElement.EnumUsage;

/**
 * Create a vertex format compatible with Optifine shaders.
 * 
 * Of course it can also be used for vanilla.
 */
public class VertexBuilder
{
    public static final VertexFormat[] cache = new VertexFormat[4];

    /* location */
    public static int entityAttrib = -1;
    public static int midTexCoordAttrib = -1;
    public static int tangentAttrib = -1;

    /* Prepare for future */
    public static int velocityAttrib = -1;
    public static int midBlockAttrib = -1;

    static
    {
        try
        {
            Class<?> clazz = Class.forName("net.optifine.shaders.Shaders");

            Field fieldEntity = clazz.getField("entityAttrib");
            Field fieldMidTexCoord = clazz.getField("midTexCoordAttrib");
            Field fieldTangent = clazz.getField("tangentAttrib");

            entityAttrib = fieldEntity.getInt(null);
            midTexCoordAttrib = fieldMidTexCoord.getInt(null);
            tangentAttrib = fieldTangent.getInt(null);

            Field fieldVelocity = clazz.getField("velocityAttrib");
            Field fieldMidBlock = clazz.getField("midBlockAttrib");

            velocityAttrib = fieldVelocity.getInt(null);
            midBlockAttrib = fieldMidBlock.getInt(null);
        }
        catch (ClassNotFoundException | NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e)
        {
        }
    }

    public static VertexFormat getFormat(boolean color, boolean tex, boolean lightmap, boolean normal)
    {
        int index = (color ? 1 : 0) | (lightmap ? 1 << 1 : 0);

        if (cache[index] == null)
        {
            VertexFormat vertexformat = new VertexFormat();

            vertexformat.addElement(new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.POSITION, 3));
            vertexformat.addElement(new VertexFormatElement(0, EnumType.UBYTE, color ? EnumUsage.COLOR : EnumUsage.PADDING, 4));
            vertexformat.addElement(new VertexFormatElement(0, EnumType.FLOAT, tex ? EnumUsage.UV : EnumUsage.PADDING, 2));
            vertexformat.addElement(new VertexFormatElement(lightmap ? 1 : 0, EnumType.SHORT, lightmap ? EnumUsage.UV : EnumUsage.PADDING, 2));
            vertexformat.addElement(new VertexFormatElement(0, EnumType.BYTE, normal ? EnumUsage.NORMAL : EnumUsage.PADDING, 3));
            vertexformat.addElement(new VertexFormatElement(0, EnumType.BYTE, EnumUsage.PADDING, 1));

            if (entityAttrib != -1)
            {
                if (velocityAttrib != -1)
                {
                    /* attribute vec3 at_midBlock; */
                    vertexformat.addElement(new VertexFormatElement(0, EnumType.BYTE, EnumUsage.PADDING, 4));
                }

                /* attribute vec2 mc_midTexCoord; */
                vertexformat.addElement(new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.PADDING, 2));

                /* attribute vec4 at_tangent; */
                vertexformat.addElement(new VertexFormatElement(0, EnumType.SHORT, EnumUsage.PADDING, 4));

                /* attribute vec3 mc_Entity; */
                vertexformat.addElement(new VertexFormatElement(0, EnumType.SHORT, EnumUsage.PADDING, 4));

                if (velocityAttrib != -1)
                {
                    /* attribute vec3 at_velocity; */
                    vertexformat.addElement(new VertexFormatElement(0, EnumType.FLOAT, EnumUsage.PADDING, 3));
                }
            }

            cache[index] = vertexformat;
        }

        return cache[index];
    }

    /**
     * attribute vec3 mc_Entity;<br>
     * 
     * By default it is used for blocks.<br>
     * Please call this method after endVertex for each <b>vertex</b>.
     * 
     * @param x block id
     * @param y render type {@link net.minecraft.util.EnumBlockRenderType}
     * @param z metadata
     */
    public static void fillEntity(BufferBuilder builder, int x, int y, int z)
    {
        if (builder.getVertexFormat().getNextOffset() != (velocityAttrib == -1 ? 56 : 72))
        {
            return;
        }

        int baseIndex = (builder.getVertexCount() - 1) * builder.getVertexFormat().getIntegerSize();

        if (baseIndex < 0)
        {
            return;
        }

        ByteBuffer byteBuf = builder.getByteBuffer();

        int pos = byteBuf.position();
        byteBuf.position(0);

        int offset = velocityAttrib == -1 ? 12 : 13;
        IntBuffer buffer = builder.getByteBuffer().asIntBuffer();

        int i = (y & 0xFFFF) << 16 | x & 0xFFFF;
        int j = z & 0xFFFF;

        buffer.put(baseIndex + offset, i);
        buffer.put(baseIndex + offset + 1, j);
    }

    /**
     * attribute vec2 mc_midTexCoord;<br>
     * 
     * Please call this method after endVertex for each <b>vertex</b>.
     */
    public static void fillMidTexCoord(BufferBuilder builder, float u, float v)
    {
        if (builder.getVertexFormat().getNextOffset() != (velocityAttrib == -1 ? 56 : 72))
        {
            return;
        }

        int baseIndex = (builder.getVertexCount() - 1) * builder.getVertexFormat().getIntegerSize();

        if (baseIndex < 0)
        {
            return;
        }

        ByteBuffer byteBuf = builder.getByteBuffer();

        int pos = byteBuf.position();
        byteBuf.position(0);

        int offset = velocityAttrib == -1 ? 8 : 9;
        FloatBuffer buffer = builder.getByteBuffer().asFloatBuffer();

        byteBuf.position(pos);

        buffer.put(baseIndex + offset, u);
        buffer.put(baseIndex + offset + 1, v);
    }

    /*
     * Optifine will recalculate the normals for GL11.QUADS when calling endVertex or something similar
     * 
     * So you can reset it with this method
     */
    public static void resetNormal(BufferBuilder builder, float x, float y, float z)
    {
        if (builder.getDrawMode() != GL11.GL_QUADS || !builder.getVertexFormat().hasNormal() || builder.getVertexFormat().getNextOffset() != (velocityAttrib == -1 ? 56 : 72))
        {
            return;
        }

        int vertexCount = builder.getDrawMode() == GL11.GL_QUADS ? 4 : 3;

        if (builder.getVertexCount() % vertexCount != 0)
        {
            return;
        }

        int vertexSize = builder.getVertexFormat().getNextOffset();
        int normalOffset = builder.getVertexFormat().getNormalOffset();
        int baseIndex = (builder.getVertexCount() - vertexCount) * vertexSize;

        ByteBuffer byteBuf = builder.getByteBuffer();

        int pos = byteBuf.position();
        byteBuf.position(0);

        float lenSquared = x * x + y * y + z * z;

        if (lenSquared > 0.0001F)
        {
            x /= Math.sqrt(lenSquared);
            y /= Math.sqrt(lenSquared);
            z /= Math.sqrt(lenSquared);
        }

        for (int i = 0; i < vertexCount; i++)
        {
            byteBuf.put(baseIndex + vertexSize * i + normalOffset + 0, (byte) ((int) (x * 0x7F) & 0xFF));
            byteBuf.put(baseIndex + vertexSize * i + normalOffset + 1, (byte) ((int) (y * 0x7F) & 0xFF));
            byteBuf.put(baseIndex + vertexSize * i + normalOffset + 2, (byte) ((int) (z * 0x7F) & 0xFF));
        }

        byteBuf.position(pos);
    }

    /**
     * attribute vec4 at_tangent;<br>
     * 
     * Please call this method after endVertex for each <b>face (not vertex)</b>.
     * 
     * @param calcNormal calculate normal vector
     */
    public static void calcTangent(BufferBuilder builder, boolean calcNormal)
    {
        if (builder.getDrawMode() != GL11.GL_QUADS && builder.getDrawMode() != GL11.GL_TRIANGLES || !builder.getVertexFormat().hasNormal() || builder.getVertexFormat().getNextOffset() != (velocityAttrib == -1 ? 56 : 72))
        {
            return;
        }

        int vertexCount = builder.getDrawMode() == GL11.GL_QUADS ? 4 : 3;

        if (builder.getVertexCount() % vertexCount != 0)
        {
            return;
        }

        int vertexSize = builder.getVertexFormat().getIntegerSize();
        int normalOffset = builder.getVertexFormat().getNormalOffset() / 4;
        int baseIndex = (builder.getVertexCount() - vertexCount) * vertexSize;

        ByteBuffer byteBuf = builder.getByteBuffer();

        int pos = byteBuf.position();
        byteBuf.position(0);

        IntBuffer intBuf = builder.getByteBuffer().asIntBuffer();
        FloatBuffer floatBuf = builder.getByteBuffer().asFloatBuffer();

        byteBuf.position(pos);

        Point3f v0 = new Point3f();
        Point3f v1 = new Point3f();
        Point3f v2 = new Point3f();

        v0.x = floatBuf.get(baseIndex + vertexSize * 0 + 0);
        v0.y = floatBuf.get(baseIndex + vertexSize * 0 + 1);
        v0.z = floatBuf.get(baseIndex + vertexSize * 0 + 2);

        v1.x = floatBuf.get(baseIndex + vertexSize * 1 + 0);
        v1.y = floatBuf.get(baseIndex + vertexSize * 1 + 1);
        v1.z = floatBuf.get(baseIndex + vertexSize * 1 + 2);

        v2.x = floatBuf.get(baseIndex + vertexSize * 2 + 0);
        v2.y = floatBuf.get(baseIndex + vertexSize * 2 + 1);
        v2.z = floatBuf.get(baseIndex + vertexSize * 2 + 2);

        Vector3f e1 = new Vector3f();
        Vector3f e2 = new Vector3f();

        e1.sub(v1, v0);
        e2.sub(v2, v0);

        if (calcNormal)
        {
            Vector3f normal = new Vector3f();

            normal.cross(e1, e2);

            if (normal.lengthSquared() > 0.0001F)
            {
                normal.normalize();
            }
            else
            {
                normal.set(0, 0, 1);
            }

            int packedNormal = ((int) (normal.z * 0x7F) & 0xFF) << 16 | ((int) (normal.y * 0x7F) & 0xFF) << 8 | (int) (normal.x * 0x7F) & 0xFF;

            intBuf.put(baseIndex + vertexSize * 0 + normalOffset, packedNormal);
            intBuf.put(baseIndex + vertexSize * 1 + normalOffset, packedNormal);
            intBuf.put(baseIndex + vertexSize * 2 + normalOffset, packedNormal);
        }

        if (!builder.getVertexFormat().hasUvOffset(0))
        {
            return;
        }

        int uvOffset = builder.getVertexFormat().getUvOffsetById(0) / 4;
        int tangentOffset = velocityAttrib == -1 ? 10 : 11;

        Point2f uv0 = new Point2f();
        Point2f uv1 = new Point2f();
        Point2f uv2 = new Point2f();

        uv0.x = floatBuf.get(baseIndex + vertexSize * 0 + uvOffset + 0);
        uv0.y = floatBuf.get(baseIndex + vertexSize * 0 + uvOffset + 1);

        uv1.x = floatBuf.get(baseIndex + vertexSize * 1 + uvOffset + 0);
        uv1.y = floatBuf.get(baseIndex + vertexSize * 1 + uvOffset + 1);

        uv2.x = floatBuf.get(baseIndex + vertexSize * 2 + uvOffset + 0);
        uv2.y = floatBuf.get(baseIndex + vertexSize * 2 + uvOffset + 1);

        Vector2f duv1 = new Vector2f();
        Vector2f duv2 = new Vector2f();

        duv1.sub(uv1, uv0);
        duv2.sub(uv2, uv0);

        Vector3f tangent = new Vector3f();
        Vector3f binormal = new Vector3f();

        float scale = duv1.y * duv2.x - duv1.x * duv2.y;

        if (Math.abs(scale) <= 0.0001F)
        {
            scale = 1.0f;
        }

        tangent.scale(duv1.y, e2);
        tangent.scaleAdd(-duv2.y, e1, tangent);
        tangent.scale(1.0f / scale);

        binormal.scale(duv2.x, e1);
        binormal.scaleAdd(-duv1.x, e2, binormal);
        binormal.scale(1.0f / scale);

        if (tangent.lengthSquared() > 0.0001F)
        {
            tangent.normalize();
        }

        if (binormal.lengthSquared() > 0.0001F)
        {
            binormal.normalize();
        }

        int packedNormal = intBuf.get(baseIndex + vertexSize * 0 + normalOffset);
        Vector3f normal = new Vector3f();

        normal.x = (byte) packedNormal;
        normal.y = (byte) (packedNormal >> 8);
        normal.z = (byte) (packedNormal >> 16);

        if (normal.lengthSquared() <= 0.0001F)
        {
            normal.cross(e1, e2);
        }

        normal.normalize();

        Vector3f binormalCheck = new Vector3f();

        binormalCheck.cross(normal, tangent);

        float w = binormalCheck.dot(binormal) < 0 ? -1F : 1F;

        tangent.scaleAdd(-normal.dot(tangent), normal, tangent);

        if (tangent.lengthSquared() > 0.0001F)
        {
            tangent.normalize();
        }

        int p1 = ((int) (tangent.y * 0x7FFF) & 0xFFFF) << 16 | (int) (tangent.x * 0x7FFF) & 0xFFFF;
        int p2 = ((int) (w * 0x7FFF) & 0xFFFF) << 16 | (int) (tangent.z * 0x7FFF) & 0xFFFF;

        for (int i = 0; i < vertexCount; i++)
        {
            intBuf.put(baseIndex + vertexSize * i + tangentOffset + 0, p1);
            intBuf.put(baseIndex + vertexSize * i + tangentOffset + 1, p2);
        }
    }

    /**
     * Used for Emoticons
     */
    public static Vector4f calcTangent(Point3f[] vertices, Point2f[] uvs, Vector3f normal)
    {
        Point3f v0 = vertices[0];
        Point3f v1 = vertices[1];
        Point3f v2 = vertices[2];

        Vector3f e1 = new Vector3f();
        Vector3f e2 = new Vector3f();

        e1.sub(v1, v0);
        e2.sub(v2, v0);

        Point2f uv0 = uvs[0];
        Point2f uv1 = uvs[1];
        Point2f uv2 = uvs[2];

        Vector2f duv1 = new Vector2f();
        Vector2f duv2 = new Vector2f();

        duv1.sub(uv1, uv0);
        duv2.sub(uv2, uv0);

        Vector3f tangent = new Vector3f();
        Vector3f binormal = new Vector3f();

        float scale = duv1.y * duv2.x - duv1.x * duv2.y;

        if (Math.abs(scale) <= 0.0001F)
        {
            scale = 1.0f;
        }

        tangent.scale(duv1.y, e2);
        tangent.scaleAdd(-duv2.y, e1, tangent);
        tangent.scale(1.0f / scale);

        binormal.scale(duv2.x, e1);
        binormal.scaleAdd(-duv1.x, e2, binormal);
        binormal.scale(1.0f / scale);

        if (tangent.lengthSquared() > 0.0001F)
        {
            tangent.normalize();
        }

        if (binormal.lengthSquared() > 0.0001F)
        {
            binormal.normalize();
        }

        if (normal.lengthSquared() <= 0.0001F)
        {
            normal.cross(e1, e2);
        }

        normal.normalize();

        Vector3f binormalCheck = new Vector3f();

        binormalCheck.cross(normal, tangent);

        float w = binormalCheck.dot(binormal) < 0 ? -1F : 1F;

        tangent.scaleAdd(-normal.dot(tangent), normal, tangent);

        if (tangent.lengthSquared() > 0.0001F)
        {
            tangent.normalize();
        }

        return new Vector4f(tangent.x, tangent.y, tangent.z, w);
    }

    /**
     * attribute vec3 at_velocity;<br>
     * 
     * Hope it could work in future.<br>
     * 
     * Please call this method after endVertex for each <b>vertex</b>.
     */
    public static void fillVelocity(BufferBuilder builder, float x, float y, float z)
    {
        if (velocityAttrib == -1 || builder.getVertexFormat().getNextOffset() != 72)
        {
            return;
        }

        int baseIndex = (builder.getVertexCount() - 1) * builder.getVertexFormat().getIntegerSize();

        if (baseIndex < 0)
        {
            return;
        }

        ByteBuffer byteBuf = builder.getByteBuffer();

        int pos = byteBuf.position();
        byteBuf.position(0);

        int offset = 15;
        FloatBuffer buffer = builder.getByteBuffer().asFloatBuffer();

        byteBuf.position(pos);

        buffer.put(baseIndex + offset, x);
        buffer.put(baseIndex + offset + 1, y);
        buffer.put(baseIndex + offset + 2, z);
    }

    /**
     * attribute vec3 at_velocity;<br>
     * 
     * Hope it could work in future.<br>
     * 
     * Please call this method after endVertex for each <b>vertex</b>.
     */
    public static void fillMidBlock(BufferBuilder builder, int x, int y, int z)
    {
        if (velocityAttrib == -1 || builder.getVertexFormat().getNextOffset() != 72)
        {
            return;
        }

        int baseIndex = (builder.getVertexCount() - 1) * builder.getVertexFormat().getIntegerSize();

        if (baseIndex < 0)
        {
            return;
        }

        ByteBuffer byteBuf = builder.getByteBuffer();

        int pos = byteBuf.position();
        byteBuf.position(0);

        int offset = 8;
        IntBuffer buffer = builder.getByteBuffer().asIntBuffer();

        byteBuf.position(pos);

        buffer.put(baseIndex + offset, x);
        buffer.put(baseIndex + offset + 1, y);
        buffer.put(baseIndex + offset + 2, z);
    }
}


==================================================

--- Файл №121 ---
Путь: main\java\mchorse\mclib\commands\CommandCheats.java
--------------------
package mchorse.mclib.commands;

import mchorse.mclib.McLib;
import mchorse.mclib.commands.utils.L10n;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;

import javax.annotation.Nullable;
import java.util.List;

public class CommandCheats extends McCommandBase
{
    @Override
    public L10n getL10n()
    {
        return McLib.l10n;
    }

    @Override
    public String getName()
    {
        return "cheats";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "mclib.commands.cheats";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}cheats {7}<enabled:true|false>{r}";
    }

    @Override
    public boolean checkPermission(MinecraftServer server, ICommandSender sender)
    {
        return true;
    }

    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        sender.getEntityWorld().getWorldInfo().setAllowCommands(CommandBase.parseBoolean(args[0]));
        server.saveAllWorlds(false);
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos targetPos)
    {
        if (args.length == 1)
        {
            return getListOfStringsMatchingLastWord(args, McCommandBase.BOOLEANS);
        }

        return super.getTabCompletions(server, sender, args, targetPos);
    }
}


==================================================

--- Файл №122 ---
Путь: main\java\mchorse\mclib\commands\CommandMcLib.java
--------------------
package mchorse.mclib.commands;

import mchorse.mclib.McLib;
import mchorse.mclib.commands.config.SubCommandConfig;
import mchorse.mclib.commands.utils.L10n;
import net.minecraft.command.ICommandSender;

public class CommandMcLib extends SubCommandBase
{
    public CommandMcLib()
    {
        this.add(new SubCommandConfig());
    }

    @Override
    public String getName()
    {
        return "mclib";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "mclib.commands.mclib.help";
    }

    @Override
    public String getSyntax()
    {
        return "";
    }

    @Override
    public L10n getL10n()
    {
        return McLib.l10n;
    }
}


==================================================

--- Файл №123 ---
Путь: main\java\mchorse\mclib\commands\McCommandBase.java
--------------------
package mchorse.mclib.commands;

import com.google.common.collect.ImmutableList;
import mchorse.mclib.commands.utils.L10n;
import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.util.text.TextFormatting;

import java.util.List;

/**
 * McHorse's base command class
 *
 * This command class is responsible for catching {@link CommandException}s and
 * output them as my error styled messages sent via {@link L10n}. This class
 * is also frees the check for required arguments (which is very often
 * redundant if for args.length).
 */
public abstract class McCommandBase extends CommandBase
{
    public static final List<String> BOOLEANS = ImmutableList.of("true", "false", "1", "0");

    public static String processSyntax(String str)
    {
        return str.replaceAll("\\{([\\w\\d_]+)\\}", "§$1");
    }

    public abstract L10n getL10n();

    public abstract String getSyntax();

    public String getProcessedSyntax()
    {
        return processSyntax(this.getSyntax());
    }

    public ITextComponent getUsageMessage(ICommandSender sender)
    {
        ITextComponent message = new TextComponentTranslation(this.getProcessedSyntax());

        message.getStyle().setColor(TextFormatting.WHITE);

        return message
            .appendSibling(new TextComponentString("\n\n"))
            .appendSibling(new TextComponentTranslation(this.getUsage(sender)));
    }

    /**
     * Get the count of arguments which are required
     */
    public int getRequiredArgs()
    {
        return 0;
    }

    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (args.length >= 1 && args[0].equals("-h"))
        {
            throw new WrongUsageException("mclib.commands.wrapper", this.getUsageMessage(sender));
        }

        if (args.length < this.getRequiredArgs())
        {
            throw new WrongUsageException("mclib.commands.wrapper", this.getUsageMessage(sender));
        }

        try
        {
            this.executeCommand(server, sender, args);
        }
        catch (CommandException e)
        {
            if (e.getMessage().startsWith("commands."))
            {
                throw e;
            }

            throw new CommandException("mclib.commands.wrapper", this.getL10n().error(e.getMessage(), e.getErrorObjects()));
        }
    }

    /**
     * Execute the command's task
     */
    public abstract void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException;
}

==================================================

--- Файл №124 ---
Путь: main\java\mchorse\mclib\commands\SubCommandBase.java
--------------------
package mchorse.mclib.commands;

import net.minecraft.command.CommandBase;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.command.WrongUsageException;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.util.text.TextFormatting;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Abstract sub-command base handler command
 *
 * This abstract command implements sub-commands system. By extending this
 * class, it allows to add sub-commands.
 */
public abstract class SubCommandBase extends McCommandBase
{
    /**
     * Sub-commands list, add your sub commands in this list.
     */
    protected Map<String, McCommandBase> subcommands = new LinkedHashMap<String, McCommandBase>();

    /**
     * Drop only the first argument
     */
    public static String[] dropFirstArgument(String[] input)
    {
        return dropFirstArguments(input, 1);
    }

    /**
     * Totally not copied from CommandHandler.
     */
    public static String[] dropFirstArguments(String[] input, int amount)
    {
        String[] astring = new String[input.length - amount];
        System.arraycopy(input, amount, astring, 0, input.length - amount);

        return astring;
    }

    /**
     * Add a sub-command to the sub-commands map
     */
    protected void add(McCommandBase subcommand)
    {
        this.subcommands.put(subcommand.getName(), subcommand);
    }

    @Override
    public String getSyntax()
    {
        return "";
    }

    @Override
    public ITextComponent getUsageMessage(ICommandSender sender)
    {
        ITextComponent message = new TextComponentTranslation(this.getUsage(sender));

        message.getStyle().setColor(TextFormatting.WHITE);
        message.appendSibling(new TextComponentString("\n\n"));

        int i = 0;
        int c = this.subcommands.size();

        for (McCommandBase command : this.subcommands.values())
        {
            String extra = i == c - 1 ? "" : "\n";

            message.appendSibling(new TextComponentString(command.getProcessedSyntax() + extra));

            i += 1;
        }

        return message;
    }

    /**
     * Delegate isUsernameIndex method to a subcommand
     */
    @Override
    public boolean isUsernameIndex(String[] args, int index)
    {
        McCommandBase command = this.subcommands.get(args.length >= 1 ? args[0] : "");

        if (command != null && command.isUsernameIndex(dropFirstArgument(args), index - 1))
        {
            return true;
        }

        return super.isUsernameIndex(args, index);
    }

    /**
     * Execute the command
     *
     * This method basically delegates the execution to the matched sub-command,
     * if the command was found, otherwise it shows usage message. */
    @Override
    public void execute(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        if (args.length < 1)
        {
            throw new WrongUsageException("mclib.commands.wrapper", this.getUsageMessage(sender));
        }

        McCommandBase command = this.subcommands.get(args[0]);

        if (command != null)
        {
            if (args.length >= 2 && args[1].equals("-h"))
            {
                throw new WrongUsageException("mclib.commands.wrapper", command.getUsageMessage(sender));
            }

            command.execute(server, sender, dropFirstArgument(args));
        }
        else
        {
            throw new WrongUsageException("mclib.commands.wrapper", this.getUsageMessage(sender));
        }
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {}

    /**
     * Get completions for this command or its sub-commands.
     *
     * This method is responsible for giving completions of this command (names
     * of sub-commands) or completions of sub-command.
     */
    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, BlockPos pos)
    {
        if (args.length == 0)
        {
            return super.getTabCompletions(server, sender, args, pos);
        }

        Collection<McCommandBase> commands = this.subcommands.values();

        if (args.length == 1)
        {
            List<String> options = new ArrayList<String>();

            for (CommandBase command : commands)
            {
                options.add(command.getName());
            }

            return getListOfStringsMatchingLastWord(args, options);
        }

        for (CommandBase command : commands)
        {
            if (command.getName().equals(args[0]))
            {
                return command.getTabCompletions(server, sender, dropFirstArgument(args), pos);
            }
        }

        return super.getTabCompletions(server, sender, args, pos);
    }
}

==================================================

--- Файл №125 ---
Путь: main\java\mchorse\mclib\commands\config\SubCommandConfig.java
--------------------
package mchorse.mclib.commands.config;

import mchorse.mclib.McLib;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.commands.utils.L10n;
import mchorse.mclib.config.values.Value;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;

public class SubCommandConfig extends SubCommandBase
{
    public static Value get(String id) throws CommandException
    {
        try
        {
            String[] splits = id.split("\\.");

            if (splits.length != 3)
            {
                throw new Exception("Identifier should have exactly 3 strings separated by a period!");
            }

            return McLib.proxy.configs.modules.get(splits[0]).values.get(splits[1]).getSubValue(splits[2]);
        }
        catch (Exception e)
        {
            throw new CommandException("config.invalid_id", id);
        }
    }

    public SubCommandConfig()
    {
        this.add(new SubCommandConfigPrint());
        this.add(new SubCommandConfigSet());
    }

    @Override
    public String getName()
    {
        return "config";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "mclib.commands.mclib.config.help";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}mclib {8}config{r}";
    }

    @Override
    public L10n getL10n()
    {
        return McLib.l10n;
    }
}


==================================================

--- Файл №126 ---
Путь: main\java\mchorse\mclib\commands\config\SubCommandConfigBase.java
--------------------
package mchorse.mclib.commands.config;

import mchorse.mclib.McLib;
import mchorse.mclib.commands.McCommandBase;
import mchorse.mclib.commands.utils.L10n;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.values.Value;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;
import net.minecraft.util.math.BlockPos;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.List;

public abstract class SubCommandConfigBase extends McCommandBase
{
    @Override
    public int getRequiredArgs()
    {
        return 1;
    }

    @Override
    public L10n getL10n()
    {
        return McLib.l10n;
    }

    @Override
    public List<String> getTabCompletions(MinecraftServer server, ICommandSender sender, String[] args, @Nullable BlockPos targetPos)
    {
        if (args.length == 1)
        {
            List<String> ids = new ArrayList<>();

            for (Config config : McLib.proxy.configs.modules.values())
            {
                for (Value category : config.values.values())
                {
                    for (Value value : category.getSubValues())
                    {
                        if (value.isClientSide())
                        {
                            continue;
                        }

                        ids.add(config.id + "." + category.id + "." + value.id);
                    }
                }
            }

            return getListOfStringsMatchingLastWord(args, ids);
        }

        return super.getTabCompletions(server, sender, args, targetPos);
    }
}


==================================================

--- Файл №127 ---
Путь: main\java\mchorse\mclib\commands\config\SubCommandConfigPrint.java
--------------------
package mchorse.mclib.commands.config;

import mchorse.mclib.config.values.Value;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

public class SubCommandConfigPrint extends SubCommandConfigBase
{
    @Override
    public String getName()
    {
        return "print";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "mclib.commands.mclib.config.print";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}mclib {8}config print{r} {7}<mod.category.option>{r}";
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Value value = SubCommandConfig.get(args[0]);

        if (!value.isClientSide())
        {
            this.getL10n().info(sender, "config.print", args[0], value.toString());
        }
        else
        {
            this.getL10n().info(sender, "config.client_side", args[0]);
        }
    }
}


==================================================

--- Файл №128 ---
Путь: main\java\mchorse\mclib\commands\config\SubCommandConfigSet.java
--------------------
package mchorse.mclib.commands.config;

import mchorse.mclib.McLib;
import mchorse.mclib.commands.SubCommandBase;
import mchorse.mclib.config.ConfigManager;
import mchorse.mclib.config.values.IServerValue;
import mchorse.mclib.config.values.Value;
import net.minecraft.command.CommandException;
import net.minecraft.command.ICommandSender;
import net.minecraft.server.MinecraftServer;

public class SubCommandConfigSet extends SubCommandConfigBase
{
    @Override
    public String getName()
    {
        return "set";
    }

    @Override
    public String getUsage(ICommandSender sender)
    {
        return "mclib.commands.mclib.config.set";
    }

    @Override
    public String getSyntax()
    {
        return "{l}{6}/{r}mclib {8}config set{r} {7}<mod.category.option> <value...>{r}";
    }

    @Override
    public int getRequiredArgs()
    {
        return 2;
    }

    @Override
    public void executeCommand(MinecraftServer server, ICommandSender sender, String[] args) throws CommandException
    {
        Value value = SubCommandConfig.get(args[0]);

        if (!value.isClientSide() && value instanceof IServerValue)
        {
            String command = String.join(" ", SubCommandBase.dropFirstArguments(args, 1));

            if (((IServerValue) value).parseFromCommand(command))
            {
                if (value.isSyncable())
                {
                    String mod = args[0].substring(0, args[0].indexOf("."));

                    ConfigManager.synchronizeConfig(McLib.proxy.configs.modules.get(mod).filterSyncable(), server);
                }

                this.getL10n().info(sender, "config.set", args[0], value.toString());
            }
            else
            {
                throw new CommandException("config.invalid_format", args[0], args[1]);
            }
        }
        else
        {
            this.getL10n().info(sender, "config.client_side", args[0]);
        }
    }
}


==================================================

--- Файл №129 ---
Путь: main\java\mchorse\mclib\commands\utils\L10n.java
--------------------
package mchorse.mclib.commands.utils;

import net.minecraft.command.ICommandSender;
import net.minecraft.util.text.ITextComponent;
import net.minecraft.util.text.TextComponentString;
import net.minecraft.util.text.TextComponentTranslation;
import net.minecraft.util.text.TextFormatting;

/**
 * Localization utils
 *
 * This class provides shortcuts for sending messages to players. Pretty tired
 * of typing a lot of characters with provided API.
 *
 * API should be clear, short and concise.
 */
public class L10n
{
    public static String ERROR_MARKER = "§4(§cX§4)§r ";
    public static String SUCCESS_MARKER = "§2(§aV§2)§r ";
    public static String INFO_MARKER = "§9(§bi§9)§r ";

    private final String id;

    public L10n(String id)
    {
        this.id = id;
    }

    /**
     * Send a translated message to player
     */
    public void send(ICommandSender sender, String key, Object... objects)
    {
        sender.sendMessage(new TextComponentTranslation(key, objects));
    }

    /**
     * Send a translated message to player
     */
    public void sendColored(ICommandSender sender, TextFormatting color, String key, Object... objects)
    {
        ITextComponent text = new TextComponentTranslation(key, objects);
        text.getStyle().setColor(color);

        sender.sendMessage(text);
    }

    /**
     * Send error message to the sender
     */
    public void error(ICommandSender sender, String key, Object... objects)
    {
        this.sendWithMarker(sender, ERROR_MARKER, this.id + ".error." + key, objects);
    }

    /**
     * Get error message
     */
    public ITextComponent error(String key, Object... objects)
    {
        return this.messageWithMarker(ERROR_MARKER, this.id + ".error." + key, objects);
    }

    /**
     * Send success message to the sender
     */
    public void success(ICommandSender sender, String key, Object... objects)
    {
        this.sendWithMarker(sender, SUCCESS_MARKER, this.id + ".success." + key, objects);
    }

    /**
     * Get success message
     */
    public ITextComponent success(String key, Object... objects)
    {
        return this.messageWithMarker(SUCCESS_MARKER, this.id + ".success." + key, objects);
    }

    /**
     * Send informing message to the sender
     */
    public void info(ICommandSender sender, String key, Object... objects)
    {
        this.sendWithMarker(sender, INFO_MARKER, this.id + ".info." + key, objects);
    }

    /**
     * Get informing message
     */
    public ITextComponent info(String key, Object... objects)
    {
        return  this.messageWithMarker(INFO_MARKER, this.id + ".info." + key, objects);
    }

    /**
     * Send a message with given marker
     */
    public void sendWithMarker(ICommandSender sender, String marker, String key, Object... objects)
    {
        sender.sendMessage(this.messageWithMarker(marker, key, objects));
    }

    public ITextComponent messageWithMarker(String marker, String key, Object... objects)
    {
        ITextComponent message = new TextComponentString(marker);
        ITextComponent string = new TextComponentTranslation(key, objects);

        string.getStyle().setColor(TextFormatting.GRAY);

        message.appendSibling(string);

        return message;
    }
}

==================================================

--- Файл №130 ---
Путь: main\java\mchorse\mclib\config\Config.java
--------------------
package mchorse.mclib.config;

import com.google.common.base.Predicates;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.json.ConfigParser;
import mchorse.mclib.config.values.Value;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketConfig;
import mchorse.mclib.utils.JsonUtils;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class Config implements IByteBufSerializable
{
    public final String id;
    public final File file;

    public final Map<String, Value> values = new LinkedHashMap<String, Value>();

    private boolean serverSide;

    public Config(String id, File file)
    {
        this.id = id;
        this.file = file;
    }

    public Config(String id)
    {
        this.id = id;
        this.file = null;
    }

    public Config serverSide()
    {
        this.serverSide = true;

        return this;
    }

    public boolean isServerSide()
    {
        return this.serverSide;
    }

    public boolean hasSyncable()
    {
        for (Value value : this.values.values())
        {
            if (value.hasSyncable())
            {
                return true;
            }
        }

        return false;
    }

    /* Translation string related methods */

    @SideOnly(Side.CLIENT)
    public String getTitleKey()
    {
        return this.id + ".config.title";
    }

    @SideOnly(Side.CLIENT)
    public String getCategoryTitleKey(Value value)
    {
        return this.id + ".config." + value.getPath() + ".title";
    }

    @SideOnly(Side.CLIENT)
    public String getCategoryTooltipKey(Value value)
    {
        return this.id + ".config." + value.getPath() + ".tooltip";
    }

    @SideOnly(Side.CLIENT)
    public String getValueLabelKey(Value value)
    {
        return this.id + ".config." + value.getPath();
    }

    @SideOnly(Side.CLIENT)
    public String getValueCommentKey(Value value)
    {
        return this.id + ".config.comments." + value.getPath();
    }

    /**
     * Get a value from category by their ids
     */
    public Value get(String category, String value)
    {
        Value cat = this.values.get(category);

        if (cat != null)
        {
            return cat.getSubValue(value);
        }

        return null;
    }

    /**
     * Save later in a separate thread
     */
    public void saveLater()
    {
        ConfigThread.add(this);
    }

    /**
     * Save config to default location
     */
    public void save()
    {
        this.save(this.file);
    }

    /**
     * Save config to given file
     */
    public boolean save(File file)
    {
        try
        {
            if (file != null)
            {
                FileUtils.writeStringToFile(file, this.toJSON(), StandardCharsets.UTF_8);
            }
            else
            {
                /* If file is null, that means that it was sent from server side */
                Dispatcher.sendToServer(new PacketConfig(this));
            }

            return true;
        }
        catch (IOException e)
        {}

        return false;
    }

    /**
     * Copy all values from given config to this config
     */
    public void copy(Config config)
    {
        for (Map.Entry<String, Value> entry : config.values.entrySet())
        {
            this.values.get(entry.getKey()).copy(entry.getValue());
        }
    }

    public void copyServer(Config config)
    {
        for (Map.Entry<String, Value> entry : config.values.entrySet())
        {
            this.values.get(entry.getKey()).copyServer(entry.getValue());
        }
    }

    /**
     * Convert this config into JSON string
     */
    public String toJSON()
    {
        return JsonUtils.jsonToPretty(ConfigParser.toJson(this));
    }

    public Config filterSyncable()
    {
        return this.filter(Value::isSyncable);
    }

    public Config filterServerSide()
    {
        return this.filter(Predicates.not(Value::isClientSide));
    }

    public Config filter(Predicate<Value> predicate)
    {
        Config config = new Config(this.id);

        for (Value category : this.values.values())
        {
            List<Value> values = category.getSubValues().stream().filter(predicate).collect(Collectors.toList());

            if (!values.isEmpty())
            {
                Value newCategory = new Value(category.id);

                newCategory.setConfig(config);

                for (Value value : values)
                {
                    newCategory.addSubValue(value);
                }

                config.values.put(newCategory.id, newCategory);
            }
        }

        return config;
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        this.values.clear();

        for (int i = 0, c = buffer.readInt(); i < c; i++)
        {
            String key = ByteBufUtils.readUTF8String(buffer);
            Value category = new Value(key);

            category.setConfig(this);
            category.fromBytes(buffer);
            this.values.put(key, category);
        }
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        buffer.writeInt(this.values.size());

        for (Map.Entry<String, Value> entry : this.values.entrySet())
        {
            ByteBufUtils.writeUTF8String(buffer, entry.getKey());

            entry.getValue().toBytes(buffer);
        }
    }

    public void resetServerValues()
    {
        for (Value category : this.values.values())
        {
            category.resetServerValues();
        }
    }
}

==================================================

--- Файл №131 ---
Путь: main\java\mchorse\mclib\config\ConfigBuilder.java
--------------------
package mchorse.mclib.config;

import mchorse.mclib.config.values.Value;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueDouble;
import mchorse.mclib.config.values.ValueFloat;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueRL;
import mchorse.mclib.config.values.ValueString;
import net.minecraft.util.ResourceLocation;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class ConfigBuilder
{
    private Config config;
    private Value category;

    public ConfigBuilder(String id, File file)
    {
        this.config = new Config(id, file);
    }

    public Config getConfig()
    {
        return this.config;
    }

    public Value getCategory()
    {
        return this.category;
    }

    public ConfigBuilder category(String id)
    {
        this.config.values.put(id, this.category = new Value(id));
        this.category.setConfig(this.config);

        return this;
    }

    public ConfigBuilder register(Value value)
    {
        this.category.addSubValue(value);
        value.setConfig(this.config);

        return this;
    }

    public ValueInt getInt(String id, int defaultValue)
    {
        ValueInt value = new ValueInt(id, defaultValue);

        this.register(value);

        return value;
    }

    public ValueInt getInt(String id, int defaultValue, int min, int max)
    {
        ValueInt value = new ValueInt(id, defaultValue, min, max);

        this.register(value);

        return value;
    }

    public ValueFloat getFloat(String id, float defaultValue)
    {
        ValueFloat value = new ValueFloat(id, defaultValue);

        this.register(value);

        return value;
    }

    public ValueFloat getFloat(String id, float defaultValue, float min, float max)
    {
        ValueFloat value = new ValueFloat(id, defaultValue, min, max);

        this.register(value);

        return value;
    }

    public ValueDouble getDouble(String id, double defaultValue)
    {
        ValueDouble value = new ValueDouble(id, defaultValue);

        this.register(value);

        return value;
    }

    public ValueDouble getDouble(String id, double defaultValue, double min, double max)
    {
        ValueDouble value = new ValueDouble(id, defaultValue, min, max);

        this.register(value);

        return value;
    }

    public ValueBoolean getBoolean(String id, boolean defaultValue)
    {
        ValueBoolean value = new ValueBoolean(id, defaultValue);

        this.register(value);

        return value;
    }

    public ValueString getString(String id, String defaultValue)
    {
        ValueString value = new ValueString(id, defaultValue);

        this.register(value);

        return value;
    }

    public ValueRL getRL(String id, ResourceLocation defaultValue)
    {
        ValueRL value = new ValueRL(id, defaultValue);

        this.register(value);

        return value;
    }
}

==================================================

--- Файл №132 ---
Путь: main\java\mchorse\mclib\config\ConfigHandler.java
--------------------
package mchorse.mclib.config;

import mchorse.mclib.McLib;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketConfig;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.PlayerEvent;

public class ConfigHandler
{
    @SubscribeEvent
    public void onPlayerLogIn(PlayerEvent.PlayerLoggedInEvent event)
    {
        MinecraftServer server = event.player.getServer();

        if (server == null || server.isSinglePlayer() || !(event.player instanceof EntityPlayerMP))
        {
            return;
        }

        for (Config config : McLib.proxy.configs.modules.values())
        {
            if (config.hasSyncable())
            {
                Dispatcher.sendTo(new PacketConfig(config.filterSyncable(), true), (EntityPlayerMP) event.player);
            }
        }
    }
}


==================================================

--- Файл №133 ---
Путь: main\java\mchorse\mclib\config\ConfigManager.java
--------------------
package mchorse.mclib.config;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.utils.ValueColors;
import mchorse.mclib.config.json.ConfigParser;
import mchorse.mclib.config.values.Value;
import mchorse.mclib.config.values.ValueBoolean;
import mchorse.mclib.config.values.ValueDouble;
import mchorse.mclib.config.values.ValueFloat;
import mchorse.mclib.config.values.ValueInt;
import mchorse.mclib.config.values.ValueRL;
import mchorse.mclib.config.values.ValueString;
import mchorse.mclib.events.RegisterConfigEvent;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketConfig;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import java.io.File;
import java.util.HashMap;
import java.util.Map;

public class ConfigManager
{
    public static final BiMap<String, Class<? extends Value>> TYPES = HashBiMap.<String, Class<? extends  Value>>create();

    public final Map<String, Config> modules = new HashMap<String, Config>();

    static
    {
        TYPES.put("boolean", ValueBoolean.class);
        TYPES.put("double", ValueDouble.class);
        TYPES.put("float", ValueFloat.class);
        TYPES.put("int", ValueInt.class);
        TYPES.put("rl", ValueRL.class);
        TYPES.put("string", ValueString.class);
        TYPES.put("colors", ValueColors.class);
    }

    public static void synchronizeConfig(Config config, MinecraftServer server)
    {
        synchronizeConfig(config, server, null);
    }

    /**
     * Send given config to all players on the server
     */
    public static void synchronizeConfig(Config config, MinecraftServer server, EntityPlayer exception)
    {
        for (EntityPlayerMP target : server.getPlayerList().getPlayers())
        {
            if (target == exception)
            {
                continue;
            }

            Dispatcher.sendTo(new PacketConfig(config, true), target);
        }
    }

    /**
     * Config value to bytes
     */
    public static Value fromBytes(ByteBuf buffer)
    {
        String key = ByteBufUtils.readUTF8String(buffer);
        String type = ByteBufUtils.readUTF8String(buffer);

        if (type.isEmpty())
        {
            return null;
        }

        try
        {
            Class<? extends Value> clazz = TYPES.get(type);
            Value value = clazz.getConstructor(String.class).newInstance(key);

            value.fromBytes(buffer);

            return value;
        }
        catch (Exception e)
        {}

        return null;
    }

    /**
     * Config value from bytes
     */
    public static void toBytes(ByteBuf buffer, Value value)
    {
        String type = TYPES.inverse().get(value.getClass());

        ByteBufUtils.writeUTF8String(buffer, value.id);
        ByteBufUtils.writeUTF8String(buffer, type == null ? "" : type);

        if (type != null)
        {
            value.toBytes(buffer);
        }
    }

    public void register(File configs)
    {
        RegisterConfigEvent event = new RegisterConfigEvent(configs);

        McLib.EVENT_BUS.post(event);

        Config opAccess = event.opAccess.getConfig().serverSide();

        this.modules.put(opAccess.id, opAccess);

        for (Config config : event.modules)
        {
            this.modules.put(config.id, config);
        }

        this.reload();
    }

    public void reload()
    {
        for (Config config : this.modules.values())
        {
            ConfigParser.fromJson(config, config.file);
        }
    }

    public void resetServerValues()
    {
        for (Config config : this.modules.values())
        {
            config.resetServerValues();
        }
    }
}

==================================================

--- Файл №134 ---
Путь: main\java\mchorse\mclib\config\ConfigThread.java
--------------------
package mchorse.mclib.config;

import mchorse.mclib.utils.Timer;

import java.util.ArrayList;
import java.util.List;

/**
 * Config thread
 *
 * This bad boy is responsible for saving configs after some time
 */
public class ConfigThread implements Runnable
{
    private static ConfigThread instance;

    public List<Config> configs = new ArrayList<Config>();
    public Timer timer = new Timer(2000);

    public static synchronized void add(Config config)
    {
        if (instance == null)
        {
            instance = new ConfigThread();
            instance.addConfig(config);
            new Thread(instance).start();
        }
        else
        {
            instance.addConfig(config);
        }
    }

    public void addConfig(Config config)
    {
        if (this.configs.indexOf(config) == -1)
        {
            this.configs.add(config);
        }

        this.timer.mark();
    }

    @Override
    public void run()
    {
        while (!this.timer.checkReset())
        {
            try
            {
                Thread.sleep(100);
            }
            catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }

        for (Config config : this.configs)
        {
            config.save();
        }

        instance = null;
    }
}

==================================================

--- Файл №135 ---
Путь: main\java\mchorse\mclib\config\gui\GuiConfigPanel.java
--------------------
package mchorse.mclib.config.gui;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.GuiScrollElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiIconElement;
import mchorse.mclib.client.gui.framework.elements.list.GuiLabelListElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiContext;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.framework.elements.utils.ITextColoring;
import mchorse.mclib.client.gui.mclib.GuiAbstractDashboard;
import mchorse.mclib.client.gui.mclib.GuiDashboardPanel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.Icons;
import mchorse.mclib.client.gui.utils.Label;
import mchorse.mclib.client.gui.utils.ScrollDirection;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.values.IConfigGuiProvider;
import mchorse.mclib.config.values.Value;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketRequestConfigs;
import mchorse.mclib.utils.Direction;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

@SideOnly(Side.CLIENT)
public class GuiConfigPanel extends GuiDashboardPanel<GuiAbstractDashboard>
{
    public GuiIconElement request;
    public GuiIconElement reload;
    public GuiLabelListElement<String> mods;
    public GuiScrollElement options;

    private Config config;
    private IKey title = IKey.lang("mclib.gui.config.title");

    private Map<String, Config> serverConfigs;

    public GuiConfigPanel(Minecraft mc, GuiAbstractDashboard dashboard)
    {
        super(mc, dashboard);

        this.request = new GuiIconElement(mc, Icons.DOWNLOAD, (button) -> this.request());
        this.request.tooltip(IKey.lang("mclib.gui.config.request_tooltip"), Direction.BOTTOM);
        this.reload = new GuiIconElement(mc, Icons.REFRESH, (button) -> this.reload());
        this.reload.tooltip(IKey.lang("mclib.gui.config.reload_tooltip"), Direction.BOTTOM);
        this.mods = new GuiLabelListElement<String>(mc, (mod) -> this.selectConfig(mod.get(0).value));
        this.options = new GuiScrollElement(mc, ScrollDirection.HORIZONTAL);
        this.options.scroll.scrollSpeed = 51;

        this.reload.flex().relative(this).set(120 - 14, 12, 16, 16);
        this.request.flex().relative(this.reload.resizer()).set(-20, 0, 16, 16);
        this.mods.flex().relative(this).set(10, 35, 110, 0).h(1, -45);
        this.options.flex().relative(this).set(130, 0, 0, 0).w(1, -130).h(1F);
        this.options.flex().column(5).scroll().width(240).height(20).padding(15);

        this.fillClientMods();

        this.add(this.reload, this.request, this.mods, this.options);
        this.selectConfig("mclib");
        this.markContainer();
    }

    private void fillClientMods()
    {
        for (Config config : McLib.proxy.configs.modules.values())
        {
            if (!config.isServerSide())
            {
                this.mods.add(IKey.lang(config.getTitleKey()), config.id);
            }
        }

        this.mods.sort();
    }

    @Override
    public void open()
    {
        this.request.setVisible(!Minecraft.getMinecraft().isIntegratedServerRunning() && OpHelper.isPlayerOp());
    }

    @Override
    public void close()
    {
        if (this.serverConfigs != null)
        {
            this.request();
        }
    }

    @Override
    public boolean canBeOpened(int opLevel)
    {
        return true;
    }

    public void storeServerConfig(Config config)
    {
        this.serverConfigs.put(config.id, config);
        this.mods.add(IKey.lang(config.getTitleKey()), config.id);
        this.mods.sort();

        if (config.id.equals("mclib"))
        {
            this.selectConfig("mclib");
        }
    }

    private void request()
    {
        this.config = null;
        this.mods.clear();

        if (this.serverConfigs == null)
        {
            this.serverConfigs = new HashMap<String, Config>();
            this.mods.setCurrent((Label<String>) null);

            Dispatcher.sendToServer(new PacketRequestConfigs());
        }
        else
        {
            this.serverConfigs = null;

            this.fillClientMods();
            this.selectConfig("mclib");
        }

        this.reload.setEnabled(this.serverConfigs == null);
        this.request.both(this.serverConfigs == null ? Icons.DOWNLOAD : Icons.UPLOAD);
    }

    private void reload()
    {
        if (this.serverConfigs == null)
        {
            McLib.proxy.configs.reload();
            this.refresh();
        }
    }

    private void selectConfig(String mod)
    {
        this.mods.setCurrentValue(mod);
        this.config = this.serverConfigs == null ? McLib.proxy.configs.modules.get(mod) : this.serverConfigs.get(mod);
        this.refresh();
    }

    public void refresh()
    {
        if (this.config == null)
        {
            return;
        }

        this.options.removeAll();

        boolean first = true;
        boolean checkForClient = this.serverConfigs != null;
        boolean isSingleplayer = Minecraft.getMinecraft().isIntegratedServerRunning();

        for (Value category : this.config.values.values())
        {
            if (!category.isVisible() || (checkForClient && category.isClientSide()))
            {
                continue;
            }

            String catTitleKey = this.config.getCategoryTitleKey(category);
            String catTooltipKey = this.config.getCategoryTooltipKey(category);

            GuiLabel label = Elements.label(IKey.lang(catTitleKey)).anchor(0, 1).background();

            if (!first)
            {
                label.margin.top(24);
            }

            label.tooltip(IKey.lang(catTooltipKey), Direction.BOTTOM).flex().w(this.font.getStringWidth(label.label.get()));
            this.options.add(label);

            for (Value value : category.getSubValues())
            {
                if (!value.isVisible() || (checkForClient && value.isClientSide()))
                {
                    continue;
                }

                if (!(value instanceof IConfigGuiProvider))
                {
                    continue;
                }

                for (GuiElement element : ((IConfigGuiProvider) value).getFields(this.mc, this))
                {
                    this.options.add(element);

                    /* Distinguish client side options from server side */
                    if (!isSingleplayer && !checkForClient && !value.isClientSide())
                    {
                        for (ITextColoring elem : element.getChildren(ITextColoring.class, new ArrayList<ITextColoring>(), true))
                        {
                            elem.setColor(0x999999, true);
                        }
                    }
                }
            }

            first = false;
        }

        this.resize();
    }

    @Override
    public void draw(GuiContext context)
    {
        this.mods.area.draw(0xdd000000, -10, -35, -10, -10);
        this.font.drawStringWithShadow(this.title.get(), this.area.x + 10, this.area.y + 20 - this.font.FONT_HEIGHT / 2, 0xffffff);

        super.draw(context);
    }
}

==================================================

--- Файл №136 ---
Путь: main\java\mchorse\mclib\config\json\ConfigParser.java
--------------------
package mchorse.mclib.config.json;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.values.Value;
import org.apache.commons.io.FileUtils;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.util.Map;

public class ConfigParser
{
    public static JsonObject toJson(Config config)
    {
        JsonObject object = new JsonObject();

        for (Map.Entry<String, Value> entry : config.values.entrySet())
        {
            object.add(entry.getKey(), entry.getValue().toJSON());
        }

        return object;
    }

    public static boolean fromJson(Config config, File file)
    {
        if (!file.exists())
        {
            config.save(file);

            return false;
        }

        try
        {
            JsonObject object = (JsonObject) new JsonParser().parse(FileUtils.readFileToString(file, StandardCharsets.UTF_8));

            for (Map.Entry<String, Value> entry : config.values.entrySet())
            {
                entry.getValue().fromJSON(object.getAsJsonObject(entry.getKey()));
            }

            return true;
        }
        catch (Exception e)
        {}

        return false;
    }
}

==================================================

--- Файл №137 ---
Путь: main\java\mchorse\mclib\config\values\GenericBaseValue.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.ICopy;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.nbt.NBTBase;

import javax.annotation.Nullable;

/**
 * A Value container, providing an interface for dealing with
 * the {@link #value} and {@link #serverValue}. The subclass {@link GenericValue} has a defaultValue.
 * Using the {@link #serverValue}, it can be used for server side syncing, for example, in configs.
 * If a subclass extending this should be used in configs with server side syncing visit {@link IServerValue}.
 *
 * <br><br>
 *
 * <h2>Important when extending:</h2>
 * If the generic datatype is a class, then that class should implement {@link ICopy}.
 * If the class of the generic datatype cannot implement {@link ICopy}, the methods {@link #set(Object)} and {@link #get()} need to be overridden!
 * <br>
 * The class of the generic datatype should also override {@link Object#equals(Object)} to ensure a safe usage.
 * If it cannot override {@link Object#equals(Object)}, the method {@link #equals(Object)} need to be overridden!
 *
 * <br><br>
 * The GenericBaseValue subclasses can be used together with the {@link mchorse.mclib.utils.ValueSerializer}
 * to automate all of the toNBT, fromNBT, toBytes, fromBytes, fromJson and toJson serialization processes.
 * GenericBaseValue subclasses can also be used for an undo / redo system, as it is already in place in Aperture mod.
 *
 * @param <T> the datatype of the values in this value container
 * @author Christian F (Chryfi)
 */
public abstract class GenericBaseValue<T> extends Value
{
    protected T value;
    protected T serverValue;

    public GenericBaseValue(String id)
    {
        super(id);
    }

    public GenericBaseValue(String id, T value)
    {
        super(id);

        this.value = value;
    }

    /**
     * @return reference to {@link #value}, or if the {@link #serverValue} != null return {@link #serverValue}.
     *         If the generic datatype is instance of {@link ICopy}, the return value will be copied.
     */
    public T get()
    {
        if (this.serverValue == null)
        {
            if (this.value instanceof ICopy)
            {
                return ((ICopy<T>) this.value).copy();
            }
            else
            {
                return this.value;
            }
        }
        else
        {
            if (this.serverValue instanceof ICopy)
            {
                return ((ICopy<T>) this.serverValue).copy();
            }
            else
            {
                return this.serverValue;
            }
        }
    }


    /**
     * Set the value of this instance to the provided value. If the value is instanceOf {@link ICopy}, it will be copied.
     * If the value is null, the result of {@link #getNullValue()} will be assigned.
     * This method calls {@link #saveLater()}
     * @param value
     */
    public void set(T value)
    {
        if (value == null)
        {
            this.value = this.getNullValue();
        }
        else
        {
            if (value instanceof ICopy)
            {
                this.value = ((ICopy<T>) value).copy();
            }
            else
            {
                this.value = value;
            }
        }

        this.saveLater();
    }

    /**
     * @return the default value that this type produces when not being initialised.
     *         This is used in {@link #set(T)}, for example, to avoid null values for primitive datatype wrappers.
     */
    protected T getNullValue()
    {
        return null;
    }


    /**
     * Only used in Aperture undo/redo system
     * @param value if the specified object is not null and assignable to the generic type T,
     *             the value be set, using the {@link #set(Object)} method.
     */
    @Override
    public void setValue(Object value)
    {
        if (value == null)
        {
            return;
        }

        try
        {
            this.set((T) value);
        }
        catch(ClassCastException e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Only used in Aperture undo/redo system
     * @return the value returned by this {@link #get()}
     */
    @Override
    public Object getValue()
    {
        return this.get();
    }


    /**
     * @return a deep copy of this object
     */
    @Override
    public abstract GenericBaseValue<T> copy();

    /**
     * Copy the {@link #value} from the specified object to this object.
     * @param origin the origin that should be copied from
     */
    @Override
    public abstract void copy(Value origin);

    /**
     * Compare the objects based on their {@link #value} variables. Ignores the other variables.
     * @param obj
     * @return true if this object's {@link #value} equals the specified object's {@link #value}, using {@link #equals(Object)}.
     *         Or if the specified object or its value and this.value are both null.
     */
    @Override
    public boolean equals(Object obj)
    {
        if (!(obj instanceof GenericBaseValue))
        {
            /*
             * if this.value == null and obj is null return true because both values are null
             */
            return (obj == null && this.value == null);
        }

        GenericBaseValue valueObj = (GenericBaseValue) obj;

        if (valueObj.value == null && this.value == null)
        {
            return true;
        }
        else if (valueObj.value == null)
        {
            return false;
        }
        else if (valueObj.value.equals(this.value))
        {
            return true;
        }

        return this == obj;
    }

    /**
     * Read all contents from this object from the ByteBuffer and call {@link #superFromBytes(ByteBuf)}
     * @param buffer
     */
    @Override
    public abstract void fromBytes(ByteBuf buffer);

    /**
     * Write all contents from this object to the ByteBuffer and call {@link #superToBytes(ByteBuf)}
     * @param buffer
     */
    @Override
    public abstract void toBytes(ByteBuf buffer);

    /**
     * Only read the {@link #value} from the ByteBuffer
     * @param buffer
     */
    public abstract void valueFromBytes(ByteBuf buffer);

    /**
     * Only write the {@link #value} into the ByteBuffer
     * @param buffer
     */
    public abstract void valueToBytes(ByteBuf buffer);

    @Override
    public abstract void valueFromJSON(JsonElement element);

    @Override
    public abstract JsonElement valueToJSON();

    /**
     * set the value based on the specified tag
     * @param tag the tag should be the value without the necessity to search for a key
     */
    public abstract void valueFromNBT(NBTBase tag);

    /**
     * @return the value as instance of a subclass of {@link net.minecraft.nbt.NBTBase}.
     *         It can also return null, depending on the implementation in the subclasses.
     */
    @Nullable
    public abstract NBTBase valueToNBT();

    /**
     * @param interpolation
     * @param to
     * @param factor
     * @return a new interpolated value between this value and the provided to value.
     */
    public abstract T interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor);
}


==================================================

--- Файл №138 ---
Путь: main\java\mchorse\mclib\config\values\GenericNumberValue.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import mchorse.mclib.utils.MathUtils;

import javax.annotation.Nonnull;

/**
 * GenericNumberValue can be used for the primitive datatype wrappers
 * that extend the {@link Number} class and implement {@link Comparable}.
 *
 * <br><br>
 * Subclasses need to override {@link #getNullValue()} to ensure
 * that the internal values never take the null state!
 * <br>
 * This means {@link #value}, {@link #defaultValue}, {@link #min} and {@link #max} shall never be null!
 * <br>
 * The variable {@link #serverValue} can be null.
 * @param <T>
 */
public abstract class GenericNumberValue<T extends Number & Comparable<T>> extends GenericValue<T>
{
    protected T min;
    protected T max;

    /**
     * If defaultValue, min or max are null, the value of {@link #getNullValue()} will be set for the variable with null.
     * @param id
     * @param defaultValue
     * @param min
     * @param max
     */
    public GenericNumberValue(String id, @Nonnull T defaultValue, @Nonnull T min, @Nonnull T max)
    {
        super(id);

        this.min = (min == null) ? this.getNullValue() : min;
        this.max = (max == null) ? this.getNullValue() : max;

        this.defaultValue = (defaultValue == null) ? this.getNullValue() : defaultValue;

        this.reset();
    }

    @Override
    public void setValue(Object value)
    {
        if (value == null)
        {
            return;
        }

        if (value instanceof Number) {
            this.set(this.numberToValue((Number) value));
        }
    }

    protected abstract T numberToValue(Number number);

    /**
     * The value will be clamped between {@link #min} and {@link #max}
     * @param value
     */
    @Override
    public void set(T value)
    {
        this.value = MathUtils.clamp((value == null) ? this.getNullValue() : value, this.min, this.max);

        this.saveLater();
    }

    public T getMin()
    {
        return this.min;
    }

    public T getMax()
    {
        return this.max;
    }

    @Override
    protected abstract T getNullValue();

    /**
     * @return true when the Value is a whole number, like integer, byte or long.
     */
    public abstract boolean isInteger();

    @Override
    public JsonElement valueToJSON()
    {
        return new JsonPrimitive(this.value);
    }
}


==================================================

--- Файл №139 ---
Путь: main\java\mchorse\mclib\config\values\GenericValue.java
--------------------
package mchorse.mclib.config.values;

import mchorse.mclib.utils.ICopy;

/**
 * A Value container, providing an interface for dealing with
 * the {@link #value}, {@link #defaultValue} and {@link #serverValue}.
 * Using the {@link #serverValue}, it can be used for server side syncing, for example, in configs.
 * If a subclass extending this should be used in configs with server side syncing visit {@link IServerValue}.
 *
 * <br><br>
 *
 * <h2>Important when extending:</h2>
 * If the generic datatype is a class, then that class should implement {@link ICopy}.
 * If the class of the generic datatype cannot implement {@link ICopy}, the methods {@link #set(Object)} and {@link #get()} need to be overridden!
 * <br>
 * The class of the generic datatype should also override {@link Object#equals(Object)} to ensure a safe usage.
 * If it cannot override {@link Object#equals(Object)}, the methods {@link #hasChanged()} and {@link #equals(Object)} need to be overridden!
 *
 * <br><br>
 * The GenericValue subclasses can be used together with the {@link mchorse.mclib.utils.ValueSerializer}
 * to automate all of the toNBT, fromNBT, toBytes, fromBytes, fromJson and toJson serialization processes.
 * GenericValue subclasses can also be used for an undo / redo system, as it is already in place in Aperture mod.
 *
 * @param <T> the datatype of the values in this value container
 * @author Christian F (Chryfi)
 */
public abstract class GenericValue<T> extends GenericBaseValue<T>
{
    protected T defaultValue;

    public GenericValue(String id)
    {
        super(id);
    }

    /**
     * Sets defaultValue to the provided defaultValue.
     * If defaultValue is null, the value of {@link #getNullValue()} will be set.
     * After defaultValue has been set the method {@link #reset()} will be called
     * @param id the id name of this value container
     * @param defaultValue
     */
    public GenericValue(String id, T defaultValue)
    {
        super(id);

        this.defaultValue = (defaultValue == null) ? this.getNullValue() : defaultValue;

        this.reset();
    }

    /**
     * Reset this value to defaultValue. Calls {@link #set(Object)}
     */
    @Override
    public void reset()
    {
        this.set(this.defaultValue);
    }

    /**
     * @return true if value is null and defaultValue is not null or
     *         if the result of value {@link Object#equals(Object)} is false.
     */
    public boolean hasChanged()
    {
        if (this.value == null && this.defaultValue == null)
        {
            return false;
        }
        else if (this.value == null)
        {
            return true;
        }

        return !this.value.equals(this.defaultValue);
    }
}


==================================================

--- Файл №140 ---
Путь: main\java\mchorse\mclib\config\values\IConfigGuiProvider.java
--------------------
package mchorse.mclib.config.values;

import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.config.gui.GuiConfigPanel;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

public interface IConfigGuiProvider
{
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui);
}

==================================================

--- Файл №141 ---
Путь: main\java\mchorse\mclib\config\values\IServerValue.java
--------------------
package mchorse.mclib.config.values;

public interface IServerValue
{
    public void resetServer();

    public boolean parseFromCommand(String value);

    public void copyServer(Value value);
}

==================================================

--- Файл №142 ---
Путь: main\java\mchorse\mclib\config\values\Value.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonNull;
import com.google.gson.JsonObject;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.ConfigManager;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.mclib.utils.ICopy;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class Value implements IByteBufSerializable, ICopy<Value>
{
    public final String id;
    private boolean visible = true;
    private boolean clientSide;
    private boolean syncable;

    private Config config;
    private Map<String, Value> children = new LinkedHashMap<String, Value>();
    private Value parent;

    public Value(String id)
    {
        this.id = id;
    }

    public Object getValue()
    {
        return null;
    }

    public void setValue(Object value)
    {}

    public void reset()
    {}

    /* Hierarchy code */

    public Config getConfig()
    {
        return this.config;
    }

    public void setConfig(Config config)
    {
        this.config = config;
    }

    public void removeAllSubValues()
    {
        this.children.clear();
    }

    public List<Value> getSubValues()
    {
        return new ArrayList<Value>(this.children.values());
    }

    public void addSubValue(Value value)
    {
        if (value != null)
        {
            this.children.put(value.id, value);
            value.parent = this;
        }
    }

    public Value getSubValue(String key)
    {
        return this.children.get(key);
    }

    public void removeSubValue(String key)
    {
        this.children.remove(key);
    }

    public Value getRoot()
    {
        Value value = this;

        while (value != null)
        {
            if (value.parent == null)
            {
                return value;
            }

            value = value.parent;
        }

        return null;
    }

    public Value getParent()
    {
        return this.parent;
    }

    public Value setParent(Value parent)
    {
        this.parent = parent;

        return this;
    }

    public String getPath()
    {
        List<String> strings = new ArrayList<String>();
        Value value = this;

        while (value != null)
        {
            if (!value.id.isEmpty())
            {
                strings.add(value.id);
            }

            value = value.parent;
        }

        Collections.reverse(strings);

        return String.join(".", strings);
    }

    /* Base property getters and setters */

    public Value invisible()
    {
        this.visible = false;

        return this;
    }

    public Value clientSide()
    {
        this.clientSide = true;

        return this;
    }

    public Value markClientSide()
    {
        for (Value value : this.children.values())
        {
            value.markClientSide();
        }

        return this.clientSide();
    }

    public Value syncable()
    {
        this.syncable = true;

        return this;
    }

    public boolean isVisible()
    {
        boolean visible = true;
        Value value = this;

        while (value != null)
        {
            visible = visible && value.visible;
            value = value.parent;
        }

        return visible;
    }

    public boolean isClientSide()
    {
        boolean visible = false;
        Value value = this;

        while (value != null)
        {
            visible = visible || value.clientSide;
            value = value.parent;
        }

        return visible;
    }

    public boolean isSyncable()
    {
        return this.syncable;
    }

    public boolean hasSyncable()
    {
        if (this.syncable)
        {
            return true;
        }

        for (Value value : this.children.values())
        {
            if (value.hasSyncable())
            {
                return true;
            }
        }

        return false;
    }

    public void saveLater()
    {
        if (this.config != null)
        {
            this.config.saveLater();
        }
    }

    /* Saving data */

    public void fromJSON(JsonElement element)
    {
        if (element.isJsonObject())
        {
            JsonObject object = element.getAsJsonObject();

            if (object.has("value") && object.has("subvalues") && object.size() == 2)
            {
                this.childrenFromJSON(object.get("subvalues").getAsJsonObject());
                this.valueFromJSON(object.get("value"));
            }
            else
            {
                this.childrenFromJSON(object);
            }
        }
        else
        {
            this.valueFromJSON(element);
        }
    }

    private void childrenFromJSON(JsonObject object)
    {
        for (Map.Entry<String, JsonElement> entry : object.entrySet())
        {
            Value value = this.children.get(entry.getKey());

            if (value != null)
            {
                value.reset();
                value.setParent(this);
                value.fromJSON(entry.getValue());
            }
        }
    }

    protected void valueFromJSON(JsonElement element)
    {}

    public JsonElement toJSON()
    {
        JsonElement child = this.valueToJSON();
        JsonObject object = new JsonObject();

        for (Value value : this.children.values())
        {
            object.add(value.id, value.toJSON());
        }

        if (child.isJsonNull())
        {
            return object;
        }
        else if (object.size() == 0)
        {
            return child;
        }

        JsonObject container = new JsonObject();

        container.add("value", child);
        container.add("subvalues", object);

        return container;
    }

    protected JsonElement valueToJSON()
    {
        return JsonNull.INSTANCE;
    }

    /**
     * @return a Value instance with the same {@link #id} and containing copies of the {@link #children} values
     */
    @Override
    public Value copy()
    {
        Value copy = new Value(this.id);

        for (Map.Entry<String, Value> entry : this.children.entrySet())
        {
            copy.children.put(entry.getKey(), entry.getValue().copy());
        }

        return copy;
    }

    @Override
    public void copy(Value category)
    {
        this.superCopy(category);
    }

    /**
     * For internal usage in subclasses of {@link GenericValue}.
     * @param category
     */
    protected final void superCopy(Value category)
    {
        for (Map.Entry<String, Value> entry : category.children.entrySet())
        {
            this.children.get(entry.getKey()).copy(entry.getValue());
        }
    }

    public void copyServer(Value category)
    {
        for (Map.Entry<String, Value> entry : category.children.entrySet())
        {
            Value value = this.children.get(entry.getKey());

            if (value != null && value.isSyncable() && value instanceof IServerValue)
            {
                ((IServerValue) value).copyServer(entry.getValue());
            }
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        this.superFromBytes(buffer);
    }

    /**
     * For internal usage in subclasses of {@link GenericValue}.
     * @param buffer
     */
    protected final void superFromBytes(ByteBuf buffer)
    {
        this.visible = buffer.readBoolean();
        this.clientSide = buffer.readBoolean();

        this.children.clear();

        for (int i = 0, c = buffer.readInt(); i < c; i++)
        {
            Value value = ConfigManager.fromBytes(buffer);

            if (value != null)
            {
                value.setConfig(this.config);
                value.setParent(this);
                this.addSubValue(value);
            }
        }
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        this.superToBytes(buffer);
    }

    /**
     * For internal usage in subclasses of {@link GenericValue}.
     * @param buffer
     */
    protected final void superToBytes(ByteBuf buffer)
    {
        buffer.writeBoolean(this.visible);
        buffer.writeBoolean(this.clientSide);

        buffer.writeInt(this.children.size());

        for (Map.Entry<String, Value> entry : this.children.entrySet())
        {
            ConfigManager.toBytes(buffer, entry.getValue());
        }
    }

    public void resetServerValues()
    {
        for (Value value : this.children.values())
        {
            if (value instanceof IServerValue)
            {
                ((IServerValue) value).resetServer();
            }
        }
    }

    /* Client side stuff */

    @SideOnly(Side.CLIENT)
    public String getLabelKey()
    {
        return this.config.getValueLabelKey(this);
    }

    @SideOnly(Side.CLIENT)
    public String getCommentKey()
    {
        return this.config.getValueCommentKey(this);
    }
}

==================================================

--- Файл №143 ---
Путь: main\java\mchorse\mclib\config\values\ValueBoolean.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiToggleElement;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MatrixUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagInt;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueBoolean extends GenericValue<Boolean> implements IServerValue, IConfigGuiProvider
{
    public ValueBoolean(String id)
    {
        super(id, false);
    }

    public ValueBoolean(String id, boolean defaultValue)
    {
        super(id, defaultValue);
    }

    @Override
    protected Boolean getNullValue()
    {
        return false;
    }

    @Override
    public void resetServer()
    {
        this.serverValue = null;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiToggleElement toggle = new GuiToggleElement(mc, this);

        toggle.flex().reset();

        return Arrays.asList(toggle);
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(element.getAsBoolean());
    }

    @Override
    public JsonElement valueToJSON()
    {
        return new JsonPrimitive(this.value);
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTPrimitive)
        {
            if (((NBTPrimitive) tag).getInt() == 1)
            {
                this.set(true);
            }
            else if (((NBTPrimitive) tag).getInt() == 0)
            {
                this.set(false);
            }
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagInt(this.value ? 1 : 0);
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        if (value.equals("1"))
        {
            this.set(true);
        }
        else if (value.equals("0"))
        {
            this.set(false);
        }
        else
        {
            this.set(Boolean.parseBoolean(value));
        }

        return true;
    }

    @Override
    public void copy(Value value)
    {
        superCopy(value);

        if (value instanceof ValueBoolean)
        {
            this.value = ((ValueBoolean) value).value;
        }
    }

    @Override
    public void copyServer(Value value)
    {
        super.copyServer(value);

        if (value instanceof ValueBoolean)
        {
            this.serverValue = ((ValueBoolean) value).value;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.value = buffer.readBoolean();
        this.defaultValue = buffer.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeBoolean(this.value);
        buffer.writeBoolean(this.defaultValue);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.value = buffer.readBoolean();
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeBoolean(this.value);
    }

    @Override
    public String toString()
    {
        return Boolean.toString(this.value);
    }

    @Override
    public ValueBoolean copy()
    {
        ValueBoolean clone = new ValueBoolean(this.id);
        clone.defaultValue = this.defaultValue;
        clone.value = this.value;
        clone.serverValue = this.serverValue;

        return clone;
    }

    public Boolean interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof Boolean)) return this.value;

        return factor == 1F ? (Boolean) to.value : this.value;
    }
}


==================================================

--- Файл №144 ---
Путь: main\java\mchorse\mclib\config\values\ValueColor.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagFloat;
import net.minecraft.nbt.NBTTagInt;

import javax.annotation.Nullable;

public class ValueColor extends GenericValue<Color>
{
    public ValueColor(String id)
    {
        super(id);
    }

    public ValueColor(String id, Color defaultValue)
    {
        super(id, defaultValue);
    }

    @Override
    public GenericBaseValue<Color> copy()
    {
        ValueColor clone = new ValueColor(this.id, this.defaultValue);
        clone.value = this.value;
        return clone;
    }

    @Override
    public void copy(Value origin)
    {
        if (origin instanceof ValueColor)
        {
            this.set(((ValueColor) origin).value);
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.defaultValue = new Color(buffer.readInt());
        this.valueFromBytes(buffer);
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeInt(this.defaultValue.getRGBAColor());
        this.valueToBytes(buffer);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.value = new Color(buffer.readInt());
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeInt(this.value.getRGBAColor());
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(new Color(element.getAsInt()));
    }

    @Override
    public JsonElement valueToJSON()
    {
        return new JsonPrimitive(this.value.getRGBAColor());
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTTagInt)
        {
            this.set(new Color(((NBTTagInt) tag).getInt()));
        }
    }

    @Nullable
    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagInt(this.value.getRGBAColor());
    }

    public Color interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof Color)) return this.value.copy();

        Color toC = (Color) to.value;
        Color interpolated = new Color();
        interpolated.r = interpolation.interpolate(this.value.r, toC.r, factor);
        interpolated.g = interpolation.interpolate(this.value.g, toC.g, factor);
        interpolated.b = interpolation.interpolate(this.value.b, toC.b, factor);
        interpolated.a = interpolation.interpolate(this.value.a, toC.a, factor);

        return interpolated;
    }
}


==================================================

--- Файл №145 ---
Путь: main\java\mchorse\mclib\config\values\ValueDouble.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagDouble;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueDouble extends GenericNumberValue<Double> implements IServerValue, IConfigGuiProvider
{
    public ValueDouble(String id)
    {
        super(id, 0D, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
    }

    public ValueDouble(String id, double defaultValue)
    {
        super(id, defaultValue, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);
    }

    public ValueDouble(String id, double defaultValue, double min, double max)
    {
        super(id, defaultValue, min, max);
    }

    @Override
    public void resetServer()
    {
        this.serverValue = null;
    }

    @Override
    protected Double getNullValue()
    {
        return 0D;
    }

    @Override
    protected Double numberToValue(Number number) {
        return number.doubleValue();
    }

    public boolean isInteger()
    {
        return false;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiElement element = new GuiElement(mc);
        GuiLabel label = Elements.label(IKey.lang(this.getLabelKey()), 0).anchor(0, 0.5F);
        GuiTrackpadElement trackpad = new GuiTrackpadElement(mc, this);

        trackpad.flex().w(90);

        element.flex().row(0).preferred(0).height(20);
        element.add(label, trackpad.removeTooltip());

        return Arrays.asList(element.tooltip(IKey.lang(this.getCommentKey())));
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(element.getAsDouble());
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        try
        {
            this.set(Double.parseDouble(value));
        }
        catch (Exception e)
        {}

        return false;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueDouble)
        {
            this.set(((ValueDouble) value).value);
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueDouble)
        {
            this.serverValue = ((ValueDouble) value).value;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.defaultValue = buffer.readDouble();
        this.min = buffer.readDouble();
        this.max = buffer.readDouble();
        this.valueFromBytes(buffer);
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeDouble(this.defaultValue);
        buffer.writeDouble(this.min);
        buffer.writeDouble(this.max);
        this.valueToBytes(buffer);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.set(buffer.readDouble());
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeDouble(this.value);
    }

    @Override
    public String toString()
    {
        return Double.toString(this.value);
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTPrimitive)
        {
            this.set(((NBTPrimitive) tag).getDouble());
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagDouble(this.value);
    }

    @Override
    public ValueDouble copy()
    {
        ValueDouble clone = new ValueDouble(this.id, this.defaultValue, this.min, this.max);
        clone.value = this.value;

        return clone;
    }

    public Double interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof Double)) return this.value;

        return interpolation.interpolate(this.value, (Double) to.value, factor);
    }
}

==================================================

--- Файл №146 ---
Путь: main\java\mchorse\mclib\config\values\ValueFloat.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagFloat;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueFloat extends GenericNumberValue<Float> implements IServerValue, IConfigGuiProvider
{
    public ValueFloat(String id)
    {
        super(id, 0F, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);
    }

    public ValueFloat(String id, float defaultValue)
    {
        super(id, defaultValue, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY);
    }

    public ValueFloat(String id, float defaultValue, float min, float max)
    {
        super(id, defaultValue, min, max);
    }

    @Override
    public void resetServer()
    {
        this.serverValue = null;
    }

    @Override
    protected Float getNullValue()
    {
        return 0F;
    }

    @Override
    protected Float numberToValue(Number number) {
        return number.floatValue();
    }

    public boolean isInteger()
    {
        return false;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiElement element = new GuiElement(mc);
        GuiLabel label = Elements.label(IKey.lang(this.getLabelKey()), 0).anchor(0, 0.5F);
        GuiTrackpadElement trackpad = new GuiTrackpadElement(mc, this);

        trackpad.flex().w(90);

        element.flex().row(0).preferred(0).height(20);
        element.add(label, trackpad.removeTooltip());

        return Arrays.asList(element.tooltip(IKey.lang(this.getCommentKey())));
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(element.getAsFloat());
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTPrimitive)
        {
            this.set(((NBTPrimitive) tag).getFloat());
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagFloat(this.value);
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        try
        {
            this.set(Float.parseFloat(value));
        }
        catch (Exception e)
        {}

        return false;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueFloat)
        {
            this.set(((ValueFloat) value).value);
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueFloat)
        {
            this.serverValue = ((ValueFloat) value).value;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.defaultValue = buffer.readFloat();
        this.min = buffer.readFloat();
        this.max = buffer.readFloat();
        this.valueFromBytes(buffer);
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeFloat(this.defaultValue);
        buffer.writeFloat(this.min);
        buffer.writeFloat(this.max);
        this.valueToBytes(buffer);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.set(buffer.readFloat());
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeFloat(this.value);
    }

    @Override
    public String toString()
    {
        return Float.toString(this.value);
    }

    @Override
    public ValueFloat copy()
    {
        ValueFloat clone = new ValueFloat(this.id, this.defaultValue, this.min, this.max);
        clone.value = this.value;

        return clone;
    }

    public Float interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof Float)) return this.value;

        return interpolation.interpolate(this.value, (Float) to.value, factor);
    }
}

==================================================

--- Файл №147 ---
Путь: main\java\mchorse\mclib\config\values\ValueGUI.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonNull;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.config.gui.GuiConfigPanel;
import net.minecraft.client.Minecraft;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.List;

public abstract class ValueGUI extends Value implements IConfigGuiProvider
{
    public ValueGUI(String id)
    {
        super(id);
    }

    @Override
    public Object getValue()
    {
        return null;
    }

    @Override
    public void setValue(Object value)
    {}

    @Override
    public void reset()
    {}

    @Override
    public void valueFromJSON(JsonElement element)
    {}

    @Override
    public void copy(Value value)
    {}

    @Override
    public JsonElement valueToJSON()
    {
        return JsonNull.INSTANCE;
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {}

    @Override
    public void toBytes(ByteBuf buffer)
    {}
}

==================================================

--- Файл №148 ---
Путь: main\java\mchorse\mclib\config\values\ValueInt.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiCirculateElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiColorElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiKeybindElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.client.gui.utils.keys.KeyParser;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.ColorUtils;
import mchorse.mclib.utils.Interpolation;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagInt;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class ValueInt extends GenericNumberValue<Integer> implements IServerValue, IConfigGuiProvider
{
    private Subtype subtype = Subtype.INTEGER;
    private List<IKey> labels;

    public ValueInt(String id)
    {
        super(id, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    public ValueInt(String id, int defaultValue)
    {
        super(id, defaultValue, Integer.MIN_VALUE, Integer.MAX_VALUE);
    }

    public ValueInt(String id, int defaultValue, int min, int max)
    {
        super(id, defaultValue, min, max);
    }

    public void setColorValue(String value)
    {
        this.set(ColorUtils.parseColor(value));
    }

    @Override
    protected Integer numberToValue(Number number) {
        return number.intValue();
    }

    public Subtype getSubtype()
    {
        return this.subtype;
    }

    public ValueInt subtype(Subtype subtype)
    {
        this.subtype = subtype;

        return this;
    }

    public ValueInt color()
    {
        return this.subtype(Subtype.COLOR);
    }

    public ValueInt colorAlpha()
    {
        return this.subtype(Subtype.COLOR_ALPHA);
    }

    public ValueInt keybind()
    {
        return this.subtype(Subtype.KEYBIND);
    }

    public ValueInt comboKey()
    {
        return this.subtype(Subtype.COMBOKEY);
    }

    public ValueInt modes(IKey... labels)
    {
        this.labels = new ArrayList<IKey>();
        Collections.addAll(this.labels, labels);

        return this.subtype(Subtype.MODES);
    }

    public boolean isInteger()
    {
        return true;
    }


    @Override
    public void resetServer()
    {
        this.serverValue = null;
    }

    @Override
    protected Integer getNullValue()
    {
        return 0;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiElement element = new GuiElement(mc);
        GuiLabel label = Elements.label(IKey.lang(this.getLabelKey()), 0).anchor(0, 0.5F);

        element.flex().row(0).preferred(0).height(20);
        element.add(label);

        if (this.subtype == Subtype.COLOR || this.subtype == Subtype.COLOR_ALPHA)
        {
            GuiColorElement color = new GuiColorElement(mc, this);

            color.flex().w(90);
            element.add(color.removeTooltip());
        }
        else if (this.subtype == Subtype.KEYBIND || this.subtype == Subtype.COMBOKEY)
        {
            GuiKeybindElement keybind = new GuiKeybindElement(mc, this);

            keybind.flex().w(90);
            element.add(keybind.removeTooltip());
        }
        else if (this.subtype == Subtype.MODES)
        {
            GuiCirculateElement button = new GuiCirculateElement(mc, null);

            for (IKey key : this.labels)
            {
                button.addLabel(key);
            }

            button.callback = (b) -> this.set(button.getValue());
            button.setValue(this.get());
            button.flex().w(90);
            element.add(button);
        }
        else
        {
            GuiTrackpadElement trackpad = new GuiTrackpadElement(mc, this);

            trackpad.flex().w(90);
            element.add(trackpad.removeTooltip());
        }

        return Arrays.asList(element.tooltip(IKey.lang(this.getCommentKey())));
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(element.getAsInt());
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTPrimitive)
        {
            this.set(((NBTPrimitive) tag).getInt());
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagInt(this.value);
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        try
        {
            if (this.subtype == Subtype.COLOR || this.subtype == Subtype.COLOR_ALPHA)
            {
                this.set(ColorUtils.parseColorWithException(value));
            }
            else
            {
                this.set(Integer.parseInt(value));
            }

            return true;
        }
        catch (Exception e)
        {}

        return false;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueInt)
        {
            this.set(((ValueInt) value).value);
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueInt)
        {
            this.serverValue = ((ValueInt) value).value;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.defaultValue = buffer.readInt();
        this.min = buffer.readInt();
        this.max = buffer.readInt();
        this.valueFromBytes(buffer);

        this.subtype = Subtype.values()[buffer.readInt()];

        if (buffer.readBoolean())
        {
            this.labels = new ArrayList<IKey>();

            for (int i = 0, c = buffer.readInt(); i < c; i++)
            {
                IKey key = KeyParser.keyFromBytes(buffer);

                if (key != null)
                {
                    this.labels.add(key);
                }
            }
        }
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeInt(this.defaultValue);
        buffer.writeInt(this.min);
        buffer.writeInt(this.max);
        this.valueToBytes(buffer);

        buffer.writeInt(this.subtype.ordinal());
        buffer.writeBoolean(this.labels != null);

        if (this.labels != null)
        {
            buffer.writeInt(this.labels.size());

            for (IKey key : this.labels)
            {
                KeyParser.keyToBytes(buffer, key);
            }
        }
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.set(buffer.readInt());
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeInt(this.value);
    }

    @Override
    public String toString()
    {
        if (this.subtype == Subtype.COLOR || this.subtype == Subtype.COLOR_ALPHA)
        {
            return "#" + Integer.toHexString(this.value);
        }

        return Integer.toString(this.value);
    }

    @Override
    public ValueInt copy()
    {
        ValueInt clone = new ValueInt(this.id, this.defaultValue, this.min, this.max);
        clone.value = this.value;

        return clone;
    }

    public static enum Subtype
    {
        INTEGER,
        COLOR,
        COLOR_ALPHA,
        KEYBIND,
        COMBOKEY,
        MODES
    }

    public Integer interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof Integer)) return this.value;

        return (int) interpolation.interpolate(this.value, (Integer) to.value, factor);
    }
}

==================================================

--- Файл №149 ---
Путь: main\java\mchorse\mclib\config\values\ValueItemSlots.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.JsonUtils;
import net.minecraft.item.Item;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagList;
import net.minecraftforge.fml.common.network.ByteBufUtils;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.Arrays;


/**
 * The Array of ItemStacks will not contain null values. Null values will be replaced with {@link ItemStack#EMPTY}
 */
public class ValueItemSlots extends GenericValue<ItemStack[]>
{
    private int size;

    public ValueItemSlots(String id, int size)
    {
        super(id);

        this.size = size;
        this.defaultValue = this.getNullValue();

        this.reset();
    }

    /**
     * Sets the defaultValue to a copy of the provided defaultValue array.
     * @param id
     * @param defaultValue
     */
    public ValueItemSlots(String id, ItemStack[] defaultValue)
    {
        super(id);

        this.size = defaultValue.length;
        this.defaultValue = new ItemStack[defaultValue.length];

        for (int i = 0; i < this.defaultValue.length; i++)
        {
            this.defaultValue[i] = (defaultValue[i] == null) ? this.getNullElementValue() : defaultValue[i].copy();
        }

        this.reset();
    }

    /**
     * Set this value to a copy of the provided array
     * @param value
     */
    @Override
    public void set(@Nonnull ItemStack[] value)
    {
        if (value == null) return;

        for (int i = 0; i < value.length && i < this.value.length; i++)
        {
            this.value[i] = (value[i] == null) ? this.getNullElementValue() : value[i].copy();
        }

        this.saveLater();
    }

    /**
     * Set the provided index to a copy of the provided ItemStack.<br>
     * If the provided ItemStack is null, {@link ItemStack#EMPTY} will be set.<br>
     * Do nothing if the provided index is out of bounds.
     * @param itemStack
     * @param index
     */
    public void set(ItemStack itemStack, int index)
    {
        if (index < this.value.length)
        {
            this.value[index] = (itemStack == null) ? this.getNullElementValue() : itemStack.copy();

            this.saveLater();
        }
    }

    @Override
    public void reset()
    {
        this.value = new ItemStack[this.defaultValue.length];

        for (int i = 0; i < this.value.length; i++)
        {
            this.set(this.defaultValue[i], i);
        }
    }

    /**
     * @return a deep copy of the array
     */
    @Override
    public ItemStack[] get()
    {
        ItemStack[] copy = new ItemStack[this.value.length];

        for (int i = 0; i < this.value.length; i++)
        {
            copy[i] = this.value[i].copy();
        }

        return copy;
    }

    /**
     * @param index
     * @return a copy of the ItemStack at the provided index
     * @throws IndexOutOfBoundsException
     */
    public ItemStack get(int index) throws IndexOutOfBoundsException
    {
        return this.value[index].copy();
    }

    public int size()
    {
        return this.size;
    }

    /**
     * @return {@link ItemStack#EMPTY}, the default value that the type of the array should produce instead of null.
     */
    protected ItemStack getNullElementValue()
    {
        return ItemStack.EMPTY;
    }

    /**
     * @return an ItemStack array with the {@link #size} of this object filled with {@link ItemStack#EMPTY}
     */
    @Override
    protected ItemStack[] getNullValue()
    {
        ItemStack[] nullValue = new ItemStack[this.size];

        Arrays.fill(nullValue, this.getNullElementValue());

        return nullValue;
    }

    /**
     *
     * @param obj
     * @return false if the provided object is not instance of ValueItemSlots or if the length of the arrays are different.
     *         Returns true if every ItemStack in the array returns true for {@link ItemStack#isItemEqual(ItemStack)} or {@link ItemStack#isEmpty()}.
     */
    @Override
    public boolean equals(Object obj)
    {
        if (!(obj instanceof ValueItemSlots))
        {
            return false;
        }

        ValueItemSlots valueObj = (ValueItemSlots) obj;

        if (this.value.length != valueObj.value.length)
        {
            return false;
        }

        for (int i = 0; i < this.value.length; i++)
        {
            if (!ItemStack.areItemStacksEqual(this.value[i], this.defaultValue[i]))
            {
                return false;
            }
        }

        return true;
    }

    /**
     * @return false if every ItemStack in {@link #value} and {@link #defaultValue} returns true for {@link ItemStack#isItemEqual(ItemStack)} or {@link ItemStack#isEmpty()}.
     */
    @Override
    public boolean hasChanged()
    {
        for (int i = 0; i < this.value.length; i++)
        {
            if (!ItemStack.areItemStacksEqual(this.value[i], this.defaultValue[i]))
            {
                return true;
            }
        }

        return false;
    }

    @Override
    public ValueItemSlots copy()
    {
        ValueItemSlots copy = new ValueItemSlots(this.id, this.defaultValue);

        copy.set(this.value);

        return copy;
    }

    @Override
    public void copy(Value origin)
    {
        superCopy(origin);

        if (origin instanceof ValueItemSlots)
        {
            ValueItemSlots valueItemSlots = (ValueItemSlots) origin;

            for (int i = 0; i < valueItemSlots.value.length && i < this.value.length; i++)
            {
                this.value[i] = valueItemSlots.value[i].copy();
            }
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        this.size = buffer.readInt();

        this.value = new ItemStack[this.size];
        this.defaultValue = new ItemStack[this.size];

        for (int i = 0; i < this.value.length; i++)
        {
            this.value[i] = buffer.readBoolean() ? ByteBufUtils.readItemStack(buffer) : this.getNullElementValue();
        }

        for (int i = 0; i < this.defaultValue.length; i++)
        {
            this.defaultValue[i] = buffer.readBoolean() ? ByteBufUtils.readItemStack(buffer) : this.getNullElementValue();
        }
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        buffer.writeInt(this.size);

        for (int i = 0; i < this.value.length; i++)
        {
            buffer.writeBoolean(this.value[i] != null);

            if (this.value[i] != null)
            {
                ByteBufUtils.writeItemStack(buffer, this.value[i]);
            }
        }

        for (int i = 0; i < this.defaultValue.length; i++)
        {
            buffer.writeBoolean(this.defaultValue[i] != null);

            if (this.defaultValue[i] != null)
            {
                ByteBufUtils.writeItemStack(buffer, this.defaultValue[i]);
            }
        }
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.size = buffer.readInt();

        this.value = new ItemStack[this.size];

        for (int i = 0; i < this.value.length; i++)
        {
            this.value[i] = buffer.readBoolean() ? ByteBufUtils.readItemStack(buffer) : this.getNullElementValue();
        }
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeInt(this.size);

        for (int i = 0; i < this.value.length; i++)
        {
            buffer.writeBoolean(this.value[i] != null);

            if (this.value[i] != null)
            {
                ByteBufUtils.writeItemStack(buffer, this.value[i]);
            }
        }
    }

    /*TODO*/
    @Override
    public void valueFromJSON(JsonElement element)
    {

    }

    /*TODO*/
    @Override
    @Nullable
    public JsonElement valueToJSON()
    {
        return null;
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTTagList)
        {
            NBTTagList items = (NBTTagList) tag;

            for (int i = 0; i < items.tagCount() && i < this.value.length; i++)
            {
                this.value[i] = new ItemStack(items.getCompoundTagAt(i));
            }
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        NBTTagList list = new NBTTagList();

        for (int i = 0; i < this.value.length; i++)
        {
            NBTTagCompound tag = new NBTTagCompound();
            ItemStack stack = this.value[i];

            if (!stack.isEmpty())
            {
                stack.writeToNBT(tag);
            }

            list.appendTag(tag);
        }

        return list;
    }

    @Override
    public String toString()
    {
        String str = "";

        for (int i = 0; i < this.value.length; i++)
        {
            str += this.value[i].toString() + ((i + 1 == this.value.length) ? "" : ", ");
        }

        return str;
    }

    public ItemStack[] interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof ItemStack[])) return this.copy().value;

        return factor == 1F ? (ItemStack[]) to.copy().value : this.copy().value;
    }
}


==================================================

--- Файл №150 ---
Путь: main\java\mchorse\mclib\config\values\ValueLong.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTrackpadElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.Color;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagDouble;
import net.minecraft.nbt.NBTTagLong;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueLong extends GenericNumberValue<Long> implements IServerValue, IConfigGuiProvider
{
    public ValueLong(String id)
    {
        super(id, 0L, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public ValueLong(String id, long defaultValue)
    {
        super(id, defaultValue, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public ValueLong(String id, long defaultValue, long min, long max)
    {
        super(id, defaultValue, min, max);
    }

    @Override
    public void resetServer()
    {
        this.serverValue = null;
    }

    @Override
    protected Long getNullValue()
    {
        return 0L;
    }

    public boolean isInteger()
    {
        return true;
    }

    @Override
    protected Long numberToValue(Number number) {
        return number.longValue();
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiElement element = new GuiElement(mc);
        GuiLabel label = Elements.label(IKey.lang(this.getLabelKey()), 0).anchor(0, 0.5F);

        element.flex().row(0).preferred(0).height(20);
        element.add(label);

        GuiTrackpadElement trackpad = new GuiTrackpadElement(mc, this);

        trackpad.flex().w(90);
        element.add(trackpad.removeTooltip());

        return Arrays.asList(element.tooltip(IKey.lang(this.getCommentKey())));
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(element.getAsLong());
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTPrimitive)
        {
            this.set(((NBTPrimitive) tag).getLong());
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagLong(this.value);
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        try
        {
            this.set(Long.parseLong(value));

            return true;
        }
        catch (Exception e)
        {}

        return false;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueLong)
        {
            this.set(((ValueLong) value).value);
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueLong)
        {
            this.serverValue = ((ValueLong) value).value;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.defaultValue = buffer.readLong();
        this.min = buffer.readLong();
        this.max = buffer.readLong();
        this.valueFromBytes(buffer);
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeLong(this.defaultValue);
        buffer.writeLong(this.min);
        buffer.writeLong(this.max);
        this.valueToBytes(buffer);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.set(buffer.readLong());
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeLong(this.value);
    }

    @Override
    public ValueLong copy()
    {
        ValueLong clone = new ValueLong(this.id, this.defaultValue, this.min, this.max);
        clone.value = this.value;

        return clone;
    }

    @Override
    public String toString()
    {
        return Long.toString(this.value);
    }

    public Long interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof Long)) return this.value;

        return (long) interpolation.interpolate(this.value, (Long) to.value, factor);
    }
}

==================================================

--- Файл №151 ---
Путь: main\java\mchorse\mclib\config\values\ValueRL.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.buttons.GuiButtonElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.List;

public class ValueRL extends GenericValue<ResourceLocation> implements IServerValue, IConfigGuiProvider
{
    @SideOnly(Side.CLIENT)
    public static GuiTexturePicker picker;

    private boolean useServer;

    public ValueRL(String id)
    {
        super(id);
    }

    public ValueRL(String id, ResourceLocation defaultValue)
    {
        super(id);

        this.defaultValue = defaultValue;
    }

    /**
     * @return the reference to {@link #value} or {@link #serverValue}.
     */
    @Override
    public ResourceLocation get()
    {
        return !this.useServer ? this.value : this.serverValue;
    }

    /**
     * Set this {@link #value} to the reference of the provided value.
     * <br>Note: This is how it was implemented before Chryfi did rewrites
     * and it has been used throughout McLib etc., so to avoid any problems, the old implementation is kept
     * @param value
     */
    @Override
    public void set(ResourceLocation value)
    {
        this.value = value;

        this.saveLater();
    }

    public void set(String value)
    {
        this.set(RLUtils.create(value));
    }

    @Override
    public void resetServer()
    {
        this.useServer = false;
        this.serverValue = null;
    }

    @Override
    public void reset()
    {
        this.set(RLUtils.clone(this.defaultValue));
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiElement element = new GuiElement(mc);
        GuiLabel label = Elements.label(IKey.lang(this.getLabelKey()), 0).anchor(0, 0.5F);
        GuiButtonElement pick = new GuiButtonElement(mc, IKey.lang("mclib.gui.pick_texture"),  (button) ->
        {
            if (picker == null)
            {
                picker = new GuiTexturePicker(mc, null);
            }

            picker.callback = this::set;
            picker.fill(this.value);
            picker.flex().relative(gui).wh(1F, 1F);
            picker.resize();

            if (picker.hasParent())
            {
                picker.removeFromParent();
            }

            gui.add(picker);
        });

        pick.flex().w(90);

        element.flex().row(0).preferred(0).height(20);
        element.add(label, pick);

        return Arrays.asList(element.tooltip(IKey.lang(this.getCommentKey())));
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.value = RLUtils.create(element);
    }

    @Override
    public JsonElement valueToJSON()
    {
        return RLUtils.writeJson(this.value);
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        this.set(RLUtils.create(tag));
    }

    @Override
    @Nullable
    public NBTBase valueToNBT()
    {
        return RLUtils.writeNbt(this.value);
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        this.set(RLUtils.create(value));

        return true;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueRL)
        {
            this.value = RLUtils.clone(((ValueRL) value).value);
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueRL)
        {
            this.useServer = true;
            this.serverValue = RLUtils.clone(((ValueRL) value).value);
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.value = this.readRL(buffer);
        this.defaultValue = this.readRL(buffer);
    }

    private ResourceLocation readRL(ByteBuf buffer)
    {
        if (buffer.readBoolean())
        {
            NBTTagCompound tag = ByteBufUtils.readTag(buffer);

            return RLUtils.create(tag.getTag("RL"));
        }

        return null;
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        this.writeRL(buffer, this.value);
        this.writeRL(buffer, this.defaultValue);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.value = this.readRL(buffer);
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        this.writeRL(buffer, this.value);
    }

    private void writeRL(ByteBuf buffer, ResourceLocation rl)
    {
        buffer.writeBoolean(rl != null);

        if (rl != null)
        {
            NBTTagCompound tag = new NBTTagCompound();

            tag.setTag("RL", RLUtils.writeNbt(rl));
            ByteBufUtils.writeTag(buffer, tag);
        }
    }

    @Override
    public String toString()
    {
        return this.value == null ? "" : this.value.toString();
    }

    @Override
    public ValueRL copy()
    {
        ValueRL clone = new ValueRL(this.id);
        clone.value = RLUtils.clone(this.value);
        clone.defaultValue = RLUtils.clone(this.defaultValue);
        clone.serverValue = RLUtils.clone(this.serverValue);
        clone.useServer = this.useServer;

        return clone;
    }

    @Override
    public ResourceLocation interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof ResourceLocation)) return RLUtils.clone(this.value);

        return factor == 1F ? RLUtils.clone((ResourceLocation) to.value) : RLUtils.clone(this.value);
    }
}

==================================================

--- Файл №152 ---
Путь: main\java\mchorse\mclib\config\values\ValueRotationOrder.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MatrixUtils.RotationOrder;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagByte;

import javax.annotation.Nonnull;

/**
 * The value of this container will never be null. Null values will be replaced with XYZ RotationOrder
 */
public class ValueRotationOrder extends GenericValue<RotationOrder>
{
    public ValueRotationOrder(String id, @Nonnull RotationOrder order)
    {
        super(id, order);
    }

    @Override
    protected RotationOrder getNullValue()
    {
        return RotationOrder.XYZ;
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.value = RotationOrder.values()[buffer.readByte()];
        this.defaultValue = RotationOrder.values()[buffer.readByte()];
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        buffer.writeByte((byte) this.value.ordinal());
        buffer.writeByte((byte) this.defaultValue.ordinal());
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.value = RotationOrder.values()[buffer.readByte()];
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        buffer.writeByte((byte) this.value.ordinal());
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(RotationOrder.values()[element.getAsByte()]);
    }

    @Override
    public JsonElement valueToJSON()
    {
        return new JsonPrimitive(this.value.ordinal());
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTTagByte)
        {
            this.set(RotationOrder.values()[((NBTTagByte) tag).getByte()]);
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagByte((byte) this.value.ordinal());
    }

    @Override
    public ValueRotationOrder copy()
    {
        ValueRotationOrder clone = new ValueRotationOrder(this.id, this.defaultValue);
        clone.value = this.value;
        clone.serverValue = this.serverValue;

        return clone;
    }

    @Override
    public void copy(Value origin)
    {
        superCopy(origin);

        if (origin instanceof ValueRotationOrder)
        {
            this.value = ((ValueRotationOrder) origin).value;
        }
    }

    @Override
    public RotationOrder interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof RotationOrder)) return this.value;

        return factor == 1F ? (RotationOrder) to.value : this.value;
    }
}


==================================================

--- Файл №153 ---
Путь: main\java\mchorse\mclib\config\values\ValueString.java
--------------------
package mchorse.mclib.config.values;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.framework.elements.GuiElement;
import mchorse.mclib.client.gui.framework.elements.input.GuiTextElement;
import mchorse.mclib.client.gui.framework.elements.utils.GuiLabel;
import mchorse.mclib.client.gui.utils.Elements;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.MatrixUtils;
import mchorse.mclib.utils.resources.RLUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTPrimitive;
import net.minecraft.nbt.NBTTagDouble;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Arrays;
import java.util.List;

public class ValueString extends GenericValue<String> implements IServerValue, IConfigGuiProvider
{
    public ValueString(String id)
    {
        super(id, "");
    }

    public ValueString(String id, String defaultValue)
    {
        super(id, defaultValue);
    }

    @Override
    public void resetServer()
    {
        this.serverValue = null;
    }

    @Override
    @SideOnly(Side.CLIENT)
    public List<GuiElement> getFields(Minecraft mc, GuiConfigPanel gui)
    {
        GuiElement element = new GuiElement(mc);
        GuiLabel label = Elements.label(IKey.lang(this.getConfig().getValueLabelKey(this)), 0).anchor(0, 0.5F);
        GuiTextElement textbox = new GuiTextElement(mc, this);

        textbox.flex().w(90);

        element.flex().row(0).preferred(0).height(20);
        element.add(label, textbox.removeTooltip());

        return Arrays.asList(element.tooltip(IKey.lang(this.getConfig().getValueCommentKey(this))));
    }

    @Override
    public void valueFromJSON(JsonElement element)
    {
        this.set(element.getAsString());
    }

    @Override
    public JsonElement valueToJSON()
    {
        return new JsonPrimitive(this.value);
    }

    @Override
    public void valueFromNBT(NBTBase tag)
    {
        if (tag instanceof NBTTagString)
        {
            this.set(((NBTTagString) tag).getString());
        }
    }

    @Override
    public NBTBase valueToNBT()
    {
        return new NBTTagString(this.value == null ? "" : this.value);
    }

    @Override
    public boolean parseFromCommand(String value)
    {
        this.set(value);

        return true;
    }

    @Override
    public void copy(Value value)
    {
        if (value instanceof ValueString)
        {
            this.value = ((ValueString) value).value;
        }
    }

    @Override
    public void copyServer(Value value)
    {
        if (value instanceof ValueString)
        {
            this.serverValue = ((ValueString) value).value;
        }
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        superFromBytes(buffer);

        this.value = ByteBufUtils.readUTF8String(buffer);
        this.defaultValue = ByteBufUtils.readUTF8String(buffer);
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        superToBytes(buffer);

        ByteBufUtils.writeUTF8String(buffer, this.value == null ? "" : this.value);
        ByteBufUtils.writeUTF8String(buffer, this.defaultValue == null ? "" : this.defaultValue);
    }

    @Override
    public void valueFromBytes(ByteBuf buffer)
    {
        this.value = ByteBufUtils.readUTF8String(buffer);
    }

    @Override
    public void valueToBytes(ByteBuf buffer)
    {
        ByteBufUtils.writeUTF8String(buffer, this.value == null ? "" : this.value);
    }

    @Override
    public String toString()
    {
        return this.value;
    }

    @Override
    public ValueString copy()
    {
        ValueString clone = new ValueString(this.id);
        clone.defaultValue = this.defaultValue;
        clone.value = this.value;
        clone.serverValue = this.serverValue;

        return clone;
    }

    @Override
    public String interpolate(Interpolation interpolation, GenericBaseValue<?> to, float factor)
    {
        if (!(to.value instanceof String)) return this.value;

        return factor == 1F ? (String) to.value : this.value;
    }
}

==================================================

--- Файл №154 ---
Путь: main\java\mchorse\mclib\core\McLibCM.java
--------------------
package mchorse.mclib.core;

import java.util.Map;

import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin;
import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin.MCVersion;
import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin.Name;
import net.minecraftforge.fml.relauncher.IFMLLoadingPlugin.SortingIndex;

@Name("McLib core mod")
@MCVersion("1.12.2")
@SortingIndex(1)
public class McLibCM implements IFMLLoadingPlugin
{
    @Override
    public String[] getASMTransformerClass()
    {
        return new String[] {McLibCMClassTransformer.class.getName()};
    }

    @Override
    public String getModContainerClass()
    {
        return McLibCMInfo.class.getName();
    }

    @Override
    public String getSetupClass()
    {
        return null;
    }

    @Override
    public void injectData(Map<String, Object> data)
    {}

    @Override
    public String getAccessTransformerClass()
    {
        return null;
    }
}

==================================================

--- Файл №155 ---
Путь: main\java\mchorse\mclib\core\McLibCMClassTransformer.java
--------------------
package mchorse.mclib.core;

import mchorse.mclib.core.transformers.CPacketCustomPayloadTransformer;
import mchorse.mclib.core.transformers.EntityRendererTransformer;
import mchorse.mclib.core.transformers.PacketBufferTransformer;
import mchorse.mclib.core.transformers.SimpleReloadableResourceManagerTransformer;
import mchorse.mclib.utils.coremod.CoreClassTransformer;

public class McLibCMClassTransformer extends CoreClassTransformer
{
    private SimpleReloadableResourceManagerTransformer resourcePack = new SimpleReloadableResourceManagerTransformer();
    private CPacketCustomPayloadTransformer customPayload = new CPacketCustomPayloadTransformer();
    private EntityRendererTransformer entityRenderer = new EntityRendererTransformer();
    private PacketBufferTransformer packetBuffer = new PacketBufferTransformer();

    @Override
    public byte[] transform(String name, String transformedName, byte[] basicClass)
    {
        if (checkName(name, "cev", "net.minecraft.client.resources.SimpleReloadableResourceManager"))
        {
            System.out.println("McLib: Transforming SimpleReloadableResourceManager class (" + name + ")");

            return this.resourcePack.transform(name, basicClass);
        }
        else if (checkName(name, "lh", "net.minecraft.network.play.client.CPacketCustomPayload"))
        {
            System.out.println("McLib: Transforming CPacketCustomPayloadTransformer class (" + name + ")");

            return this.customPayload.transform(name, basicClass);
        }
        else if (checkName(name, "buq", "net.minecraft.client.renderer.EntityRenderer"))
        {
            System.out.println("McLib: patching EntityRenderer (" + name + ")");

            return this.entityRenderer.transform(name, basicClass);
        }
        else if (checkName(name, "gy", "net.minecraft.network.PacketBuffer"))
        {
            System.out.println("McLib: Transforming PacketBuffer class (" + name + ")");

            return this.packetBuffer.transform(name, basicClass);
        }

        return basicClass;
    }
}

==================================================

--- Файл №156 ---
Путь: main\java\mchorse\mclib\core\McLibCMInfo.java
--------------------
package mchorse.mclib.core;

import net.minecraftforge.fml.common.DummyModContainer;

public class McLibCMInfo extends DummyModContainer
{
    @Override
    public String getName()
    {
        return "McLib core mod";
    }

    @Override
    public String getModId()
    {
        return "mclib_core";
    }

    @Override
    public Object getMod()
    {
        return null;
    }

    @Override
    public String getVersion()
    {
        return "%VERSION%";
    }
}

==================================================

--- Файл №157 ---
Путь: main\java\mchorse\mclib\core\transformers\CPacketCustomPayloadTransformer.java
--------------------
package mchorse.mclib.core.transformers;

import mchorse.mclib.utils.PayloadASM;
import mchorse.mclib.utils.coremod.ClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class CPacketCustomPayloadTransformer extends ClassTransformer
{
    @Override
    public void process(String name, ClassNode node)
    {
        for (MethodNode method : node.methods)
        {
            PacketBufferTransformer.replaceConstant(method, node.name, PayloadASM.MIN_SIZE);
        }
    }
}

==================================================

--- Файл №158 ---
Путь: main\java\mchorse\mclib\core\transformers\EntityRendererTransformer.java
--------------------
package mchorse.mclib.core.transformers;

import mchorse.mclib.utils.coremod.ClassMethodTransformer;
import mchorse.mclib.utils.coremod.ClassTransformer;
import mchorse.mclib.utils.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.Iterator;
import java.util.ListIterator;

public class EntityRendererTransformer extends ClassTransformer
{
    @Override
    public void process(String name, ClassNode node)
    {
        for (MethodNode methodNode : node.methods)
        {
            if (methodNode.name.equals(this.checkName(methodNode, "a", "(FJ)V", "updateCameraAndRender", "(FJ)V")))
            {
                this.processUpdateCameraAndRender(methodNode);
            }
            else if(methodNode.name.equals(this.checkName(methodNode, "a", "(IFJ)V", "renderWorldPass", "(IFJ)V")))
            {
                this.processRenderWorldPass(methodNode);
            }
        }
    }

    public void processRenderWorldPass(MethodNode method)
    {
        ListIterator<AbstractInsnNode> iterator = method.instructions.iterator();

        while (iterator.hasNext())
        {
            AbstractInsnNode currentNode = iterator.next();

            if (currentNode instanceof MethodInsnNode)
            {
                /* credit goes to MiaoNLI for discovering this possibility and implementing it in Minema */

                MethodInsnNode mnode = (MethodInsnNode) currentNode;
                if ((mnode.name.equals("a") || mnode.name.equals("setupCameraTransform")) && mnode.desc.equals("(FI)V"))
                {
                    iterator.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/mclib/utils/MatrixUtils", "ASMAfterCamera", "()V", false));

                    System.out.println("McLib: successfully patched renderWorldPass!");

                    break;
                }
            }
        }
    }

    public void processUpdateCameraAndRender(MethodNode method)
    {
        Iterator<AbstractInsnNode> it = method.instructions.iterator();
        AbstractInsnNode pre = null;
        AbstractInsnNode post = null;

        int i = 0;
        boolean gui = false;

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node instanceof MethodInsnNode)
            {
                MethodInsnNode methodNode = (MethodInsnNode) node;
                String desc = methodNode.owner + "/" + methodNode.name + methodNode.desc;
                String targetPost = CoreClassTransformer.obfuscated ? "rl/b()V" : "net/minecraft/profiler/Profiler/endSection()V";
                String targetPre = CoreClassTransformer.obfuscated ? "rl/c(Ljava/lang/String;)V" : "net/minecraft/profiler/Profiler/endStartSection(Ljava/lang/String;)V";

                if (desc.equals(targetPost))
                {
                    i++;

                    if (i == 2)
                    {
                        post = node.getPrevious().getPrevious().getPrevious();

                        break;
                    }
                }
                else if (gui && desc.equals(targetPre))
                {
                    pre = node;
                }
            }
            else if (node instanceof LdcInsnNode)
            {
                LdcInsnNode ldc = (LdcInsnNode) node;

                if (ldc.cst.equals("gui"))
                {
                    gui = true;
                }
            }
        }

        if (pre != null && post != null)
        {
            method.instructions.insert(pre, new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/mclib/client/InputRenderer", "preRenderOverlay", "()V", false));
            method.instructions.insertBefore(post, new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/mclib/client/InputRenderer", "postRenderOverlay", "()V", false));

            System.out.println("McLib: successfully patched updateCameraAndRender!");
        }
    }
}


==================================================

--- Файл №159 ---
Путь: main\java\mchorse\mclib\core\transformers\PacketBufferTransformer.java
--------------------
package mchorse.mclib.core.transformers;

import mchorse.mclib.utils.PayloadASM;
import mchorse.mclib.utils.coremod.ClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class PacketBufferTransformer extends ClassTransformer
{
    @Override
    public void process(String name, ClassNode node)
    {
        for (MethodNode method : node.methods)
        {
            replaceConstant(method, node.name, PayloadASM.MIN_SIZE);
        }
    }

    public static void replaceConstant(MethodNode method, String className, int constant)
    {
        List<AbstractInsnNode> targets = new ArrayList<AbstractInsnNode>();
        Iterator<AbstractInsnNode> it = method.instructions.iterator();

        while (it.hasNext())
        {
            AbstractInsnNode node = it.next();

            if (node.getOpcode() == Opcodes.SIPUSH && ((IntInsnNode) node).operand == constant)
            {
                targets.add(node);
            }
        }

        for (AbstractInsnNode target : targets)
        {
            method.instructions.insert(target, new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/mclib/utils/PayloadASM", "getPayloadSize", "()I", false));
            method.instructions.remove(target);
        }

        if (!targets.isEmpty())
        {
            System.out.println("McLib: successfully patched " + className + "." + method.name + "!");
        }
    }
}

==================================================

--- Файл №160 ---
Путь: main\java\mchorse\mclib\core\transformers\SimpleReloadableResourceManagerTransformer.java
--------------------
package mchorse.mclib.core.transformers;

import mchorse.mclib.utils.coremod.ClassMethodTransformer;
import mchorse.mclib.utils.coremod.CoreClassTransformer;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.JumpInsnNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import org.objectweb.asm.tree.TypeInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

public class SimpleReloadableResourceManagerTransformer extends ClassMethodTransformer
{
    public SimpleReloadableResourceManagerTransformer()
    {
        this.setMcp("getResource", "(Lnet/minecraft/util/ResourceLocation;)Lnet/minecraft/client/resources/IResource;");
        this.setNotch("a", "(Lnf;)Lceo;");
    }

    @Override
    public void processMethod(String name, MethodNode method)
    {
        LabelNode label = this.getFirstLabel(method);

        if (label != null)
        {
            InsnList list = new InsnList();
            String desc = "(Lmchorse/mclib/utils/resources/MultiResourceLocation;)L" + CoreClassTransformer.get("ceo", "net/minecraft/client/resources/IResource") + ";";

            list.add(new VarInsnNode(Opcodes.ALOAD, 1));
            list.add(new TypeInsnNode(Opcodes.INSTANCEOF, "mchorse/mclib/utils/resources/MultiResourceLocation"));
            list.add(new JumpInsnNode(Opcodes.IFEQ, label));
            list.add(new VarInsnNode(Opcodes.ALOAD, 1));
            list.add(new TypeInsnNode(Opcodes.CHECKCAST, "mchorse/mclib/utils/resources/MultiResourceLocation"));
            list.add(new MethodInsnNode(Opcodes.INVOKESTATIC, "mchorse/mclib/utils/resources/RLUtils", "getStreamForMultiskin", desc, false));
            list.add(new InsnNode(Opcodes.ARETURN));

            method.instructions.insert(list);

            System.out.println("McLib: successfully patched getResource!");
        }
    }
}

==================================================

--- Файл №161 ---
Путь: main\java\mchorse\mclib\events\EventHandler.java
--------------------
package mchorse.mclib.events;

import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent.PlayerTickEvent;
import net.minecraftforge.fml.common.network.FMLNetworkEvent.ClientDisconnectionFromServerEvent;
import net.minecraftforge.fml.relauncher.Side;

public class EventHandler
{
    @SubscribeEvent
    public void clientLogsOut(ClientDisconnectionFromServerEvent event)
    {

    }
}


==================================================

--- Файл №162 ---
Путь: main\java\mchorse\mclib\events\MultiskinProcessedEvent.java
--------------------
package mchorse.mclib.events;

import mchorse.mclib.utils.resources.MultiResourceLocation;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.awt.image.BufferedImage;

@SideOnly(Side.CLIENT)
public class MultiskinProcessedEvent extends Event
{
    public MultiResourceLocation location;
    public BufferedImage image;

    public MultiskinProcessedEvent(MultiResourceLocation location, BufferedImage image)
    {
        this.location = location;
        this.image = image;
    }
}

==================================================

--- Файл №163 ---
Путь: main\java\mchorse\mclib\events\RegisterConfigEvent.java
--------------------
package mchorse.mclib.events;

import mchorse.mclib.config.Config;
import mchorse.mclib.config.ConfigBuilder;
import net.minecraftforge.fml.common.eventhandler.Event;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

public class RegisterConfigEvent extends Event
{
    public final File configs;
    public List<Config> modules = new ArrayList<Config>();

    public final ConfigBuilder opAccess;

    public RegisterConfigEvent(File configs)
    {
        this.configs = configs;

        this.opAccess = this.createBuilder("op_access", "mclib/op_access.json");
    }

    public ConfigBuilder createBuilder(String id)
    {
        ConfigBuilder builder = this.createBuilder(id, id + "/config.json");

        this.modules.add(builder.getConfig());

        return builder;
    }

    public ConfigBuilder createBuilder(String id, String path)
    {
        ConfigBuilder builder = new ConfigBuilder(id, new File(this.configs, path));

        this.modules.add(builder.getConfig());

        return builder;
    }
}

==================================================

--- Файл №164 ---
Путь: main\java\mchorse\mclib\events\RegisterDashboardPanels.java
--------------------
package mchorse.mclib.events;

import mchorse.mclib.client.gui.mclib.GuiAbstractDashboard;
import net.minecraftforge.fml.common.eventhandler.Event;

public class RegisterDashboardPanels extends Event
{
    public final GuiAbstractDashboard dashboard;

    public RegisterDashboardPanels(GuiAbstractDashboard dashboard)
    {
        this.dashboard = dashboard;
    }
}

==================================================

--- Файл №165 ---
Путь: main\java\mchorse\mclib\events\RegisterPermissionsEvent.java
--------------------
package mchorse.mclib.events;

import mchorse.mclib.McLib;
import mchorse.mclib.permissions.PermissionCategory;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.server.permission.DefaultPermissionLevel;
import net.minecraftforge.server.permission.PermissionAPI;

import java.util.ArrayList;
import java.util.List;

public class RegisterPermissionsEvent extends Event
{
    /**
     * List of the mods registered
     */
    private final List<PermissionCategory> mods = new ArrayList<>();
    /**
     * List of all permissions registered for fast access.
     */
    private final List<PermissionCategory> permissions = new ArrayList<>();

    private PermissionCategory currentMod;
    private PermissionCategory currentCategory;

    /**
     * Register a mod that holds permissions. This is necessary to register permissions or sub categories.
     * @param modid
     * @param level the default permission level.
     *              See {@link PermissionCategory#getDefaultPermission()} for implementation details how a level is inherited.
     */
    public void registerMod(String modid, DefaultPermissionLevel level)
    {
        this.currentMod = new PermissionCategory(modid, level);
        this.currentCategory = this.currentMod;

        this.mods.add(this.currentMod);
    }

    /**
     * register the provided permission category to the current category.
     * @param category
     * @throws UnsupportedOperationException if there is no current category
     */
    public void registerCategory(PermissionCategory category) throws UnsupportedOperationException
    {
        if (this.currentCategory == null) throw new UnsupportedOperationException("No current category to add this category to!");

        this.currentCategory.addChild(category);
        this.currentCategory = category;
    }

    /**
     * Register the permission at the last registered category
     * @param permission
     * @throws UnsupportedOperationException if no category is present to add the permission to
     */
    public void registerPermission(PermissionCategory permission) throws UnsupportedOperationException
    {
        if (this.currentCategory == null) throw new UnsupportedOperationException("No current category present to add the permission to!");

        this.currentCategory.addChild(permission);
        this.permissions.add(permission);
    }

    /**
     * Register the permissions in the API, see {@link PermissionAPI#registerNode(String, DefaultPermissionLevel, String)}
     * and register them into the permission factory {@link mchorse.mclib.McLib#permissionFactory}.
     */
    public void loadPermissions()
    {
        for (PermissionCategory permission : this.permissions)
        {
            if (permission.hasChildren()) continue;

            PermissionAPI.registerNode(permission.toString(), permission.getDefaultPermission(), "");
            McLib.permissionFactory.registerPermission(permission);
        }
    }

    /**
     * End the current registered category and return to the parent category, so new permissions can be registered.
     * If the current category is the mod category, then the mod category will be ended,
     * so the registering process can start over with a new mod.
     */
    public void endCategory()
    {
        if (this.currentCategory == this.currentMod)
        {
            this.currentMod = null;
            this.currentCategory = null;
        }
        else
        {
            this.currentCategory = this.currentCategory.getParent();
        }
    }

    public void endMod()
    {
        this.currentMod = null;
        this.currentCategory = null;
    }
}


==================================================

--- Файл №166 ---
Путь: main\java\mchorse\mclib\events\RemoveDashboardPanels.java
--------------------
package mchorse.mclib.events;

import net.minecraftforge.fml.common.eventhandler.Event;

public class RemoveDashboardPanels extends Event
{
    public RemoveDashboardPanels()
    {}
}

==================================================

--- Файл №167 ---
Путь: main\java\mchorse\mclib\events\RenderingHandler.java
--------------------
package mchorse.mclib.events;

import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;

public class RenderingHandler
{
    /**
     * Indicates whether Minecraft is rendering
     */
    private static boolean isRendering;

    public static boolean isMinecraftRendering()
    {
        return isRendering;
    }

    @SubscribeEvent
    public void onRenderTick(TickEvent.RenderTickEvent event)
    {
        if (event.phase == TickEvent.Phase.START)
        {
            isRendering = true;
        }

        if (event.phase == TickEvent.Phase.END)
        {
            isRendering = false;
        }
    }
}


==================================================

--- Файл №168 ---
Путь: main\java\mchorse\mclib\events\RenderOverlayEvent.java
--------------------
package mchorse.mclib.events;

import net.minecraft.client.Minecraft;
import net.minecraft.client.gui.ScaledResolution;
import net.minecraftforge.fml.common.eventhandler.Cancelable;
import net.minecraftforge.fml.common.eventhandler.Event;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

@Cancelable
@SideOnly(Side.CLIENT)
public abstract class RenderOverlayEvent extends Event
{
    public final Minecraft mc;
    public final ScaledResolution resolution;

    public RenderOverlayEvent(Minecraft mc, ScaledResolution resolution)
    {
        this.mc = mc;
        this.resolution = resolution;
    }

    public static class Pre extends RenderOverlayEvent
    {
        public Pre(Minecraft mc, ScaledResolution resolution)
        {
            super(mc, resolution);
        }
    }

    public static class Post extends RenderOverlayEvent
    {
        public Post(Minecraft mc, ScaledResolution resolution)
        {
            super(mc, resolution);
        }
    }
}

==================================================

--- Файл №169 ---
Путь: main\java\mchorse\mclib\math\Constant.java
--------------------
package mchorse.mclib.math;

/**
 * Constant class
 * 
 * This class simply returns supplied in the constructor value
 */
public class Constant implements IValue
{
    private double doubleValue;
    private String stringValue;

    public Constant(double doubleValue)
    {
        this.doubleValue = doubleValue;
    }

    public Constant(String stringValue)
    {
        this.stringValue = stringValue;
    }

    @Override
    public IValue get()
    {
        return this;
    }

    @Override
    public boolean isNumber()
    {
        return this.stringValue == null;
    }

    @Override
    public void set(double value)
    {
        this.doubleValue = value;
        this.stringValue = null;
    }

    @Override
    public void set(String value)
    {
        this.doubleValue = 0;
        this.stringValue = value;
    }

    @Override
    public double doubleValue()
    {
        return this.doubleValue;
    }

    @Override
    public boolean booleanValue()
    {
        if (this.isNumber())
        {
            return Operation.isTrue(this.doubleValue);
        }

        return this.stringValue.equalsIgnoreCase("true");
    }

    @Override
    public String stringValue()
    {
        return this.stringValue;
    }

    @Override
    public String toString()
    {
        return this.stringValue == null ? String.valueOf(this.doubleValue) : "\"" + this.stringValue + "\"";
    }
}

==================================================

--- Файл №170 ---
Путь: main\java\mchorse\mclib\math\Group.java
--------------------
package mchorse.mclib.math;

/**
 * Group class
 * 
 * Simply wraps given {@link IValue} into parenthesis in the 
 * {@link #toString()} method.
 */
public class Group implements IValue
{
    private IValue value;

    public Group(IValue value)
    {
        this.value = value;
    }

    @Override
    public IValue get()
    {
        return this.value.get();
    }

    @Override
    public boolean isNumber()
    {
        return this.value.isNumber();
    }

    @Override
    public void set(double value)
    {
        this.value.set(value);
    }

    @Override
    public void set(String value)
    {
        this.value.set(value);
    }

    @Override
    public double doubleValue()
    {
        return this.value.doubleValue();
    }

    @Override
    public boolean booleanValue()
    {
        return this.value.booleanValue();
    }

    @Override
    public String stringValue()
    {
        return this.value.stringValue();
    }

    @Override
    public String toString()
    {
        return "(" + this.value.toString() + ")";
    }
}

==================================================

--- Файл №171 ---
Путь: main\java\mchorse\mclib\math\IValue.java
--------------------
package mchorse.mclib.math;

/**
 * Math value interface
 * 
 * This interface provides only one method which is used by all 
 * mathematical related classes. The point of this interface is to 
 * provide generalized abstract method for computing/fetching some value 
 * from different mathematical classes.
 */
public interface IValue
{
    /**
     * Get computed or stored value 
     */
    public IValue get();

    public boolean isNumber();

    public void set(double value);

    public void set(String value);

    public double doubleValue();

    public boolean booleanValue();

    public String stringValue();
}

==================================================

--- Файл №172 ---
Путь: main\java\mchorse\mclib\math\MathBuilder.java
--------------------
package mchorse.mclib.math;

import mchorse.mclib.math.functions.Function;
import mchorse.mclib.math.functions.classic.Abs;
import mchorse.mclib.math.functions.classic.Exp;
import mchorse.mclib.math.functions.classic.Ln;
import mchorse.mclib.math.functions.classic.Mod;
import mchorse.mclib.math.functions.classic.Pow;
import mchorse.mclib.math.functions.classic.Sqrt;
import mchorse.mclib.math.functions.limit.Clamp;
import mchorse.mclib.math.functions.limit.Max;
import mchorse.mclib.math.functions.limit.Min;
import mchorse.mclib.math.functions.rounding.Ceil;
import mchorse.mclib.math.functions.rounding.Floor;
import mchorse.mclib.math.functions.rounding.Round;
import mchorse.mclib.math.functions.rounding.Trunc;
import mchorse.mclib.math.functions.string.StringContains;
import mchorse.mclib.math.functions.string.StringEndsWith;
import mchorse.mclib.math.functions.string.StringStartsWith;
import mchorse.mclib.math.functions.trig.Acos;
import mchorse.mclib.math.functions.trig.Asin;
import mchorse.mclib.math.functions.trig.Atan;
import mchorse.mclib.math.functions.trig.Atan2;
import mchorse.mclib.math.functions.trig.Cos;
import mchorse.mclib.math.functions.trig.Sin;
import mchorse.mclib.math.functions.utility.DieRoll;
import mchorse.mclib.math.functions.utility.DieRollInteger;
import mchorse.mclib.math.functions.utility.HermiteBlend;
import mchorse.mclib.math.functions.utility.Lerp;
import mchorse.mclib.math.functions.utility.LerpRotate;
import mchorse.mclib.math.functions.utility.Random;
import mchorse.mclib.math.functions.utility.RandomInteger;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Math builder
 * 
 * This class is responsible for parsing math expressions provided by 
 * user in a string to an {@link IValue} which can be used to compute 
 * some value dynamically using different math operators, variables and 
 * functions.
 * 
 * It works by first breaking down given string into a list of tokens 
 * and then putting them together in a binary tree-like {@link IValue}.
 * 
 * TODO: maybe implement constant pool (to reuse same values)?
 * TODO: maybe pre-compute constant expressions?
 */
public class MathBuilder
{
    /**
     * Named variables that can be used in math expression by this 
     * builder
     */
    public Map<String, Variable> variables = new HashMap<String, Variable>();

    /**
     * Map of functions which can be used in the math expressions
     */
    public Map<String, Class<? extends Function>> functions = new HashMap<String, Class<? extends Function>>();

    /**
     * Whether math expression parser should be strict about which characters
     * can be used within math expressions
     */
    protected boolean strict = true;

    public MathBuilder()
    {
        /* Some default values */
        this.register(new Variable("PI", Math.PI));
        this.register(new Variable("E", Math.E));

        /* Rounding functions */
        this.functions.put("floor", Floor.class);
        this.functions.put("round", Round.class);
        this.functions.put("ceil", Ceil.class);
        this.functions.put("trunc", Trunc.class);

        /* Selection and limit functions */
        this.functions.put("clamp", Clamp.class);
        this.functions.put("max", Max.class);
        this.functions.put("min", Min.class);

        /* Classical functions */
        this.functions.put("abs", Abs.class);
        this.functions.put("exp", Exp.class);
        this.functions.put("ln", Ln.class);
        this.functions.put("sqrt", Sqrt.class);
        this.functions.put("mod", Mod.class);
        this.functions.put("pow", Pow.class);

        /* Trig functions */
        this.functions.put("cos", Cos.class);
        this.functions.put("sin", Sin.class);
        this.functions.put("acos", Acos.class);
        this.functions.put("asin", Asin.class);
        this.functions.put("atan", Atan.class);
        this.functions.put("atan2", Atan2.class);

        /* Utility functions */
        this.functions.put("lerp", Lerp.class);
        this.functions.put("lerprotate", LerpRotate.class);
        this.functions.put("random", Random.class);
        this.functions.put("randomi", RandomInteger.class);
        this.functions.put("roll", DieRoll.class);
        this.functions.put("rolli", DieRollInteger.class);
        this.functions.put("hermite", HermiteBlend.class);

        /* String functions */
        this.functions.put("str_contains", StringContains.class);
        this.functions.put("str_starts", StringStartsWith.class);
        this.functions.put("str_ends", StringEndsWith.class);
    }

    public MathBuilder lenient()
    {
        this.strict = false;

        return this;
    }

    /**
     * Register a variable 
     */
    public void register(Variable variable)
    {
        this.variables.put(variable.getName(), variable);
    }

    /**
     * Parse given math expression into a {@link IValue} which can be 
     * used to execute math.
     */
    public IValue parse(String expression) throws Exception
    {
        return this.parseSymbols(this.breakdownChars(this.breakdown(expression)));
    }

    /**
     * Breakdown an expression
     */
    public String[] breakdown(String expression) throws Exception
    {
        /* If given string have illegal characters, then it can't be parsed */
        if (this.strict && !expression.matches("^[\\w\\d\\s_+-/*%^&|<>=!?:.,()\"'@~\\[\\]]+$"))
        {
            throw new Exception("Given expression '" + expression + "' contains illegal characters!");
        }

        String[] chars = expression.split("(?!^)");

        int left = 0;
        int right = 0;

        for (String s : chars)
        {
            if (s.equals("("))
            {
                left++;
            }
            else if (s.equals(")"))
            {
                right++;
            }
        }

        /* Amount of left and right brackets should be the same */
        if (left != right)
        {
            throw new Exception("Given expression '" + expression + "' has more uneven amount of parenthesis, there are " + left + " open and " + right + " closed!");
        }

        return chars;
    }

    /**
     * Breakdown characters into a list of math expression symbols. 
     */
    public List<Object> breakdownChars(String[] chars)
    {
        List<Object> symbols = new ArrayList<Object>();
        String buffer = "";
        int len = chars.length;
        boolean string = false;

        for (int i = 0; i < len; i++)
        {
            String s = chars[i];
            boolean longOperator = i < chars.length - 1 && this.isOperator(s + chars[i + 1]);

            if (s.equals("\""))
            {
                string = !string;
            }

            if (string)
            {
                buffer += s;
            }
            else if (this.isOperator(s) || longOperator || s.equals(","))
            {
                /* Taking care of a special case of using minus sign to 
                 * invert the positive value */
                if (s.equals("-"))
                {
                    int size = symbols.size();

                    boolean isEmpty = buffer.trim().isEmpty();
                    boolean isFirst = size == 0 && isEmpty;
                    boolean isOperatorBehind = size > 0 && (this.isOperator(symbols.get(size - 1)) || symbols.get(size - 1).equals(",")) && isEmpty;

                    if (isFirst || isOperatorBehind)
                    {
                        buffer += s;

                        continue;
                    }
                }

                /* Push buffer and operator */
                if (!buffer.isEmpty())
                {
                    symbols.add(buffer);
                    buffer = "";
                }

                if (longOperator)
                {
                    symbols.add(s + chars[i + 1]);
                    i += 1;
                }
                else
                {
                    symbols.add(s);
                }
            }
            else if (s.equals("("))
            {
                /* Push a list of symbols */
                if (!buffer.isEmpty())
                {
                    symbols.add(buffer);
                    buffer = "";
                }

                int counter = 1;

                for (int j = i + 1; j < len; j++)
                {
                    String c = chars[j];

                    if (c.equals("("))
                    {
                        counter++;
                    }
                    else if (c.equals(")"))
                    {
                        counter--;
                    }

                    if (counter == 0)
                    {
                        symbols.add(this.breakdownChars(buffer.split("(?!^)")));

                        i = j;
                        buffer = "";

                        break;
                    }
                    else
                    {
                        buffer += c;
                    }
                }
            }
            else
            {
                /* Accumulate the buffer */
                buffer += s;
            }
        }

        if (!buffer.isEmpty())
        {
            symbols.add(buffer);
        }

        return this.trimSymbols(symbols);
    }

    /**
     * Trims spaces from individual symbols
     */
    private List<Object> trimSymbols(List<Object> symbols)
    {
        List<Object> newSymbols = new ArrayList<Object>();

        for (int i = 0; i < symbols.size(); i++)
        {
            Object value = symbols.get(i);

            if (value instanceof String)
            {
                String string = ((String) value).trim();

                if (!string.isEmpty())
                {
                    newSymbols.add(string);
                }
            }
            else
            {
                newSymbols.add(this.trimSymbols((List) value));
            }
        }

        return newSymbols;
    }

    /**
     * Parse symbols
     * 
     * This function is the most important part of this class. It's 
     * responsible for turning list of symbols into {@link IValue}. This 
     * is done by constructing a binary tree-like {@link IValue} based on 
     * {@link Operator} class.
     * 
     * However, beside parsing operations, it's also can return one or 
     * two item sized symbol lists.
     */
    @SuppressWarnings("unchecked")
    public IValue parseSymbols(List<Object> symbols) throws Exception
    {
        IValue ternary = this.tryTernary(symbols);

        if (ternary != null)
        {
            return ternary;
        }

        int size = symbols.size();

        /* Constant, variable or group (parenthesis) */
        if (size == 1)
        {
            return this.valueFromObject(symbols.get(0));
        }

        /* Function */
        if (size == 2)
        {
            Object first = symbols.get(0);
            Object second = symbols.get(1);

            if ((this.isVariable(first) || first.equals("-")) && second instanceof List)
            {
                return this.createFunction((String) first, (List<Object>) second);
            }
        }

        /* Any other math expression */
        int lastOp = this.seekLastOperator(symbols);
        int op = lastOp;

        while (op != -1)
        {
            int leftOp = this.seekLastOperator(symbols, op - 1);

            if (leftOp != -1)
            {
                Operation left = this.operationForOperator((String) symbols.get(leftOp));
                Operation right = this.operationForOperator((String) symbols.get(op));

                if (right.value > left.value)
                {
                    IValue leftValue = this.parseSymbols(symbols.subList(0, leftOp));
                    IValue rightValue = this.parseSymbols(symbols.subList(leftOp + 1, size));

                    return new Operator(left, leftValue, rightValue);
                }
                else if (left.value > right.value)
                {
                    Operation initial = this.operationForOperator((String) symbols.get(lastOp));

                    if (initial.value < left.value)
                    {
                        IValue leftValue = this.parseSymbols(symbols.subList(0, lastOp));
                        IValue rightValue = this.parseSymbols(symbols.subList(lastOp + 1, size));

                        return new Operator(initial, leftValue, rightValue);
                    }

                    IValue leftValue = this.parseSymbols(symbols.subList(0, op));
                    IValue rightValue = this.parseSymbols(symbols.subList(op + 1, size));

                    return new Operator(right, leftValue, rightValue);
                }
            }

            op = leftOp;
        }

        Operation operation = this.operationForOperator((String) symbols.get(lastOp));

        return new Operator(operation, this.parseSymbols(symbols.subList(0, lastOp)), this.parseSymbols(symbols.subList(lastOp + 1, size)));
    }

    protected int seekLastOperator(List<Object> symbols)
    {
        return this.seekLastOperator(symbols, symbols.size() - 1);
    }

    /**
     * Find the index of the first operator
     */
    protected int seekLastOperator(List<Object> symbols, int offset)
    {
        for (int i = offset; i >= 0; i--)
        {
            Object o = symbols.get(i);

            if (this.isOperator(o))
            {
                /* - before a group isn't considered an operator per se */
                if (o.equals("-"))
                {
                    Object next = i < symbols.size() - 1 ? symbols.get(i + 1) : null;
                    Object prev = i > 0 ? symbols.get(i - 1) : null;

                    if (next instanceof List && (this.isOperator(prev) || prev == null))
                    {
                        continue;
                    }
                }

                return i;
            }
        }

        return -1;
    }

    /**
     * Try parsing a ternary expression
     *
     * From what we know, with ternary expressions, we should have only one ? and :,
     * and some elements from beginning till ?, in between ? and :, and also some
     * remaining elements after :.
     */
    protected IValue tryTernary(List<Object> symbols) throws Exception
    {
        int question = -1;
        int questions = 0;
        int colon = -1;
        int colons = 0;
        int size = symbols.size();

        for (int i = 0; i < size; i ++)
        {
            Object object = symbols.get(i);

            if (object instanceof String)
            {
                if (object.equals("?"))
                {
                    if (question == -1)
                    {
                        question = i;
                    }

                    questions ++;
                }
                else if (object.equals(":"))
                {
                    if (colons + 1 == questions && colon == -1)
                    {
                        colon = i;
                    }

                    colons ++;
                }
            }
        }

        if (questions == colons && question > 0 && question + 1 < colon && colon < size - 1)
        {
            return new Ternary(
                this.parseSymbols(symbols.subList(0, question)),
                this.parseSymbols(symbols.subList(question + 1, colon)),
                this.parseSymbols(symbols.subList(colon + 1, size))
            );
        }

        return null;
    }

    /**
     * Create a function value
     * 
     * This method in comparison to {@link #valueFromObject(Object)} 
     * needs the name of the function and list of args (which can't be 
     * stored in one object).
     * 
     * This method will constructs {@link IValue}s from list of args 
     * mixed with operators, groups, values and commas. And then plug it 
     * in to a class constructor with given name. 
     */
    protected IValue createFunction(String first, List<Object> args) throws Exception
    {
        /* Handle special cases with negation */
        if (first.equals("!"))
        {
            return new Negate(this.parseSymbols(args));
        }

        if (first.startsWith("!") && first.length() > 1)
        {
            return new Negate(this.createFunction(first.substring(1), args));
        }

        /* Handle inversion of the value */
        if (first.equals("-"))
        {
            return new Negative(new Group(this.parseSymbols(args)));
        }

        if (first.startsWith("-") && first.length() > 1)
        {
            return new Negative(this.createFunction(first.substring(1), args));
        }

        if (!this.functions.containsKey(first))
        {
            throw new Exception("Function '" + first + "' couldn't be found!");
        }

        List<IValue> values = new ArrayList<IValue>();
        List<Object> buffer = new ArrayList<Object>();

        for (Object o : args)
        {
            if (o.equals(","))
            {
                values.add(this.parseSymbols(buffer));
                buffer.clear();
            }
            else
            {
                buffer.add(o);
            }
        }

        if (!buffer.isEmpty())
        {
            values.add(this.parseSymbols(buffer));
        }

        Class<? extends Function> function = this.functions.get(first);
        Constructor<? extends Function> ctor = function.getConstructor(IValue[].class, String.class);
        Function func = ctor.newInstance(values.toArray(new IValue[values.size()]), first);

        return func;
    }

    /**
     * Get value from an object.
     * 
     * This method is responsible for creating different sort of values 
     * based on the input object. It can create constants, variables and 
     * groups. 
     */
    @SuppressWarnings("unchecked")
    public IValue valueFromObject(Object object) throws Exception
    {
        if (object instanceof String)
        {
            String symbol = (String) object;

            /* Variable and constant negation */
            if (symbol.startsWith("!"))
            {
                return new Negate(this.valueFromObject(symbol.substring(1)));
            }

            if (symbol.startsWith("\"") && symbol.endsWith("\""))
            {
                return new Constant(symbol.substring(1, symbol.length() - 1));
            }

            if (this.isDecimal(symbol))
            {
                return new Constant(Double.parseDouble(symbol));
            }
            else if (this.isVariable(symbol))
            {
                /* Need to account for a negative value variable */
                if (symbol.startsWith("-"))
                {
                    symbol = symbol.substring(1);
                    Variable value = this.getVariable(symbol);

                    if (value != null)
                    {
                        return new Negative(value);
                    }
                }
                else
                {
                    IValue value = this.getVariable(symbol);

                    /* Avoid NPE */
                    if (value != null)
                    {
                        return value;
                    }
                }
            }
        }
        else if (object instanceof List)
        {
            return new Group(this.parseSymbols((List<Object>) object));
        }

        throw new Exception("Given object couldn't be converted to value! " + object);
    }

    /**
     * Get variable
     */
    protected Variable getVariable(String name)
    {
        return this.variables.get(name);
    }

    /**
     * Get operation for given operator strings 
     */
    protected Operation operationForOperator(String op) throws Exception
    {
        for (Operation operation : Operation.values())
        {
            if (operation.sign.equals(op))
            {
                return operation;
            }
        }

        throw new Exception("There is no such operator '" + op + "'!");
    }

    /**
     * Whether given object is a variable 
     */
    protected boolean isVariable(Object o)
    {
        return o instanceof String && !this.isDecimal((String) o) && !this.isOperator((String) o);
    }

    protected boolean isOperator(Object o)
    {
        return o instanceof String && this.isOperator((String) o);
    }

    /**
     * Whether string is an operator 
     */
    protected boolean isOperator(String s)
    {
        return Operation.OPERATORS.contains(s) || s.equals("?") || s.equals(":");
    }

    /**
     * Whether string is numeric (including whether it's a floating 
     * number) 
     */
    protected boolean isDecimal(String s)
    {
        return s.matches("^-?\\d+(\\.\\d+)?$");
    }
}

==================================================

--- Файл №173 ---
Путь: main\java\mchorse\mclib\math\Negate.java
--------------------
package mchorse.mclib.math;

/**
 * Negate operator class
 *
 * This class is responsible for negating given value
 */
public class Negate extends Wrapper
{
    public Negate(IValue value)
    {
        super(value);
    }

    @Override
    protected void process()
    {
        this.result.set(this.doubleValue());
    }

    @Override
    public double doubleValue()
    {
        return this.booleanValue() ? 1 : 0;
    }

    @Override
    public boolean booleanValue()
    {
        return !this.value.booleanValue();
    }

    @Override
    public String toString()
    {
        return "!" + this.value.toString();
    }
}

==================================================

--- Файл №174 ---
Путь: main\java\mchorse\mclib\math\Negative.java
--------------------
package mchorse.mclib.math;

/**
 * Negative operator class
 *
 * This class is responsible for inverting given value
 */
public class Negative extends Wrapper
{
    public Negative(IValue value)
    {
        super(value);
    }

    @Override
    protected void process()
    {
        this.result.set(this.doubleValue());
    }

    @Override
    public double doubleValue()
    {
        return -this.value.doubleValue();
    }

    @Override
    public boolean booleanValue()
    {
        return Operation.isTrue(this.doubleValue());
    }

    @Override
    public String toString()
    {
        return "-" + this.value.toString();
    }
}

==================================================

--- Файл №175 ---
Путь: main\java\mchorse\mclib\math\Operation.java
--------------------
package mchorse.mclib.math;

import java.util.HashSet;
import java.util.Set;

/**
 * Operation enumeration
 * 
 * This enumeration provides different hardcoded enumerations of default 
 * math operators such addition, substraction, multiplication, division, 
 * modulo and power.
 * 
 * TODO: maybe convert to classes (for the sake of API)?
 */
public enum Operation
{
    ADD("+", 1)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a + b;
        }
    },
    SUB("-", 1)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a - b;
        }
    },
    MUL("*", 2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a * b;
        }
    },
    DIV("/", 2)
    {
        @Override
        public double calculate(double a, double b)
        {
            /* To avoid any exceptions */
            return a / (b == 0 ? 1 : b);
        }
    },
    MOD("%", 2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a % b;
        }
    },
    POW("^", 3)
    {
        @Override
        public double calculate(double a, double b)
        {
            return Math.pow(a, b);
        }
    },
    AND("&&", -3)
    {
        @Override
        public double calculate(double a, double b)
        {
            return isTrue(a) && isTrue(b) ? 1 : 0;
        }
    },
    OR("||", -3)
    {
        @Override
        public double calculate(double a, double b)
        {
            return isTrue(a) || isTrue(b) ? 1 : 0;
        }
    },
    SHIFT_LEFT("<<", 0)
    {
        @Override
        public double calculate(double a, double b)
        {
            return ((int) a) << ((int) b);
        }
    },
    SHIFT_RIGHT(">>", 0)
    {
        @Override
        public double calculate(double a, double b)
        {
            return ((int) a) >> ((int) b);
        }
    },
    BIT_AND("&", -1)
    {
        @Override
        public double calculate(double a, double b)
        {
            return ((int) a) & ((int) b);
        }
    },
    BIT_OR("|", -1)
    {
        @Override
        public double calculate(double a, double b)
        {
            return ((int) a) | ((int) b);
        }
    },
    BIT_XOR("^^", -1)
    {
        @Override
        public double calculate(double a, double b)
        {
            return ((int) a) ^ ((int) b);
        }
    },
    LESS("<", -2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a < b ? 1 : 0;
        }
    },
    LESS_THAN("<=", -2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a < b || equals(a, b) ? 1 : 0;
        }
    },
    GREATER_THAN(">=", -2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a > b || equals(a, b) ? 1 : 0;
        }
    },
    GREATER(">", -2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return a > b ? 1 : 0;
        }
    },
    EQUALS("==", -2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return equals(a, b) ? 1 : 0;
        }
    },
    NOT_EQUALS("!=", -2)
    {
        @Override
        public double calculate(double a, double b)
        {
            return !equals(a, b) ? 1 : 0;
        }
    };

    public final static Set<String> OPERATORS = new HashSet<String>();

    public static boolean equals(double a, double b)
    {
        return Math.abs(a - b) < 0.00001;
    }

    public static boolean isTrue(double value)
    {
        return !equals(value, 0);
    }

    static
    {
        for (Operation op : values())
        {
            OPERATORS.add(op.sign);
        }
    }

    /**
     * String-ified name of this operation  
     */
    public final String sign;

    /**
     * Value of this operation in relation to other operations (i.e 
     * precedence importance)  
     */
    public final int value;

    private Operation(String sign, int value)
    {
        this.sign = sign;
        this.value = value;
    }

    /**
     * Calculate the value based on given two doubles 
     */
    public abstract double calculate(double a, double b);
}

==================================================

--- Файл №176 ---
Путь: main\java\mchorse\mclib\math\Operator.java
--------------------
package mchorse.mclib.math;

/**
 * Operator class
 * 
 * This class is responsible for performing a calculation of two values 
 * based on given operation.
 */
public class Operator implements IValue
{
    public static boolean DEBUG = false;

    public Operation operation;
    public IValue a;
    public IValue b;
    private IValue result = new Constant(0);

    public Operator(Operation op, IValue a, IValue b)
    {
        this.operation = op;
        this.a = a;
        this.b = b;
    }

    @Override
    public IValue get()
    {
        if (!this.isNumber() && this.operation == Operation.ADD)
        {
            this.result.set(this.stringValue());
        }
        else
        {
            this.result.set(this.doubleValue());
        }

        return this.result;
    }

    @Override
    public boolean isNumber()
    {
        return this.a.isNumber() || this.b.isNumber();
    }

    @Override
    public void set(double value)
    {}

    @Override
    public void set(String value)
    {}

    @Override
    public double doubleValue()
    {
        if (!this.isNumber() && this.operation == Operation.EQUALS)
        {
            return this.a.stringValue().equals(this.b.stringValue()) ? 1 : 0;
        }

        return this.operation.calculate(this.a.doubleValue(), this.b.doubleValue());
    }

    @Override
    public boolean booleanValue()
    {
        return Operation.isTrue(this.doubleValue());
    }

    @Override
    public String stringValue()
    {
        if (this.operation == Operation.ADD)
        {
            return this.a.stringValue() + this.b.stringValue();
        }

        return this.a.stringValue();
    }

    @Override
    public String toString()
    {
        if (DEBUG)
        {
            return "(" + this.a.toString() + " " + this.operation.sign + " " + this.b.toString() + ")";
        }

        return this.a.toString() + " " + this.operation.sign + " " + this.b.toString();
    }
}

==================================================

--- Файл №177 ---
Путь: main\java\mchorse\mclib\math\Ternary.java
--------------------
package mchorse.mclib.math;

/**
 * Ternary operator class
 *
 * This value implementation allows to return different values depending on
 * given condition value
 */
public class Ternary implements IValue
{
    public IValue condition;
    public IValue ifTrue;
    public IValue ifFalse;

    private IValue result = new Constant(0);

    public Ternary(IValue condition, IValue ifTrue, IValue ifFalse)
    {
        this.condition = condition;
        this.ifTrue = ifTrue;
        this.ifFalse = ifFalse;
    }

    @Override
    public IValue get()
    {
        if (this.isNumber())
        {
            this.result.set(this.doubleValue());
        }
        else
        {
            this.result.set(this.stringValue());
        }

        return this.result;
    }

    @Override
    public boolean isNumber()
    {
        return this.ifFalse.isNumber() || this.ifTrue.isNumber();
    }

    @Override
    public void set(double value)
    {}

    @Override
    public void set(String value)
    {}

    @Override
    public double doubleValue()
    {
        return Operation.isTrue(this.condition.doubleValue()) ? this.ifTrue.doubleValue() : this.ifFalse.doubleValue();
    }

    @Override
    public boolean booleanValue()
    {
        return Operation.isTrue(this.doubleValue());
    }

    @Override
    public String stringValue()
    {
        return Operation.isTrue(this.condition.doubleValue()) ? this.ifTrue.stringValue() : this.ifFalse.stringValue();
    }

    @Override
    public String toString()
    {
        return this.condition.toString() + " ? " + this.ifTrue.toString() + " : " + this.ifFalse.toString();
    }
}

==================================================

--- Файл №178 ---
Путь: main\java\mchorse\mclib\math\Variable.java
--------------------
package mchorse.mclib.math;

/**
 * Variable class
 * 
 * This class is responsible for providing a mutable {@link IValue} 
 * which can be modifier during runtime and still getting referenced in 
 * the expressions parsed by {@link MathBuilder}.
 * 
 * But in practice, it's simply returns stored value and provides a 
 * method to modify it.
 */
public class Variable extends Constant
{
    private String name;

    public Variable(String name, double value)
    {
        super(value);

        this.name = name;
    }

    public Variable(String name, String value)
    {
        super(value);

        this.name = name;
    }

    public String getName()
    {
        return name;
    }

    @Override
    public String toString()
    {
        return this.name;
    }
}

==================================================

--- Файл №179 ---
Путь: main\java\mchorse\mclib\math\Wrapper.java
--------------------
package mchorse.mclib.math;

public abstract class Wrapper implements IValue
{
    public IValue value;

    protected IValue result = new Constant(0);

    public Wrapper(IValue value)
    {
        this.value = value;
    }

    @Override
    public IValue get()
    {
        this.process();

        return this.result;
    }

    protected abstract void process();

    @Override
    public boolean isNumber()
    {
        return this.value.isNumber();
    }

    @Override
    public void set(double value)
    {
        this.value.set(value);
    }

    @Override
    public void set(String value)
    {
        this.value.set(value);
    }

    @Override
    public double doubleValue()
    {
        return this.value.doubleValue();
    }

    @Override
    public boolean booleanValue()
    {
        return this.value.booleanValue();
    }

    @Override
    public String stringValue()
    {
        return this.value.stringValue();
    }
}


==================================================

--- Файл №180 ---
Путь: main\java\mchorse\mclib\math\functions\Function.java
--------------------
package mchorse.mclib.math.functions;

import mchorse.mclib.math.Constant;
import mchorse.mclib.math.IValue;

/**
 * Abstract function class
 * 
 * This class provides function capability (i.e. giving it arguments and 
 * upon {@link #get()} method you receive output).
 */
public abstract class Function implements IValue
{
    protected IValue[] args;
    protected String name;

    protected IValue result = new Constant(0);

    public Function(IValue[] values, String name) throws Exception
    {
        if (values.length < this.getRequiredArguments())
        {
            String message = String.format("Function '%s' requires at least %s arguments. %s are given!", this.getName(), this.getRequiredArguments(), values.length);

            throw new Exception(message);
        }

        for (int i = 0; i < values.length; i++)
        {
            this.verifyArgument(i, values[i]);
        }

        this.args = values;
        this.name = name;
    }

    protected void verifyArgument(int index, IValue value)
    {}

    @Override
    public void set(double value)
    {}

    @Override
    public void set(String value)
    {}

    /**
     * Get the value of nth argument 
     */
    public IValue getArg(int index)
    {
        if (index < 0 || index >= this.args.length)
        {
            throw new IllegalStateException("Index should be within the argument's length range! Given " + index + ", arguments length: " +this.args.length);
        }

        return this.args[index].get();
    }

    @Override
    public String toString()
    {
        String args = "";

        for (int i = 0; i < this.args.length; i++)
        {
            args += this.args[i].toString();

            if (i < this.args.length - 1)
            {
                args += ", ";
            }
        }

        return this.getName() + "(" + args + ")";
    }

    /**
     * Get name of this function 
     */
    public String getName()
    {
        return this.name;
    }

    /**
     * Get minimum count of arguments this function needs
     */
    public int getRequiredArguments()
    {
        return 0;
    }
}

==================================================

--- Файл №181 ---
Путь: main\java\mchorse\mclib\math\functions\NNFunction.java
--------------------
package mchorse.mclib.math.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.Operation;

/**
 * Function that expects number input arguments and outputs a number
 */
public abstract class NNFunction extends Function
{
    public NNFunction(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    protected void verifyArgument(int index, IValue value)
    {
        if (!value.isNumber())
        {
            throw new IllegalStateException("Function " + this.name + " cannot receive string arguments!");
        }
    }

    @Override
    public IValue get()
    {
        this.result.set(this.doubleValue());

        return this.result;
    }

    @Override
    public boolean isNumber()
    {
        return true;
    }

    @Override
    public boolean booleanValue()
    {
        return Operation.isTrue(this.doubleValue());
    }

    @Override
    public String stringValue()
    {
        return "";
    }
}


==================================================

--- Файл №182 ---
Путь: main\java\mchorse\mclib\math\functions\NSFunction.java
--------------------
package mchorse.mclib.math.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.Operation;

/**
 * Function that expects number input arguments and outputs a string
 */
public abstract class NSFunction extends Function
{
    public NSFunction(IValue[] values, String name) throws Exception
    {
        super(values, name);

        for (IValue value : values)
        {
            if (!value.isNumber())
            {
                throw new IllegalStateException("Function " + name + " cannot receive string arguments!");
            }
        }
    }

    @Override
    protected void verifyArgument(int index, IValue value)
    {
        if (!value.isNumber())
        {
            throw new IllegalStateException("Function " + this.name + " cannot receive string arguments!");
        }
    }

    @Override
    public IValue get()
    {
        this.result.set(this.stringValue());

        return this.result;
    }

    @Override
    public boolean isNumber()
    {
        return false;
    }

    @Override
    public double doubleValue()
    {
        return 0;
    }

    @Override
    public boolean booleanValue()
    {
        return this.stringValue().equalsIgnoreCase("true");
    }
}


==================================================

--- Файл №183 ---
Путь: main\java\mchorse\mclib\math\functions\SNFunction.java
--------------------
package mchorse.mclib.math.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.Operation;

/**
 * Function that expects string input arguments and outputs a number
 */
public abstract class SNFunction extends Function
{
    public SNFunction(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    protected void verifyArgument(int index, IValue value)
    {
        if (value.isNumber())
        {
            throw new IllegalStateException("Function " + this.name + " cannot receive number arguments!");
        }
    }

    @Override
    public IValue get()
    {
        this.result.set(this.doubleValue());

        return this.result;
    }

    @Override
    public boolean isNumber()
    {
        return true;
    }

    @Override
    public boolean booleanValue()
    {
        return Operation.isTrue(this.doubleValue());
    }

    @Override
    public String stringValue()
    {
        return "";
    }
}


==================================================

--- Файл №184 ---
Путь: main\java\mchorse\mclib\math\functions\SSFunction.java
--------------------
package mchorse.mclib.math.functions;

import mchorse.mclib.math.IValue;

/**
 * Function that expects string input arguments and outputs a string
 */
public abstract class SSFunction extends Function
{
    public SSFunction(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    protected void verifyArgument(int index, IValue value)
    {
        if (value.isNumber())
        {
            throw new IllegalStateException("Function " + this.name + " cannot receive number arguments!");
        }
    }

    @Override
    public IValue get()
    {
        this.result.set(this.stringValue());

        return this.result;
    }

    @Override
    public boolean isNumber()
    {
        return false;
    }

    @Override
    public double doubleValue()
    {
        return 0;
    }

    @Override
    public boolean booleanValue()
    {
        return this.stringValue().equalsIgnoreCase("true");
    }
}


==================================================

--- Файл №185 ---
Путь: main\java\mchorse\mclib\math\functions\classic\Abs.java
--------------------
package mchorse.mclib.math.functions.classic;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

/**
 * Absolute value function 
 */
public class Abs extends NNFunction
{
    public Abs(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.abs(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №186 ---
Путь: main\java\mchorse\mclib\math\functions\classic\Exp.java
--------------------
package mchorse.mclib.math.functions.classic;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Exp extends NNFunction
{
    public Exp(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.exp(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №187 ---
Путь: main\java\mchorse\mclib\math\functions\classic\Ln.java
--------------------
package mchorse.mclib.math.functions.classic;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Ln extends NNFunction
{
    public Ln(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.log(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №188 ---
Путь: main\java\mchorse\mclib\math\functions\classic\Mod.java
--------------------
package mchorse.mclib.math.functions.classic;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Mod extends NNFunction
{
    public Mod(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return this.getArg(0).doubleValue() % this.getArg(1).doubleValue();
    }
}

==================================================

--- Файл №189 ---
Путь: main\java\mchorse\mclib\math\functions\classic\Pow.java
--------------------
package mchorse.mclib.math.functions.classic;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Pow extends NNFunction
{
    public Pow(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return Math.pow(this.getArg(0).doubleValue(), this.getArg(1).doubleValue());
    }
}

==================================================

--- Файл №190 ---
Путь: main\java\mchorse\mclib\math\functions\classic\Sqrt.java
--------------------
package mchorse.mclib.math.functions.classic;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Sqrt extends NNFunction
{
    public Sqrt(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.sqrt(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №191 ---
Путь: main\java\mchorse\mclib\math\functions\limit\Clamp.java
--------------------
package mchorse.mclib.math.functions.limit;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;
import mchorse.mclib.utils.MathUtils;

public class Clamp extends NNFunction
{
    public Clamp(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 3;
    }

    @Override
    public double doubleValue()
    {
        return MathUtils.clamp(this.getArg(0).doubleValue(), this.getArg(1).doubleValue(), this.getArg(2).doubleValue());
    }
}

==================================================

--- Файл №192 ---
Путь: main\java\mchorse\mclib\math\functions\limit\Max.java
--------------------
package mchorse.mclib.math.functions.limit;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Max extends NNFunction
{
    public Max(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return Math.max(this.getArg(0).doubleValue(), this.getArg(1).doubleValue());
    }
}

==================================================

--- Файл №193 ---
Путь: main\java\mchorse\mclib\math\functions\limit\Min.java
--------------------
package mchorse.mclib.math.functions.limit;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Min extends NNFunction
{
    public Min(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return Math.min(this.getArg(0).doubleValue(), this.getArg(1).doubleValue());
    }
}

==================================================

--- Файл №194 ---
Путь: main\java\mchorse\mclib\math\functions\rounding\Ceil.java
--------------------
package mchorse.mclib.math.functions.rounding;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Ceil extends NNFunction
{
    public Ceil(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.ceil(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №195 ---
Путь: main\java\mchorse\mclib\math\functions\rounding\Floor.java
--------------------
package mchorse.mclib.math.functions.rounding;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Floor extends NNFunction
{
    public Floor(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.floor(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №196 ---
Путь: main\java\mchorse\mclib\math\functions\rounding\Round.java
--------------------
package mchorse.mclib.math.functions.rounding;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Round extends NNFunction
{
    public Round(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.round(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №197 ---
Путь: main\java\mchorse\mclib\math\functions\rounding\Trunc.java
--------------------
package mchorse.mclib.math.functions.rounding;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Trunc extends NNFunction
{
    public Trunc(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        double value = this.getArg(0).doubleValue();

        return value < 0 ? Math.ceil(value) : Math.floor(value);
    }
}

==================================================

--- Файл №198 ---
Путь: main\java\mchorse\mclib\math\functions\string\StringContains.java
--------------------
package mchorse.mclib.math.functions.string;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.SNFunction;

public class StringContains extends SNFunction
{
    public StringContains(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return this.getArg(0).stringValue().contains(this.getArg(1).stringValue()) ? 1 : 0;
    }
}


==================================================

--- Файл №199 ---
Путь: main\java\mchorse\mclib\math\functions\string\StringEndsWith.java
--------------------
package mchorse.mclib.math.functions.string;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.SNFunction;

public class StringEndsWith extends SNFunction
{
    public StringEndsWith(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return this.getArg(0).stringValue().endsWith(this.getArg(1).stringValue()) ? 1 : 0;
    }
}


==================================================

--- Файл №200 ---
Путь: main\java\mchorse\mclib\math\functions\string\StringStartsWith.java
--------------------
package mchorse.mclib.math.functions.string;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.SNFunction;

public class StringStartsWith extends SNFunction
{
    public StringStartsWith(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return this.getArg(0).stringValue().startsWith(this.getArg(1).stringValue()) ? 1 : 0;
    }
}


==================================================

--- Файл №201 ---
Путь: main\java\mchorse\mclib\math\functions\trig\Acos.java
--------------------
package mchorse.mclib.math.functions.trig;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Acos extends NNFunction
{
    public Acos(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.acos(this.getArg(0).doubleValue());
    }
}


==================================================

--- Файл №202 ---
Путь: main\java\mchorse\mclib\math\functions\trig\Asin.java
--------------------
package mchorse.mclib.math.functions.trig;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Asin extends NNFunction
{
    public Asin(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.asin(this.getArg(0).doubleValue());
    }
}


==================================================

--- Файл №203 ---
Путь: main\java\mchorse\mclib\math\functions\trig\Atan.java
--------------------
package mchorse.mclib.math.functions.trig;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Atan extends NNFunction
{
    public Atan(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.atan(this.getArg(0).doubleValue());
    }
}


==================================================

--- Файл №204 ---
Путь: main\java\mchorse\mclib\math\functions\trig\Atan2.java
--------------------
package mchorse.mclib.math.functions.trig;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Atan2 extends NNFunction
{
    public Atan2(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 2;
    }

    @Override
    public double doubleValue()
    {
        return Math.atan2(this.getArg(0).doubleValue(), this.getArg(1).doubleValue());
    }
}


==================================================

--- Файл №205 ---
Путь: main\java\mchorse\mclib\math\functions\trig\Cos.java
--------------------
package mchorse.mclib.math.functions.trig;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Cos extends NNFunction
{
    public Cos(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.cos(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №206 ---
Путь: main\java\mchorse\mclib\math\functions\trig\Sin.java
--------------------
package mchorse.mclib.math.functions.trig;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Sin extends NNFunction
{
    public Sin(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.sin(this.getArg(0).doubleValue());
    }
}

==================================================

--- Файл №207 ---
Путь: main\java\mchorse\mclib\math\functions\utility\DieRoll.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class DieRoll extends NNFunction
{
    public static double rollDie(int num, double min, double max)
    {
        double m = Math.max(max, min);
        double n = Math.min(max, min);

        double sum = 0;

        for (int i = 0; i < num; i++)
        {
            sum += Math.random() * (m - n) + n;
        }

        return sum;
    }

    public DieRoll(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 3;
    }

    @Override
    public double doubleValue()
    {
        return rollDie((int) this.getArg(0).doubleValue(), this.getArg(1).doubleValue(), this.getArg(2).doubleValue());
    }
}

==================================================

--- Файл №208 ---
Путь: main\java\mchorse\mclib\math\functions\utility\DieRollInteger.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.Function;

public class DieRollInteger extends DieRoll
{
    public DieRollInteger(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public double doubleValue()
    {
        return (int) super.doubleValue();
    }
}

==================================================

--- Файл №209 ---
Путь: main\java\mchorse\mclib\math\functions\utility\HermiteBlend.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class HermiteBlend extends NNFunction
{
    public HermiteBlend(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        double x = this.getArg(0).doubleValue();

        return 3 * x * x - 2 * x * x * x;
    }
}

==================================================

--- Файл №210 ---
Путь: main\java\mchorse\mclib\math\functions\utility\Lerp.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;
import mchorse.mclib.utils.Interpolations;

public class Lerp extends NNFunction
{
    public Lerp(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 3;
    }

    @Override
    public double doubleValue()
    {
        return Interpolations.lerp(this.getArg(0).doubleValue(), this.getArg(1).doubleValue(), this.getArg(2).doubleValue());
    }
}

==================================================

--- Файл №211 ---
Путь: main\java\mchorse\mclib\math\functions\utility\LerpRotate.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;
import mchorse.mclib.utils.Interpolations;

public class LerpRotate extends NNFunction
{
    public LerpRotate(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 3;
    }

    @Override
    public double doubleValue()
    {
        return Interpolations.lerpYaw(this.getArg(0).doubleValue(), this.getArg(1).doubleValue(), this.getArg(2).doubleValue());
    }
}

==================================================

--- Файл №212 ---
Путь: main\java\mchorse\mclib\math\functions\utility\Random.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class Random extends NNFunction
{
    public java.util.Random random;

    public Random(IValue[] values, String name) throws Exception
    {
        super(values, name);

        this.random = new java.util.Random();
    }

    @Override
    public double doubleValue()
    {
        double random;

        if (this.args.length >= 3)
        {
            this.random.setSeed((long) this.getArg(2).doubleValue());
            random = this.random.nextDouble();
        }
        else
        {
            random = Math.random();
        }

        if (this.args.length >= 2)
        {
            double a = this.getArg(0).doubleValue();
            double b = this.getArg(1).doubleValue();

            double min = Math.min(a, b);
            double max = Math.max(a, b);

            random = random * (max - min) + min;
        }
        else if (this.args.length >= 1)
        {
            random = random * this.getArg(0).doubleValue();
        }

        return random;
    }
}

==================================================

--- Файл №213 ---
Путь: main\java\mchorse\mclib\math\functions\utility\RandomInteger.java
--------------------
package mchorse.mclib.math.functions.utility;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.Function;

public class RandomInteger extends Random
{
    public RandomInteger(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public double doubleValue()
    {
        return (int) super.doubleValue();
    }
}

==================================================

--- Файл №214 ---
Путь: main\java\mchorse\mclib\math\molang\MolangException.java
--------------------
package mchorse.mclib.math.molang;

public class MolangException extends Exception
{
    public MolangException(String message)
    {
        super(message);
    }
}

==================================================

--- Файл №215 ---
Путь: main\java\mchorse\mclib\math\molang\MolangParser.java
--------------------
package mchorse.mclib.math.molang;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.MathBuilder;
import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.expressions.MolangAssignment;
import mchorse.mclib.math.molang.expressions.MolangExpression;
import mchorse.mclib.math.molang.expressions.MolangMultiStatement;
import mchorse.mclib.math.molang.expressions.MolangValue;
import mchorse.mclib.math.molang.functions.AcosDegrees;
import mchorse.mclib.math.molang.functions.AsinDegrees;
import mchorse.mclib.math.molang.functions.Atan2Degrees;
import mchorse.mclib.math.molang.functions.AtanDegrees;
import mchorse.mclib.math.molang.functions.CosDegrees;
import mchorse.mclib.math.molang.functions.SinDegrees;

import java.util.ArrayList;
import java.util.List;

/**
 * MoLang parser
 *
 * This bad boy parses Molang expressions
 *
 * @link https://bedrock.dev/1.14.0.0/1.14.2.50/MoLang
 */
public class MolangParser extends MathBuilder
{
    public static final MolangExpression ZERO = new MolangValue(null, new Constant(0));
    public static final MolangExpression ONE = new MolangValue(null, new Constant(1));
    public static final String RETURN = "return ";

    private MolangMultiStatement currentStatement;
    private boolean registerAsGlobals;

    public MolangParser()
    {
        super();

        /* Replace radian based sin and cos with degreebased */
        this.functions.put("cos", CosDegrees.class);
        this.functions.put("sin", SinDegrees.class);
        this.functions.put("acos", AcosDegrees.class);
        this.functions.put("asin", AsinDegrees.class);
        this.functions.put("atan", AtanDegrees.class);
        this.functions.put("atan2", Atan2Degrees.class);

        /* Remap functions to be in tact with Molang specification */
        this.remap("abs", "math.abs");
        this.remap("ceil", "math.ceil");
        this.remap("clamp", "math.clamp");
        this.remap("cos", "math.cos");
        this.remap("exp", "math.exp");
        this.remap("floor", "math.floor");
        this.remap("lerp", "math.lerp");
        this.remap("lerprotate", "math.lerprotate");
        this.remap("ln", "math.ln");
        this.remap("max", "math.max");
        this.remap("min", "math.min");
        this.remap("mod", "math.mod");
        this.remap("pow", "math.pow");
        this.remap("random", "math.random");
        this.remap("round", "math.round");
        this.remap("sin", "math.sin");
        this.remap("sqrt", "math.sqrt");
        this.remap("trunc", "math.trunc");

        /* New functions in 1.16 */
        this.remap("acos", "math.acos");
        this.remap("asin", "math.asin");
        this.remap("atan", "math.atan");
        this.remap("atan2", "math.atan2");
        this.remap("randomi", "math.random_integer");
        this.remap("roll", "math.die_roll");
        this.remap("rolli", "math.die_roll_integer");
        this.remap("hermite", "math.hermite_blend");

        /* Remap variables as well */
        this.remapVar("PI", "math.pi");
    }

    /**
     * Remap function names
     */
    public void remap(String old, String newName)
    {
        this.functions.put(newName, this.functions.remove(old));
    }

    /**
     * Remap variable names
     */
    public void remapVar(String old, String newName)
    {
        this.variables.put(newName, this.variables.remove(old));
    }

    public void setValue(String name, double value)
    {
        Variable variable = this.getVariable(name);

        if (variable != null)
        {
            variable.set(value);
        }
    }

    /**
     * Interactively return a new variable
     */
    @Override
    protected Variable getVariable(String name)
    {
        Variable variable = this.currentStatement == null ? null : this.currentStatement.locals.get(name);

        if (variable == null)
        {
            variable = super.getVariable(name);
        }

        if (variable == null)
        {
            variable = new Variable(name, 0);

            this.register(variable);
        }

        return variable;
    }

    public MolangExpression parseJson(JsonElement element) throws MolangException
    {
        if (element.isJsonPrimitive())
        {
            JsonPrimitive primitive = element.getAsJsonPrimitive();

            if (primitive.isString())
            {
                try
                {
                    return new MolangValue(this, new Constant(Double.parseDouble(primitive.getAsString())));
                }
                catch (Exception e)
                {}

                return this.parseExpression(primitive.getAsString());
            }
            else
            {
                return new MolangValue(this, new Constant(primitive.getAsDouble()));
            }
        }

        return ZERO;
    }

    public MolangExpression parseGlobalJson(JsonElement element) throws MolangException
    {
        this.registerAsGlobals = true;

        MolangExpression expression = parseJson(element);

        this.registerAsGlobals = false;

        return expression;
    }

    /**
     * Parse a molang expression
     */
    public MolangExpression parseExpression(String expression) throws MolangException
    {
        List<String> lines = new ArrayList<String>();

        for (String split : expression.toLowerCase().trim().split(";"))
        {
            if (!split.trim().isEmpty())
            {
                lines.add(split);
            }
        }

        if (lines.size() == 0)
        {
            throw new MolangException("Molang expression cannot be blank!");
        }

        MolangMultiStatement result = new MolangMultiStatement(this);

        this.currentStatement = result;

        try
        {
            for (String line : lines)
            {
                result.expressions.add(this.parseOneLine(line));
            }
        }
        catch (Exception e)
        {
            this.currentStatement = null;

            throw e;
        }

        this.currentStatement = null;

        return result;
    }

    /**
     * Parse a single Molang statement
     */
    protected MolangExpression parseOneLine(String expression) throws MolangException
    {
        expression = expression.trim();

        if (expression.startsWith(RETURN))
        {
            try
            {
                return new MolangValue(this, this.parse(expression.substring(RETURN.length()))).addReturn();
            }
            catch (Exception e)
            {
                throw new MolangException("Couldn't parse return '" + expression + "' expression!");
            }
        }

        try
        {
            List<Object> symbols = this.breakdownChars(this.breakdown(expression));

            /* Assignment it is */
            if (symbols.size() >= 3 && symbols.get(0) instanceof String && this.isVariable(symbols.get(0)) && symbols.get(1).equals("="))
            {
                String name = (String) symbols.get(0);
                symbols = symbols.subList(2, symbols.size());

                Variable variable = null;

                if (!this.registerAsGlobals && !this.variables.containsKey(name) && !this.currentStatement.locals.containsKey(name))
                {
                    variable = new Variable(name, 0);
                    this.currentStatement.locals.put(name, variable);
                }
                else
                {
                    variable = this.getVariable(name);
                }

                return new MolangAssignment(this, variable, this.parseSymbolsMolang(symbols));
            }

            return new MolangValue(this, this.parseSymbolsMolang(symbols));
        }
        catch (Exception e)
        {
            throw new MolangException("Couldn't parse '" + expression + "' expression!");
        }
    }

    /**
     * Wrapper around {@link #parseSymbols(List)} to throw {@link MolangException}
     */
    private IValue parseSymbolsMolang(List<Object> symbols) throws MolangException
    {
        try
        {
            return this.parseSymbols(symbols);
        }
        catch (Exception e)
        {
            e.printStackTrace();

            throw new MolangException("Couldn't parse an expression!");
        }
    }

    /**
     * Extend this method to allow {@link #breakdownChars(String[])} to capture
     * "=" as an operator so it was easier to parse assignment statements
     */
    @Override
    protected boolean isOperator(String s)
    {
        return super.isOperator(s) || s.equals("=");
    }
}

==================================================

--- Файл №216 ---
Путь: main\java\mchorse\mclib\math\molang\expressions\MolangAssignment.java
--------------------
package mchorse.mclib.math.molang.expressions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangParser;

public class MolangAssignment extends MolangExpression
{
    public Variable variable;
    public IValue expression;

    public MolangAssignment(MolangParser context, Variable variable, IValue expression)
    {
        super(context);

        this.variable = variable;
        this.expression = expression;
    }

    @Override
    public double get()
    {
        double value = this.expression.get().doubleValue();

        this.variable.set(value);

        return value;
    }

    @Override
    public String toString()
    {
        return this.variable.getName() + " = " + this.expression.toString();
    }
}

==================================================

--- Файл №217 ---
Путь: main\java\mchorse\mclib\math\molang\expressions\MolangExpression.java
--------------------
package mchorse.mclib.math.molang.expressions;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.Operation;
import mchorse.mclib.math.molang.MolangParser;

public abstract class MolangExpression
{
    public MolangParser context;

    public static boolean isZero(MolangExpression expression)
    {
        return isConstant(expression, 0);
    }

    public static boolean isOne(MolangExpression expression)
    {
        return isConstant(expression, 1);
    }

    public static boolean isConstant(MolangExpression expression, double x)
    {
        if (expression instanceof MolangValue)
        {
            MolangValue value = (MolangValue) expression;

            return value.value instanceof Constant && Operation.equals(value.value.get().doubleValue(), x);
        }

        return false;
    }

    public static boolean isExpressionConstant(MolangExpression expression)
    {
        if (expression instanceof MolangValue)
        {
            MolangValue value = (MolangValue) expression;

            return value.value instanceof Constant;
        }

        return false;
    }

    public MolangExpression(MolangParser context)
    {
        this.context = context;
    }

    public abstract double get();

    public JsonElement toJson()
    {
        return new JsonPrimitive(this.toString());
    }
}

==================================================

--- Файл №218 ---
Путь: main\java\mchorse\mclib\math\molang\expressions\MolangMultiStatement.java
--------------------
package mchorse.mclib.math.molang.expressions;

import mchorse.mclib.math.Variable;
import mchorse.mclib.math.molang.MolangParser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.StringJoiner;

public class MolangMultiStatement extends MolangExpression
{
    public List<MolangExpression> expressions = new ArrayList<MolangExpression>();
    public Map<String, Variable> locals = new HashMap<String, Variable>();

    public MolangMultiStatement(MolangParser context)
    {
        super(context);
    }

    @Override
    public double get()
    {
        double value = 0;

        for (MolangExpression expression : this.expressions)
        {
            value = expression.get();

            if (expression instanceof MolangValue && ((MolangValue) expression).returns)
            {
                break;
            }
        }

        return value;
    }

    @Override
    public String toString()
    {
        StringJoiner builder = new StringJoiner("; ");

        for (MolangExpression expression : this.expressions)
        {
            builder.add(expression.toString());
        }

        return builder.toString();
    }
}

==================================================

--- Файл №219 ---
Путь: main\java\mchorse\mclib\math\molang\expressions\MolangValue.java
--------------------
package mchorse.mclib.math.molang.expressions;

import com.google.gson.JsonElement;
import com.google.gson.JsonPrimitive;
import mchorse.mclib.math.Constant;
import mchorse.mclib.math.IValue;
import mchorse.mclib.math.molang.MolangParser;

public class MolangValue extends MolangExpression
{
    public IValue value;
    public boolean returns;

    public MolangValue(MolangParser context, IValue value)
    {
        super(context);

        this.value = value;
    }

    public MolangExpression addReturn()
    {
        this.returns = true;

        return this;
    }

    @Override
    public double get()
    {
        return this.value.get().doubleValue();
    }

    @Override
    public String toString()
    {
        return (this.returns ? MolangParser.RETURN : "") + this.value.toString();
    }

    @Override
    public JsonElement toJson()
    {
        if (this.value instanceof Constant)
        {
            return new JsonPrimitive(this.value.get().doubleValue());
        }

        return super.toJson();
    }
}

==================================================

--- Файл №220 ---
Путь: main\java\mchorse\mclib\math\molang\functions\AcosDegrees.java
--------------------
package mchorse.mclib.math.molang.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.trig.Acos;

public class AcosDegrees extends Acos
{
    public AcosDegrees(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public double doubleValue()
    {
        return super.doubleValue() / Math.PI * 180;
    }
}

==================================================

--- Файл №221 ---
Путь: main\java\mchorse\mclib\math\molang\functions\AsinDegrees.java
--------------------
package mchorse.mclib.math.molang.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.trig.Asin;

public class AsinDegrees extends Asin
{
    public AsinDegrees(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public double doubleValue()
    {
        return super.doubleValue() / Math.PI * 180;
    }
}

==================================================

--- Файл №222 ---
Путь: main\java\mchorse\mclib\math\molang\functions\Atan2Degrees.java
--------------------
package mchorse.mclib.math.molang.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.trig.Atan2;

public class Atan2Degrees extends Atan2
{
    public Atan2Degrees(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public double doubleValue()
    {
        return super.doubleValue() / Math.PI * 180;
    }
}

==================================================

--- Файл №223 ---
Путь: main\java\mchorse\mclib\math\molang\functions\AtanDegrees.java
--------------------
package mchorse.mclib.math.molang.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.trig.Atan;

public class AtanDegrees extends Atan
{
    public AtanDegrees(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public double doubleValue()
    {
        return super.doubleValue() / Math.PI * 180;
    }
}

==================================================

--- Файл №224 ---
Путь: main\java\mchorse\mclib\math\molang\functions\CosDegrees.java
--------------------
package mchorse.mclib.math.molang.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class CosDegrees extends NNFunction
{
    public CosDegrees(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.cos(this.getArg(0).doubleValue() / 180 * Math.PI);
    }
}

==================================================

--- Файл №225 ---
Путь: main\java\mchorse\mclib\math\molang\functions\SinDegrees.java
--------------------
package mchorse.mclib.math.molang.functions;

import mchorse.mclib.math.IValue;
import mchorse.mclib.math.functions.NNFunction;

public class SinDegrees extends NNFunction
{
    public SinDegrees(IValue[] values, String name) throws Exception
    {
        super(values, name);
    }

    @Override
    public int getRequiredArguments()
    {
        return 1;
    }

    @Override
    public double doubleValue()
    {
        return Math.sin(this.getArg(0).doubleValue() / 180 * Math.PI);
    }
}

==================================================

--- Файл №226 ---
Путь: main\java\mchorse\mclib\network\AbstractDispatcher.java
--------------------
package mchorse.mclib.network;

import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityTracker;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.world.WorldServer;
import net.minecraftforge.fml.common.network.NetworkRegistry;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.SimpleNetworkWrapper;
import net.minecraftforge.fml.relauncher.Side;

/**
 * Network dispatcher
 *
 * @author Ernio (Ernest Sadowski)
 */
public abstract class AbstractDispatcher
{
    private final SimpleNetworkWrapper dispatcher;
    private byte nextPacketID;

    public AbstractDispatcher(String modID)
    {
        this.dispatcher = NetworkRegistry.INSTANCE.newSimpleChannel(modID);
    }

    public SimpleNetworkWrapper get()
    {
        return this.dispatcher;
    }

    /**
     * Here you supposed to register packets to handlers 
     */
    public abstract void register();

    /**
     * Send message to players who are tracking given entity
     */
    public void sendToTracked(Entity entity, IMessage message)
    {
        EntityTracker tracker = ((WorldServer) entity.world).getEntityTracker();

        for (EntityPlayer player : tracker.getTrackingPlayers(entity))
        {
            this.dispatcher.sendTo(message, (EntityPlayerMP) player);
        }
    }

    /**
     * Send message to given player
     */
    public void sendTo(IMessage message, EntityPlayerMP player)
    {
        this.dispatcher.sendTo(message, player);
    }

    /**
     * Send message to all players
     * @param message
     */
    public void sendToAll(IMessage message)
    {
        this.dispatcher.sendToAll(message);
    }

    /**
     * Send message to all players around the given point
     * @param message
     * @param point The {@link NetworkRegistry.TargetPoint} around which to send
     */
    public void sendToAllAround(IMessage message, NetworkRegistry.TargetPoint point)
    {
        this.dispatcher.sendToAllAround(message, point);
    }

    /**
     * Send message to the server
     */
    public void sendToServer(IMessage message)
    {
        this.dispatcher.sendToServer(message);
    }

    /**
     * Register given message with given message handler on a given side
     */
    public <REQ extends IMessage, REPLY extends IMessage> void register(Class<REQ> message, Class<? extends IMessageHandler<REQ, REPLY>> handler, Side side)
    {
        this.dispatcher.registerMessage(handler, message, this.nextPacketID++, side);
    }
}

==================================================

--- Файл №227 ---
Путь: main\java\mchorse\mclib\network\AbstractMessageHandler.java
--------------------
package mchorse.mclib.network;

import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.common.network.simpleimpl.IMessageHandler;
import net.minecraftforge.fml.common.network.simpleimpl.MessageContext;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * Base of all MessageHandlers.
 *
 * @author Ernio (Ernest Sadowski)
 */
public abstract class AbstractMessageHandler<T extends IMessage> implements IMessageHandler<T, IMessage>
{
    /**
     * Handle a message received on the client side
     *
     * @return a message to send back to the Server, or null if no reply is
     *         necessary
     */
    @SideOnly(Side.CLIENT)
    public abstract IMessage handleClientMessage(final T message);

    /**
     * Handle a message received on the server side
     *
     * @return a message to send back to the Client, or null if no reply is
     *         necessary
     */
    public abstract IMessage handleServerMessage(final EntityPlayerMP player, final T message);

    @Override
    public IMessage onMessage(T message, MessageContext ctx)
    {
        if (ctx.side.isClient())
        {
            return this.handleClientMessage(message);
        }
        else
        {
            return this.handleServerMessage(ctx.getServerHandler().player, message);
        }
    }
}

==================================================

--- Файл №228 ---
Путь: main\java\mchorse\mclib\network\ClientMessageHandler.java
--------------------
package mchorse.mclib.network;

import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

/**
 * This class passes operation from Netty to Minecraft (Client) Thread. Also
 * prevents the server-side message handling method from appearing in client
 * message handler classes.
 *
 * @author Ernio (Ernest Sadowski)
 */
public abstract class ClientMessageHandler<T extends IMessage> extends AbstractMessageHandler<T>
{
    @SideOnly(Side.CLIENT)
    public abstract void run(final EntityPlayerSP player, final T message);

    @Override
    @SideOnly(Side.CLIENT)
    public IMessage handleClientMessage(final T message)
    {
        Minecraft.getMinecraft().addScheduledTask(new Runnable()
        {
            @Override
            public void run()
            {
                ClientMessageHandler.this.run(Minecraft.getMinecraft().player, message);
            }
        });

        return null;
    }

    @Override
    public final IMessage handleServerMessage(final EntityPlayerMP player, final T message)
    {
        return null;
    }
}

==================================================

--- Файл №229 ---
Путь: main\java\mchorse\mclib\network\IByteBufSerializable.java
--------------------
package mchorse.mclib.network;

import io.netty.buffer.ByteBuf;

public interface IByteBufSerializable
{
    public void fromBytes(ByteBuf buffer);

    public void toBytes(ByteBuf buffer);
}


==================================================

--- Файл №230 ---
Путь: main\java\mchorse\mclib\network\INBTSerializable.java
--------------------
package mchorse.mclib.network;

import net.minecraft.nbt.NBTTagCompound;

public interface INBTSerializable
{
    public void fromNBT(NBTTagCompound tag);

    public NBTTagCompound toNBT(NBTTagCompound tag);

    public default NBTTagCompound toNBT()
    {
        return this.toNBT(new NBTTagCompound());
    }
}


==================================================

--- Файл №231 ---
Путь: main\java\mchorse\mclib\network\ServerMessageHandler.java
--------------------
package mchorse.mclib.network;

import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.tileentity.TileEntity;
import net.minecraft.util.math.BlockPos;
import net.minecraft.world.World;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

/**
 * This class passes operation from Netty to Minecraft (Server) Thread. This
 * class will prevent the client-side message handling method from appearing in
 * server message handler classes.
 *
 * @author Ernio (Ernest Sadowski)
 */
public abstract class ServerMessageHandler<T extends IMessage> extends AbstractMessageHandler<T>
{
    public abstract void run(final EntityPlayerMP player, final T message);

    @Override
    public IMessage handleServerMessage(final EntityPlayerMP player, final T message)
    {
        player.getServer().addScheduledTask(new Runnable()
        {
            @Override
            public void run()
            {
                ServerMessageHandler.this.run(player, message);
            }
        });

        return null;
    }

    @Override
    public final IMessage handleClientMessage(final T message)
    {
        return null;
    }

    /**
     * Safe way to get a tile entity on the server without exposing code 
     * to ACG (Arbitrary Chunk Generation) exploit (thanks to Paul Fulham)
     */
    protected TileEntity getTE(EntityPlayerMP player, BlockPos pos)
    {
        World world = player.getEntityWorld();

        if (world.isBlockLoaded(pos))
        {
            return world.getTileEntity(pos);
        }

        return null;
    }
}

==================================================

--- Файл №232 ---
Путь: main\java\mchorse\mclib\network\mclib\Dispatcher.java
--------------------
package mchorse.mclib.network.mclib;

import mchorse.mclib.McLib;
import mchorse.mclib.network.AbstractDispatcher;
import mchorse.mclib.network.mclib.client.ClientHandlerAnswer;
import mchorse.mclib.network.mclib.client.ClientHandlerBoolean;
import mchorse.mclib.network.mclib.client.ClientHandlerConfig;
import mchorse.mclib.network.mclib.client.ClientHandlerConfirm;
import mchorse.mclib.network.mclib.common.PacketAnswer;
import mchorse.mclib.network.mclib.common.PacketBoolean;
import mchorse.mclib.network.mclib.common.PacketConfig;
import mchorse.mclib.network.mclib.common.PacketConfirm;
import mchorse.mclib.network.mclib.common.PacketDropItem;
import mchorse.mclib.network.mclib.common.PacketRequestConfigs;
import mchorse.mclib.network.mclib.common.PacketRequestPermission;
import mchorse.mclib.network.mclib.server.ServerHandlerConfig;
import mchorse.mclib.network.mclib.server.ServerHandlerConfirm;
import mchorse.mclib.network.mclib.server.ServerHandlerDropItem;
import mchorse.mclib.network.mclib.server.ServerHandlerPermissionRequest;
import mchorse.mclib.network.mclib.server.ServerHandlerRequestConfigs;
import net.minecraft.entity.Entity;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;
import net.minecraftforge.fml.relauncher.Side;

public class Dispatcher
{
    public static final AbstractDispatcher DISPATCHER = new AbstractDispatcher(McLib.MOD_ID)
    {
        @Override
        public void register()
        {
            register(PacketDropItem.class, ServerHandlerDropItem.class, Side.SERVER);

            /* Config related packets */
            register(PacketRequestConfigs.class, ServerHandlerRequestConfigs.class, Side.SERVER);
            register(PacketConfig.class, ServerHandlerConfig.class, Side.SERVER);
            register(PacketConfig.class, ClientHandlerConfig.class, Side.CLIENT);

            //TODO abstract confirm thing into server to client to server answer thing - see IAnswerRequest etc.
            /* Confirm related packets */
            register(PacketConfirm.class, ClientHandlerConfirm.class, Side.CLIENT);
            register(PacketConfirm.class, ServerHandlerConfirm.class, Side.SERVER);

            /* client answer related packets */
            register(PacketAnswer.class, ClientHandlerAnswer.class, Side.CLIENT);
            register(PacketBoolean.class, ClientHandlerBoolean.class, Side.CLIENT);

            register(PacketRequestPermission.class, ServerHandlerPermissionRequest.class, Side.SERVER);
        }
    };

    /**
     * Send message to players who are tracking given entity
     */
    public static void sendToTracked(Entity entity, IMessage message)
    {
        DISPATCHER.sendToTracked(entity, message);
    }

    /**
     * Send message to given player
     */
    public static void sendTo(IMessage message, EntityPlayerMP player)
    {
        DISPATCHER.sendTo(message, player);
    }

    /**
     * Send message to the server
     */
    public static void sendToServer(IMessage message)
    {
        DISPATCHER.sendToServer(message);
    }

    /**
     * Register all the networking messages and message handlers
     */
    public static void register()
    {
        DISPATCHER.register();
    }
}

==================================================

--- Файл №233 ---
Путь: main\java\mchorse\mclib\network\mclib\client\AbstractClientHandlerAnswer.java
--------------------
package mchorse.mclib.network.mclib.client;

import mchorse.mclib.McLib;
import mchorse.mclib.network.AbstractDispatcher;
import mchorse.mclib.network.ClientMessageHandler;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.IAnswerRequest;
import mchorse.mclib.network.mclib.common.PacketAnswer;
import mchorse.mclib.utils.Consumers;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.Mod;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraftforge.fml.common.gameevent.TickEvent;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Consumer;

@Mod.EventBusSubscriber
public abstract class AbstractClientHandlerAnswer<T extends PacketAnswer> extends ClientMessageHandler<T>
{
    protected static final Consumers<Object> CONSUMERS = new Consumers<>();
    protected static final Map<Integer, Long> TIME = new HashMap<>();
    /**
     * For logging / debugging purposes
     */
    protected static final Map<Integer, IAnswerRequest<?>> REQUESTS = new HashMap<>();

    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketAnswer message)
    {
        CONSUMERS.consume(message.getCallbackID(), message.getValue());
        TIME.remove(message.getCallbackID());
        REQUESTS.remove(message.getCallbackID());
    }

    @SubscribeEvent
    @SideOnly(Side.CLIENT)
    public static void onClientTick(TickEvent.ClientTickEvent event)
    {
        if (event.phase == TickEvent.Phase.START) return;

        long now = System.currentTimeMillis();

        for (Map.Entry<Integer, Long> entry : TIME.entrySet())
        {
            //5 minute timeout
            if (entry.getValue() + 5 * 60000 < now)
            {
                IAnswerRequest<?> request = REQUESTS.get(entry.getKey());

                McLib.LOGGER.info("Timeout for the answer request " + request.getClass().getSimpleName() + ". The consumer has been removed.");

                CONSUMERS.remove(entry.getKey());
                TIME.remove(entry.getKey());
                REQUESTS.remove(entry.getKey());
            }
        }
    }

    /**
     * This will register the consumer and set the resulting callbackID to the provided AnswerRequest.
     * The AnswerRequest will then be sent to the server.
     * @param request
     * @param callback
     */
    @SideOnly(Side.CLIENT)
    public static <T extends Serializable> void requestServerAnswer(AbstractDispatcher dispatcher, IAnswerRequest<T> request, Consumer<T> callback)
    {
        int id = CONSUMERS.register((obj) ->
        {
            T param;

            try
            {
                param = (T) obj;
            }
            catch (ClassCastException e)
            {
                McLib.LOGGER.error("Type of the answer's value is incompatible with the consumer generic type!");
                e.printStackTrace();

                return;
            }

            callback.accept(param);
        });

        TIME.put(id, System.currentTimeMillis());
        REQUESTS.put(id, request);
        request.setCallbackID(id);

        dispatcher.sendToServer(request);
    }


    /**
     * Send the answer to the player. The answer's generic datatype needs to be equal
     * to the Consumer input datatype that has been registered on the client side.
     * @param receiver
     * @param answer
     * @param <T> the type of the registered Consumer input datatype.
     */
    public static <T extends Serializable> void sendAnswerTo(EntityPlayerMP receiver, PacketAnswer<T> answer)
    {
        Dispatcher.sendTo(answer, receiver);
    }
}


==================================================

--- Файл №234 ---
Путь: main\java\mchorse\mclib\network\mclib\client\ClientHandlerAnswer.java
--------------------
package mchorse.mclib.network.mclib.client;

import mchorse.mclib.network.mclib.common.PacketAnswer;

/**
 * Handler for generic PacketAnswer which uses java's Serializable and Streams, which cat waste a lot of bytes
 */
public class ClientHandlerAnswer extends AbstractClientHandlerAnswer<PacketAnswer>
{

}


==================================================

--- Файл №235 ---
Путь: main\java\mchorse\mclib\network\mclib\client\ClientHandlerBoolean.java
--------------------
package mchorse.mclib.network.mclib.client;

import mchorse.mclib.network.mclib.common.PacketBoolean;

/**
 * A special handler just for PacketBoolean to allow for efficient transport of just 5 bytes in total.
 * Currently packets cannot be transported via inheritance to handlers, every packet requires an own handler TODO check in port
 */
public class ClientHandlerBoolean extends AbstractClientHandlerAnswer<PacketBoolean>
{

}


==================================================

--- Файл №236 ---
Путь: main\java\mchorse\mclib\network\mclib\client\ClientHandlerConfig.java
--------------------
package mchorse.mclib.network.mclib.client;

import mchorse.mclib.McLib;
import mchorse.mclib.client.gui.mclib.GuiDashboard;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.gui.GuiConfigPanel;
import mchorse.mclib.network.ClientMessageHandler;
import mchorse.mclib.network.mclib.common.PacketConfig;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.client.gui.GuiScreen;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class ClientHandlerConfig extends ClientMessageHandler<PacketConfig>
{
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP player, PacketConfig message)
    {
        if (message.overwrite)
        {
            Config present = McLib.proxy.configs.modules.get(message.config.id);

            present.copyServer(message.config);
        }
        else
        {
            GuiScreen screen = Minecraft.getMinecraft().currentScreen;

            if (screen instanceof GuiDashboard)
            {
                GuiConfigPanel panel = ((GuiDashboard) screen).config;

                panel.storeServerConfig(message.config);
            }
        }
    }
}


==================================================

--- Файл №237 ---
Путь: main\java\mchorse\mclib\network\mclib\client\ClientHandlerConfirm.java
--------------------
package mchorse.mclib.network.mclib.client;

import mchorse.mclib.client.gui.framework.elements.GuiConfirmationScreen;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.network.ClientMessageHandler;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketConfirm;
import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.function.Consumer;

public class ClientHandlerConfirm extends ClientMessageHandler<PacketConfirm>
{

    /**
     * Renders the GUI based on the enum value of packet. Every GUI confirmation screen dispatches the packet back to the server
     * @param packet
     */
    @Override
    @SideOnly(Side.CLIENT)
    public void run(EntityPlayerSP entityPlayerSP, PacketConfirm packet)
    {
        switch(packet.gui)
        {
            case MCSCREEN:
                Minecraft.getMinecraft().displayGuiScreen(new GuiConfirmationScreen(packet.langKey, (value) ->
                {
                    this.dispatchPacket(packet, value);
                }));
        }
    }

    private void dispatchPacket(PacketConfirm packet, boolean value)
    {
        packet.confirm = value;

        Dispatcher.sendToServer(packet);
    }

    public enum GUI {
        MCSCREEN;
    }
}


==================================================

--- Файл №238 ---
Путь: main\java\mchorse\mclib\network\mclib\common\IAnswerRequest.java
--------------------
package mchorse.mclib.network.mclib.common;

import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import java.io.Serializable;
import java.util.NoSuchElementException;
import java.util.Optional;

public interface IAnswerRequest<T extends Serializable> extends IMessage
{
    void setCallbackID(int callbackID);
    Optional<Integer> getCallbackID();
    /**
     * Get an answer packet with the provided values and callbackID.
     * The generic type of the PacketAnswer needs to equal the type of the provided value.
     * @param value
     * @return a PacketAnswer containing the value of the type of this request.
     * @throws NoSuchElementException if {@link #getCallbackID()} value is not present.
     */
    PacketAnswer<T> getAnswer(T value) throws NoSuchElementException;
}


==================================================

--- Файл №239 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketAnswer.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.utils.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class PacketAnswer<T extends Serializable> implements IMessage
{
    protected int callBackID;
    protected T answer;

    public PacketAnswer()
    { }

    public PacketAnswer(int callBackID, T answer)
    {
        this.callBackID = callBackID;
        this.answer = answer;
    }

    public int getCallbackID()
    {
        return this.callBackID;
    }

    public T getValue()
    {
        return this.answer;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.callBackID = buf.readInt();

        try
        {
            this.answer = (T) ByteBufUtils.readObject(buf);
        }
        catch (ClassCastException e)
        {
            e.printStackTrace();
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.callBackID);
        ByteBufUtils.writeObject(buf, this.answer);
    }
}


==================================================

--- Файл №240 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketBoolean.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;

public class PacketBoolean extends PacketAnswer<Boolean>
{
    public PacketBoolean()
    { }

    public PacketBoolean(int callbackID, boolean value)
    {
        super(callbackID, value);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.callBackID = buf.readInt();
        this.answer = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.callBackID);
        buf.writeBoolean(this.getValue());
    }
}


==================================================

--- Файл №241 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketConfig.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.config.Config;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketConfig implements IMessage
{
    public Config config;
    public boolean overwrite;

    public PacketConfig()
    {}

    public PacketConfig(Config config)
    {
        this(config, false);
    }

    public PacketConfig(Config config, boolean overwrite)
    {
        this.config = config;
        this.overwrite = overwrite;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.config = new Config(ByteBufUtils.readUTF8String(buf));
        this.config.fromBytes(buf);
        this.overwrite = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        ByteBufUtils.writeUTF8String(buf, this.config.id);

        this.config.toBytes(buf);
        buf.writeBoolean(this.overwrite);
    }
}

==================================================

--- Файл №242 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketConfirm.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.client.gui.utils.keys.IKey;
import mchorse.mclib.client.gui.utils.keys.KeyParser;
import mchorse.mclib.network.mclib.client.ClientHandlerConfirm;
import mchorse.mclib.network.mclib.server.ServerHandlerConfirm;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

import javax.annotation.Nullable;
import java.util.Map;
import java.util.function.Consumer;

public class PacketConfirm implements IMessage
{

    public int consumerID;
    public ClientHandlerConfirm.GUI gui;
    public IKey langKey;
    public boolean confirm;

    public PacketConfirm(ClientHandlerConfirm.GUI gui, IKey langKey, Consumer<Boolean> callback)
    {
        this.gui = gui;
        this.langKey = langKey;

        Map.Entry<Integer, Consumer<Boolean>> entry = ServerHandlerConfirm.getLastConsumerEntry();
        this.consumerID = (entry != null) ? entry.getKey()+1 : 0;

        ServerHandlerConfirm.addConsumer(consumerID, callback);
    }

    public PacketConfirm()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.langKey = KeyParser.keyFromBytes(buf);
        this.gui = ClientHandlerConfirm.GUI.values()[buf.readInt()];
        this.consumerID = buf.readInt();
        this.confirm = buf.readBoolean();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        KeyParser.keyToBytes(buf, this.langKey);
        buf.writeInt(this.gui.ordinal());
        buf.writeInt(this.consumerID);
        buf.writeBoolean(this.confirm);
    }
}

==================================================

--- Файл №243 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketDropItem.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;
import net.minecraft.item.ItemStack;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketDropItem implements IMessage
{
    public ItemStack stack = ItemStack.EMPTY;

    public PacketDropItem()
    {}

    public PacketDropItem(ItemStack stack)
    {
        this.stack = stack;
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        NBTTagCompound tagCompound = ByteBufUtils.readTag(buf);

        if (tagCompound != null)
        {
            this.stack = new ItemStack(tagCompound);
        }
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        if (!this.stack.isEmpty())
        {
            ByteBufUtils.writeTag(buf, this.stack.writeToNBT(new NBTTagCompound()));
        }
    }
}

==================================================

--- Файл №244 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketRequestConfigs.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;
import net.minecraftforge.fml.common.network.simpleimpl.IMessage;

public class PacketRequestConfigs implements IMessage
{
    public PacketRequestConfigs()
    {}

    @Override
    public void fromBytes(ByteBuf buf)
    {}

    @Override
    public void toBytes(ByteBuf buf)
    {}
}

==================================================

--- Файл №245 ---
Путь: main\java\mchorse\mclib\network\mclib\common\PacketRequestPermission.java
--------------------
package mchorse.mclib.network.mclib.common;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.McLib;
import mchorse.mclib.permissions.PermissionCategory;

import javax.annotation.Nullable;
import java.util.NoSuchElementException;
import java.util.Optional;

public class PacketRequestPermission implements IAnswerRequest<Boolean>
{
    private PermissionCategory request;
    private int callbackID = -1;

    public PacketRequestPermission()
    { }

    public PacketRequestPermission(int callbackID, PermissionCategory permission)
    {
        this.callbackID = callbackID;
        this.request = permission;
    }

    @Nullable
    public PermissionCategory getPermissionRequest()
    {
        return this.request;
    }

    @Override
    public void setCallbackID(int callbackID)
    {
        this.callbackID = callbackID;
    }

    @Override
    public Optional<Integer> getCallbackID()
    {
        return Optional.of(this.callbackID == -1 ? null : this.callbackID);
    }

    @Override
    public PacketBoolean getAnswer(Boolean value) throws NoSuchElementException
    {
        return new PacketBoolean(this.getCallbackID().get(), value);
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        this.callbackID = buf.readInt();
        this.request = McLib.permissionFactory.getPermission(buf.readInt());
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeInt(this.callbackID);
        buf.writeInt(McLib.permissionFactory.getPermissionID(this.request));
    }
}


==================================================

--- Файл №246 ---
Путь: main\java\mchorse\mclib\network\mclib\server\ServerHandlerConfig.java
--------------------
package mchorse.mclib.network.mclib.server;

import mchorse.mclib.McLib;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.ConfigManager;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.network.mclib.common.PacketConfig;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerConfig extends ServerMessageHandler<PacketConfig>
{
    @Override
    public void run(EntityPlayerMP player, PacketConfig message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        Config present = McLib.proxy.configs.modules.get(message.config.id);

        if (present != null)
        {
            present.copy(message.config);
            present.save();

            if (present.hasSyncable())
            {
                ConfigManager.synchronizeConfig(present.filterSyncable(), player.getServerWorld().getMinecraftServer(), null);
            }
        }
    }
}

==================================================

--- Файл №247 ---
Путь: main\java\mchorse\mclib\network\mclib\server\ServerHandlerConfirm.java
--------------------
package mchorse.mclib.network.mclib.server;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.network.mclib.common.PacketConfirm;
import net.minecraft.entity.player.EntityPlayerMP;

import java.util.Map.Entry;
import java.util.TreeMap;
import java.util.function.Consumer;

public class ServerHandlerConfirm extends ServerMessageHandler<PacketConfirm>
{
    private static TreeMap<Integer, Consumer<Boolean>> consumers = new TreeMap<Integer, Consumer<Boolean>>();

    @Override
    public void run(EntityPlayerMP entityPlayerMP, PacketConfirm packetConfirm)
    {
        if (consumers.containsKey(packetConfirm.consumerID))
        {
            consumers.remove(packetConfirm.consumerID).accept(packetConfirm.confirm);
        }
    }

    public static void addConsumer(int id, Consumer<Boolean> item)
    {
        consumers.put(id, item);
    }

    public static Entry getLastConsumerEntry()
    {
        return consumers.lastEntry();
    }
}


==================================================

--- Файл №248 ---
Путь: main\java\mchorse\mclib\network\mclib\server\ServerHandlerDropItem.java
--------------------
package mchorse.mclib.network.mclib.server;

import mchorse.mclib.McLib;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.network.mclib.common.PacketDropItem;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.init.SoundEvents;
import net.minecraft.item.ItemStack;
import net.minecraft.util.SoundCategory;

public class ServerHandlerDropItem extends ServerMessageHandler<PacketDropItem>
{
    @Override
    public void run(EntityPlayerMP player, PacketDropItem message)
    {
        if (player.isCreative() && McLib.opDropItems.get() || OpHelper.isPlayerOp(player))
        {
            ItemStack stack = message.stack;

            player.inventory.addItemStackToInventory(stack);
            player.world.playSound(null, player.posX, player.posY, player.posZ, SoundEvents.ENTITY_ITEM_PICKUP, SoundCategory.PLAYERS, 0.2F, 1F);
            player.inventoryContainer.detectAndSendChanges();
        }
    }
}

==================================================

--- Файл №249 ---
Путь: main\java\mchorse\mclib\network\mclib\server\ServerHandlerPermissionRequest.java
--------------------
package mchorse.mclib.network.mclib.server;

import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.network.mclib.client.ClientHandlerAnswer;
import mchorse.mclib.network.mclib.common.PacketRequestPermission;
import mchorse.mclib.permissions.PermissionCategory;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerPermissionRequest extends ServerMessageHandler<PacketRequestPermission>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestPermission message)
    {
        PermissionCategory perm = message.getPermissionRequest();

        boolean hasPermission = perm != null && perm.playerHasPermission(player);

        ClientHandlerAnswer.sendAnswerTo(player, message.getAnswer(hasPermission));
    }
}


==================================================

--- Файл №250 ---
Путь: main\java\mchorse\mclib\network\mclib\server\ServerHandlerRequestConfigs.java
--------------------
package mchorse.mclib.network.mclib.server;

import mchorse.mclib.McLib;
import mchorse.mclib.config.Config;
import mchorse.mclib.config.ConfigManager;
import mchorse.mclib.network.ServerMessageHandler;
import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.common.PacketConfig;
import mchorse.mclib.network.mclib.common.PacketRequestConfigs;
import mchorse.mclib.utils.OpHelper;
import net.minecraft.entity.player.EntityPlayerMP;

public class ServerHandlerRequestConfigs extends ServerMessageHandler<PacketRequestConfigs>
{
    @Override
    public void run(EntityPlayerMP player, PacketRequestConfigs message)
    {
        if (!OpHelper.isPlayerOp(player))
        {
            return;
        }

        ConfigManager manager = McLib.proxy.configs;

        for (Config config : manager.modules.values())
        {
            Config serverSide = config.filterServerSide();

            if (!serverSide.values.isEmpty())
            {
                Dispatcher.sendTo(new PacketConfig(serverSide), player);
            }
        }
    }
}

==================================================

--- Файл №251 ---
Путь: main\java\mchorse\mclib\permissions\McLibPermissions.java
--------------------
package mchorse.mclib.permissions;

public class McLibPermissions
{
    public static PermissionCategory configEdit;
    public static PermissionCategory accessGui;
}


==================================================

--- Файл №252 ---
Путь: main\java\mchorse\mclib\permissions\PermissionCategory.java
--------------------
package mchorse.mclib.permissions;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.network.IByteBufSerializable;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.network.ByteBufUtils;
import net.minecraftforge.server.permission.DefaultPermissionLevel;
import net.minecraftforge.server.permission.PermissionAPI;

import java.util.ArrayList;
import java.util.List;

public class PermissionCategory implements IByteBufSerializable
{
    private String name;
    private final List<PermissionCategory> children = new ArrayList<>();
    private PermissionCategory parent;
    /**
     * If null, then this permission takes the level of the parent
     */
    private DefaultPermissionLevel level;

    public PermissionCategory(String name)
    {
        this(name, null);
    }

    public PermissionCategory(String name, DefaultPermissionLevel level)
    {
        this.name = name;
        this.level = level;
    }

    private PermissionCategory()
    {

    }

    public boolean playerHasPermission(EntityPlayer player)
    {
        return PermissionAPI.hasPermission(player, this.toString());
    }

    public void addChild(PermissionCategory category)
    {
        this.children.add(category);
        category.parent = this;
    }

    public boolean hasChildren()
    {
        return !this.children.isEmpty();
    }

    public List<PermissionCategory> getChildren()
    {
        return new ArrayList<>(this.children);
    }

    /**
     * @return the parent or null if no parent is present.
     */
    public PermissionCategory getParent()
    {
        return this.parent;
    }

    /**
     * Gets the default permission based on this or the parent's default permission level.
     * @return the permission level of this permission or if null of the parent.
     *         If no parent above has a default permission level, this method will return {@link DefaultPermissionLevel#NONE}
     */
    public DefaultPermissionLevel getDefaultPermission()
    {
        if (this.level == null)
        {
            return (this.parent != null) ? this.parent.getDefaultPermission() : DefaultPermissionLevel.NONE;
        }

        return this.level;
    }

    @Override
    public String toString()
    {
        return (this.parent != null ? this.parent + "." : "") + this.name;
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        this.name = ByteBufUtils.readUTF8String(buffer);
        this.level = DefaultPermissionLevel.values()[buffer.readInt()];

        int size = buffer.readInt();

        for (int i = 0; i < size; i++)
        {
            PermissionCategory child = new PermissionCategory();

            child.fromBytes(buffer);

            this.addChild(child);
        }
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        ByteBufUtils.writeUTF8String(buffer, this.name);
        buffer.writeInt(this.level.ordinal());

        buffer.writeInt(this.children.size());

        for (PermissionCategory category : this.children)
        {
            category.toBytes(buffer);
        }
    }
}


==================================================

--- Файл №253 ---
Путь: main\java\mchorse\mclib\permissions\PermissionFactory.java
--------------------
package mchorse.mclib.permissions;

import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import mchorse.mclib.McLib;

import javax.annotation.Nullable;

/**
 * This class is needed for serialisation, for example, into bytes to reduce the amount of data being sent.
 */
public class PermissionFactory
{
    /**
     * Map the permission string hashcode to the permission
     */
    private final BiMap<Integer, PermissionCategory> permissions = HashBiMap.create();

    public void registerPermission(PermissionCategory permission)
    {
        String name = permission.toString();
        int hash = name.hashCode();

        if (this.permissions.containsKey(hash))
        {
            McLib.LOGGER.warn("The hash of the permission " + name + " is equal to the already registered permission " + this.permissions.get(hash));

            return;
        }

        if (!permission.hasChildren() && !this.permissions.containsValue(permission))
        {
            this.permissions.put(hash, permission);
        }
    }

    public boolean isRegistered(PermissionCategory permission)
    {
        return this.permissions.containsValue(permission);
    }

    /**
     * @param permission
     * @return the id of the permission or -1 if the provided permission was not registered
     */
    public int getPermissionID(PermissionCategory permission)
    {
        return this.permissions.inverse().get(permission);
    }

    @Nullable
    public PermissionCategory getPermission(int id)
    {
        return this.permissions.get(id);
    }
}


==================================================

--- Файл №254 ---
Путь: main\java\mchorse\mclib\permissions\PermissionUtils.java
--------------------
package mchorse.mclib.permissions;

import mchorse.mclib.network.mclib.Dispatcher;
import mchorse.mclib.network.mclib.client.ClientHandlerAnswer;
import mchorse.mclib.network.mclib.common.PacketRequestPermission;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.player.EntityPlayer;
import java.util.function.Consumer;

public class PermissionUtils
{
    /**
     * Side independent method for checking if it has the permission and then passing the result to the callback
     * @param node the full name of the permission
     * @param player the player to check for the permission
     * @param callback the callback to be executed after checking the player
     *                 or after the server has sent the permission result.
     */
    public static void hasPermission(EntityPlayer player, PermissionCategory permission, Consumer<Boolean> callback)
    {
        if (!Minecraft.getMinecraft().world.isRemote)
        {
            callback.accept(permission.playerHasPermission(player));
        }
        else
        {
            //in singleplayer there is no use in having a permission system
            if (Minecraft.getMinecraft().isIntegratedServerRunning())
            {
                callback.accept(true);
            }
            else
            {
                ClientHandlerAnswer.requestServerAnswer(Dispatcher.DISPATCHER, new PacketRequestPermission(-1, permission), callback);
            }
        }
    }
}


==================================================

--- Файл №255 ---
Путь: main\java\mchorse\mclib\utils\BetterLightsHelper.java
--------------------
package mchorse.mclib.utils;

import java.lang.reflect.Field;

public class BetterLightsHelper
{
    private static ReflectionElement<Class> betterLightsClass = new ReflectionElement<>();
    private static ReflectionElement<Field> shadowPass = new ReflectionElement<>();

    /**
     * Checks whether BetterLights is currently rendering shadow map.
     */
    public static boolean isBetterLightsShadowPass()
    {
        /* only check once for isShadowPass Field to avoid too many reflection calls */
        if (!shadowPass.checked)
        {
            try
            {
                Class context = Class.forName("dz.betterlights.utils.BetterLightsContext");

                shadowPass.element = context.getDeclaredField("isBlShadowPass");
                shadowPass.element.setAccessible(true);
            }
            catch (Exception e)
            {}

            shadowPass.checked = true;
        }

        if (shadowPass.element != null)
        {
            try
            {
                return (boolean) shadowPass.element.get(null);
            }
            catch (Exception e)
            {}
        }

        return false;
    }

    public static boolean isBetterLightsLoaded()
    {
        return findBetterLightsClass();
    }

    private static boolean findBetterLightsClass()
    {
        /* only check once if Optifine is there - avoid too many reflection calls*/
        if (!betterLightsClass.checked)
        {
            try
            {
                betterLightsClass.element = Class.forName("dz.betterlights.BetterLightsMod");
            }
            catch (Exception e)
            { }

            betterLightsClass.checked = true;
        }

        return betterLightsClass.element != null;
    }

    /* avoid too many reflection calls by saving whether it was checked */
    private static class ReflectionElement<T>
    {
        private T element;
        private boolean checked;
    }
}


==================================================

--- Файл №256 ---
Путь: main\java\mchorse\mclib\utils\ByteBufUtils.java
--------------------
package mchorse.mclib.utils;

import io.netty.buffer.ByteBuf;

import javax.annotation.Nullable;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

public class ByteBufUtils
{
    public static void writeObject(ByteBuf to, Object object)
    {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();

        try
        {
            ObjectOutputStream output = new ObjectOutputStream(bos);

            output.writeObject(object);
            output.flush();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }

        writeByteArray(to, bos.toByteArray());
    }

    @Nullable
    public static Object readObject(ByteBuf from)
    {
        ByteArrayInputStream bis = new ByteArrayInputStream(readByteArray(from));
        Object result = null;

        try
        {
            ObjectInputStream input = new ObjectInputStream(bis);

            result = input.readObject();
        }
        catch (IOException | ClassNotFoundException e)
        {
            e.printStackTrace();
        }

        return result;
    }

    public static byte[] readByteArray(ByteBuf from)
    {
        int size = from.readInt();
        ByteBuf bytes = from.readBytes(size);

        byte[] array = new byte[bytes.capacity()];

        bytes.getBytes(0, array);

        return array;
    }

    public static void writeByteArray(ByteBuf to, byte[] array)
    {
        to.writeInt(array.length);
        to.writeBytes(array);
    }
}


==================================================

--- Файл №257 ---
Путь: main\java\mchorse\mclib\utils\Color.java
--------------------
package mchorse.mclib.utils;

import org.apache.commons.lang3.StringUtils;

public class Color implements ICopy<Color>
{
    public float r;
    public float g;
    public float b;
    public float a = 1;

    public Color()
    {}

    public Color(float r, float g, float b)
    {
        this.r = r;
        this.g = g;
        this.b = b;
    }

    public Color(float r, float g, float b, float a)
    {
        this(r, g, b);

        this.a = a;
    }

    public Color(int color)
    {
        this(color, true);
    }

    public Color(int color, boolean alpha)
    {
        this.set(color, alpha);
    }

    public Color set(float r, float g, float b, float a)
    {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;

        return this;
    }

    public Color set(float value, int component)
    {
        switch (component)
        {
            case 1:
                this.r = value;
            break;

            case 2:
                this.g = value;
            break;

            case 3:
                this.b = value;
            break;

            default:
                this.a = value;
            break;
        }

        return this;
    }

    public Color set(int color)
    {
        return this.set(color, true);
    }

    public Color set(int color, boolean alpha)
    {
        this.set((color >> 16 & 0xff) / 255F, (color >> 8 & 0xff) / 255F, (color & 0xff)  / 255F, alpha ? (color >> 24 & 0xff)  / 255F : 1F);

        return this;
    }

    @Override
    public Color copy()
    {
        Color copy = new Color();

        copy.copy(this);

        return copy;
    }

    @Override
    public void copy(Color color)
    {
        this.set(color.r, color.g, color.b, color.a);
    }

    public int getRGBAColor()
    {
        float r = MathUtils.clamp(this.r, 0, 1);
        float g = MathUtils.clamp(this.g, 0, 1);
        float b = MathUtils.clamp(this.b, 0, 1);
        float a = MathUtils.clamp(this.a, 0, 1);

        return ((int) (a * 255) << 24) | ((int) (r * 255) << 16) | ((int) (g * 255) << 8) | (int) (b * 255);
    }

    public int getRGBColor()
    {
        return this.getRGBAColor() & 0xffffff;
    }

    public String stringify()
    {
        return this.stringify(false);
    }

    public String stringify(boolean alpha)
    {
        if (alpha)
        {
            return "#" + StringUtils.leftPad(Integer.toHexString(this.getRGBAColor()), 8, '0');
        }

        return "#" + StringUtils.leftPad(Integer.toHexString(this.getRGBColor()), 6, '0');
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof Color)
        {
            Color color = (Color) obj;

            return color.getRGBAColor() == this.getRGBAColor();
        }

        return super.equals(obj);
    }
}

==================================================

--- Файл №258 ---
Путь: main\java\mchorse\mclib\utils\ColorUtils.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.renderer.GlStateManager;

public class ColorUtils
{
    public static final int HALF_BLACK = 0x88000000;

    public static final Color COLOR = new Color();

    public static int multiplyColor(int color, float factor)
    {
        COLOR.set(color, true);
        COLOR.r *= factor;
        COLOR.g *= factor;
        COLOR.b *= factor;

        return COLOR.getRGBAColor();
    }

    public static int setAlpha(int color, float alpha)
    {
        COLOR.set(color, true);
        COLOR.a = alpha;

        return COLOR.getRGBAColor();
    }

    public static void interpolate(Color target, int a, int b, float x)
    {
        interpolate(target, a, b, x, true);
    }

    public static void interpolate(Color target, int a, int b, float x, boolean alpha)
    {
        target.set(a, alpha);
        COLOR.set(b, alpha);

        target.r = Interpolations.lerp(target.r, COLOR.r, x);
        target.g = Interpolations.lerp(target.g, COLOR.g, x);
        target.b = Interpolations.lerp(target.b, COLOR.b, x);

        if (alpha)
        {
            target.a = Interpolations.lerp(target.a, COLOR.a, x);
        }
    }

    public static void bindColor(int color)
    {
        COLOR.set(color, true);

        GlStateManager.color(COLOR.r, COLOR.g, COLOR.b, COLOR.a);
    }

    public static int rgbaToInt(float r, float g, float b, float a)
    {
        COLOR.set(r, g, b, a);

        return COLOR.getRGBAColor();
    }

    public static int parseColor(String color)
    {
        return parseColor(color, 0);
    }

    public static int parseColor(String color, int orDefault)
    {
        try
        {
            return parseColorWithException(color);
        }
        catch (Exception e)
        {}

        return orDefault;
    }

    public static int parseColorWithException(String color) throws Exception
    {
        if (color.startsWith("#"))
        {
            color = color.substring(1);
        }

        if (color.length() == 6 || color.length() == 8)
        {
            if (color.length() == 8)
            {
                String alpha = color.substring(0, 2);
                String rest = color.substring(2);

                int a = Integer.parseInt(alpha, 16) << 24;
                int rgb = Integer.parseInt(rest, 16);

                return a + rgb;
            }

            return Integer.parseInt(color, 16);
        }

        throw new Exception("Given color \"" + color + "\" can't be parsed!");
    }
}

==================================================

--- Файл №259 ---
Путь: main\java\mchorse\mclib\utils\Consumers.java
--------------------
package mchorse.mclib.utils;

import java.util.Map;
import java.util.TreeMap;
import java.util.function.Consumer;

public class Consumers<C>
{
    private final TreeMap<Integer, Consumer<C>> callbacks = new TreeMap<>();

    public void remove(int id)
    {
        this.callbacks.remove(id);
    }

    /**
     * Executes the Consumer at the given id, if present, and remove after execution.
     * @param id
     * @param value
     */
    public void consume(int id, C value)
    {
        this.consume(id, value, true);
    }

    /**
     * Executes the Consumer at the given id, if present and remove after execution.
     * @param id
     * @param value
     * @param remove whether to remove the consumer after execution
     */
    public void consume(int id, C value, boolean remove)
    {
        Consumer<C> callback = this.callbacks.get(id);

        if (callback != null)
        {
            callback.accept(value);

            if (remove)
            {
                callbacks.remove(id);
            }
        }
    }

    public int register(Consumer<C> callback)
    {
        if (!this.callbacks.containsValue(callback))
        {
            Map.Entry<Integer, Consumer<C>> last = this.callbacks.lastEntry();

            int id = (last != null) ? last.getKey() + 1 : 0;

            this.callbacks.put(id, callback);

            return id;
        }
        else
        {
            for (Map.Entry<Integer, Consumer<C>> entry : callbacks.entrySet())
            {
                if (entry.getValue() == callback)
                {
                    return entry.getKey();
                }
            }
        }

        /* this statement should never be reached... */
        return -1;
    }
}


==================================================

--- Файл №260 ---
Путь: main\java\mchorse\mclib\utils\Direction.java
--------------------
package mchorse.mclib.utils;

public enum Direction
{
    TOP(0.5F, 0F), LEFT(0F, 0.5F), BOTTOM(0.5F, 1F), RIGHT(1F, 0.5F);

    public final float anchorX;
    public final float anchorY;
    public final int factorX;
    public final int factorY;

    private Direction(float anchorX, float anchorY)
    {
        this.anchorX = anchorX;
        this.anchorY = anchorY;
        this.factorX = (int) Interpolations.lerp(-1, 1, anchorX);
        this.factorY = (int) Interpolations.lerp(-1, 1, anchorY);
    }

    public boolean isHorizontal()
    {
        return this == LEFT || this == RIGHT;
    }

    public boolean isVertical()
    {
        return this == TOP || this == BOTTOM;
    }

    public Direction opposite()
    {
        if (this == TOP)
        {
            return BOTTOM;
        }
        else if (this == BOTTOM)
        {
            return TOP;
        }
        else if (this == LEFT)
        {
            return  RIGHT;
        }

        /* this == RIGHT */
        return LEFT;
    }
}


==================================================

--- Файл №261 ---
Путь: main\java\mchorse\mclib\utils\DummyEntity.java
--------------------
package mchorse.mclib.utils;

import java.util.Arrays;

import net.minecraft.entity.EntityLivingBase;
import net.minecraft.init.Items;
import net.minecraft.inventory.EntityEquipmentSlot;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHandSide;
import net.minecraft.world.World;

/**
 * Dummy entity
 *
 * This class is used in model editor as a player substitution for the model
 * methods.
 */
public class DummyEntity extends EntityLivingBase
{
    private final ItemStack[] held;
    public ItemStack right;
    public ItemStack left;

    public DummyEntity(World worldIn)
    {
        super(worldIn);

        this.right = new ItemStack(Items.DIAMOND_SWORD);
        this.left = new ItemStack(Items.GOLDEN_SWORD);
        this.held = new ItemStack[] {ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY};
    }

    public void setItems(ItemStack left, ItemStack right)
    {
        this.left = left;
        this.right = right;
    }

    public void toggleItems(boolean toggle)
    {
        int main = EntityEquipmentSlot.MAINHAND.getSlotIndex();
        int off = EntityEquipmentSlot.OFFHAND.getSlotIndex();

        if (toggle)
        {
            this.held[main] = this.right;
            this.held[off] = this.left;
        }
        else
        {
            this.held[main] = this.held[off] = ItemStack.EMPTY;
        }
    }

    @Override
    public Iterable<ItemStack> getArmorInventoryList()
    {
        return Arrays.asList(this.held);
    }

    @Override
    public ItemStack getItemStackFromSlot(EntityEquipmentSlot slotIn)
    {
        return this.held[slotIn.getSlotIndex()];
    }

    @Override
    public void setItemStackToSlot(EntityEquipmentSlot slotIn, ItemStack stack)
    {
        this.held[slotIn.getSlotIndex()] = stack;
    }

    @Override
    public EnumHandSide getPrimaryHand()
    {
        return EnumHandSide.RIGHT;
    }
}

==================================================

--- Файл №262 ---
Путь: main\java\mchorse\mclib\utils\EntityUtils.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.Minecraft;
import net.minecraft.client.network.NetHandlerPlayClient;
import net.minecraft.client.network.NetworkPlayerInfo;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.world.GameType;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class EntityUtils
{
    @SideOnly(Side.CLIENT)
    public static GameType getGameMode()
    {
        return getGameMode(Minecraft.getMinecraft().player);
    }

    @SideOnly(Side.CLIENT)
    public static GameType getGameMode(EntityPlayer player)
    {
        NetworkPlayerInfo networkplayerinfo = EntityUtils.getNetworkInfo(player);

        return networkplayerinfo == null ? GameType.SURVIVAL : networkplayerinfo.getGameType();
    }

    @SideOnly(Side.CLIENT)
    public static boolean isAdventureMode(EntityPlayer player)
    {
        NetworkPlayerInfo info = getNetworkInfo(player);

        return info != null && info.getGameType() == GameType.ADVENTURE;
    }

    @SideOnly(Side.CLIENT)
    public static NetworkPlayerInfo getNetworkInfo(EntityPlayer player)
    {
        NetHandlerPlayClient connection = Minecraft.getMinecraft().getConnection();

        if (connection == null)
        {
            return null;
        }

        return connection.getPlayerInfo(player.getGameProfile().getId());
    }
}


==================================================

--- Файл №263 ---
Путь: main\java\mchorse\mclib\utils\ForgeUtils.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraftforge.fml.common.FMLCommonHandler;

import java.util.List;

/**
 * A Utils class that holds common Forge calls.
 * Should help in abstraction for porting.
 */
public class ForgeUtils
{
    /**
     * @return a list of players on the server instance
     */
    public static List<EntityPlayerMP> getServerPlayers()
    {
        return FMLCommonHandler.instance().getMinecraftServerInstance().getPlayerList().getPlayers();
    }
}


==================================================

--- Файл №264 ---
Путь: main\java\mchorse\mclib\utils\ICopy.java
--------------------
package mchorse.mclib.utils;

/**
 * The Java Cloneable interface is only a marker interface to enforce
 * a convention to override the protected Object.clone() method with a public method.
 * This does not allow for dynamic validation whether an object actually has a public clone() method.
 *
 * This interface should provide better knowledge at compile time whether a generic object
 * has a public copy method.
 * @param <T> by convention this should be the type of the class that inherits this interface
 */
public interface ICopy<T>
{
    T copy();

    default void copy(T origin)
    { }
}


==================================================

--- Файл №265 ---
Путь: main\java\mchorse\mclib\utils\IInterpolation.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.resources.I18n;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public interface IInterpolation
{
    public float interpolate(float a, float b, float x);

    public double interpolate(double a, double b, double x);

    @SideOnly(Side.CLIENT)
    public default String getName()
    {
        return I18n.format(this.getKey());
    }

    @SideOnly(Side.CLIENT)
    public String getKey();

    @SideOnly(Side.CLIENT)
    public default String getTooltip()
    {
        return I18n.format(this.getTooltipKey());
    }

    @SideOnly(Side.CLIENT)
    public String getTooltipKey();
}


==================================================

--- Файл №266 ---
Путь: main\java\mchorse\mclib\utils\Interpolation.java
--------------------
package mchorse.mclib.utils;

import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public enum Interpolation implements IInterpolation
{
    LINEAR("linear")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return Interpolations.lerp(a, b, x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return Interpolations.lerp(a, b, x);
        }
    },
    QUAD_IN("quad_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return a + (b - a) * x * x;
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return a + (b - a) * x * x;
        }
    },
    QUAD_OUT("quad_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return a - (b - a) * x * (x - 2);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return a - (b - a) * x * (x - 2);
        }
    },
    QUAD_INOUT("quad_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            x *= 2;

            if (x < 1F) return a + (b - a) / 2 * x * x;

            x -= 1;

            return a - (b - a) / 2 * (x * (x - 2) - 1);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            x *= 2;

            if (x < 1F) return a + (b - a) / 2 * x * x;

            x -= 1;

            return a - (b - a) / 2 * (x * (x - 2) - 1);
        }
    },
    CUBIC_IN("cubic_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return a + (b - a) * x * x * x;
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return a + (b - a) * x * x * x;
        }
    },
    CUBIC_OUT("cubic_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            x -= 1;
            return a + (b - a) * (x * x * x + 1);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            x -= 1;
            return a + (b - a) * (x * x * x + 1);
        }
    },
    CUBIC_INOUT("cubic_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            x *= 2;

            if (x < 1F) return a + (b - a) / 2 * x * x * x;

            x -= 2;

            return a + (b - a) / 2 * (x * x * x + 2);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            x *= 2;

            if (x < 1F) return a + (b - a) / 2 * x * x * x;

            x -= 2;

            return a + (b - a) / 2 * (x * x * x + 2);
        }
    },
    EXP_IN("exp_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return (float) this.interpolate((double) a, b, x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            if (x == 0) return a;

            double pow0 = Math.pow(2, -10);

            /*
             * The restrictions f(0) = a and f(1) = b will lead to the following formula instead of plain
             * 2^10*(x-1). This would change the derivative,
             * but with the plain formula the animation jumps when animating big values.
             */
            return (a + (b - a) / (1 - pow0) * (Math.pow(2, 10 * (x - 1))) - pow0);
        }
    },
    EXP_OUT("exp_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return (float) this.interpolate((double) a, b, x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            if (x == 0) return a;

            double pow0 = Math.pow(2, -10);

            return a + (b - a) * (1 - (Math.pow(2, -10 * x) - pow0) * 1 / (1 - pow0));
        }
    },
    EXP_INOUT("exp_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return (float) this.interpolate((double) a, b, x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            if (x <= 0.5D) {
                return Interpolation.EXP_IN.interpolate(a, a + (b - a) / 2, x * 2);
            }

            return Interpolation.EXP_OUT.interpolate(a + (b - a) / 2, b, x * 2 - 1);
        }
    },
    /* Following interpolations below were copied from: https://easings.net/ */
    BACK_IN("back_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float c1 = 1.70158F;
            final float c3 = c1 + 1;

            return Interpolations.lerp(a, b, c3 * x * x * x - c1 * x * x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double c1 = 1.70158D;
            final double c3 = c1 + 1;

            return Interpolations.lerp(a, b, c3 * x * x * x - c1 * x * x);
        }
    },
    BACK_OUT("back_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float c1 = 1.70158F;
            final float c3 = c1 + 1;

            return Interpolations.lerp(a, b, 1 + c3 * (float) Math.pow(x - 1, 3) + c1 * (float) Math.pow(x - 1, 2));
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double c1 = 1.70158D;
            final double c3 = c1 + 1;

            return Interpolations.lerp(a, b, 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2));
        }
    },
    BACK_INOUT("back_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float c1 = 1.70158F;
            final float c2 = c1 * 1.525F;

            float factor = x < 0.5
                ? ((float) Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
                : ((float) Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double c1 = 1.70158D;
            final double c2 = c1 * 1.525D;

            double factor = x < 0.5
                ? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2
                : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;

            return Interpolations.lerp(a, b, factor);
        }
    },
    ELASTIC_IN("elastic_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float c4 = (2 * (float) Math.PI) / 3;

            float factor = x == 0 ? 0 :
                    (x == 1 ? 1 : -(float) Math.pow(2, 10 * x - 10) * (float) Math.sin((x * 10 - 10.75) * c4));

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double c4 = (2 * (float) Math.PI) / 3;

            double factor = x == 0 ? 0 :
                    (x == 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4));

            return Interpolations.lerp(a, b, factor);
        }
    },
    ELASTIC_OUT("elastic_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float c4 = (2 * (float) Math.PI) / 3;

            float factor = x == 0 ? 0 :
                    (x == 1 ? 1 : (float) Math.pow(2, -10 * x) * (float) Math.sin((x * 10 - 0.75) * c4) + 1);

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double c4 = (2 * Math.PI) / 3;

            double factor = x == 0 ? 0 :
                (x == 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1);

            return Interpolations.lerp(a, b, factor);
        }
    },
    ELASTIC_INOUT("elastic_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float c5 = (2 * (float) Math.PI) / 4.5F;

            float factor = x == 0 ? 0 : (x == 1 ? 1 :
                (x < 0.5
                    ? -((float) Math.pow(2, 20 * x - 10) * (float) Math.sin((20 * x - 11.125) * c5)) / 2
                    : ((float) Math.pow(2, -20 * x + 10) * (float) Math.sin((20 * x - 11.125) * c5)) / 2 + 1)
                );

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double c5 = (2 * Math.PI) / 4.5;

            double factor = x == 0 ? 0 : (x == 1 ? 1 :
                (x < 0.5
                    ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2
                    : (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1)
                );

            return Interpolations.lerp(a, b, factor);
        }
    },
    BOUNCE_IN("bounce_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return Interpolations.lerp(a, b, 1 - BOUNCE_OUT.interpolate(0, 1, 1 - x));
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return Interpolations.lerp(a, b, 1 - BOUNCE_OUT.interpolate(0, 1, 1 - x));
        }
    },
    BOUNCE_OUT("bounce_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            final float n1 = 7.5625F;
            final float d1 = 2.75F;
            float factor;

            if (x < 1 / d1)
            {
                factor = n1 * x * x;
            }
            else if (x < 2 / d1)
            {
                factor = n1 * (x -= 1.5F / d1) * x + 0.75F;
            }
            else if (x < 2.5 / d1)
            {
                factor = n1 * (x -= 2.25F / d1) * x + 0.9375F;
            }
            else
            {
                factor = n1 * (x -= 2.625F / d1) * x + 0.984375F;
            }

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            final double n1 = 7.5625;
            final double d1 = 2.75;
            double factor;

            if (x < 1 / d1)
            {
                factor = n1 * x * x;
            }
            else if (x < 2 / d1)
            {
                factor = n1 * (x -= 1.5 / d1) * x + 0.75;
            }
            else if (x < 2.5 / d1)
            {
                factor = n1 * (x -= 2.25 / d1) * x + 0.9375;
            }
            else
            {
                factor = n1 * (x -= 2.625 / d1) * x + 0.984375;
            }

            return Interpolations.lerp(a, b, factor);
        }
    },
    BOUNCE_INOUT("bounce_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = x < 0.5
                ? (1 - BOUNCE_OUT.interpolate(0, 1, 1 - 2 * x)) / 2
                : (1 + BOUNCE_OUT.interpolate(0, 1, 2 * x - 1)) / 2;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = x < 0.5
                ? (1 - BOUNCE_OUT.interpolate(0, 1, 1 - 2 * x)) / 2
                : (1 + BOUNCE_OUT.interpolate(0, 1, 2 * x - 1)) / 2;

            return Interpolations.lerp(a, b, factor);
        }
    },
    SINE_IN("sine_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = 1 - (float) Math.cos((x * Math.PI) / 2);

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = 1 - (float) Math.cos((x * Math.PI) / 2);

            return Interpolations.lerp(a, b, factor);
        }
    },
    SINE_OUT("sine_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = (float) Math.sin((x * Math.PI) / 2);

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = Math.sin((x * Math.PI) / 2);

            return Interpolations.lerp(a, b, factor);
        }
    },
    SINE_INOUT("sine_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = (float) (-(Math.cos(Math.PI * x) - 1) / 2);

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = -(Math.cos(Math.PI * x) - 1) / 2;

            return Interpolations.lerp(a, b, factor);
        }
    },
    QUART_IN("quart_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = x * x * x * x;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = x * x * x * x;

            return Interpolations.lerp(a, b, factor);
        }
    },
    QUART_OUT("quart_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = 1 - (float) Math.pow(1 - x, 4);

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = 1 - Math.pow(1 - x, 4);

            return Interpolations.lerp(a, b, factor);
        }
    },
    QUART_INOUT("quart_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = x < 0.5 ? 8 * x * x * x * x : 1 - (float) Math.pow(-2 * x + 2, 4) / 2;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2;

            return Interpolations.lerp(a, b, factor);
        }
    },
    QUINT_IN("quint_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = x * x * x * x * x;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = x * x * x * x * x;

            return Interpolations.lerp(a, b, factor);
        }
    },
    QUINT_OUT("quint_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = 1 - (float) Math.pow(1 - x, 5);

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = 1 - Math.pow(1 - x, 5);

            return Interpolations.lerp(a, b, factor);
        }
    },
    QUINT_INOUT("quint_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            float factor = x < 0.5 ? 16 * x * x * x * x * x : 1 - (float) Math.pow(-2 * x + 2, 5) / 2;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            double factor = x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2;

            return Interpolations.lerp(a, b, factor);
        }
    },
    CIRCLE_IN("circle_in")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            x = MathUtils.clamp(x, 0, 1);

            float factor = 1 - (float) Math.sqrt(1 - Math.pow(x, 2));

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            x = MathUtils.clamp(x, 0, 1);

            double factor = 1 - (float) Math.sqrt(1 - Math.pow(x, 2));

            return Interpolations.lerp(a, b, factor);
        }
    },
    CIRCLE_OUT("circle_out")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            x = MathUtils.clamp(x, 0, 1);

            float factor = (float) Math.sqrt(1 - Math.pow(x - 1, 2));

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            x = MathUtils.clamp(x, 0, 1);

            double factor = Math.sqrt(1 - Math.pow(x - 1, 2));

            return Interpolations.lerp(a, b, factor);
        }
    },
    CIRCLE_INOUT("circle_inout")
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            x = MathUtils.clamp(x, 0, 1);

            float factor = x < 0.5
                ? (float) (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2
                : (float) (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;

            return Interpolations.lerp(a, b, factor);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            x = MathUtils.clamp(x, 0, 1);

            double factor = x < 0.5
                ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2
                : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2;

            return Interpolations.lerp(a, b, factor);
        }
    };

    public final String key;

    private Interpolation(String key)
    {
        this.key = key;
    }

    @SideOnly(Side.CLIENT)
    public String getKey()
    {
        return "mclib.interpolations." + this.key;
    }

    @SideOnly(Side.CLIENT)
    public String getTooltipKey()
    {
        return "mclib.interpolations.tooltips." + this.key;
    }
}

==================================================

--- Файл №267 ---
Путь: main\java\mchorse\mclib\utils\Interpolations.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.util.math.MathHelper;

/**
 * Interpolation methods
 *
 * This class is responsible for doing different kind of interpolations. Cubic
 * interpolation code was from website below, but BauerCam also uses this code.
 *
 * @author mchorse
 * @link http://paulbourke.net/miscellaneous/interpolation/
 * @link https://github.com/daipenger/BauerCam
 */
public class Interpolations
{
    /**
     * Linear interpolation
     */
    public static float lerp(float a, float b, float position)
    {
        return a + (b - a) * position;
    }

    /**
     * Special interpolation method for interpolating yaw. The problem with yaw,
     * is that it may go in the "wrong" direction when having, for example,
     * -170 (as a) and 170 (as b) degress or other way around (170 and -170).
     *
     * This interpolation method fixes this problem.
     */
    public static float lerpYaw(float a, float b, float position)
    {
        a = MathHelper.wrapDegrees(a);
        b = MathHelper.wrapDegrees(b);

        return lerp(a, normalizeYaw(a, b), position);
    }

    /**
     * Cubic interpolation using Hermite between y1 and y2. Taken from paul's
     * website.
     *
     * @param y0 - points[x-1]
     * @param y1 - points[x]
     * @param y2 - points[x+1]
     * @param y3 - points[x+2]
     * @param x - step between 0 and 1
     */
    public static double cubicHermite(double y0, double y1, double y2, double y3, double x)
    {
        double a = -0.5 * y0 + 1.5 * y1 - 1.5 * y2 + 0.5 * y3;
        double b = y0 - 2.5 * y1 + 2 * y2 - 0.5 * y3;
        double c = -0.5 * y0 + 0.5 * y2;

        return ((a * x + b) * x + c) * x + y1;
    }

    /**
     * Yaw normalization for cubic interpolation
     */
    public static double cubicHermiteYaw(float y0, float y1, float y2, float y3, float position)
    {
        y0 = MathHelper.wrapDegrees(y0);
        y1 = MathHelper.wrapDegrees(y1);
        y2 = MathHelper.wrapDegrees(y2);
        y3 = MathHelper.wrapDegrees(y3);

        y1 = normalizeYaw(y0, y1);
        y2 = normalizeYaw(y1, y2);
        y3 = normalizeYaw(y2, y3);

        return cubicHermite(y0, y1, y2, y3, position);
    }

    /**
     * Cubic interpolation between y1 and y2. Taken from paul's website.
     *
     * @param y0 - points[x-1]
     * @param y1 - points[x]
     * @param y2 - points[x+1]
     * @param y3 - points[x+2]
     * @param x - step between 0 and 1
     */
    public static float cubic(float y0, float y1, float y2, float y3, float x)
    {
        float a = y3 - y2 - y0 + y1;
        float b = y0 - y1 - a;
        float c = y2 - y0;

        return ((a * x + b) * x + c) * x + y1;
    }

    /**
     * Yaw normalization for cubic interpolation
     */
    public static float cubicYaw(float y0, float y1, float y2, float y3, float position)
    {
        y0 = MathHelper.wrapDegrees(y0);
        y1 = MathHelper.wrapDegrees(y1);
        y2 = MathHelper.wrapDegrees(y2);
        y3 = MathHelper.wrapDegrees(y3);

        y1 = normalizeYaw(y0, y1);
        y2 = normalizeYaw(y1, y2);
        y3 = normalizeYaw(y2, y3);

        return cubic(y0, y1, y2, y3, position);
    }

    /**
     * Calculate X value for given T using some brute force algorithm... 
     * This method should be precise enough
     * 
     * @param x1 - control point of initial value
     * @param x2 - control point of final value
     * @param t - time (should be 0..1)
     * @param epsilon - delta that would satisfy the approximation 
     */
    public static float bezierX(float x1, float x2, float t, final float epsilon)
    {
        float x = t;
        float init = bezier(0, x1, x2, 1, t);
        float factor = Math.copySign(0.1F, t - init);

        while (Math.abs(t - init) > epsilon)
        {
            float oldFactor = factor;

            x += factor;
            init = bezier(0, x1, x2, 1, x);

            if (Math.copySign(factor, t - init) != oldFactor)
            {
                factor *= -0.25F;
            }
        }

        return x;
    }

    /**
     * Calculate X value for given T using default epsilon value. See 
     * other overload method for more information. 
     */
    public static float bezierX(float x1, float x2, float t)
    {
        return bezierX(x1, x2, t, 0.0005F);
    }

    /**
     * Calculate cubic bezier from given variables
     * 
     * @param x1 - initial value
     * @param x2 - control point of initial value
     * @param x3 - control point of final value
     * @param x4 - final value
     * @param t - time (should be 0..1)
     */
    public static float bezier(float x1, float x2, float x3, float x4, float t)
    {
        float t1 = lerp(x1, x2, t);
        float t2 = lerp(x2, x3, t);
        float t3 = lerp(x3, x4, t);
        float t4 = lerp(t1, t2, t);
        float t5 = lerp(t2, t3, t);

        return lerp(t4, t5, t);
    }

    /**
     * Normalize yaw rotation (argument {@code b}) based on the previous
     * yaw rotation.
     */
    public static float normalizeYaw(float a, float b)
    {
        float diff = a - b;

        if (diff > 180 || diff < -180)
        {
            diff = Math.copySign(360 - Math.abs(diff), diff);

            return a + diff;
        }

        return b;
    }

    /**
     * Envelope function allows to create simple attack, sustain and release function.
     *
     * This version only goes from 0 to duration with fade in/out being the same
     */
    public static float envelope(float x, float duration, float fades)
    {
        return envelope(x, 0, fades, duration - fades, duration);
    }

    /**
     * Envelope function allows to create simple attack, sustain and release function.
     *
     * This advanced version allows you to specify a more customized range
     */
    public static float envelope(float x, float lowIn, float lowOut, float highIn, float highOut)
    {
        if (x < lowIn || x > highOut) return 0;
        if (x < lowOut) return (x - lowIn) / (lowOut - lowIn);
        if (x > highIn) return 1 - (x - highIn) / (highOut - highIn);

        return 1;
    }

    /* --- Double versions of the functions --- */

    /**
     * Linear interpolation
     */
    public static double lerp(double a, double b, double position)
    {
        return a + (b - a) * position;
    }

    /**
     * Special interpolation method for interpolating yaw. The problem with yaw,
     * is that it may go in the "wrong" direction when having, for example,
     * -170 (as a) and 170 (as b) degress or other way around (170 and -170).
     *
     * This interpolation method fixes this problem.
     */
    public static double lerpYaw(double a, double b, double position)
    {
        a = MathHelper.wrapDegrees(a);
        b = MathHelper.wrapDegrees(b);

        return lerp(a, normalizeYaw(a, b), position);
    }

    /**
     * Cubic interpolation between y1 and y2. Taken from paul's website.
     *
     * @param y0 - points[x-1]
     * @param y1 - points[x]
     * @param y2 - points[x+1]
     * @param y3 - points[x+2]
     * @param x - step between 0 and 1
     */
    public static double cubic(double y0, double y1, double y2, double y3, double x)
    {
        double a = y3 - y2 - y0 + y1;
        double b = y0 - y1 - a;
        double c = y2 - y0;

        return ((a * x + b) * x + c) * x + y1;
    }

    /**
     * Yaw normalization for cubic interpolation
     */
    public static double cubicYaw(double y0, double y1, double y2, double y3, double position)
    {
        y0 = MathHelper.wrapDegrees(y0);
        y1 = MathHelper.wrapDegrees(y1);
        y2 = MathHelper.wrapDegrees(y2);
        y3 = MathHelper.wrapDegrees(y3);

        y1 = normalizeYaw(y0, y1);
        y2 = normalizeYaw(y1, y2);
        y3 = normalizeYaw(y2, y3);

        return cubic(y0, y1, y2, y3, position);
    }

    /**
     * Calculate X value for given T using some brute force algorithm... 
     * This method should be precise enough
     * 
     * @param x1 - control point of initial value
     * @param x2 - control point of final value
     * @param t - time (should be 0..1)
     * @param epsilon - delta that would satisfy the approximation 
     */
    public static double bezierX(double x1, double x2, double t, final double epsilon)
    {
        double x = t;
        double init = bezier(0, x1, x2, 1, t);
        double factor = Math.copySign(0.1F, t - init);

        while (Math.abs(t - init) > epsilon)
        {
            double oldFactor = factor;

            x += factor;
            init = bezier(0, x1, x2, 1, x);

            if (Math.copySign(factor, t - init) != oldFactor)
            {
                factor *= -0.25F;
            }
        }

        return x;
    }

    /**
     * Calculate X value for given T using default epsilon value. See 
     * other overload method for more information. 
     */
    public static double bezierX(double x1, double x2, float t)
    {
        return bezierX(x1, x2, t, 0.0005F);
    }

    /**
     * Calculate cubic bezier from given variables
     * 
     * @param x1 - initial value
     * @param x2 - control point of initial value
     * @param x3 - control point of final value
     * @param x4 - final value
     * @param t - time (should be 0..1)
     */
    public static double bezier(double x1, double x2, double x3, double x4, double t)
    {
        double t1 = lerp(x1, x2, t);
        double t2 = lerp(x2, x3, t);
        double t3 = lerp(x3, x4, t);
        double t4 = lerp(t1, t2, t);
        double t5 = lerp(t2, t3, t);

        return lerp(t4, t5, t);
    }

    /**
     * Normalize yaw rotation (argument {@code b}) based on the previous
     * yaw rotation.
     */
    public static double normalizeYaw(double a, double b)
    {
        double diff = a - b;

        if (diff > 180 || diff < -180)
        {
            diff = Math.copySign(360 - Math.abs(diff), diff);

            return a + diff;
        }

        return b;
    }

    /**
     * Envelope function allows to create simple attack, sustain and release function.
     *
     * This version only goes from 0 to duration with fade in/out being the same
     */
    public static double envelope(double x, double duration, double fades)
    {
        return envelope(x, 0, fades, duration - fades, duration);
    }

    /**
     * Envelope function allows to create simple attack, sustain and release function.
     *
     * This advanced version allows you to specify a more customized range
     */
    public static double envelope(double x, double lowIn, double lowOut, double highIn, double highOut)
    {
        if (x < lowIn || x > highOut) return 0;
        if (x < lowOut) return (x - lowIn) / (lowOut - lowIn);
        if (x > highIn) return 1 - (x - highIn) / (highOut - highIn);

        return 1;
    }
}

==================================================

--- Файл №268 ---
Путь: main\java\mchorse\mclib\utils\ITransformationObject.java
--------------------
package mchorse.mclib.utils;

import mchorse.mclib.client.gui.framework.elements.input.GuiTransformations;

public interface ITransformationObject
{
    void addTranslation(double x, double y, double z, GuiTransformations.TransformOrientation orientation);
}


==================================================

--- Файл №269 ---
Путь: main\java\mchorse\mclib\utils\JsonUtils.java
--------------------
package mchorse.mclib.utils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonElement;
import com.google.gson.stream.JsonWriter;

import java.io.StringWriter;

public class JsonUtils
{
    public static String jsonToPretty(JsonElement element)
    {
        StringWriter writer = new StringWriter();
        JsonWriter jsonWriter = new JsonWriter(writer);
        Gson gson = new GsonBuilder().setPrettyPrinting().create();

        jsonWriter.setIndent("    ");
        gson.toJson(element, jsonWriter);

        /* Prettify arrays */
        return writer.toString();
    }
}

==================================================

--- Файл №270 ---
Путь: main\java\mchorse\mclib\utils\Keys.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.Minecraft;

import java.util.List;

import org.lwjgl.input.Keyboard;

import com.google.common.collect.ImmutableList;

public class Keys
{
    public static final String[] KEYS = new String[Keyboard.KEYBOARD_SIZE];
    public static final List<Integer> MODIFIERS = ImmutableList.<Integer>of(Keyboard.KEY_LCONTROL, Keyboard.KEY_LSHIFT, Keyboard.KEY_LMENU, Keyboard.KEY_RCONTROL, Keyboard.KEY_RSHIFT, Keyboard.KEY_RMENU);
    public static final String[] MODNAME = new String[] {"Ctrl", "Shift", "Alt"};

    public static String getKeyName(int key)
    {
        if (key < Keyboard.KEY_NONE || key >= Keyboard.KEYBOARD_SIZE)
        {
            return null;
        }

	// Adding this line prevents a null-pointer exception
        if (KEYS[key] == null)
        {
            KEYS[key] = getKey(key);
            if (KEYS[key] == null) {
                return "Unknown key";
            }
        }

        return KEYS[key];
    }

    private static String getKey(int key)
    {
        switch (key)
        {
            case Keyboard.KEY_MINUS:
                return "-";
            case Keyboard.KEY_EQUALS:
                return "=";
            case Keyboard.KEY_LBRACKET:
                return "[";
            case Keyboard.KEY_RBRACKET:
                return "]";
            case Keyboard.KEY_SEMICOLON:
                return ";";
            case Keyboard.KEY_APOSTROPHE:
                return "'";
            case Keyboard.KEY_BACKSLASH:
                return "\\";
            case Keyboard.KEY_COMMA:
                return ",";
            case Keyboard.KEY_PERIOD:
                return ".";
            case Keyboard.KEY_SLASH:
                return "/";
            case Keyboard.KEY_GRAVE:
                return "`";
            case Keyboard.KEY_TAB:
                return "Tab";
            case Keyboard.KEY_CAPITAL:
                return "Caps Lock";
            case Keyboard.KEY_LSHIFT:
                return "L. Shift";
            case Keyboard.KEY_LCONTROL:
                return "L. Ctrl";
            case Keyboard.KEY_LMENU:
                return "L. Alt";
            case Keyboard.KEY_LMETA:
                return Minecraft.IS_RUNNING_ON_MAC ? "L. Cmd" : "L. Win";
            case Keyboard.KEY_RSHIFT:
                return "R. Shift";
            case Keyboard.KEY_RCONTROL:
                return "R. Ctrl";
            case Keyboard.KEY_RMENU:
                return "R. Alt";
            case Keyboard.KEY_RMETA:
                return Minecraft.IS_RUNNING_ON_MAC ? "R. Cmd" : "R. Win";
            case Keyboard.KEY_DIVIDE:
                return "Numpad /";
            case Keyboard.KEY_MULTIPLY:
                return "Numpad *";
            case Keyboard.KEY_SUBTRACT:
                return "Numpad -";
            case Keyboard.KEY_ADD:
                return "Numpad +";
            case Keyboard.KEY_DECIMAL:
                return "Numpad .";
        }

        String name = Keyboard.getKeyName(key);

	// Adding this line prevents a null-pointer exception
	if (name == null) {
            return null;
        }

        if (name.length() > 1)
        {
            name = name.substring(0, 1) + name.substring(1).toLowerCase();
        }

        if (name.startsWith("Numpad"))
        {
            name = name.replace("Numpad", "Numpad ");
        }

        return name;
    }

    /* Combo keys */

    public static int getComboKeyCode(int[] held, int keyCode)
    {
        int comboKey = keyCode;
        int modifierIndex = MODIFIERS.indexOf(keyCode) % 3;

        if (held != null)
        {
            for (int heldKey : held)
            {
                int index = MODIFIERS.indexOf(heldKey) % 3;

                if (index >= 0 && index != modifierIndex)
                {
                    comboKey |= 1 << 31 - index;
                }
            }
        }

        return comboKey;
    }

    public static void main(String...args)
    {
        System.out.println(getComboKeyName(getComboKeyCode(new int[] {Keyboard.KEY_RSHIFT, Keyboard.KEY_LMENU, Keyboard.KEY_LCONTROL, Keyboard.KEY_RCONTROL}, Keyboard.KEY_RMENU)));
    }

    public static int getMainKey(int comboKey)
    {
        int key = comboKey & 0x1FFFFFFF;

        if (key >= Keyboard.KEYBOARD_SIZE)
        {
            key = Keyboard.KEY_NONE;
        }

        return key;
    }

    public static String getComboKeyName(int comboKey)
    {
        StringBuilder builder = new StringBuilder();
        int mainKey = getMainKey(comboKey);

        if (mainKey == Keyboard.KEY_NONE)
        {
            return getKeyName(mainKey);
        }

        for (int i = 0; i < 3; i++)
        {
            if ((comboKey & 1 << 31 - i) != 0)
            {
                builder.append(MODNAME[i]).append(" + ");
            }
        }

        builder.append(getKeyName(mainKey));

        return builder.toString();
    }

    public static boolean checkModifierKeys(int comboKey)
    {
        int index = MODIFIERS.indexOf(getMainKey(comboKey)) % 3;

        for (int i = 0; i < 3; i++)
        {
            if (i == index)
            {
                continue;
            }

            if ((comboKey & 1 << 31 - i) != 0 != isKeyDown(MODIFIERS.get(i)))
            {
                return false;
            }
        }

        return true;
    }

    public static boolean isKeyDown(int key)
    {
        if (key == Keyboard.KEY_LSHIFT || key == Keyboard.KEY_RSHIFT)
        {
            return Keyboard.isKeyDown(Keyboard.KEY_LSHIFT) || Keyboard.isKeyDown(Keyboard.KEY_RSHIFT);
        }
        else if (key == Keyboard.KEY_LCONTROL || key == Keyboard.KEY_RCONTROL)
        {
            return Keyboard.isKeyDown(Keyboard.KEY_LCONTROL) || Keyboard.isKeyDown(Keyboard.KEY_RCONTROL);
        }
        else if (key == Keyboard.KEY_LMENU || key == Keyboard.KEY_RMENU)
        {
            return Keyboard.isKeyDown(Keyboard.KEY_LMENU) || Keyboard.isKeyDown(Keyboard.KEY_RMENU);
        }

        return Keyboard.isKeyDown(key);
    }
}


==================================================

--- Файл №271 ---
Путь: main\java\mchorse\mclib\utils\LatencyTimer.java
--------------------
package mchorse.mclib.utils;

import io.netty.buffer.ByteBuf;
import mchorse.mclib.network.IByteBufSerializable;

/**
 * This class is used to clock the time it takes to
 * send something between server and client to sync data like audio.
 *
 * @author Christian F. (known as Chryfi)
 */
public class LatencyTimer implements IByteBufSerializable
{
    private long startTime;
    private long endTime;

    /**
     * Saves the system time it has been created
     */
    public LatencyTimer()
    {
        this.startTime = System.currentTimeMillis();
    }

    /**
     * Sets the endTime, if it has not been set yet, to the current system time in milliseconds.
     */
    public void finish()
    {
        if (this.endTime == 0)
        {
            this.endTime = System.currentTimeMillis();
        }
    }

    /**
     * @param raw when true it just calculates the elapsed time,
     *            when false it takes into account the difference between server and client time from ClientHandlerTimeSync class.
     * @return the elapsed time in milliseconds since the creation of this object
     * or if this timer has finished, the elapsed time from start to end.
     */
    public long getElapsedTime()
    {
        return Math.abs((this.endTime != 0) ? (this.endTime - this.startTime) : (System.currentTimeMillis() - this.startTime));
    }

    @Override
    public void fromBytes(ByteBuf buf)
    {
        LatencyTimer timer = new LatencyTimer();

        timer.startTime = buf.readLong();
        timer.endTime = buf.readLong();
    }

    @Override
    public void toBytes(ByteBuf buf)
    {
        buf.writeLong(this.startTime);
        buf.writeLong(this.endTime);
    }
}


==================================================

--- Файл №272 ---
Путь: main\java\mchorse\mclib\utils\MathUtils.java
--------------------
package mchorse.mclib.utils;

public class MathUtils
{
    public static int clamp(int x, int min, int max)
    {
        return x < min ? min : (x > max ? max : x);
    }

    public static<T extends Comparable> T clamp(T x, T min, T max)
    {
        return x.compareTo(min) < 0 ? min : (x.compareTo(max) > 0 ? max : x);
    }

    public static float clamp(float x, float min, float max)
    {
        return x < min ? min : (x > max ? max : x);
    }

    public static double clamp(double x, double min, double max)
    {
        return x < min ? min : (x > max ? max : x);
    }

    public static long clamp(long x, long min, long max)
    {
        return x < min ? min : (x > max ? max : x);
    }

    public static int cycler(int x, int min, int max)
    {
        return x < min ? max : (x > max ? min : x);
    }

    public static float cycler(float x, float min, float max)
    {
        return x < min ? max : (x > max ? min : x);
    }

    public static double cycler(double x, double min, double max)
    {
        return x < min ? max : (x > max ? min : x);
    }

    public static int gridIndex(int x, int y, int size, int width)
    {
        x = x / size;
        y = y / size;

        return x + y * width / size;
    }

    public static int gridRows(int count, int size, int width)
    {
        double x = count * size / (double) width;

        return count <= 0 ? 1 : (int) Math.ceil(x);
    }

    /**
     * Remove 360 degrees of flips between previous and current angle.
     * A difference greater or equal than 180 degrees will be treated as a flip.
     * @param prev previous angle in radians
     * @param current current angle in radians
     * @return cleaned current in radians
     */
    public static float filterFlips(float prev, float current)
    {
        final float sign = (prev > current) ? 1 : -1;
        final float add = sign * 2.0F * (float) Math.PI;

        while (Math.abs(prev - current) >= Math.PI)
        {
            current += add;
        }

        return current;
    }
}

==================================================

--- Файл №273 ---
Путь: main\java\mchorse\mclib\utils\MatrixUtils.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.Minecraft;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import javax.annotation.Nullable;
import javax.vecmath.*;
import java.nio.DoubleBuffer;
import java.nio.FloatBuffer;

@SideOnly(Side.CLIENT)
public class MatrixUtils
{
    /**
     * Model view matrix buffer
     */
    public static final FloatBuffer buffer = BufferUtils.createFloatBuffer(16);

    /**
     * Float array for transferring data from FloatBuffer to the matrix
     */
    public static final float[] floats = new float[16];

    /**
     * Model view matrix captured here
     */
    public static Matrix4f matrix;

    private static final DoubleBuffer doubleBuffer = BufferUtils.createDoubleBuffer(16);
    private static final double[] doubles = new double[16];
    private static final Matrix4d camera = new Matrix4d();

    public static Matrix4d getCameraMatrix()
    {
        return new Matrix4d(camera);
    }

    /**
     * Read OpenGL's model view matrix
     */
    public static Matrix4f readModelView(Matrix4f matrix4f)
    {
        buffer.clear();
        GL11.glGetFloat(GL11.GL_MODELVIEW_MATRIX, buffer);
        buffer.get(floats);

        matrix4f.set(floats);
        matrix4f.transpose();

        return matrix4f;
    }

    /**
     * This method is called by the ASMAfterCamera method. It saves the camera modelview matrix after the camera is set up.
     * The camera matrix will be used to calculate global transformations of models.
     * Thank you to MiaoNLI for discovering this possibility.
     */
    private static void readCamera()
    {
        doubleBuffer.clear();
        GL11.glGetDouble(GL11.GL_MODELVIEW_MATRIX, doubleBuffer);
        doubleBuffer.get(doubles);
        camera.set(doubles);
        camera.transpose();
    }

    public static Matrix4f readModelView()
    {
        return readModelView(new Matrix4f());
    }

    public static Matrix4d readModelViewDouble()
    {
        doubleBuffer.clear();
        GL11.glGetDouble(GL11.GL_MODELVIEW_MATRIX, doubleBuffer);
        doubleBuffer.get(doubles);

        Matrix4d matrix4d = new Matrix4d();

        matrix4d.set(doubles);
        matrix4d.transpose();

        return matrix4d;
    }

    /**
     * Replace model view matrix with given matrix
     */
    public static void loadModelView(Matrix4f matrix4f)
    {
        matrixToFloat(floats, matrix4f);

        buffer.clear();
        buffer.put(floats);
        buffer.rewind();
        GL11.glLoadMatrix(buffer);
    }

    /**
     * method to fill the float array with values from the matrix
     */
    public static void matrixToFloat(float[] floats, Matrix4f matrix4f)
    {
        floats[0] = matrix4f.m00;
        floats[1] = matrix4f.m01;
        floats[2] = matrix4f.m02;
        floats[3] = matrix4f.m03;
        floats[4] = matrix4f.m10;
        floats[5] = matrix4f.m11;
        floats[6] = matrix4f.m12;
        floats[7] = matrix4f.m13;
        floats[8] = matrix4f.m20;
        floats[9] = matrix4f.m21;
        floats[10] = matrix4f.m22;
        floats[11] = matrix4f.m23;
        floats[12] = matrix4f.m30;
        floats[13] = matrix4f.m31;
        floats[14] = matrix4f.m32;
        floats[15] = matrix4f.m33;
    }

    /**
     * @param floatBuffer with the minimum size of 16
     * @param matrix
     */
    public static void matrixToFloatBuffer(FloatBuffer floatBuffer, Matrix4f matrix)
    {
        floatBuffer.put(matrix.m00);
        floatBuffer.put(matrix.m01);
        floatBuffer.put(matrix.m02);
        floatBuffer.put(matrix.m03);
        floatBuffer.put(matrix.m10);
        floatBuffer.put(matrix.m11);
        floatBuffer.put(matrix.m12);
        floatBuffer.put(matrix.m13);
        floatBuffer.put(matrix.m20);
        floatBuffer.put(matrix.m21);
        floatBuffer.put(matrix.m22);
        floatBuffer.put(matrix.m23);
        floatBuffer.put(matrix.m30);
        floatBuffer.put(matrix.m31);
        floatBuffer.put(matrix.m32);
        floatBuffer.put(matrix.m33);

        floatBuffer.flip();
    }


    public static boolean captureMatrix()
    {
        if (matrix == null)
        {
            matrix = MatrixUtils.readModelView(new Matrix4f());

            return true;
        }

        return false;
    }

    public static void ASMAfterCamera()
    {
        readCamera();
    }

    public static void releaseMatrix()
    {
        matrix = null;
    }

    public static Quat4d matrixToQuaternion(Matrix3f matrix)
    {
        double tr = matrix.m00 + matrix.m11 + matrix.m22;
        double qw = 0;
        double qx = 0;
        double qy = 0;
        double qz = 0;

        if (tr > 0)
        {
            double S = Math.sqrt(tr+1.0) * 2; // S=4*qw
            qw = 0.25 * S;
            qx = (matrix.m21 - matrix.m12) / S;
            qy = (matrix.m02 - matrix.m20) / S;
            qz = (matrix.m10 - matrix.m01) / S;
        }
        else if ((matrix.m00 > matrix.m11) & (matrix.m00 > matrix.m22))
        {
            double S = Math.sqrt(1.0 + matrix.m00 - matrix.m11 - matrix.m22) * 2; // S=4*qx
            qw = (matrix.m21 - matrix.m12) / S;
            qx = 0.25 * S;
            qy = (matrix.m01 + matrix.m10) / S;
            qz = (matrix.m02 + matrix.m20) / S;
        }
        else if (matrix.m11 > matrix.m22)
        {
            double S = Math.sqrt(1.0 + matrix.m11 - matrix.m00 - matrix.m22) * 2; // S=4*qy
            qw = (matrix.m02 - matrix.m20) / S;
            qx = (matrix.m01 + matrix.m10) / S;
            qy = 0.25 * S;
            qz = (matrix.m12 + matrix.m21) / S;
        }
        else
        {
            double S = Math.sqrt(1.0 + matrix.m22 - matrix.m00 - matrix.m11) * 2; // S=4*qz
            qw = (matrix.m10 - matrix.m01) / S;
            qx = (matrix.m02 + matrix.m20) / S;
            qy = (matrix.m12 + matrix.m21) / S;
            qz = 0.25 * S;
        }

        return new Quat4d(qw, qx, qy, qz);
    }

    /**
     * This method calculates the angular velocity around the arbitrary axis.
     * The arbitrary axis and the angle around it can be obtained from this result.
     * @param rotation
     * @return the angular velocity vector.
     */
    public static Vector3f getAngularVelocity(Matrix3f rotation)
    {
        Matrix3f step = new Matrix3f(rotation);
        Matrix3f angularVelocity = new Matrix3f();
        Matrix3f i = new Matrix3f();

        i.setIdentity();
        angularVelocity.setIdentity();
        angularVelocity.mul(2);

        step.add(i);
        step.invert();
        step.mul(4);

        angularVelocity.sub(step);

        Vector3f angularV = new Vector3f(angularVelocity.m21,
                                    -angularVelocity.m20,
                                     angularVelocity.m10);

        return angularV;
    }

    /**
     * Calculate an intrinsic rotation matrix based on the given order and the angles.
     * @param x angle in radians
     * @param y angle in radians
     * @param z angle in radians
     * @param order order of the rotation matrix
     * @return intrinsic rotation matrix
     */
    public static Matrix4f getRotationMatrix(float x, float y, float z, RotationOrder order)
    {
        Matrix4f mat = new Matrix4f();
        Matrix4f rot = new Matrix4f();

        mat.setIdentity();

        switch (order)
        {
            case XYZ:
                rot.rotZ(z);
                mat.mul(rot);
                rot.rotY(y);
                mat.mul(rot);
                rot.rotX(x);
                mat.mul(rot);

                break;
            case ZYX:
                rot.rotX(x);
                mat.mul(rot);
                rot.rotY(y);
                mat.mul(rot);
                rot.rotZ(z);
                mat.mul(rot);

                break;
            case XZY:
                rot.rotY(y);
                mat.mul(rot);
                rot.rotZ(z);
                mat.mul(rot);
                rot.rotX(x);
                mat.mul(rot);

                break;
            case YZX:
                rot.rotX(x);
                mat.mul(rot);
                rot.rotZ(z);
                mat.mul(rot);
                rot.rotY(y);
                mat.mul(rot);

                break;
            case YXZ:
                rot.rotZ(z);
                mat.mul(rot);
                rot.rotX(x);
                mat.mul(rot);
                rot.rotY(y);
                mat.mul(rot);

                break;
            case ZXY:
                rot.rotY(y);
                mat.mul(rot);
                rot.rotX(x);
                mat.mul(rot);
                rot.rotZ(z);
                mat.mul(rot);

                break;
        }

        return mat;
    }

    /**
     * Calculates the current global transformations
     * @return Matrix4d array {translation, rotation, scale} or null if singular matrix exception occured during inverting the camera matrix.
     */
    public static Matrix4d[] getTransformation()
    {
        Matrix4d parent = new Matrix4d(camera);
        Matrix4d translation = new Matrix4d();
        Matrix4d rotation = new Matrix4d();
        Matrix4d scale = new Matrix4d();

        translation.setIdentity();
        rotation.setIdentity();
        scale.setIdentity();

        try
        {
            parent.invert();
        }
        catch (SingularMatrixException e)
        {
            return null;
        }

        parent.mul(parent, readModelViewDouble());

        Entity renderViewEntity = Minecraft.getMinecraft().getRenderViewEntity();

        Matrix4d cameraTrans = new Matrix4d();

        cameraTrans.setIdentity();
        cameraTrans.m03 = Interpolations.lerp(renderViewEntity.lastTickPosX, renderViewEntity.posX, Minecraft.getMinecraft().getRenderPartialTicks());
        cameraTrans.m13 = Interpolations.lerp(renderViewEntity.lastTickPosY, renderViewEntity.posY, Minecraft.getMinecraft().getRenderPartialTicks());
        cameraTrans.m23 = Interpolations.lerp(renderViewEntity.lastTickPosZ, renderViewEntity.posZ, Minecraft.getMinecraft().getRenderPartialTicks());

        parent.mul(cameraTrans, parent);

        Vector4d rx = new Vector4d(parent.m00, parent.m10, parent.m20, 0);
        Vector4d ry = new Vector4d(parent.m01, parent.m11, parent.m21, 0);
        Vector4d rz = new Vector4d(parent.m02, parent.m12, parent.m22, 0);

        rx.normalize();
        ry.normalize();
        rz.normalize();
        rotation.setRow(0, rx);
        rotation.setRow(1, ry);
        rotation.setRow(2, rz);

        translation.setTranslation(new Vector3d(parent.m03, parent.m13, parent.m23));

        scale.m00 = Math.sqrt(parent.m00 * parent.m00 + parent.m10 * parent.m10 + parent.m20 * parent.m20);
        scale.m11 = Math.sqrt(parent.m01 * parent.m01 + parent.m11 * parent.m11 + parent.m21 * parent.m21);
        scale.m22 = Math.sqrt(parent.m02 * parent.m02 + parent.m12 * parent.m12 + parent.m22 * parent.m22);

        return new Matrix4d[]{translation, rotation, scale};
    }

    public static Transformation getTransformation(Matrix4d transform)
    {
        Matrix4d translation = new Matrix4d();
        Matrix4d rotation = new Matrix4d();
        Matrix4d scale = new Matrix4d();

        translation.setIdentity();
        rotation.setIdentity();
        scale.setIdentity();

        Vector4d rx = new Vector4d(transform.m00, transform.m10, transform.m20, 0);
        Vector4d ry = new Vector4d(transform.m01, transform.m11, transform.m21, 0);
        Vector4d rz = new Vector4d(transform.m02, transform.m12, transform.m22, 0);

        rx.normalize();
        ry.normalize();
        rz.normalize();
        rotation.setRow(0, rx);
        rotation.setRow(1, ry);
        rotation.setRow(2, rz);

        translation.setTranslation(new Vector3d(transform.m03, transform.m13, transform.m23));

        scale.m00 = Math.sqrt(transform.m00 * transform.m00 + transform.m10 * transform.m10 + transform.m20 * transform.m20);
        scale.m11 = Math.sqrt(transform.m01 * transform.m01 + transform.m11 * transform.m11 + transform.m21 * transform.m21);
        scale.m22 = Math.sqrt(transform.m02 * transform.m02 + transform.m12 * transform.m12 + transform.m22 * transform.m22);

        return new Transformation(translation, rotation, scale);
    }


    /**
     * This method extracts the rotation, translation and scale from the modelview matrix. It needs the view matrix to work properly
     * @author Christian F. (known as Chryfi)
     * @param cameraMatrix The cameraMatrix from rendering so you can extract modelView from OpenGL's matrix.
     * @param modelView The matrix containing the transformations that should be extracted.
     * @return Transformation contains translation, rotation and scale as 4x4 matrices. It also has getter methods for the 3x3 matrices.
     */
    public static Transformation extractTransformations(@Nullable Matrix4f cameraMatrix, Matrix4f modelView)
    {
        return extractTransformations(cameraMatrix, modelView, MatrixMajor.ROW);
    }

    public static Transformation extractTransformations(@Nullable Matrix4f cameraMatrix, Matrix4f modelView, MatrixMajor major)
    {
        Matrix4f parent = new Matrix4f(modelView);

        if (cameraMatrix != null)
        {
            parent.set(cameraMatrix);

            try
            {
                parent.invert();
            }
            catch (SingularMatrixException e)
            {
                Transformation transformation = new Transformation();
                transformation.creationException = e;

                return transformation;
            }

            parent.mul(modelView);
        }

        Matrix4f translation = new Matrix4f();
        Matrix4f scale = new Matrix4f();
        Matrix4f rotation = new Matrix4f();

        translation.setIdentity();
        rotation.setIdentity();
        scale.setIdentity();

        translation.m03 = parent.m03;
        translation.m13 = parent.m13;
        translation.m23 = parent.m23;

        Vector4f ax = new Vector4f(parent.m00, parent.m01, parent.m02, 0);
        Vector4f ay = new Vector4f(parent.m10, parent.m11, parent.m12, 0);
        Vector4f az = new Vector4f(parent.m20, parent.m21, parent.m22, 0);

        if (major == MatrixMajor.COLUMN)
        {
            ax = new Vector4f(parent.m00, parent.m10, parent.m20, 0.0F);
            ay = new Vector4f(parent.m01, parent.m11, parent.m21, 0.0F);
            az = new Vector4f(parent.m02, parent.m12, parent.m22, 0.0F);
        }

        ax.normalize();
        ay.normalize();
        az.normalize();
        rotation.setRow(0, ax);
        rotation.setRow(1, ay);
        rotation.setRow(2, az);

        if (major == MatrixMajor.COLUMN)
        {
            rotation.transpose();
        }

        scale.m00 = (float) Math.sqrt(parent.m00 * parent.m00 + parent.m01 * parent.m01 + parent.m02 * parent.m02);
        scale.m11 = (float) Math.sqrt(parent.m10 * parent.m10 + parent.m11 * parent.m11 + parent.m12 * parent.m12);
        scale.m22 = (float) Math.sqrt(parent.m20 * parent.m20 + parent.m21 * parent.m21 + parent.m22 * parent.m22);

        if (major == MatrixMajor.COLUMN)
        {
            scale.m00 = (float) Math.sqrt(parent.m00 * parent.m00 + parent.m10 * parent.m10 + parent.m20 * parent.m20);
            scale.m11 = (float) Math.sqrt(parent.m01 * parent.m01 + parent.m11 * parent.m11 + parent.m21 * parent.m21);
            scale.m22 = (float) Math.sqrt(parent.m02 * parent.m02 + parent.m12 * parent.m12 + parent.m22 * parent.m22);
        }

        return new Transformation(translation, rotation, scale);
    }

    public static class Transformation
    {
        public Matrix4f translation = new Matrix4f();
        public Matrix4f rotation = new Matrix4f();
        public Matrix4f scale = new Matrix4f();
        /**
         * contains the exception that may have
         * occurred during calculation of transformation data
         */
        private Exception creationException = null;

        public Transformation(Matrix4f translation, Matrix4f rotation, Matrix4f scale)
        {
            this.translation.set(translation);
            this.rotation.set(rotation);
            this.scale.set(scale);
        }

        public Transformation(Matrix4d translation, Matrix4d rotation, Matrix4d scale)
        {
            this.translation.set(translation);
            this.rotation.set(rotation);
            this.scale.set(scale);
        }

        public Transformation()
        {
            this.translation.setIdentity();
            this.rotation.setIdentity();
            this.scale.setIdentity();
        }

        public Matrix3f getScale3f()
        {
            Matrix3f scale3f = new Matrix3f();

            scale3f.setIdentity();

            scale3f.m00 = this.scale.m00;
            scale3f.m11 = this.scale.m11;
            scale3f.m22 = this.scale.m22;

            return scale3f;
        }

        public Vector3f getTranslation3f()
        {
            Vector3f translation3f = new Vector3f();

            translation3f.set(this.translation.m03,this.translation.m13, this.translation.m23);

            return translation3f;
        }

        public Matrix3f getRotation3f()
        {
            Matrix3f rotation3f = new Matrix3f();

            rotation3f.setIdentity();
            rotation3f.setRow(0, this.rotation.m00, this.rotation.m01, this.rotation.m02);
            rotation3f.setRow(1, this.rotation.m10, this.rotation.m11, this.rotation.m12);
            rotation3f.setRow(2, this.rotation.m20, this.rotation.m21, this.rotation.m22);

            return rotation3f;
        }

        public Exception getCreationException()
        {
            return this.creationException;
        }

        public Vector3f getRotation(RotationOrder order)
        {
            return this.getRotation(order, null);
        }
        public Vector3f getRotation(RotationOrder order, Vector3f ref)
        {
            return this.getRotation(order, ref, 0);
        }
        public Vector3f getRotation(RotationOrder order, int invAxis)
        {
            return this.getRotation(order, null, invAxis);
        }

        /**
         * Get rotation values from matrix<br>
         * <b>It must be called first to determine if the value can be obtained
         * properly</b>
         * 
         * @param order   Rotation Order
         * @param ref     The vector used for reference. Null if nothing to refer. Make
         *                sure that the incoming matrix is not affected by negative
         *                scaling.
         * @param invAxis The axis to be inverted when the matrix is a left-handed
         *                coordinate system. 012 equals xyz
         * @return A vector includes rotation values with specific order, null if matrix
         *         is a illegal rotation matrix.<br>
         *         The returned vector will be as close to the reference vector as
         *         possible
         */
        public Vector3f getRotation(RotationOrder order, Vector3f ref, int invAxis)
        {
            Matrix3f mat = this.getRotation3f();
            float[] rotation = new float[3];
            float[] refFloats = null;
            if (ref != null)
            {
                refFloats = new float[3];
                ref.get(refFloats);
            }

            // DirectX -> OpenGL
            // If the scaling value has an odd number of negative values, this will cause it
            // to become a left-handed coordinate system.
            Vector3f x = new Vector3f(mat.m00, mat.m10, mat.m20);
            Vector3f y = new Vector3f(mat.m01, mat.m11, mat.m21);
            Vector3f z = new Vector3f(mat.m02, mat.m12, mat.m22);
            Vector3f crossY = new Vector3f();
            Vector3f originalY = new Vector3f();
            originalY.normalize(y);
            crossY.cross(z, x);
            crossY.normalize();

            if (crossY.dot(originalY) < 0)
            {
                mat.mul(getInvertAxisMatrix(invAxis));
            }

            Float angle = order.doTest(order.thirdIndex, mat);

            /* if the second rotation value is +/-90, here will be null. */
            if (angle != null)
            {
                if (refFloats != null)
                {
                    angle = refFloats[order.thirdIndex] + MathHelper.wrapDegrees(2F * (angle - refFloats[order.thirdIndex])) / 2F;
                }
                rotation[order.thirdIndex] = angle;
                mat.mul(getRotationMatrix(order.thirdIndex, -angle), mat);
            }
            else if (refFloats != null)
            {
                rotation[order.thirdIndex] = angle = refFloats[order.thirdIndex];
                mat.mul(getRotationMatrix(order.thirdIndex, -angle), mat);
            }
            angle = order.doTest(order.secondIndex, mat);

            if (angle == null)
            {
                // Illegal: Scale is zero, no rotation information here.
                return null;
            }

            if (refFloats != null)
            {
                angle = refFloats[order.secondIndex] + MathHelper.wrapDegrees(angle - refFloats[order.secondIndex]);
            }

            rotation[order.secondIndex] = angle;
            mat.mul(getRotationMatrix(order.secondIndex, -angle), mat);

            angle = order.doTest(order.firstIndex, mat);

            if (angle == null)
            {
                return null;
            }
            else if (refFloats != null)
            {
                angle = refFloats[order.firstIndex] + MathHelper.wrapDegrees(angle - refFloats[order.firstIndex]);
            }

            rotation[order.firstIndex] = angle;

            return new Vector3f(rotation);
        }

        public Vector3f getScale()
        {
            return this.getScale(0);
        }

        public Vector3f getScale(int invAxis)
        {
            Vector3f scale = new Vector3f(this.scale.m00, this.scale.m11, this.scale.m22);
            Vector3f x = new Vector3f(this.rotation.m00, this.rotation.m10, this.rotation.m20);
            Vector3f y = new Vector3f(this.rotation.m01, this.rotation.m11, this.rotation.m21);
            Vector3f z = new Vector3f(this.rotation.m02, this.rotation.m12, this.rotation.m22);
            Vector3f crossY = new Vector3f();
            Vector3f originalY = new Vector3f();

            originalY.normalize(y);
            crossY.cross(z, x);
            crossY.normalize();

            if (crossY.dot(originalY) < 0)
            {
                getInvertAxisMatrix(invAxis).transform(scale);
            }

            return scale;
        }

        public static Matrix3f getRotationMatrix(int axis, double degrees)
        {
            Matrix3f mat = new Matrix3f();

            switch (axis)
            {
                case 0:
                    mat.rotX((float) Math.toRadians(degrees));
                    break;
                case 1:
                    mat.rotY((float) Math.toRadians(degrees));
                    break;
                case 2:
                    mat.rotZ((float) Math.toRadians(degrees));
                    break;
            }

            return mat;
        }

        public static Matrix3f getInvertAxisMatrix(int axis)
        {
            Matrix3f mat = new Matrix3f();

            mat.setIdentity();

            switch (axis)
            {
                case 0:
                    mat.m00 = -1;
                    break;
                case 1:
                    mat.m11 = -1;
                    break;
                case 2:
                    mat.m22 = -1;
                    break;
            }

            return mat;
        }
    }

    public enum MatrixMajor
    {
        ROW,
        COLUMN
    }

    public enum RotationOrder
    {
        XYZ, XZY, YXZ, YZX, ZXY, ZYX;

        public final int firstIndex;
        public final int secondIndex;
        public final int thirdIndex;

        private RotationOrder()
        {
            String order = this.name().toUpperCase();
            firstIndex = order.charAt(0) - 'X';
            secondIndex = order.charAt(1) - 'X';
            thirdIndex = order.charAt(2) - 'X';
        }

        public Float doTest(int index, Matrix3f test)
        {
            float[] buffer = new float[3];

            buffer[index == firstIndex ? secondIndex : firstIndex] = 1;

            Vector3f in = new Vector3f(buffer);
            Vector3f out = new Vector3f();

            test.transform(in, out);
            out.get(buffer);
            buffer[index] = 0;
            out.set(buffer);

            if (out.length() < 1E-07)
            {
                return null;
            }

            out.normalize();

            float cos = in.dot(out);

            out.cross(in, out);
            out.get(buffer);

            float sin = out.length() * Math.signum(buffer[index]);

            return (float) Math.toDegrees(Math.atan2(sin, cos));
        }
    }
}

==================================================

--- Файл №274 ---
Путь: main\java\mchorse\mclib\utils\ModHelper.java
--------------------
package mchorse.mclib.utils;

import java.io.File;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

import net.minecraftforge.fml.common.Loader;
import net.minecraftforge.fml.common.ModContainer;

public class ModHelper
{
    public static ModContainer getCallerMod()
    {
        Class<?> caller = getCallerClass(2);

        if (caller == null) return null;

        String jar = caller.getProtectionDomain().getCodeSource().getLocation().getPath().substring(5);

        //TODO this needs to be rewritten... getting the mod through the stacktrace is very hacky and unstable
        if (jar.lastIndexOf('!') == -1) return null;

        jar = jar.substring(0, jar.lastIndexOf('!'));

        try
        {
            jar = URLDecoder.decode(jar, StandardCharsets.UTF_8.name());
        }
        catch (UnsupportedEncodingException e)
        {}

        File jarFile = new File(jar);

        for (ModContainer mod : Loader.instance().getActiveModList())
        {
            if (jarFile.equals(mod.getSource()))
            {
                return mod;
            }
        }

        return null;
    }

    public static Class<?> getCallerClass(int offset)
    {
        StackTraceElement element = new Exception().getStackTrace()[offset + 1];

        try
        {
            return Class.forName(element.getClassName());
        }
        catch (ClassNotFoundException e)
        {
            return null;
        }
    }
}


==================================================

--- Файл №275 ---
Путь: main\java\mchorse\mclib\utils\NBTUtils.java
--------------------
package mchorse.mclib.utils;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.ByteBufInputStream;
import io.netty.handler.codec.EncoderException;
import net.minecraft.nbt.CompressedStreamTools;
import net.minecraft.nbt.NBTSizeTracker;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagFloat;
import net.minecraft.nbt.NBTTagList;

import javax.vecmath.Vector3f;
import java.io.IOException;

/**
 * NBT utils 
 */
public class NBTUtils
{
    public static void readFloatList(NBTTagList list, float[] array)
    {
        int count = Math.min(array.length, list.tagCount());

        for (int i = 0; i < count; i++)
        {
            array[i] = list.getFloatAt(i);
        }
    }

    public static NBTTagList writeFloatList(NBTTagList list, float[] array)
    {
        for (int i = 0; i < array.length; i++)
        {
            list.appendTag(new NBTTagFloat(array[i]));
        }

        return list;
    }

    public static void readFloatList(NBTTagList list, Vector3f vector)
    {
        if (list.tagCount() != 3)
        {
            return;
        }

        vector.x = list.getFloatAt(0);
        vector.y = list.getFloatAt(1);
        vector.z = list.getFloatAt(2);
    }

    public static NBTTagList writeFloatList(NBTTagList list, Vector3f vector)
    {
        list.appendTag(new NBTTagFloat(vector.x));
        list.appendTag(new NBTTagFloat(vector.y));
        list.appendTag(new NBTTagFloat(vector.z));

        return list;
    }

    public static NBTTagCompound readInfiniteTag(ByteBuf buf)
    {
        int i = buf.readerIndex();
        byte b0 = buf.readByte();

        if (b0 == 0)
        {
            return null;
        }
        else
        {
            buf.readerIndex(i);

            try
            {
                return CompressedStreamTools.read(new ByteBufInputStream(buf), NBTSizeTracker.INFINITE);
            }
            catch (IOException ioexception)
            {
                throw new EncoderException(ioexception);
            }
        }
    }
}

==================================================

--- Файл №276 ---
Путь: main\java\mchorse\mclib\utils\OpHelper.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.Minecraft;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.server.MinecraftServer;
import net.minecraft.server.management.UserListOpsEntry;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class OpHelper
{
    /**
     * Minimum OP level according to vanilla code
     */
    public static final int VANILLA_OP_LEVEL = 2;

    @SideOnly(Side.CLIENT)
    public static int getPlayerOpLevel()
    {
        EntityPlayerSP player = Minecraft.getMinecraft().player;

        return player == null ? 0 : player.getPermissionLevel();
    }

    @SideOnly(Side.CLIENT)
    public static boolean isPlayerOp()
    {
        return isOp(getPlayerOpLevel());
    }

    public static boolean isPlayerOp(EntityPlayerMP player)
    {
        if (player == null)
        {
            return false;
        }

        MinecraftServer server = player.mcServer;

        if (server.getPlayerList().canSendCommands(player.getGameProfile()))
        {
            UserListOpsEntry userEntry = server.getPlayerList().getOppedPlayers().getEntry(player.getGameProfile());

            return isOp(userEntry == null ? server.getOpPermissionLevel() : userEntry.getPermissionLevel());
        }

        return false;
    }

    public static boolean isOp(int opLevel)
    {
        return opLevel >= VANILLA_OP_LEVEL;
    }
}


==================================================

--- Файл №277 ---
Путь: main\java\mchorse\mclib\utils\OptifineHelper.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.entity.Entity;
import net.minecraft.tileentity.TileEntity;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

/**
 * A class that uses reflection to access functionalities of the Optifine mod
 */
public class OptifineHelper
{
    private static ReflectionElement<Field> shadowPass = new ReflectionElement<>();
    private static ReflectionElement<Class> shadersClass = new ReflectionElement<>();
    private static ReflectionElement<Method> nextEntity = new ReflectionElement<>();
    private static ReflectionElement<Method> nextBlockEntity = new ReflectionElement<>();

    /**
     * Checks whether Optifine is currently rendering shadow map. Thanks to
     * MiaoNLI for suggesting how to do it!
     */
    public static boolean isOptifineShadowPass()
    {
        /* only check once for isShadowPass Field to avoid too many reflection calls */
        if (!shadowPass.checked)
        {
            try
            {
                if (findShadersClass())
                {
                    shadowPass.element = shadersClass.element.getDeclaredField("isShadowPass");
                }
            }
            catch (Exception e)
            {}

            shadowPass.checked = true;
        }

        if (shadowPass.element != null)
        {
            try
            {
                return (boolean) shadowPass.element.get(null);
            }
            catch (Exception e)
            {}
        }

        return false;
    }

    /**
     * Invokes net.optifine.shaders.Shaders.nextEntity(Entity) when Optifine is present
     * @param entity
     */
    public static void nextEntity(Entity entity)
    {
        if (!nextEntity.checked)
        {
            try
            {
                if (findShadersClass())
                {
                    nextEntity.element = shadersClass.element.getMethod("nextEntity", Entity.class);
                }
            }
            catch (Exception var1)
            { }

            nextEntity.checked = true;
        }

        if (nextEntity.element != null)
        {
            try
            {
                nextEntity.element.invoke(null, entity);
            }
            catch (Exception e)
            { }
        }
    }

    /**
     * Invokes net.optifine.shaders.Shaders.nextBlockEntity(TileEntity) when Optifine is present
     * @param tileEntity
     */
    public static void nextBlockEntity(TileEntity tileEntity)
    {
        if (!nextBlockEntity.checked)
        {
            try
            {
                if (findShadersClass())
                {
                    nextBlockEntity.element = shadersClass.element.getMethod("nextBlockEntity", TileEntity.class);
                }
            }
            catch (Exception e)
            { }

            nextBlockEntity.checked = true;
        }

        if (nextBlockEntity.element != null)
        {
            try
            {
                nextBlockEntity.element.invoke(null, tileEntity);
            }
            catch (Exception e)
            { }
        }
    }

    /**
     * @return true if the Shaders Class was found i.e. not equal to null
     */
    private static boolean findShadersClass()
    {
        /* only check once if Optifine is there - avoid too many reflection calls*/
        if (!shadersClass.checked)
        {
            try
            {
                shadersClass.element = Class.forName("net.optifine.shaders.Shaders");
            }
            catch (Exception e)
            { }

            shadersClass.checked = true;
        }

        return shadersClass.element != null;
    }

    /* avoid too many reflection calls by saving whether it was checked */
    private static class ReflectionElement<T>
    {
        private T element;
        private boolean checked;
    }
}


==================================================

--- Файл №278 ---
Путь: main\java\mchorse\mclib\utils\Patterns.java
--------------------
package mchorse.mclib.utils;

import java.util.regex.Pattern;

public class Patterns
{
    public static final Pattern FILENAME = Pattern.compile("^[\\w\\d-_.\\[\\]!@#$%^&()]*$");
}

==================================================

--- Файл №279 ---
Путь: main\java\mchorse\mclib\utils\PayloadASM.java
--------------------
package mchorse.mclib.utils;

import mchorse.mclib.McLib;

public class PayloadASM
{
    public static final int MIN_SIZE = 32767;

    /**
     * ASM hook which is used in {@link mchorse.mclib.core.transformers.CPacketCustomPayloadTransformer}
     */
    public static int getPayloadSize()
    {
        if (McLib.maxPacketSize == null)
        {
            return MIN_SIZE;
        }

        return Math.max(MIN_SIZE, McLib.maxPacketSize.get());
    }
}

==================================================

--- Файл №280 ---
Путь: main\java\mchorse\mclib\utils\RayTracing.java
--------------------
package mchorse.mclib.utils;

import com.google.common.base.Predicate;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.RayTraceResult;
import net.minecraft.util.math.Vec3d;

import javax.annotation.Nullable;
import java.util.List;

public class RayTracing
{
    /**
     * Get the entity at which given player is looking at
     */
    public static Entity getTargetEntity(Entity input, double maxReach)
    {
        RayTraceResult result = rayTraceWithEntity(input, maxReach);

        return result.typeOfHit == RayTraceResult.Type.ENTITY ? result.entityHit : null;
    }

    /**
     * Kind of like rayTrace method, but as well it takes into account entity
     * ray tracing
     */
    public static RayTraceResult rayTraceWithEntity(Entity input, double maxReach)
    {
        double blockDistance = maxReach;

        RayTraceResult result = rayTrace(input, maxReach, 1.0F);
        Vec3d eyes = new Vec3d(input.posX, input.posY + input.getEyeHeight(), input.posZ);

        if (result != null)
        {
            blockDistance = result.hitVec.distanceTo(eyes);
        }

        Vec3d look = input.getLook(1.0F);
        Vec3d max = eyes.addVector(look.x * maxReach, look.y * maxReach, look.z * maxReach);
        Vec3d hit = null;
        Entity target = null;

        float area = 1.0F;

        List<Entity> list = input.world.getEntitiesInAABBexcluding(input, input.getEntityBoundingBox().expand(look.x * maxReach, look.y * maxReach, look.z * maxReach).grow(area, area, area), new Predicate<Entity>()
        {
            @Override
            public boolean apply(@Nullable Entity entity)
            {
                return entity != null && entity.canBeCollidedWith();
            }
        });

        double entityDistance = blockDistance;

        for (int i = 0; i < list.size(); ++i)
        {
            Entity entity = list.get(i);

            if (entity == input)
            {
                continue;
            }

            AxisAlignedBB aabb = entity.getEntityBoundingBox().grow(entity.getCollisionBorderSize());
            RayTraceResult intercept = aabb.calculateIntercept(eyes, max);

            if (aabb.contains(eyes))
            {
                if (entityDistance >= 0.0D)
                {
                    hit = intercept == null ? eyes : intercept.hitVec;
                    target = entity;
                    entityDistance = 0.0D;
                }
            }
            else if (intercept != null)
            {
                double eyesDistance = eyes.distanceTo(intercept.hitVec);

                if (eyesDistance < entityDistance || entityDistance == 0.0D)
                {
                    if (entity.getLowestRidingEntity() == input.getLowestRidingEntity() && !input.canRiderInteract())
                    {
                        if (entityDistance == 0.0D)
                        {
                            hit = intercept.hitVec;
                            target = entity;
                        }
                    }
                    else
                    {
                        hit = intercept.hitVec;
                        target = entity;
                        entityDistance = eyesDistance;
                    }
                }
            }
        }

        if (target != null)
        {
            result = new RayTraceResult(target, hit);
        }

        return result;
    }

    /**
     * This method is extracted from {@link Entity} class, because it was marked
     * as client side only code.
     */
    public static RayTraceResult rayTrace(Entity input, double blockReachDistance, float partialTicks)
    {
        Vec3d eyePos = new Vec3d(input.posX, input.posY + input.getEyeHeight(), input.posZ);
        Vec3d eyeDir = input.getLook(partialTicks);
        Vec3d eyeReach = eyePos.addVector(eyeDir.x * blockReachDistance, eyeDir.y * blockReachDistance, eyeDir.z * blockReachDistance);

        return input.world.rayTraceBlocks(eyePos, eyeReach, false, false, true);
    }
}


==================================================

--- Файл №281 ---
Путь: main\java\mchorse\mclib\utils\ReflectionUtils.java
--------------------
package mchorse.mclib.utils;

import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureManager;
import net.minecraft.client.resources.IResourceManager;
import net.minecraft.client.resources.IResourcePack;
import net.minecraft.client.resources.SimpleReloadableResourceManager;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.client.FMLClientHandler;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Map;

public class ReflectionUtils
{
    /**
     * Minecraft texture manager's field to the texture map (a map of 
     * {@link ITextureObject} which is used to cache references to 
     * OpenGL textures). 
     */
    public static Field TEXTURE_MAP;

    /**
     * Whether isShadowPass field was checked
     */
    private static boolean SHADOW_PASS_CHECK;

    /**
     * Optifine's shadow pass field
     */
    private static Field SHADOW_PASS;

    /**
     * Get texture map from texture manager using reflection API
     */
    @SuppressWarnings("unchecked")
    public static Map<ResourceLocation, ITextureObject> getTextures(TextureManager manager)
    {
        if (TEXTURE_MAP == null)
        {
            setupTextureMapField(manager);
        }

        try
        {
            return (Map<ResourceLocation, ITextureObject>) TEXTURE_MAP.get(manager);
        }
        catch (Exception e)
        {
            return null;
        }
    }

    /**
     * Setup texture map field which is looked up using the reflection API
     */
    @SuppressWarnings("rawtypes")
    public static void setupTextureMapField(TextureManager manager)
    {
        /* Finding the field which has holds the texture cache */
        for (Field field : manager.getClass().getDeclaredFields())
        {
            if (Modifier.isStatic(field.getModifiers()))
            {
                continue;
            }

            field.setAccessible(true);

            try
            {
                Object value = field.get(manager);

                if (value instanceof Map && ((Map) value).keySet().iterator().next() instanceof ResourceLocation)
                {
                    TEXTURE_MAP = field;

                    break;
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }
    }

    @SideOnly(Side.CLIENT)
    public static boolean registerResourcePack(IResourcePack pack)
    {
        try
        {
            Field field = FMLClientHandler.class.getDeclaredField("resourcePackList");
            field.setAccessible(true);

            List<IResourcePack> packs = (List<IResourcePack>) field.get(FMLClientHandler.instance());
            packs.add(pack);
            IResourceManager manager = Minecraft.getMinecraft().getResourceManager();

            if (manager instanceof SimpleReloadableResourceManager)
            {
                ((SimpleReloadableResourceManager) manager).reloadResourcePack(pack);
            }

            return false;
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return false;
    }

    /**
     * Use {@link OptifineHelper} class!
     */
    @Deprecated
    public static boolean isOptifineShadowPass()
    {
        if (!SHADOW_PASS_CHECK)
        {
            try
            {
                Class clazz = Class.forName("net.optifine.shaders.Shaders");

                SHADOW_PASS = clazz.getDeclaredField("isShadowPass");
            }
            catch (Exception e)
            {}

            SHADOW_PASS_CHECK = true;
        }

        if (SHADOW_PASS != null)
        {
            try
            {
                return (boolean) SHADOW_PASS.get(null);
            }
            catch (Exception e)
            {}
        }

        return false;
    }
}

==================================================

--- Файл №282 ---
Путь: main\java\mchorse\mclib\utils\RenderingUtils.java
--------------------
package mchorse.mclib.utils;

import mchorse.mclib.client.render.VertexBuilder;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.BufferBuilder;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.Tessellator;
import net.minecraft.entity.Entity;
import net.minecraft.util.ResourceLocation;
import net.minecraft.util.math.MathHelper;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import javax.annotation.Nullable;
import javax.vecmath.*;
import java.nio.FloatBuffer;

public class RenderingUtils
{
    private static final FloatBuffer matrixBuffer = BufferUtils.createFloatBuffer(16);

    /**
     * This method inverts the scale and rotation of the modelview matrix and
     * multiplies it on the OpenGL stack.
     */
    public static void glRevertRotationScale()
    {
        matrixBuffer.clear();

        MatrixUtils.matrixToFloatBuffer(matrixBuffer, getRevertRotationScale());

        GL11.glMultMatrix(matrixBuffer);
    }

    public static Matrix4f getRevertRotationScale()
    {
        Matrix4d[] transformation = MatrixUtils.getTransformation();

        Matrix4d invertRotScale = new Matrix4d();

        invertRotScale.setIdentity();

        invertRotScale.m00 = ((transformation[2].m00 != 0) ? 1 / transformation[2].m00 : 0);
        invertRotScale.m11 = ((transformation[2].m11 != 0) ? 1 / transformation[2].m11 : 0);
        invertRotScale.m22 = ((transformation[2].m22 != 0) ? 1 / transformation[2].m22 : 0);

        try
        {
            transformation[1].invert();
        }
        catch (SingularMatrixException e)
        { }

        invertRotScale.mul(transformation[1], invertRotScale);

        return new Matrix4f(invertRotScale);
    }


    /**
     * This method inverts the scale and rotation using the provided parameters
     * and multiplies the OpenGL matrix stack with it.
     * @param scale
     * @param rotation angles in radians
     * @param rotationOrder the order of the rotation
     */
    public static void glRevertRotationScale(Vector3d rotation, Vector3d scale, MatrixUtils.RotationOrder rotationOrder)
    {
        double invSx = (scale.x != 0) ? 1 / scale.x : 0;
        double invSy = (scale.y != 0) ? 1 / scale.y : 0;
        double invSz = (scale.z != 0) ? 1 / scale.z : 0;

        GlStateManager.scale(invSx, invSy, invSz);

        float rotx = (float) -Math.toDegrees(rotation.x);
        float roty = (float) -Math.toDegrees(rotation.y);
        float rotz = (float) -Math.toDegrees(rotation.z);

        switch (rotationOrder)
        {
            case ZYX:
                GlStateManager.rotate(rotz, 0, 0, 1);
                GlStateManager.rotate(roty, 0, 1, 0);
                GlStateManager.rotate(rotx, 1, 0, 0);

                break;
            case XYZ:
                GlStateManager.rotate(rotx, 1, 0, 0);
                GlStateManager.rotate(roty, 0, 1, 0);
                GlStateManager.rotate(rotz, 0, 0, 1);

                break;
            case XZY:
                GlStateManager.rotate(rotx, 1, 0, 0);
                GlStateManager.rotate(rotz, 0, 0, 1);
                GlStateManager.rotate(roty, 0, 1, 0);

                break;
            case YZX:
                GlStateManager.rotate(roty, 0, 1, 0);
                GlStateManager.rotate(rotz, 0, 0, 1);
                GlStateManager.rotate(rotx, 1, 0, 0);

                break;
            case YXZ:
                GlStateManager.rotate(roty, 0, 1, 0);
                GlStateManager.rotate(rotx, 1, 0, 0);
                GlStateManager.rotate(rotz, 0, 0, 1);

                break;
            case ZXY:
                GlStateManager.rotate(rotz, 0, 0, 1);
                GlStateManager.rotate(rotx, 1, 0, 0);
                GlStateManager.rotate(roty, 0, 1, 0);

                break;
        }

    }

    public static void renderCircle(Vector3d center, Vector3d normal, float radius, int divisions, Color color, float thickness)
    {
        renderCircleDotted(center, normal, radius, divisions, color, thickness, 0);
    }

    public static void renderCircleDotted(Vector3d center, Vector3d normal, float radius, int divisions, Color color, float thickness, int skipDivision)
    {
        Matrix3d rotation = new Matrix3d();
        rotation.setIdentity();
        Matrix3d transform = new Matrix3d();
        transform.rotY(Math.toRadians(getYaw(normal)));
        rotation.mul(transform);
        transform.rotX(Math.toRadians(getPitch(normal)));
        rotation.mul(transform);

        GL11.glColor4f(color.r, color.g, color.b, color.a);
        GL11.glLineWidth(thickness);
        GL11.glBegin(GL11.GL_LINES);

        for (int i = 1; i <= divisions; i += skipDivision + 1)
        {
            double angle0 = 2 * Math.PI / divisions * (i - 1);
            double angle1 = 2 * Math.PI / divisions * i;

            Vector3d a = new Vector3d(radius * Math.cos(angle0), radius * Math.sin(angle0), 0);
            Vector3d b = new Vector3d(radius * Math.cos(angle1), radius * Math.sin(angle1), 0);
            rotation.transform(a);
            rotation.transform(b);
            a.add(center);
            b.add(center);

            GL11.glVertex3d(a.x, a.y, a.z);
            GL11.glVertex3d(b.x, b.y, b.z);
        }

        GL11.glEnd();
    }

    public static float getYaw(Vector3f direction)
    {
        return (float) getYaw(new Vector3d(direction));
    }

    public static float getPitch(Vector3f direction)
    {
        return (float) getPitch(new Vector3d(direction));
    }

    public static double getYaw(Vector3d direction)
    {
        double yaw = Math.atan2(-direction.x, direction.z);
        yaw = Math.toDegrees(yaw);
        if (yaw < -180)
        {
            yaw += 360;
        }
        else if (yaw > 180)
        {
            yaw -= 360;
        }
        return -yaw;
    }

    public static double getPitch(Vector3d direction)
    {
        double pitch = Math.atan2(direction.y, Math.sqrt(direction.x * direction.x + direction.z * direction.z));
        return -Math.toDegrees(pitch);
    }

    public static void renderImage(ResourceLocation image, float scale)
    {
        renderImage(image, scale, new Color(1F, 1F, 1F, 1F));
    }

    public static void renderImage(ResourceLocation image, float scale, Color color)
    {
        Minecraft.getMinecraft().renderEngine.bindTexture(image);

        boolean isCulling = GL11.glIsEnabled(GL11.GL_CULL_FACE);

        GlStateManager.alphaFunc(GL11.GL_GREATER, 0);
        GlStateManager.enableAlpha();
        GlStateManager.enableBlend();

        if (ReflectionUtils.isOptifineShadowPass())
        {
            GlStateManager.disableCull();
        }
        else
        {
            GlStateManager.enableCull();
        }

        GlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);

        Tessellator tessellator = Tessellator.getInstance();
        BufferBuilder buffer = tessellator.getBuffer();

        GlStateManager.color(color.r, color.g, color.b, color.a);

        buffer.begin(GL11.GL_QUADS, VertexBuilder.getFormat(false, true, false, true));

        int perspective = Minecraft.getMinecraft().gameSettings.thirdPersonView;
        float width = scale * (perspective == 2 ? -1 : 1) * 0.5F;
        float height = scale * 0.5F;

        /* Frontface */
        buffer.pos(-width, height, 0.0F).tex(0, 0).normal(0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(-width, -height, 0.0F).tex(0, 1).normal(0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(width, -height, 0.0F).tex(1, 1).normal(0.0F, 0.0F, 1.0F).endVertex();
        buffer.pos(width, height, 0.0F).tex(1, 0).normal(0.0F, 0.0F, 1.0F).endVertex();
        /* backface */
        buffer.pos(width,height, 0.0F).tex(1, 0).normal(0.0F, 0.0F, -1.0F).endVertex();
        buffer.pos(width, -height, 0.0F).tex(1, 1).normal(0.0F, 0.0F, -1.0F).endVertex();
        buffer.pos(-width, -height, 0.0F).tex(0, 1).normal(0.0F, 0.0F, -1.0F).endVertex();
        buffer.pos(-width, height, 0.0F).tex(0, 0).normal(0.0F, 0.0F, -1.0F).endVertex();

        tessellator.draw();

        if (isCulling)
        {
            GlStateManager.enableCull();
        }
        else
        {
            GlStateManager.disableCull();
        }

        GlStateManager.disableBlend();
        GlStateManager.disableAlpha();
        GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);
    }

    public static Matrix4f getFacingRotation(Facing facing, Vector3f position)
    {
        return getFacingRotation(facing, position, null);
    }

    public static Matrix4f getFacingRotation(Facing facing, Vector3f position, Vector3f direction)
    {
        if (facing.isDirection && direction == null)
        {
            throw new IllegalArgumentException("Argument direction cannot be null when the facing mode has isDirection=true");
        }

        Entity camera = Minecraft.getMinecraft().getRenderViewEntity();
        float partialTicks = Minecraft.getMinecraft().getRenderPartialTicks();
        Matrix4f transform = new Matrix4f();
        Matrix4f rotation = new Matrix4f();

        transform.setIdentity();

        float cYaw = - Interpolations.lerp(camera.prevRotationYaw, camera.rotationYaw, partialTicks);
        float cPitch = Interpolations.lerp(camera.prevRotationPitch, camera.rotationPitch, partialTicks);
        double cX = Interpolations.lerp(camera.prevPosX, camera.posX, partialTicks);
        double cY = Interpolations.lerp(camera.prevPosY, camera.posY, partialTicks) + camera.getEyeHeight();
        double cZ = Interpolations.lerp(camera.prevPosZ, camera.posZ, partialTicks);

        if (facing.isLookAt && !facing.isDirection)
        {
            double dX = cX - position.x;
            double dY = cY - position.y;
            double dZ = cZ - position.z;
            double horizontalDistance = MathHelper.sqrt(dX * dX + dZ * dZ);

            cYaw = 180 - (float) (Math.toDegrees(MathHelper.atan2(dZ, dX)) - 90.0F);
            cPitch = (float) (Math.toDegrees(MathHelper.atan2(dY, horizontalDistance)));
        }

        if (facing.isDirection)
        {
            double lengthSq = direction.lengthSquared();
            if (lengthSq < 0.0001)
            {
                direction.set(1, 0, 0);
            }
            else if (Math.abs(lengthSq - 1) > 0.0001)
            {
                direction.normalize();
            }
        }

        switch (facing)
        {
            case LOOKAT_XYZ:
            case ROTATE_XYZ:
                rotation.rotX((float) Math.toRadians(cPitch));
                transform.mul(rotation);
                rotation.rotY((float) Math.toRadians(180 - cYaw));
                transform.mul(rotation);
                break;
            case ROTATE_Y:
            case LOOKAT_Y:
                rotation.rotY((float) Math.toRadians(180 - cYaw));
                transform.mul(rotation);
                break;
            case LOOKAT_DIRECTION:
                rotation.setIdentity();
                rotation.rotY((float) Math.toRadians(getYaw(direction)));
                transform.mul(rotation);
                rotation.rotX((float) Math.toRadians(getPitch(direction) + 90));
                transform.mul(rotation);

                Vector3f cameraDir = new Vector3f(
                        (float) (cX - position.x),
                        (float) (cY - position.y),
                        (float) (cZ - position.z));

                Vector3f rotatedNormal = new Vector3f(0,0,1);

                transform.transform(rotatedNormal);

                /*
                 * The direction vector is the normal of the plane used for calculating the rotation around local y Axis.
                 * Project the cameraDir onto that plane to find out the axis angle (direction vector is the y axis).
                 */
                Vector3f projectDir = new Vector3f(direction);
                projectDir.scale(cameraDir.dot(direction));
                cameraDir.sub(projectDir);

                if (cameraDir.lengthSquared() < 1.0e-30) break;

                cameraDir.normalize();

                /*
                 * The angle between two vectors is only between 0 and 180 degrees.
                 * RotationDirection will be parallel to direction but pointing in different directions depending
                 * on the rotation of cameraDir. Use this to find out the sign of the angle
                 * between cameraDir and the rotatedNormal.
                 */
                Vector3f rotationDirection = new Vector3f();
                rotationDirection.cross(cameraDir, rotatedNormal);

                rotation.rotY(-Math.copySign(cameraDir.angle(rotatedNormal), rotationDirection.dot(direction)));
                transform.mul(rotation);
                break;
        }

        return transform;
    }

    /**
     * This method multiples the openGL matrix stack with a rotation matrix
     * according to the facing parameter
     */
    public static void glFacingRotation(Facing facing, Vector3f position, Vector3f direction)
    {
        matrixBuffer.clear();
        MatrixUtils.matrixToFloatBuffer(matrixBuffer, getFacingRotation(facing, position, direction));

        GL11.glMultMatrix(matrixBuffer);
    }

    public static void glFacingRotation(Facing facing, Vector3f position)
    {
        glFacingRotation(facing, position, null);
    }

    public enum Facing
    {
        ROTATE_XYZ("rotate_xyz"),
        ROTATE_Y("rotate_y"),
        LOOKAT_XYZ("lookat_xyz", true, false),
        LOOKAT_Y("lookat_y", true, false),
        LOOKAT_DIRECTION("lookat_direction", true, true);


        public final String id;
        public final boolean isLookAt;
        public final boolean isDirection;

        public static Facing fromString(String string)
        {
            for (Facing facing : values())
            {
                if (facing.id.equals(string))
                {
                    return facing;
                }
            }

            return null;
        }

        Facing(String id, boolean isLookAt, boolean isDirection)
        {
            this.id = id;
            this.isLookAt = isLookAt;
            this.isDirection = isDirection;
        }

        Facing(String id)
        {
            this(id, false, false);
        }
    }
}


==================================================

--- Файл №283 ---
Путь: main\java\mchorse\mclib\utils\Rewriter.java
--------------------
package mchorse.mclib.utils;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A Rewriter does a global substitution in the strings passed to its
 * 'rewrite' method. It uses the pattern supplied to its constructor, and is
 * like 'String.replaceAll' except for the fact that its replacement strings
 * are generated by invoking a method you write, rather than from another
 * string. This class is supposed to be equivalent to Ruby's 'gsub' when
 * given a block. This is the nicest syntax I've managed to come up with in
 * Java so far. It's not too bad, and might actually be preferable if you
 * want to do the same rewriting to a number of strings in the same method
 * or class. See the example 'main' for a sample of how to use this class.
 *
 * @author Elliott Hughes
 */
public abstract class Rewriter
{
    private Pattern pattern;
    private Matcher matcher;

    /**
     * Constructs a rewriter using the given regular expression; the syntax is
     * the same as for 'Pattern.compile'.
     */
    public Rewriter(String regex)
    {
        this.pattern = Pattern.compile(regex);
    }

    /**
     * Returns the input subsequence captured by the given group during the
     * previous match operation.
     */
    public String group(int i)
    {
        return matcher.group(i);
    }

    /**
     * Overridden to compute a replacement for each match. Use the method
     * 'group' to access the captured groups.
     */
    public abstract String replacement();

    /**
     * Returns the result of rewriting 'original' by invoking the method
     * 'replacement' for each match of the regular expression supplied to the
     * constructor.
     */
    public String rewrite(CharSequence original)
    {
        this.matcher = pattern.matcher(original);
        StringBuffer result = new StringBuffer(original.length());
        while (matcher.find())
        {
            matcher.appendReplacement(result, "");
            result.append(replacement());
        }
        matcher.appendTail(result);
        return result.toString();
    }
}

==================================================

--- Файл №284 ---
Путь: main\java\mchorse\mclib\utils\TextUtils.java
--------------------
package mchorse.mclib.utils;

public class TextUtils
{
    public static String processColoredText(String text)
    {
        if (!text.contains("["))
        {
            return text;
        }

        StringBuilder builder = new StringBuilder();

        for (int i = 0, c = text.length(); i < c; i++)
        {
            char character = text.charAt(i);

            if (character == '\\' && i < c - 1 && text.charAt(i + 1) == '[')
            {
                builder.append('[');
                i += 1;
            }
            else
            {
                builder.append(character == '[' ? '\u00A7' : character);
            }
        }

        return builder.toString();
    }
}


==================================================

--- Файл №285 ---
Путь: main\java\mchorse\mclib\utils\Timer.java
--------------------
package mchorse.mclib.utils;

public class Timer
{
    public boolean enabled;
    public long time;
    public long duration;

    public Timer(long duration)
    {
        this.duration = duration;
    }

    public long getRemaining()
    {
        return this.time - System.currentTimeMillis();
    }

    public void mark()
    {
        this.mark(this.duration);
    }

    public void mark(long duration)
    {
        this.enabled = true;
        this.time = System.currentTimeMillis() + duration;
    }

    public void reset()
    {
        this.enabled = false;
    }

    public boolean checkReset()
    {
        boolean enabled = this.check();

        if (enabled)
        {
            this.reset();
        }

        return enabled;
    }

    public boolean check()
    {
        return this.enabled && this.isTime();
    }

    public boolean isTime()
    {
        return System.currentTimeMillis() >= this.time;
    }

    public boolean checkRepeat()
    {
        if (!this.enabled)
        {
            this.mark();
        }

        return this.checkReset();
    }
}

==================================================

--- Файл №286 ---
Путь: main\java\mchorse\mclib\utils\ValueSerializer.java
--------------------
package mchorse.mclib.utils;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.config.values.GenericBaseValue;
import mchorse.mclib.config.values.GenericValue;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.mclib.network.INBTSerializable;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;

import java.util.*;

/**
 * A Serializer for GenericValue instances.
 * <br><br>
 * <h2>Ideal usage:</h2>
 * All the variables that should be serialized/deserialized need to be GenericValue subclasses.
 * Ideally, the references to these instances will not change throughout their lifetime, so the usage of final is advised.
 * In the constructor of the class with the variables, the references to all the GenericValue variables 
 * can now be registered to a ValueSerializer instance, 
 * using {@link #registerValue(String, String, GenericBaseValue)} or {@link #registerJSONValue(String, GenericBaseValue)} or {@link #registerNBTValue(String, GenericBaseValue)}.
 *
 * @author Christian F. (Chryfi)
 */
public class ValueSerializer implements IByteBufSerializable, INBTSerializable, ICopy<ValueSerializer>
{
    /**
     * A pool of values, so we can easily retrieve a value that has been either registered for json or nbt.
     * The key is the path of the value.
     */
    private final Map<String, Value<?>> pool = new LinkedHashMap<>();

    /**
     * Key is the name that is used for serialization/deserialization
     * Value is the value's path -> Key in {@link #pool}.
     */
    private final Map<String, String> nbtMap = new HashMap<>();
    /**
     * Key is the name that is used for serialization/deserialization
     * Value is the value's path -> Key in {@link #pool}.
     */
    private final Map<String, String> jsonMap = new HashMap<>();

    /**
     * Register a value.
     * @param value
     * @returns a helper object where you can configure serialization.
     * @throws IllegalArgumentException when the path of the value is already registered with a different value.
     */
    public <T> Value<T> registerValue(GenericBaseValue<T> value)
    {
        return this.poolValue(value);
    }

    public Optional<GenericBaseValue<?>> getValue(String path)
    {
        return this.pool.containsKey(path) ? Optional.of(this.pool.get(path).value) : Optional.empty();
    }

    /**
     * @return a list of all the registered values.
     */
    public List<GenericBaseValue<?>> getValues()
    {
        List<GenericBaseValue<?>> values = new ArrayList<>();
        for (Value<?> value : this.pool.values())
        {
            values.add(value.value);
        }

        return values;
    }

    /**
     * Register the provided GenericValue object reference
     * with the provided key name for NBT serialization/deserialization.
     * If the provided value is null or if the key already exists, it will not be registered.
     *
     * @param nbt name that should be used for serialization/deserialization.
     *            If it is empty, the value will not be registered for NBT serialization/deserialization
     * @param value the reference to the value that should be serialization/deserialization
     * @throws IllegalArgumentException when the path of the value is already registered.
     * @deprecated use {@link #registerValue(GenericBaseValue)} and the methods of {@link Value}
     */
    @Deprecated
    public void registerNBTValue(String nbt, GenericBaseValue<?> value)
    {
        this.registerValue(nbt, "", value, false, false);
    }

    /**
     * Register the provided GenericValue object reference
     * with the provided key name for NBT serialization/deserialization.
     * If the provided value is null or if the key already exists, it will not be registered.
     *
     * @param nbt name that should be used for serialization/deserialization.
     *            If it is empty, the value will not be registered for NBT serialization/deserialization
     * @param value the reference to the value that should be serialization/deserialization
     * @param alwaysWrite when true, the value will always be serialized to NBT, no matter if it changed or not.
     * @throws IllegalArgumentException when the path of the value is already registered.
     * @deprecated use {@link #registerValue(GenericBaseValue)} and the methods of {@link Value}
     */
    @Deprecated
    public void registerNBTValue(String nbt, GenericBaseValue<?> value, boolean alwaysWrite)
    {
        this.registerValue(nbt, "", value, alwaysWrite, false);
    }

    /**
     * Register the provided GenericValue object reference
     * with the provided key name for JSON serialization/deserialization.
     * If the provided value is null or if the key already exists, it will not be registered.
     *
     * @param json name that should be used for serialization/deserialization.
     *                If it is empty, the value will not be registered for JSON serialization/deserialization
     * @param value the reference to the value that should be serialization/deserialization
     * @throws IllegalArgumentException when the path of the value is already registered.
     * @deprecated use {@link #registerValue(GenericBaseValue)} and the methods of {@link Value}
     */
    @Deprecated
    public void registerJSONValue(String json, GenericBaseValue<?> value)
    {
        this.registerValue("", json, value, false, false);
    }

    /**
     * Register the provided GenericValue object reference
     * with the provided key name for JSON serialization/deserialization.
     * If the provided value is null or if the key already exists, it will not be registered.
     *
     * @param json name that should be used for serialization/deserialization.
     *                If it is empty, the value will not be registered for JSON serialization/deserialization
     * @param value the reference to the value that should be serialization/deserialization
     * @param alwaysWrite when true, the value will always be serialized to JSON, no matter if it changed or not.
     * @throws IllegalArgumentException when the path of the value is already registered.
     * @deprecated use {@link #registerValue(GenericBaseValue)} and the methods of {@link Value}
     */
    @Deprecated
    public void registerJSONValue(String json, GenericBaseValue<?> value, boolean alwaysWrite)
    {
        this.registerValue("", json, value, false, alwaysWrite);
    }

    /**
     * Register the provided GenericValue object reference
     * with the provided key names for NBT and JSON serialization/deserialization.
     * If the provided value is null or if the key already exists, it will not be registered.
     *
     * @param nbt name that should be used for serialization and deserialization.
     *            If it is empty, the value will not be registered for NBT serialization/deserialization
     * @param json name that should be used for serialization/deserialization
     *                If it is empty, the value will not be registered for JSON serialization/deserialization
     * @param value the reference to the value that should be serialization/deserialization
     * @throws IllegalArgumentException when the path of the value is already registered.
     * @deprecated use {@link #registerValue(GenericBaseValue)} and the methods of {@link Value}
     */
    @Deprecated
    public void registerValue(String nbt, String json, GenericBaseValue<?> value)
    {
        this.registerValue(nbt, json, value, false, false);
    }

    /**
     * Register the provided GenericValue object reference
     * with the provided key names for NBT and JSON serialization/deserialization.
     * If the provided value is null or if the key already exists, it will not be registered.
     *
     * @param nbt name that should be used for serialization and deserialization.
     *            If it is empty, the value will not be registered for NBT serialization/deserialization
     * @param json name that should be used for serialization/deserialization
     *                If it is empty, the value will not be registered for JSON serialization/deserialization
     * @param value the reference to the value that should be serialization/deserialization
     * @param alwaysWriteJSON when true, the value will always be serialized to JSON, no matter if it changed or not.
     * @param alwaysWriteNBT when true, the value will always be serialized to NBT, no matter if it changed or not.
     * @throws IllegalArgumentException when the path of the value is already registered.
     * @deprecated use {@link #registerValue(GenericBaseValue)} and the methods of {@link Value}
     */
    @Deprecated
    public void registerValue(String nbt, String json, GenericBaseValue<?> value, boolean alwaysWriteNBT, boolean alwaysWriteJSON)
    {
        if (!nbt.isEmpty() && !this.nbtMap.containsKey(nbt))
        {
            Value<?> packet = this.poolValue(value);
            packet.serializeNBT(nbt, alwaysWriteNBT);
        }

        if (!json.isEmpty() && !this.jsonMap.containsKey(json))
        {
            Value<?> packet = this.poolValue(value);
            packet.serializeJSON(json, alwaysWriteJSON);
        }
    }

    /**
     * @throws IllegalArgumentException when the path of the value is already registered.
     */
    protected <T> Value<T> poolValue(GenericBaseValue<T> value)
    {
        String key = value.getPath();
        if (this.pool.containsKey(key) && this.pool.get(key).value != value)
        {
            throw new IllegalArgumentException("The provided value's path is already registered with a different value reference.");
        }

        Value<T> packet;
        if (this.pool.containsKey(key))
        {
            packet = (Value<T>) this.pool.get(key);
        }
        else
        {
            packet = new Value<>(value, this);
            this.pool.put(key, packet);
        }

        return packet;
    }

    /**
     * Registers the NBT value for serialization for quick access.
     * Has some safety checks to ensure that pooled values and serialization maps are consistent.
     * @throws IllegalArgumentException when the name is already registered with a different value reference.
     */
    protected void putNBTValue(String name, Value<?> value)
    {
        String key = value.value.getPath();
        if (this.nbtMap.containsKey(name) && !this.nbtMap.get(name).equals(key))
        {
            throw new IllegalArgumentException("The provided nbt name is already registered with a different value reference.");
        }

        if (this.pool.containsKey(key) && this.pool.get(key).value != value.value)
        {
            throw new IllegalArgumentException("The provided value's path is already registered with a different value reference.");
        }

        this.pool.put(key, value);
        this.nbtMap.put(name, key);
    }

    /**
     * @throws IllegalArgumentException when the name is already registered with a different value reference.
     */
    protected void putJSONValue(String name, Value<?> value)
    {
        String key = value.value.getPath();
        if (this.jsonMap.containsKey(name) && !this.jsonMap.get(name).equals(key))
        {
            throw new IllegalArgumentException("The provided json name is already registered with a different value reference.");
        }

        if (this.pool.containsKey(key) && this.pool.get(key).value != value.value)
        {
            throw new IllegalArgumentException("The provided value's path is already registered with a different value reference.");
        }

        this.pool.put(key, value);
        this.jsonMap.put(name, key);
    }

    /**
     * Calls {@link GenericBaseValue#valueFromBytes(ByteBuf)}
     */
    @Override
    public void fromBytes(ByteBuf buffer)
    {
        for (Value<?> value : this.pool.values())
        {
            value.value.valueFromBytes(buffer);
        }
    }

    /**
     * Calls {@link GenericBaseValue#valueToBytes(ByteBuf)}
     */
    @Override
    public void toBytes(ByteBuf buffer)
    {
        for (Value<?> value : this.pool.values())
        {
            value.value.valueToBytes(buffer);
        }
    }

    /**
     * Calls {@link GenericBaseValue#valueFromNBT(NBTBase)}
     */
    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        for (Map.Entry<String, String> entry : this.nbtMap.entrySet())
        {
            Value<?> packet = this.pool.get(entry.getValue());
            GenericBaseValue<?> value = packet.value;
            String key = entry.getKey();

            if (tag.hasKey(key))
            {
                value.valueFromNBT(tag.getTag(key));
            }
        }
    }

    /**
     * Calls {@link GenericBaseValue#valueToNBT()}. Only serializes the value if it has changed.
     * Serializes always, if the value has been registered with alwaysWrite flag true.
     */
    @Override
    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        for (Map.Entry<String, String> entry : this.nbtMap.entrySet())
        {
            Value<?> packet = this.pool.get(entry.getValue());
            GenericBaseValue<?> value = packet.value;

            if (!packet.nbtAlwaysWrite && value instanceof GenericValue && !((GenericValue) value).hasChanged())
            {
                continue;
            }

            tag.setTag(entry.getKey(), value.valueToNBT());
        }

        return tag;
    }

    /**
     * Calls {@link GenericBaseValue#valueToJSON()}. Only serialize the value if it has changed.
     * Serializes always, if the value has been registered with alwaysWrite flag true.
     */
    public JsonElement toJSON()
    {
        JsonObject jsonRoot = new JsonObject();

        for (Map.Entry<String, String> entry : this.jsonMap.entrySet())
        {
            Value<?> packet = this.pool.get(entry.getValue());
            GenericBaseValue<?> value = packet.value;
            if (!packet.jsonAlwaysWrite && value instanceof GenericValue && !((GenericValue) value).hasChanged())
            {
                continue;
            }

            jsonRoot.add(entry.getKey(), value.valueToJSON());
        }

        return jsonRoot;
    }

    /**
     * Calls {@link GenericBaseValue#valueFromJSON(JsonElement)}
     * @param element
     */
    public void fromJSON(JsonElement element)
    {
        if (!element.isJsonObject())
        {
            return;
        }

        JsonObject jsonObject = element.getAsJsonObject();

        for (Map.Entry<String, String> entry : this.jsonMap.entrySet())
        {
            Value<?> packet = this.pool.get(entry.getValue());
            GenericBaseValue<?> value = packet.value;
            String key = entry.getKey();

            if (jsonObject.has(key))
            {
                value.valueFromJSON(jsonObject.get(key));
            }
        }
    }

    /**
     * Copies the values of the origin with matching paths to the values in this.
     * Only copies if copyable is true for the respective value.
     * @param origin
     */
    public void copyValues(ValueSerializer origin)
    {
        for (Map.Entry<String, Value<?>> originEntry : origin.pool.entrySet())
        {
            if (!originEntry.getValue().copyable) continue;

            this.pool.get(originEntry.getKey()).value.copy(originEntry.getValue().value);
        }
    }

    /**
     * Compare the values with matching paths using the {@link GenericBaseValue#equals(Object)} method.
     * @param serializer
     * @return true if all values with matching paths are equal.
     */
    public boolean equalsValues(ValueSerializer serializer)
    {
        for (Map.Entry<String, Value<?>> entryOrigin : serializer.pool.entrySet())
        {
            String path = entryOrigin.getKey();
            GenericBaseValue<?> originValue = entryOrigin.getValue().value;

            if (this.pool.containsKey(path) && !this.pool.get(path).value.equals(originValue)) return false;
        }

        return true;
    }

    /**
     * Interpolates values with matching paths from the provided serializer to this and then sets the values to this.
     * @param from
     */
    public void interpolateFrom(Interpolation interpolation, ValueSerializer from, float factor)
    {
        for (Map.Entry<String, Value<?>> entryOrigin : from.pool.entrySet())
        {
            String path = entryOrigin.getKey();
            GenericBaseValue<?> originValue = entryOrigin.getValue().value;

            if (this.pool.containsKey(path))
            {
                this.pool.get(path).value.setValue(originValue.interpolate(interpolation, this.pool.get(path).value, factor));
            }
        }
    }

    /**
     * @return deep copy of this valueSerializer
     */
    @Override
    public ValueSerializer copy()
    {
        ValueSerializer copy = new ValueSerializer();
        copy.copy(this);
        return copy;
    }

    /**
     * Copies the values (deep copy), json and nbt mappings from the specified origin and put them into this.
     * @param origin
     */
    @Override
    public void copy(ValueSerializer origin)
    {
        this.jsonMap.clear();
        this.jsonMap.putAll(origin.jsonMap);

        this.nbtMap.clear();
        this.nbtMap.putAll(origin.nbtMap);

        for (Map.Entry<String, Value<?>> entryOrigin : origin.pool.entrySet())
        {
            this.pool.put(entryOrigin.getKey(), entryOrigin.getValue().copy(this));
        }
    }

    public static class Value<T>
    {
        private String nbt;
        private boolean nbtAlwaysWrite;
        private String json;
        private boolean jsonAlwaysWrite;
        private boolean copyable = true;
        private GenericBaseValue<T> value;
        private ValueSerializer serializer;

        public Value(GenericBaseValue<T> value, ValueSerializer serializer)
        {
            this.value = value;
            this.serializer = serializer;
        }

        /**
         * @throws IllegalArgumentException when the name is already registered with a different value reference.
         */
        public Value<T> serializeNBT(String nbt)
        {
            return this.serializeNBT(nbt, false);
        }

        /**
         * @throws IllegalArgumentException when the name is already registered with a different value reference.
         */
        public Value<T> serializeNBT(String nbt, boolean alwaysWrite)
        {
            this.nbt = nbt;
            this.nbtAlwaysWrite = alwaysWrite;
            this.serializer.putNBTValue(nbt, this);
            return this;
        }

        /**
         * @throws IllegalArgumentException when the name is already registered with a different value reference.
         */
        public Value<T> serializeJSON(String json)
        {
            return this.serializeJSON(json, false);
        }

        /**
         * @throws IllegalArgumentException when the name is already registered with a different value reference.
         */
        public Value<T> serializeJSON(String json, boolean alwaysWrite)
        {
            this.json = json;
            this.jsonAlwaysWrite = alwaysWrite;
            this.serializer.putJSONValue(json, this);
            return this;
        }

        public Value<T> copyable()
        {
            this.copyable = true;
            return this;
        }

        public Value<T> nonCopyable()
        {
            this.copyable = false;
            return this;
        }

        public Value<T> copy(ValueSerializer destinationSerializer) {
            Value<T> copy = new Value<>(this.value.copy(), destinationSerializer);
            copy.json = this.json;
            copy.jsonAlwaysWrite = this.jsonAlwaysWrite;
            copy.nbt = this.nbt;
            copy.nbtAlwaysWrite = this.nbtAlwaysWrite;
            copy.copyable = this.copyable;
            return copy;
        }
    }
}


==================================================

--- Файл №287 ---
Путь: main\java\mchorse\mclib\utils\binary\BinaryChunk.java
--------------------
package mchorse.mclib.utils.binary;

public class BinaryChunk
{
    public String id;
    public int size;

    public BinaryChunk(String id, int size)
    {
        this.id = id;
        this.size = size;
    }
}

==================================================

--- Файл №288 ---
Путь: main\java\mchorse\mclib\utils\binary\BinaryReader.java
--------------------
package mchorse.mclib.utils.binary;

import java.io.IOException;
import java.io.InputStream;

public abstract class BinaryReader
{
    public byte[] buf = new byte[4];

    public static int b2i(byte b0, byte b1, byte b2, byte b3)
    {
        return (b0 & 0xff) | ((b1 & 0xff) << 8) | ((b2 & 0xff) << 16) | ((b3 & 0xff) << 24);
    }

    public int fourChars(char c0, char c1, char c2, char c3)
    {
        return ((c3 << 24) & 0xff000000) | ((c2 << 16) & 0x00ff0000) | ((c1 << 8) & 0x0000ff00) | (c0 & 0x000000ff);
    }

    public int fourChars(String string) throws Exception
    {
        char[] chars = string.toCharArray();

        if (chars.length != 4)
        {
            throw new Exception("Given string '" + string + "'");
        }

        return this.fourChars(chars[0], chars[1], chars[2], chars[3]);
    }

    public String readFourString(InputStream stream) throws Exception
    {
        stream.read(this.buf);

        return new String(this.buf);
    }

    public int readInt(InputStream stream) throws Exception
    {
        if (stream.read(this.buf) < 4)
        {
            throw new IOException();
        }

        return b2i(this.buf[0], this.buf[1], this.buf[2], this.buf[3]);
    }

    public int readShort(InputStream stream) throws Exception
    {
        if (stream.read(this.buf, 0, 2) < 2)
        {
            throw new IOException();
        }

        return b2i(this.buf[0], this.buf[1], (byte) 0, (byte) 0);
    }

    public void skip(InputStream stream, long bytes) throws Exception
    {
        while (bytes > 0)
        {
            bytes -= stream.skip(bytes);
        }
    }
}

==================================================

--- Файл №289 ---
Путь: main\java\mchorse\mclib\utils\coremod\ClassMethodTransformer.java
--------------------
package mchorse.mclib.utils.coremod;

import java.util.Iterator;

import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

public abstract class ClassMethodTransformer extends ClassTransformer
{
    public String mcp = "";
    public String mcpSign = "";
    public String notch = "";
    public String notchSign = "";

    public ClassMethodTransformer setMcp(String name, String signature)
    {
        this.mcp = name;
        this.mcpSign = signature;

        return this;
    }

    public ClassMethodTransformer setNotch(String name, String signature)
    {
        this.notch = name;
        this.notchSign = signature;

        return this;
    }

    @Override
    public void process(String name, ClassNode node)
    {
        Iterator<MethodNode> methods = node.methods.iterator();

        while (methods.hasNext())
        {
            MethodNode method = methods.next();
            String methodName = this.checkName(method);

            if (methodName != null)
            {
                this.processMethod(methodName, method);
            }
        }
    }

    protected String checkName(MethodNode method)
    {
        return this.checkName(method, this.notch, this.notchSign, this.mcp, this.mcpSign);
    }

    public abstract void processMethod(String name, MethodNode method);
}

==================================================

--- Файл №290 ---
Путь: main\java\mchorse\mclib\utils\coremod\ClassTransformer.java
--------------------
package mchorse.mclib.utils.coremod;

import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LabelNode;
import org.objectweb.asm.tree.MethodNode;

public abstract class ClassTransformer
{
    public byte[] transform(String name, byte[] bytes)
    {
        ClassNode classNode = new ClassNode();
        ClassReader classReader = new ClassReader(bytes);

        classReader.accept(classNode, 0);

        this.process(name, classNode);

        ClassWriter writer = new ClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES);

        classNode.accept(writer);

        return writer.toByteArray();
    }

    protected String checkName(MethodNode method, String notch, String notchSign, String mcp, String mcpSign)
    {
        if (CoreClassTransformer.obfuscated)
        {
            return method.name.equals(notch) && method.desc.equals(notchSign) ? notch : null;
        }

        return method.name.equals(mcp) && method.desc.equals(mcpSign) ? mcp : null;
    }

    protected LabelNode getFirstLabel(MethodNode method)
    {
        AbstractInsnNode node = method.instructions.getFirst();

        while (node != null)
        {
            if (node instanceof LabelNode)
            {
                return (LabelNode) node;
            }

            node = node.getNext();
        }

        return null;
    }

    public abstract void process(String name, ClassNode node);
}

==================================================

--- Файл №291 ---
Путь: main\java\mchorse\mclib\utils\coremod\CoreClassTransformer.java
--------------------
package mchorse.mclib.utils.coremod;

import net.minecraft.launchwrapper.IClassTransformer;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.VarInsnNode;

public abstract class CoreClassTransformer implements IClassTransformer
{
    public static boolean obfuscated = false;

    public static boolean checkName(String name, String notch, String mcp)
    {
        if (name.equals(mcp) || name.equals(notch))
        {
            obfuscated = name.equals(notch);

            return true;
        }

        return false;
    }

    public static String get(String notch, String mcp)
    {
        return obfuscated ? notch : mcp;
    }

    public static String stringify(AbstractInsnNode node)
    {
        String output = node.toString();

        if (node instanceof LdcInsnNode)
        {
            output = "LDC " + ((LdcInsnNode) node).cst.toString();
        }
        else if (node instanceof MethodInsnNode)
        {
            MethodInsnNode method = (MethodInsnNode) node;

            output = "Method " + method.owner + "." + method.name + method.desc;
        }
        else if (node instanceof FieldInsnNode)
        {
            FieldInsnNode field = (FieldInsnNode) node;

            output = "Field " + field.owner + "." + field.name + field.desc;
        }
        else if (node instanceof VarInsnNode)
        {
            VarInsnNode var = (VarInsnNode) node;

            output = "Field " + var.getOpcode() + " " + var.var;
        }

        return output;
    }
}

==================================================

--- Файл №292 ---
Путь: main\java\mchorse\mclib\utils\files\EntrySorter.java
--------------------
package mchorse.mclib.utils.files;

import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FileEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;

import java.util.Comparator;

/**
 * Abstract entry sorter
 * 
 * Sorts by folder first, and then by display name (title)
 */
public class EntrySorter implements Comparator<AbstractEntry>
{
    @Override
    public int compare(AbstractEntry o1, AbstractEntry o2)
    {
        if (o1 instanceof FolderEntry && o2 instanceof FileEntry)
        {
            return -1;
        }
        else if (o1 instanceof FileEntry && o2 instanceof FolderEntry)
        {
            return 1;
        }

        return o1.title.compareToIgnoreCase(o2.title);
    }
}

==================================================

--- Файл №293 ---
Путь: main\java\mchorse\mclib\utils\files\FileTree.java
--------------------
package mchorse.mclib.utils.files;

import java.util.Comparator;

import mchorse.mclib.client.gui.framework.elements.input.GuiTexturePicker;
import mchorse.mclib.utils.files.entries.AbstractEntry;
import mchorse.mclib.utils.files.entries.FolderEntry;

/**
 * File tree
 * 
 * The implementations of file tree are responsible for creating full 
 * tree of files, so that {@link GuiTexturePicker} could navigate it.
 */
public abstract class FileTree
{
    /**
     * Abstract entry sorter. Sorts folders on top first, and then by
     * the display title name   
     */
    public static Comparator<AbstractEntry> SORTER = new EntrySorter();

    /**
     * Root entry, this top folder should be populated in
     */
    public FolderEntry root = new FolderEntry("root", null, null);

    /**
     * Adds a "back to parent directory" entry 
     */
    public static void addBackEntry(FolderEntry entry)
    {
        if (entry.parent == null)
        {
            return;
        }

        FolderEntry top = new FolderEntry("../", entry.parent != null ? entry.parent.file : null, entry);

        top.setTop(entry.parent);
        entry.getRawEntries().add(0, top);
    }

    /**
     * Get a top level folder for given name    
     */
    public FolderEntry getEntryForName(String name)
    {
        for (AbstractEntry entry : this.root.getEntries())
        {
            if (entry instanceof FolderEntry && entry.title.equalsIgnoreCase(name))
            {
                return (FolderEntry) entry;
            }
        }

        return this.root;
    }

    /**
     * Get a folder entry by path 
     */
    public FolderEntry getByPath(String path)
    {
        return this.getByPath(path, this.root);
    }

    /**
     * Get a folder entry by path with a default value, if given path 
     * wasn't found 
     */
    public FolderEntry getByPath(String path, FolderEntry orDefault)
    {
        FolderEntry entry = this.root;
        String[] segments = path.trim().split("/");

        for (String segment : segments)
        {
            for (AbstractEntry folder : entry.getEntries())
            {
                if (folder.isFolder() && folder.title.equalsIgnoreCase(segment))
                {
                    entry = (FolderEntry) folder;
                }
            }

        }

        return this.root == entry ? orDefault : entry;
    }
}

==================================================

--- Файл №294 ---
Путь: main\java\mchorse\mclib\utils\files\GlobalTree.java
--------------------
package mchorse.mclib.utils.files;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Global file tree 
 */
public class GlobalTree extends FileTree
{
    /**
     * You can register your own file trees
     */
    public final static GlobalTree TREE = new GlobalTree();

    /**
     * Registered trees
     */
    protected List<FileTree> trees = new ArrayList<FileTree>();

    public void register(FileTree tree)
    {
        this.trees.add(tree);
        this.root.getEntries().add(tree.root);

        tree.root.parent = this.root;
    }

    public List<FileTree> getTrees()
    {
        return Collections.unmodifiableList(this.trees);
    }
}

==================================================

--- Файл №295 ---
Путь: main\java\mchorse\mclib\utils\files\entries\AbstractEntry.java
--------------------
package mchorse.mclib.utils.files.entries;

import java.io.File;
import java.util.Objects;

/**
 * Abstract file tree entry class
 * 
 * This basic type is basically contained within file tree
 */
public abstract class AbstractEntry
{
    /**
     * Displayable title 
     */
    public String title;

    /**
     * Associated file
     */
    public File file;

    public AbstractEntry(String title, File file)
    {
        this.title = title;
        this.file = file;
    }

    public boolean isFolder()
    {
        return this instanceof FolderEntry;
    }

    public boolean exists()
    {
        return this.file == null ? true : this.file.exists();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof AbstractEntry)
        {
            AbstractEntry entry = (AbstractEntry) obj;

            return Objects.equals(this.title, entry.title) && Objects.equals(this.file, entry.file);
        }

        return super.equals(obj);
    }
}

==================================================

--- Файл №296 ---
Путь: main\java\mchorse\mclib\utils\files\entries\FileEntry.java
--------------------
package mchorse.mclib.utils.files.entries;

import net.minecraft.util.ResourceLocation;

import java.io.File;
import java.util.Objects;

public class FileEntry extends AbstractEntry
{
    public ResourceLocation resource;

    public FileEntry(String title, File file, ResourceLocation resource)
    {
        super(title, file);

        this.resource = resource;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof FileEntry)
        {
            result = result && Objects.equals(this.resource, ((FileEntry) obj).resource);
        }

        return result;
    }
}


==================================================

--- Файл №297 ---
Путь: main\java\mchorse\mclib\utils\files\entries\FolderEntry.java
--------------------
package mchorse.mclib.utils.files.entries;

import mchorse.mclib.utils.files.FileTree;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;

public class FolderEntry extends AbstractEntry
{
    public FolderEntry parent;
    public FolderEntry top;
    protected List<AbstractEntry> entries = new ArrayList<AbstractEntry>();
    private long lastModified;

    public FolderEntry(String title, File file, FolderEntry parent)
    {
        super(title, file);

        this.parent = parent;
    }

    protected String getPrefix()
    {
        List<String> joiner = new ArrayList<String>();
        FolderEntry parent = this;

        while (parent != null && parent.parent != null)
        {
            joiner.add(parent.title);
            parent = parent.parent;
        }

        Collections.reverse(joiner);

        return String.join("/", joiner).replaceFirst("/", ":");
    }

    public List<AbstractEntry> getEntries()
    {
        if (this.top != null)
        {
            return this.top.getEntries();
        }
        else if (this.file != null)
        {
            if (this.hasChanged())
            {
                this.populateEntries();
            }

            this.lastModified = System.currentTimeMillis();
        }

        return this.entries;
    }

    public List<AbstractEntry> getRawEntries()
    {
        return this.entries;
    }

    protected void populateEntries()
    {
        Collections.sort(this.entries, FileTree.SORTER);

        if (this.getEntry("../") == null)
        {
            FileTree.addBackEntry(this);
        }
    }

    protected AbstractEntry getEntry(String title)
    {
        for (AbstractEntry entry : this.entries)
        {
            if (entry.title.equals(title)) return entry;
        }

        return null;
    }

    public void setTop(FolderEntry top)
    {
        this.top = top;
    }

    public boolean hasChanged()
    {
        if (this.top != null)
        {
            return false;
        }

        if (this.file != null && this.file.lastModified() > this.lastModified)
        {
            return true;
        }

        for (AbstractEntry entry : this.entries)
        {
            if (entry.isFolder())
            {
                FolderEntry folder = (FolderEntry) entry;

                if (folder.hasChanged())
                {
                    return true;
                }
            }
        }

        return false;
    }

    public boolean isEmpty()
    {
        if (this.entries.size() == 1)
        {
            AbstractEntry entry = this.entries.get(0);

            if (entry.isFolder() && ((FolderEntry) entry).isTop())
            {
                return true;
            }
        }

        return this.entries.isEmpty();
    }

    public boolean isTop()
    {
        return this.top != null;
    }

    @Override
    public boolean equals(Object obj)
    {
        boolean result = super.equals(obj);

        if (obj instanceof FolderEntry)
        {
            result = result && Objects.equals(this.parent, ((FolderEntry) obj).parent);
        }

        return result;
    }
}


==================================================

--- Файл №298 ---
Путь: main\java\mchorse\mclib\utils\files\entries\FolderImageEntry.java
--------------------
package mchorse.mclib.utils.files.entries;

import mchorse.mclib.utils.resources.RLUtils;

import java.io.File;
import java.util.Iterator;
import java.util.Objects;

public class FolderImageEntry extends FolderEntry
{
    public FolderImageEntry(String title, File file, FolderEntry parent)
    {
        super(title, file, parent);
    }

    @Override
    protected void populateEntries()
    {
        String prefix = this.getPrefix();

        for (File file : this.file.listFiles())
        {
            AbstractEntry entry = null;
            String name = file.getName();
            String lowercase = name.toLowerCase();

            if (file.isDirectory())
            {
                entry = new FolderImageEntry(name, file, this);
            }
            else if (file.isFile())
            {
                /* Only textures files should be shown */
                if (lowercase.endsWith(".png") || lowercase.endsWith(".jpg") || lowercase.endsWith(".jpeg") || lowercase.endsWith(".gif"))
                {
                    String path = prefix + (prefix.contains(":") ? "/" : ":") + name;

                    entry = new FileEntry(name, file, RLUtils.create(path));
                }
            }

            if (Objects.equals(this.getEntry(name), entry))
            {
                continue;
            }

            if (entry != null)
            {
                this.entries.add(entry);
            }
        }

        /* Remove removed folders and files */
        Iterator<AbstractEntry> it = this.entries.iterator();

        while (it.hasNext())
        {
            AbstractEntry entry = it.next();

            if (!entry.exists())
            {
                it.remove();
            }
        }

        super.populateEntries();
    }
}

==================================================

--- Файл №299 ---
Путь: main\java\mchorse\mclib\utils\keyframes\Keyframe.java
--------------------
package mchorse.mclib.utils.keyframes;

import com.google.gson.JsonObject;
import com.google.gson.annotations.Expose;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.network.IByteBufSerializable;
import mchorse.mclib.network.INBTSerializable;
import mchorse.mclib.utils.ICopy;
import net.minecraft.nbt.NBTTagCompound;

/**
 * Keyframe class
 *
 * This class is responsible for storing individual keyframe properties such
 * as tick at which its located, value, interpolation, easing type, etc.
 */
public class Keyframe implements IByteBufSerializable, INBTSerializable, ICopy<Keyframe>
{
    public Keyframe prev;
    public Keyframe next;

    @Expose
    public long tick;

    @Expose
    public double value;

    @Expose
    public KeyframeInterpolation interp = KeyframeInterpolation.LINEAR;

    @Expose
    public KeyframeEasing easing = KeyframeEasing.IN;

    @Expose
    public float rx = 5;

    @Expose
    public float ry;

    @Expose
    public float lx = 5;

    @Expose
    public float ly;

    public Keyframe(long tick, double value)
    {
        this();

        this.tick = tick;
        this.value = value;
    }

    public Keyframe()
    {
        this.prev = this;
        this.next = this;
    }

    public void setTick(long tick)
    {
        this.tick = tick;
    }

    public void setValue(double value)
    {
        this.value = value;
    }

    public void setInterpolation(KeyframeInterpolation interp)
    {
        this.interp = interp;
    }

    public void setInterpolation(KeyframeInterpolation interp, KeyframeEasing easing)
    {
        this.interp = interp;
        this.setEasing(easing);
    }

    public void setEasing(KeyframeEasing easing)
    {
        this.easing = easing;
    }

    public double interpolate(Keyframe frame, float x)
    {
        return this.interp.interpolate(this, frame, x);
    }

    @Override
    public Keyframe copy()
    {
        Keyframe frame = new Keyframe(this.tick, this.value);

        frame.copy(this);

        return frame;
    }

    @Override
    public void copy(Keyframe keyframe)
    {
        this.tick = keyframe.tick;
        this.value = keyframe.value;
        this.interp = keyframe.interp;
        this.easing = keyframe.easing;
        this.lx = keyframe.lx;
        this.ly = keyframe.ly;
        this.rx = keyframe.rx;
        this.ry = keyframe.ry;
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        this.tick = buffer.readLong();
        this.value = buffer.readDouble();
        this.interp = KeyframeInterpolation.values()[buffer.readInt()];
        this.easing = KeyframeEasing.values()[buffer.readInt()];
        this.rx = buffer.readFloat();
        this.ry = buffer.readFloat();
        this.lx = buffer.readFloat();
        this.ly = buffer.readFloat();
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        buffer.writeLong(this.tick);
        buffer.writeDouble(this.value);
        buffer.writeInt(this.interp.ordinal());
        buffer.writeInt(this.easing.ordinal());
        buffer.writeFloat(this.rx);
        buffer.writeFloat(this.ry);
        buffer.writeFloat(this.lx);
        buffer.writeFloat(this.ly);
    }

    @Override
    public void fromNBT(NBTTagCompound tag)
    {
        if (tag.hasKey("Tick")) this.tick = tag.getLong("Tick");
        if (tag.hasKey("Value")) this.value = tag.getDouble("Value");
        if (tag.hasKey("Interp")) this.interp = KeyframeInterpolation.values()[tag.getInteger("Interp")];
        if (tag.hasKey("Easing")) this.easing = KeyframeEasing.values()[tag.getInteger("Easing")];
        if (tag.hasKey("RX")) this.rx = tag.getFloat("RX");
        if (tag.hasKey("RY")) this.ry = tag.getFloat("RY");
        if (tag.hasKey("LX")) this.lx = tag.getFloat("LX");
        if (tag.hasKey("LY")) this.ly = tag.getFloat("LY");
    }

    @Override
    public NBTTagCompound toNBT(NBTTagCompound tag)
    {
        tag.setLong("Tick", this.tick);
        tag.setDouble("Value", this.value);

        if (this.interp != KeyframeInterpolation.LINEAR) tag.setInteger("Interp", this.interp.ordinal());
        if (this.easing != KeyframeEasing.IN) tag.setInteger("Easing", this.easing.ordinal());
        if (this.rx != 5) tag.setFloat("RX", this.rx);
        if (this.ry != 0) tag.setFloat("RY", this.ry);
        if (this.lx != 5) tag.setFloat("LX", this.lx);
        if (this.ly != 0) tag.setFloat("LY", this.ly);

        return tag;
    }

    public void fromJSON(JsonObject object)
    {
        this.tick = object.get("tick").getAsLong();
        this.value = object.get("value").getAsDouble();
        this.interp = KeyframeInterpolation.valueOf(object.get("interp").getAsString());
        this.easing = KeyframeEasing.valueOf(object.get("easing").getAsString());
        this.rx = object.get("rx").getAsFloat();
        this.ry = object.get("ry").getAsFloat();
        this.lx = object.get("lx").getAsFloat();
        this.ly = object.get("ly").getAsFloat();
    }

    public JsonObject toJSON()
    {
        JsonObject frame = new JsonObject();

        frame.addProperty("tick", this.tick);
        frame.addProperty("value", this.value);
        frame.addProperty("interp", this.interp.toString());
        frame.addProperty("easing", this.easing.toString());
        frame.addProperty("rx", this.rx);
        frame.addProperty("ry", this.ry);
        frame.addProperty("lx", this.lx);
        frame.addProperty("ly", this.ly);

        return frame;
    }
}


==================================================

--- Файл №300 ---
Путь: main\java\mchorse\mclib\utils\keyframes\KeyframeChannel.java
--------------------
package mchorse.mclib.utils.keyframes;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.annotations.Expose;
import io.netty.buffer.ByteBuf;
import mchorse.mclib.network.IByteBufSerializable;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Keyframe channel
 *
 * This class is responsible for storing individual keyframes and also
 * interpolating between them.
 */
public class KeyframeChannel implements IByteBufSerializable
{
    @Expose
    protected final List<Keyframe> keyframes = new ArrayList<Keyframe>();

    protected Keyframe create(long tick, double value)
    {
        return new Keyframe(tick, value);
    }

    public boolean isEmpty()
    {
        return this.keyframes.isEmpty();
    }

    public List<Keyframe> getKeyframes()
    {
        return this.keyframes;
    }

    public boolean has(int index)
    {
        return index >= 0 && index < this.keyframes.size();
    }

    public Keyframe get(int index)
    {
        return this.has(index) ? this.keyframes.get(index) : null;
    }

    public void remove(int index)
    {
        if (index < 0 || index > this.keyframes.size() - 1)
        {
            return;
        }

        Keyframe frame = this.keyframes.remove(index);

        frame.prev.next = frame.next;
        frame.next.prev = frame.prev;
    }

    /**
     * Calculate the value at given tick
     */
    public double interpolate(float ticks)
    {
        if (this.keyframes.isEmpty())
        {
            return 0;
        }

        Keyframe prev = this.keyframes.get(0);

        if (ticks < prev.tick)
        {
            return prev.value;
        }

        prev = null;

        for (Keyframe frame : this.keyframes)
        {
            if (prev != null && ticks >= prev.tick && ticks < frame.tick)
            {
                return prev.interpolate(frame, (ticks - prev.tick) / (frame.tick - prev.tick));
            }

            prev = frame;
        }

        return prev.value;
    }

    /**
     * Insert a keyframe at given tick with given value
     *
     * This method is useful as it's not creating keyframes every time you
     * need to add some value, but rather inserts in correct order or
     * overwrites existing keyframe.
     *
     * Also it returns index at which it was inserted.
     */
    public int insert(long tick, double value)
    {
        Keyframe prev = null;

        if (!this.keyframes.isEmpty())
        {
            prev = this.keyframes.get(0);

            if (tick < prev.tick)
            {
                this.keyframes.add(0, this.create(tick, value));

                return 0;
            }
        }

        prev = null;
        int index = 0;

        for (Keyframe frame : this.keyframes)
        {
            if (frame.tick == tick)
            {
                frame.value = value;

                return index;
            }

            if (prev != null && tick > prev.tick && tick < frame.tick)
            {
                break;
            }

            index++;
            prev = frame;
        }

        Keyframe frame = this.create(tick, value);
        this.keyframes.add(index, frame);

        if (this.keyframes.size() > 1)
        {
            frame.prev = this.keyframes.get(Math.max(index - 1, 0));
            frame.next = this.keyframes.get(Math.min(index + 1, this.keyframes.size() - 1));
        }

        return index;
    }

    public void moveX(long offset)
    {
        for (Keyframe keyframe : this.keyframes)
        {
            keyframe.tick += offset;
        }
    }

    /**
     * Sorts keyframes based on their ticks. This method should be used
     * when you modify individual tick values of keyframes.
     * {@link #interpolate(float)} and other methods assume the order of
     * the keyframes to be chronologically correct.
     */
    public void sort()
    {
        Collections.sort(this.keyframes, (a, b) -> (int) (a.tick - b.tick));

        if (!this.keyframes.isEmpty())
        {
            Keyframe prev = this.keyframes.get(0);

            for (Keyframe frame : this.keyframes)
            {
                frame.prev = prev;
                prev.next = frame;

                prev = frame;
            }

            prev.next = prev;
        }
    }

    public void copy(KeyframeChannel channel)
    {
        this.keyframes.clear();

        for (Keyframe frame : channel.keyframes)
        {
            this.keyframes.add(frame.copy());
        }

        this.sort();
    }

    public void fromJSON(JsonArray array)
    {
        this.keyframes.clear();

        for (JsonElement element : array)
        {
            if (!element.isJsonObject())
            {
                continue;
            }

            JsonObject object = element.getAsJsonObject();
            Keyframe keyframe = new Keyframe();

            keyframe.fromJSON(object);
            this.keyframes.add(keyframe);
        }
    }

    public JsonElement toJSON()
    {
        JsonArray array = new JsonArray();

        for (Keyframe keyframe : this.keyframes)
        {
            array.add(keyframe.toJSON());
        }

        return array;
    }

    @Override
    public void fromBytes(ByteBuf buffer)
    {
        this.keyframes.clear();

        for (int i = 0, c = buffer.readInt(); i < c; i++)
        {
            Keyframe frame = new Keyframe();

            frame.fromBytes(buffer);
            this.keyframes.add(frame);
        }

        this.sort();
    }

    @Override
    public void toBytes(ByteBuf buffer)
    {
        buffer.writeInt(this.keyframes.size());

        for (Keyframe frame : this.keyframes)
        {
            frame.toBytes(buffer);
        }
    }
}


==================================================

--- Файл №301 ---
Путь: main\java\mchorse\mclib\utils\keyframes\KeyframeEasing.java
--------------------
package mchorse.mclib.utils.keyframes;

public enum KeyframeEasing
{
    IN("in"), OUT("out"), INOUT("inout");

    public final String key;

    private KeyframeEasing(String key)
    {
        this.key = key;
    }

    public String getKey()
    {
        return "mclib.easing." + this.key;
    }
}


==================================================

--- Файл №302 ---
Путь: main\java\mchorse\mclib\utils\keyframes\KeyframeInterpolation.java
--------------------
package mchorse.mclib.utils.keyframes;

import mchorse.mclib.utils.IInterpolation;
import mchorse.mclib.utils.Interpolation;
import mchorse.mclib.utils.Interpolations;
import mchorse.mclib.utils.MathUtils;

public enum KeyframeInterpolation
{
    CONST("const")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            return KeyframeInterpolations.CONSTANT;
        }
    },
    LINEAR("linear")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            return Interpolation.LINEAR;
        }
    },
    QUAD("quad")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.QUAD_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.QUAD_OUT;

            return Interpolation.QUAD_INOUT;
        }
    },
    CUBIC("cubic")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.CUBIC_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.CUBIC_OUT;

            return Interpolation.CUBIC_INOUT;
        }
    },
    HERMITE("hermite")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            return KeyframeInterpolations.HERMITE;
        }

        @Override
        public double interpolate(Keyframe a, Keyframe b, float x)
        {
            double v0 = a.prev.value;
            double v1 = a.value;
            double v2 = b.value;
            double v3 = b.next.value;

            return Interpolations.cubicHermite(v0, v1, v2, v3, x);
        }
    },
    EXP("exp")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.EXP_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.EXP_OUT;

            return Interpolation.EXP_INOUT;
        }
    },
    BEZIER("bezier")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            return KeyframeInterpolations.BEZIER;
        }

        @Override
        public double interpolate(Keyframe a, Keyframe b, float x)
        {
            if (x <= 0) return a.value;
            if (x >= 1) return b.value;

            /* Transform input to 0..1 */
            double w = b.tick - a.tick;
            double h = b.value - a.value;

            /* In case if there is no slope whatsoever */
            if (h == 0) h = 0.00001;

            double x1 = a.rx / w;
            double y1 = a.ry / h;
            double x2 = (w - b.lx) / w;
            double y2 = (h + b.ly) / h;
            double e = 0.0005;

            e = h == 0 ? e : Math.max(Math.min(e, 1 / h * e), 0.00001);
            x1 = MathUtils.clamp(x1, 0, 1);
            x2 = MathUtils.clamp(x2, 0, 1);

            return Interpolations.bezier(0, y1, y2, 1, Interpolations.bezierX(x1, x2, x, e)) * h + a.value;
        }
    },
    BACK("back")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.BACK_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.BACK_OUT;

            return Interpolation.BACK_INOUT;
        }
    },
    ELASTIC("elastic")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.ELASTIC_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.ELASTIC_OUT;

            return Interpolation.ELASTIC_INOUT;
        }
    },
    BOUNCE("bounce")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.BOUNCE_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.BOUNCE_OUT;

            return Interpolation.BOUNCE_INOUT;
        }
    },
    SINE("sine")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.SINE_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.SINE_OUT;

            return Interpolation.SINE_INOUT;
        }
    },
    QUART("quart")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.QUART_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.QUART_OUT;

            return Interpolation.QUART_INOUT;
        }
    },
    QUINT("quint")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.QUINT_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.QUINT_OUT;

            return Interpolation.QUINT_INOUT;
        }
    },
    CIRCLE("circle")
    {
        @Override
        public IInterpolation from(KeyframeEasing easing)
        {
            if (easing == KeyframeEasing.IN) return Interpolation.CIRCLE_IN;
            if (easing == KeyframeEasing.OUT) return Interpolation.CIRCLE_OUT;

            return Interpolation.CIRCLE_INOUT;
        }
    };

    public final String key;

    private KeyframeInterpolation(String key)
    {
        this.key = key;
    }

    public IInterpolation from(KeyframeEasing easing)
    {
        return null;
    }

    public double interpolate(Keyframe a, Keyframe b, float x)
    {
        IInterpolation interpolation = this.from(a.easing);

        return interpolation == null ? a.value : interpolation.interpolate(a.value, b.value, x);
    }

    public String getKey()
    {
        return "mclib.interpolations." + this.key;
    }
}


==================================================

--- Файл №303 ---
Путь: main\java\mchorse\mclib\utils\keyframes\KeyframeInterpolations.java
--------------------
package mchorse.mclib.utils.keyframes;

import mchorse.mclib.utils.IInterpolation;
import mchorse.mclib.utils.Interpolations;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

public class KeyframeInterpolations
{
    public static final IInterpolation CONSTANT = new IInterpolation()
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return a;
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return a;
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getKey()
        {
            return "mclib.interpolations.const";
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getTooltipKey()
        {
            return "mclib.interpolations.tooltips.const";
        }
    };

    public static final IInterpolation HERMITE = new IInterpolation()
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return (float) Interpolations.cubicHermite(a, a, b, b, x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return Interpolations.cubicHermite(a, a, b, b, x);
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getKey()
        {
            return "mclib.interpolations.hermite";
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getTooltipKey()
        {
            return "mclib.interpolations.tooltips.hermite";
        }
    };

    public static final IInterpolation BEZIER = new IInterpolation()
    {
        @Override
        public float interpolate(float a, float b, float x)
        {
            return (float) Interpolations.cubicHermite(a, a, b, b, x);
        }

        @Override
        public double interpolate(double a, double b, double x)
        {
            return Interpolations.cubicHermite(a, a, b, b, x);
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getKey()
        {
            return "mclib.interpolations.bezier";
        }

        @Override
        @SideOnly(Side.CLIENT)
        public String getTooltipKey()
        {
            return "mclib.interpolations.tooltips.bezier";
        }
    };
}

==================================================

--- Файл №304 ---
Путь: main\java\mchorse\mclib\utils\resources\FilteredResourceLocation.java
--------------------
package mchorse.mclib.utils.resources;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonPrimitive;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.util.ResourceLocation;

import java.util.Objects;

public class FilteredResourceLocation implements IWritableLocation<FilteredResourceLocation>
{
    public static final int DEFAULT_COLOR = 0xffffffff;

    public ResourceLocation path;

    public boolean autoSize = true;
    public int sizeW;
    public int sizeH;

    public int color = DEFAULT_COLOR;
    public float scale = 1F;
    public boolean scaleToLargest;
    public int shiftX;
    public int shiftY;

    /* Filters */
    public int pixelate = 1;
    public boolean erase;

    public static FilteredResourceLocation from(NBTBase base)
    {
        try
        {
            FilteredResourceLocation location = new FilteredResourceLocation();

            location.fromNbt(base);

            return location;
        }
        catch (Exception e)
        {}

        return null;
    }

    public static FilteredResourceLocation from(JsonElement element)
    {
        try
        {
            FilteredResourceLocation location = new FilteredResourceLocation();

            location.fromJson(element);

            return location;
        }
        catch (Exception e)
        {}

        return null;
    }

    public FilteredResourceLocation()
    {}

    public FilteredResourceLocation(ResourceLocation path)
    {
        this.path = path;
    }

    public int getWidth(int width)
    {
        if (!this.autoSize && this.sizeW > 0)
        {
            return this.sizeW;
        }

        return width;
    }

    public int getHeight(int height)
    {
        if (!this.autoSize && this.sizeH > 0)
        {
            return this.sizeH;
        }

        return height;
    }

    @Override
    public String toString()
    {
        return this.path == null ? "" : this.path.toString();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (super.equals(obj))
        {
            return true;
        }

        if (obj instanceof FilteredResourceLocation)
        {
            FilteredResourceLocation frl = (FilteredResourceLocation) obj;

            return Objects.equals(this.path, frl.path)
                && this.autoSize == frl.autoSize
                && this.sizeW == frl.sizeW
                && this.sizeH == frl.sizeH
                && this.scaleToLargest == frl.scaleToLargest
                && this.color == frl.color
                && this.scale == frl.scale
                && this.shiftX == frl.shiftX
                && this.shiftY == frl.shiftY
                && this.pixelate == frl.pixelate
                && this.erase == frl.erase;
        }

        return false;
    }

    @Override
    public int hashCode()
    {
        int hashCode = this.path.hashCode();

        hashCode = 31 * hashCode + (this.autoSize ? 1 : 0);
        hashCode = 31 * hashCode + this.sizeW;
        hashCode = 31 * hashCode + this.sizeH;
        hashCode = 31 * hashCode + (this.scaleToLargest ? 1 : 0);
        hashCode = 31 * hashCode + this.color;
        hashCode = 31 * hashCode + (int) (this.scale * 1000);
        hashCode = 31 * hashCode + this.shiftX;
        hashCode = 31 * hashCode + this.shiftY;
        hashCode = 31 * hashCode + this.pixelate;
        hashCode = 31 * hashCode + (this.erase ? 1 : 0);

        return hashCode;
    }

    public boolean isDefault()
    {
        return (this.autoSize || (this.sizeW == 0 && this.sizeH == 0)) && this.color == DEFAULT_COLOR && !this.scaleToLargest && this.scale == 1F && this.shiftX == 0 && this.shiftY == 0 && this.pixelate <= 1 && !this.erase;
    }

    @Override
    public void fromNbt(NBTBase nbt) throws Exception
    {
        if (nbt instanceof NBTTagString)
        {
            this.path = RLUtils.create(nbt);

            return;
        }

        NBTTagCompound tag = (NBTTagCompound) nbt;

        this.path = RLUtils.create(tag.getString("Path"));

        if (tag.hasKey("Color"))
        {
            this.color = tag.getInteger("Color");
        }

        if (tag.hasKey("Scale"))
        {
            this.scale = tag.getFloat("Scale");
        }

        if (tag.hasKey("ScaleToLargest"))
        {
            this.scaleToLargest = tag.getBoolean("ScaleToLargest");
        }

        if (tag.hasKey("ShiftX"))
        {
            this.shiftX = tag.getInteger("ShiftX");
        }

        if (tag.hasKey("ShiftY"))
        {
            this.shiftY = tag.getInteger("ShiftY");
        }

        if (tag.hasKey("Pixelate"))
        {
            this.pixelate = tag.getInteger("Pixelate");
        }

        if (tag.hasKey("Erase"))
        {
            this.erase = tag.getBoolean("Erase");
        }

        if (tag.hasKey("AutoSize"))
        {
            this.autoSize = tag.getBoolean("AutoSize");
        }

        if (tag.hasKey("SizeW"))
        {
            this.sizeW = tag.getInteger("SizeW");
        }

        if (tag.hasKey("SizeH"))
        {
            this.sizeH = tag.getInteger("SizeH");
        }
    }

    @Override
    public void fromJson(JsonElement element) throws Exception
    {
        if (element.isJsonPrimitive())
        {
            this.path = RLUtils.create(element);

            return;
        }

        JsonObject object = element.getAsJsonObject();

        this.path = RLUtils.create(object.get("path").getAsString());

        if (object.has("color"))
        {
            this.color = object.get("color").getAsInt();
        }

        if (object.has("scale"))
        {
            this.scale = object.get("scale").getAsFloat();
        }

        if (object.has("scaleToLargest"))
        {
            this.scaleToLargest = object.get("scaleToLargest").getAsBoolean();
        }

        if (object.has("shiftX"))
        {
            this.shiftX = object.get("shiftX").getAsInt();
        }

        if (object.has("shiftY"))
        {
            this.shiftY = object.get("shiftY").getAsInt();
        }

        if (object.has("pixelate"))
        {
            this.pixelate = object.get("pixelate").getAsInt();
        }

        if (object.has("erase"))
        {
            this.erase = object.get("erase").getAsBoolean();
        }

        if (object.has("autoSize"))
        {
            this.autoSize = object.get("autoSize").getAsBoolean();
        }

        if (object.has("sizeW"))
        {
            this.sizeW = object.get("sizeW").getAsInt();
        }

        if (object.has("sizeH"))
        {
            this.sizeH = object.get("sizeH").getAsInt();
        }
    }

    @Override
    public NBTBase writeNbt()
    {
        NBTTagCompound tag = new NBTTagCompound();

        tag.setString("Path", this.toString());

        if (this.color != DEFAULT_COLOR) tag.setInteger("Color", this.color);
        if (this.scale != 1) tag.setFloat("Scale", this.scale);
        if (this.scaleToLargest) tag.setBoolean("ScaleToLargest", this.scaleToLargest);
        if (this.shiftX != 0) tag.setInteger("ShiftX", this.shiftX);
        if (this.shiftY != 0) tag.setInteger("ShiftY", this.shiftY);
        if (this.pixelate > 1) tag.setInteger("Pixelate", this.pixelate);
        if (this.erase) tag.setBoolean("Erase", this.erase);
        if (!this.autoSize) tag.setBoolean("AutoSize", this.autoSize);
        if (this.sizeW > 0) tag.setInteger("SizeW", this.sizeW);
        if (this.sizeH > 0) tag.setInteger("SizeH", this.sizeH);

        return tag;
    }

    @Override
    public JsonElement writeJson()
    {
        JsonObject object = new JsonObject();

        object.addProperty("path", this.toString());

        if (this.color != DEFAULT_COLOR) object.addProperty("color", this.color);
        if (this.scale != 1) object.addProperty("scale", this.scale);
        if (this.scaleToLargest) object.addProperty("scaleToLargest", this.scaleToLargest);
        if (this.shiftX != 0) object.addProperty("shiftX", this.shiftX);
        if (this.shiftY != 0) object.addProperty("shiftY", this.shiftY);
        if (this.pixelate > 1) object.addProperty("pixelate", this.pixelate);
        if (this.erase) object.addProperty("erase", this.erase);
        if (!this.autoSize) object.addProperty("autoSize", this.autoSize);
        if (this.sizeW > 0) object.addProperty("sizeW", this.sizeW);
        if (this.sizeH > 0) object.addProperty("sizeH", this.sizeH);

        return object;
    }

    @Override
    public ResourceLocation clone()
    {
        return RLUtils.clone(this.path);
    }

    @Override
    public FilteredResourceLocation copy()
    {
        return FilteredResourceLocation.from(this.writeNbt());
    }
}

==================================================

--- Файл №305 ---
Путь: main\java\mchorse\mclib\utils\resources\IResourceTransformer.java
--------------------
package mchorse.mclib.utils.resources;

import net.minecraft.util.ResourceLocation;

public interface IResourceTransformer
{
    public String transformDomain(String domain, String path);

    public String transformPath(String domain, String path);

    public String transform(String location);
}

==================================================

--- Файл №306 ---
Путь: main\java\mchorse\mclib\utils\resources\IWritableLocation.java
--------------------
package mchorse.mclib.utils.resources;

import com.google.gson.JsonElement;
import mchorse.mclib.utils.ICopy;
import net.minecraft.nbt.NBTBase;
import net.minecraft.util.ResourceLocation;

public interface IWritableLocation<T> extends ICopy<T>
{
    public void fromNbt(NBTBase nbt) throws Exception;

    public void fromJson(JsonElement element) throws Exception;

    public NBTBase writeNbt();

    public JsonElement writeJson();
}

==================================================

--- Файл №307 ---
Путь: main\java\mchorse\mclib\utils\resources\MultiResourceLocation.java
--------------------
package mchorse.mclib.utils.resources;

import com.google.common.base.Objects;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagList;
import net.minecraft.util.ResourceLocation;

import java.util.ArrayList;
import java.util.List;

/**
 * Multiple resource location class
 * 
 * This bad boy allows constructing a single texture out of several 
 * {@link ResourceLocation}s. It doesn't really make sense for other 
 * types of resources beside pictures.
 */
public class MultiResourceLocation extends ResourceLocation implements IWritableLocation<MultiResourceLocation>
{
    public List<FilteredResourceLocation> children = new ArrayList<FilteredResourceLocation>();

    private int id = -1;

    public MultiResourceLocation(String resourceName)
    {
        this();
        this.children.add(new FilteredResourceLocation(RLUtils.create(resourceName)));
    }

    public MultiResourceLocation(String resourceDomainIn, String resourcePathIn)
    {
        this();
        this.children.add(new FilteredResourceLocation(RLUtils.create(resourceDomainIn, resourcePathIn)));
    }

    public static MultiResourceLocation from(NBTBase nbt)
    {
        NBTTagList list = nbt instanceof NBTTagList ? (NBTTagList) nbt : null;

        if (list == null || list.hasNoTags())
        {
            return null;
        }

        MultiResourceLocation multi = new MultiResourceLocation();

        try
        {
            multi.fromNbt(nbt);

            return multi;
        }
        catch (Exception e)
        {}

        return null;
    }

    public static MultiResourceLocation from(JsonElement element)
    {
        JsonArray list = element.isJsonArray() ? (JsonArray) element : null;

        if (list == null || list.size() == 0)
        {
            return null;
        }

        MultiResourceLocation multi = new MultiResourceLocation();

        try
        {
            multi.fromJson(element);

            return multi;
        }
        catch (Exception e)
        {}

        return null;
    }

    public MultiResourceLocation()
    {
        /* This needed so there would less chances to match with an
         * actual ResourceLocation */
        super("it_would_be_very_ironic", "if_this_would_match_with_regular_rls");
    }

    public void recalculateId()
    {
        this.id = MultiResourceLocationManager.getId(this);
    }

    @Override
    public String getResourceDomain()
    {
        return this.children.isEmpty() ? "" : this.children.get(0).path.getResourceDomain();
    }

    @Override
    public String getResourcePath()
    {
        return this.children.isEmpty() ? "" : this.children.get(0).path.getResourcePath();
    }

    /**
     * This is mostly for looks, but it doesn't really makes sense by  
     * itself
     */
    @Override
    public String toString()
    {
        return this.getResourceDomain() + ":" + this.getResourcePath();
    }

    @Override
    public boolean equals(Object obj)
    {
        if (obj instanceof MultiResourceLocation)
        {
            MultiResourceLocation multi = (MultiResourceLocation) obj;

            return Objects.equal(this.children, multi.children);
        }

        return super.equals(obj);
    }

    @Override
    public int hashCode()
    {
        if (this.id < 0)
        {
            this.recalculateId();
        }

        return this.id;
    }

    @Override
    public void fromNbt(NBTBase nbt) throws Exception
    {
        NBTTagList list = (NBTTagList) nbt;

        for (int i = 0; i < list.tagCount(); i++)
        {
            FilteredResourceLocation location = FilteredResourceLocation.from(list.get(i));

            if (location != null)
            {
                this.children.add(location);
            }
        }
    }

    @Override
    public void fromJson(JsonElement element) throws Exception
    {
        JsonArray array = (JsonArray) element;

        for (int i = 0; i < array.size(); i++)
        {
            FilteredResourceLocation location = FilteredResourceLocation.from(array.get(i));

            if (location != null)
            {
                this.children.add(location);
            }
        }
    }

    @Override
    public NBTBase writeNbt()
    {
        NBTTagList list = new NBTTagList();

        for (FilteredResourceLocation child : this.children)
        {
            NBTBase tag = child.writeNbt();

            if (tag != null)
            {
                list.appendTag(tag);
            }
        }

        return list;
    }

    @Override
    public JsonElement writeJson()
    {
        JsonArray array = new JsonArray();

        for (FilteredResourceLocation child : this.children)
        {
            JsonElement element = child.writeJson();

            if (element != null)
            {
                array.add(element);
            }
        }

        return array;
    }

    @Override
    public MultiResourceLocation copy()
    {
        MultiResourceLocation newMulti = new MultiResourceLocation();

        for (FilteredResourceLocation child : this.children)
        {
            newMulti.children.add(child.copy());
        }

        return newMulti;
    }
}

==================================================

--- Файл №308 ---
Путь: main\java\mchorse\mclib\utils\resources\MultiResourceLocationManager.java
--------------------
package mchorse.mclib.utils.resources;

import net.minecraft.util.ResourceLocation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class MultiResourceLocationManager
{
    private static int id = 0;
    private static Map<ResourceLocation, List<Pair>> map = new HashMap<ResourceLocation, List<Pair>>();

    public static int getId(MultiResourceLocation location)
    {
        if (location.children.isEmpty())
        {
            return -1;
        }

        ResourceLocation keyRL = location.children.get(0).path;
        List<Pair> pairs = map.get(keyRL);

        if (pairs == null)
        {
            pairs = new ArrayList<Pair>();

            map.put(keyRL, pairs);
        }

        for (Pair pair : pairs)
        {
            if (pair.mrl.equals(location))
            {
                return pair.id;
            }
        }

        int newId = id;

        pairs.add(new Pair(newId, location.copy()));
        id += 1;

        return newId;
    }

    private static class Pair
    {
        public int id;
        public MultiResourceLocation mrl;

        public Pair(int id, MultiResourceLocation mrl)
        {
            this.id = id;
            this.mrl = mrl;
        }
    }
}

==================================================

--- Файл №309 ---
Путь: main\java\mchorse\mclib\utils\resources\MultiskinThread.java
--------------------
package mchorse.mclib.utils.resources;

import mchorse.mclib.utils.ReflectionUtils;
import net.minecraft.client.Minecraft;
import net.minecraft.client.renderer.GLAllocation;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.texture.ITextureObject;
import net.minecraft.client.renderer.texture.TextureUtil;
import org.lwjgl.opengl.GL11;

import java.awt.image.BufferedImage;
import java.nio.ByteBuffer;
import java.util.Stack;

public class MultiskinThread implements Runnable
{
    private static MultiskinThread instance;
    private static Thread thread;

    public Stack<MultiResourceLocation> locations = new Stack<MultiResourceLocation>();

    public static synchronized void add(MultiResourceLocation location)
    {
        if (instance != null && !thread.isAlive())
        {
            instance = null;
        }

        if (instance == null)
        {
            instance = new MultiskinThread();
            instance.addLocation(location);
            thread = new Thread(instance);
            thread.start();
        }
        else
        {
            instance.addLocation(location);
        }
    }

    public static void clear()
    {
        instance = null;
    }

    /**
     * Create a byte buffer from buffered image
     */
    public static ByteBuffer bytesFromBuffer(BufferedImage image)
    {
        int w = image.getWidth();
        int h = image.getHeight();

        ByteBuffer buffer = GLAllocation.createDirectByteBuffer(w * h * 4);
        int[] pixels = new int[w * h];

        image.getRGB(0, 0, w, h, pixels, 0, w);

        for (int y = 0; y < h; y++)
        {
            for (int x = 0; x < w; x++)
            {
                int pixel = pixels[y * w + x];

                buffer.put((byte) ((pixel >> 16) & 0xFF));
                buffer.put((byte) ((pixel >> 8) & 0xFF));
                buffer.put((byte) (pixel & 0xFF));
                buffer.put((byte) ((pixel >> 24) & 0xFF));
            }
        }

        buffer.flip();

        return buffer;
    }

    public synchronized void addLocation(MultiResourceLocation location)
    {
        if (this.locations.contains(location))
        {
            return;
        }

        this.locations.add(location);
    }

    @Override
    public void run()
    {
        while (!this.locations.isEmpty() && instance != null)
        {
            MultiResourceLocation location = this.locations.peek();
            ITextureObject texture = ReflectionUtils.getTextures(Minecraft.getMinecraft().renderEngine).get(location);

            try
            {
                if (texture != null)
                {
                    this.locations.pop();

                    BufferedImage image = TextureProcessor.postProcess(location);
                    int w = image.getWidth();
                    int h = image.getHeight();
                    ByteBuffer buffer = bytesFromBuffer(image);

                    Minecraft.getMinecraft().addScheduledTask(() ->
                    {
                        TextureUtil.allocateTexture(texture.getGlTextureId(), w, h);

                        GL11.glBindTexture(GL11.GL_TEXTURE_2D, texture.getGlTextureId());
                        GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MIN_FILTER, GL11.GL_NEAREST);
                        GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_MAG_FILTER, GL11.GL_NEAREST);
                        GL11.glTexImage2D(GL11.GL_TEXTURE_2D, 0, GL11.GL_RGBA8, w, h, 0, GL11.GL_RGBA, GL11.GL_UNSIGNED_BYTE, buffer);
                    });
                }

                Thread.sleep(100);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }

        instance = null;
        thread = null;
    }
}

==================================================

--- Файл №310 ---
Путь: main\java\mchorse\mclib\utils\resources\PixelAccessor.java
--------------------
package mchorse.mclib.utils.resources;

import mchorse.mclib.utils.Color;

public enum PixelAccessor
{
    BYTE()
    {
        @Override
        public void get(Pixels pixels, int index, Color color)
        {
            index *= pixels.pixelLength;

            int offset = 0;

            if (pixels.hasAlpha())
            {
                color.a = ((int) pixels.pixelBytes[index + offset++] & 0xff) / 255F;
            }
            else
            {
                color.a = 1;
            }

            color.b = ((int) pixels.pixelBytes[index + offset++] & 0xff) / 255F;
            color.g = ((int) pixels.pixelBytes[index + offset++] & 0xff) / 255F;
            color.r = ((int) pixels.pixelBytes[index + offset] & 0xff) / 255F;
        }

        @Override
        public void set(Pixels pixels, int index, Color color)
        {
            index *= pixels.pixelLength;

            int offset = 0;

            if (pixels.hasAlpha())
            {
                pixels.pixelBytes[index + offset++] = (byte) (color.a * 0xff);
            }

            pixels.pixelBytes[index + offset++] = (byte) (color.b * 0xff);
            pixels.pixelBytes[index + offset++] = (byte) (color.g * 0xff);
            pixels.pixelBytes[index + offset] = (byte) (color.r * 0xff);
        }
    },
    INT()
    {
        @Override
        public void get(Pixels pixels, int index, Color color)
        {
            int c = pixels.pixelInts[index];

            int a = c >> 24 & 0xff;
            int b = c >> 16 & 0xff;
            int g = c >> 8 & 0xff;
            int r = c & 0xff;

            color.r = r / 255F;
            color.g = g / 255F;
            color.b = b / 255F;
            color.a = a / 255F;
        }

        @Override
        public void set(Pixels pixels, int index, Color color)
        {
            pixels.pixelInts[index] = ((int) (color.a * 0xff) << 24) + ((int) (color.b * 0xff) << 16) + ((int) (color.g * 0xff) << 8) + (int) (color.r * 0xff);
        }
    };

    public abstract void get(Pixels pixels, int index, Color color);

    public abstract void set(Pixels pixels, int index, Color color);
}

==================================================

--- Файл №311 ---
Путь: main\java\mchorse\mclib\utils\resources\Pixels.java
--------------------
package mchorse.mclib.utils.resources;

import mchorse.mclib.utils.Color;

import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;
import java.awt.image.DataBufferInt;

public class Pixels
{
    public byte[] pixelBytes;
    public int[] pixelInts;
    public int pixelLength;
    public int width;
    public int height;

    public Color color = new Color();
    private PixelAccessor accessor;

    public void set(BufferedImage image)
    {
        if (image.getRaster().getDataBuffer() instanceof DataBufferByte)
        {
            this.pixelBytes = ((DataBufferByte) image.getRaster().getDataBuffer()).getData();
            this.pixelInts = null;
            this.accessor = PixelAccessor.BYTE;
        }
        else
        {
            this.pixelInts = ((DataBufferInt) image.getRaster().getDataBuffer()).getData();
            this.pixelBytes = null;
            this.accessor = PixelAccessor.INT;
        }

        this.pixelLength = image.getAlphaRaster() != null ? 4 : 3;
        this.width = image.getWidth();
        this.height = image.getHeight();
    }

    public boolean hasAlpha()
    {
        return this.pixelLength == 4;
    }

    public int toIndex(int x, int y)
    {
        return x + y * this.width;
    }

    public int toX(int index)
    {
        return index % this.width;
    }

    public int toY(int index)
    {
        return index / this.width;
    }

    public int getCount()
    {
        return this.accessor == PixelAccessor.BYTE ? this.pixelBytes.length / this.pixelLength : this.pixelInts.length;
    }

    public Color getColor(int index)
    {
        this.accessor.get(this, index, this.color);

        return this.color;
    }

    public Color getColor(int x, int y)
    {
        return this.getColor(this.toIndex(x, y));
    }

    public void setColor(int index, Color color)
    {
        this.accessor.set(this, index, color);
    }

    public void setColor(int x, int y, Color color)
    {
        this.setColor(this.toIndex(x, y), color);
    }
}

==================================================

--- Файл №312 ---
Путь: main\java\mchorse\mclib\utils\resources\RLUtils.java
--------------------
package mchorse.mclib.utils.resources;

import com.google.gson.JsonElement;
import com.google.gson.JsonNull;
import com.google.gson.JsonPrimitive;
import mchorse.mclib.McLib;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.IResource;
import net.minecraft.client.resources.SimpleResource;
import net.minecraft.nbt.NBTBase;
import net.minecraft.nbt.NBTTagString;
import net.minecraft.util.ResourceLocation;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.imageio.ImageIO;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * {@link ResourceLocation} utility methods
 *
 * This class has utils for saving and reading {@link ResourceLocation} from
 * actor model and skin.
 */
public class RLUtils
{
    private static List<IResourceTransformer> transformers = new ArrayList<IResourceTransformer>();
    private static ResourceLocation pixel = new ResourceLocation("mclib:textures/pixel.png");

    /**
     * Get stream for multi resource location 
     */
    @SideOnly(Side.CLIENT)
    public static IResource getStreamForMultiskin(MultiResourceLocation multi) throws IOException
    {
        if (multi.children.isEmpty())
        {
            throw new IOException("Multi-skin is empty!");
        }

        try
        {
            if (McLib.multiskinMultiThreaded.get())
            {
                MultiskinThread.add(multi);

                return Minecraft.getMinecraft().getResourceManager().getResource(pixel);
            }
            else
            {
                MultiskinThread.clear();
                ByteArrayOutputStream stream = new ByteArrayOutputStream();
                ImageIO.write(TextureProcessor.postProcess(multi), "png", stream);

                return new SimpleResource("McLib multiskin handler", multi, new ByteArrayInputStream(stream.toByteArray()), null, null);
            }
        }
        catch (IOException e)
        {
            throw e;
        }
        catch (Exception e)
        {
            throw new IOException(e);
        }
    }

    public static void register(IResourceTransformer transformer)
    {
        transformers.add(transformer);
    }

    public static ResourceLocation create(String path)
    {
        for (IResourceTransformer transformer : transformers)
        {
            path = transformer.transform(path);
        }

        return new TextureLocation(path);
    }

    public static ResourceLocation create(String domain, String path)
    {
        for (IResourceTransformer transformer : transformers)
        {
            String newDomain = transformer.transformDomain(domain, path);
            String newPath = transformer.transformPath(domain, path);

            domain = newDomain;
            path = newPath;
        }

        return new TextureLocation(domain, path);
    }

    public static ResourceLocation create(NBTBase base)
    {
        ResourceLocation location = MultiResourceLocation.from(base);

        if (location != null)
        {
            return location;
        }

        if (base instanceof NBTTagString)
        {
            return create(((NBTTagString) base).getString());
        }

        return null;
    }

    public static ResourceLocation create(JsonElement element)
    {
        ResourceLocation location = MultiResourceLocation.from(element);

        if (location != null)
        {
            return location;
        }

        if (element.isJsonPrimitive())
        {
            return create(element.getAsString());
        }

        return null;
    }

    public static NBTBase writeNbt(ResourceLocation location)
    {
        if (location instanceof IWritableLocation)
        {
            return ((IWritableLocation) location).writeNbt();
        }
        else if (location != null)
        {
            return new NBTTagString(location.toString());
        }

        return null;
    }

    public static JsonElement writeJson(ResourceLocation location)
    {
        if (location instanceof IWritableLocation)
        {
            return ((IWritableLocation) location).writeJson();
        }
        else if (location != null)
        {
            return new JsonPrimitive(location.toString());
        }

        return JsonNull.INSTANCE;
    }

    public static ResourceLocation clone(ResourceLocation location)
    {
        if (location instanceof IWritableLocation)
        {
            Object copy = ((IWritableLocation) location).copy();

            if (copy instanceof ResourceLocation)
            {
                return (ResourceLocation) copy;
            }
        }

        if (location != null)
        {
            return create(location.toString());
        }

        return null;
    }
}

==================================================

--- Файл №313 ---
Путь: main\java\mchorse\mclib\utils\resources\TextureLocation.java
--------------------
package mchorse.mclib.utils.resources;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;

import net.minecraft.util.ResourceLocation;

/**
 * Texture location
 *
 * A hack class that allows to use uppercase characters in the path 1.11.2 and
 * up.
 */
public class TextureLocation extends ResourceLocation
{
    public TextureLocation(String domain, String path)
    {
        super(domain, path);

        this.set(domain, path);
    }

    public TextureLocation(String string)
    {
        super(string);

        this.set(string);
    }

    public void set(String location)
    {
        String[] split = location.split(":");
        String domain = split.length > 0 ? split[0] : "minecraft";
        String path = split.length > 1 ? split[1] : "";

        this.set(domain, path);
    }

    public void set(String domain, String path)
    {
        /* Guess what it does */
        Field[] fields = ResourceLocation.class.getDeclaredFields();

        for (Field field : fields)
        {
            try
            {
                this.unlockField(field);
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        }

        try
        {
            fields[0].set(this, domain);
            fields[1].set(this, path);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    protected void unlockField(Field field) throws Exception
    {
        field.setAccessible(true);

        Field modifiers = Field.class.getDeclaredField("modifiers");
        modifiers.setAccessible(true);
        modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);
    }
}

==================================================

--- Файл №314 ---
Путь: main\java\mchorse\mclib\utils\resources\TextureProcessor.java
--------------------
package mchorse.mclib.utils.resources;

import mchorse.mclib.McLib;
import mchorse.mclib.events.MultiskinProcessedEvent;
import mchorse.mclib.utils.Color;
import net.minecraft.client.Minecraft;
import net.minecraft.client.resources.IResource;
import net.minecraft.client.resources.IResourceManager;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

@SideOnly(Side.CLIENT)
public class TextureProcessor
{
    public static Pixels pixels = new Pixels();
    public static Pixels target = new Pixels();

    public static BufferedImage postProcess(MultiResourceLocation multi)
    {
        BufferedImage image = process(multi);

        Minecraft.getMinecraft().addScheduledTask(() ->
        {
            McLib.EVENT_BUS.post(new MultiskinProcessedEvent(multi, image));
        });

        return image;
    }

    public static BufferedImage process(MultiResourceLocation multi)
    {
        IResourceManager manager = Minecraft.getMinecraft().getResourceManager();
        List<BufferedImage> images = new ArrayList<BufferedImage>();

        int w = 0;
        int h = 0;

        for (int i = 0; i < multi.children.size(); i++)
        {
            FilteredResourceLocation child = multi.children.get(i);
            BufferedImage image = null;

            try
            {
                IResource resource = manager.getResource(child.path);

                image = ImageIO.read(resource.getInputStream());

                w = Math.max(w, child.getWidth(image.getWidth()));
                h = Math.max(h, child.getHeight(image.getHeight()));
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }

            images.add(image);
        }

        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics g = image.getGraphics();

        for (int i = 0; i < multi.children.size(); i++)
        {
            BufferedImage child = images.get(i);

            if (child == null)
            {
                continue;
            }

            FilteredResourceLocation filter = multi.children.get(i);
            int iw = child.getWidth();
            int ih = child.getHeight();

            if (filter.scaleToLargest)
            {
                iw = w;
                ih = h;
            }
            else if (filter.scale != 0 && filter.scale > 0)
            {
                iw = (int) (iw * filter.scale);
                ih = (int) (ih * filter.scale);
            }

            if (iw > 0 && ih > 0)
            {
                if (filter.erase)
                {
                    processErase(image, child, filter, iw, ih);
                }
                else
                {
                    if (filter.color != 0xffffff || filter.pixelate > 1)
                    {
                        processImage(child, filter);
                    }

                    g.drawImage(child, filter.shiftX, filter.shiftY, iw, ih, null);
                }
            }
        }

        g.dispose();

        return image;
    }

    /**
     * Apply erasing
     */
    private static void processErase(BufferedImage image, BufferedImage child, FilteredResourceLocation filter, int iw, int ih)
    {
        BufferedImage mask = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());
        Graphics g2 = mask.getGraphics();

        g2.drawImage(child, filter.shiftX, filter.shiftY, iw, ih, null);
        g2.dispose();

        target.set(mask);
        pixels.set(image);

        for (int p = 0, c = target.getCount(); p < c; p++)
        {
            Color pixel = target.getColor(p);

            if (pixel.a > 0.999F)
            {
                pixel = pixels.getColor(p);
                pixel.a = 0;
                pixels.setColor(p, pixel);
            }
        }
    }

    /**
     * Apply filters
     */
    private static void processImage(BufferedImage child, FilteredResourceLocation frl)
    {
        pixels.set(child);

        Color filter = new Color().set(frl.color);
        Color pixel = new Color();

        for (int i = 0, c = pixels.getCount(); i < c; i++)
        {
            pixel.copy(pixels.getColor(i));

            if (pixels.hasAlpha())
            {
                if (pixel.a <= 0)
                {
                    continue;
                }
            }

            if (frl.pixelate > 1)
            {
                int x = pixels.toX(i);
                int y = pixels.toY(i);
                boolean origin = x % frl.pixelate == 0 && y % frl.pixelate == 0;

                x -= x % frl.pixelate;
                y -= y % frl.pixelate;

                pixel.copy(pixels.getColor(x, y));
                pixels.setColor(i, pixel);

                if (!origin)
                {
                    continue;
                }
            }

            pixel.r *= filter.r;
            pixel.g *= filter.g;
            pixel.b *= filter.b;
            pixel.a *= filter.a;
            pixels.setColor(i, pixel);
        }
    }
}

==================================================

--- Файл №315 ---
Путь: main\java\mchorse\mclib\utils\shaders\Shader.java
--------------------
package mchorse.mclib.utils.shaders;

import org.apache.commons.io.IOUtils;
import org.lwjgl.opengl.GL20;

import java.nio.charset.StandardCharsets;

public class Shader
{
    public int programId = -1;

    public void compile(String vertexPath, String fragmentPath, boolean code) throws Exception
    {
        if (this.programId != -1)
        {
            return;
        }

        this.programId = GL20.glCreateProgram();

        int vertex = this.createShader(vertexPath, GL20.GL_VERTEX_SHADER, code);
        int fragment = this.createShader(fragmentPath, GL20.GL_FRAGMENT_SHADER, code);

        GL20.glLinkProgram(this.programId);

        if (GL20.glGetProgrami(this.programId, GL20.GL_LINK_STATUS) == 0)
        {
            throw new Exception("Error linking Shader code: " + GL20.glGetProgramInfoLog(this.programId, 1024));
        }

        if (vertex != 0)
        {
            GL20.glDetachShader(this.programId, vertex);
        }

        if (fragment != 0)
        {
            GL20.glDetachShader(this.programId, fragment);
        }

        GL20.glValidateProgram(this.programId);

        if (GL20.glGetProgrami(this.programId, GL20.GL_VALIDATE_STATUS) == 0)
        {
            System.err.println("Warning validating Shader code: " + GL20.glGetProgramInfoLog(this.programId, 1024));
        }

        GL20.glDeleteShader(vertex);
        GL20.glDeleteShader(fragment);
    }

    /**
     * Shared code for compiling a shader program's shader
     */
    protected int createShader(String shaderPath, int shaderType, boolean code) throws Exception
    {
        String shaderCode = code ? shaderPath : IOUtils.toString(this.getClass().getResourceAsStream(shaderPath), StandardCharsets.UTF_8);
        int shaderId = GL20.glCreateShader(shaderType);

        if (shaderId == 0)
        {
            throw new Exception("Error creating shader. Type: " + shaderType);
        }

        GL20.glShaderSource(shaderId, shaderCode);
        GL20.glCompileShader(shaderId);

        if (GL20.glGetShaderi(shaderId, GL20.GL_COMPILE_STATUS) == 0)
        {
            throw new Exception("Error compiling Shader code: " + GL20.glGetShaderInfoLog(shaderId, 1024));
        }

        GL20.glAttachShader(this.programId, shaderId);

        return shaderId;
    }

    public void bind()
    {
        GL20.glUseProgram(this.programId);
    }

    public void unbind()
    {
        GL20.glUseProgram(0);
    }
}

==================================================

--- Файл №316 ---
Путь: main\java\mchorse\mclib\utils\undo\CompoundUndo.java
--------------------
package mchorse.mclib.utils.undo;

import java.util.ArrayList;
import java.util.List;

/**
 * Compound undo
 *
 * This generalized undo element allows to undo/redo multiple undo/redos
 * at a time
 */
public class CompoundUndo <T> implements IUndo<T>
{
    private List<IUndo<T>> undos = new ArrayList<IUndo<T>>();
    private boolean mergable = true;

    public CompoundUndo(IUndo<T>... undos)
    {
        for (IUndo<T> undo : undos)
        {
            if (undo == null)
            {
                continue;
            }

            this.undos.add(undo);
        }
    }

    public List<IUndo<T>> getUndos()
    {
        return this.undos;
    }

    /**
     * Get first undo matching given class
     */
    public IUndo<T> getFirst(Class<? extends IUndo<T>> clazz)
    {
        int i = 0;

        while (i < this.undos.size())
        {
            IUndo<T> undo = this.undos.get(i);

            if (clazz.isAssignableFrom(undo.getClass()))
            {
                return undo;
            }

            i += 1;
        }

        return null;
    }

    /**
     * Get last undo matching given class
     */
    public IUndo<T> getLast(Class<? extends IUndo<T>> clazz)
    {
        int i = this.undos.size() - 1;

        while (i >= 0)
        {
            IUndo<T> undo = this.undos.get(i);

            if (clazz.isAssignableFrom(undo.getClass()))
            {
                return undo;
            }

            i -= 1;
        }

        return null;
    }

    public boolean has(Class<? extends IUndo<T>> clazz)
    {
        for (IUndo<T> undo : this.undos)
        {
            if (clazz.isAssignableFrom(undo.getClass()))
            {
                return true;
            }
        }

        return false;
    }

    @Override
    public IUndo<T> noMerging()
    {
        this.mergable = false;

        return this;
    }

    @Override
    public boolean isMergeable(IUndo<T> undo)
    {
        if (this.mergable && undo instanceof CompoundUndo && ((CompoundUndo<T>) undo).undos.size() == this.undos.size())
        {
            CompoundUndo<T> compound = (CompoundUndo<T>) undo;

            for (int i = 0; i < this.undos.size(); i++)
            {
                if (!this.undos.get(i).isMergeable(compound.undos.get(i)))
                {
                    return false;
                }
            }

            return true;
        }

        return false;
    }

    @Override
    public void merge(IUndo<T> undo)
    {
        CompoundUndo<T> theUndo = (CompoundUndo<T>) undo;

        for (int i = 0, c = this.undos.size(); i < c; i++)
        {
            IUndo<T> otherChildUndo = theUndo.undos.get(i);
            IUndo<T> myUndo = this.undos.get(i);

            if (myUndo.isMergeable(otherChildUndo))
            {
                myUndo.merge(otherChildUndo);
            }
        }
    }

    @Override
    public void undo(T context)
    {
        for (int i = this.undos.size() - 1; i >= 0; i--)
        {
            this.undos.get(i).undo(context);
        }
    }

    @Override
    public void redo(T context)
    {
        for (IUndo<T> undo : this.undos)
        {
            undo.redo(context);
        }
    }
}

==================================================

--- Файл №317 ---
Путь: main\java\mchorse\mclib\utils\undo\IUndo.java
--------------------
package mchorse.mclib.utils.undo;

/**
 * An undo entry in the UndoManager
 *
 * This represents a single operation that can be either undone or redone.
 * The generic represents context upon which this undo acts upon.
 */
public interface IUndo <T>
{
    /**
     * Mark undo as unmergable
     */
    public IUndo<T> noMerging();

    /**
     * Check whether a given undo is compatible with whatever
     * data it might be storing
     */
    public boolean isMergeable(IUndo<T> undo);

    /**
     * Merge the data with given undo
     */
    public void merge(IUndo<T> undo);

    /**
     * Undo changes made to given context
     */
    public void undo(T context);

    /**
     * Redo changes made to given context
     */
    public void redo(T context);
}


==================================================

--- Файл №318 ---
Путь: main\java\mchorse\mclib\utils\undo\IUndoListener.java
--------------------
package mchorse.mclib.utils.undo;

public interface IUndoListener<T>
{
    public void handleUndo(IUndo<T> undo, boolean redo);
}

==================================================

--- Файл №319 ---
Путь: main\java\mchorse\mclib\utils\undo\UndoManager.java
--------------------
package mchorse.mclib.utils.undo;

import java.util.LinkedList;
import java.util.List;

/**
 * Undo manager
 *
 * This class is responsible for handling undo/redo functionality. In theory,
 * it can be used to practically with any data type.
 */
public class UndoManager<T>
{
    private List<IUndo<T>> undos = new LinkedList<IUndo<T>>();
    private int position = -1;

    private int limit = 20;
    private IUndoListener<T> callback;
    private boolean simpleMerge;

    public UndoManager()
    {}

    public UndoManager(int limit)
    {
        this.limit = limit;
    }

    public UndoManager(IUndoListener<T> callback)
    {
        this.callback = callback;
    }

    public UndoManager(int limit, IUndoListener<T> callback)
    {
        this.limit = limit;
        this.callback = callback;
    }

    public UndoManager<T> simpleMerge()
    {
        this.simpleMerge = true;

        return this;
    }

    public IUndoListener<T> getCallback()
    {
        return this.callback;
    }

    public void setCallback(IUndoListener<T> callback)
    {
        this.callback = callback;
    }

    /* Getters */

    public IUndo<T> getCurrentUndo()
    {
        if (this.position >= 0 && this.position < this.undos.size())
        {
            return this.undos.get(this.position);
        }

        return null;
    }

    public int getCurrentUndos()
    {
        return this.position + 1;
    }

    public int getTotalUndos()
    {
        return this.undos.size();
    }

    /**
     * Push the undo, and apply it immediately
     */
    public IUndo<T> pushApplyUndo(IUndo<T> undo, T context)
    {
        IUndo<T> newUndo = this.pushUndo(undo);

        newUndo.redo(context);

        if (this.callback != null)
        {
            this.callback.handleUndo(undo, true);
        }

        return newUndo;
    }

    public IUndo<T> pushUndo(IUndo<T> undo)
    {
        IUndo<T> present = this.position == -1 ? null : this.undos.get(this.position);

        if (present != null && this.checkMergeability(present, undo))
        {
            this.removeConsequent();
            present.merge(undo);
        }
        else
        {
            if (this.position + 1 >= this.limit)
            {
                this.undos.remove(0);
            }
            else
            {
                this.removeConsequent();
                this.position += 1;
            }

            present = undo;
            this.undos.add(undo);
        }

        return present;
    }

    private boolean checkMergeability(IUndo<T> present, IUndo<T> undo)
    {
        if (this.simpleMerge)
        {
            return present.isMergeable(undo);
        }

        return present.isMergeable(undo) && undo.isMergeable(present);
    }

    protected void removeConsequent()
    {
        /* Remove the consequent undos that could've been redone */
        while (this.undos.size() > this.position + 1)
        {
            this.undos.remove(this.undos.size() - 1);
        }
    }

    /**
     * Undo changes done to context
     */
    public boolean undo(T context)
    {
        if (this.position < 0)
        {
            return false;
        }

        IUndo<T> undo = this.undos.get(this.position);

        undo.undo(context);
        this.position -= 1;

        if (this.callback != null)
        {
            this.callback.handleUndo(undo, false);
        }

        return true;
    }

    /**
     * Redo changes done to context
     */
    public boolean redo(T context)
    {
        if (this.position + 1 >= this.undos.size())
        {
            return false;
        }

        IUndo<T> undo = this.undos.get(this.position + 1);

        undo.redo(context);
        this.position += 1;

        if (this.callback != null)
        {
            this.callback.handleUndo(undo, true);
        }

        return true;
    }
}

==================================================

--- Файл №320 ---
Путь: main\java\mchorse\mclib\utils\wav\Wave.java
--------------------
package mchorse.mclib.utils.wav;

import net.minecraft.client.renderer.GLAllocation;
import org.lwjgl.openal.AL10;

import java.nio.ByteBuffer;

public class Wave
{
    public int audioFormat;
    public int numChannels;
    public int sampleRate;
    public int byteRate;
    public int blockAlign;
    public int bitsPerSample;

    public byte[] data;

    public Wave(int audioFormat, int numChannels, int sampleRate, int byteRate, int blockAlign, int bitsPerSample, byte[] data)
    {
        this.audioFormat = audioFormat;
        this.numChannels = numChannels;
        this.sampleRate = sampleRate;
        this.byteRate = byteRate;
        this.blockAlign = blockAlign;
        this.bitsPerSample = bitsPerSample;
        this.data = data;
    }

    public int getBytesPerSample()
    {
        return this.bitsPerSample / 8;
    }

    public float getDuration()
    {
        return this.data.length / this.numChannels / this.getBytesPerSample() / (float) this.sampleRate;
    }

    public int getALFormat()
    {
        int bytes = this.getBytesPerSample();

        if (bytes == 1)
        {
            if (this.numChannels == 2)
            {
                return AL10.AL_FORMAT_STEREO8;
            }
            else if (this.numChannels == 1)
            {
                return AL10.AL_FORMAT_MONO8;
            }
        }
        else if (bytes == 2)
        {
            if (this.numChannels == 2)
            {
                return AL10.AL_FORMAT_STEREO16;
            }
            else if (this.numChannels == 1)
            {
                return AL10.AL_FORMAT_MONO16;
            }
        }

        throw new IllegalStateException("Current WAV file has unusual configuration... channels: " + this.numChannels + ", BPS: " + bytes);
    }

    public int getScanRegion(float pixelsPerSecond)
    {
        return (int) (this.sampleRate / pixelsPerSecond) * this.getBytesPerSample() * this.numChannels;
    }

    public Wave convertTo16()
    {
        final int bytes = 16 / 8;

        int c = this.data.length / this.numChannels / this.getBytesPerSample();
        int byteRate = c * this.numChannels * bytes ;
        byte[] data = new byte[byteRate];
        boolean isFloat = this.getBytesPerSample() == 4;

        Wave wave = new Wave(this.audioFormat, this.numChannels, this.sampleRate, byteRate, bytes * this.numChannels, 16, data);

        ByteBuffer sample = GLAllocation.createDirectByteBuffer(4);
        ByteBuffer dataBuffer = GLAllocation.createDirectByteBuffer(data.length);

        for (int i = 0; i < c * this.numChannels; i++)
        {
            sample.clear();

            for (int j = 0; j < this.getBytesPerSample(); j++)
            {
                sample.put(this.data[i * this.getBytesPerSample() + j]);
            }

            if (isFloat)
            {
                sample.flip();
                dataBuffer.putShort((short) (sample.getFloat() * 0xffff / 2));
            }
            else
            {
                sample.put((byte) 0);
                sample.flip();
                dataBuffer.putShort((short) ((int) (sample.getInt() / (0xffffff / 2F) * (0xffff / 2F))));
            }
        }

        dataBuffer.flip();
        dataBuffer.get(data);

        return wave;
    }
}

==================================================

--- Файл №321 ---
Путь: main\java\mchorse\mclib\utils\wav\Waveform.java
--------------------
package mchorse.mclib.utils.wav;

import mchorse.mclib.client.gui.framework.elements.utils.GuiDraw;
import net.minecraft.client.renderer.GlStateManager;
import net.minecraft.client.renderer.texture.TextureUtil;
import net.minecraftforge.fml.relauncher.Side;
import net.minecraftforge.fml.relauncher.SideOnly;
import org.lwjgl.opengl.GL11;
import org.lwjgl.opengl.GL12;

import java.awt.*;
import java.awt.image.BufferedImage;
import java.util.ArrayList;
import java.util.List;

/**
 * Waveform class
 *
 * This class allows to
 */
@SideOnly(Side.CLIENT)
public class Waveform
{
    public float[] average;
    public float[] maximum;

    private List<WaveformSprite> sprites = new ArrayList<WaveformSprite>();
    private int w;
    private int h;
    private int pixelsPerSecond;

    public void generate(Wave data, int pixelsPerSecond, int height)
    {
        if (data.getBytesPerSample() != 2)
        {
            throw new IllegalStateException("Waveform generation doesn't support non 16-bit audio data!");
        }

        this.populate(data, pixelsPerSecond, height);
        this.render();
    }

    public void render()
    {
        this.delete();

        int maxTextureSize = GL11.glGetInteger(GL11.GL_MAX_TEXTURE_SIZE) / 2;
        int count = (int) Math.ceil(this.w / (double) maxTextureSize);
        int offset = 0;

        for (int t = 0; t < count; t++)
        {
            int texture = GlStateManager.generateTexture();
            int width = Math.min(this.w - offset, maxTextureSize);

            BufferedImage image = new BufferedImage(width, this.h, BufferedImage.TYPE_INT_ARGB);
            Graphics g = image.getGraphics();

            for (int i = offset, j = 0, c = Math.min(offset + width, this.average.length); i < c; i++, j++)
            {
                float average = this.average[i];
                float maximum = this.maximum[i];

                int maxHeight = (int) (maximum * this.h);
                int avgHeight = (int) (average * (this.h - 1)) + 1;

                if (avgHeight > 0)
                {
                    g.setColor(java.awt.Color.WHITE);
                    g.drawRect(j, this.h / 2 - maxHeight / 2, 1, maxHeight);
                    g.setColor(java.awt.Color.LIGHT_GRAY);
                    g.drawRect(j, this.h / 2 - avgHeight / 2, 1, avgHeight);
                }
            }

            g.dispose();

            TextureUtil.uploadTextureImage(texture, image);
            GlStateManager.glTexParameteri(GL11.GL_TEXTURE_2D, GL11.GL_TEXTURE_WRAP_S, GL12.GL_CLAMP_TO_EDGE);

            this.sprites.add(new WaveformSprite(texture, width));

            offset += maxTextureSize;
        }
    }

    public void populate(Wave data, int pixelsPerSecond, int height)
    {
        this.pixelsPerSecond = pixelsPerSecond;
        this.w = (int) (data.getDuration() * pixelsPerSecond);
        this.h = height;
        this.average = new float[this.w];
        this.maximum = new float[this.w];

        int region = data.getScanRegion(pixelsPerSecond);

        for (int i = 0; i < this.w; i ++)
        {
            int offset = i * region;
            int count = 0;
            float average = 0;
            float maximum = 0;

            for (int j = 0; j < region; j += 2 * data.numChannels)
            {
                if (offset + j + 1 >= data.data.length)
                {
                    break;
                }

                byte a = data.data[offset + j];
                byte b = data.data[offset + j + 1];
                float sample = a + (b << 8);

                maximum = Math.max(maximum, Math.abs(sample));
                average += Math.abs(sample);
                count++;
            }

            average /= count;
            average /= 0xffff / 2;
            maximum /= 0xffff / 2;

            this.average[i] = average;
            this.maximum[i] = maximum;
        }
    }

    public void delete()
    {
        for (WaveformSprite sprite : this.sprites)
        {
            GlStateManager.deleteTexture(sprite.texture);
        }

        this.sprites.clear();
    }

    public boolean isCreated()
    {
        return !this.sprites.isEmpty();
    }

    public int getPixelsPerSecond()
    {
        return this.pixelsPerSecond;
    }

    public int getWidth()
    {
        return this.w;
    }

    public int getHeight()
    {
        return this.h;
    }

    public List<WaveformSprite> getSprites()
    {
        return this.sprites;
    }

    public void draw(int x, int y, int u, int v, int w, int h)
    {
        draw(x, y, u, v, w, h, this.h);
    }

    /**
     * Draw the waveform out of multiple sprites of desired cropped region
     */
    public void draw(int x, int y, int u, int v, int w, int h, int height)
    {
        int offset = 0;

        for (WaveformSprite sprite : this.sprites)
        {
            int sw = sprite.width;
            offset += sw;

            if (w <= 0)
            {
                break;
            }

            if (u >= offset)
            {
                continue;
            }

            int so = offset - u;

            GlStateManager.bindTexture(sprite.texture);
            GuiDraw.drawBillboard(x, y, u, v, Math.min(w, so), h, sw, height);

            x += so;
            u += so;
            w -= so;
        }
    }

    @SideOnly(Side.CLIENT)
    public static class WaveformSprite
    {
        public final int texture;
        public final int width;

        public WaveformSprite(int texture, int width)
        {
            this.texture = texture;
            this.width = width;
        }
    }
}

==================================================

--- Файл №322 ---
Путь: main\java\mchorse\mclib\utils\wav\WavePlayer.java
--------------------
package mchorse.mclib.utils.wav;

import mchorse.mclib.utils.MathUtils;
import net.minecraft.client.renderer.GLAllocation;
import org.lwjgl.openal.AL10;
import org.lwjgl.openal.AL11;

import java.nio.ByteBuffer;

public class WavePlayer
{
    private int buffer = -1;
    private int source = -1;
    private float duration;

    public WavePlayer initialize(Wave wave)
    {
        this.buffer = AL10.alGenBuffers();
        ByteBuffer buffer = GLAllocation.createDirectByteBuffer(wave.data.length);

        buffer.put(wave.data);
        buffer.flip();

        AL10.alBufferData(this.buffer, wave.getALFormat(), buffer, wave.sampleRate);

        this.duration = wave.getDuration();
        this.source = AL10.alGenSources();
        AL10.alSourcei(this.source, AL10.AL_BUFFER, this.buffer);
        AL10.alSourcei(this.source, AL10.AL_SOURCE_RELATIVE, AL10.AL_TRUE);

        return this;
    }

    public void delete()
    {
        AL10.alDeleteBuffers(this.buffer);
        AL10.alDeleteSources(this.source);

        this.buffer = -1;
        this.source = -1;
    }

    public void play()
    {
        AL10.alSourcePlay(this.source);
    }

    public void pause()
    {
        AL10.alSourcePause(this.source);
    }

    public void stop()
    {
        AL10.alSourceStop(this.source);
    }

    public int getSourceState()
    {
        return AL10.alGetSourcei(this.source, AL10.AL_SOURCE_STATE);
    }

    public boolean isPlaying()
    {
        return this.getSourceState() == AL10.AL_PLAYING;
    }

    public boolean isPaused()
    {
        return this.getSourceState() == AL10.AL_PAUSED;
    }

    public boolean isStopped()
    {
        int state = this.getSourceState();

        return state == AL10.AL_STOPPED || state == AL10.AL_INITIAL;
    }

    public float getPlaybackPosition()
    {
        return AL10.alGetSourcef(this.source, AL11.AL_SEC_OFFSET);
    }

    /**
     * This method sets the playback position to the provided seconds.
     * It clamps the seconds between 0 and the duration of the audio file.
     * @param seconds seconds to set the playback position to
     */
    public void setPlaybackPosition(float seconds)
    {
        seconds = MathUtils.clamp(seconds, 0, this.duration);

        AL10.alSourcef(this.source, AL11.AL_SEC_OFFSET, seconds);
    }

    public int getBuffer()
    {
        return this.buffer;
    }

    public int getSource()
    {
        return this.source;
    }
}

==================================================

--- Файл №323 ---
Путь: main\java\mchorse\mclib\utils\wav\WaveReader.java
--------------------
package mchorse.mclib.utils.wav;

import mchorse.mclib.utils.binary.BinaryChunk;
import mchorse.mclib.utils.binary.BinaryReader;

import java.io.InputStream;

/**
 * @link http://soundfile.sapp.org/doc/WaveFormat/
 */
public class WaveReader extends BinaryReader
{
    public Wave read(InputStream stream) throws Exception
    {
        try
        {
            BinaryChunk main = this.readChunk(stream);

            if (!main.id.equals("RIFF"))
            {
                throw new Exception("Given file is not 'RIFF'! It's '" + main.id + "' instead...");
            }

            String format = this.readFourString(stream);

            if (!format.equals("WAVE"))
            {
                throw new Exception("Given RIFF file is not a 'WAVE' file! It's '" + format + "' instead...");
            }

            int audioFormat = -1;
            int numChannels = -1;
            int sampleRate = -1;
            int byteRate = -1;
            int blockAlign = -1;
            int bitsPerSample = -1;
            byte[] data = null;

            int read = 0;

            while (read < 2)
            {
                BinaryChunk chunk = this.readChunk(stream);

                if (chunk.id.equals("fmt "))
                {
                    audioFormat = this.readShort(stream);
                    numChannels = this.readShort(stream);

                    sampleRate = this.readInt(stream);
                    byteRate = this.readInt(stream);

                    blockAlign = this.readShort(stream);
                    bitsPerSample = this.readShort(stream);

                    /* Discarding extra data */
                    if (chunk.size > 16)
                    {
                        stream.skip(chunk.size - 16);
                    }

                    read++;
                }
                else if (chunk.id.equals("data"))
                {
                    data = new byte[chunk.size];
                    stream.read(data);
                    read++;
                }
                else
                {
                    this.skip(stream, chunk.size);
                }
            }

            stream.close();

            return new Wave(audioFormat, numChannels, sampleRate, byteRate, blockAlign, bitsPerSample, data);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }

        return null;
    }

    public BinaryChunk readChunk(InputStream stream) throws Exception
    {
        String id = this.readFourString(stream);
        int size = this.readInt(stream);

        return new BinaryChunk(id, size);
    }
}

==================================================

--- Файл №324 ---
Путь: main\resources\mcmod.info
--------------------
[
    {
        "modid": "mclib",
        "name": "McLib",
        "description": "McHorse's library mod",
        "version": "${version}",
        "mcversion": "${mcversion}",
        "url": "https://www.curseforge.com/minecraft/mc-mods/mchorses-mclib/",
        "updateJSON": "https://raw.githubusercontent.com/mchorse/mclib/1.12/version.json",
        "authorList": ["mchorse"],
        "credits": "Ernio for networking code I still use to this day!"
    }
]

==================================================

--- Файл №325 ---
Путь: main\resources\assets\mclib\lang\en_US.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=Dashboard

mclib.gui.ok=Ok
mclib.gui.cancel=Cancel
mclib.gui.none=(none)
mclib.gui.multi_skin=Multi-skin
mclib.gui.no_data=No data available...
mclib.gui.open_folder=Open folder
mclib.gui.pick_texture=Pick texture

mclib.gui.context.multi_skin.copy=Copy texture location
mclib.gui.context.multi_skin.paste=Paste copied texture location

# Don't remove space on the end!
mclib.gui.dashboard.category=Dashboard
mclib.gui.dashboard.open_panel=Open 

mclib.gui.graph.tooltip=Graphing calculator
mclib.gui.graph.help=Click on this button to go to a web page which documents features of following graphing calculator.\n\nExpressions used here, can be also used in Aperture's math modifier and Commander's math expression evaluation within commands.\n\nThis graphing calculator provides only one variable "x" which is horizontal coordinate you can plug in into y=x (aka f(x)) graph functions.
mclib.gui.config.title=Configuration
mclib.gui.config.tooltip=Mods configuration
mclib.gui.config.reload_tooltip=Reload configuration from file...
mclib.gui.config.request_tooltip=Switch between server and client side configuration...
mclib.gui.keys.list=Keybinds list

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.orientation.global=Global
mclib.gui.transforms.orientation.local=Local
mclib.gui.transforms.orientation.tooltip=How the translation axes should be aligned.
mclib.gui.transforms.translate=Translate
mclib.gui.transforms.scale=Scale
mclib.gui.transforms.rotate=Rotate
mclib.gui.transforms.context.copy=Copy transformations
mclib.gui.transforms.context.paste=Paste transformations
mclib.gui.transforms.context.paste_translation=Paste translation
mclib.gui.transforms.context.paste_scale=Paste scale
mclib.gui.transforms.context.paste_rotation=Paste rotation
mclib.gui.transforms.context.reset=Reset transformation
mclib.gui.transforms.delta.origin=Around the origin

mclib.gui.keyframes.tick=Tick
mclib.gui.keyframes.value=Value
mclib.gui.keyframes.context.maximize=View all keyframes
mclib.gui.keyframes.context.select_all=Select all
mclib.gui.keyframes.context.remove=Remove keyframe(s)
mclib.gui.keyframes.context.copy=Copy keyframes
mclib.gui.keyframes.context.paste=Paste copied keyframes
mclib.gui.keyframes.context.to_left=Switch to left handles
mclib.gui.keyframes.context.to_main=Switch to main handles
mclib.gui.keyframes.context.to_right=Switch to right handles

mclib.gui.multiskin.color=With this color element, you can adjust color (RGB) channels. It works best with white/grayscale images.
mclib.gui.multiskin.scale=Scale
mclib.gui.multiskin.scale_to_largest=Scale to largest
mclib.gui.multiskin.shift=Shift
mclib.gui.multiskin.pixelate=Pixelate
mclib.gui.multiskin.erase=Erase
mclib.gui.multiskin.erase_tooltip=This feature allows to using current skin as difference mask, meaning, any opaque pixels will erase pixels of all skins underneath it.
mclib.gui.multiskin.custom_size=Custom size
mclib.gui.multiskin.auto_size=Auto size
mclib.gui.multiskin.auto_size_tooltip=When enabled, it will use texture's original size, otherwise custom size provided below. 
mclib.gui.multiskin.size_w=Custom width
mclib.gui.multiskin.size_h=Custom height

mclib.gui.color.favorite=Favorite colors
mclib.gui.color.recent=Recent colors

mclib.gui.color.context.favorites.add=Add to favorites
mclib.gui.color.context.favorites.remove=Remove from favorites

mclib.gui.item_slot.context.copy=Copy item's NBT
mclib.gui.item_slot.context.paste=Paste item NBT
mclib.gui.item_slot.context.drop=Drop the item down
mclib.gui.item_slot.context.clear=Clear the item

# Config
mclib.config.title=McLib

mclib.config.appearance.title=Appearance
mclib.config.appearance.tooltip=General options regarding appearance of GUIs and the framework

mclib.config.appearance.primary_color=Primary color
mclib.config.comments.appearance.primary_color=The color which is used everywhere in the GUI system
mclib.config.appearance.enable_borders=Button borders
mclib.config.comments.appearance.enable_borders=Should buttons and other elements have borders?
mclib.config.appearance.enable_checkbox_rendering=Check boxes
mclib.config.comments.appearance.enable_checkbox_rendering=Enable check box rendering instead of toggle element (matter of the taste)
mclib.config.appearance.enable_trackpad_increments=Trackpad increments
mclib.config.comments.appearance.enable_trackpad_increments=Enable < and > buttons on the trackpad field (which increment the trackpad value)
mclib.config.appearance.enable_grid_rendering=Model grid
mclib.config.comments.appearance.enable_grid_rendering=Enable grid rendering instead of the ground grass block
mclib.config.appearance.user_interface_scale=GUI scale
mclib.config.comments.appearance.user_interface_scale=GUI scale for McHorse's mods instead of Video Settings' GUI scale. If set to 0, it will use Minecraft's GUI scale setting
mclib.config.appearance.render_translation_text_colours=Render translation text colours
mclib.config.comments.appearance.render_translation_text_colours=Render the respective axis colour for the translation fields, e.g. x is red, y is green and z is blue.
mclib.config.appearance.tooltip_style=Tooltip style
mclib.config.comments.appearance.tooltip_style=This option allows to change GUI tooltip style
mclib.config.appearance.trackpad_decimal_places=Trackpad decimal places
mclib.config.comments.appearance.trackpad_decimal_places=Set how many decimal places should not be rounded

mclib.config.tutorials.title=Tutorials options
mclib.config.tutorials.tooltip=This category provides options which are useful for making tutorial videos

mclib.config.tutorials.enable_mouse_rendering=Mouse cursor
mclib.config.comments.tutorials.enable_mouse_rendering=Enable rendering of the mouse cursor. It's very useful for tutorials when they're recorded with Minema mod and the cursor isn't visible
mclib.config.tutorials.enable_mouse_buttons_rendering=Mouse buttons
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=Enable rendering of the mouse button presses and mouse wheel scrolling. It's very useful for tutorials when they're recorded with Minema mod and mouse button presses or wheel scrolling are not visible
mclib.config.tutorials.enable_keystrokes_rendering=Keystrokes
mclib.config.comments.tutorials.enable_keystrokes_rendering=Enable rendering of the keystrokes. It's very useful for tutorials when to show which keys are being pressed
mclib.config.tutorials.keystroke_offset=Keystrokes offset
mclib.config.comments.tutorials.keystroke_offset=Allows to configure how many pixels away from the corner the keystroke line would be drawn
mclib.config.tutorials.keystroke_position=Keystrokes position
mclib.config.comments.tutorials.keystroke_position=Allows to change the corner of the keystroke line 

mclib.config.background.title=Background
mclib.config.background.tooltip=Background options like color and texture to be used

mclib.config.background.image=Image
mclib.config.comments.background.image=Background image to be used in every menu
mclib.config.background.color=Color
mclib.config.comments.background.color=Background color to be used in every menu. If image is specified, then this will be used as tinting color for background

mclib.config.scrollbars.title=Scrollbars
mclib.config.scrollbars.tooltip=Style options for scrollbars

mclib.config.scrollbars.flat=Flat scrollbars
mclib.config.comments.scrollbars.flat=Return the looks of flat colored scrollbars
mclib.config.scrollbars.shadow=Shadow color
mclib.config.comments.scrollbars.shadow=Allows you to set shadow color of scrollbars
mclib.config.scrollbars.width=Thickness
mclib.config.comments.scrollbars.width=Allows you to setup the thickness (width of scrollbars)

mclib.config.multiskin.title=Multi-skin
mclib.config.multiskin.tooltip=Options regarding Multi-skin feature

mclib.config.multiskin.multithreaded=Multi-threaded processing
mclib.config.comments.multiskin.multithreaded=Allows you to toggle multi-threaded processing of multi-skins, which should fix the lag at cost of longer processing
mclib.config.multiskin.clear=Clear upon RPs reloading
mclib.config.comments.multiskin.clear=Allows you to toggle deleting all multi-skin textures during resource pack reloading

mclib.config.vanilla.title=Vanilla tweaks
mclib.config.vanilla.tooltip=Options regarding to tweaks done to Minecraft's code

mclib.config.vanilla.max_packet_size=Max. packet size
mclib.config.comments.vanilla.max_packet_size=Allows you to configure the maximum size (in bytes) of a modded packet. Warning: don't change this value for public servers, as it will allow to DDoS server much easier. This option is designed for singleplayer!

# OP access
op_access.config.title=OP Access

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=McLib's OP access options

op_access.config.mclib.drop_items=Drop items
op_access.config.comments.mclib.drop_items=Can non-OP players use drop items option of item stack slot element?

# Keybinds config
keybinds.config.title=Keybinds

keybinds.config.unknown_mod=Unknown mod
keybinds.config.no_category=No category

# Interpolations
mclib.interpolations.linear=Linear
mclib.interpolations.quad_in=Quadratic In
mclib.interpolations.quad_out=Quadratic Out
mclib.interpolations.quad_inout=Quadratic In/out
mclib.interpolations.cubic_in=Cubic In
mclib.interpolations.cubic_out=Cubic Out
mclib.interpolations.cubic_inout=Cubic In/out
mclib.interpolations.exp_in=Exponential In
mclib.interpolations.exp_out=Exponential Out
mclib.interpolations.exp_inout=Exponential In/out

mclib.interpolations.back_in=Back In
mclib.interpolations.back_out=Back Out
mclib.interpolations.back_inout=Back In/out
mclib.interpolations.elastic_in=Elastic In
mclib.interpolations.elastic_out=Elastic Out
mclib.interpolations.elastic_inout=Elastic In/out
mclib.interpolations.bounce_in=Bounce In
mclib.interpolations.bounce_out=Bounce Out
mclib.interpolations.bounce_inout=Bounce In/out

mclib.interpolations.sine_in=Sine In
mclib.interpolations.sine_out=Sine Out
mclib.interpolations.sine_inout=Sine In/out
mclib.interpolations.quart_in=Quartic In
mclib.interpolations.quart_out=Quartic Out
mclib.interpolations.quart_inout=Quartic In/out
mclib.interpolations.quint_in=Quintic In
mclib.interpolations.quint_out=Quintic Out
mclib.interpolations.quint_inout=Quintic In/out
mclib.interpolations.circle_in=Circle In
mclib.interpolations.circle_out=Circle Out
mclib.interpolations.circle_inout=Circle In/out

mclib.interpolations.const=Constant
mclib.interpolations.quad=Quadratic
mclib.interpolations.cubic=Cubic
mclib.interpolations.hermite=Hermite
mclib.interpolations.exp=Exponential
mclib.interpolations.bezier=Bezier
mclib.interpolations.back=Back
mclib.interpolations.elastic=Elastic
mclib.interpolations.bounce=Bounce
mclib.interpolations.sine=Sine
mclib.interpolations.quart=Quartic
mclib.interpolations.quint=Quintic
mclib.interpolations.circle=Circle

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=This interpolation goes at constant speed from A to B. It's useful for seamless rotations and slow movement.
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=It's most useful for pose animation denoting an even more lazier degree of movement than Exponential or Cubic In/out.
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=It's most useful for pose animation denoting a more lazier movement than Exponential In/out.
mclib.interpolations.tooltips.exp_in=It's useful for cameras in combination with Exponential Out, as you can create jumpy, spike-like, transition between two camera shots.
mclib.interpolations.tooltips.exp_out=It's useful for creating rapid movement.
mclib.interpolations.tooltips.exp_inout=It's most useful for pose animation or camera emphasis.

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=It can be used for swaying and natural pose animation movement.
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=It's useful for jumpy cartoon movements.
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=It's useful for creating an animation of something falling on the ground and bouncing a couple of times.
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=This interpolation doesn't interpolate, but rather keeps the initial value till the end. It's useful for creating sharp steps using multiple keyframes.
mclib.interpolations.tooltips.hermite=This interpolation that can smooth animation across multiple keyframes. Make sure that you have same distance between keyframes, as its smoothness breaks with variable distance.
mclib.interpolations.tooltips.bezier=This interpolation allows customize the curve using control points, which allows also mimicking majority of other interpolations. It's useful for creating smoother transition between multiple keyframes.

mclib.easing.in=Ease in
mclib.easing.out=Ease out
mclib.easing.inout=Ease in/out

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=McLib command which features config editing capabilities on the server side.
mclib.commands.mclib.config.help=McLib config subcommand allows to manage mod options from McHorse's mods.
mclib.commands.mclib.config.print=§fThis command prints the current value of given mod option by §7<mod.category.option>§f ID.
mclib.commands.mclib.config.set=§fThis command sets current value of given mod option by §7<mod.category.option>§f ID to §7<value...>§f.
mclib.commands.cheats=Cheat command allows to toggle cheat commands in a singleplayer world.\n\nIt can be used either to disable cheats in a creative world with commands enabled, let's say you are publishing an adventure map, or enable commands in a downloaded world in which cheat commands are disabled, because you need to use commands for a video.

mclib.error.config.invalid_id=§fGiven mod option identifier %s§f is invalid!
mclib.error.config.invalid_format=§fGiven value %s§f for mod option identifier %s§f can't be parsed!
mclib.info.config.set=§fThe new value of mod option %s§f is: %s§f
mclib.info.config.print=§fThe value of mod option %s§f is: %s§f
mclib.info.config.client_side=§fGiven mod option %s§f is client side only...

# Keystroke modes
mclib.keystrokes_position.auto=Auto
mclib.keystrokes_position.bottom_left=Bottom left
mclib.keystrokes_position.bottom_right=Bottom right
mclib.keystrokes_position.top_right=Top right
mclib.keystrokes_position.top_left=Top left

# Tootlip styles
mclib.tooltip_style.light=Light
mclib.tooltip_style.dark=Dark

==================================================

--- Файл №326 ---
Путь: main\resources\assets\mclib\lang\es_ES.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=Tablero

mclib.gui.ok=Ok
mclib.gui.cancel=Cancelar
mclib.gui.none=(ninguno)
mclib.gui.multi_skin=Skin múltiple
mclib.gui.no_data=Datos no disponibles...
mclib.gui.open_folder=Abrir carpeta
mclib.gui.pick_texture=Seleccionar textura

mclib.gui.context.multi_skin.copy=Copiar ubicación de textura
mclib.gui.context.multi_skin.paste=Pegar localización de textura

# Don't remove space on the end!
mclib.gui.dashboard.category=Tablero
mclib.gui.dashboard.open_panel=Abrir 

mclib.gui.graph.tooltip=Graphing calculator
mclib.gui.graph.help=Clic en este botón para ir a una página web que documenta las características de la siguiente calculadora gráfica.\n\nExpressions used here, también puede ser usada en el modificador matemático de Aperture en la evaluación de expresiones matemáticas de Commander dentro de los comandos.\n\nEsta calculadora gráfica proporciona solo una variable "x" que es una coordenada horizontal en la que puedes conectarte y=x (aka f(x))funciones gráficas.
mclib.gui.config.title=Configuración
mclib.gui.config.tooltip=Configuración de los mods
mclib.gui.config.reload_tooltip=Actualizar configuración desde el archivo...
mclib.gui.config.request_tooltip=Cambiar entre la configuración del lado del servidor y del cliente...
mclib.gui.keys.list=Lista de combinación de teclas

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.translate=Trasladar
mclib.gui.transforms.scale=Escala
mclib.gui.transforms.rotate=Rotar
mclib.gui.transforms.context.copy=Copiar transformaciones
mclib.gui.transforms.context.paste=Pegar transformaciones
mclib.gui.transforms.context.paste_translation=Pegar traslación
mclib.gui.transforms.context.paste_scale=Pegar escala
mclib.gui.transforms.context.paste_rotation=Pegar rotación
mclib.gui.transforms.context.reset=Reiniciar transformación

mclib.gui.keyframes.tick=Tick
mclib.gui.keyframes.value=Valor
mclib.gui.keyframes.context.maximize=Ver todos los fotogramas claves
mclib.gui.keyframes.context.select_all=Seleccionar todos
mclib.gui.keyframes.context.remove=Remover fotograma clave (s)
mclib.gui.keyframes.context.copy=Copiar fotogramas claves
mclib.gui.keyframes.context.paste=Pegar fotogramas claves
mclib.gui.keyframes.context.to_left=Cambiar a palancas izquierdas
mclib.gui.keyframes.context.to_main=Cambiar a palancas principales
mclib.gui.keyframes.context.to_right=Cambiar a palancas derechas

mclib.gui.multiskin.color=Con este elemento de color, puede ajustar los canales de color (RGB). Funciona mejor con imágenes en blanco/escala de grises.
mclib.gui.multiskin.scale=Escala
mclib.gui.multiskin.scale_to_largest=Escalar al más grande
mclib.gui.multiskin.shift=Cambio
mclib.gui.multiskin.pixelate=Pixelar
mclib.gui.multiskin.erase=Borrar
mclib.gui.multiskin.erase_tooltip=Esta función permite usar la máscara actual como máscara de diferencia, lo que significa que cualquier píxel opaco borrará los píxeles de todas las máscaras que se encuentran debajo.
mclib.gui.multiskin.custom_size=Tamaño personalizado
mclib.gui.multiskin.auto_size=Tamaño automático
mclib.gui.multiskin.auto_size_tooltip=Cuando está habilitado, utilizará el tamaño original de la textura; de lo contrario, el tamaño personalizado se proporciona a continuación. 
mclib.gui.multiskin.size_w=Ancho personalizado
mclib.gui.multiskin.size_h=Altura personalizada

mclib.gui.color.favorite=Colores favoritos
mclib.gui.color.recent=Colores recientes

mclib.gui.color.context.favorites.add=Agregar a fovaritos
mclib.gui.color.context.favorites.remove=Eliminar de favoritos

mclib.gui.item_slot.context.copy=Copiar NBT del artículo
mclib.gui.item_slot.context.paste=Pegar elemento NBT
mclib.gui.item_slot.context.drop=Soltar el ítem
mclib.gui.item_slot.context.clear=Borrar el ítem

# Config
mclib.config.title=McLib

mclib.config.appearance.title=Apariencia
mclib.config.appearance.tooltip=Opciones generales con respecto a la apariencia de las GUIs y la estructura

mclib.config.appearance.primary_color=Color principal
mclib.config.comments.appearance.primary_color=El color que es usado en todo el sistema de la GUI
mclib.config.appearance.enable_borders=Activar los bordes de los botones
mclib.config.comments.appearance.enable_borders=¿Los botones y otros elementos deberían tener bordes?
mclib.config.appearance.enable_checkbox_rendering=Activar Casillas de verificación
mclib.config.comments.appearance.enable_checkbox_rendering=Activa la visualización de Casillas de verificación en lugar de Alternar el elemento (según el gusto de cada usuario)
mclib.config.appearance.enable_trackpad_increments=Incrementa el trackpad
mclib.config.comments.appearance.enable_trackpad_increments=Activa < and > los botones en el campo trackpad (lo cual incrementa el valor del trackpad)
mclib.config.appearance.enable_grid_rendering=Activar Piso de cuadrículas
mclib.config.comments.appearance.enable_grid_rendering=Activa la visualización de cuadrículas en lugar de un bloque de césped
mclib.config.appearance.user_interface_scale=Escala de la GUI
mclib.config.comments.appearance.user_interface_scale=Escala de la GUI para los mods de McHorse en lugar de la escala de la GUI de la Configuración de video. Si se establece en 0, utilizará la configuración de escala de la GUI de Minecraft
mclib.config.appearance.tooltip_style=Estilo de información sobre herramientas
mclib.config.comments.appearance.tooltip_style=Esta opción permite cambiar el estilo de información sobre herramientas de la GUI

mclib.config.tutorials.title=Opciones para los tutoriales
mclib.config.tutorials.tooltip=Esta categoría proporciona opciones que son útiles para hacer videos tutoriales

mclib.config.tutorials.enable_mouse_rendering=Activar visualización del cursor del mouse
mclib.config.comments.tutorials.enable_mouse_rendering=Activa la representación del cursor del mouse. Es muy útil cuando no aparece el cursor del mouse mientras se graban tutoriales con el mod Minema
mclib.config.tutorials.enable_mouse_buttons_rendering=Botones del mouse
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=Habilita la visualización de los clics del del mouse y el desplazamiento de la rueda. Es muy útil para los tutoriales cuando se graban con Minema mod.
mclib.config.tutorials.enable_keystrokes_rendering=Activar Pulsaciones de teclas
mclib.config.comments.tutorials.enable_keystrokes_rendering=Activa la visualización de las pulsaciones de las teclas. Es muy útil cuando se quiere mostrar en un tutorial las teclas que se estén usando
mclib.config.tutorials.keystroke_offset=Desplazamiento de Pulsaciones de teclas
mclib.config.comments.tutorials.keystroke_offset=Permite configurar a cuántos píxeles de la esquina se dibujará la línea de pulsación
mclib.config.tutorials.keystroke_position=Posición de las pulsaciones de teclas
mclib.config.comments.tutorials.keystroke_position= Permite cambiar la esquina de la línea de las pulsaciones de teclas

mclib.config.background.title=Fondo
mclib.config.background.tooltip=Opciones de fondo, ej: Color y texturas que se usarán

mclib.config.background.image=Imagen
mclib.config.comments.background.image=Imagen de fondo que se usará en cada menú
mclib.config.background.color=Color
mclib.config.comments.background.color=Color de fondo que se usará en cada menú. Si se especifica una imagen se utilizará como color de tinte para el fondo

mclib.config.scrollbars.title=Barras de desplazamiento
mclib.config.scrollbars.tooltip=Opciones de fondo, ej: Color y texturas que se usarán

mclib.config.scrollbars.flat=Barras de desplazamiento planas
mclib.config.comments.scrollbars.flat=Cambia a simple el aspecto de las Barras de desplazamiento
mclib.config.scrollbars.shadow=Color de la sombra
mclib.config.comments.scrollbars.shadow=Permite establecer el color de las sombra de las barras desplazamiento
mclib.config.scrollbars.width=Grosor
mclib.config.comments.scrollbars.width=Permite configurar el grosor (ancho de las barras de desplazamiento)

mclib.config.multiskin.title=Multi-skin
mclib.config.multiskin.tooltip=Opciones relacionadas con la función Multi-skin

mclib.config.multiskin.multithreaded=Procesamiento de subprocesos múltiples
mclib.config.comments.multiskin.multithreaded=Le permite alternar el procesamiento de subprocesos múltiples de máscaras múltiples, lo que debería corregir el retraso a costa de un procesamiento más largo
mclib.config.multiskin.clear=Eliminar al recargar RP
mclib.config.comments.multiskin.clear=Permite alternar la eliminación de todas las texturas multi-skin durante la recarga del paquete de recursos

mclib.config.vanilla.title=Ajustes de Minecraft Vanilla
mclib.config.vanilla.tooltip=Opciones con respecto a los ajustes realizados al código de Minecraft

mclib.config.vanilla.max_packet_size=Tamaño máximo del paquete
mclib.config.comments.vanilla.max_packet_size=Permite configurar el tamaño máximo (en bytes) de un paquete del mod. Advertencia: No cambiar este valor para servidores públicos, puesto que va a permitir hacer ataques DDoS con mucha más facilidad. Esta opción está diseñada para un jugador!

# OP access
op_access.config.title=Acceso OP

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=Opciones de acceso OP de McLib

op_access.config.mclib.drop_items=Soltar ítems
op_access.config.comments.mclib.drop_items=¿Pueden los jugadores que no son OP usar la opción de soltar elementos del elemento de ranura de pila de elementos?

# Interpolations
mclib.interpolations.linear=Lineal
mclib.interpolations.quad_in=Cuadrático hacia dentro
mclib.interpolations.quad_out=Cuadrático hacia fuera
mclib.interpolations.quad_inout=Cuadrático hacia dentro/fuera
mclib.interpolations.cubic_in=Cúbico hacia dentro
mclib.interpolations.cubic_out=Cúbico hacia dentro
mclib.interpolations.cubic_inout=Cúbico hacia dentro/fuera
mclib.interpolations.exp_in=Exponencial hacia dentro
mclib.interpolations.exp_out=Exponencial hacia fuera
mclib.interpolations.exp_inout=Exponencial hacia dentro/fuera

mclib.interpolations.back_in=Atrás hacia adentro
mclib.interpolations.back_out=Atrás hacia afuera
mclib.interpolations.back_inout=Atrás hacia adentro/afuera
mclib.interpolations.elastic_in=Elástico hacia adentro
mclib.interpolations.elastic_out=Elástico hacia afuera
mclib.interpolations.elastic_inout=Elástico hacia adentro/afuera
mclib.interpolations.bounce_in=Rebotar hacia adentro
mclib.interpolations.bounce_out=Rebotar hacia afuera
mclib.interpolations.bounce_inout=Rebotar hacia adentro/afuera

mclib.interpolations.const=Constante
mclib.interpolations.quad=Cuadrático
mclib.interpolations.cubic=Cúbico
mclib.interpolations.hermite=Hermite
mclib.interpolations.exp=Exponencial
mclib.interpolations.bezier=Bezier
mclib.interpolations.back=Atrás
mclib.interpolations.elastic=Elástico
mclib.interpolations.bounce=Rebotar

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=Esta interpolación va a una velocidad constante de A a B. Es útil para rotaciones continuas y movimientos lentos.
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=Es más útil para la animación de poses que denota un grado de movimiento aún más perezoso que Exponencial o Cúbico Adentro/afuera.
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=Es más útil para la animación de poses que denota un movimiento más perezoso que la entrada/salida exponencial.
mclib.interpolations.tooltips.exp_in=Es útil para las cámaras en combinación con Exponencia hacia afuera, ya que puede crear una transición con saltos, similar a un pico, entre dos tomas de cámara.
mclib.interpolations.tooltips.exp_out=Es útil para crear movimientos rápidos..
mclib.interpolations.tooltips.exp_inout=Es más útil para la animación de poses o el énfasis de la cámara.

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=Se puede utilizar para balanceo y movimiento de animación de pose natural.
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=Es útil para movimientos de dibujos animados nerviosos.
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=Es útil para crear una animación de algo que cae al suelo y rebota un par de veces.
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.const=Esta interpolación no interpola, sino que mantiene el valor inicial hasta el final. Es útil para crear pasos nítidos utilizando varios fotogramas clave.
mclib.interpolations.tooltips.hermite=Esta interpolación puede suavizar la animación en varios fotogramas clave. Asegúrese de tener la misma distancia entre fotogramas clave, ya que su suavidad se rompe con la distancia variable.
mclib.interpolations.tooltips.bezier=Esta interpolación permite personalizar la curva usando puntos de control, lo que también permite imitar la mayoría de otras interpolaciones. Es útil para crear una transición más suave entre varios fotogramas clave.

mclib.easing.in=Ease dentro
mclib.easing.out=Ease fuera
mclib.easing.inout=Ease dentro/fuera

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=Comando de McLib que presenta capacidades de edición de configuración en el lado del servidor.
mclib.commands.mclib.config.help=El subcomando McLib config permite administrar las opciones de modificación de las modificaciones de McHorse.
mclib.commands.mclib.config.print=§fEste comando imprime el valor actual de la opción del mod dada por §7<mod.category.option>§f ID.
mclib.commands.mclib.config.set=§fEste comando estabelece el valor actual del mod dado por §7<mod.category.option>§f ID to §7<value...>§f.
mclib.commands.cheats=El comando de trucos permite alternar los comandos de trucos en un mundo de un solo jugador.\n\nSe puede usar para deshabilitar trucos en un mundo creativo con comandos habilitados, digamos que está publicando un mapa de aventuras, o para habilitar comandos en un mundo descargado en el que los comandos de trucos están deshabilitados, porque necesita usar comandos para un video.

mclib.error.config.invalid_id=§fIdentificador de opción de mod dado %s§f es inválido!
mclib.error.config.invalid_format=§fValor dado %s§f para el identificador del mod %s§f no puede ser analizado!
mclib.info.config.set=§fEl nuevo valor del mod dado %s§f es: %s§f
mclib.info.config.print=§fEl valor del mod dado %s§f es: %s§f
mclib.info.config.client_side=§fEl valor del mod dado %s§f es solo del lado del cliente...

# Keystroke modes
mclib.keystrokes_position.auto=Automático
mclib.keystrokes_position.bottom_left=Abajo a la izquierda
mclib.keystrokes_position.bottom_right=Abajo a la derecha
mclib.keystrokes_position.top_right=Parte superior derecha
mclib.keystrokes_position.top_left=Parte superior izquierda

# Tootlip styles
mclib.tooltip_style.light=Claro
mclib.tooltip_style.dark=Oscuro


==================================================

--- Файл №327 ---
Путь: main\resources\assets\mclib\lang\fr_FR.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=Tableau de bord

mclib.gui.ok=Ok
mclib.gui.cancel=Annuler
mclib.gui.none=(nul)
mclib.gui.multi_skin=Multi-skin
mclib.gui.no_data=Aucune donnée disponible...
mclib.gui.open_folder=Ouvrir le dossier
mclib.gui.pick_texture=Choisir les textures

mclib.gui.context.multi_skin.copy=Copier le chemin de la texture
mclib.gui.context.multi_skin.paste=Coller le chemin de la texture copiée

# Don't remove space on the end!
mclib.gui.dashboard.category=Tableau de bord
mclib.gui.dashboard.open_panel=Ouvrir 

mclib.gui.graph.tooltip=Calculatrice graphique
mclib.gui.graph.help=Cliquez sur ce bouton pour accéder à une page Web qui documente les caractéristiques de la calculatrice graphique suivante.\n\nLes expressions utilisées ici peuvent également être utilisées dans le modifieur mathématique d’Aperture et dans l’évaluation de l’expression mathématique de Commander dans les commandes.\n\nCette calculatrice graphique ne fournit qu’une seule variable "x" qui est une coordonnée horizontale que vous pouvez insérer dans les fonctions graphiques y=x (aka f(x)).
mclib.gui.config.title=Configuration
mclib.gui.config.tooltip=Configuration des mods
mclib.gui.config.reload_tooltip=Recharger les configurations depuis le fichier...
mclib.gui.config.request_tooltip=Changer entre les configurations côté client et serveur...
mclib.gui.keys.list=Liste des raccourcis clavier

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.translate=Translater
mclib.gui.transforms.scale=Redimensionner
mclib.gui.transforms.rotate=Pivoter
mclib.gui.transforms.context.copy=Copier les transformations
mclib.gui.transforms.context.paste=Coller les transformations
mclib.gui.transforms.context.paste_translation=Coller la translation
mclib.gui.transforms.context.paste_scale=Coller la taille
mclib.gui.transforms.context.paste_rotation=Coller la rotation
mclib.gui.transforms.context.reset=Réinitialiser les transformations
mclib.gui.transforms.delta.origin=Autour de l'origine

mclib.gui.keyframes.tick=Tick
mclib.gui.keyframes.value=Valeur
mclib.gui.keyframes.context.maximize=Voir toutes les keyframes
mclib.gui.keyframes.context.select_all=Sélectionner tout
mclib.gui.keyframes.context.remove=Retirer la/les keyframe(s)
mclib.gui.keyframes.context.copy=Copier les keyframes
mclib.gui.keyframes.context.paste=Coller les keyframes copiées
#Not sure for the next three
mclib.gui.keyframes.context.to_left=Passer aux commandes de gauche
mclib.gui.keyframes.context.to_main=Passer aux commandes principales
mclib.gui.keyframes.context.to_right=Passer aux commandes de droite

mclib.gui.multiskin.color=Avec cet élément de couleur, vous pouvez ajuster les canaux de couleur (RVB). Cela fonctionne mieux avec des images blanches ou de teintes de gris.
mclib.gui.multiskin.scale=Redimensionner
mclib.gui.multiskin.scale_to_largest=Redimensionner vers le plus grand
mclib.gui.multiskin.shift=Décaler
mclib.gui.multiskin.pixelate=Pixeliser
mclib.gui.multiskin.erase=Effacer
mclib.gui.multiskin.erase_tooltip=Cette fonctionnalité vous permet d'utiliser le skin actuel comme masque de différence, c'est-à-dire que tous les pixels opaques vont effacer les pixels de tous les skins en-dessous.
mclib.gui.multiskin.custom_size=Taille personnalisée
mclib.gui.multiskin.auto_size=Taille automatique
mclib.gui.multiskin.auto_size_tooltip=Lorsque cette fonctionnalité est activée, la taille originale de la texture sera utilisée, sinon ce taille personnalisée fournie ci-dessous qui sera utilisée. 
mclib.gui.multiskin.size_w=Largeur personnalisée
mclib.gui.multiskin.size_h=Hauteur personnalisée

mclib.gui.color.favorite=Couleurs favorites
mclib.gui.color.recent=Couleurs récentes

mclib.gui.color.context.favorites.add=Aujouter aux favoris
mclib.gui.color.context.favorites.remove=Retirer des favoris

mclib.gui.item_slot.context.copy=Copier le NBT de l'item
mclib.gui.item_slot.context.paste=Coller le NBT de l'item
mclib.gui.item_slot.context.drop=Lâcher l'item
mclib.gui.item_slot.context.clear=Retirer l'item

# Config
mclib.config.title=McLib

mclib.config.appearance.title=Apparence
mclib.config.appearance.tooltip=Les options générales en rapport avec l'apparence de l'interface et du cadre

mclib.config.appearance.primary_color=Couleur primaire
mclib.config.comments.appearance.primary_color=La couleur utilisée partout pour le système d'interface
mclib.config.appearance.enable_borders=Bordure des boutons
mclib.config.comments.appearance.enable_borders=Est-ce que les boutons et les autres éléments doivent avoir des bordures ?
mclib.config.appearance.enable_checkbox_rendering=Cases à cocher
mclib.config.comments.appearance.enable_checkbox_rendering=Active le rendu de cases à cocher au lieu d'interrupteurs (dépend du goût)
mclib.config.appearance.enable_trackpad_increments=Incréments des champs de valeurs
mclib.config.comments.appearance.enable_trackpad_increments=Active les boutons < et > des champs de valeurs (qui incrémentent la valeur)
mclib.config.appearance.enable_grid_rendering=Grille de modèle
mclib.config.comments.appearance.enable_grid_rendering=Active le rendu d'une grille au lieu des blocks d'herbe
mclib.config.appearance.user_interface_scale=Taille de l'interface
mclib.config.comments.appearance.user_interface_scale=Taille de l'interface pour les mods de McHorse au lieu de la taille de l'interface dans les paramètres graphiques. Si mis à 0, la taille de l'interface de Minecraft sera utilisée
mclib.config.appearance.tooltip_style=Style des infobulles
mclib.config.comments.appearance.tooltip_style=Cette option permet de changer le syle des infobulles de l'interface
mclib.config.appearance.trackpad_decimal_places=Place des décimales dans les champs de valeurs
mclib.config.comments.appearance.trackpad_decimal_places=Sélectionne combien de nombres après la virgule ne devraient pas être arrondis (précision)

mclib.config.tutorials.title=Options pour les tutoriels
mclib.config.tutorials.tooltip=Cette catégorie présente des option utiles pour la réalisation de tutoriels vidéo

mclib.config.tutorials.enable_mouse_rendering=Curseur de souris
mclib.config.comments.tutorials.enable_mouse_rendering=Active le rendu du curseur de la souris. C'est très utile pour les tutoriels quand ils sont enregistrés avec le mod Minema et que le curseur n'est pas visible
mclib.config.tutorials.enable_mouse_buttons_rendering=Boutons de souris
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=Active le rendu des boutons de la souris pressés et de la molette. C'est très utile pour les tutoriels quand ils sont enregistrés avec le mod Minema et que les appuis sur les boutons ou que le défilement avec la molette ne sont pas visibles
mclib.config.tutorials.enable_keystrokes_rendering=Frappes au clavier
mclib.config.comments.tutorials.enable_keystrokes_rendering=Active le rendu des frappes au clavier. C'est très utile pour les tutoriels pour montrer quelles touches sont pressées
mclib.config.tutorials.keystroke_offset=Décalage des frappes au clavier
mclib.config.comments.tutorials.keystroke_offset=Permet de configurer à combien de pixels du coin de l'écran les frappes au clavier devraient s'afficher
mclib.config.tutorials.keystroke_position=Position des frappes au clavier
mclib.config.comments.tutorials.keystroke_position=Permet de changer le coin d'affichage des frappes au clavier 

mclib.config.background.title=Fond d'écran
mclib.config.background.tooltip=Les options de fond d'écran comme la couleur et les textures à utiliser

mclib.config.background.image=Image
mclib.config.comments.background.image=Image de fond utilisée dans tous les menus
mclib.config.background.color=Couleur
mclib.config.comments.background.color=Couleur de fond utilisée dans tous les menus. Si une image est spécifiée, alors la couleur sera utilisée comme couleur de teinte pour le fond d'écran

mclib.config.scrollbars.title=Barres de défilement
mclib.config.scrollbars.tooltip=Les options de personnalisation de la barre de défilement

mclib.config.scrollbars.flat=Barres de défilement unie
mclib.config.comments.scrollbars.flat=Donne une couleur unie pour les barres de défilement
mclib.config.scrollbars.shadow=Couleur de l'ombre
mclib.config.comments.scrollbars.shadow=Permet de modifier la couleur de l'ombre des barres de défilement
mclib.config.scrollbars.width=Épaisseur
mclib.config.comments.scrollbars.width=Permet de modifier l'épaisseur (largeur des barres de défilement)

mclib.config.multiskin.title=Multi-skin
mclib.config.multiskin.tooltip=Options par rapport aux fonctionnalités du Multi-skin

mclib.config.multiskin.multithreaded=Traitement multi-threadé
mclib.config.comments.multiskin.multithreaded=Permet d'activer ou de désactiver le traitement multi-threadé des multi-skins, qui devrait fixer le lag au prix d'un traitement plus long
mclib.config.multiskin.clear=Autoriser le rechargement des packs de ressources
mclib.config.comments.multiskin.clear=Vous permet d'activer ou désactiver la supression de toutes les textures des multi-skins lors d'un rechargement du pack de ressources

mclib.config.vanilla.title=Retouches de Minecraft Vanilla
mclib.config.vanilla.tooltip=Options par rapport aux retouches faites au code de Minecraft

mclib.config.vanilla.max_packet_size=Taille maximale des paquets
mclib.config.comments.vanilla.max_packet_size=Vous permet de configurer la taille maximale (en octets) d'un paquet moddé. Attention : ne changez pas cette valeur pour les serveurs publics, puisque cela rend le DDoS du serveur bien plus simple. Cette option est pensée pour le solo !

# OP access
op_access.config.title=Accès OP

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=Options d'accès OP de McLib

op_access.config.mclib.drop_items=Lâcher des items
#Not sure for the one bellow
op_access.config.comments.mclib.drop_items=Est-ce que les joueurs non-OP peuvent utiliser l'option de jetter des items stackés dans un slot ?

# Keybinds config
keybinds.config.title=Raccourcis clavier

keybinds.config.unknown_mod=Mod inconnu
keybinds.config.no_category=Aucune catégorie

# Interpolations
mclib.interpolations.linear=Linéaire
mclib.interpolations.quad_in=Quadratique
mclib.interpolations.quad_out=Quadratique Out
mclib.interpolations.quad_inout=Quadratique In/out
mclib.interpolations.cubic_in=Cubique In
mclib.interpolations.cubic_out=Cubique Out
mclib.interpolations.cubic_inout=Cubique In/out
mclib.interpolations.exp_in=Exponentiel In
mclib.interpolations.exp_out=Exponentiel Out
mclib.interpolations.exp_inout=Exponentiel In/out

mclib.interpolations.back_in=Retour In
mclib.interpolations.back_out=Retour Out
mclib.interpolations.back_inout=Retour In/out
mclib.interpolations.elastic_in=Élastique In
mclib.interpolations.elastic_out=Élastique Out
mclib.interpolations.elastic_inout=Élastique In/out
mclib.interpolations.bounce_in=Rebond In
mclib.interpolations.bounce_out=Rebond Out
mclib.interpolations.bounce_inout=Rebond In/out

mclib.interpolations.sine_in=Sinusoïdal In
mclib.interpolations.sine_out=Sinusoïdal Out
mclib.interpolations.sine_inout=Sinusoïdal In/out
mclib.interpolations.quart_in=Quartique In
mclib.interpolations.quart_out=Quartique Out
mclib.interpolations.quart_inout=Quartique In/out
mclib.interpolations.quint_in=Quintique In
mclib.interpolations.quint_out=Quintique Out
mclib.interpolations.quint_inout=Quintique In/out
mclib.interpolations.circle_in=Circulaire In
mclib.interpolations.circle_out=Circulaire Out
mclib.interpolations.circle_inout=Circulaire In/out

mclib.interpolations.const=Constant
mclib.interpolations.quad=Quadratique
mclib.interpolations.cubic=Cubique
mclib.interpolations.hermite=Hermite
mclib.interpolations.exp=Exponentiel
mclib.interpolations.bezier=Bézier
mclib.interpolations.back=Retour
mclib.interpolations.elastic=Élastique
mclib.interpolations.bounce=Rebond
mclib.interpolations.sine=Sinusoïdal
mclib.interpolations.quart=Quartique
mclib.interpolations.quint=Quintique
mclib.interpolations.circle=Circulaire

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=Cette interpolation va de A à B à une vitesse constante. C'est utile pour les rotations fluides et les mouvements lents.
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=C'est principalement utile pour les animations de poses en prenant en compte un degré de mouvement plus paresseux que Exponentiel ou Cubique In/out.
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=C'est principalement utile pour les animations de poses en prenant en compte un degré plus paresseux que Exponentiel In/out.
mclib.interpolations.tooltips.exp_in=C'est utile pour les caméras en le combinant avec Exponentiel Out, puisque vous pouvez créer des transitions nerveuses entre deux plans de caméra.
mclib.interpolations.tooltips.exp_out=C'est utile pour créer des mouvements rapides.
mclib.interpolations.tooltips.exp_inout=C'est principalement utile pour les animations de poses ou les emphases de caméra.

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=Il peut être utilisé pour les animations de mouvement de poses naturelles et se balançant.
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=C'est utile pour les mouvements de cartoon nerveux.
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=C'est utile pour créer une animation de quelque chose qui tombe sur le sol et qui rebondit un certain nombre de fois.
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=Cette interpolation n'interpole pas, mais garde plutôt la valeur initiale jusqu'à la fin. C'est utile pour créer des à-coups avec plusieurs keyframes.
mclib.interpolations.tooltips.hermite=Cette interpolation peut être fluide entre plusieurs keyframes d'animation. Soyez sûr que vous avez la même distance entre chaque keyframes, puisque sa fluidité ne fonctionne plus avec des distances variables.
mclib.interpolations.tooltips.bezier=Cette interpolation permet de personnaliser la courbe en utilisant des points de contrôle, qui permet aussi d'imiter la majorité des autres interpolations. C'est utile pour créer des transitions plus fluides entre plusieurs keyframes.

mclib.easing.in=Assouplissement in
mclib.easing.out=Assouplissement out
mclib.easing.inout=Assouplissement in/out

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=Commande McLib qui présente une possibilité d'éditer la configuration côté serveur.
mclib.commands.mclib.config.help=Les sous-commandes de configuration McLib permet de gérer les options de mod des mods de McHorse.
mclib.commands.mclib.config.print=§fCette commande renvoie la valeur actuelle de l'option de mod donnée par l'ID §7<mod.category.option>§f.
mclib.commands.mclib.config.set=§fCette commande modifie la valeur actuelle de l'option de mod donnée par l'ID §7<mod.category.option>§f à §7<value...>§f.
mclib.commands.cheats=La commande cheat permet d'activer/désactiver les cheats dans un monde solo.\n\nElle peut être utilisée aussi bien pour désactiver les cheats dans un monde créatif avec les commandes d'activées, par exemple si vous publiez une map aventure, que pour activer les commandes dans un monde téléchargé dans lequel les commandes cheats sont désactivées, parce que vous avez besoin d'utiliser des commandes pour une vidéo.

mclib.error.config.invalid_id=§fL'identifiant de l'option de mod donné %s§f est invalide !
mclib.error.config.invalid_format=§fLa valeur donnée %s§f pour l'option de mid d'identifiant %s§f ne peut être interprétée !
mclib.info.config.set=§fLa nouvelle valeur de l'option de mod %s§f est : %s§f
mclib.info.config.print=§fLa valeur de l'option de mod %s§f est : %s§f
mclib.info.config.client_side=§fL'option de mod donnée %s§f est uniquement côté client...

# Keystroke modes
mclib.keystrokes_position.auto=Auto
mclib.keystrokes_position.bottom_left=Bas gauche
mclib.keystrokes_position.bottom_right=Bas droit
mclib.keystrokes_position.top_right=Haut droit
mclib.keystrokes_position.top_left=Haut gauche

# Tootlip styles
mclib.tooltip_style.light=Clair
mclib.tooltip_style.dark=Sombre


==================================================

--- Файл №328 ---
Путь: main\resources\assets\mclib\lang\pt_BR.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=Painel

mclib.gui.ok=Ok
mclib.gui.cancel=Cancelar
mclib.gui.none=(nenhum)
mclib.gui.multi_skin=Múltipla-skin
mclib.gui.no_data=Nenhuns dados disponíveis
mclib.gui.open_folder=Abrir pasta
mclib.gui.pick_texture=Selecionar textura

mclib.gui.context.multi_skin.copy=Copiar localização da textura
mclib.gui.context.multi_skin.paste=Colocar localização da textura

# Don't remove space on the end!
mclib.gui.dashboard.category=Painel
mclib.gui.dashboard.open_panel=Abrir

mclib.gui.graph.tooltip=Calculadora Gráfica
mclib.gui.graph.help=Click on this button to go to a web page which documents features of following graphing calculator.\n\nExpressions used here, can be also used in Aperture's math modifier and Commander's math expression evaluation within commands.\n\nThis graphing calculator provides only one variable "x" which is horizontal coordinate you can plug in into y=x (aka f(x)) graph functions.
mclib.gui.config.title=Configuração
mclib.gui.config.tooltip=Configuração dos mods
mclib.gui.config.reload_tooltip=Recarregar configuração a partir de um arquivo...
mclib.gui.config.request_tooltip=Alternar entre a configuração do lado do servidor e do cliente...
mclib.gui.keys.list=Lista de atalhos

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.orientation.global=Global
mclib.gui.transforms.orientation.local=Local
mclib.gui.transforms.orientation.tooltip=Como os eixos de translação devem ser alinhados.
mclib.gui.transforms.translate=Translação
mclib.gui.transforms.scale=Escala
mclib.gui.transforms.rotate=Rotação
mclib.gui.transforms.context.copy=Copiar transformações
mclib.gui.transforms.context.paste=Colar transformações
mclib.gui.transforms.context.paste_translation=Colar translação
mclib.gui.transforms.context.paste_scale=Colar escala
mclib.gui.transforms.context.paste_rotation=Colar escala
mclib.gui.transforms.context.reset=Redefinir transformaçôes
mclib.gui.transforms.delta.origin=Em torno da origem

mclib.gui.keyframes.tick=Tick
mclib.gui.keyframes.value=Valor
mclib.gui.keyframes.context.maximize=Ver todos os keyframes
mclib.gui.keyframes.context.select_all=Selecionar todos
mclib.gui.keyframes.context.remove=Remover keyframe(s)
mclib.gui.keyframes.context.copy=Copiar keyframes
mclib.gui.keyframes.context.paste=Colar keyframes copiados
mclib.gui.keyframes.context.to_left=Mudar para as alças esquerdas
mclib.gui.keyframes.context.to_main=Mudar para as alças principais
mclib.gui.keyframes.context.to_right=Mudar para as alças direitas

mclib.gui.multiskin.color=With this color element, you can adjust color (RGB) channels. It works best with white/grayscale images.
mclib.gui.multiskin.scale=Escalar
mclib.gui.multiskin.scale_to_largest=Scale to largest
mclib.gui.multiskin.shift=Mudança
mclib.gui.multiskin.pixelate=Pixelizar
mclib.gui.multiskin.erase=Apagar
mclib.gui.multiskin.erase_tooltip=This feature allows to using current skin as difference mask, meaning, any opaque pixels will erase pixels of all skins underneath it.
mclib.gui.multiskin.custom_size=Tamanho custumizado
mclib.gui.multiskin.auto_size=Tamanho automático
mclib.gui.multiskin.auto_size_tooltip=When enabled, it will use texture's original size, otherwise custom size provided below. 
mclib.gui.multiskin.size_w=Largura personalizada
mclib.gui.multiskin.size_h=Altura personalizada

mclib.gui.color.favorite=Cores favoritas
mclib.gui.color.recent=Cores recentes

mclib.gui.color.context.favorites.add=Adicionar aos favoritos
mclib.gui.color.context.favorites.remove=Remover dos favoritos

mclib.gui.item_slot.context.copy=Copiar NBT do item
mclib.gui.item_slot.context.paste=Colar item NBT
mclib.gui.item_slot.context.drop=Soltar o item
mclib.gui.item_slot.context.clear=Limpar o item

# Config
mclib.config.title=McLib

mclib.config.appearance.title=Appearance
mclib.config.appearance.tooltip=General options regarding appearance of GUIs and the framework

mclib.config.appearance.primary_color=Primary color
mclib.config.comments.appearance.primary_color=The color which is used everywhere in the GUI system
mclib.config.appearance.enable_borders=Button borders
mclib.config.comments.appearance.enable_borders=Should buttons and other elements have borders?
mclib.config.appearance.enable_checkbox_rendering=Check boxes
mclib.config.comments.appearance.enable_checkbox_rendering=Enable check box rendering instead of toggle element (matter of the taste)
mclib.config.appearance.enable_trackpad_increments=Trackpad increments
mclib.config.comments.appearance.enable_trackpad_increments=Enable < and > buttons on the trackpad field (which increment the trackpad value)
mclib.config.appearance.enable_grid_rendering=Model grid
mclib.config.comments.appearance.enable_grid_rendering=Enable grid rendering instead of the ground grass block
mclib.config.appearance.user_interface_scale=GUI scale
mclib.config.comments.appearance.user_interface_scale=GUI scale for McHorse's mods instead of Video Settings' GUI scale. If set to 0, it will use Minecraft's GUI scale setting
mclib.config.appearance.render_translation_text_colours=Render translation text colours
mclib.config.comments.appearance.render_translation_text_colours=Render the respective axis colour for the translation fields, e.g. x is red, y is green and z is blue.
mclib.config.appearance.tooltip_style=Tooltip style
mclib.config.comments.appearance.tooltip_style=This option allows to change GUI tooltip style
mclib.config.appearance.trackpad_decimal_places=Trackpad decimal places
mclib.config.comments.appearance.trackpad_decimal_places=Set how many decimal places should not be rounded

mclib.config.tutorials.title=Tutorials options
mclib.config.tutorials.tooltip=This category provides options which are useful for making tutorial videos

mclib.config.tutorials.enable_mouse_rendering=Mouse cursor
mclib.config.comments.tutorials.enable_mouse_rendering=Enable rendering of the mouse cursor. It's very useful for tutorials when they're recorded with Minema mod and the cursor isn't visible
mclib.config.tutorials.enable_mouse_buttons_rendering=Mouse buttons
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=Enable rendering of the mouse button presses and mouse wheel scrolling. It's very useful for tutorials when they're recorded with Minema mod and mouse button presses or wheel scrolling are not visible
mclib.config.tutorials.enable_keystrokes_rendering=Keystrokes
mclib.config.comments.tutorials.enable_keystrokes_rendering=Enable rendering of the keystrokes. It's very useful for tutorials when to show which keys are being pressed
mclib.config.tutorials.keystroke_offset=Keystrokes offset
mclib.config.comments.tutorials.keystroke_offset=Allows to configure how many pixels away from the corner the keystroke line would be drawn
mclib.config.tutorials.keystroke_position=Keystrokes position
mclib.config.comments.tutorials.keystroke_position=Allows to change the corner of the keystroke line 

mclib.config.background.title=Background
mclib.config.background.tooltip=Background options like color and texture to be used

mclib.config.background.image=Image
mclib.config.comments.background.image=Background image to be used in every menu
mclib.config.background.color=Color
mclib.config.comments.background.color=Background color to be used in every menu. If image is specified, then this will be used as tinting color for background

mclib.config.scrollbars.title=Scrollbars
mclib.config.scrollbars.tooltip=Style options for scrollbars

mclib.config.scrollbars.flat=Flat scrollbars
mclib.config.comments.scrollbars.flat=Return the looks of flat colored scrollbars
mclib.config.scrollbars.shadow=Shadow color
mclib.config.comments.scrollbars.shadow=Allows you to set shadow color of scrollbars
mclib.config.scrollbars.width=Thickness
mclib.config.comments.scrollbars.width=Allows you to setup the thickness (width of scrollbars)

mclib.config.multiskin.title=Multi-skin
mclib.config.multiskin.tooltip=Options regarding Multi-skin feature

mclib.config.multiskin.multithreaded=Multi-threaded processing
mclib.config.comments.multiskin.multithreaded=Allows you to toggle multi-threaded processing of multi-skins, which should fix the lag at cost of longer processing
mclib.config.multiskin.clear=Clear upon RPs reloading
mclib.config.comments.multiskin.clear=Allows you to toggle deleting all multi-skin textures during resource pack reloading

mclib.config.vanilla.title=Vanilla tweaks
mclib.config.vanilla.tooltip=Options regarding to tweaks done to Minecraft's code

mclib.config.vanilla.max_packet_size=Max. packet size
mclib.config.comments.vanilla.max_packet_size=Allows you to configure the maximum size (in bytes) of a modded packet. Warning: don't change this value for public servers, as it will allow to DDoS server much easier. This option is designed for singleplayer!

# OP access
op_access.config.title=Acesso OP

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=Opções de acesso OP do McLib

op_access.config.mclib.drop_items=Soltar itens
op_access.config.comments.mclib.drop_items=Jogadores não-OP podem usar a opção de soltar itens do elemento de slot na pilha de itens?

# Keybinds config
keybinds.config.title=Atalhos

keybinds.config.unknown_mod=Mod desconhecido
keybinds.config.no_category=Nenhuma categoria

# Interpolations
mclib.interpolations.linear=Linear
mclib.interpolations.quad_in=Quadratic In
mclib.interpolations.quad_out=Quadratic Out
mclib.interpolations.quad_inout=Quadratic In/out
mclib.interpolations.cubic_in=Cubic In
mclib.interpolations.cubic_out=Cubic Out
mclib.interpolations.cubic_inout=Cubic In/out
mclib.interpolations.exp_in=Exponential In
mclib.interpolations.exp_out=Exponential Out
mclib.interpolations.exp_inout=Exponential In/out

mclib.interpolations.back_in=Back In
mclib.interpolations.back_out=Back Out
mclib.interpolations.back_inout=Back In/out
mclib.interpolations.elastic_in=Elastic In
mclib.interpolations.elastic_out=Elastic Out
mclib.interpolations.elastic_inout=Elastic In/out
mclib.interpolations.bounce_in=Bounce In
mclib.interpolations.bounce_out=Bounce Out
mclib.interpolations.bounce_inout=Bounce In/out

mclib.interpolations.sine_in=Sine In
mclib.interpolations.sine_out=Sine Out
mclib.interpolations.sine_inout=Sine In/out
mclib.interpolations.quart_in=Quartic In
mclib.interpolations.quart_out=Quartic Out
mclib.interpolations.quart_inout=Quartic In/out
mclib.interpolations.quint_in=Quintic In
mclib.interpolations.quint_out=Quintic Out
mclib.interpolations.quint_inout=Quintic In/out
mclib.interpolations.circle_in=Circle In
mclib.interpolations.circle_out=Circle Out
mclib.interpolations.circle_inout=Circle In/out

mclib.interpolations.const=Constant
mclib.interpolations.quad=Quadratic
mclib.interpolations.cubic=Cubic
mclib.interpolations.hermite=Hermite
mclib.interpolations.exp=Exponential
mclib.interpolations.bezier=Bezier
mclib.interpolations.back=Back
mclib.interpolations.elastic=Elastic
mclib.interpolations.bounce=Bounce
mclib.interpolations.sine=Sine
mclib.interpolations.quart=Quartic
mclib.interpolations.quint=Quintic
mclib.interpolations.circle=Circle

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=This interpolation goes at constant speed from A to B. It's useful for seamless rotations and slow movement.
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=It's most useful for pose animation denoting an even more lazier degree of movement than Exponential or Cubic In/out.
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=It's most useful for pose animation denoting a more lazier movement than Exponential In/out.
mclib.interpolations.tooltips.exp_in=It's useful for cameras in combination with Exponential Out, as you can create jumpy, spike-like, transition between two camera shots.
mclib.interpolations.tooltips.exp_out=It's useful for creating rapid movement.
mclib.interpolations.tooltips.exp_inout=It's most useful for pose animation or camera emphasis.

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=It can be used for swaying and natural pose animation movement.
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=It's useful for jumpy cartoon movements.
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=It's useful for creating an animation of something falling on the ground and bouncing a couple of times.
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=This interpolation doesn't interpolate, but rather keeps the initial value till the end. It's useful for creating sharp steps using multiple keyframes.
mclib.interpolations.tooltips.hermite=This interpolation that can smooth animation across multiple keyframes. Make sure that you have same distance between keyframes, as its smoothness breaks with variable distance.
mclib.interpolations.tooltips.bezier=This interpolation allows customize the curve using control points, which allows also mimicking majority of other interpolations. It's useful for creating smoother transition between multiple keyframes.

mclib.easing.in=Ease in
mclib.easing.out=Ease out
mclib.easing.inout=Ease in/out

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=McLib command which features config editing capabilities on the server side.
mclib.commands.mclib.config.help=McLib config subcommand allows to manage mod options from McHorse's mods.
mclib.commands.mclib.config.print=§fThis command prints the current value of given mod option by §7<mod.category.option>§f ID.
mclib.commands.mclib.config.set=§fThis command sets current value of given mod option by §7<mod.category.option>§f ID to §7<value...>§f.
mclib.commands.cheats=Cheat command allows to toggle cheat commands in a singleplayer world.\n\nIt can be used either to disable cheats in a creative world with commands enabled, let's say you are publishing an adventure map, or enable commands in a downloaded world in which cheat commands are disabled, because you need to use commands for a video.

mclib.error.config.invalid_id=§fGiven mod option identifier %s§f is invalid!
mclib.error.config.invalid_format=§fGiven value %s§f for mod option identifier %s§f can't be parsed!
mclib.info.config.set=§fThe new value of mod option %s§f is: %s§f
mclib.info.config.print=§fThe value of mod option %s§f is: %s§f
mclib.info.config.client_side=§fGiven mod option %s§f is client side only...

# Keystroke modes
mclib.keystrokes_position.auto=Automático
mclib.keystrokes_position.bottom_left=Inferior esquerdo
mclib.keystrokes_position.bottom_right=Canto inferior direito
mclib.keystrokes_position.top_right=Canto superior direito
mclib.keystrokes_position.top_left=Canto superior esquerdo

# Tootlip styles
mclib.tooltip_style.light=Claro
mclib.tooltip_style.dark=Escuro

==================================================

--- Файл №329 ---
Путь: main\resources\assets\mclib\lang\ru_RU.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=МакЛиб
key.mclib.dashboard=Главная панель

mclib.gui.ok=Ок
mclib.gui.cancel=Отменить
mclib.gui.none=(отсутствует)
mclib.gui.multi_skin=Мультискин
mclib.gui.no_data=Данные отсутствуют...
mclib.gui.open_folder=Открыть папку
mclib.gui.pick_texture=Выбрать текстуру

mclib.gui.context.multi_skin.copy=Скопировать путь расположения теекстуры
mclib.gui.context.multi_skin.paste=Вставить путь расположения теекстуры

# Don't remove space on the end!
mclib.gui.dashboard.category=Главная панель
mclib.gui.dashboard.open_panel=Открыть 

mclib.gui.graph.tooltip=Калькулятор графиков
mclib.gui.graph.help=Кликните на эту кнопку чтобы перейти на веб-страницу, на которой расписана документация представленного калькулятора графиков.\n\nВыражения, используемые в нём, можно также использовать в модификаторе "Математика" в Aperture и вычисление выражений в командах в моде Commander.\n\nЭтот калькулятор графиков предоставляет только одну переменную - "х", которая является горизонтальной координатой, которую вы можете вставлять в функции графика на манер y=x (ака f(x)).
mclib.gui.config.title=Конфигурация
mclib.gui.config.tooltip=Конфигурация модов
mclib.gui.config.reload_tooltip=Перезагрузить конфигурацию из файла...
mclib.gui.config.request_tooltip=Переключиться между конфигурацией сервера и клиента...
mclib.gui.keys.list=Список комбинаций клавиш

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.translate=Перемещение
mclib.gui.transforms.scale=Масштаб
mclib.gui.transforms.rotate=Вращение
mclib.gui.transforms.context.copy=Копировать трансформации
mclib.gui.transforms.context.paste=Вставить трансформации
mclib.gui.transforms.context.paste_translation=Вставить перемещение
mclib.gui.transforms.context.paste_scale=Вставить масштаб
mclib.gui.transforms.context.paste_rotation=Вставить вращение
mclib.gui.transforms.context.reset=Сбросить трансформацию

mclib.gui.keyframes.tick=Тик
mclib.gui.keyframes.value=Значение
mclib.gui.keyframes.context.maximize=Просмотреть все ключёвые кадры
mclib.gui.keyframes.context.select_all=Выбрать все
mclib.gui.keyframes.context.remove=Удалить ключевые кадры
mclib.gui.keyframes.context.copy=Copy keyframes
mclib.gui.keyframes.context.paste=Paste copied keyframes
mclib.gui.keyframes.context.to_left=Выбрать только левые стрелки
mclib.gui.keyframes.context.to_main=Выбрать только кадры без стрелок
mclib.gui.keyframes.context.to_right=Выбрать только правые стрелки

mclib.gui.multiskin.color=Используя эту панель настройки цвета, вы можете настроить каналы цвета в формате RGB. Лучше всего работает с белыми/серыми изображениями.
mclib.gui.multiskin.scale=Масштаб
mclib.gui.multiskin.scale_to_largest=Отмасштабировать по найбольшему
mclib.gui.multiskin.shift=Перемещение
mclib.gui.multiskin.pixelate=Пикселизировать
mclib.gui.multiskin.erase=Стереть
mclib.gui.multiskin.erase_tooltip=Этот параметр позволяет использовать текущий скин в качестве маски отличий (difference mask), означая, что любые непрозрачные пиксели изображения сотрут пиксели всех скинов под ним.
mclib.gui.multiskin.custom_size=Пользовательский масштаб
mclib.gui.multiskin.auto_size=Автомасштаб
mclib.gui.multiskin.auto_size_tooltip=Если эта опция включена, то изображение будет использовать свой изначальный размер - во всех остальных случаях будет использован пользовательский размер заданный в полях ниже. 
mclib.gui.multiskin.size_w=Пользовательская ширина
mclib.gui.multiskin.size_h=Пользовательская высота

mclib.gui.color.favorite=Избранные цвета
mclib.gui.color.recent=Недавние цвета

mclib.gui.color.context.favorites.add=Добавить к избранным
mclib.gui.color.context.favorites.remove=Удалить из избранных

mclib.gui.item_slot.context.copy=Скопировать NBT предмета
mclib.gui.item_slot.context.paste=Вставить NBT предмета
mclib.gui.item_slot.context.drop=Выбросить предмет
mclib.gui.item_slot.context.clear=Очистить предмет

# Config
mclib.config.title=МакЛиб

mclib.config.appearance.title=Внешний вид
mclib.config.appearance.tooltip=Общие настройки, касающиеся внешнего вида интерфейса и системы

mclib.config.appearance.primary_color=Главный цвет
mclib.config.comments.appearance.primary_color=Цвет, который повсеместно используется в системе интерфейса
mclib.config.appearance.enable_borders=Рамки кнопок
mclib.config.comments.appearance.enable_borders=Необходимо ли наличие рамок у кнопок и других элементов?
mclib.config.appearance.enable_checkbox_rendering=Клетки
mclib.config.comments.appearance.enable_checkbox_rendering=Включить клетки вместо переключателя (дело вкуса)
mclib.config.appearance.enable_trackpad_increments=Изменения трекпадами
mclib.config.comments.appearance.enable_trackpad_increments=Включить кнопки < и > в поле трекпадов, которые позволяют изменять значения, заданные в полях с трекпадами
mclib.config.appearance.enable_grid_rendering=Сетка редактора моделей
mclib.config.comments.appearance.enable_grid_rendering=Включить отрисовку сетки вместо блока травы
mclib.config.appearance.user_interface_scale=Размер интерфейса
mclib.config.comments.appearance.user_interface_scale=Размера интерфейса для модов МакХорса, используемый отдельно от такового прамаетра в "Натройках видео". Если значение параметра равняется нулю, то будет использовано значение из "Настроек видео"
mclib.config.appearance.tooltip_style=Tooltip style
mclib.config.comments.appearance.tooltip_style=Эта опция позволяет менять стиль подсказов интерфейса
mclib.config.appearance.trackpad_decimal_places=Кол-во знаков после запятой
mclib.config.comments.appearance.trackpad_decimal_places=Установить сколько знаков после запятой необходимо для округления значения

mclib.config.tutorials.title=Опции для туториалов
mclib.config.tutorials.tooltip=Опции этой категории могут быть полезны для производства туториалов (обучающих видео)

mclib.config.tutorials.enable_mouse_rendering=Курсор мыши
mclib.config.comments.tutorials.enable_mouse_rendering=Включает отображение курсора мыши. Рекомендуется включить при записи туториалов минемой (т.к. при записи минемой курсор не отображается)
mclib.config.tutorials.enable_mouse_buttons_rendering=Кнопки мыши
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=Включает отображение нажатий кнопок мыши и прокрутки колёсика. Очень полезная функция для записи туториалов с минемой, где не видно системные манипуляции с мышью
mclib.config.tutorials.enable_keystrokes_rendering=Подсветка клавиш
mclib.config.comments.tutorials.enable_keystrokes_rendering=Включает отображение подсветки клавиш. Очень полезная функция для туториалов, т.к. так можно продемонстрировать нажимаемые клавиши без танцев с бубном
mclib.config.tutorials.keystroke_offset=Смещение подсветки клавиш
mclib.config.comments.tutorials.keystroke_offset=Позволяет настроить на сколько пикселей от угла будет смещаться подсветка клавиш 
mclib.config.tutorials.keystroke_position=Позиция подсветки клавиш
mclib.config.comments.tutorials.keystroke_position=Позволяет менять местонахождение угла с подсветкой клавиш 

mclib.config.background.title=Задний фон
mclib.config.background.tooltip=Настройки заднего фона, такие как цвет и фоновое изображение

mclib.config.background.image=Изображение
mclib.config.comments.background.image=Фоновое изображение, использующееся во всех меню
mclib.config.background.color=Цвет
mclib.config.comments.background.color=Цвет заднего фона, использующийся во всех меню. Если указано изображение, то цвет будет использован в качестве оттенка для заднего фона

mclib.config.scrollbars.title=Поля прокрутки
mclib.config.scrollbars.tooltip=Настройки полей, такие как цвет и фоновое изображение

mclib.config.scrollbars.flat=Одноцветные поля прокрутки
mclib.config.comments.scrollbars.flat=Вернуть вид одноцветных полей прокрутки
mclib.config.scrollbars.shadow=Цвет затенения
mclib.config.comments.scrollbars.shadow=Позволяетвам устанавливать цвет затенения полей прокрутки
mclib.config.scrollbars.width=Толщина
mclib.config.comments.scrollbars.width=Позволяет вам настроить толщину (ширину полей прокрутки)

mclib.config.multiskin.title=Мультискин
mclib.config.multiskin.tooltip=Опции, которые относятся к Мультискину

mclib.config.multiskin.multithreaded=Многопоточная обработка
mclib.config.comments.multiskin.multithreaded=Позволяет вам использовать многопоточную обработку мультискинов, что должно убрать лаги, но обойдётся более длинным временем обработки
mclib.config.multiskin.clear=Очистка во время перезагрузки ресурспаков
mclib.config.comments.multiskin.clear=Позволяет вам включить удаление всех текстур, использующих мульти-скин, во время перезагрузки ресурспаков

mclib.config.vanilla.title=Ванильные ухищрения
mclib.config.vanilla.tooltip=Опции, затрагивающие махинации-ухищрения, проводимые с кодом Майнкрафта

mclib.config.vanilla.max_packet_size=Максимальный размер пакетов
mclib.config.comments.vanilla.max_packet_size=Позволяет вам настраивать максимальный размер модифицированного отсылаемого пакета (в байтах). Внимание! Не меняйте это значение на публичных серверах, так как это позволит очень легко провести DDoS-атаку. Меняйте этот параметр исключительно в одиночной игре!

# OP access
op_access.config.title=ОП-Доступ

op_access.config.mclib.title=МакЛиб
op_access.config.mclib.tooltip=Настройки доступа неоператоров к МакЛибу

op_access.config.mclib.drop_items=Выбрасывание предметов
op_access.config.comments.mclib.drop_items=Могут ли игроки-неоператоры использовать опцию выбрасывания предметов дабы выбросить вещь из слота предмета у какого-либо элемента?

# Interpolations
mclib.interpolations.linear=Линейная
mclib.interpolations.quad_in=Квадратическая In
mclib.interpolations.quad_out=Квадратическая Out
mclib.interpolations.quad_inout=Квадратическая In/Out
mclib.interpolations.cubic_in=Кубическая In
mclib.interpolations.cubic_out=Кубическая Out
mclib.interpolations.cubic_inout=Кубическая In/Out
mclib.interpolations.exp_in=Экспоненциальная In
mclib.interpolations.exp_out=Экспоненциальная Out
mclib.interpolations.exp_inout=Экспоненциальная In/Out

mclib.interpolations.back_in=Заскакивающая In
mclib.interpolations.back_out=Заскакивающая Out
mclib.interpolations.back_inout=Заскакивающая In/Out
mclib.interpolations.elastic_in=Упругая In
mclib.interpolations.elastic_out=Упругая Out
mclib.interpolations.elastic_inout=Упругая In/Out
mclib.interpolations.bounce_in=Пружинистая In
mclib.interpolations.bounce_out=Пружинистая Out
mclib.interpolations.bounce_inout=Пружинистая In/Out

mclib.interpolations.sine_in=Синусоидальная In
mclib.interpolations.sine_out=Синусоидальная Out
mclib.interpolations.sine_inout=Синусоидальная In/Out
mclib.interpolations.quart_in=Биквадратная In
mclib.interpolations.quart_out=Биквадратная Out
mclib.interpolations.quart_inout=Биквадратная In/Out
mclib.interpolations.quint_in=Пятистепенная In
mclib.interpolations.quint_out=Пятистепенная Out
mclib.interpolations.quint_inout=Пятистепенная In/Out
mclib.interpolations.circle_in=Круговая In
mclib.interpolations.circle_out=Круговая Out
mclib.interpolations.circle_inout=Круговая In/Out

mclib.interpolations.const=Постоянная
mclib.interpolations.quad=Квадратическая
mclib.interpolations.cubic=Кубическая
mclib.interpolations.hermite=Сплайновая
mclib.interpolations.exp=Экспоненциальная
mclib.interpolations.bezier=Безье
mclib.interpolations.back=Заскакивающая
mclib.interpolations.elastic=Упругая
mclib.interpolations.bounce=Пружинистая
mclib.interpolations.sine=Синусоидальная
mclib.interpolations.quart=Биквадратная
mclib.interpolations.quint=Пятистепенная
mclib.interpolations.circle=Круговая

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=Эта интерполяция представляет из себя изменение с постоянной скоростью из состояния А в состояние Б. Полезна для бесшовного вращения и медленных движений.
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=Крайне полезна для анимации поз, в которых необходимо ещё более ленивое движение, чем в Экспоненциальной In/Out или Кубической In/Out.
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=Крайне полезна для анимации поз, в которых необходимо более ленивое движение, чем в Экспоненциальной In/Out.
mclib.interpolations.tooltips.exp_in=Полезна для камер в комбинации с Экспоненциальной Out, так как с их помощью можно делать прыгучие, резки переходы между двумя ракурсами.
mclib.interpolations.tooltips.exp_out=Полезна для внезапного движения.
mclib.interpolations.tooltips.exp_inout=Крайне полезна для анимации поз или акцентирования камеры на чём-либо.

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=Может быть использована для медленной тряски из стороны в сторону и естественной анимации поз.
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=Полезна для "мультяшного" прыгучего движения.
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=Полезна для анимации падающего объекта, несколько раз отскакивающего от земли.
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=Одна из самых плавных интерполяций.
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=Эта интерполяция не интерполирует, а, скорее, сохраняет первичное значение до конца. Полезна для создания резких шагов используя несколько ключей.
mclib.interpolations.tooltips.hermite=Эта интерполяция может сглаживать анимацию в случае использования нескольких ключей. Имейте в виду, что для правильной работы интерполяции, вам необходимо иметь одинаковое расстояние между ключами, так как сглаживание ломается в случае если расстояние неодинаково.
mclib.interpolations.tooltips.bezier=Эта интерполяция позволяет настроить кривую, используя контрольные точки (стрелки), с помощью чего можно подделать множество других интерполяций. Полезна для создания более гладких переходов между несколькими ключами.

mclib.easing.in=In
mclib.easing.out=Out
mclib.easing.inout=In/Out

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=Команда МакЛиба, которая предусматривает возможность редактирования конфига со стороны сервера.
mclib.commands.mclib.config.help=Подкоманды конфига МакЛиба позволяют вам настраивать опции модов МакХорса.
mclib.commands.mclib.config.print=§fЭта команда печатает в чат текущее значение заданной опции мода с ID §7<mod.category.option>§f.
mclib.commands.mclib.config.set=§fЭта команда задаёт текущее значение заданной опции мода с ID §7<mod.category.option>§f ко значению §7<value...>§f.
mclib.commands.cheats=Команда читов позволяет включить чит-команды в мире одиночной игры.\n\nЕё можно использовать для того, чтобы выключать читы в творческом мире, но оставить выполнение команд - скажем, если вам необходимо опубликовать приключенческую карту, или включить команды в загруженном мире, где команды по умолчанию запрещены.

mclib.error.config.invalid_id=§fОпция мода с заданным идентификатором %s§f неверна!
mclib.error.config.invalid_format=§fНевозможно просчитать заданное значение %s§f для опции мода с идентификатором %s§f!
mclib.info.config.set=§fНовое значение в моде опции %s§f равняется: %s§f
mclib.info.config.print=§fЗначение в моде опции %s§f равняется: %s§f
mclib.info.config.client_side=§fЗаданная опция мода %s§f является исключительно клиентской настройкой...

# Keystroke modes
mclib.keystrokes_position.auto=Автоматически
mclib.keystrokes_position.bottom_left=Слева снизу
mclib.keystrokes_position.bottom_right=Справа снизу
mclib.keystrokes_position.top_right=Справа сверху
mclib.keystrokes_position.top_left=Слева сверху

# Tootlip styles
mclib.tooltip_style.light=Светлые
mclib.tooltip_style.dark=Тёмные


==================================================

--- Файл №330 ---
Путь: main\resources\assets\mclib\lang\ua_uk.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=Головна панель

mclib.gui.ok=Ок
mclib.gui.cancel=Відмінити
mclib.gui.none=(відсутньо)
mclib.gui.multi_skin=Мультискін
mclib.gui.no_data=Немає доступних даних...
mclib.gui.open_folder=Відкрити папку
mclib.gui.pick_texture=Обрати текстуру
mclib.gui.context.multi_skin.copy=Скопіювати місцезнаходження текстури
mclib.gui.context.multi_skin.paste=Вставити скопійоване місцезнаходження текстури

# Don't remove space on the end!
mclib.gui.dashboard.category=Головна панель
mclib.gui.dashboard.open_panel=Відкрити 

mclib.gui.graph.tooltip=Калькулятор графіків
mclib.gui.graph.help=mclib.gui.graph.help=Клацніть на цю кнопку аби перейти на інтернет-сторінку, що містить документацію можливостей калькулятора графіків.\n\nВирази, які можна використати тут, також можна використати у модифікаторі Аперчур "Вираз", та математичній перевірці виразів у командах моду Commander.\n\nДаний калькулятор графіків надає можливість використовувати тільки одну змінну "x", яка є горизонтальною координатою, котру ви можете використовувати у функціях графіків по типу y=x (aka f(x)).
mclib.gui.config.title=Налаштування
mclib.gui.config.tooltip=Налаштування модів
mclib.gui.config.reload_tooltip=Перезавантажити налаштування з файлу...
mclib.gui.config.request_tooltip=Перемикнутися між налаштуваннями серверу та клієнту...
mclib.gui.keys.list=Список клавіш

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.orientation.global=Глобальний
mclib.gui.transforms.orientation.local=Локальний
mclib.gui.transforms.orientation.tooltip=Яким чином мають бути розташовані вісі переміщення.
mclib.gui.transforms.translate=Переміщення
mclib.gui.transforms.scale=Масштабування
mclib.gui.transforms.rotate=Обертання
mclib.gui.transforms.context.copy=Скопіювати трансформації
mclib.gui.transforms.context.paste=Вставити трансформації
mclib.gui.transforms.context.paste_translation=Вставити переміщення
mclib.gui.transforms.context.paste_scale=Вставити масштабування
mclib.gui.transforms.context.paste_rotation=Вставити обертання
mclib.gui.transforms.context.reset=Скинути трансформації
mclib.gui.transforms.delta.origin=Коло кординат

mclib.gui.keyframes.tick=Тік
mclib.gui.keyframes.value=Значення
mclib.gui.keyframes.context.maximize=Переглянути усі ключкадри
mclib.gui.keyframes.context.select_all=Обрати усі
mclib.gui.keyframes.context.remove=Видалити ключкадр(и)
mclib.gui.keyframes.context.copy=Скопіювати ключкадри
mclib.gui.keyframes.context.paste=Вставити скопійовані ключкадри
mclib.gui.keyframes.context.to_left=Перемкнутися на ліві стрілки
mclib.gui.keyframes.context.to_main=Перемкнутися на центральні стрілки
mclib.gui.keyframes.context.to_right=Перемкнутися на праві стрілки

mclib.gui.multiskin.color=З цим елементом кольору, ви можете налаштувати колір каналів за схемою RGB. Найкраще працює з білими або сірими світлинами.
mclib.gui.multiskin.scale=Масштаб
mclib.gui.multiskin.scale_to_largest=Вирівняти до найбільшого
mclib.gui.multiskin.shift=Зміщення
mclib.gui.multiskin.pixelate=Пікселізація
mclib.gui.multiskin.erase=Стерти
mclib.gui.multiskin.erase_tooltip=Ця опція надає можливість використовувати обраний скін у якості маски різниці - будь-які непрозорі пікселі маски зітруть пікселі усіх скінів під ними.
mclib.gui.multiskin.custom_size=Користувацький масштаб
mclib.gui.multiskin.auto_size=Автомасштаб
mclib.gui.multiskin.auto_size_tooltip=Якщо вмикнено, текстура зберігатиме свій оригінальний масштаб, в усіх інших випадках є графи користуацького розміру знизу.
mclib.gui.multiskin.size_w=Користувацька ширина
mclib.gui.multiskin.size_h=Користувацька висота

mclib.gui.color.favorite=Обрані кольори
mclib.gui.color.recent=Недавні кольори

mclib.gui.color.context.favorites.add=Додати до обраних
mclib.gui.color.context.favorites.remove=Видалити з обраних

mclib.gui.item_slot.context.copy=Скопіювати NBT предмету
mclib.gui.item_slot.context.paste=Вставити NBT предмету
mclib.gui.item_slot.context.drop=Викинути предмет
mclib.gui.item_slot.context.clear=Скинути предмет

# Config
mclib.config.title=McLib
mclib.config.appearance.title=Зовнішній вигляд
mclib.config.appearance.tooltip=Загальні налаштування зовнішнього вигляду інтерфейсу та фреймворку

mclib.config.appearance.primary_color=Головний колір
mclib.config.comments.appearance.primary_color=Колір, що використовуватиметься всюди в інтерфейсі
mclib.config.appearance.enable_borders=Рамка кнопок
mclib.config.comments.appearance.enable_borders=Чи мають кнопки та інші елементи мати рамку?
mclib.config.appearance.enable_checkbox_rendering=Прапорці
mclib.config.comments.appearance.enable_checkbox_rendering=Вмикнути прапорці замість тумблерів (справа смаку)
mclib.config.appearance.enable_trackpad_increments=Зміна значення трекпадів
mclib.config.comments.appearance.enable_trackpad_increments=Вмикає кнопки < та > на полях трекпадів (за допомогою яких можна змінювати значення у трекпадах)
mclib.config.appearance.enable_grid_rendering=Сітка у моделей
mclib.config.comments.appearance.enable_grid_rendering=Вмикає відображення сітки замість відображення блоку трави
mclib.config.appearance.user_interface_scale=Розмір інтерфейсу
mclib.config.comments.appearance.user_interface_scale=Розмір інтерфейсу для модів від McHorse, що використовуватиметься замість розміру інтерфейсу Майнкрафту у налаштуваннях відео. У разі якщо значення цього параметру встановлено на 0, використовуватиметься усталений розмір інтерфейсу Майнкрафту
mclib.config.appearance.render_translation_text_colours=Відображати кольори тексту трансформацій
mclib.config.comments.appearance.render_translation_text_colours=Відображати відповідний колір вісі для полей трансформацій, себто x - червоний, y - зелений та z - синій.
mclib.config.appearance.tooltip_style=Стиль підказок
mclib.config.comments.appearance.tooltip_style=Ця опція надає можливість змінювати стиль інтерфейсу підказок
mclib.config.appearance.trackpad_decimal_places=Десяткові позиції трекпадів
mclib.config.comments.appearance.trackpad_decimal_places=Задайте до скількох позицій необхідно НЕ округлювати числа у трекпадах

mclib.config.tutorials.title=Налаштування гайдів
mclib.config.tutorials.tooltip=Ця категорія містить опції, корисні для створення гайдів та навчальних відео

mclib.config.tutorials.enable_mouse_rendering=Курсор миші
mclib.config.comments.tutorials.enable_mouse_rendering=Вмикнути відображення внутрішьного курсору миші. Дуже корисно для гайдів, за умови, що ви записуєте їх з Minema, де не видно стандартний курсор ОС
mclib.config.tutorials.enable_mouse_buttons_rendering=Кнопки миші
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=Вмикнути відображення натискань кнопок миші та прокрутки колесика. Дуже корисно для гайдів, за умови, що ви записуєте їх з Minema, де не видно натискань кнопок миші та колесика
mclib.config.tutorials.enable_keystrokes_rendering=Іконки клавіш
mclib.config.comments.tutorials.enable_keystrokes_rendering=Вмикнути відображення іконок клавіш, які ви натискаєте. Дуже корисно для гайдів, де необхідно демонструвати які саме клавіші ви натискаєте
mclib.config.tutorials.keystroke_offset=Зміщення іконок клавіш
mclib.config.comments.tutorials.keystroke_offset=Надає вам можливість налаштувати за скільки пікселів від куту мають відображатися іконки клавіш
mclib.config.tutorials.keystroke_position=Позиція іконок клавіш
mclib.config.comments.tutorials.keystroke_position=Надає вам можливість змінити кут, в якому розміщуються іконки клавіш 

mclib.config.background.title=Фон
mclib.config.background.tooltip=Налаштування деталей фону, таких як кольори та світлина

mclib.config.background.image=Світлина
mclib.config.comments.background.image=Фонова світлина, що використовуватиметься у кожному меню
mclib.config.background.color=Колір
mclib.config.comments.background.color=Фоновий колір, що використовуватиметься у кожному меню. У разі, якщо ви також задали світлину, колір буде використано у якості відтінку для світлини

mclib.config.scrollbars.title=Смуги прокрутки
mclib.config.scrollbars.tooltip=Налаштування деталей смуги прокрутки

mclib.config.scrollbars.flat=Плоскі смуги прокрутки
mclib.config.comments.scrollbars.flat=Повертає вигляд плоских, монотонних смуг прокрутки
mclib.config.scrollbars.shadow=Колір тіні
mclib.config.comments.scrollbars.shadow=Надає можливість налаштувати колір тіні смуги прокрутки
mclib.config.scrollbars.width=Товщина
mclib.config.comments.scrollbars.width=Надає можливість налаштувати товщину (ширину смуг прокрутки)

mclib.config.multiskin.title=Мультискін
mclib.config.multiskin.tooltip=Налаштування, що стосуються Мультискіну

mclib.config.multiskin.multithreaded=Мультипоточна обробка
mclib.config.comments.multiskin.multithreaded=Надає можливість вмикнути або вимкнути мультипоточну обробку мультискінів, що має полагодити затримку у провантаженні за рахунок довшої обробки
mclib.config.multiskin.clear=Скинути після перевантаження РП
mclib.config.comments.multiskin.clear=Надає можливість вмикнути видалення усіх мультискінових текстур під час перезавантаження ресурс-паку

mclib.config.vanilla.title=Рихтування Ваніли
mclib.config.vanilla.tooltip=Налаштування деяких рихтунків до коду Майнкрафту

mclib.config.vanilla.max_packet_size=Макс. розмір пакетів
mclib.config.comments.vanilla.max_packet_size=Надає вам можливість налаштувати максимальний розмір (у байтах) модифікованого пакету даних. Увага: не змінюйте це значення для публічних серверів, т.я. таким чином провести DDoS-атаку стане набагато легше. Це налаштування існує лише для використання у самітній грі!

# OP access
op_access.config.title=Операторський Допступ

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=Налаштування операторського доступу McLib

op_access.config.mclib.drop_items=Викидання предметів
op_access.config.comments.mclib.drop_items=Чи можуть гравці не-оператори мати можливість викидання предметів у елементі слота стаку предметів?

# Keybinds config
keybinds.config.title=Клавіші

keybinds.config.unknown_mod=Невідомий мод
keybinds.config.no_category=Відсутня категорія

# Interpolations
mclib.interpolations.linear=Лінійна
mclib.interpolations.quad_in=Квадратична In
mclib.interpolations.quad_out=Квадратична Out
mclib.interpolations.quad_inout=Квадратична In/out
mclib.interpolations.cubic_in=Кубічна In
mclib.interpolations.cubic_out=Кубічна Out
mclib.interpolations.cubic_inout=Кубічна In/out
mclib.interpolations.exp_in=Експоненційна In
mclib.interpolations.exp_out=Експоненційна Out
mclib.interpolations.exp_inout=Експоненційна In/out

mclib.interpolations.back_in=Зворотня In
mclib.interpolations.back_out=Зворотня Out
mclib.interpolations.back_inout=Зворотня In/out
mclib.interpolations.elastic_in=Гнучка In
mclib.interpolations.elastic_out=Гнучка Out
mclib.interpolations.elastic_inout=Гнучка In/out
mclib.interpolations.bounce_in=Стрибуча In
mclib.interpolations.bounce_out=Стрибуча Out
mclib.interpolations.bounce_inout=Стрибуча In/out

mclib.interpolations.sine_in=Синусоїдна In
mclib.interpolations.sine_out=Синусоїдна Out
mclib.interpolations.sine_inout=Синусоїдна In/out
mclib.interpolations.quart_in=Квартова In
mclib.interpolations.quart_out=Квартова Out
mclib.interpolations.quart_inout=Квартова In/out
mclib.interpolations.quint_in=Квінтова In
mclib.interpolations.quint_out=Квінтова Out
mclib.interpolations.quint_inout=Квінтова In/out
mclib.interpolations.circle_in=Кругова In
mclib.interpolations.circle_out=Кругова Out
mclib.interpolations.circle_inout=Кругова In/out

mclib.interpolations.const=Постійна
mclib.interpolations.quad=Квадратична
mclib.interpolations.cubic=Кубічна
mclib.interpolations.hermite=Сплайнова
mclib.interpolations.exp=Експоненційна
mclib.interpolations.bezier=Безьє
mclib.interpolations.back=Зворотня
mclib.interpolations.elastic=Гнучка
mclib.interpolations.bounce=Стрибуча
mclib.interpolations.sine=Синусоїдна
mclib.interpolations.quart=Квартова
mclib.interpolations.quint=Квінтова
mclib.interpolations.circle=Кругова

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=Ця інтерполяція відбувається зі сталою швидкістю від A до Б. Корисно для плавних обертань та повільного руху.
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=Найбільш корисна для анімації поз, що мають навіть більш ліниву траекторію рухів, аніж експоненційна чи кубічна In/out.
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=Найбільш корисна для анімації поз, які мають навіть більш ліниву траекторію рухів, ніж експоненційна In/out.
mclib.interpolations.tooltips.exp_in=Корисна для камер у поєднанні з Експоненційною Out - так ви можете створити стрибкоподібні переходи між двома ракурсами камери.
mclib.interpolations.tooltips.exp_out=Корисна для швидкого руху.
mclib.interpolations.tooltips.exp_inout=Найбільш корисна для анімації поз чи акцентування камери.

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=Може використовуватися для похитування та анімації природних рухів у позах.
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=Корисна для стрибкоподібних мультяшних рухів.
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=Корисна для створення анімації, коли щось падає на землю і підстрибує кілька разів.
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=Ця інтерполяція не інтерполює, а зберігає початкове значення до кінця. Є корисною для створення різких стрибків у анімації за допомогою декількох ключкадрами.
mclib.interpolations.tooltips.hermite=Ця інтерполяція може згладити анімацію між кількома ключкадрами. Переконайтеся, що відстань між ключкадрами однакова, оскільки при зміні відстані згладжування порушується.
mclib.interpolations.tooltips.bezier=Ця інтерполяція дозволяє налаштувати криву за допомогою контрольних точок, що також дозволяє імітувати більшість інших інтерполяцій. Є корисною для створення більш плавного переходу між кількома ключкадрами.

mclib.easing.in=Ease in
mclib.easing.out=Ease out
mclib.easing.inout=Ease in/out

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=Команда McLib, що надає можливість редагування конфігурації на стороні сервера.
mclib.commands.mclib.config.help=Підкоманда конфігу McLib, що надає можливість керувати налаштуваннями модів McHorse.
mclib.commands.mclib.config.print=§fЦя команда друкує поточне значення заданого налаштування моду з ID §7<mod.category.option>§f.
mclib.commands.mclib.config.set=§fЦя команда задає поточне значення заданого налаштування моду з ID §7<mod.category.option>§f до значення §7<value...>§f.
mclib.commands.cheats=Команда-чит, що надає можливість перемикати дозвіл на використання чит-команд у сві самітної гри.\n\nМоже бути використана задля вимкнення змоги викорисання читів у творчому світі, попри змогу використання команд у разі, якщо ви, скажімо, публікуєте пригодницьку мапу, або ж хочете вмикнути змогу використання команда у завантаженому світі, де чит-команди не дозволені, т.я. вам необхідно використання команд для відео.

mclib.error.config.invalid_id=§fЗаданий ідентифікатор моду %s§f є некоректним!
mclib.error.config.invalid_format=§fЗадане значення %s§f для ідентифікатору налаштування моду %s§f неможливо зчитати!
mclib.info.config.set=§fНове значення заданого налаштування моду %s§f є: %s§f
mclib.info.config.print=§fЗначення ідентифікатору налаштування моду %s§f є: %s§f
mclib.info.config.client_side=§fЗадане налаштування моду %s§f працює виключно на стороні клієнту...

# Keystroke modes
mclib.keystrokes_position.auto=Авто
mclib.keystrokes_position.bottom_left=Знизу ліворуч
mclib.keystrokes_position.bottom_right=Знизу праворуч
mclib.keystrokes_position.top_right=Зверху праворуч
mclib.keystrokes_position.top_left=Знизу ліворуч

# Tootlip styles
mclib.tooltip_style.light=Світлі
mclib.tooltip_style.dark=Темні


==================================================

--- Файл №331 ---
Путь: main\resources\assets\mclib\lang\zh_CN.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=仪表盘

mclib.gui.ok=确定
mclib.gui.cancel=取消
mclib.gui.none=（无）
mclib.gui.multi_skin=多重皮肤
mclib.gui.no_data=无可用的数据...
mclib.gui.open_folder=打开文件夹
mclib.gui.pick_texture=选择材质

mclib.gui.context.multi_skin.copy=拷贝材质路径
mclib.gui.context.multi_skin.paste=粘贴材质路径

# Don't remove space on the end!
mclib.gui.dashboard.category=仪表盘
mclib.gui.dashboard.open_panel=打开 

mclib.gui.graph.tooltip=图形计算器
mclib.gui.graph.help=点击该按钮会进入一个网页，其中详细列出了该图形计算器的功能。\n\n此处使用的表达式，也可以在 Aperture 的“数学”调整器以及 Commander 的数学表达式计算命令中使用。\n\n该图形计算器只提供一个变量 "x"，它是你可以插入 y=x（又称 f(x)）图形函数的水平坐标。
mclib.gui.config.title=选项
mclib.gui.config.tooltip=模组选项
mclib.gui.config.reload_tooltip=从文件重载选项...
mclib.gui.config.request_tooltip=在服务端配置和客户端配置之间进行切换...
mclib.gui.keys.list=快捷键列表

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.orientation.global=全局
mclib.gui.transforms.orientation.local=相对
mclib.gui.transforms.orientation.tooltip=切换平移变换的坐标系。
mclib.gui.transforms.translate=平移
mclib.gui.transforms.scale=缩放
mclib.gui.transforms.rotate=旋转
mclib.gui.transforms.context.copy=拷贝变换信息
mclib.gui.transforms.context.paste=粘贴变换信息
mclib.gui.transforms.context.paste_translation=仅粘贴平移
mclib.gui.transforms.context.paste_scale=仅粘贴缩放
mclib.gui.transforms.context.paste_rotation=仅粘贴旋转
mclib.gui.transforms.context.reset=重置变换信息
mclib.gui.transforms.delta.origin=围绕原点

mclib.gui.keyframes.tick=Tick
mclib.gui.keyframes.value=值
mclib.gui.keyframes.context.maximize=框显所有关键帧
mclib.gui.keyframes.context.select_all=全选
mclib.gui.keyframes.context.remove=移除关键帧
mclib.gui.keyframes.context.copy=拷贝关键帧
mclib.gui.keyframes.context.paste=粘贴关键帧
mclib.gui.keyframes.context.to_left=选中左侧手柄
mclib.gui.keyframes.context.to_main=选中主手柄
mclib.gui.keyframes.context.to_right=选中右侧手柄

mclib.gui.multiskin.color=通过该颜色控件，你可以调整颜色（RGB）通道。最适用于白色/灰度图像。
mclib.gui.multiskin.scale=缩放
mclib.gui.multiskin.scale_to_largest=缩放至最大
mclib.gui.multiskin.shift=偏移
mclib.gui.multiskin.pixelate=像素化
mclib.gui.multiskin.erase=擦除
mclib.gui.multiskin.erase_tooltip=该功可以使用当前皮肤作为差值蒙板，也就是说，任何不透明的像素都会擦去其下层所有皮肤的像素。
mclib.gui.multiskin.custom_size=自定义尺寸
mclib.gui.multiskin.auto_size=自适应尺寸
mclib.gui.multiskin.auto_size_tooltip=启用后，会使用材质的原始尺寸，否则便会应用下面给出的自定义尺寸。
mclib.gui.multiskin.size_w=自定义宽度
mclib.gui.multiskin.size_h=自定义高度

mclib.gui.color.favorite=收藏的颜色
mclib.gui.color.recent=最近的颜色

mclib.gui.color.context.favorites.add=添加至收藏
mclib.gui.color.context.favorites.remove=移出收藏

mclib.gui.item_slot.context.copy=拷贝物品 NBT 数据
mclib.gui.item_slot.context.paste=粘贴物品 NBT 数据
mclib.gui.item_slot.context.drop=获取该物品到背包
mclib.gui.item_slot.context.clear=清除物品

# Config
mclib.config.title=McLib

mclib.config.appearance.title=外观
mclib.config.appearance.tooltip=有关 GUI 和框架外观的常规选项

mclib.config.appearance.primary_color=主色调
mclib.config.comments.appearance.primary_color=GUI 系统中最常见的颜色
mclib.config.appearance.enable_borders=按钮边框
mclib.config.comments.appearance.enable_borders=按钮与其他控件是否显示边框？
mclib.config.appearance.enable_checkbox_rendering=复选框
mclib.config.comments.appearance.enable_checkbox_rendering=启用复选框呈现而不是开关元件（凭个人喜好）
mclib.config.appearance.enable_trackpad_increments=触控板增量
mclib.config.comments.appearance.enable_trackpad_increments=启用触控板控件上的 < 和 > 按钮（用于触控板值的递增）
mclib.config.appearance.enable_grid_rendering=模型网络
mclib.config.comments.appearance.enable_grid_rendering=启用网络地面呈现而非草方块地面
mclib.config.appearance.user_interface_scale=GUI 尺寸
mclib.config.comments.appearance.user_interface_scale=McHorse 的模组的 GUI 尺寸，代替视频设置中的界面尺寸。若设为 0，则会使用 Minecraft 的界面尺寸设置
mclib.config.appearance.render_translation_text_colours=显示平移提示文本颜色
mclib.config.comments.appearance.render_translation_text_colours=为平移参数栏显示各个坐标轴的颜色，例如 X 是红色，Y 是绿色，Z 是蓝色。
mclib.config.appearance.tooltip_style=工具提示样式
mclib.config.comments.appearance.tooltip_style=该选项用于更改 GUI 工具提示的样式
mclib.config.appearance.trackpad_decimal_places=滑动参数框小数点精度
mclib.config.comments.appearance.trackpad_decimal_places=设置小数点多少位后不被四舍五入

mclib.config.tutorials.title=教学选项
mclib.config.tutorials.tooltip=该分类提供了利于制作教程视频的选项

mclib.config.tutorials.enable_mouse_rendering=鼠标光标
mclib.config.comments.tutorials.enable_mouse_rendering=启用鼠标光标的显示。在使用 Minema mod 录制教程并且没有光标显示时十分有用
mclib.config.tutorials.enable_mouse_buttons_rendering=鼠标按键
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=启用鼠标按键和鼠标滚轮滚动的显示。在使用 Minema mod 录制教程，并且鼠标按键或滚轮滚动不可见时非常有用
mclib.config.tutorials.enable_keystrokes_rendering=按键显示
mclib.config.comments.tutorials.enable_keystrokes_rendering=启用按键显示。在需要展示按了哪些按键的教程中十分有用
mclib.config.tutorials.keystroke_offset=按键显示偏移
mclib.config.comments.tutorials.keystroke_offset=允许设置按键显示行从边角处起的偏移像素数量
mclib.config.tutorials.keystroke_position=按键显示位置
mclib.config.comments.tutorials.keystroke_position=允许更改按键显示行处于哪个角落

mclib.config.background.title=背景
mclib.config.background.tooltip=背景选项，例如使用的颜色和材质

mclib.config.background.image=图片
mclib.config.comments.background.image=应用于所有菜单的背景图片
mclib.config.background.color=颜色
mclib.config.comments.background.color=应用于所有菜单的背景颜色。若指定了图片，则会作为背景图片的色调

mclib.config.scrollbars.title=滚动条
mclib.config.scrollbars.tooltip=滚动条样式选项

mclib.config.scrollbars.flat=扁平滚动条
mclib.config.comments.scrollbars.flat=回退至扁平颜色外观的滚动条
mclib.config.scrollbars.shadow=阴影颜色
mclib.config.comments.scrollbars.shadow=用于设置滚动条阴影的颜色
mclib.config.scrollbars.width=厚度
mclib.config.comments.scrollbars.width=用于设置厚度（滚动条宽度）

mclib.config.multiskin.title=多重皮肤
mclib.config.multiskin.tooltip=多重皮肤功能相关选项

mclib.config.multiskin.multithreaded=多线程处理
mclib.config.comments.multiskin.multithreaded=允许您启用多重皮肤的多线程处理，可以适当解决卡顿问题，但需要更长的处理时间
mclib.config.multiskin.clear=重载 RP 时清空
mclib.config.comments.multiskin.clear=用于开关在重载资源包时删除所有多重皮肤的材质

mclib.config.vanilla.title=原版属性微调
mclib.config.vanilla.tooltip=关于对 Minecraft 的代码进行微调的选项

mclib.config.vanilla.max_packet_size=最大数据包大小
mclib.config.comments.vanilla.max_packet_size=用于配置模型数据包的最大大小（以字节为单位）。警告：请勿在公开服务器中修改该属性，因为这会让服务器更容易遭到 DDoS。该选项是为单人模式设计的！

# OP access
op_access.config.title=OP 访问权限

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=McLib OP 访问权限选项

op_access.config.mclib.drop_items=获取物品到背包
op_access.config.comments.mclib.drop_items=非 OP 玩家是否可以使用物品槽控件中的“获取该物品到背包”选项？

# Keybinds config
keybinds.config.title=快捷键配置

keybinds.config.unknown_mod=未知 Mod
keybinds.config.no_category=未分类快捷键

# Interpolations
mclib.interpolations.linear=线性
mclib.interpolations.quad_in=二次方缓入
mclib.interpolations.quad_out=二次方缓出
mclib.interpolations.quad_inout=二次方缓入/缓出
mclib.interpolations.cubic_in=三次曲线缓入
mclib.interpolations.cubic_out=三次曲线缓出
mclib.interpolations.cubic_inout=三次曲线缓入/缓出
mclib.interpolations.exp_in=指数缓入
mclib.interpolations.exp_out=指数缓出
mclib.interpolations.exp_inout=指数缓入/缓出

mclib.interpolations.back_in=回弹缓入
mclib.interpolations.back_out=回弹缓出
mclib.interpolations.back_inout=回弹缓入/缓出
mclib.interpolations.elastic_in=弹性缓入
mclib.interpolations.elastic_out=弹性缓出
mclib.interpolations.elastic_inout=弹性缓入/缓出
mclib.interpolations.bounce_in=弹跳缓入
mclib.interpolations.bounce_out=弹跳缓出
mclib.interpolations.bounce_inout=弹跳缓入/缓出

mclib.interpolations.sine_in=正弦缓入
mclib.interpolations.sine_out=正弦缓出
mclib.interpolations.sine_inout=正弦缓入/缓出
mclib.interpolations.quart_in=四次方缓入
mclib.interpolations.quart_out=四次方缓出
mclib.interpolations.quart_inout=四次方缓入/缓出
mclib.interpolations.quint_in=五次方缓入
mclib.interpolations.quint_out=五次方缓出
mclib.interpolations.quint_inout=五次方缓入/缓出
mclib.interpolations.circle_in=圆弧缓入
mclib.interpolations.circle_out=圆弧缓出
mclib.interpolations.circle_inout=圆弧缓入/缓出

mclib.interpolations.const=连续的
mclib.interpolations.quad=二次方
mclib.interpolations.cubic=三次曲线
mclib.interpolations.hermite=艾米插值
mclib.interpolations.exp=指数
mclib.interpolations.bezier=贝塞尔曲线
mclib.interpolations.back=回弹
mclib.interpolations.elastic=弹性
mclib.interpolations.bounce=弹跳
mclib.interpolations.sine=正弦
mclib.interpolations.quart=四次方
mclib.interpolations.quint=五次方
mclib.interpolations.circle=圆弧

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=该插值会以恒定的速度从 A 过渡到 B。它适用于无缝旋转和缓慢移动的使用场景。
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=该插值适用于姿势动画，用于表现比指数或三次曲线缓入/缓出的程度更平缓的运动。
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=该插值适用于姿势动画，用于表现比指数缓入/缓出的程度更平缓的运动。
mclib.interpolations.tooltips.exp_in=适合与“指数缓出”类型的相机相结合，因为你可以在两个相机镜头之间实现跳跃的、锐增/锐减的过渡。
mclib.interpolations.tooltips.exp_out=适用于创建动作迅速的运动。
mclib.interpolations.tooltips.exp_inout=适用于姿势动画或强调类型的镜头运动。

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=适用于摇摆和比较自然的动作。
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=适用于跳跃性的卡通风格的动作。
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=适用于创建一个东西掉在地上并弹跳几下的动画。
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=该插值并不算是真正意义上的插值，而是将初始值保持到最后。适用于通过多个关键帧来创建变化强烈的的阶梯式运动曲线。
mclib.interpolations.tooltips.hermite=该插值可以使动画在多个关键帧之间平滑地进行过渡。请确保关键帧之间拥有相同的距离，因为这一平滑的特性会在不同距离的情况下被打破。
mclib.interpolations.tooltips.bezier=该插值能够适用控制点来调整曲线，进而能通过它模仿出其他大多数插值的的效果。适用于在多个关键帧之间创建更平滑的过渡。

mclib.easing.in=缓入
mclib.easing.out=缓出
mclib.easing.inout=缓入/缓出

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=McLib 命令，提供了在服务器端编辑配置的功能。
mclib.commands.mclib.config.help=McLib 子命令，用于管理 McHorse 系列模组的选项。
mclib.commands.mclib.config.print=§f该命令会输出当前给定模组选项（选项 ID 为 §7<mod.category.option>§f）的值。
mclib.commands.mclib.config.set=§f该命令用于将模组选项 ID 为 §7<mod.category.option>§f 的值设置为 §7<值...>§f。
mclib.commands.cheats=作弊命令可以在单人游戏世界中开关作弊命令。\n\n该命令既可用于在一个开启了命令的创造模式存档中禁用作弊，例如你打算发布一张冒险地图；也可用于在一个禁用了作弊命令的存档中启用命令，因为你需要在制作视频时使用命令。

mclib.error.config.invalid_id=§f给定的模组选项标识符 %s§f 不存在！
mclib.error.config.invalid_format=§f给定的值 %s§f 对于模组选项标识符 %s§f 而言，无法进行解析！
mclib.info.config.set=§f模组选项 %s§f 的值已更新为： %s§f
mclib.info.config.print=§f模组选项 %s§f 的值为： %s§f
mclib.info.config.client_side=§f给定的模组选项 %s§f 仅适用于本地客户端...

# Keystroke modes
mclib.keystrokes_position.auto=自动
mclib.keystrokes_position.bottom_left=左下
mclib.keystrokes_position.bottom_right=右下
mclib.keystrokes_position.top_right=右上
mclib.keystrokes_position.top_left=左上

# Tootlip styles
mclib.tooltip_style.light=浅色
mclib.tooltip_style.dark=深色

==================================================

--- Файл №332 ---
Путь: main\resources\assets\mclib\lang\zh_TW.lang
--------------------
#PARSE_ESCAPES

key.mclib.category=McLib
key.mclib.dashboard=儀表盤

mclib.gui.ok=確定
mclib.gui.cancel=取消
mclib.gui.none=（無）
mclib.gui.multi_skin=多重皮膚
mclib.gui.no_data=無可用的數據...
mclib.gui.open_folder=打開文件夾
mclib.gui.pick_texture=選擇材質

mclib.gui.context.multi_skin.copy=拷貝材質路徑
mclib.gui.context.multi_skin.paste=粘貼材質路徑

# Don't remove space on the end!
mclib.gui.dashboard.category=儀表盤
mclib.gui.dashboard.open_panel=打開 

mclib.gui.graph.tooltip=圖形計算器
mclib.gui.graph.help=點擊該按鈕會進入一個網頁，其中詳細列出了該圖形計算器的功能。\n\n此處使用的表達式，也可以在 Aperture 的“數學”調整器以及 Commander 的數學表達式計算命令中使用。\n\n該圖形計算器只提供一個變量 "x"，它是你可以插入 y=x（又稱 f(x)）圖形函數的水平座標。
mclib.gui.config.title=選項
mclib.gui.config.tooltip=模組選項
mclib.gui.config.reload_tooltip=從文件重載選項...
mclib.gui.config.request_tooltip=在服務端配置和客戶端配置之間進行切換...
mclib.gui.keys.list=快捷鍵列表

mclib.gui.transforms.x=X
mclib.gui.transforms.y=Y
mclib.gui.transforms.z=Z
mclib.gui.transforms.orientation.global=全局
mclib.gui.transforms.orientation.local=相對
mclib.gui.transforms.orientation.tooltip=切換平移變換的座標系。
mclib.gui.transforms.translate=平移
mclib.gui.transforms.scale=縮放
mclib.gui.transforms.rotate=旋轉
mclib.gui.transforms.context.copy=拷貝變換信息
mclib.gui.transforms.context.paste=粘貼變換信息
mclib.gui.transforms.context.paste_translation=僅粘貼平移
mclib.gui.transforms.context.paste_scale=僅粘貼縮放
mclib.gui.transforms.context.paste_rotation=僅粘貼旋轉
mclib.gui.transforms.context.reset=重置變換信息
mclib.gui.transforms.delta.origin=圍繞原點

mclib.gui.keyframes.tick=Tick
mclib.gui.keyframes.value=值
mclib.gui.keyframes.context.maximize=框顯所有關鍵幀
mclib.gui.keyframes.context.select_all=全選
mclib.gui.keyframes.context.remove=移除關鍵幀
mclib.gui.keyframes.context.copy=拷貝關鍵幀
mclib.gui.keyframes.context.paste=粘貼關鍵幀
mclib.gui.keyframes.context.to_left=選中左側手柄
mclib.gui.keyframes.context.to_main=選中主手柄
mclib.gui.keyframes.context.to_right=選中右側手柄

mclib.gui.multiskin.color=通過該顏色控件，你可以調整顏色（RGB）通道。最適用於白色/灰度圖像。
mclib.gui.multiskin.scale=縮放
mclib.gui.multiskin.scale_to_largest=縮放至最大
mclib.gui.multiskin.shift=偏移
mclib.gui.multiskin.pixelate=像素化
mclib.gui.multiskin.erase=擦除
mclib.gui.multiskin.erase_tooltip=該功可以使用當前皮膚作為差值蒙板，也就是說，任何不透明的像素都會擦去其下層所有皮膚的像素。
mclib.gui.multiskin.custom_size=自定義尺寸
mclib.gui.multiskin.auto_size=自適應尺寸
mclib.gui.multiskin.auto_size_tooltip=啟用後，會使用材質的原始尺寸，否則便會應用下面給出的自定義尺寸。
mclib.gui.multiskin.size_w=自定義寬度
mclib.gui.multiskin.size_h=自定義高度

mclib.gui.color.favorite=收藏的顏色
mclib.gui.color.recent=最近的顏色

mclib.gui.color.context.favorites.add=添加至收藏
mclib.gui.color.context.favorites.remove=移出收藏

mclib.gui.item_slot.context.copy=拷貝物品 NBT 數據
mclib.gui.item_slot.context.paste=粘貼物品 NBT 數據
mclib.gui.item_slot.context.drop=獲取該物品到揹包
mclib.gui.item_slot.context.clear=清除物品

# Config
mclib.config.title=McLib

mclib.config.appearance.title=外觀
mclib.config.appearance.tooltip=有關 GUI 和框架外觀的常規選項

mclib.config.appearance.primary_color=主色調
mclib.config.comments.appearance.primary_color=GUI 系統中最常見的顏色
mclib.config.appearance.enable_borders=按鈕邊框
mclib.config.comments.appearance.enable_borders=按鈕與其他控件是否顯示邊框？
mclib.config.appearance.enable_checkbox_rendering=複選框
mclib.config.comments.appearance.enable_checkbox_rendering=啟用複選框呈現而不是開關元件（憑個人喜好）
mclib.config.appearance.enable_trackpad_increments=觸控板增量
mclib.config.comments.appearance.enable_trackpad_increments=啟用觸控板控件上的 < 和 > 按鈕（用於觸控板值的遞增）
mclib.config.appearance.enable_grid_rendering=模型網絡
mclib.config.comments.appearance.enable_grid_rendering=啟用網絡地面呈現而非草方塊地面
mclib.config.appearance.user_interface_scale=GUI 尺寸
mclib.config.comments.appearance.user_interface_scale=McHorse 的模組的 GUI 尺寸，代替視頻設置中的界面尺寸。若設為 0，則會使用 Minecraft 的界面尺寸設置
mclib.config.appearance.render_translation_text_colours=顯示平移提示文本顏色
mclib.config.comments.appearance.render_translation_text_colours=為平移參數欄顯示各個座標軸的顏色，例如 X 是紅色，Y 是綠色，Z 是藍色。
mclib.config.appearance.tooltip_style=工具提示樣式
mclib.config.comments.appearance.tooltip_style=該選項用於更改 GUI 工具提示的樣式
mclib.config.appearance.trackpad_decimal_places=滑動參數框小數點精度
mclib.config.comments.appearance.trackpad_decimal_places=設置小數點多少位後不被四捨五入

mclib.config.tutorials.title=教學選項
mclib.config.tutorials.tooltip=該分類提供了利於製作教程視頻的選項

mclib.config.tutorials.enable_mouse_rendering=鼠標光標
mclib.config.comments.tutorials.enable_mouse_rendering=啟用鼠標光標的顯示。在使用 Minema mod 錄製教程並且沒有光標顯示時十分有用
mclib.config.tutorials.enable_mouse_buttons_rendering=鼠標按鍵
mclib.config.comments.tutorials.enable_mouse_buttons_rendering=啟用鼠標按鍵和鼠標滾輪滾動的顯示。在使用 Minema mod 錄製教程，並且鼠標按鍵或滾輪滾動不可見時非常有用
mclib.config.tutorials.enable_keystrokes_rendering=按鍵顯示
mclib.config.comments.tutorials.enable_keystrokes_rendering=啟用按鍵顯示。在需要展示按了哪些按鍵的教程中十分有用
mclib.config.tutorials.keystroke_offset=按鍵顯示偏移
mclib.config.comments.tutorials.keystroke_offset=允許設置按鍵顯示行從邊角處起的偏移像素數量
mclib.config.tutorials.keystroke_position=按鍵顯示位置
mclib.config.comments.tutorials.keystroke_position=允許更改按鍵顯示行處於哪個角落

mclib.config.background.title=背景
mclib.config.background.tooltip=背景選項，例如使用的顏色和材質

mclib.config.background.image=圖片
mclib.config.comments.background.image=應用於所有菜單的背景圖片
mclib.config.background.color=顏色
mclib.config.comments.background.color=應用於所有菜單的背景顏色。若指定了圖片，則會作為背景圖片的色調

mclib.config.scrollbars.title=滾動條
mclib.config.scrollbars.tooltip=滾動條樣式選項

mclib.config.scrollbars.flat=扁平滾動條
mclib.config.comments.scrollbars.flat=回退至扁平顏色外觀的滾動條
mclib.config.scrollbars.shadow=陰影顏色
mclib.config.comments.scrollbars.shadow=用於設置滾動條陰影的顏色
mclib.config.scrollbars.width=厚度
mclib.config.comments.scrollbars.width=用於設置厚度（滾動條寬度）

mclib.config.multiskin.title=多重皮膚
mclib.config.multiskin.tooltip=多重皮膚功能相關選項

mclib.config.multiskin.multithreaded=多線程處理
mclib.config.comments.multiskin.multithreaded=允許您啟用多重皮膚的多線程處理，可以適當解決卡頓問題，但需要更長的處理時間
mclib.config.multiskin.clear=重載 RP 時清空
mclib.config.comments.multiskin.clear=用於開關在重載資源包時刪除所有多重皮膚的材質

mclib.config.vanilla.title=原版屬性微調
mclib.config.vanilla.tooltip=關於對 Minecraft 的代碼進行微調的選項

mclib.config.vanilla.max_packet_size=最大數據包大小
mclib.config.comments.vanilla.max_packet_size=用於配置模型數據包的最大大小（以字節為單位）。警告：請勿在公開服務器中修改該屬性，因為這會讓服務器更容易遭到 DDoS。該選項是為單人模式設計的！

# OP access
op_access.config.title=OP 訪問權限

op_access.config.mclib.title=McLib
op_access.config.mclib.tooltip=McLib OP 訪問權限選項

op_access.config.mclib.drop_items=獲取物品到揹包
op_access.config.comments.mclib.drop_items=非 OP 玩家是否可以使用物品槽控件中的“獲取該物品到揹包”選項？

# Keybinds config
keybinds.config.title=快捷鍵配置

keybinds.config.unknown_mod=未知 Mod
keybinds.config.no_category=未分類快捷鍵

# Interpolations
mclib.interpolations.linear=線性
mclib.interpolations.quad_in=二次方緩入
mclib.interpolations.quad_out=二次方緩出
mclib.interpolations.quad_inout=二次方緩入/緩出
mclib.interpolations.cubic_in=三次曲線緩入
mclib.interpolations.cubic_out=三次曲線緩出
mclib.interpolations.cubic_inout=三次曲線緩入/緩出
mclib.interpolations.exp_in=指數緩入
mclib.interpolations.exp_out=指數緩出
mclib.interpolations.exp_inout=指數緩入/緩出

mclib.interpolations.back_in=回彈緩入
mclib.interpolations.back_out=回彈緩出
mclib.interpolations.back_inout=回彈緩入/緩出
mclib.interpolations.elastic_in=彈性緩入
mclib.interpolations.elastic_out=彈性緩出
mclib.interpolations.elastic_inout=彈性緩入/緩出
mclib.interpolations.bounce_in=彈跳緩入
mclib.interpolations.bounce_out=彈跳緩出
mclib.interpolations.bounce_inout=彈跳緩入/緩出

mclib.interpolations.sine_in=正弦緩入
mclib.interpolations.sine_out=正弦緩出
mclib.interpolations.sine_inout=正弦緩入/緩出
mclib.interpolations.quart_in=四次方緩入
mclib.interpolations.quart_out=四次方緩出
mclib.interpolations.quart_inout=四次方緩入/緩出
mclib.interpolations.quint_in=五次方緩入
mclib.interpolations.quint_out=五次方緩出
mclib.interpolations.quint_inout=五次方緩入/緩出
mclib.interpolations.circle_in=圓弧緩入
mclib.interpolations.circle_out=圓弧緩出
mclib.interpolations.circle_inout=圓弧緩入/緩出

mclib.interpolations.const=連續的
mclib.interpolations.quad=二次方
mclib.interpolations.cubic=三次曲線
mclib.interpolations.hermite=艾米插值
mclib.interpolations.exp=指數
mclib.interpolations.bezier=貝塞爾曲線
mclib.interpolations.back=回彈
mclib.interpolations.elastic=彈性
mclib.interpolations.bounce=彈跳
mclib.interpolations.sine=正弦
mclib.interpolations.quart=四次方
mclib.interpolations.quint=五次方
mclib.interpolations.circle=圓弧

# Interpolation tooltips
#
# Feel free to add your own tips. If there is no tip, then leave it empty.
# DO NOT REMOVE THESE LINES!

mclib.interpolations.tooltips.linear=該插值會以恆定的速度從 A 過渡到 B。它適用於無縫旋轉和緩慢移動的使用場景。
mclib.interpolations.tooltips.quad_in=
mclib.interpolations.tooltips.quad_out=
mclib.interpolations.tooltips.quad_inout=該插值適用於姿勢動畫，用於表現比指數或三次曲線緩入/緩出的程度更平緩的運動。
mclib.interpolations.tooltips.cubic_in=
mclib.interpolations.tooltips.cubic_out=
mclib.interpolations.tooltips.cubic_inout=該插值適用於姿勢動畫，用於表現比指數緩入/緩出的程度更平緩的運動。
mclib.interpolations.tooltips.exp_in=適合與“指數緩出”類型的相機相結合，因為你可以在兩個相機鏡頭之間實現跳躍的、銳增/銳減的過渡。
mclib.interpolations.tooltips.exp_out=適用於創建動作迅速的運動。
mclib.interpolations.tooltips.exp_inout=適用於姿勢動畫或強調類型的鏡頭運動。

mclib.interpolations.tooltips.back_in=
mclib.interpolations.tooltips.back_out=
mclib.interpolations.tooltips.back_inout=適用於搖擺和比較自然的動作。
mclib.interpolations.tooltips.elastic_in=
mclib.interpolations.tooltips.elastic_out=適用於跳躍性的卡通風格的動作。
mclib.interpolations.tooltips.elastic_inout=
mclib.interpolations.tooltips.bounce_in=
mclib.interpolations.tooltips.bounce_out=適用於創建一個東西掉在地上並彈跳幾下的動畫。
mclib.interpolations.tooltips.bounce_inout=

mclib.interpolations.tooltips.sine_in=
mclib.interpolations.tooltips.sine_out=
mclib.interpolations.tooltips.sine_inout=
mclib.interpolations.tooltips.quart_in=
mclib.interpolations.tooltips.quart_out=
mclib.interpolations.tooltips.quart_inout=
mclib.interpolations.tooltips.quint_in=
mclib.interpolations.tooltips.quint_out=
mclib.interpolations.tooltips.quint_inout=
mclib.interpolations.tooltips.circle_in=
mclib.interpolations.tooltips.circle_out=
mclib.interpolations.tooltips.circle_inout=

mclib.interpolations.tooltips.const=該插值並不算是真正意義上的插值，而是將初始值保持到最後。適用於通過多個關鍵幀來創建變化強烈的的階梯式運動曲線。
mclib.interpolations.tooltips.hermite=該插值可以使動畫在多個關鍵幀之間平滑地進行過渡。請確保關鍵幀之間擁有相同的距離，因為這一平滑的特性會在不同距離的情況下被打破。
mclib.interpolations.tooltips.bezier=該插值能夠適用控制點來調整曲線，進而能通過它模仿出其他大多數插值的的效果。適用於在多個關鍵幀之間創建更平滑的過渡。

mclib.easing.in=緩入
mclib.easing.out=緩出
mclib.easing.inout=緩入/緩出

# Commands
mclib.commands.wrapper=%s
mclib.commands.mclib.help=McLib 命令，提供了在服務器端編輯配置的功能。
mclib.commands.mclib.config.help=McLib 子命令，用於管理 McHorse 系列模組的選項。
mclib.commands.mclib.config.print=§f該命令會輸出當前給定模組選項（選項 ID 為 §7<mod.category.option>§f）的值。
mclib.commands.mclib.config.set=§f該命令用於將模組選項 ID 為 §7<mod.category.option>§f 的值設置為 §7<值...>§f。
mclib.commands.cheats=作弊命令可以在單人遊戲世界中開關作弊命令。\n\n該命令既可用於在一個開啟了命令的創造模式存檔中禁用作弊，例如你打算髮布一張冒險地圖；也可用於在一個禁用了作弊命令的存檔中啟用命令，因為你需要在製作視頻時使用命令。

mclib.error.config.invalid_id=§f給定的模組選項標識符 %s§f 不存在！
mclib.error.config.invalid_format=§f給定的值 %s§f 對於模組選項標識符 %s§f 而言，無法進行解析！
mclib.info.config.set=§f模組選項 %s§f 的值已更新為： %s§f
mclib.info.config.print=§f模組選項 %s§f 的值為： %s§f
mclib.info.config.client_side=§f給定的模組選項 %s§f 僅適用於本地客戶端...

# Keystroke modes
mclib.keystrokes_position.auto=自動
mclib.keystrokes_position.bottom_left=左下
mclib.keystrokes_position.bottom_right=右下
mclib.keystrokes_position.top_right=右上
mclib.keystrokes_position.top_left=左上

# Tootlip styles
mclib.tooltip_style.light=淺色
mclib.tooltip_style.dark=深色

==================================================

--- Файл №333 ---
Путь: main\resources\assets\mclib\shaders\preview.frag
--------------------
#version 120

/**
 * Preview shader
 *
 * This shader is responsible for previewing filters provided by
 * the multi-skin system
 */

uniform sampler2D texture;
uniform sampler2D texture_background;
uniform vec2 size;
/* r = pixelate, b = erase, g = not used, a = not used */
uniform vec4 filters;
uniform vec4 color;

float mod(float a, float b)
{
    return a - b * floor(a / b);
}

void main()
{
    vec2 coord = gl_TexCoord[0].xy * size;

    coord.x = floor(coord.x);
    coord.y = floor(coord.y);

    int pixelate = int(filters.r);
    int erase = int(filters.g);

    if (erase == 1)
    {
        coord.x = mod(coord.x, 16);
        coord.y = mod(coord.y, 16) + 240;
        coord /= vec2(256, 256);

        gl_FragColor = (texture2D(texture, gl_TexCoord[0].xy).a > 0.6 ? 1 : 0) * texture2D(texture_background, coord);
    }
    else
    {
        coord.x -= mod(coord.x, pixelate);
        coord.y -= mod(coord.y, pixelate);
        coord /= size;

        gl_FragColor = texture2D(texture, coord) * color;
    }
}

==================================================

--- Файл №334 ---
Путь: main\resources\assets\mclib\shaders\preview.vert
--------------------
#version 120

varying vec2 pass_coord;

void main()
{
    gl_Position = ftransform();

    gl_TexCoord[0] = gl_MultiTexCoord0;
}

==================================================

--- Файл №335 ---
Путь: main\resources\assets\mclib\textures\pixel.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 1516 байт]

==================================================

--- Файл №336 ---
Путь: main\resources\assets\mclib\textures\gui\icons.png
--------------------
[Это бинарный файл. Отображение содержимого невозможно.]
[Расширение: .png]
[Размер: 22572 байт]

==================================================

